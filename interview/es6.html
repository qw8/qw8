<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>ES6 | 秦伟博客 | 前端、全栈、SEO的知识点、面试题与学习链接的整理</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="JavaScript,ES6">
    <meta name="description" content="ES6（2015）1. 类（class）12345678910class Man &amp;#123;  constructor(name) &amp;#123;    this.name = &apos;小豪&apos;;  &amp;#125;  console() &amp;#123;    console.log(this.name);  &amp;#125;&amp;#125;const man = new Man(&apos;小豪&apos;);man.console()">
<meta name="keywords" content="JavaScript,ES6">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6">
<meta property="og:url" content="https://qw8.github.io/qw8/interview/es6.html">
<meta property="og:site_name" content="秦伟博客">
<meta property="og:description" content="ES6（2015）1. 类（class）12345678910class Man &amp;#123;  constructor(name) &amp;#123;    this.name = &apos;小豪&apos;;  &amp;#125;  console() &amp;#123;    console.log(this.name);  &amp;#125;&amp;#125;const man = new Man(&apos;小豪&apos;);man.console()">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:updated_time" content="2023-04-14T17:01:50.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ES6">
<meta name="twitter:description" content="ES6（2015）1. 类（class）12345678910class Man &amp;#123;  constructor(name) &amp;#123;    this.name = &apos;小豪&apos;;  &amp;#125;  console() &amp;#123;    console.log(this.name);  &amp;#125;&amp;#125;const man = new Man(&apos;小豪&apos;);man.console()">
<meta name="twitter:image" content="https://qw8.github.io/img/loading.gif">
    
        <link rel="alternate" type="application/atom+xml" title="秦伟博客" href="/qw8/atom.xml">
    
    <link rel="shortcut icon" href="/qw8/img/qw.ico">
    <link rel="stylesheet" href="/qw8/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
<div id="loading" class="active"></div>

<aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/qw8/img/brand.jpg)">
      <div class="brand">
        <a href="/qw8/" class="avatar waves-effect waves-circle waves-light">
          <img src="/qw8/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">秦伟</h5>
          <a href="mailto:124729081@qq.com" title="124729081@qq.com" class="mail">124729081@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/qw8/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/qw8/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/qw8/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/qw8/archives"  >
                <i class="icon icon-lg icon-hourglass"></i>
                时光
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://wpa.qq.com/msgrd?v=3&uin=124729081&site=qq&menu=yes" target="_blank" >
                <i class="icon icon-lg icon-qq"></i>
                聊天
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=124729081@qq.com"  >
                <i class="icon icon-lg icon-envelope-o"></i>
                邮箱
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/qw8/user"  >
                <i class="icon icon-lg icon-user"></i>
                简介
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://gitee.com/qw66" target="_blank" >
                <i class="icon icon-lg icon-code"></i>
                Gitee
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/qw8" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

<main id="main">
    <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">ES6</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">ES6</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-08-13T03:42:39.000Z" itemprop="datePublished" class="page-time">
  2020-08-13
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/qw8/categories/前端面试题/">前端面试题</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#ES6（2015）"><span class="post-toc-number">1.</span> <span class="post-toc-text">ES6（2015）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-类（class）"><span class="post-toc-number">1.0.1.</span> <span class="post-toc-text">1. 类（class）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-模块化-ES-Module"><span class="post-toc-number">1.0.2.</span> <span class="post-toc-text">2. 模块化(ES Module)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-箭头（Arrow）函数"><span class="post-toc-number">1.0.3.</span> <span class="post-toc-text">3. 箭头（Arrow）函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-函数参数默认值"><span class="post-toc-number">1.0.4.</span> <span class="post-toc-text">4. 函数参数默认值</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-模板字符串"><span class="post-toc-number">1.0.5.</span> <span class="post-toc-text">5. 模板字符串</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-解构赋值"><span class="post-toc-number">1.0.6.</span> <span class="post-toc-text">6. 解构赋值</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-延展操作符"><span class="post-toc-number">1.0.7.</span> <span class="post-toc-text">7. 延展操作符</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8-对象属性简写"><span class="post-toc-number">1.0.8.</span> <span class="post-toc-text">8. 对象属性简写</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#9-Promise"><span class="post-toc-number">1.0.9.</span> <span class="post-toc-text">9. Promise</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#10-let和const"><span class="post-toc-number">1.0.10.</span> <span class="post-toc-text">10. let和const</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#ES7（2016）"><span class="post-toc-number">2.</span> <span class="post-toc-text">ES7（2016）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-Array-prototype-includes"><span class="post-toc-number">2.0.1.</span> <span class="post-toc-text">1. Array.prototype.includes()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-指数操作符"><span class="post-toc-number">2.0.2.</span> <span class="post-toc-text">2. 指数操作符</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#ES8（2017）"><span class="post-toc-number">3.</span> <span class="post-toc-text">ES8（2017）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-async-await"><span class="post-toc-number">3.0.1.</span> <span class="post-toc-text">1. async/await</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-Object-values"><span class="post-toc-number">3.0.2.</span> <span class="post-toc-text">2. Object.values()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-Object-entries"><span class="post-toc-number">3.0.3.</span> <span class="post-toc-text">3. Object.entries()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-String-padding"><span class="post-toc-number">3.0.4.</span> <span class="post-toc-text">4. String padding</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-函数参数列表结尾允许逗号"><span class="post-toc-number">3.0.5.</span> <span class="post-toc-text">5. 函数参数列表结尾允许逗号</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-Object-getOwnPropertyDescriptors"><span class="post-toc-number">3.0.6.</span> <span class="post-toc-text">6. Object.getOwnPropertyDescriptors()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-SharedArrayBuffer对象"><span class="post-toc-number">3.0.7.</span> <span class="post-toc-text">7. SharedArrayBuffer对象</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8-Atomics对象"><span class="post-toc-number">3.0.8.</span> <span class="post-toc-text">8. Atomics对象</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#ES9（2018）"><span class="post-toc-number">4.</span> <span class="post-toc-text">ES9（2018）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-异步迭代"><span class="post-toc-number">4.0.1.</span> <span class="post-toc-text">1. 异步迭代</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-Promise-finally"><span class="post-toc-number">4.0.2.</span> <span class="post-toc-text">2. Promise.finally()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-Rest-Spread-属性"><span class="post-toc-number">4.0.3.</span> <span class="post-toc-text">3. Rest/Spread 属性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-正则表达式命名捕获组"><span class="post-toc-number">4.0.4.</span> <span class="post-toc-text">4. 正则表达式命名捕获组</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-正则表达式反向断言"><span class="post-toc-number">4.0.5.</span> <span class="post-toc-text">5. 正则表达式反向断言</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-正则表达式dotAll模式"><span class="post-toc-number">4.0.6.</span> <span class="post-toc-text">6. 正则表达式dotAll模式</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#ES10（2019）"><span class="post-toc-number">5.</span> <span class="post-toc-text">ES10（2019）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-Array-flat-和Array-flatMap"><span class="post-toc-number">5.0.1.</span> <span class="post-toc-text">1. Array.flat()和Array.flatMap()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-String-trimStart-和String-trimEnd"><span class="post-toc-number">5.0.2.</span> <span class="post-toc-text">2. String.trimStart()和String.trimEnd()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-String-prototype-matchAll"><span class="post-toc-number">5.0.3.</span> <span class="post-toc-text">3. String.prototype.matchAll</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-Symbol-prototype-description"><span class="post-toc-number">5.0.4.</span> <span class="post-toc-text">4. Symbol.prototype.description</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-Object-fromEntries"><span class="post-toc-number">5.0.5.</span> <span class="post-toc-text">5. Object.fromEntries()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-可选-Catch"><span class="post-toc-number">5.0.6.</span> <span class="post-toc-text">6. 可选 Catch</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#ES11（2020）"><span class="post-toc-number">6.</span> <span class="post-toc-text">ES11（2020）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-Nullish-coalescing-Operator-空值处理"><span class="post-toc-number">6.0.1.</span> <span class="post-toc-text">1. Nullish coalescing Operator(空值处理)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-Optional-chaining（可选链）"><span class="post-toc-number">6.0.2.</span> <span class="post-toc-text">2. Optional chaining（可选链）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-Promise-allSettled"><span class="post-toc-number">6.0.3.</span> <span class="post-toc-text">3. Promise.allSettled</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-import"><span class="post-toc-number">6.0.4.</span> <span class="post-toc-text">4. import()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-新基本数据类型BigInt"><span class="post-toc-number">6.0.5.</span> <span class="post-toc-text">5. 新基本数据类型BigInt</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-globalThis"><span class="post-toc-number">6.0.6.</span> <span class="post-toc-text">6. globalThis</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#ES12（2021）"><span class="post-toc-number">7.</span> <span class="post-toc-text">ES12（2021）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-replaceAll"><span class="post-toc-number">7.0.1.</span> <span class="post-toc-text">1. replaceAll</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-Promise-any"><span class="post-toc-number">7.0.2.</span> <span class="post-toc-text">2. Promise.any</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-WeakRefs"><span class="post-toc-number">7.0.3.</span> <span class="post-toc-text">3. WeakRefs</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-逻辑运算符和赋值表达式"><span class="post-toc-number">7.0.4.</span> <span class="post-toc-text">4. 逻辑运算符和赋值表达式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-数字分隔符"><span class="post-toc-number">7.0.5.</span> <span class="post-toc-text">5. 数字分隔符</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#箭头函数"><span class="post-toc-number">7.0.6.</span> <span class="post-toc-text">箭头函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ES5、ES6和ES2015有什么区别"><span class="post-toc-number">7.0.7.</span> <span class="post-toc-text">ES5、ES6和ES2015有什么区别?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ES6的了解"><span class="post-toc-number">7.0.8.</span> <span class="post-toc-text">ES6的了解</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#谈一谈你了解ECMAScript6的新特性？"><span class="post-toc-number">7.0.9.</span> <span class="post-toc-text">谈一谈你了解ECMAScript6的新特性？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#日常前端代码开发中，有哪些值得用ES6去改进的编程优化或者规范？"><span class="post-toc-number">7.0.10.</span> <span class="post-toc-text">日常前端代码开发中，有哪些值得用ES6去改进的编程优化或者规范？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#var、let、const-的区别"><span class="post-toc-number">7.0.11.</span> <span class="post-toc-text">var、let、const 的区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#let有什么用，有了var为什么还要用let？"><span class="post-toc-number">7.0.12.</span> <span class="post-toc-text">let有什么用，有了var为什么还要用let？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JS-块级作用域、变量提升"><span class="post-toc-number">7.0.13.</span> <span class="post-toc-text">JS 块级作用域、变量提升</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#var-let-在-for-循环中的区别"><span class="post-toc-number">7.0.14.</span> <span class="post-toc-text">var let 在 for 循环中的区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何避免回调函数嵌套？"><span class="post-toc-number">7.0.15.</span> <span class="post-toc-text">如何避免回调函数嵌套？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Promise是什么，有什么作用？"><span class="post-toc-number">7.0.16.</span> <span class="post-toc-text">Promise是什么，有什么作用？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Promise-的构造函数"><span class="post-toc-number">7.0.17.</span> <span class="post-toc-text">Promise 的构造函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#async函数是什么，有什么作用？"><span class="post-toc-number">7.0.18.</span> <span class="post-toc-text">async函数是什么，有什么作用？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#async、await"><span class="post-toc-number">7.0.19.</span> <span class="post-toc-text">async、await</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#箭头函数和普通函数有什么区别"><span class="post-toc-number">7.0.20.</span> <span class="post-toc-text">箭头函数和普通函数有什么区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#举一些ES6对Function函数类型做的常用升级优化"><span class="post-toc-number">7.0.21.</span> <span class="post-toc-text">举一些ES6对Function函数类型做的常用升级优化?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#模板字符串"><span class="post-toc-number">7.0.22.</span> <span class="post-toc-text">模板字符串</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#module、export、import是什么，有什么作用？"><span class="post-toc-number">7.0.23.</span> <span class="post-toc-text">module、export、import是什么，有什么作用？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ES6-如何动态加载-import"><span class="post-toc-number">7.0.24.</span> <span class="post-toc-text">ES6 如何动态加载 import</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是-Babel"><span class="post-toc-number">7.0.25.</span> <span class="post-toc-text">什么是 Babel</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Object-is-与原来的比较操作符“-”、“-”的区别？"><span class="post-toc-number">7.0.26.</span> <span class="post-toc-text">Object.is() 与原来的比较操作符“ ===”、“ ==”的区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#for…in-和for…of有什么区别？"><span class="post-toc-number">7.0.27.</span> <span class="post-toc-text">for…in 和for…of有什么区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Symbol是什么，有什么作用？"><span class="post-toc-number">7.0.28.</span> <span class="post-toc-text">Symbol是什么，有什么作用？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Set是什么，有什么作用？"><span class="post-toc-number">7.0.29.</span> <span class="post-toc-text">Set是什么，有什么作用？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Map是什么，有什么作用？"><span class="post-toc-number">7.0.30.</span> <span class="post-toc-text">Map是什么，有什么作用？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Proxy是什么，有什么作用？"><span class="post-toc-number">7.0.31.</span> <span class="post-toc-text">Proxy是什么，有什么作用？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Reflect是什么，有什么作用？"><span class="post-toc-number">7.0.32.</span> <span class="post-toc-text">Reflect是什么，有什么作用？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#举一些ES6对String字符串类型做的常用升级优化"><span class="post-toc-number">7.0.33.</span> <span class="post-toc-text">举一些ES6对String字符串类型做的常用升级优化?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#举一些ES6对Array数组类型做的常用升级优化"><span class="post-toc-number">7.0.34.</span> <span class="post-toc-text">举一些ES6对Array数组类型做的常用升级优化</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#举一些ES6对Number数字类型做的常用升级优化"><span class="post-toc-number">7.0.35.</span> <span class="post-toc-text">举一些ES6对Number数字类型做的常用升级优化</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#举一些ES6对Object类型做的常用升级优化-重要"><span class="post-toc-number">7.0.36.</span> <span class="post-toc-text">举一些ES6对Object类型做的常用升级优化?(重要)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ES6-都有什么-Iterator-遍历器"><span class="post-toc-number">7.0.37.</span> <span class="post-toc-text">ES6 都有什么 Iterator 遍历器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Iterator是什么，有什么作用？-重要"><span class="post-toc-number">7.0.38.</span> <span class="post-toc-text">Iterator是什么，有什么作用？(重要)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Generator函数是什么，有什么作用？"><span class="post-toc-number">7.0.39.</span> <span class="post-toc-text">Generator函数是什么，有什么作用？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Generator"><span class="post-toc-number">7.0.40.</span> <span class="post-toc-text">Generator</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Class、extends是什么，有什么作用？"><span class="post-toc-number">7.0.41.</span> <span class="post-toc-text">Class、extends是什么，有什么作用？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#AMD，CMD，CommonJs，ES6-Module：解决原始无模块化的痛点"><span class="post-toc-number">7.0.42.</span> <span class="post-toc-text">AMD，CMD，CommonJs，ES6 Module：解决原始无模块化的痛点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Class-的讲解"><span class="post-toc-number">7.0.43.</span> <span class="post-toc-text">Class 的讲解</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ECMAScript6-怎么写class么，为什么会出现class这种东西"><span class="post-toc-number">7.0.44.</span> <span class="post-toc-text">ECMAScript6 怎么写class么，为什么会出现class这种东西?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ES6-中类的定义"><span class="post-toc-number">7.0.45.</span> <span class="post-toc-text">ES6 中类的定义</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#解构赋值及其原理"><span class="post-toc-number">7.0.46.</span> <span class="post-toc-text">解构赋值及其原理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#总结：解构赋值的规则是："><span class="post-toc-number">7.0.47.</span> <span class="post-toc-text">总结：解构赋值的规则是：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Array-from-与-Array-reduce"><span class="post-toc-number">7.0.48.</span> <span class="post-toc-text">Array.from() 与 Array.reduce()</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-interview/ES6"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">ES6</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-08-13 11:42:39" datetime="2020-08-13T03:42:39.000Z"  itemprop="datePublished">2020-08-13</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/qw8/categories/前端面试题/">前端面试题</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="ES6（2015）"><a href="#ES6（2015）" class="headerlink" title="ES6（2015）"></a>ES6（2015）</h1><h3 id="1-类（class）"><a href="#1-类（class）" class="headerlink" title="1. 类（class）"></a>1. 类（class）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Man &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = <span class="string">'小豪'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">console</span></span>() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const man = new Man(<span class="string">'小豪'</span>);</span><br><span class="line">man.console(); // 小豪</span><br></pre></td></tr></table></figure>

<h3 id="2-模块化-ES-Module"><a href="#2-模块化-ES-Module" class="headerlink" title="2. 模块化(ES Module)"></a>2. 模块化(ES Module)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 模块 A 导出一个方法</span><br><span class="line"><span class="built_in">export</span> const sub = (a, b) =&gt; a + b;</span><br><span class="line">// 模块 B 导入使用</span><br><span class="line">import &#123; sub &#125; from <span class="string">'./A'</span>;</span><br><span class="line">console.log(sub(1, 2)); // 3</span><br></pre></td></tr></table></figure>

<h3 id="3-箭头（Arrow）函数"><a href="#3-箭头（Arrow）函数" class="headerlink" title="3. 箭头（Arrow）函数"></a>3. 箭头（Arrow）函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const func = (a, b) =&gt; a + b;</span><br><span class="line">func(1, 2); // 3</span><br></pre></td></tr></table></figure>

<h3 id="4-函数参数默认值"><a href="#4-函数参数默认值" class="headerlink" title="4. 函数参数默认值"></a>4. 函数参数默认值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> foo(age = 25,)&#123; // ...&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-模板字符串"><a href="#5-模板字符串" class="headerlink" title="5. 模板字符串"></a>5. 模板字符串</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const name = <span class="string">'小豪'</span>;</span><br><span class="line">const str = `Your name is <span class="variable">$&#123;name&#125;</span>`;</span><br></pre></td></tr></table></figure>

<h3 id="6-解构赋值"><a href="#6-解构赋值" class="headerlink" title="6. 解构赋值"></a>6. 解构赋值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = 1, b= 2;</span><br><span class="line">[a, b] = [b, a]; // a 2  b 1</span><br></pre></td></tr></table></figure>

<h3 id="7-延展操作符"><a href="#7-延展操作符" class="headerlink" title="7. 延展操作符"></a>7. 延展操作符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = [...<span class="string">'hello world'</span>]; // [<span class="string">"h"</span>, <span class="string">"e"</span>, <span class="string">"l"</span>, <span class="string">"l"</span>, <span class="string">"o"</span>, <span class="string">" "</span>, <span class="string">"w"</span>, <span class="string">"o"</span>, <span class="string">"r"</span>, <span class="string">"l"</span>, <span class="string">"d"</span>]</span><br></pre></td></tr></table></figure>

<h3 id="8-对象属性简写"><a href="#8-对象属性简写" class="headerlink" title="8. 对象属性简写"></a>8. 对象属性简写</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const name=<span class="string">'小豪'</span>,</span><br><span class="line">const obj = &#123; name &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="9-Promise"><a href="#9-Promise" class="headerlink" title="9. Promise"></a>9. Promise</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve().<span class="keyword">then</span>(() =&gt; &#123; console.log(2); &#125;);</span><br><span class="line">console.log(1);</span><br><span class="line">// 先打印 1 ，再打印 2</span><br></pre></td></tr></table></figure>

<h3 id="10-let和const"><a href="#10-let和const" class="headerlink" title="10. let和const"></a>10. let和const</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> name = <span class="string">'小豪'</span>；</span><br><span class="line">const arr = [];</span><br></pre></td></tr></table></figure>

<h1 id="ES7（2016）"><a href="#ES7（2016）" class="headerlink" title="ES7（2016）"></a>ES7（2016）</h1><h3 id="1-Array-prototype-includes"><a href="#1-Array-prototype-includes" class="headerlink" title="1. Array.prototype.includes()"></a>1. Array.prototype.includes()</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1].includes(1); // <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="2-指数操作符"><a href="#2-指数操作符" class="headerlink" title="2. 指数操作符"></a>2. 指数操作符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2**10; // 1024</span><br></pre></td></tr></table></figure>

<h1 id="ES8（2017）"><a href="#ES8（2017）" class="headerlink" title="ES8（2017）"></a>ES8（2017）</h1><h3 id="1-async-await"><a href="#1-async-await" class="headerlink" title="1. async/await"></a>1. async/await</h3><p>异步终极解决方案</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async <span class="function"><span class="title">getData</span></span>()&#123;</span><br><span class="line">    const res = await api.getTableData(); // await 异步任务</span><br><span class="line">    // <span class="keyword">do</span> something    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Object-values"><a href="#2-Object-values" class="headerlink" title="2. Object.values()"></a>2. Object.values()</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.values(&#123;a: 1, b: 2, c: 3&#125;); // [1, 2, 3]</span><br></pre></td></tr></table></figure>

<h3 id="3-Object-entries"><a href="#3-Object-entries" class="headerlink" title="3. Object.entries()"></a>3. Object.entries()</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.entries(&#123;a: 1, b: 2, c: 3&#125;); // [[<span class="string">"a"</span>, 1], [<span class="string">"b"</span>, 2], [<span class="string">"c"</span>, 3]]</span><br></pre></td></tr></table></figure>

<h3 id="4-String-padding"><a href="#4-String-padding" class="headerlink" title="4. String padding"></a>4. String padding</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// padStart</span><br><span class="line"><span class="string">'hello'</span>.padStart(10); // <span class="string">"     hello"</span></span><br><span class="line">// padEnd</span><br><span class="line"><span class="string">'hello'</span>.padEnd(10) <span class="string">"hello     "</span></span><br></pre></td></tr></table></figure>

<h3 id="5-函数参数列表结尾允许逗号"><a href="#5-函数参数列表结尾允许逗号" class="headerlink" title="5. 函数参数列表结尾允许逗号"></a>5. 函数参数列表结尾允许逗号</h3><h3 id="6-Object-getOwnPropertyDescriptors"><a href="#6-Object-getOwnPropertyDescriptors" class="headerlink" title="6. Object.getOwnPropertyDescriptors()"></a>6. Object.getOwnPropertyDescriptors()</h3><blockquote>
<p>获取一个对象的所有自身属性的描述符,如果没有任何自身属性，则返回空对象。</p>
</blockquote>
<h3 id="7-SharedArrayBuffer对象"><a href="#7-SharedArrayBuffer对象" class="headerlink" title="7. SharedArrayBuffer对象"></a>7. SharedArrayBuffer对象</h3><blockquote>
<p>SharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param &#123;*&#125; length 所创建的数组缓冲区的大小，以字节(byte)为单位。  </span><br><span class="line"> * @returns &#123;SharedArrayBuffer&#125; 一个大小指定的新 SharedArrayBuffer 对象。其内容被初始化为 0。</span><br><span class="line"> */</span><br><span class="line">new SharedArrayBuffer(10)</span><br></pre></td></tr></table></figure>

<h3 id="8-Atomics对象"><a href="#8-Atomics对象" class="headerlink" title="8. Atomics对象"></a>8. Atomics对象</h3><blockquote>
<p>Atomics 对象提供了一组静态方法用来对 SharedArrayBuffer 对象进行原子操作。</p>
</blockquote>
<h1 id="ES9（2018）"><a href="#ES9（2018）" class="headerlink" title="ES9（2018）"></a>ES9（2018）</h1><h3 id="1-异步迭代"><a href="#1-异步迭代" class="headerlink" title="1. 异步迭代"></a>1. 异步迭代</h3><p>await可以和for…of循环一起使用，以串行的方式运行异步操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> process(array) &#123;</span><br><span class="line">  <span class="keyword">for</span> await (<span class="built_in">let</span> i of array) &#123;</span><br><span class="line">    // doSomething(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Promise-finally"><a href="#2-Promise-finally" class="headerlink" title="2. Promise.finally()"></a>2. Promise.finally()</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve().<span class="keyword">then</span>().catch(e =&gt; e).finally();</span><br></pre></td></tr></table></figure>

<h3 id="3-Rest-Spread-属性"><a href="#3-Rest-Spread-属性" class="headerlink" title="3. Rest/Spread 属性"></a>3. Rest/Spread 属性</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const values = [1, 2, 3, 5, 6];</span><br><span class="line">console.log( Math.max(...values) ); // 6</span><br></pre></td></tr></table></figure>

<h3 id="4-正则表达式命名捕获组"><a href="#4-正则表达式命名捕获组" class="headerlink" title="4. 正则表达式命名捕获组"></a>4. 正则表达式命名捕获组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const reg = /(?&lt;year&gt;[0-9]&#123;4&#125;)-(?&lt;month&gt;[0-9]&#123;2&#125;)-(?&lt;day&gt;[0-9]&#123;2&#125;)/;</span><br><span class="line">const match = reg.exec(<span class="string">'2021-02-23'</span>);</span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://segmentfault.com/img/remote/1460000039272643" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>



<h3 id="5-正则表达式反向断言"><a href="#5-正则表达式反向断言" class="headerlink" title="5. 正则表达式反向断言"></a>5. 正则表达式反向断言</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(?=p)、(?&lt;=p)  p 前面(位置)、p 后面(位置)</span><br><span class="line">(?!p)、(?&lt;!p&gt;) 除了 p 前面(位置)、除了 p 后面(位置)</span><br><span class="line">(?&lt;=w)</span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://segmentfault.com/img/remote/1460000039272644" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>`(?</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://segmentfault.com/img/remote/1460000039272648" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>



<h3 id="6-正则表达式dotAll模式"><a href="#6-正则表达式dotAll模式" class="headerlink" title="6. 正则表达式dotAll模式"></a>6. 正则表达式dotAll模式</h3><blockquote>
<p>正则表达式中点.匹配除回车外的任何单字符，标记s改变这种行为，允许行终止符的出现</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/hello.world/.<span class="built_in">test</span>(<span class="string">'hello\nworld'</span>);  // <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://segmentfault.com/img/remote/1460000039272649" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>







<h1 id="ES10（2019）"><a href="#ES10（2019）" class="headerlink" title="ES10（2019）"></a>ES10（2019）</h1><h3 id="1-Array-flat-和Array-flatMap"><a href="#1-Array-flat-和Array-flatMap" class="headerlink" title="1. Array.flat()和Array.flatMap()"></a>1. Array.flat()和Array.flatMap()</h3><p>flat()</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, [3, 4]].flat(Infinity); // [1, 2, 3, 4]</span><br></pre></td></tr></table></figure>

<p>flatMap()</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4].flatMap(a =&gt; [a**2]); // [1, 4, 9, 16]</span><br></pre></td></tr></table></figure>

<h3 id="2-String-trimStart-和String-trimEnd"><a href="#2-String-trimStart-和String-trimEnd" class="headerlink" title="2. String.trimStart()和String.trimEnd()"></a>2. String.trimStart()和String.trimEnd()</h3><p>去除字符串首尾空白字符</p>
<h3 id="3-String-prototype-matchAll"><a href="#3-String-prototype-matchAll" class="headerlink" title="3. String.prototype.matchAll"></a>3. String.prototype.matchAll</h3><blockquote>
<p>matchAll（）为所有匹配的匹配对象返回一个迭代器</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const raw_arr = <span class="string">'test1  test2  test3'</span>.matchAll((/t(e)(st(\d?))/g));</span><br><span class="line">const arr = [...raw_arr];</span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://segmentfault.com/img/remote/1460000039272646" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>



<h3 id="4-Symbol-prototype-description"><a href="#4-Symbol-prototype-description" class="headerlink" title="4. Symbol.prototype.description"></a>4. Symbol.prototype.description</h3><blockquote>
<p>只读属性，回 Symbol 对象的可选描述的字符串。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Symbol(<span class="string">'description'</span>).description; // <span class="string">'description'</span></span><br></pre></td></tr></table></figure>

<h3 id="5-Object-fromEntries"><a href="#5-Object-fromEntries" class="headerlink" title="5. Object.fromEntries()"></a>5. Object.fromEntries()</h3><blockquote>
<p>返回一个给定对象自身可枚举属性的键值对数组</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 通过 Object.fromEntries， 可以将 Map 转化为 Object:</span><br><span class="line">const map = new Map([ [<span class="string">'foo'</span>, <span class="string">'bar'</span>], [<span class="string">'baz'</span>, 42] ]);</span><br><span class="line">console.log(Object.fromEntries(map)); // &#123; foo: <span class="string">"bar"</span>, baz: 42 &#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-可选-Catch"><a href="#6-可选-Catch" class="headerlink" title="6. 可选 Catch"></a>6. 可选 Catch</h3><h1 id="ES11（2020）"><a href="#ES11（2020）" class="headerlink" title="ES11（2020）"></a>ES11（2020）</h1><h3 id="1-Nullish-coalescing-Operator-空值处理"><a href="#1-Nullish-coalescing-Operator-空值处理" class="headerlink" title="1. Nullish coalescing Operator(空值处理)"></a>1. Nullish coalescing Operator(空值处理)</h3><p>表达式在 ?? 的左侧 运算符求值为undefined或null，返回其右侧。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> user = &#123;</span><br><span class="line">    u1: 0,</span><br><span class="line">    u2: <span class="literal">false</span>,</span><br><span class="line">    u3: null,</span><br><span class="line">    u4: undefined</span><br><span class="line">    u5: <span class="string">''</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> u2 = user.u2 ?? <span class="string">'用户2'</span>  // <span class="literal">false</span></span><br><span class="line"><span class="built_in">let</span> u3 = user.u3 ?? <span class="string">'用户3'</span>  // 用户3</span><br><span class="line"><span class="built_in">let</span> u4 = user.u4 ?? <span class="string">'用户4'</span>  // 用户4</span><br><span class="line"><span class="built_in">let</span> u5 = user.u5 ?? <span class="string">'用户5'</span>  // <span class="string">''</span></span><br></pre></td></tr></table></figure>

<h3 id="2-Optional-chaining（可选链）"><a href="#2-Optional-chaining（可选链）" class="headerlink" title="2. Optional chaining（可选链）"></a>2. Optional chaining（可选链）</h3><p>?.用户检测不确定的中间节点</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> user = &#123;&#125;</span><br><span class="line"><span class="built_in">let</span> u1 = user.childer.name // TypeError: Cannot <span class="built_in">read</span> property <span class="string">'name'</span> of undefined</span><br><span class="line"><span class="built_in">let</span> u1 = user.childer?.name // undefined</span><br></pre></td></tr></table></figure>

<h3 id="3-Promise-allSettled"><a href="#3-Promise-allSettled" class="headerlink" title="3. Promise.allSettled"></a>3. Promise.allSettled</h3><blockquote>
<p>返回一个在所有给定的promise已被决议或被拒绝后决议的promise，并带有一个对象数组，每个对象表示对应的promise结果</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const promise1 = Promise.resolve(3);</span><br><span class="line">const promise2 = 42;</span><br><span class="line">const promise3 = new Promise((resolve, reject) =&gt; reject(<span class="string">'我是失败的Promise_1'</span>));</span><br><span class="line">const promise4 = new Promise((resolve, reject) =&gt; reject(<span class="string">'我是失败的Promise_2'</span>));</span><br><span class="line">const promiseList = [promise1,promise2,promise3, promise4]</span><br><span class="line">Promise.allSettled(promiseList)</span><br><span class="line">.<span class="keyword">then</span>(values=&gt;&#123;</span><br><span class="line">  console.log(values)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://segmentfault.com/img/remote/1460000039272647" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>



<h3 id="4-import"><a href="#4-import" class="headerlink" title="4. import()"></a>4. import()</h3><p>按需导入</p>
<h3 id="5-新基本数据类型BigInt"><a href="#5-新基本数据类型BigInt" class="headerlink" title="5. 新基本数据类型BigInt"></a>5. 新基本数据类型BigInt</h3><blockquote>
<p>任意精度的整数</p>
</blockquote>
<h3 id="6-globalThis"><a href="#6-globalThis" class="headerlink" title="6. globalThis"></a>6. globalThis</h3><ul>
<li>浏览器：window</li>
<li>worker：self</li>
<li>node：global</li>
</ul>
<h1 id="ES12（2021）"><a href="#ES12（2021）" class="headerlink" title="ES12（2021）"></a>ES12（2021）</h1><h3 id="1-replaceAll"><a href="#1-replaceAll" class="headerlink" title="1. replaceAll"></a>1. replaceAll</h3><blockquote>
<p>返回一个全新的字符串，所有符合匹配规则的字符都将被替换掉</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const str = <span class="string">'hello world'</span>;</span><br><span class="line">str.replaceAll(<span class="string">'l'</span>, <span class="string">''</span>); // <span class="string">"heo word"</span></span><br></pre></td></tr></table></figure>

<h3 id="2-Promise-any"><a href="#2-Promise-any" class="headerlink" title="2. Promise.any"></a>2. Promise.any</h3><blockquote>
<p>Promise.any() 接收一个Promise可迭代对象，只要其中的一个 promise 成功，就返回那个已经成功的 promise 。如果可迭代对象中没有一个 promise 成功（即所有的 promises 都失败/拒绝），就返回一个失败的 promise</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const promise1 = new Promise((resolve, reject) =&gt; reject(<span class="string">'我是失败的Promise_1'</span>));</span><br><span class="line">const promise2 = new Promise((resolve, reject) =&gt; reject(<span class="string">'我是失败的Promise_2'</span>));</span><br><span class="line">const promiseList = [promise1, promise2];</span><br><span class="line">Promise.any(promiseList)</span><br><span class="line">.<span class="keyword">then</span>(values=&gt;&#123;</span><br><span class="line">  console.log(values);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(e=&gt;&#123;</span><br><span class="line">  console.log(e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://segmentfault.com/img/remote/1460000039272645" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>



<h3 id="3-WeakRefs"><a href="#3-WeakRefs" class="headerlink" title="3. WeakRefs"></a>3. WeakRefs</h3><blockquote>
<p>使用WeakRefs的Class类创建对对象的弱引用(对对象的弱引用是指当该对象应该被GC回收时不会阻止GC的回收行为)</p>
</blockquote>
<h3 id="4-逻辑运算符和赋值表达式"><a href="#4-逻辑运算符和赋值表达式" class="headerlink" title="4. 逻辑运算符和赋值表达式"></a>4. 逻辑运算符和赋值表达式</h3><blockquote>
<p>逻辑运算符和赋值表达式，新特性结合了逻辑运算符（&amp;&amp;，||，??）和赋值表达式而JavaScript已存在的 复合赋值运算符有：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a ||= b</span><br><span class="line">//等价于</span><br><span class="line">a = a || (a = b)</span><br><span class="line"></span><br><span class="line">a &amp;&amp;= b</span><br><span class="line">//等价于</span><br><span class="line">a = a &amp;&amp; (a = b)</span><br><span class="line"></span><br><span class="line">a ??= b</span><br><span class="line">//等价于</span><br><span class="line">a = a ?? (a = b)</span><br></pre></td></tr></table></figure>

<h3 id="5-数字分隔符"><a href="#5-数字分隔符" class="headerlink" title="5. 数字分隔符"></a>5. 数字分隔符</h3><blockquote>
<p>数字分隔符，可以在数字之间创建可视化分隔符，通过_下划线来分割数字，使数字更具可读性</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const money = 1_000_000_000;</span><br><span class="line">//等价于</span><br><span class="line">const money = 1000000000;</span><br><span class="line"></span><br><span class="line">1_000_000_000 === 1000000000; // <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://segmentfault.com/img/remote/1460000039272650" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>以上内容来自<a href="https://segmentfault.com/a/1190000039272641" target="_blank" rel="noopener">https://segmentfault.com/a/1190000039272641</a></p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>一、ES6标准新增加了一种新的匿名函数定义方法:箭头函数(Arrow Function)。箭头函数并没有替代以前定义匿名函数的方法，只是新增的一种定义匿名函数的方式！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 正常函数</span><br><span class="line">function name(形参列表)&#123;代码块&#125;</span><br><span class="line"></span><br><span class="line">// ES6之前的匿名函数</span><br><span class="line">function(形参列表)&#123;代码块&#125;</span><br><span class="line">function(x,y)&#123;return x+y&#125;</span><br><span class="line"></span><br><span class="line">// ES6新特性箭头函数</span><br><span class="line">(形参列表)=&gt;&#123;代码块&#125;</span><br><span class="line">x =&gt; x+1 ; // 只有一个形参省略括号</span><br><span class="line">x =&gt; (&#123;foo: x&#125;); // 返回对象字面量表达式</span><br><span class="line">(x,y) =&gt; x+y;</span><br><span class="line">(x,y) =&gt; &#123;return x+y&#125;</span><br></pre></td></tr></table></figure>

<p>二、箭头函数没有定义this绑定。</p>
<p>箭头函数最大的好处是解决了匿名函数的this指向问题，有利于封装回调函数。箭头函数体内的this对象，就是定义该函数时所在的作用域指向的对象，而不是使用时所在的作用域指向的对象。（简述：箭头函数的this是继承所在作用域的this）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  msg: &quot;你好&quot;,</span><br><span class="line">  fn1: function () &#123;</span><br><span class="line">    //  你好</span><br><span class="line">    console.log(this.msg);</span><br><span class="line">    // undefined （this指向该当前对象）</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      console.log(this.msg);</span><br><span class="line">    &#125;, 500);</span><br><span class="line">    // 你好 （this指向定义该箭头函数时所在的作用域）</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(this.msg);</span><br><span class="line">    &#125;, 500);</span><br><span class="line">  &#125;,</span><br><span class="line">  fn2: () =&gt; &#123;</span><br><span class="line">    // undefined （this指向window）</span><br><span class="line">    console.log(this.msg);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>三、箭头函数不绑定Arguments 对象，不能用作构造器，没有prototype属性，yield关键字通常不能在箭头函数中使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var fn1 = function (x) &#123;</span><br><span class="line">  // arguments数组</span><br><span class="line">  console.log(arguments);</span><br><span class="line">&#125;;</span><br><span class="line">var fn2 = (x) =&gt; &#123;</span><br><span class="line">  // ReferenceError</span><br><span class="line">  console.log(arguments);</span><br><span class="line">&#125;;</span><br><span class="line">fn2.prototype; // undefined</span><br><span class="line">let fn3 = new fn2(); // ReferenceError</span><br></pre></td></tr></table></figure>

<p>四、其他</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// 三元运算</span><br><span class="line">var simple = a =&gt; a &gt; 10 ? 15 : a;</span><br><span class="line">simple(18); // 15</span><br><span class="line">simple(8); // 8</span><br><span class="line"></span><br><span class="line">// 递归</span><br><span class="line">var mult = (x) =&gt; ( x==0 ?  1 : x*mult(x-1) );</span><br><span class="line">mult(5); // 120</span><br><span class="line"></span><br><span class="line">// 标准的闭包函数</span><br><span class="line">function fn1() &#123;</span><br><span class="line">  var i = 0;</span><br><span class="line">  return function fn2() &#123; return ++i; &#125;;</span><br><span class="line">&#125;</span><br><span class="line">fn1()(); // 1</span><br><span class="line">var v = fn1();</span><br><span class="line">v(); //1 </span><br><span class="line">v(); //2</span><br><span class="line"></span><br><span class="line">//箭头函数体的闭包（ i=0 是默认参数）</span><br><span class="line">var Add = (i = 0) =&gt; &#123;</span><br><span class="line">  return () =&gt; ++i;</span><br><span class="line">&#125;;</span><br><span class="line">//因为仅有一个返回，return 及括号（）也可以省略</span><br><span class="line">var Add = (i = 0) =&gt; () =&gt; ++i;</span><br><span class="line"></span><br><span class="line">var q = Add ();</span><br><span class="line">q(); //1 </span><br><span class="line">q(); //2</span><br><span class="line"></span><br><span class="line">// 箭头函数内定义的变量及其作用域</span><br><span class="line"></span><br><span class="line">// 常规写法 函数体内var let定义的变量是局部变量</span><br><span class="line">var whatTime = () =&gt; &#123;</span><br><span class="line">  let now = new Date();</span><br><span class="line">  // var now = new Date();</span><br><span class="line">  return now.getHours() &gt; 17 ? &quot;晚上好&quot; : &quot;日安&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">whatTime(); // &quot;晚上好&quot;</span><br><span class="line">console.log(now); // ReferenceError: now is not defined</span><br><span class="line"></span><br><span class="line">// 参数括号内定义的变量是局部变量（默认参数）</span><br><span class="line">var whatTime = (now = new Date()) =&gt; (now.getHours() &gt; 17 ? &quot;晚上好&quot; : &quot;日安&quot;);</span><br><span class="line">whatTime(); // &quot;晚上好&quot;</span><br><span class="line">console.log(now); // ReferenceError: now is not defined</span><br><span class="line"></span><br><span class="line">// 对比：函数体内&#123;&#125;不使用var定义的变量是全局变量</span><br><span class="line">var whatTime = () =&gt; &#123;</span><br><span class="line">  now = new Date();</span><br><span class="line">  return now.getHours() &gt; 17 ? &quot;晚上好&quot; : &quot;日安&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">whatTime(); // &quot;晚上好&quot;</span><br><span class="line">console.log(now); // Thu Oct 14 2021 18:21:21 GMT+0800 (中国标准时间)</span><br></pre></td></tr></table></figure>

<p>原文链接：<a href="https://blog.csdn.net/lusy258/article/details/120767707" target="_blank" rel="noopener">https://blog.csdn.net/lusy258/article/details/120767707</a></p>
<h3 id="ES5、ES6和ES2015有什么区别"><a href="#ES5、ES6和ES2015有什么区别" class="headerlink" title="ES5、ES6和ES2015有什么区别?"></a>ES5、ES6和ES2015有什么区别?</h3><blockquote>
<p><code>ES2015</code>特指在<code>2015</code>年发布的新一代<code>JS</code>语言标准，<code>ES6</code>泛指下一代JS语言标准，包含<code>ES2015</code>、<code>ES2016</code>、<code>ES2017</code>、<code>ES2018</code>等。现阶段在绝大部分场景下，<code>ES2015</code>默认等同<code>ES6</code>。<code>ES5</code>泛指上一代语言标准。<code>ES2015</code>可以理解为<code>ES5</code>和<code>ES6</code>的时间分界线</p>
</blockquote>
<h3 id="ES6的了解"><a href="#ES6的了解" class="headerlink" title="ES6的了解"></a>ES6的了解</h3><p>es6 是一个新的标准，它包含了许多新的语言特性和库，是 JS 最实质性的一次升级。<br>比如’箭头函数’、’字符串模板’、’generators(生成器)’、’async/await’、’解构赋值’、’class’等等，还有就是引入 module 模块的概念。</p>
<ul>
<li><p>增加了块级作用域。let命令实际上就增加了块级作用域。ES6规定，var命令和function命令声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。</p>
<p>块级作用域let a = 1;<code>可定义常量</code>const PI = 3.141592654;`</p>
</li>
<li><p>ES6将promise对象纳入规范，提供了原生的Promise对象。增加了let和const命令，用来声明变量。</p>
<p><code>var promise = new Promise(func);</code></p>
</li>
<li><p>箭头函数（操作符左边为输入的参数，而右边则是进行的操作以及返回的值Inputs=&gt;outputs。）</p>
</li>
<li><p>新增模板字符串（为JavaScript提供了简单的字符串插值功能，字符串的扩展） <code>var sum =</code>${a + b}<code>;</code></p>
</li>
<li><p>arguments对象可被不定参数和默认参数完美代替。</p>
</li>
<li><p>ES6新的语法糖，类，module模块化等新特性</p>
</li>
</ul>
<p>解析：<a href="https://www.cnblogs.com/heweijain/p/7073553.html" target="_blank" rel="noopener">参考</a></p>
<h3 id="谈一谈你了解ECMAScript6的新特性？"><a href="#谈一谈你了解ECMAScript6的新特性？" class="headerlink" title="谈一谈你了解ECMAScript6的新特性？"></a>谈一谈你了解ECMAScript6的新特性？</h3><ul>
<li>变量解构赋值              <code>var [a, b, c] = [1, 2, 3];</code></li>
<li>数组的扩展(转换数组类型)   <code>Array.from($(&#39;li&#39;));</code></li>
<li>函数的扩展(扩展运算符)     <code>[1, 2].push(...[3, 4, 5]);</code></li>
<li>对象的扩展(同值相等算法)   <code>Object.is(NaN, NaN);</code></li>
<li>新增数据类型(Symbol)      <code>let uid = Symbol(&#39;uid&#39;);</code></li>
<li>新增数据结构(Map)        <code>let set = new Set([1, 2, 2, 3]);</code></li>
<li>for…of循环（用来遍历数据—例如数组中的值。）            <code>for(let val of arr){};</code></li>
<li>Promise对象        </li>
<li>Generator函数          <code>function* foo(x){yield x; return x*x;}</code></li>
<li>引入Class(类)          <code>class Foo {}</code></li>
<li>引入模块体系            <code>export default func;</code></li>
<li>引入async函数[ES7]    </li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">await</span> timeout(ms);</span><br><span class="line">      <span class="built_in">console</span>.log(value)</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<h3 id="日常前端代码开发中，有哪些值得用ES6去改进的编程优化或者规范？"><a href="#日常前端代码开发中，有哪些值得用ES6去改进的编程优化或者规范？" class="headerlink" title="日常前端代码开发中，有哪些值得用ES6去改进的编程优化或者规范？"></a>日常前端代码开发中，有哪些值得用ES6去改进的编程优化或者规范？</h3><ul>
<li>常用箭头函数来取代<code>var self = this</code>;的做法。</li>
<li>常用<code>let</code>取代<code>var</code>命令。</li>
<li>常用数组/对象的结构赋值来命名变量，结构更清晰，语义更明确，可读性更好。</li>
<li>在长字符串多变量组合场合，用模板字符串来取代字符串累加，能取得更好地效果和阅读体验。</li>
<li>用<code>Class</code>类取代传统的构造函数，来生成实例化对象。</li>
<li>在大型应用开发中，要保持<code>module</code>模块化开发思维，分清模块之间的关系，常用<code>import</code>、<code>export</code>方法。</li>
</ul>
<h3 id="var、let、const-的区别"><a href="#var、let、const-的区别" class="headerlink" title="var、let、const 的区别"></a>var、let、const 的区别</h3><ul>
<li>var 定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。</li>
<li>let 定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。（通常配合 <code>for</code> 循环或者 <code>{}</code> 进行使用产生块级作用域）</li>
<li>const 用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改（内存地址不变）。</li>
<li>同一个变量只能使用一种方式声明，不然会报错</li>
</ul>
<p><a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">参考链接</a></p>
<h3 id="let有什么用，有了var为什么还要用let？"><a href="#let有什么用，有了var为什么还要用let？" class="headerlink" title="let有什么用，有了var为什么还要用let？"></a>let有什么用，有了var为什么还要用let？</h3><blockquote>
<p>在<code>ES6</code>之前，声明变量只能用<code>var</code>，<code>var</code>方式声明变量其实是很不合理的，准确的说，是因为<code>ES5</code>里面没有块级作用域是很不合理的。没有块级作用域回来带很多难以理解的问题，比如<code>for</code>循环<code>var</code>变量泄露，变量覆盖等问题。<code>let</code>声明的变量拥有自己的块级作用域，且修复了<code>var</code>声明变量带来的变量提升问题。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">	<span class="comment">// 块作用域</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">const</span> c = <span class="number">3</span>;</span><br><span class="line">		<span class="comment">// c = 4; // 报错</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// let a = 'a';	// 报错  注：是上面 var a = 1; 那行报错</span></span><br><span class="line">		<span class="comment">// var b = 'b';	// 报错：本行报错</span></span><br><span class="line">		<span class="comment">// const a = 'a1';	// 报错  注：是上面 var a = 1; 那行报错</span></span><br><span class="line">		<span class="comment">// let c = 'c';	// 报错：本行报错</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> aa;</span><br><span class="line">		<span class="keyword">let</span> bb;</span><br><span class="line">		<span class="comment">// const cc; // 报错</span></span><br><span class="line">		<span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">		<span class="built_in">console</span>.log(b); <span class="comment">// 2</span></span><br><span class="line">		<span class="built_in">console</span>.log(c); <span class="comment">// 3</span></span><br><span class="line">		<span class="built_in">console</span>.log(aa); <span class="comment">// undefined</span></span><br><span class="line">		<span class="built_in">console</span>.log(bb); <span class="comment">// undefined</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">	<span class="comment">// console.log(b); // 报错</span></span><br><span class="line">	<span class="comment">// console.log(c); // 报错</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 函数作用域</span></span><br><span class="line">	(<span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> d = <span class="number">5</span>;</span><br><span class="line">		<span class="keyword">let</span> e = <span class="number">6</span>;</span><br><span class="line">		<span class="keyword">const</span> f = <span class="number">7</span>;</span><br><span class="line">		<span class="built_in">console</span>.log(d); <span class="comment">// 5</span></span><br><span class="line">		<span class="built_in">console</span>.log(e); <span class="comment">// 6  (在同一个&#123; &#125;中,也属于同一个块，可以正常访问到)</span></span><br><span class="line">		<span class="built_in">console</span>.log(f); <span class="comment">// 7  (在同一个&#123; &#125;中,也属于同一个块，可以正常访问到)</span></span><br><span class="line">	&#125;)();</span><br><span class="line">	<span class="comment">// console.log(d); // 报错</span></span><br><span class="line">	<span class="comment">// console.log(e); // 报错</span></span><br><span class="line">	<span class="comment">// console.log(f); // 报错</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="JS-块级作用域、变量提升"><a href="#JS-块级作用域、变量提升" class="headerlink" title="JS 块级作用域、变量提升"></a>JS 块级作用域、变量提升</h3><p><strong>块级作用域</strong></p>
<p>JS 中作用域有：全局作用域、函数作用域。没有块作用域的概念。ECMAScript 6(简称 ES6)中新增了块级作用域。块作用域由 { } 包括，if 语句和 for 语句里面的{ }也属于块作用域。</p>
<p><strong>变量提升</strong></p>
<ul>
<li>如果变量声明在函数里面，则将变量声明提升到函数的开头</li>
<li>如果变量声明是一个全局变量，则将变量声明提升到全局作用域的开头</li>
</ul>
<p>解析：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">	<span class="comment">// 可见，通过var定义的变量可以跨块作用域访问到。</span></span><br><span class="line"></span><br><span class="line">	(<span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">		<span class="built_in">console</span>.log(b); <span class="comment">// 2</span></span><br><span class="line">	&#125;)();</span><br><span class="line">	<span class="comment">// console.log(b); // 报错，</span></span><br><span class="line">	<span class="comment">// 可见，通过var定义的变量不能跨函数作用域访问到</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">console</span>.log(c); <span class="comment">// 3</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">var</span> d = <span class="number">5</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">console</span>.log(i);	<span class="comment">// 4   (循环结束i已经是4，所以此处i为4)</span></span><br><span class="line">	<span class="built_in">console</span>.log(d); <span class="comment">// 5</span></span><br><span class="line">	<span class="comment">// if语句和for语句中用var定义的变量可以在外面访问到，</span></span><br><span class="line">	<span class="comment">// 可见，if语句和for语句属于块作用域，不属于函数作用域。</span></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">const</span> c = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(a);		<span class="comment">// 1	子作用域可以访问到父作用域的变量</span></span><br><span class="line">			<span class="built_in">console</span>.log(b);		<span class="comment">// 2	子作用域可以访问到父作用域的变量</span></span><br><span class="line">			<span class="built_in">console</span>.log(c);		<span class="comment">// 3	子作用域可以访问到父作用域的变量</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">var</span> aa = <span class="number">11</span>;</span><br><span class="line">			<span class="keyword">let</span> bb = <span class="number">22</span>;</span><br><span class="line">			<span class="keyword">const</span> cc = <span class="number">33</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">console</span>.log(aa);	<span class="comment">// 11	// 可以跨块访问到子 块作用域 的变量</span></span><br><span class="line">		<span class="comment">// console.log(bb);	// 报错	bb is not defined</span></span><br><span class="line">		<span class="comment">// console.log(cc);	// 报错	cc is not defined</span></span><br><span class="line">	&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="var-let-在-for-循环中的区别"><a href="#var-let-在-for-循环中的区别" class="headerlink" title="var let 在 for 循环中的区别"></a>var let 在 for 循环中的区别</h3><p>解析：<a href="https://blog.csdn.net/zoelinjf/article/details/79618688" target="_blank" rel="noopener">参考</a></p>
<h3 id="如何避免回调函数嵌套？"><a href="#如何避免回调函数嵌套？" class="headerlink" title="如何避免回调函数嵌套？"></a>如何避免回调函数嵌套？</h3><p>使用 Promises 将回调写成单独的函数</p>
<h3 id="Promise是什么，有什么作用？"><a href="#Promise是什么，有什么作用？" class="headerlink" title="Promise是什么，有什么作用？"></a>Promise是什么，有什么作用？</h3><blockquote>
<p>这里你谈 <code>promise</code>的时候，除了将他解决的痛点以及常用的 <code>API</code> 之外，最好进行拓展把 <code>eventloop</code> 带进来好好讲一下，<code>microtask</code>(微任务)、<code>macrotask</code>(任务) 的执行顺序；</p>
<p>如果看过 <code>promise</code> 源码，最好可以谈一谈 原生 <code>Promise</code> 是如何实现的。<code>Promise</code> 的关键点在于<code>callback</code> 的两个参数，一个是 <code>resovle</code>，一个是 <code>reject</code>。还有就是 <code>Promise</code> 的链式调用（<code>Promise.then()</code>，每一个 <code>then</code> 都是一个责任人）</p>
</blockquote>
<p><code>Promise</code>是<code>ES6</code>引入的一个新的对象，他的主要作用是用来<strong>解决JS异步机制里，回调机制产生的“回调地狱”。</strong>从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。它并不是什么突破性的<code>API</code>，只是<strong>封装了异步回调形式，使得异步回调可以写的更加优雅，可读性更高，而且可以链式调用。</strong></p>
<p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件监听——更合理和更强大。简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<ul>
<li>Promise 就是一个对象，用来表示并传递异步操作的最终结果</li>
<li>Promise 最主要的交互方式：将回调函数传入 then 方法来获得最终结果或出错原因</li>
<li>Promise 代码书写上的表现：以“链式调用”代替回调函数层层嵌套（回调地狱）</li>
</ul>
<p><strong>有两个特点:</strong></p>
<ol>
<li>对象的状态不受外界影响，Promise 对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和 Rejected（已失败）</li>
<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。</li>
</ol>
<p>依照 Promise/A+ 的定义，Promise 有四种状态：</p>
<ul>
<li><p>pending: 初始状态, 非 fulfilled 或 rejected.</p>
</li>
<li><p>fulfilled: 成功的操作.</p>
</li>
<li><p>rejected: 失败的操作.</p>
</li>
<li><p>settled: Promise已被fulfilled或rejected，且不是pending</p>
</li>
</ul>
<p>另外， fulfilled 与 rejected 一起合称 settled</p>
<p>Promise 对象用来进行延迟(deferred) 和异步(asynchronous ) 计算</p>
<p>解析：<a href="https://www.cnblogs.com/heweijain/p/7073553.html" target="_blank" rel="noopener">参考</a>、<a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">参考链接</a></p>
<h3 id="Promise-的构造函数"><a href="#Promise-的构造函数" class="headerlink" title="Promise 的构造函数"></a>Promise 的构造函数</h3><p>构造一个 Promise，最基本的用法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (...) &#123;  <span class="comment">// succeed</span></span><br><span class="line">            resolve(result);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;   <span class="comment">// fails</span></span><br><span class="line">            reject(<span class="built_in">Error</span>(errMessage));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>Promise 实例拥有 then 方法（具有 then 方法的对象，通常被称为thenable）。它的使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure>

<p>接收两个函数作为参数，一个在 fulfilled 的时候被调用，一个在rejected的时候被调用，接收参数就是 future，onFulfilled 对应 resolve, onRejected 对应 reject</p>
<h3 id="async函数是什么，有什么作用？"><a href="#async函数是什么，有什么作用？" class="headerlink" title="async函数是什么，有什么作用？"></a>async函数是什么，有什么作用？</h3><p><code>async</code>函数可以理解为<strong>内置自动执行器的<code>Generator</code>函数语法糖</strong>，它配合<code>ES6</code>的<code>Promise</code>近乎完美的实现了异步编程解决方案。</p>
<h3 id="async、await"><a href="#async、await" class="headerlink" title="async、await"></a>async、await</h3><p>async/await 是写异步代码的新方式，以前的方法有回调函数和 Promise。</p>
<p>async/await 是基于 Promise 实现的，它不能用于普通的回调函数。async/await 与 Promise 一样，是非阻塞的。</p>
<p>async/await 使得异步代码看起来像同步代码，这正是它的魔力所在。</p>
<blockquote>
<p><code>Generator</code> 函数的语法糖。有更好的语义、更好的适用性、返回值是 <code>Promise</code>。</p>
</blockquote>
<ul>
<li><code>async =&gt; *</code></li>
<li><code>await =&gt; yield</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本用法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">timeout</span> (<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, ms)    </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncConsole</span> (<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> timeout(ms)</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line">asyncConsole(<span class="string">'hello async and await'</span>, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：最好把2，3，4 连到一起讲</p>
</blockquote>
<h3 id="箭头函数和普通函数有什么区别"><a href="#箭头函数和普通函数有什么区别" class="headerlink" title="箭头函数和普通函数有什么区别"></a>箭头函数和普通函数有什么区别</h3><p>箭头函数可以让 this 指向固定化，这种特性很有利于封装回调函数</p>
<ul>
<li>函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象，用<code>call</code> <code>apply</code> <code>bind</code>也不能改变<code>this</code>指向</li>
<li>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。</li>
<li>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 <code>rest</code> 参数代替。</li>
<li>不可以使用<code>yield</code>命令，因此箭头函数不能用作 <code>Generator</code> 函数。</li>
<li>箭头函数没有原型对象<code>prototype</code></li>
</ul>
<p>第一点尤其值得注意。this 对象的指向是可变的，但是在箭头函数中，它是固定的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"id:"</span>, <span class="keyword">this</span>.id);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> id = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">foo.call(&#123; <span class="attr">id</span>: <span class="number">42</span> &#125;);</span><br><span class="line"><span class="comment">// id: 42</span></span><br></pre></td></tr></table></figure>

<p>解析：<a href="https://www.jianshu.com/p/bc28e4f67ef9" target="_blank" rel="noopener">参考</a></p>
<h3 id="举一些ES6对Function函数类型做的常用升级优化"><a href="#举一些ES6对Function函数类型做的常用升级优化" class="headerlink" title="举一些ES6对Function函数类型做的常用升级优化?"></a>举一些ES6对Function函数类型做的常用升级优化?</h3><p><strong>优化部分</strong></p>
<blockquote>
<p>箭头函数(核心)。箭头函数是ES6核心的升级项之一，箭头函数里<strong>没有自己的this</strong>,这改变了以往JS函数中最让人难以理解的this运行机制。主要优化点</p>
</blockquote>
<ul>
<li>箭头函数内的this指向的是<strong>函数定义时所在的对象</strong>，而不是函数执行时所在的对象。ES5函数里的this总是指向函数执行时所在的对象，这使得在很多情况下<code>this</code>的指向变得很难理解，尤其是非严格模式情况下，<code>this</code>有时候会指向全局对象，这甚至也可以归结为语言层面的bug之一。ES6的箭头函数优化了这一点，<strong>它的内部没有自己的<code>this</code>,这也就导致了<code>this</code>总是指向上一层的<code>this</code>，如果上一层还是箭头函数，则继续向上指，直到指向到有自己<code>this</code>的函数为止，并作为自己的<code>this</code></strong></li>
<li>箭头函数不能用作构造函数，因为它没有自己的<code>this</code>，无法实例化</li>
<li>也是因为箭头函数没有自己的this,所以箭头函数 内也不存在<code>arguments</code>对象。（可以用扩展运算符代替）</li>
<li>函数默认赋值。<code>ES6</code>之前，函数的形参是无法给默认值得，只能在函数内部通过变通方法实现。<code>ES6</code>以更简洁更明确的方式进行函数默认赋值</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">es6Fuc</span> (<span class="params">x, y = <span class="string">'default'</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line">es6Fuc(<span class="number">4</span>) <span class="comment">// 4, default</span></span><br></pre></td></tr></table></figure>

<p><strong>升级部分</strong></p>
<blockquote>
<p>ES6新增了双冒号运算符，用来取代以往的<code>bind</code>，<code>call</code>,和<code>apply</code>。(浏览器暂不支持，<code>Babel</code>已经支持转码)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foo::bar;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">bar.bind(foo);</span><br><span class="line"></span><br><span class="line">foo::bar(...arguments);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">bar.apply(foo, <span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure>

<h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>就是这种形式${varible},在以往的时候我们在连接字符串和变量的时候需要使用这种方式’string’ + varible + ‘string’但是有了模版语言后我们可以使用string${varible}string 这种进行连接。基本用途有如下：</p>
<p>1、基本的字符串格式化，将表达式嵌入字符串中进行拼接，用${}来界定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//es5</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"lux"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"hello"</span> + name);</span><br><span class="line"><span class="comment">//es6</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">"lux"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`hello <span class="subst">$&#123;name&#125;</span>`</span>); <span class="comment">//hello lux</span></span><br></pre></td></tr></table></figure>

<p>2、在 ES5 时我们通过反斜杠()来做多行字符串或者字符串一行行拼接，ES6 反引号(``)直接搞定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5</span></span><br><span class="line"><span class="keyword">var</span> template =</span><br><span class="line">  <span class="string">"hello \</span></span><br><span class="line"><span class="string">world"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(template); <span class="comment">//hello world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6</span></span><br><span class="line"><span class="keyword">const</span> template = <span class="string">`hello</span></span><br><span class="line"><span class="string">world`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(template); <span class="comment">//hello 空行 world</span></span><br></pre></td></tr></table></figure>

<h3 id="module、export、import是什么，有什么作用？"><a href="#module、export、import是什么，有什么作用？" class="headerlink" title="module、export、import是什么，有什么作用？"></a>module、export、import是什么，有什么作用？</h3><ul>
<li><code>module</code>、<code>export</code>、<code>import</code>是<code>ES6</code>用来统一前端模块化方案的设计思路和实现方案。<code>export</code>、<code>import</code>的出现统一了前端模块化的实现方案，整合规范了浏览器/服务端的模块化方法，用来取代传统的<code>AMD/CMD</code>、<code>requireJS</code>、<code>seaJS</code>、<code>commondJS</code>等等一系列前端模块不同的实现方案，使前端模块化更加统一规范，<code>JS</code>也能更加能实现大型的应用程序开发。</li>
<li><code>import</code>引入的模块是静态加载（编译阶段加载）而不是动态加载（运行时加载）。</li>
<li><code>import</code>引入<code>export</code>导出的接口值是动态绑定关系，即通过该接口，可以取到模块内部实时的值</li>
</ul>
<h3 id="ES6-如何动态加载-import"><a href="#ES6-如何动态加载-import" class="headerlink" title="ES6 如何动态加载 import"></a>ES6 如何动态加载 import</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">"lodash"</span>).then(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Do something with lodash (a.k.a '_')...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>解析：<a href="https://webpack.js.org/api/module-methods/#import" target="_blank" rel="noopener">参考</a></p>
<h3 id="什么是-Babel"><a href="#什么是-Babel" class="headerlink" title="什么是 Babel"></a>什么是 Babel</h3><p><code>babel</code>是一个 <code>ES6</code> 转码器，可以将 <code>ES6</code> 代码转为 <code>ES5</code> 代码，以便兼容那些还没支持<code>ES6</code>的平台</p>
<ul>
<li>Babel 是一个 JS 编译器，自带一组 ES6 语法转化器，用于转化 JS 代码。<br>这些转化器让开发者提前使用最新的 JS语法(ES6/ES7)，而不用等浏览器全部兼容。</li>
<li>Babel 默认只转换新的 JS 句法(syntax)，而不转换新的API。</li>
</ul>
<h3 id="Object-is-与原来的比较操作符“-”、“-”的区别？"><a href="#Object-is-与原来的比较操作符“-”、“-”的区别？" class="headerlink" title="Object.is() 与原来的比较操作符“ ===”、“ ==”的区别？"></a>Object.is() 与原来的比较操作符“ ===”、“ ==”的区别？</h3><ul>
<li><p>== 相等运算符，比较时会自动进行数据类型转换</p>
</li>
<li><p>=== 严格相等运算符，比较时不进行隐式类型转换（类型不同则会返回false）；</p>
</li>
<li><p>Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 Object.is(NaN, NaN) 会返回 true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//Object.is 同值相等算法，在 === 基础上对 0 和 NaN 特别处理</span><br><span class="line">+0 === -0 //true</span><br><span class="line">NaN === NaN // false</span><br><span class="line"></span><br><span class="line">Object.is(+0, -0) // false</span><br><span class="line">Object.is(NaN, NaN) // true</span><br></pre></td></tr></table></figure>
</li>
<li><p>Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。</p>
</li>
</ul>
<h3 id="for…in-和for…of有什么区别？"><a href="#for…in-和for…of有什么区别？" class="headerlink" title="for…in 和for…of有什么区别？"></a>for…in 和for…of有什么区别？</h3><blockquote>
<p>如果看到问题十六，那么就很好回答。问题十六提到了ES6统一了遍历标准，制定了可遍历对象，那么用什么方法去遍历呢？答案就是用<code>for...of</code>。ES6规定，有所部署了载了<code>Iterator</code>接口的对象(可遍历对象)都可以通过<code>for...of</code>去遍历，而<code>for..in</code>仅仅可以遍历对象</p>
</blockquote>
<p>这也就意味着，数组也可以用<code>for...of</code>遍历，这极大地方便了数组的取值，且避免了很多程序用<code>for..in</code>去遍历数组的恶习</p>
<h3 id="Symbol是什么，有什么作用？"><a href="#Symbol是什么，有什么作用？" class="headerlink" title="Symbol是什么，有什么作用？"></a>Symbol是什么，有什么作用？</h3><blockquote>
<p><code>Symbol</code>是<code>ES6</code>引入的第七种原始数据类型（说法不准确，应该是第七种数据类型，Object不是原始数据类型之一，已更正），所有Symbol()生成的值都是独一无二的，可以从根本上解决对象属性太多导致属性名冲突覆盖的问题。对象中<code>Symbol()</code>属性不能被<code>for...in</code>遍历，但是也不是私有属性</p>
</blockquote>
<h3 id="Set是什么，有什么作用？"><a href="#Set是什么，有什么作用？" class="headerlink" title="Set是什么，有什么作用？"></a>Set是什么，有什么作用？</h3><blockquote>
<p><code>Set</code>是<code>ES6</code>引入的一种类似<code>Array</code>的新的数据结构，<code>Set</code>实例的成员类似于数组<code>item</code>成员。</p>
<p>区别是<code>Set</code>实例的成员都是唯一，不重复的。这个特性可以轻松地实现数组去重</p>
</blockquote>
<p><strong>Set 数据结构</strong></p>
<ul>
<li>es6 方法,Set 本身是一个构造函数，它类似于数组，但是成员值都是唯一的。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3, 4, 4]);</span><br><span class="line">console.log([...<span class="keyword">set</span>]); // [1,2,3,4]</span><br><span class="line">console.log(Array.from(new Set([2, 3, 3, 5, 6]))); //[2,3,5,6]</span><br></pre></td></tr></table></figure>

<h3 id="Map是什么，有什么作用？"><a href="#Map是什么，有什么作用？" class="headerlink" title="Map是什么，有什么作用？"></a>Map是什么，有什么作用？</h3><blockquote>
<p><code>Map</code>是<code>ES6</code>引入的一种类似<code>Object</code>的新的数据结构，<code>Map</code>可以理解为是<code>Object</code>的超集，打破了以传统键值对形式定义对象，对象的<code>key</code>不再局限于字符串，也可以是<code>Object</code>。可以更加全面的描述对象的属性</p>
</blockquote>
<h3 id="Proxy是什么，有什么作用？"><a href="#Proxy是什么，有什么作用？" class="headerlink" title="Proxy是什么，有什么作用？"></a>Proxy是什么，有什么作用？</h3><blockquote>
<p><code>Proxy</code>是<code>ES6</code>新增的一个构造函数，可以理解为JS语言的一个代理，用来改变JS默认的一些语言行为，包括拦截默认的<code>get/set</code>等底层方法，使得JS的使用自由度更高，可以最大限度的满足开发者的需求。比如通过拦截对象的<code>get/set</code>方法，可以轻松地定制自己想要的<code>key</code>或者<code>value</code>。下面的例子可以看到，随便定义一个<code>myOwnObj</code>的<code>key</code>,都可以变成自己想要的函数`</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createMyOwnObj</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">//想把所有的key都变成函数，或者Promise,或者anything</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">		<span class="keyword">get</span>(target, propKey, receiver) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">				setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">					<span class="keyword">let</span> randomBoolean = <span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span>;</span><br><span class="line">					<span class="keyword">let</span> Message;</span><br><span class="line">					<span class="keyword">if</span> (randomBoolean) &#123;</span><br><span class="line">						Message = <span class="string">`你的<span class="subst">$&#123;propKey&#125;</span>运气不错，成功了`</span>;</span><br><span class="line">						resolve(Message);</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						Message = <span class="string">`你的<span class="subst">$&#123;propKey&#125;</span>运气不行，失败了`</span>;</span><br><span class="line">						reject(Message);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;, <span class="number">1000</span>);</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myOwnObj = createMyOwnObj();</span><br><span class="line"></span><br><span class="line">myOwnObj.hahaha.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(result) <span class="comment">//你的hahaha运气不错，成功了</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(error) <span class="comment">//你的hahaha运气不行，失败了</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">myOwnObj.wuwuwu.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(result) <span class="comment">//你的wuwuwu运气不错，成功了</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(error) <span class="comment">//你的wuwuwu运气不行，失败了</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Reflect是什么，有什么作用？"><a href="#Reflect是什么，有什么作用？" class="headerlink" title="Reflect是什么，有什么作用？"></a>Reflect是什么，有什么作用？</h3><blockquote>
<p><code>Reflect</code>是<code>ES6</code>引入的一个新的对象，他的主要作用有两点，一是将原生的一些零散分布在<code>Object</code>、<code>Function</code>或者全局函数里的方法(如<code>apply</code>、<code>delete</code>、<code>get</code>、<code>set</code>等等)，统一整合到<code>Reflect</code>上，这样可以更加方便更加统一的管理一些原生<code>API</code>。其次就是因为<code>Proxy</code>可以改写默认的原生API，如果一旦原生<code>API</code>别改写可能就找不到了，所以<code>Reflect</code>也可以起到备份原生API的作用，使得即使原生<code>API</code>被改写了之后，也可以在被改写之后的<code>API</code>用上默认的<code>API</code></p>
</blockquote>
<h3 id="举一些ES6对String字符串类型做的常用升级优化"><a href="#举一些ES6对String字符串类型做的常用升级优化" class="headerlink" title="举一些ES6对String字符串类型做的常用升级优化?"></a>举一些ES6对String字符串类型做的常用升级优化?</h3><p><strong>优化部分</strong></p>
<blockquote>
<p><code>ES6</code>新增了字符串模板，在拼接大段字符串时，用反斜杠<code>(</code>)`取代以往的字符串相加的形式，能保留所有空格和换行，使得字符串拼接看起来更加直观，更加优雅</p>
</blockquote>
<p><strong>升级部分</strong></p>
<blockquote>
<p><code>ES6</code>在<code>String</code>原型上新增了<code>includes()</code>方法，用于取代传统的只能用<code>indexOf</code>查找包含字符的方法(<code>indexOf</code>返回<code>-1</code>表示没查到不如<code>includes</code>方法返回<code>false</code>更明确，语义更清晰), 此外还新增了<code>startsWith()</code>, <code>endsWith(),</code> <code>padStart()</code>,<code>padEnd()</code>,<code>repeat()</code>等方法，可方便的用于查找，补全字符串</p>
</blockquote>
<h3 id="举一些ES6对Array数组类型做的常用升级优化"><a href="#举一些ES6对Array数组类型做的常用升级优化" class="headerlink" title="举一些ES6对Array数组类型做的常用升级优化"></a>举一些ES6对Array数组类型做的常用升级优化</h3><p><strong>优化部分</strong></p>
<ul>
<li>数组解构赋值。<code>ES6</code>可以直接以<code>let [a,b,c] = [1,2,3]</code>形式进行变量赋值，在声明较多变量时，不用再写很多<code>let(var),</code>且映射关系清晰，且支持赋默认值</li>
<li>扩展运算符。<code>ES6</code>新增的扩展运算符(<code>...</code>)(重要),可以轻松的实现数组和松散序列的相互转化，可以取代<code>arguments</code>对象和<code>apply</code>方法，轻松获取未知参数个数情况下的参数集合。（尤其是在<code>ES5</code>中，<code>arguments</code>并不是一个真正的数组，而是一个类数组的对象，但是扩展运算符的逆运算却可以返回一个真正的数组）。扩展运算符还可以轻松方便的实现数组的复制和解构赋值（<code>let a = [2,3,4]</code>; <code>let b = [...a]</code>）</li>
</ul>
<p><strong>升级部分</strong></p>
<blockquote>
<p><code>ES6</code>在<code>Array</code>原型上新增了<code>find()</code>方法，用于取代传统的只能用<code>indexOf</code>查找包含数组项目的方法,且修复了<code>indexOf</code>查找不到<code>NaN的bug([NaN].indexOf(NaN) === -1)</code>.此外还新增了<code>copyWithin()</code>,<code>includes()</code>, <code>fill()</code>,<code>flat()</code>等方法，可方便的用于字符串的查找，补全,转换等</p>
</blockquote>
<h3 id="举一些ES6对Number数字类型做的常用升级优化"><a href="#举一些ES6对Number数字类型做的常用升级优化" class="headerlink" title="举一些ES6对Number数字类型做的常用升级优化"></a>举一些ES6对Number数字类型做的常用升级优化</h3><p><strong>优化部分</strong></p>
<blockquote>
<p>ES6在<code>Number</code>原型上新增了<code>isFinite()</code>, <code>isNaN()</code>方法，用来取代传统的全局<code>isFinite(),</code> <code>isNaN()</code>方法检测数值是否有限、是否是<code>NaN</code>。<code>ES5</code>的<code>isFinite()</code>, <code>isNaN()</code>方法都会先将非数值类型的参数转化为<code>Number</code>类型再做判断，这其实是不合理的，最造成i<code>sNaN(&#39;NaN&#39;) === true</code>的奇怪行为<code>--&#39;NaN&#39;</code>是一个字符串，但是<code>isNaN</code>却说这就是<code>NaN</code>。而<code>Number.isFinite()</code>和<code>Number.isNaN()</code>则不会有此类问题(<code>Number.isNaN(&#39;NaN&#39;) === false</code>)。（<code>isFinite()</code>同上）</p>
</blockquote>
<p><strong>升级部分</strong></p>
<blockquote>
<p><code>ES6</code>在<code>Math</code>对象上新增了<code>Math.cbrt()</code>，<code>trunc()</code>，<code>hypot()</code>等等较多的科学计数法运算方法，可以更加全面的进行立方根、求和立方根等等科学计算</p>
</blockquote>
<h3 id="举一些ES6对Object类型做的常用升级优化-重要"><a href="#举一些ES6对Object类型做的常用升级优化-重要" class="headerlink" title="举一些ES6对Object类型做的常用升级优化?(重要)"></a>举一些ES6对Object类型做的常用升级优化?(重要)</h3><p><strong>优化部分</strong></p>
<blockquote>
<p>对象属性变量式声明。<code>ES6</code>可以直接以变量形式声明对象属性或者方法，。比传统的键值对形式声明更加简洁，更加方便，语义更加清晰</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [apple, orange] = [<span class="string">'red appe'</span>, <span class="string">'yellow orange'</span>];</span><br><span class="line"><span class="keyword">let</span> myFruits = &#123;apple, orange&#125;;    <span class="comment">// let myFruits = &#123;apple: 'red appe', orange: 'yellow orange'&#125;;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>尤其在对象解构赋值(见优化部分b.)或者模块输出变量时，这种写法的好处体现的最为明显</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;keys, values, entries&#125; = <span class="built_in">Object</span>;</span><br><span class="line"><span class="keyword">let</span> MyOwnMethods = &#123;keys, values, entries&#125;; <span class="comment">// let MyOwnMethods = &#123;keys: keys, values: values, entries: entries&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看到属性变量式声明属性看起来更加简洁明了。方法也可以采用简洁写法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> es5Fun = &#123;</span><br><span class="line">    method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> es6Fun = &#123;</span><br><span class="line">    method()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对象的解构赋值。 <code>ES6</code>对象也可以像数组解构赋值那样，进行变量的解构赋值</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;apple, orange&#125; = &#123;<span class="attr">apple</span>: <span class="string">'red appe'</span>, <span class="attr">orange</span>: <span class="string">'yellow orange'</span>&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对象的扩展运算符(<code>...</code>)。 ES6对象的扩展运算符和数组扩展运算符用法本质上差别不大，毕竟数组也就是特殊的对象。对象的扩展运算符一个最常用也最好用的用处就在于可以轻松的取出一个目标对象内部全部或者部分的可遍历属性，从而进行对象的合并和分解</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;apple, orange, ...otherFruits&#125; = &#123;<span class="attr">apple</span>: <span class="string">'red apple'</span>, <span class="attr">orange</span>: <span class="string">'yellow orange'</span>, <span class="attr">grape</span>: <span class="string">'purple grape'</span>, <span class="attr">peach</span>: <span class="string">'sweet peach'</span>&#125;; </span><br><span class="line"><span class="comment">// otherFruits  &#123;grape: 'purple grape', peach: 'sweet peach'&#125;</span></span><br><span class="line"><span class="comment">// 注意: 对象的扩展运算符用在解构赋值时，扩展运算符只能用在最有一个参数(otherFruits后面不能再跟其他参数)</span></span><br><span class="line"><span class="keyword">let</span> moreFruits = &#123;<span class="attr">watermelon</span>: <span class="string">'nice watermelon'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> allFruits = &#123;apple, orange, ...otherFruits, ...moreFruits&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>super</code> 关键字。<code>ES6</code>在<code>Class</code>类里新增了类似<code>this</code>的关键字<code>super</code>。同<code>this</code>总是指向当前函数所在的对象不同，<code>super</code>关键字总是指向当前函数所在对象的原型对象</p>
</blockquote>
<p><strong>升级部分</strong></p>
<blockquote>
<p><code>ES6</code>在<code>Object</code>原型上新增了<code>is()</code>方法，做两个目标对象的相等比较，用来完善<code>&#39;===&#39;</code>方法。<code>&#39;===&#39;</code>方法中<code>NaN === NaN //false</code>其实是不合理的，<code>Object.is</code>修复了这个小<code>bug</code>。<code>(Object.is(NaN, NaN) // true)</code></p>
</blockquote>
<blockquote>
<p><code>ES6</code>在<code>Object</code>原型上新增了<code>assign()</code>方法，用于对象新增属性或者多个对象合并</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>: <code>assign</code>合并的对象<code>target</code>只能合并<code>source1</code>、s<code>ource2</code>中的自身属性，并不会合并<code>source1</code>、<code>source2</code>中的继承属性，也不会合并不可枚举的属性，且无法正确复制get和set属性（会直接执行<code>get/set</code>函数，取<code>return</code>的值）</p>
</blockquote>
<ul>
<li><code>ES6</code>在<code>Object</code>原型上新增了<code>getOwnPropertyDescriptors()</code>方法，此方法增强了<code>ES5</code>中<code>getOwnPropertyDescriptor()</code>方法，可以获取指定对象所有自身属性的描述对象。结合<code>defineProperties()</code>方法，可以完美复制对象，包括复制<code>get</code>和<code>set</code>属性</li>
<li><code>ES6</code>在<code>Object</code>原型上新增了<code>getPrototypeOf()</code>和<code>setPrototypeOf()</code>方法，用来获取或设置当前对象的<code>prototype</code>对象。这个方法存在的意义在于，<code>ES5</code>中获取设置<code>prototype</code>对像是通过<code>__proto__</code>属性来实现的，然而<code>__proto__</code>属性并不是ES规范中的明文规定的属性，只是浏览器各大产商“私自”加上去的属性，只不过因为适用范围广而被默认使用了，再非浏览器环境中并不一定就可以使用，所以为了稳妥起见，获取或设置当前对象的<code>prototype</code>对象时，都应该采用ES6新增的标准用法</li>
<li><code>ES6</code>在<code>Object</code>原型上还新增了<code>Object.keys()</code>，<code>Object.values()</code>，<code>Object.entries()</code>方法，用来获取对象的所有键、所有值和所有键值对数组</li>
</ul>
<h3 id="ES6-都有什么-Iterator-遍历器"><a href="#ES6-都有什么-Iterator-遍历器" class="headerlink" title="ES6 都有什么 Iterator 遍历器"></a>ES6 都有什么 Iterator 遍历器</h3><p>答案：Set、Map</p>
<p>1、遍历器（Iterator）是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）</p>
<p>2、Iterator 的作用有三个：</p>
<ul>
<li>一是为各种数据结构，提供一个统一的、简便的访问接口；</li>
<li>二是使得数据结构的成员能够按某种次序排列；</li>
<li>三是 ES6 创造了一种新的遍历命令 for…of 循环，Iterator 接口主要供 for…of 消费。</li>
</ul>
<p>3、默认部署了 Iterator 的数据有 Array、Map、Set、String、TypedArray、arguments、NodeList 对象，ES6 中有的是 Set、Map、</p>
<h3 id="Iterator是什么，有什么作用？-重要"><a href="#Iterator是什么，有什么作用？-重要" class="headerlink" title="Iterator是什么，有什么作用？(重要)"></a>Iterator是什么，有什么作用？(重要)</h3><ul>
<li><code>Iterator</code>是<code>ES6</code>中一个很重要概念，它并不是对象，也不是任何一种数据类型。因为<code>ES6</code>新增了<code>Set</code>、<code>Map</code>类型，他们和<code>Array</code>、<code>Object</code>类型很像，<code>Array</code>、<code>Object</code>都是可以遍历的，但是<code>Set</code>、<code>Map</code>都不能用for循环遍历，解决这个问题有两种方案，一种是为<code>Set</code>、<code>Map</code>单独新增一个用来遍历的<code>API</code>，另一种是为<code>Set</code>、<code>Map</code>、<code>Array</code>、<code>Object</code>新增一个统一的遍历<code>API</code>，显然，第二种更好，<code>ES6</code>也就顺其自然的需要一种设计标准，来统一所有可遍历类型的遍历方式。<code>Iterator</code>正是这样一种标准。或者说是一种规范理念</li>
<li>就好像<code>JavaScript</code>是<code>ECMAScript</code>标准的一种具体实现一样，<code>Iterator</code>标准的具体实现是<code>Iterator</code>遍历器。<code>Iterator</code>标准规定，所有部署了<code>key</code>值为<code>[Symbol.iterator]</code>，且<code>[Symbol.iterator]</code>的<code>value</code>是标准的<code>Iterator</code>接口函数(标准的<code>Iterator</code>接口函数: 该函数必须返回一个对象，且对象中包含<code>next</code>方法，且执行<code>next()</code>能返回包含<code>value/done</code>属性的<code>Iterator</code>对象)的对象，都称之为可遍历对象，<code>next()</code>后返回的<code>Iterator</code>对象也就是<code>Iterator</code>遍历器</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//obj就是可遍历的，因为它遵循了Iterator标准，且包含[Symbol.iterator]方法，方法函数也符合标准的Iterator接口规范。</span></span><br><span class="line"><span class="comment">//obj.[Symbol.iterator]() 就是Iterator遍历器</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  data: [ <span class="string">'hello'</span>, <span class="string">'world'</span> ],</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next() &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; self.data.length) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            value: self.data[index++],</span><br><span class="line">            done: <span class="literal">false</span></span><br><span class="line">          &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>ES6</code>给<code>Set</code>、<code>Map</code>、<code>Array</code>、<code>String</code>都加上了<code>[Symbol.iterator]</code>方法，且<code>[Symbol.iterator]</code>方法函数也符合标准的<code>Iterator</code>接口规范，所以<code>Set</code>、<code>Map</code>、<code>Array</code>、<code>String</code>默认都是可以遍历的</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Array</span></span><br><span class="line"><span class="keyword">let</span> array = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line">array[<span class="built_in">Symbol</span>.iterator]() <span class="comment">//Iterator遍历器</span></span><br><span class="line">array[<span class="built_in">Symbol</span>.iterator]().next() <span class="comment">//&#123;value: "red", done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//String</span></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">'1122334455'</span>;</span><br><span class="line">string[<span class="built_in">Symbol</span>.iterator]() <span class="comment">//Iterator遍历器</span></span><br><span class="line">string[<span class="built_in">Symbol</span>.iterator]().next() <span class="comment">//&#123;value: "1", done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set(['red', 'green', 'blue']);</span><br><span class="line"><span class="keyword">set</span>[Symbol.iterator]() //Iterator遍历器</span><br><span class="line"><span class="keyword">set</span>[Symbol.iterator]().next() //&#123;value: <span class="string">"red"</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Map</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">let</span> obj= &#123;<span class="attr">map</span>: <span class="string">'map'</span>&#125;;</span><br><span class="line">map.set(obj, <span class="string">'mapValue'</span>);</span><br><span class="line">map[<span class="built_in">Symbol</span>.iterator]().next()  &#123;<span class="attr">value</span>: <span class="built_in">Array</span>(<span class="number">2</span>), <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Generator函数是什么，有什么作用？"><a href="#Generator函数是什么，有什么作用？" class="headerlink" title="Generator函数是什么，有什么作用？"></a>Generator函数是什么，有什么作用？</h3><ul>
<li>如果说<code>JavaScript</code>是<code>ECMAScript</code>标准的一种具体实现、<code>Iterator</code>遍历器是<code>Iterator</code>的具体实现，那么<code>Generator</code>函数可以说是<code>Iterator</code>接口的具体实现方式。</li>
<li>执行<code>Generator</code>函数会返回一个遍历器对象，每一次<code>Generator</code>函数里面的<code>yield</code>都相当一次遍历器对象的<code>next()</code>方法，并且可以通过<code>next(value)</code>方法传入自定义的value,来改变<code>Generator</code>函数的行为。</li>
<li><code>Generator</code>函数可以通过配合<code>Thunk</code> 函数更轻松更优雅的实现异步编程和控制流管理。</li>
</ul>
<h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><blockquote>
<p>遍历器对象生成函数，最大的特点是可以交出函数的执行权</p>
</blockquote>
<ul>
<li><code>function</code> 关键字与函数名之间有一个星号；</li>
<li>函数体内部使用 <code>yield</code>表达式，定义不同的内部状态；</li>
<li><code>next</code>指针移向下一个状态</li>
</ul>
<blockquote>
<p>这里你可以说说 <code>Generator</code>的异步编程，以及它的语法糖 <code>async</code> 和 <code>awiat</code>，传统的异步编程。<code>ES6</code> 之前，异步编程大致如下</p>
</blockquote>
<ul>
<li>回调函数</li>
<li>事件监听</li>
<li>发布/订阅</li>
</ul>
<blockquote>
<p>传统异步编程方案之一：协程，多个线程互相协作，完成异步任务。</p>
</blockquote>
<h3 id="Class、extends是什么，有什么作用？"><a href="#Class、extends是什么，有什么作用？" class="headerlink" title="Class、extends是什么，有什么作用？"></a>Class、extends是什么，有什么作用？</h3><blockquote>
<p><code>ES6</code> 的<code>class</code>可以看作只是一个<code>ES5</code>生成实例对象的构造函数的语法糖。它参考了<code>java</code>语言，定义了一个类的概念，让对象原型写法更加清晰，对象实例化更像是一种面向对象编程。<code>Class</code>类可以通过<code>extends</code>实现继承。它和ES5构造函数的不同点</p>
</blockquote>
<p>类的内部定义的所有方法，都是不可枚举的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ES5Fun</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.x = x;</span><br><span class="line">	<span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line">ES5Fun.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	 <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> ES5Fun(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">p.toString();</span><br><span class="line"><span class="built_in">Object</span>.keys(ES5Fun.prototype); <span class="comment">//['toString']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ES6Fun</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span> (x, y) &#123;</span><br><span class="line">		<span class="keyword">this</span>.x = x;</span><br><span class="line">		<span class="keyword">this</span>.y = y;</span><br><span class="line">	&#125;</span><br><span class="line">	toString () &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(ES6Fun.prototype); <span class="comment">//[]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>ES6</code>的<code>class</code>类必须用<code>new</code>命令操作，而<code>ES5</code>的构造函数不用<code>new</code>也可以执行。</li>
<li><code>ES6</code>的<code>class</code>类不存在变量提升，必须先定义<code>class</code>之后才能实例化，不像<code>ES5</code>中可以将构造函数写在实例化之后。</li>
<li><code>ES5</code> 的继承，实质是先创造子类的实例对象<code>this</code>，然后再将父类的方法添加到<code>this</code>上面。<code>ES6</code> 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到<code>this</code>上面（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改<code>this</code>。</li>
</ul>
<h3 id="AMD，CMD，CommonJs，ES6-Module：解决原始无模块化的痛点"><a href="#AMD，CMD，CommonJs，ES6-Module：解决原始无模块化的痛点" class="headerlink" title="AMD，CMD，CommonJs，ES6 Module：解决原始无模块化的痛点"></a>AMD，CMD，CommonJs，ES6 Module：解决原始无模块化的痛点</h3><ul>
<li><strong>AMD</strong>：<code>requirejs</code> 在推广过程中对模块定义的规范化产出，提前执行，推崇依赖前置</li>
<li><strong>CMD</strong>：<code>seajs</code> 在推广过程中对模块定义的规范化产出，延迟执行，推崇依赖就近</li>
<li><strong>CommonJs</strong>：模块输出的是一个值的 <code>copy</code>，运行时加载，加载的是一个对象（<code>module.exports</code> 属性），该对象只有在脚本运行完才会生成</li>
<li><strong>ES6 Module</strong>：模块输出的是一个值的引用，编译时输出接口，<code>ES6</code>模块不是对象，它对外接口只是一种静态定义，在代码静态解析阶段就会生成。</li>
</ul>
<h3 id="Class-的讲解"><a href="#Class-的讲解" class="headerlink" title="Class 的讲解"></a>Class 的讲解</h3><p>class 语法相对原型、构造函数、继承更接近传统语法，它的写法能够让对象原型的写法更加清晰、面向对象编程的语法更加通俗<br>这是 class 的具体用法。</p>
<p>解析：<a href="https://www.cnblogs.com/fengxiongZz/p/8191503.html" target="_blank" rel="noopener">参考</a></p>
<h3 id="ECMAScript6-怎么写class么，为什么会出现class这种东西"><a href="#ECMAScript6-怎么写class么，为什么会出现class这种东西" class="headerlink" title="ECMAScript6 怎么写class么，为什么会出现class这种东西?"></a>ECMAScript6 怎么写class么，为什么会出现class这种东西?</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">  toString() &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">'('</span>+<span class="keyword">this</span>.x+<span class="string">', '</span>+<span class="keyword">this</span>.y+<span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ES6-中类的定义"><a href="#ES6-中类的定义" class="headerlink" title="ES6 中类的定义"></a>ES6 中类的定义</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、类的基本定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name = "小白") &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2、生成一个实例</span></span><br><span class="line"><span class="keyword">let</span> g_parent = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="built_in">console</span>.log(g_parent); <span class="comment">//&#123;name: "小白"&#125;</span></span><br><span class="line"><span class="keyword">let</span> v_parent = <span class="keyword">new</span> Parent(<span class="string">"v"</span>); <span class="comment">// 'v'就是构造函数name属性 , 覆盖构造函数的name属性值</span></span><br><span class="line"><span class="built_in">console</span>.log(v_parent); <span class="comment">// &#123;name: "v"&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3、继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="comment">//定义一个类</span></span><br><span class="line">  <span class="keyword">constructor</span>(name = "小白") &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"继承"</span>, <span class="keyword">new</span> Child()); <span class="comment">// 继承 &#123;name: "小白"&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4、继承传递参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="comment">//定义一个类</span></span><br><span class="line">  <span class="keyword">constructor</span>(name = "小白") &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name = "child") &#123;</span><br><span class="line">    <span class="comment">// 子类重写name属性值</span></span><br><span class="line">    <span class="keyword">super</span>(name); <span class="comment">// 子类向父类修改 super一定放第一行</span></span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">"preson"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"继承"</span>, <span class="keyword">new</span> Child(<span class="string">"hello"</span>)); <span class="comment">// 带参数覆盖默认值  继承&#123;name: "hello", type: "preson"&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5、ES6重新定义的ES5中的访问器属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="comment">//定义一个类</span></span><br><span class="line">  <span class="keyword">constructor</span>(name = "小白") &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> longName() &#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"mk"</span> + <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> longName(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"getter"</span>, v.longName); <span class="comment">// getter mk小白</span></span><br><span class="line"></span><br><span class="line">v.longName = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"setter"</span>, v.longName); <span class="comment">// setter mkhello</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6、类的静态方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="comment">//定义一个类</span></span><br><span class="line">  <span class="keyword">constructor</span>(name = "小白") &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> tell() &#123;</span><br><span class="line">    <span class="comment">// 静态方法:通过类去调用，而不是实例</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"tell"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.tell(); <span class="comment">// tell</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 7、类的静态属性：</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="comment">//定义一个类</span></span><br><span class="line">  <span class="keyword">constructor</span>(name = "小白") &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> tell() &#123;</span><br><span class="line">    <span class="comment">// 静态方法:通过类去调用，而不是实例</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"tell"</span>); <span class="comment">// tell</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.type = <span class="string">"test"</span>; <span class="comment">// 定义静态属性</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"静态属性"</span>, Parent.type); <span class="comment">// 静态属性 test</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v_parent = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="built_in">console</span>.log(v_parent); <span class="comment">// &#123;name: "小白"&#125;  没有tell方法和type属性</span></span><br></pre></td></tr></table></figure>

<h3 id="解构赋值及其原理"><a href="#解构赋值及其原理" class="headerlink" title="解构赋值及其原理"></a>解构赋值及其原理</h3><p>解构赋值：其实就是分解出一个对象的解构，分成两个步骤：</p>
<ol>
<li>变量的声明</li>
<li>变量的赋值</li>
</ol>
<p>原理：ES6 变量的解构赋值本质上是“模式匹配”,只要等号两边的模式相同，左边的变量就会被赋予匹配的右边的值，如果匹配不成功变量的值就等于 undefined</p>
<p>解析：</p>
<p>一、 数组的解构赋值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于数组的解构赋值，其实就是获得数组的元素，而我们一般情况下获取数组元素的方法是通过下标获取，例如：</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> a = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> b = arr[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> c = arr[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 而数组的解构赋值给我们提供了极其方便的获取方式，如下：</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c); <span class="comment">//1,2,3</span></span><br></pre></td></tr></table></figure>

<ol>
<li>模式匹配解构赋值</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line"><span class="built_in">console</span>.log(foo, bar, baz); <span class="comment">//1,2,3</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>省略解构赋值</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [, , a, , b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">//3,5</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>含剩余参数的解构赋值</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, ...reset] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, reset); <span class="comment">//1,[2,3,4,5]</span></span><br></pre></td></tr></table></figure>

<p>其转成 ES5 的原理如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>,</span><br><span class="line">  reset = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, reset); <span class="comment">//1,[2,3,4,5]</span></span><br></pre></td></tr></table></figure>

<p>注意：如果剩余参数是对应的值为 undefined，则赋值为[]，因为找不到对应值的时候，是通过 slice 截取的，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, ...reset] = [<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, reset); <span class="comment">//1,[]</span></span><br></pre></td></tr></table></figure>

<p>其转成 ES5 的原理如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ref = [<span class="number">1</span>],</span><br><span class="line">  a = _ref[<span class="number">0</span>],</span><br><span class="line">  reset = _ref.slice(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a, reset); <span class="comment">//1,[]</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>非数组解构成数组(重点，难点)</li>
</ol>
<p>一条原则：要解构成数组的前提：如果等号右边，不是数组(严格地说，不是可遍历的解构)，则直接报错，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo] = <span class="number">1</span>; <span class="comment">//报错</span></span><br><span class="line"><span class="keyword">let</span> [foo1] = <span class="literal">false</span>; <span class="comment">//报错</span></span><br><span class="line"><span class="keyword">let</span> [foo2] = <span class="literal">NaN</span>; <span class="comment">//报错</span></span><br><span class="line"><span class="keyword">let</span> [foo3] = <span class="literal">undefined</span>; <span class="comment">//报错</span></span><br><span class="line"><span class="keyword">let</span> [foo4] = <span class="literal">null</span>; <span class="comment">//报错</span></span><br><span class="line"><span class="keyword">let</span> [foo5] = &#123;&#125;; <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>

<p>为什么？转成 ES5 看下原理就一清二楚了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ = <span class="number">1</span>,</span><br><span class="line">  foo = _[<span class="number">0</span>]; <span class="comment">//报错</span></span><br><span class="line"><span class="keyword">var</span> _false = <span class="literal">false</span>,</span><br><span class="line">  foo1 = _false[<span class="number">0</span>]; <span class="comment">//报错</span></span><br><span class="line"><span class="keyword">var</span> _NaN = <span class="literal">NaN</span>,</span><br><span class="line">  foo2 = _NaN[<span class="number">0</span>]; <span class="comment">//报错</span></span><br><span class="line"><span class="keyword">var</span> _undefined = <span class="literal">undefined</span>,</span><br><span class="line">  foo3 = _undefined[<span class="number">0</span>]; <span class="comment">//报错</span></span><br><span class="line"><span class="keyword">var</span> _ref = <span class="literal">null</span>;</span><br><span class="line">foo4 = _ref[<span class="number">0</span>]; <span class="comment">//报错</span></span><br><span class="line"><span class="keyword">var</span> _ref2 = &#123;&#125;,</span><br><span class="line">  foo5 = _ref2[<span class="number">0</span>]; <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>Set 的解构赋值</li>
</ol>
<p>先执行 new Set()去重，然后对得到的结果进行解构</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c); <span class="comment">//1,2,3</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>迭代器解构</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> a;</span><br><span class="line">    [a, b] = [b, a + b];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [first, second, third, fourth, fifth, sixth] = fibs();</span><br><span class="line">sixth; <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p><strong>总结 1：只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</strong></p>
<ol start="7">
<li>解构赋值的默认值</li>
</ol>
<p>当变量严格等于 undefined 的时候，会读取默认值，所谓的严格等于，就是“===”</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">----------</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a,b = <span class="string">'default'</span>] = [<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a,b);<span class="comment">//1,'default'</span></span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [c = <span class="string">'default'</span>] = [<span class="literal">undefined</span>];</span><br><span class="line"><span class="built_in">console</span>.log(c);<span class="comment">//'default'</span></span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'aaa'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(x);<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'aaa'</span>);<span class="comment">//'aaa'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a,x = f()] = [<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a,x);<span class="comment">//1,undefined</span></span><br></pre></td></tr></table></figure>

<p><strong>总结 2：如果不使用默认值，则不会执行默认值的函数</strong></p>
<p>二、对象的解构赋值</p>
<ol>
<li>解构赋值的举例：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = &#123;</span><br><span class="line">  name: <span class="string">"zhuangzhuang"</span>,</span><br><span class="line">  age: <span class="number">25</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; name, age &#125; = p1; <span class="comment">//注意变量必须为属性名</span></span><br><span class="line"><span class="built_in">console</span>.log(name, age); <span class="comment">//"zhuangzhuang",25</span></span><br></pre></td></tr></table></figure>

<p>其转成 es5 的原理则为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _p1 = p1,</span><br><span class="line">  name = _p1.name,</span><br><span class="line">  age = _p1.age;</span><br><span class="line"><span class="built_in">console</span>.log(name, age); <span class="comment">//"zhuangzhuang",25</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>解构赋值的别名</li>
</ol>
<p>如果使用别名，则不允许再使用原有的解构出来的属性名，看以下举例则会明白：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = &#123;</span><br><span class="line">  name: <span class="string">"zhuangzhuang"</span>,</span><br><span class="line">  age: <span class="number">25</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">name</span>: aliasName, <span class="attr">age</span>: aliasAge &#125; = p1; <span class="comment">//注意变量必须为属性名</span></span><br><span class="line"><span class="built_in">console</span>.log(aliasName, aliasAge); <span class="comment">//"zhuangzhuang",25</span></span><br><span class="line"><span class="built_in">console</span>.log(name, age); <span class="comment">//Uncaught ReferenceError: age is not defined</span></span><br></pre></td></tr></table></figure>

<p>为何打印原有的属性名则会报错？让我们看看转成 es5 后的原理是如何实现的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _p1 = p1,</span><br><span class="line">  aliasName = _p1.name,</span><br><span class="line">  aliasAge = _p1.age;</span><br><span class="line"><span class="built_in">console</span>.log(aliasName, aliasAge); <span class="comment">//"zhuangzhuang",25</span></span><br><span class="line"><span class="built_in">console</span>.log(name, age); <span class="comment">//所以打印name和age会报错——“Uncaught ReferenceError: age is not defined”，但是为何只报错age，不报错name呢？</span></span><br></pre></td></tr></table></figure>

<p>只报错 age，不报错 name，这说明其实 name 是存在的，那么根据 js 的解析顺序，当在当前作用域 name 无法找到时，会向上找，直到找到 window 下的 name,而我们打印 window 可以发现，其下面确实有一个 name，值为“”，而其下面并没有属性叫做 age，所以在这里 name 不报错，只报 age 的错。类似 name 的属性还有很多，比如 length 等。</p>
<ol start="3">
<li>解构赋值的默认值</li>
</ol>
<p>有些情况下，我们解构出来的值并不存在，所以需要设定一个默认值，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"zhuangzhuang"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; name, age &#125; = obj;</span><br><span class="line"><span class="built_in">console</span>.log(name, age); <span class="comment">//"zhuangzhuang",undefined</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到当 age 这个属性并不存在于 obj 的时候，解构出来的值为 undefined，那么为了避免这种尴尬的情况，我们常常会设置该属性的默认值，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"zhuangzhuang"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; name, age = <span class="number">18</span> &#125; = obj;</span><br><span class="line"><span class="built_in">console</span>.log(name, age); <span class="comment">//"zhuangzhuang",18</span></span><br></pre></td></tr></table></figure>

<p>当我们取出来的值不存在，即为 undefined 的时候，则会取默认值(假设存在默认值)，ES6 的默认值是使用<strong>“变量=默认值”</strong>的方式。</p>
<p>注意：只有当为 undefined 的时候才会取默认值，null 等均不会取默认值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"zhuangzhuang"</span>,</span><br><span class="line">  age: <span class="number">27</span>,</span><br><span class="line">  gender: <span class="literal">null</span>, <span class="comment">//假设未知使用null</span></span><br><span class="line">  isFat: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; name, age = <span class="number">18</span>, gender = <span class="string">"man"</span>, isFat = <span class="literal">true</span>, hobbies = <span class="string">"study"</span> &#125; = obj;</span><br><span class="line"><span class="built_in">console</span>.log(name, age, gender, isFat, hobbies); <span class="comment">//"zhuangzhuang"，27，null，false，"study"</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>解构赋值的省略赋值</li>
</ol>
<p>当我们并不是需要取出所有的值的时候，其实可以省略一些变量，这就是省略赋值，如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> [, , c] = arr;</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>注意：省略赋值并不存在与对象解构，因为对象解构，明确了需要的属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"zhuangzhuang"</span>,</span><br><span class="line">  age: <span class="number">27</span>,</span><br><span class="line">  gender: <span class="string">"man"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; age &#125; = obj;</span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">//27</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>解构赋值的嵌套赋值(易错点，重点，难点)</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;,</span><br><span class="line">  arr = [];</span><br><span class="line"></span><br><span class="line">(&#123; <span class="attr">foo</span>: obj.prop, <span class="attr">bar</span>: arr[<span class="number">0</span>] &#125; = &#123; <span class="attr">foo</span>: <span class="number">123</span>, <span class="attr">bar</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj, arr); <span class="comment">//&#123;prop:123&#125;,[true]</span></span><br></pre></td></tr></table></figure>

<p>注意当解构出来是 undefined 的时候，如果再给子对象的属性，则会报错，如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">  foo: &#123; bar &#125;</span><br><span class="line">&#125; = &#123; <span class="attr">baz</span>: <span class="string">"baz"</span> &#125;;</span><br><span class="line"><span class="comment">//报错，原因很简单，看下原理即可，如下：</span></span><br><span class="line"><span class="comment">//原理:</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">baz</span>: <span class="string">"baz"</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> foo = obj.foo; <span class="comment">//foo为undefined</span></span><br><span class="line"><span class="keyword">let</span> bar = foo.bar; <span class="comment">//undefined的bar，可定报错</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>{}是块还是对象？</li>
</ol>
<p>当我们写解构赋值的时候，很容易犯一个错误——{}的作用是块还是对象混淆，举例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//举例一：</span></span><br><span class="line"><span class="keyword">let</span> &#123;a&#125; = &#123;<span class="attr">a</span>:<span class="string">"a"</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.loh(a);<span class="comment">//'a',这个很简单</span></span><br><span class="line"><span class="comment">//很多人觉得，以下这种写法也是可以的：</span></span><br><span class="line"><span class="keyword">let</span> a;</span><br><span class="line">&#123;a&#125; = &#123;<span class="attr">a</span>:<span class="string">"a"</span>&#125;;<span class="comment">//直接报错，因为此时a已经声明过了，在语法解析的时候，会将这一行的&#123;&#125;看做块结构，而“块=对象”，显然是语法错误，所以正确的做法是不将大括号写在开头，如下：</span></span><br><span class="line"><span class="keyword">let</span> a;</span><br><span class="line">(&#123;a&#125; = &#123;<span class="attr">a</span>:<span class="string">"a"</span>&#125;)</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>空解构</li>
</ol>
<p>按照之前写的，解构赋值，左边则为解构出来的属性名，当然，在这里，我们也可以不写任何属性名称，也不会又任何的语法错误，即便这样没有任何意义，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&#123;&#125; = [<span class="literal">true</span>, <span class="literal">false</span>]);</span><br><span class="line">(&#123;&#125; = <span class="string">"abc"</span>);</span><br><span class="line">(&#123;&#125; = []);</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>解构成对象的原则</li>
</ol>
<p>如果解构成对象，右侧不是 null 或者 undefined 即可!<br>之前说过，要解构成数组，右侧必须是可迭代对象，但是如果解构成对象，右侧不是 null 活着 undefined 即可!</p>
<p>三、字符串的解构赋值</p>
<p>字符串也是可以解构赋值的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c, d, e); <span class="comment">//'h','e','l','l','o'</span></span><br></pre></td></tr></table></figure>

<p>转成 es5 的原理如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _hello = <span class="string">"hello"</span>,</span><br><span class="line">  a = _hello[<span class="number">0</span>],</span><br><span class="line">  b = _hello[<span class="number">1</span>],</span><br><span class="line">  c = _hello[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a, b, c);</span><br></pre></td></tr></table></figure>

<p>注意：字符串有一个属性 length，也可以被解构出来，但是要注意，解构属性一定是对象解构</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; length &#125; = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(length); <span class="comment">//5</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>布尔值和数值的解构</li>
</ol>
<p>布尔值和数值的解构，其实就是对其包装对象的解构，取的是包装对象的属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">toString</span>:s&#125; = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s);<span class="comment">//s === Number.prototype.toString</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="attr">toString</span>:s&#125; = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s);<span class="comment">//s === Boolean.prototype.toString</span></span><br></pre></td></tr></table></figure>

<h3 id="总结：解构赋值的规则是："><a href="#总结：解构赋值的规则是：" class="headerlink" title="总结：解构赋值的规则是："></a>总结：解构赋值的规则是：</h3><blockquote>
<ol>
<li>解构成对象，只要等号右边的值不是对象或数组，就先将其转为对象。由于 undefined 和 null 无法转为对象，所以对它们进行解构赋值，都会报错。</li>
<li>解构成数组，等号右边必须为可迭代对象</li>
</ol>
</blockquote>
<p><a href="https://blog.csdn.net/qq_17175013/article/details/81490923" target="_blank" rel="noopener">参考</a></p>
<h3 id="Array-from-与-Array-reduce"><a href="#Array-from-与-Array-reduce" class="headerlink" title="Array.from() 与 Array.reduce()"></a>Array.from() 与 Array.reduce()</h3><p>Array.from()方法就是将一个类数组对象或者可遍历对象转换成一个真正的数组<br>Array.reduce()方法对累加器和数组中的每个元素 (从左到右)应用一个函数，将其减少为单个值。</p>
<p>解析：</p>
<p><strong>Array.from()</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 那么什么是类数组对象呢？所谓类数组对象，最基本的要求就是具有length属性的对象。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、将类数组对象转换为真正数组：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">"tom"</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">"65"</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">"男"</span>,</span><br><span class="line">  <span class="number">3</span>: [<span class="string">"jane"</span>, <span class="string">"john"</span>, <span class="string">"Mary"</span>],</span><br><span class="line">  length: <span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(arrayLike);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// ['tom','65','男',['jane','john','Mary']]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 那么，如果将上面代码中length属性去掉呢？实践证明，答案会是一个长度为0的空数组。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里将代码再改一下，就是具有length属性，但是对象的属性名不再是数字类型的，而是其他字符串型的，代码如下：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  name: <span class="string">"tom"</span>,</span><br><span class="line">  age: <span class="string">"65"</span>,</span><br><span class="line">  sex: <span class="string">"男"</span>,</span><br><span class="line">  friends: [<span class="string">"jane"</span>, <span class="string">"john"</span>, <span class="string">"Mary"</span>],</span><br><span class="line">  length: <span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(arrayLike);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ undefined, undefined, undefined, undefined ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 会发现结果是长度为4，元素均为undefined的数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由此可见，要将一个类数组对象转换为一个真正的数组，必须具备以下条件：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、该类数组对象必须具有length属性，用于指定数组的长度。如果没有length属性，那么转换后的数组是一个空数组。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、该类数组对象的属性名必须为数值型或字符串型的数字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ps: 该类数组对象的属性名可以加引号，也可以不加引号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、将Set结构的数据转换为真正的数组：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">12</span>, <span class="number">45</span>, <span class="number">97</span>, <span class="number">9797</span>, <span class="number">564</span>, <span class="number">134</span>, <span class="number">45642</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set(arr);</span><br><span class="line">console.log(Array.from(<span class="keyword">set</span>)); // [ 12, 45, 97, 9797, 564, 134, 45642 ]</span><br><span class="line"></span><br><span class="line">// 　Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。如下：</span><br><span class="line"></span><br><span class="line">let arr = [12, 45, 97, 9797, 564, 134, 45642];</span><br><span class="line">let <span class="keyword">set</span> = new Set(arr);</span><br><span class="line">console.log(Array.from(<span class="keyword">set</span>, item =&gt; item + 1)); // [ 13, 46, 98, 9798, 565, 135, 45643 ]</span><br><span class="line"></span><br><span class="line">// 3、将字符串转换为数组：</span><br><span class="line"></span><br><span class="line">let str = "hello world!";</span><br><span class="line">console.log(Array.from(str)); // ["h", "e", "l", "l", "o", " ", "w", "o", "r", "l", "d", "!"]</span><br><span class="line"></span><br><span class="line">// 4、Array.from参数是一个真正的数组：</span><br><span class="line"></span><br><span class="line">console.log(Array.from([12, 45, 47, 56, 213, 4654, 154]));</span><br><span class="line">// 像这种情况，Array.from会返回一个一模一样的新数组</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/jf-67/p/8440758.html" target="_blank" rel="noopener">参考</a></p>
<p><strong>Array.reduce()</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line"></span><br><span class="line">array.reduce(function(accumulator, currentValue, currentIndex, array), initialValue)；</span><br><span class="line"></span><br><span class="line">accumulator：累加器，即函数上一次调用的返回值。第一次的时候为 initialValue || arr[0]</span><br><span class="line"></span><br><span class="line">currentValue：数组中函数正在处理的的值。第一次的时候initialValue || arr[1]</span><br><span class="line"></span><br><span class="line">currentIndex：数据中正在处理的元素索引，如果提供了 initialValue ，从0开始；否则从1开始</span><br><span class="line"></span><br><span class="line">array： 调用 reduce 的数组</span><br><span class="line"></span><br><span class="line">initialValue：可选项，累加器的初始值。没有时，累加器第一次的值为currentValue；注意：在对没有设置初始值的空数组调用reduce方法时会报错。</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无初始值</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">accumulator, currentValue, currentIndex, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> accumulator + currentValue;</span><br><span class="line">&#125;); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>callback</th>
<th>accumulator</th>
<th>currentValue</th>
<th>currentIndex</th>
<th>array</th>
<th>return value</th>
</tr>
</thead>
<tbody><tr>
<td>first call</td>
<td>1(数组第一个元素)</td>
<td>2(数组第二个元素)</td>
<td>1(无初始值为 1)</td>
<td>[1, 2, 3, 4]</td>
<td>3</td>
</tr>
<tr>
<td>second call</td>
<td>3</td>
<td>3</td>
<td>2</td>
<td>[1, 2, 3, 4]</td>
<td>6</td>
</tr>
<tr>
<td>third call</td>
<td>6</td>
<td>4</td>
<td>3</td>
<td>[1, 2, 3, 4]</td>
<td>10</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有初始值</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">accumulator, currentValue, currentIndex, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> accumulator + currentValue;</span><br><span class="line">&#125;, <span class="number">10</span>); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>callback</th>
<th>accumulator</th>
<th>currentValue</th>
<th>currentIndex</th>
<th>array</th>
<th>return value</th>
</tr>
</thead>
<tbody><tr>
<td>first call</td>
<td>10(初始值)</td>
<td>1(数组第一个元素)</td>
<td>0(有初始值为 0)</td>
<td>[1, 2, 3, 4]</td>
<td>11</td>
</tr>
<tr>
<td>second call</td>
<td>11</td>
<td>2</td>
<td>1</td>
<td>[1, 2, 3, 4]</td>
<td>13</td>
</tr>
<tr>
<td>third call</td>
<td>13</td>
<td>3</td>
<td>2</td>
<td>[1, 2, 3, 4]</td>
<td>16</td>
</tr>
<tr>
<td>fourth call</td>
<td>16</td>
<td>4</td>
<td>3</td>
<td>[1, 2, 3, 4]</td>
<td>20</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.数组元素求和</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b); <span class="comment">//10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.二维数组转化为一维数组</span></span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line">  .reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.concat(b), []) <span class="comment">//[1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line">  [</span><br><span class="line">    <span class="comment">//3.计算数组中元素出现的次数</span></span><br><span class="line">    (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">  ].reduce(<span class="function">(<span class="params">items, item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item <span class="keyword">in</span> items) &#123;</span><br><span class="line">      items[item]++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      items[item] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> items;</span><br><span class="line">  &#125;, &#123;&#125;) <span class="comment">//&#123;1: 2, 2: 2, 3: 2, 4: 1&#125;</span></span><br><span class="line"></span><br><span class="line">  [</span><br><span class="line">    <span class="comment">//数组去重①</span></span><br><span class="line">    (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">  ].reduce(<span class="function">(<span class="params">init, current</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (init.length === <span class="number">0</span> || init.indexOf(current) === <span class="number">-1</span>) &#123;</span><br><span class="line">      init.push(current);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">  &#125;, []) <span class="comment">//[1, 2, 3, 4, 5]</span></span><br><span class="line">  [</span><br><span class="line">    <span class="comment">//数组去重②</span></span><br><span class="line">    (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">  ].sort()</span><br><span class="line">  .reduce(<span class="function">(<span class="params">init, current</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (init.length === <span class="number">0</span> || init[init.length - <span class="number">1</span>] !== current) &#123;</span><br><span class="line">      init.push(current);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">  &#125;, []); <span class="comment">//[1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/xuejiangjun/p/8523313.html" target="_blank" rel="noopener">参考</a></p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2023-04-14T17:01:50.000Z" itemprop="dateUpdated">2023-04-15 01:01:50</time>
</span><br>


        
        感谢您的阅读，欢迎评论(*^▽^*) 转载请附上本文链接：<a href="/qw8/interview/es6.html" target="_blank" rel="external">https://qw8.github.io/qw8/interview/es6.html</a>
        
    </div>
    
    <footer>
        <a href="https://qw8.github.io/qw8">
            <img src="/qw8/img/avatar.jpg" alt="秦伟">
            秦伟
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/qw8/tags/ES6/">ES6</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/qw8/tags/JavaScript/">JavaScript</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://qw8.github.io/qw8/interview/es6.html&title=《ES6》 — 秦伟博客&pic=https://qw8.github.io/qw8/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://qw8.github.io/qw8/interview/es6.html&title=《ES6》 — 秦伟博客&source=前端、全栈、SEO的知识点、面试题与学习链接的整理" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://qw8.github.io/qw8/interview/es6.html" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《ES6》 — 秦伟博客&url=https://qw8.github.io/qw8/interview/es6.html&via=https://qw8.github.io/qw8" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://qw8.github.io/qw8/interview/es6.html" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/qw8/knowledges/yarn.html" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">yarn</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/qw8/knowledges/html-zhi-shi-dian.html" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">HTML知识点</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'false' == 'true',
            appId: "TJ17Ax10JrfIIljlO8qkwGvz-gzGzoHsz",
            appKey: "jDGQKdWT9hlzsTLRAbInE4bK",
            avatar: "mm",
            placeholder: "说点什么吧(*╹▽╹*)",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->










</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢您，我会继续努力哒(*^▽^*)
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/qw8/img/wechat.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/qw8/img/wechat.png" data-alipay="/qw8/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

    <footer class="footer">
    <div class="top">
        <div class="map">
            <!--地球信息-->
<script type="text/javascript" src="/js/jquery-3.4.1.js"></script>
<script type="text/javascript">
    var windowWidth = $(window).width();
    if (windowWidth > 480) {
        document.write('<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5mz4gy0w2d8&amp;m=0&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33" async="async">  <\/script>');
    }
</script>
        </div>
        <p>
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>

</p>
        <p>
            <span>本网站总字数：832.3k</span>
            <span id="sitetime"></span>
        </p>
        <p>部分内容来源于互联网，用于个人知识的总结，如有侵权还请联系删除</p>
        <p>
            
            <span><a href="/qw8/atom.xml" target="_blank" class="rss" title="rss"><i
                    class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>

    <div class="bottom">
        <p>
            <span>Copyright &copy; 2019 - 2024 <a
                href="http://pdouyin.com/" target="_blank">秦伟的个人博客</a> All Rights Reserved.</span>
            <!-- <span>
                
                
            </span> -->
        </p>
    </div>
</footer>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2019, 8, 25, 18, 0, 0); // 北京时间
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "已安全运行 " + diffYears + "年 " + diffDays + "天 " + diffHours + "小时 " + diffMinutes + "分钟 " + diffSeconds + "秒";
    }
    siteTime();
</script>
</main>
<div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://qw8.github.io/qw8/interview/es6.html&title=《ES6》 — 秦伟博客&pic=https://qw8.github.io/qw8/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://qw8.github.io/qw8/interview/es6.html&title=《ES6》 — 秦伟博客&source=前端、全栈、SEO的知识点、面试题与学习链接的整理" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://qw8.github.io/qw8/interview/es6.html" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《ES6》 — 秦伟博客&url=https://qw8.github.io/qw8/interview/es6.html&via=https://qw8.github.io/qw8" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://qw8.github.io/qw8/interview/es6.html" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACIElEQVR42u3aQW7DMAwEwPz/0+m5hzq7lFNA8vgUGLHN0YGgSL1e8fX+47r+Z/62/NmlCwMDY1vG+/Ja+fD1P9v3f1hEDAyMBzCSINrQ8wyZUD98BQMDAyMIbr1YzL+LgYGBkbwuLyhXnsLAwMC469Vtiy0pEL+4F8fAwNiQkW84///3V+YbGBgYWzHe5ZU08dtUPovk13swMDCOZrSttJUSrT2u0Q4VMDAwzma0iW9WPq4El9zBwMA4m5GXerOjErNWXf4sBgbG2YzZ9nIl4SZFYbuUGBgYZzNmiTJvwyWlXrtw0SQWAwPjUMa929GVlF3vvDEwMB7DyMNtt695+6wF1KUhBgbG5ox8a9qWg/mi5EPNehKLgYGxOaMNdyUF5yVm/i0MDIyzGXkCzZtl+fGI9hDGsLbFwMA4gpGn1HZ4eV0C5qPK6LAFBgbGAxjDZBcMEtqBQR0VBgbG0YzZ1rE9DLE++GyTOwYGxtMYs9Bnm+R8CeqEi4GBsTkjL9Fmd75B/dA7xMDAOJSRlID50YrZUYyV1IyBgfFkxoyaF5pti60+LYKBgbE5YyWltkPNLw4MMDAwjmbc1aa/l5QPRGsYBgbGtoxZkZffn4V+vUB1gYiBgXEEIwllFsRsSNkWjhgYGBhtQqx7fkGajppuGBgYGHHSvKa2e+jozRgYGA9gzEq6/MOzpHy9xBgYGM9hrKS8YpMZB9EeHcPAwDia8QPlLZNh5v8F4gAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/qw8/', SHARE: true, REWARD: true };


</script>

<script src="/qw8/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/qw8/js/search.min.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '(つェ⊂)咦!跑去哪里了';
            clearTimeout(titleTime);
        } else {
            document.title = '欢迎回来━(*｀∀´*)ノ';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>




<!-- 点击特效 -->
<script type="text/javascript" src="/js/clicklove.js"></script>
<!--动态线条背景-->
<script type="text/javascript"
        color="220,220,220" opacity='0.7' zIndex="-2" count="200"
        src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>
<!-- 雪花特效 -->
<script type="text/javascript" src="/js/jquery-3.4.1.js"></script>
<script type="text/javascript">
    var windowWidth = $(window).width();
    if (windowWidth > 480) {
        document.write('<script type="text/javascript" src="/js/snow.js"><\/script>');
    }
</script>

<script>!function(e){var r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function t(){for(var c=0;c<r.length;c++)t=r[c],void 0,0<=(n=t.getBoundingClientRect()).top&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=r[c];t=o,n=function(){r=r.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}t(),e.addEventListener("scroll",function(){!function(t,n){clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)}(t,e)})}(this);</script><script src="/qw8/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/qw8/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"position":"right","width":150,"height":300,"hOffset":-25,"vOffset":30},"mobile":{"show":false,"scale":1.2},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>

<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>JavaScript面试题 | 秦伟博客 | 前端、全栈、SEO的知识点、面试题与学习链接的整理</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="JavaScript,DOM,BOM">
    <meta name="description" content="1.undefined 和 null 有什么区别？在理解undefined和null之间的差异之前，我们先来看看它们的相似类。 它们属于 JavaScript 的 7 种基本类型。 1let primitiveTypes = [&amp;apos;string&amp;apos;,&amp;apos;number&amp;apos;,&amp;apos;null&amp;apos;,&amp;apos;undefined&amp;apos;,&amp;apos;boo">
<meta name="keywords" content="JavaScript,DOM,BOM">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript面试题">
<meta property="og:url" content="https://qw8.github.io/interview/javascript-mian-shi-ti.html">
<meta property="og:site_name" content="秦伟博客">
<meta property="og:description" content="1.undefined 和 null 有什么区别？在理解undefined和null之间的差异之前，我们先来看看它们的相似类。 它们属于 JavaScript 的 7 种基本类型。 1let primitiveTypes = [&amp;apos;string&amp;apos;,&amp;apos;number&amp;apos;,&amp;apos;null&amp;apos;,&amp;apos;undefined&amp;apos;,&amp;apos;boo">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:updated_time" content="2024-02-18T06:46:10.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript面试题">
<meta name="twitter:description" content="1.undefined 和 null 有什么区别？在理解undefined和null之间的差异之前，我们先来看看它们的相似类。 它们属于 JavaScript 的 7 种基本类型。 1let primitiveTypes = [&amp;apos;string&amp;apos;,&amp;apos;number&amp;apos;,&amp;apos;null&amp;apos;,&amp;apos;undefined&amp;apos;,&amp;apos;boo">
<meta name="twitter:image" content="https://qw8.github.io/img/loading.gif">
    
        <link rel="alternate" type="application/atom+xml" title="秦伟博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/qw.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
<div id="loading" class="active"></div>

<aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">秦伟</h5>
          <a href="mailto:124729081@qq.com" title="124729081@qq.com" class="mail">124729081@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-hourglass"></i>
                时光
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://wpa.qq.com/msgrd?v=3&uin=124729081&site=qq&menu=yes" target="_blank" >
                <i class="icon icon-lg icon-qq"></i>
                聊天
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=124729081@qq.com"  >
                <i class="icon icon-lg icon-envelope-o"></i>
                邮箱
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/user"  >
                <i class="icon icon-lg icon-user"></i>
                简介
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://gitee.com/qw66" target="_blank" >
                <i class="icon icon-lg icon-code"></i>
                Gitee
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/qw8" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

<main id="main">
    <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">JavaScript面试题</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">JavaScript面试题</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-06-15T02:24:57.000Z" itemprop="datePublished" class="page-time">
  2020-06-15
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/前端面试题/">前端面试题</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-undefined-和-null-有什么区别？"><span class="post-toc-number">1.</span> <span class="post-toc-text">1.undefined 和 null 有什么区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-amp-amp-运算符能做什么"><span class="post-toc-number">2.</span> <span class="post-toc-text">2. &amp;&amp; 运算符能做什么</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-运算符能做什么"><span class="post-toc-number">3.</span> <span class="post-toc-text">3. || 运算符能做什么</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-使用-或一元加运算符是将字符串转换为数字的最快方法吗？"><span class="post-toc-number">4.</span> <span class="post-toc-text">4. 使用 + 或一元加运算符是将字符串转换为数字的最快方法吗？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-DOM-是什么？"><span class="post-toc-number">5.</span> <span class="post-toc-text">5. DOM 是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-什么是事件传播"><span class="post-toc-number">6.</span> <span class="post-toc-text">6. 什么是事件传播?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-什么是事件冒泡？"><span class="post-toc-number">7.</span> <span class="post-toc-text">7. 什么是事件冒泡？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8-什么是事件捕获？"><span class="post-toc-number">8.</span> <span class="post-toc-text">8. 什么是事件捕获？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#9-event-preventDefault-和-event-stopPropagation-方法之间有什么区别？"><span class="post-toc-number">9.</span> <span class="post-toc-text">9. event.preventDefault() 和 event.stopPropagation()方法之间有什么区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#10-如何知道是否在元素中使用了event-preventDefault-方法？"><span class="post-toc-number">10.</span> <span class="post-toc-text">10. 如何知道是否在元素中使用了event.preventDefault()方法？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#11-为什么此代码-obj-someprop-x-会引发错误"><span class="post-toc-number">11.</span> <span class="post-toc-text">11. 为什么此代码 obj.someprop.x 会引发错误?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#12-什么是-event-target-？"><span class="post-toc-number">12.</span> <span class="post-toc-text">12. 什么是 event.target ？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#13-什么是-event-currentTarget？？"><span class="post-toc-number">13.</span> <span class="post-toc-text">13. 什么是 event.currentTarget？？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#14-和-有什么区别？"><span class="post-toc-number">14.</span> <span class="post-toc-text">14. == 和 === 有什么区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#15-为什么在-JS-中比较两个相似的对象时返回-false？"><span class="post-toc-number">15.</span> <span class="post-toc-text">15. 为什么在 JS 中比较两个相似的对象时返回 false？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#16-运算符能做什么？"><span class="post-toc-number">16.</span> <span class="post-toc-text">16. !! 运算符能做什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#17-如何在一行中计算多个表达式的值？"><span class="post-toc-number">17.</span> <span class="post-toc-text">17. 如何在一行中计算多个表达式的值？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#18-什么是提升？"><span class="post-toc-number">18.</span> <span class="post-toc-text">18. 什么是提升？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#19-什么是作用域？"><span class="post-toc-number">19.</span> <span class="post-toc-text">19. 什么是作用域？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#20-什么是闭包？"><span class="post-toc-number">20.</span> <span class="post-toc-text">20. 什么是闭包？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#21-JavaScript-中的虚值是什么？"><span class="post-toc-number">21.</span> <span class="post-toc-text">21. JavaScript 中的虚值是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#22-如何检查值是否虚值？"><span class="post-toc-number">22.</span> <span class="post-toc-text">22. 如何检查值是否虚值？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#23-‘use-strict’-是干嘛用的？"><span class="post-toc-number">23.</span> <span class="post-toc-text">23. ‘use strict’ 是干嘛用的？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#24-JavaScript-中-this-值是什么？"><span class="post-toc-number">24.</span> <span class="post-toc-text">24. JavaScript 中 this 值是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#25-对象的-prototype-原型-是什么？"><span class="post-toc-number">25.</span> <span class="post-toc-text">25. 对象的 prototype(原型) 是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#26-什么是-IIFE，它的用途是什么？"><span class="post-toc-number">26.</span> <span class="post-toc-text">26. 什么是 IIFE，它的用途是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#27-Function-prototype-apply-方法的用途是什么？"><span class="post-toc-number">27.</span> <span class="post-toc-text">27. Function.prototype.apply 方法的用途是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#28-Function-prototype-call-方法的用途是什么？"><span class="post-toc-number">28.</span> <span class="post-toc-text">28. Function.prototype.call 方法的用途是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#29-Function-prototype-apply-和-Function-prototype-call-之间有什么区别？"><span class="post-toc-number">29.</span> <span class="post-toc-text">29. Function.prototype.apply 和 Function.prototype.call 之间有什么区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#30-Function-prototype-bind-的用途是什么？"><span class="post-toc-number">30.</span> <span class="post-toc-text">30. Function.prototype.bind 的用途是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#31-什么是函数式编程-JavaScript-的哪些特性使其成为函数式语言的候选语言？"><span class="post-toc-number">31.</span> <span class="post-toc-text">31. 什么是函数式编程? JavaScript 的哪些特性使其成为函数式语言的候选语言？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#32-什么是高阶函数？"><span class="post-toc-number">32.</span> <span class="post-toc-text">32. 什么是高阶函数？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#33-为什么函数被称为一等公民？"><span class="post-toc-number">33.</span> <span class="post-toc-text">33. 为什么函数被称为一等公民？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#34-手动实现-Array-prototype-map-方法"><span class="post-toc-number">34.</span> <span class="post-toc-text">34. 手动实现 Array.prototype.map 方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#35-手动实现Array-prototype-filter方法"><span class="post-toc-number">35.</span> <span class="post-toc-text">35. 手动实现Array.prototype.filter方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#36-手动实现Array-prototype-reduce方法"><span class="post-toc-number">36.</span> <span class="post-toc-text">36. 手动实现Array.prototype.reduce方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#37-arguments-的对象是什么？"><span class="post-toc-number">37.</span> <span class="post-toc-text">37. arguments 的对象是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#38-如何创建一个没有-prototype-原型-的对象？"><span class="post-toc-number">38.</span> <span class="post-toc-text">38. 如何创建一个没有 prototype(原型)的对象？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#39-为什么在调用这个函数时，代码中的b会变成一个全局变量"><span class="post-toc-number">39.</span> <span class="post-toc-text">39. 为什么在调用这个函数时，代码中的b会变成一个全局变量?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#40-ECMAScript-是什么？"><span class="post-toc-number">40.</span> <span class="post-toc-text">40. ECMAScript 是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#41-ES6或ECMAScript-2015有哪些新特性？"><span class="post-toc-number">41.</span> <span class="post-toc-text">41. ES6或ECMAScript 2015有哪些新特性？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#42-var-let和const的区别是什么？"><span class="post-toc-number">42.</span> <span class="post-toc-text">42. var,let和const的区别是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#43-什么是箭头函数？"><span class="post-toc-number">43.</span> <span class="post-toc-text">43. 什么是箭头函数？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#44-什么是类？"><span class="post-toc-number">44.</span> <span class="post-toc-text">44. 什么是类？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#45-什么是模板字符串？"><span class="post-toc-number">45.</span> <span class="post-toc-text">45. 什么是模板字符串？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#46-什么是对象解构？"><span class="post-toc-number">46.</span> <span class="post-toc-text">46. 什么是对象解构？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#47-什么是-ES6-模块？"><span class="post-toc-number">47.</span> <span class="post-toc-text">47. 什么是 ES6 模块？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#48-什么是Set对象，它是如何工作的？"><span class="post-toc-number">48.</span> <span class="post-toc-text">48. 什么是Set对象，它是如何工作的？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#49-什么是回调函数？"><span class="post-toc-number">49.</span> <span class="post-toc-text">49. 什么是回调函数？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#50-Promise-是什么？"><span class="post-toc-number">50.</span> <span class="post-toc-text">50. Promise 是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#51-什么是-async-await-及其如何工作？"><span class="post-toc-number">51.</span> <span class="post-toc-text">51. 什么是 async/await 及其如何工作？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#52-展开-spread-运算符和-剩余-Rest-运算符有什么区别？"><span class="post-toc-number">52.</span> <span class="post-toc-text">52. 展开(spread )运算符和 剩余(Rest) 运算符有什么区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#53-什么是默认参数？"><span class="post-toc-number">53.</span> <span class="post-toc-text">53. 什么是默认参数？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#54-什么是包装对象（wrapper-object）？"><span class="post-toc-number">54.</span> <span class="post-toc-text">54. 什么是包装对象（wrapper object）？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#55-隐式和显式转换有什么区别）？"><span class="post-toc-number">55.</span> <span class="post-toc-text">55. 隐式和显式转换有什么区别）？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#56-什么是NaN？以及如何检查值是否为NaN？"><span class="post-toc-number">56.</span> <span class="post-toc-text">56. 什么是NaN？以及如何检查值是否为NaN？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#57-如何判断值是否为数组？"><span class="post-toc-number">57.</span> <span class="post-toc-text">57. 如何判断值是否为数组？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#58-如何在不使用-模运算符的情况下检查一个数字是否是偶数？"><span class="post-toc-number">58.</span> <span class="post-toc-text">58. 如何在不使用%模运算符的情况下检查一个数字是否是偶数？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#59-如何检查对象中是否存在某个属性？"><span class="post-toc-number">59.</span> <span class="post-toc-text">59. 如何检查对象中是否存在某个属性？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#60-AJAX-是什么？"><span class="post-toc-number">60.</span> <span class="post-toc-text">60. AJAX 是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#61-如何在-JS-中创建对象？"><span class="post-toc-number">61.</span> <span class="post-toc-text">61. 如何在 JS 中创建对象？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#62-Object-seal-和-Object-freeze-方法之间有什么区别？"><span class="post-toc-number">62.</span> <span class="post-toc-text">62. Object.seal 和 Object.freeze 方法之间有什么区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#63-in-运算符和-Object-hasOwnProperty-方法有什么区别？"><span class="post-toc-number">63.</span> <span class="post-toc-text">63. in 运算符和 Object.hasOwnProperty 方法有什么区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#64-有哪些方法可以处理-JS-中的异步代码？"><span class="post-toc-number">64.</span> <span class="post-toc-text">64. 有哪些方法可以处理 JS 中的异步代码？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#65-函数表达式和函数声明之间有什么区别？"><span class="post-toc-number">65.</span> <span class="post-toc-text">65. 函数表达式和函数声明之间有什么区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#66-调用函数，可以使用哪些方法？"><span class="post-toc-number">66.</span> <span class="post-toc-text">66. 调用函数，可以使用哪些方法？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#67-什么是缓存及它有什么作用？"><span class="post-toc-number">67.</span> <span class="post-toc-text">67. 什么是缓存及它有什么作用？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#68-手动实现缓存方法"><span class="post-toc-number">68.</span> <span class="post-toc-text">68. 手动实现缓存方法]</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#69-为什么typeof-null-返回-object？如何检查一个值是否为-null？"><span class="post-toc-number">69.</span> <span class="post-toc-text">69. 为什么typeof null 返回 object？如何检查一个值是否为 null？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#70-new-关键字有什么作用？"><span class="post-toc-number">70.</span> <span class="post-toc-text">70. new 关键字有什么作用？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#71-什么时候不使用箭头函数-说出三个或更多的例子？"><span class="post-toc-number">71.</span> <span class="post-toc-text">71. 什么时候不使用箭头函数? 说出三个或更多的例子？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#72-Object-freeze-和-const-的区别是什么？"><span class="post-toc-number">72.</span> <span class="post-toc-text">72. Object.freeze() 和 const 的区别是什么？]</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#73-如何在-JS-中“深冻结”对象？"><span class="post-toc-number">73.</span> <span class="post-toc-text">73. 如何在 JS 中“深冻结”对象？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#74-Iterator是什么，有什么作用？"><span class="post-toc-number">74.</span> <span class="post-toc-text">74. Iterator是什么，有什么作用？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#75-Generator-函数是什么，有什么作用？"><span class="post-toc-number">75.</span> <span class="post-toc-text">75. Generator 函数是什么，有什么作用？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-new的实现原理是什么？"><span class="post-toc-number">76.</span> <span class="post-toc-text">1. new的实现原理是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-如何正确判断this的指向？"><span class="post-toc-number">77.</span> <span class="post-toc-text">2. 如何正确判断this的指向？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#全局环境中的-this"><span class="post-toc-number">77.1.</span> <span class="post-toc-text">全局环境中的 this</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#是否是-new-绑定"><span class="post-toc-number">77.2.</span> <span class="post-toc-text">是否是 new 绑定</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#函数是否通过-call-apply-调用，或者使用了-bind-绑定，如果是，那么this绑定的就是指定的对象【归结为显式绑定】。"><span class="post-toc-number">77.3.</span> <span class="post-toc-text">函数是否通过 call,apply 调用，或者使用了 bind 绑定，如果是，那么this绑定的就是指定的对象【归结为显式绑定】。</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#隐式绑定，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的隐式调用为-xxx-fn"><span class="post-toc-number">77.4.</span> <span class="post-toc-text">隐式绑定，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的隐式调用为: xxx.fn()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用。"><span class="post-toc-number">77.5.</span> <span class="post-toc-text">默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用。</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#箭头函数的情况："><span class="post-toc-number">77.6.</span> <span class="post-toc-text">箭头函数的情况：</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-深拷贝和浅拷贝的区别是什么？实现一个深拷贝"><span class="post-toc-number">78.</span> <span class="post-toc-text">3. 深拷贝和浅拷贝的区别是什么？实现一个深拷贝</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#深拷贝"><span class="post-toc-number">78.1.</span> <span class="post-toc-text">深拷贝</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#浅拷贝"><span class="post-toc-number">78.2.</span> <span class="post-toc-text">浅拷贝</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#深拷贝实现"><span class="post-toc-number">78.3.</span> <span class="post-toc-text">深拷贝实现</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-call-apply-的实现原理是什么？"><span class="post-toc-number">79.</span> <span class="post-toc-text">4. call/apply 的实现原理是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-柯里化函数实现"><span class="post-toc-number">80.</span> <span class="post-toc-text">5. 柯里化函数实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-如何让-a-1-amp-amp-a-2-amp-amp-a-3-的值为true？"><span class="post-toc-number">81.</span> <span class="post-toc-text">6. 如何让 (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) 的值为true？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-什么是BFC？BFC的布局规则是什么？如何创建BFC？"><span class="post-toc-number">82.</span> <span class="post-toc-text">7. 什么是BFC？BFC的布局规则是什么？如何创建BFC？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8-异步加载JS脚本的方式有哪些？"><span class="post-toc-number">83.</span> <span class="post-toc-text">8. 异步加载JS脚本的方式有哪些？</span></a></li></ol>
        </nav>
    </aside>


<article id="post-interview/JavaScript面试题"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">JavaScript面试题</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-06-15 10:24:57" datetime="2020-06-15T02:24:57.000Z"  itemprop="datePublished">2020-06-15</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/前端面试题/">前端面试题</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h3 id="1-undefined-和-null-有什么区别？"><a href="#1-undefined-和-null-有什么区别？" class="headerlink" title="1.undefined 和 null 有什么区别？"></a>1.undefined 和 null 有什么区别？</h3><p>在理解<code>undefined</code>和<code>null</code>之间的差异之前，我们先来看看它们的相似类。</p>
<p><strong>它们属于 JavaScript 的 7 种基本类型。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let primitiveTypes = [&apos;string&apos;,&apos;number&apos;,&apos;null&apos;,&apos;undefined&apos;,&apos;boolean&apos;,&apos;symbol&apos;, &apos;bigint&apos;];</span><br></pre></td></tr></table></figure>

<p>它们是属于虚值，可以使用<code>Boolean(value)</code>或<code>!!value</code>将其转换为布尔值时，值为<code>false</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(!!null); // false</span><br><span class="line">console.log(!!undefined); // false</span><br><span class="line"></span><br><span class="line">console.log(Boolean(null)); // false</span><br><span class="line">console.log(Boolean(undefined)); // false</span><br></pre></td></tr></table></figure>

<p>接着来看看它们的区别。</p>
<p><code>undefined</code>是未指定特定值的变量的默认值，或者没有显式返回值的函数，如：<code>console.log(1)</code>，还包括对象中不存在的属性，这些 JS 引擎都会为其分配 <code>undefined</code> 值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let _thisIsUndefined;</span><br><span class="line">const doNothing = () =&gt; &#123;&#125;;</span><br><span class="line">const someObj = &#123;</span><br><span class="line">  a : &quot;ay&quot;,</span><br><span class="line">  b : &quot;bee&quot;,</span><br><span class="line">  c : &quot;si&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(_thisIsUndefined); // undefined</span><br><span class="line">console.log(doNothing()); // undefined</span><br><span class="line">console.log(someObj[&quot;d&quot;]); // undefined</span><br></pre></td></tr></table></figure>

<p><code>null</code>是<strong>“不代表任何值的值”</strong>。<code>null</code>是已明确定义给变量的值。在此示例中，当<code>fs.readFile</code>方法未引发错误时，我们将获得<code>null</code>值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&apos;path/to/file&apos;, (e,data) =&gt; &#123;</span><br><span class="line">   console.log(e); // 当没有错误发生时，打印 null</span><br><span class="line">   if(e)&#123;</span><br><span class="line">     console.log(e);</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(data);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<p>在比较<code>null</code>和<code>undefined</code>时，我们使用<code>==</code>时得到<code>true</code>，使用<code>===</code>时得到<code>false</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(null == undefined); // true</span><br><span class="line">console.log(null === undefined); // false</span><br></pre></td></tr></table></figure>

<h3 id="2-amp-amp-运算符能做什么"><a href="#2-amp-amp-运算符能做什么" class="headerlink" title="2. &amp;&amp; 运算符能做什么"></a>2. &amp;&amp; 运算符能做什么</h3><p><code>&amp;&amp;</code> 也可以叫<strong>逻辑与</strong>，在其操作数中找到第一个虚值表达式并返回它，如果没有找到任何虚值表达式，则返回最后一个真值表达式。它采用短路来防止不必要的工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(false &amp;&amp; 1 &amp;&amp; []); // false</span><br><span class="line">console.log(&quot; &quot; &amp;&amp; true &amp;&amp; 5); // 5</span><br></pre></td></tr></table></figure>

<p><strong>使用<code>if</code>语句</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const router: Router = Router();</span><br><span class="line"></span><br><span class="line">router.get(&apos;/endpoint&apos;, (req: Request, res: Response) =&gt; &#123;</span><br><span class="line">   let conMobile: PoolConnection;</span><br><span class="line">   try &#123;</span><br><span class="line">      //do some db operations</span><br><span class="line">   &#125; catch (e) &#123;</span><br><span class="line">   if (conMobile) &#123;</span><br><span class="line">    conMobile.release();</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>使用<code>&amp;&amp;</code>操作符</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const router: Router = Router();</span><br><span class="line"></span><br><span class="line">router.get(&apos;/endpoint&apos;, (req: Request, res: Response) =&gt; &#123;</span><br><span class="line">  let conMobile: PoolConnection;</span><br><span class="line">  try &#123;</span><br><span class="line">     //do some db operations</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    conMobile &amp;&amp; conMobile.release()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="3-运算符能做什么"><a href="#3-运算符能做什么" class="headerlink" title="3. || 运算符能做什么"></a>3. || 运算符能做什么</h3><p><code>||</code>也叫或<code>逻辑或</code>，在其操作数中找到第一个真值表达式并返回它。这也使用了短路来防止不必要的工作。在支持 ES6 默认函数参数之前，它用于初始化函数中的默认参数值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">console.log(null || 1 || undefined); // 1</span><br><span class="line"></span><br><span class="line">function logName(name) &#123;</span><br><span class="line">  var n = name || &quot;Mark&quot;;</span><br><span class="line">  console.log(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logName(); // &quot;Mark&quot;</span><br></pre></td></tr></table></figure>

<h3 id="4-使用-或一元加运算符是将字符串转换为数字的最快方法吗？"><a href="#4-使用-或一元加运算符是将字符串转换为数字的最快方法吗？" class="headerlink" title="4. 使用 + 或一元加运算符是将字符串转换为数字的最快方法吗？"></a>4. 使用 + 或一元加运算符是将字符串转换为数字的最快方法吗？</h3><p>根据MDN文档，<code>+</code>是将字符串转换为数字的最快方法，因为如果值已经是数字，它不会执行任何操作。</p>
<h3 id="5-DOM-是什么？"><a href="#5-DOM-是什么？" class="headerlink" title="5. DOM 是什么？"></a>5. DOM 是什么？</h3><p><strong>DOM</strong> 代表<strong>文档对象模型</strong>，是 HTML 和 XML 文档的接口(API)。当浏览器第一次读取(解析)HTML文档时，它会创建一个大对象，一个基于 HTM L文档的非常大的对象，这就是<strong>DOM</strong>。它是一个从 HTML 文档中建模的树状结构。DOM 用于交互和修改DOM结构或特定元素或节点。</p>
<p>假设我们有这样的 HTML 结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">   &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">   &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">   &lt;title&gt;Document Object Model&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">   &lt;div&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">         &lt;span&gt;&lt;/span&gt;</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">      &lt;label&gt;&lt;/label&gt;</span><br><span class="line">      &lt;input&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>等价的<strong>DOM</strong>是这样的：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/LDPLltmNy57ianicNyt0G9GEGibARafiazZKV0Y332hOUmFjQYBIYcXTm37FgzYBmsCFpKKjqnY9fm9r6NMvQSib0rw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片](https://mmbiz.qpic.cn/mmbiz_png/LDPLltmNy57ianicNyt0G9GEGibARafiazZKV0Y332hOUmFjQYBIYcXTm37FgzYBmsCFpKKjqnY9fm9r6NMvQSib0rw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)![图片" title>
                </div>
                <div class="image-caption">图片](https://mmbiz.qpic.cn/mmbiz_png/LDPLltmNy57ianicNyt0G9GEGibARafiazZKV0Y332hOUmFjQYBIYcXTm37FgzYBmsCFpKKjqnY9fm9r6NMvQSib0rw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)![图片</div>
            </figure>

<p>JS 中的<code>document</code>对象表示DOM。它为我们提供了许多方法，我们可以使用这些方法来选择元素来更新元素内容，等等。</p>
<h3 id="6-什么是事件传播"><a href="#6-什么是事件传播" class="headerlink" title="6. 什么是事件传播?"></a>6. 什么是事件传播?</h3><p>当<strong>事件</strong>发生在<strong>DOM</strong>元素上时，该<strong>事件</strong>并不完全发生在那个元素上。在<strong>“冒泡阶段”</strong>中，事件冒泡或向上传播至父级，祖父母，祖父母或父级，直到到达<code>window</code>为止；而在<strong>“捕获阶段”</strong>中，事件从<code>window</code>开始向下触发元素 事件或<code>event.target</code>。</p>
<p>事件传播有三个阶段：</p>
<ol>
<li><strong>捕获阶段</strong>–事件从 <code>window</code> 开始，然后向下到每个元素，直到到达目标元素。</li>
<li><strong>目标阶段</strong>–事件已达到目标元素。</li>
<li><strong>冒泡阶段</strong>–事件从目标元素冒泡，然后上升到每个元素，直到到达 <code>window</code>。</li>
</ol>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/LDPLltmNy57ianicNyt0G9GEGibARafiazZKYwkJmmSmticQRSmsI0k78CTiaG6Ccia6eNRKS9usV3bO154uCLPep1DUQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>



<h3 id="7-什么是事件冒泡？"><a href="#7-什么是事件冒泡？" class="headerlink" title="7. 什么是事件冒泡？"></a>7. 什么是事件冒泡？</h3><p>当<strong>事件</strong>发生在<strong>DOM</strong>元素上时，该<strong>事件</strong>并不完全发生在那个元素上。在冒泡阶段，事件冒泡，或者事件发生在它的父代，祖父母，祖父母的父代，直到到达<code>window</code>为止。</p>
<p>假设有如下的 HTML 结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;grandparent&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;child&quot;&gt;1&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>对应的 JS 代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function addEvent(el, event, callback, isCapture = false) &#123;</span><br><span class="line">  if (!el || !event || !callback || typeof callback !== &apos;function&apos;) return;</span><br><span class="line">  if (typeof el === &apos;string&apos;) &#123;</span><br><span class="line">    el = document.querySelector(el);</span><br><span class="line">  &#125;;</span><br><span class="line">  el.addEventListener(event, callback, isCapture);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addEvent(document, &apos;DOMContentLoaded&apos;, () =&gt; &#123;</span><br><span class="line">  const child = document.querySelector(&apos;.child&apos;);</span><br><span class="line">  const parent = document.querySelector(&apos;.parent&apos;);</span><br><span class="line">  const grandparent = document.querySelector(&apos;.grandparent&apos;);</span><br><span class="line"></span><br><span class="line">  addEvent(child, &apos;click&apos;, function (e) &#123;</span><br><span class="line">    console.log(&apos;child&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  addEvent(parent, &apos;click&apos;, function (e) &#123;</span><br><span class="line">    console.log(&apos;parent&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  addEvent(grandparent, &apos;click&apos;, function (e) &#123;</span><br><span class="line">    console.log(&apos;grandparent&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  addEvent(document, &apos;click&apos;, function (e) &#123;</span><br><span class="line">    console.log(&apos;document&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  addEvent(&apos;html&apos;, &apos;click&apos;, function (e) &#123;</span><br><span class="line">    console.log(&apos;html&apos;);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  addEvent(window, &apos;click&apos;, function (e) &#123;</span><br><span class="line">    console.log(&apos;window&apos;);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>addEventListener</code>方法具有第三个可选参数<code>useCapture</code>，其默认值为<code>false</code>，事件将在冒泡阶段中发生，如果为<code>true</code>，则事件将在捕获阶段中发生。如果单击<code>child</code>元素，它将分别在控制台上记录<code>child</code>，<code>parent</code>，<code>grandparent</code>，<code>html</code>，<code>document</code>和<code>window</code>，这就是事件冒泡。</p>
<h3 id="8-什么是事件捕获？"><a href="#8-什么是事件捕获？" class="headerlink" title="8. 什么是事件捕获？"></a>8. 什么是事件捕获？</h3><p>当事件发生在 <strong>DOM</strong> 元素上时，该事件并不完全发生在那个元素上。在捕获阶段，事件从<code>window</code>开始，一直到触发事件的元素。</p>
<p>假设有如下的 HTML 结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;grandparent&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;child&quot;&gt;1&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>对应的 JS 代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function addEvent(el, event, callback, isCapture = false) &#123;</span><br><span class="line">  if (!el || !event || !callback || typeof callback !== &apos;function&apos;) return;</span><br><span class="line">  if (typeof el === &apos;string&apos;) &#123;</span><br><span class="line">    el = document.querySelector(el);</span><br><span class="line">  &#125;;</span><br><span class="line">  el.addEventListener(event, callback, isCapture);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addEvent(document, &apos;DOMContentLoaded&apos;, () =&gt; &#123;</span><br><span class="line">  const child = document.querySelector(&apos;.child&apos;);</span><br><span class="line">  const parent = document.querySelector(&apos;.parent&apos;);</span><br><span class="line">  const grandparent = document.querySelector(&apos;.grandparent&apos;);</span><br><span class="line"></span><br><span class="line">  addEvent(child, &apos;click&apos;, function (e) &#123;</span><br><span class="line">    console.log(&apos;child&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  addEvent(parent, &apos;click&apos;, function (e) &#123;</span><br><span class="line">    console.log(&apos;parent&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  addEvent(grandparent, &apos;click&apos;, function (e) &#123;</span><br><span class="line">    console.log(&apos;grandparent&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  addEvent(document, &apos;click&apos;, function (e) &#123;</span><br><span class="line">    console.log(&apos;document&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  addEvent(&apos;html&apos;, &apos;click&apos;, function (e) &#123;</span><br><span class="line">    console.log(&apos;html&apos;);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  addEvent(window, &apos;click&apos;, function (e) &#123;</span><br><span class="line">    console.log(&apos;window&apos;);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>addEventListener</code>方法具有第三个可选参数<code>useCapture</code>，其默认值为<code>false</code>，事件将在冒泡阶段中发生，如果为<code>true</code>，则事件将在捕获阶段中发生。如果单击<code>child</code>元素，它将分别在控制台上打印<code>window</code>，<code>document</code>，<code>html</code>，<code>grandparent</code>和<code>parent</code>，这就是<strong>事件捕获</strong>。</p>
<h3 id="9-event-preventDefault-和-event-stopPropagation-方法之间有什么区别？"><a href="#9-event-preventDefault-和-event-stopPropagation-方法之间有什么区别？" class="headerlink" title="9. event.preventDefault() 和 event.stopPropagation()方法之间有什么区别？"></a>9. event.preventDefault() 和 event.stopPropagation()方法之间有什么区别？</h3><p><code>event.preventDefault()</code> 方法可防止元素的默认行为。如果在表单元素中使用，它将阻止其提交。如果在锚元素中使用，它将阻止其导航。如果在上下文菜单中使用，它将阻止其显示或显示。<code>event.stopPropagation()</code>方法用于阻止捕获和冒泡阶段中当前事件的进一步传播。</p>
<h3 id="10-如何知道是否在元素中使用了event-preventDefault-方法？"><a href="#10-如何知道是否在元素中使用了event-preventDefault-方法？" class="headerlink" title="10. 如何知道是否在元素中使用了event.preventDefault()方法？"></a>10. 如何知道是否在元素中使用了<code>event.preventDefault()</code>方法？</h3><p>我们可以在事件对象中使用<code>event.defaultPrevented</code>属性。它返回一个布尔值用来表明是否在特定元素中调用了<code>event.preventDefault()</code>。</p>
<h3 id="11-为什么此代码-obj-someprop-x-会引发错误"><a href="#11-为什么此代码-obj-someprop-x-会引发错误" class="headerlink" title="11. 为什么此代码 obj.someprop.x 会引发错误?"></a>11. 为什么此代码 <code>obj.someprop.x</code> 会引发错误?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;&#125;;</span><br><span class="line">console.log(obj.someprop.x);</span><br></pre></td></tr></table></figure>

<p>显然，由于我们尝试访问<code>someprop</code>属性中的<code>x</code>属性，而 someprop 并没有在对象中，所以值为 <code>undefined</code>。记住对象本身不存在的属性，并且其原型的默认值为<code>undefined</code>。因为<code>undefined</code>没有属性<code>x</code>，所以试图访问将会报错。</p>
<h3 id="12-什么是-event-target-？"><a href="#12-什么是-event-target-？" class="headerlink" title="12. 什么是 event.target ？"></a>12. 什么是 event.target ？</h3><p>简单来说，<code>event.target</code>是发生事件的元素或触发事件的元素。</p>
<p>假设有如下的 HTML 结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div onclick=&quot;clickFunc(event)&quot; style=&quot;text-align: center;margin:15px;</span><br><span class="line">border:1px solid red;border-radius:3px;&quot;&gt;</span><br><span class="line">    &lt;div style=&quot;margin: 25px; border:1px solid royalblue;border-radius:3px;&quot;&gt;</span><br><span class="line">        &lt;div style=&quot;margin:25px;border:1px solid skyblue;border-radius:3px;&quot;&gt;</span><br><span class="line">          &lt;button style=&quot;margin:10px&quot;&gt;</span><br><span class="line">             Button</span><br><span class="line">          &lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"> &lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>JS 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function clickFunc(event) &#123;</span><br><span class="line">  console.log(event.target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果单击 <code>button</code>，即使我们将事件附加在最外面的<code>div</code>上，它也将打印 <code>button</code> 标签，因此我们可以得出结论<code>event.target</code>是触发事件的元素。</p>
<h3 id="13-什么是-event-currentTarget？？"><a href="#13-什么是-event-currentTarget？？" class="headerlink" title="13. 什么是 event.currentTarget？？"></a>13. 什么是 event.currentTarget？？</h3><p><code>event.currentTarget</code>是我们在其上显式附加事件处理程序的元素。</p>
<p>假设有如下的 HTML 结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div onclick=&quot;clickFunc(event)&quot; style=&quot;text-align: center;margin:15px;</span><br><span class="line">border:1px solid red;border-radius:3px;&quot;&gt;</span><br><span class="line">    &lt;div style=&quot;margin: 25px; border:1px solid royalblue;border-radius:3px;&quot;&gt;</span><br><span class="line">        &lt;div style=&quot;margin:25px;border:1px solid skyblue;border-radius:3px;&quot;&gt;</span><br><span class="line">          &lt;button style=&quot;margin:10px&quot;&gt;</span><br><span class="line">             Button</span><br><span class="line">          &lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"> &lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>JS 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function clickFunc(event) &#123;</span><br><span class="line">  console.log(event.currentTarget);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果单击 <code>button</code>，即使我们单击该 <code>button</code>，它也会打印最外面的<code>div</code>标签。在此示例中，我们可以得出结论，<code>event.currentTarget</code>是附加事件处理程序的元素。</p>
<h3 id="14-和-有什么区别？"><a href="#14-和-有什么区别？" class="headerlink" title="14. == 和 === 有什么区别？"></a>14. == 和 === 有什么区别？</h3><p><code>==</code>用于一般比较，<code>===</code>用于严格比较，<code>==</code>在比较的时候可以转换数据类型<code>，===</code>严格比较，只要类型不匹配就返回<code>flase</code>。</p>
<p>先来看看 <code>==</code> 这兄弟：</p>
<p>强制是将值转换为另一种类型的过程。在这种情况下，<code>==</code>会执行隐式强制。在比较两个值之前，<code>==</code>需要执行一些规则。</p>
<p>假设我们要比较<code>x == y</code>的值。</p>
<ol>
<li>如果<code>x</code>和<code>y</code>的类型相同，则 JS 会换成<code>===</code>操作符进行比较。</li>
<li>如果<code>x</code>为<code>null</code>, <code>y</code>为<code>undefined</code>，则返回<code>true</code>。</li>
<li>如果<code>x</code>为<code>undefined</code>且<code>y</code>为<code>null</code>，则返回<code>true</code>。</li>
<li>如果<code>x</code>的类型是<code>number</code>, <code>y</code>的类型是<code>string</code>，那么返回<code>x == toNumber(y)</code>。</li>
<li>如果<code>x</code>的类型是<code>string</code>, <code>y</code>的类型是<code>number</code>，那么返回<code>toNumber(x) == y</code>。</li>
<li>如果<code>x</code>为类型是<code>boolean</code>，则返回<code>toNumber(x)== y</code>。</li>
<li>如果<code>y</code>为类型是<code>boolean</code>，则返回<code>x == toNumber(y)</code>。</li>
<li>如果<code>x</code>是<code>string</code>、<code>symbol</code>或<code>number</code>，而<code>y</code>是<code>object</code>类型，则返回<code>x == toPrimitive(y)</code>。</li>
<li>如果<code>x</code>是<code>object</code>，<code>y</code>是<code>string</code>，<code>symbol</code>则返回<code>toPrimitive(x) == y</code>。</li>
<li>剩下的 返回 <code>false</code></li>
</ol>
<p>注意：<code>toPrimitive</code>首先在对象中使用<code>valueOf</code>方法，然后使用<code>toString</code>方法来获取该对象的原始值。</p>
<p>举个例子。</p>
<table>
<thead>
<tr>
<th align="left">x</th>
<th align="left">y</th>
<th align="left">x == y</th>
</tr>
</thead>
<tbody><tr>
<td align="left">5</td>
<td align="left">5</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">‘1’</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">null</td>
<td align="left">undefined</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">false</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">‘1,2’</td>
<td align="left">[1,2]</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">‘[object Object]’</td>
<td align="left">{}</td>
<td align="left">true</td>
</tr>
</tbody></table>
<p>这些例子都返回<code>true</code>。</p>
<p>第一个示例符合<code>条件1</code>，因为<code>x</code>和<code>y</code>具有相同的类型和值。</p>
<p>第二个示例符合<code>条件4</code>，在比较之前将<code>y</code>转换为数字。</p>
<p>第三个例子符合<code>条件2</code>。</p>
<p>第四个例子符合<code>条件7</code>，因为<code>y</code>是<code>boolean</code>类型。</p>
<p>第五个示例符合<code>条件8</code>。使用<code>toString()</code>方法将数组转换为字符串，该方法返回<code>1,2</code>。</p>
<p>最后一个示例符合<code>条件8</code>。使用<code>toString()</code>方法将对象转换为字符串，该方法返回<code>[object Object]</code>。</p>
<table>
<thead>
<tr>
<th align="left">x</th>
<th align="left">y</th>
<th align="left">x === y</th>
</tr>
</thead>
<tbody><tr>
<td align="left">5</td>
<td align="left">5</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">‘1’</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">null</td>
<td align="left">undefined</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">false</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">‘1,2’</td>
<td align="left">[1,2]</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">‘[object Object]’</td>
<td align="left">{}</td>
<td align="left">false</td>
</tr>
</tbody></table>
<p>如果使用<code>===</code>运算符，则第一个示例以外的所有比较将返回<code>false</code>，因为它们的类型不同，而第一个示例将返回<code>true</code>，因为两者的类型和值相同。</p>
<p>具体更多规则可以对参考我之前的文章：</p>
<p>我对 JS 中相等和全等操作符转化过程一直很迷惑，直到有了这份算法</p>
<h3 id="15-为什么在-JS-中比较两个相似的对象时返回-false？"><a href="#15-为什么在-JS-中比较两个相似的对象时返回-false？" class="headerlink" title="15. 为什么在 JS 中比较两个相似的对象时返回 false？"></a>15. 为什么在 JS 中比较两个相似的对象时返回 false？</h3><p>先看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123; a: 1 &#125;;</span><br><span class="line">let b = &#123; a: 1 &#125;;</span><br><span class="line">let c = a;</span><br><span class="line"></span><br><span class="line">console.log(a === b); // 打印 false，即使它们有相同的属性</span><br><span class="line">console.log(a === c); // true</span><br></pre></td></tr></table></figure>

<p>JS 以不同的方式比较对象和基本类型。在基本类型中，JS 通过值对它们进行比较，而在对象中，JS 通过引用或存储变量的内存中的地址对它们进行比较。这就是为什么第一个<code>console.log</code>语句返回<code>false</code>，而第二个<code>console.log</code>语句返回<code>true</code>。<code>a</code>和<code>c</code>有相同的引用地址，而<code>a</code>和<code>b</code>没有。</p>
<h3 id="16-运算符能做什么？"><a href="#16-运算符能做什么？" class="headerlink" title="16. !! 运算符能做什么？"></a>16. !! 运算符能做什么？</h3><p><code>!!</code>运算符可以将右侧的值强制转换为布尔值，这也是将值转换为布尔值的一种简单方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">console.log(!!null); // false</span><br><span class="line">console.log(!!undefined); // false</span><br><span class="line">console.log(!!&apos;&apos;); // false</span><br><span class="line">console.log(!!0); // false</span><br><span class="line">console.log(!!NaN); // false</span><br><span class="line">console.log(!!&apos; &apos;); // true</span><br><span class="line">console.log(!!&#123;&#125;); // true</span><br><span class="line">console.log(!![]); // true</span><br><span class="line">console.log(!!1); // true</span><br><span class="line">console.log(!![].length); // false</span><br></pre></td></tr></table></figure>

<h3 id="17-如何在一行中计算多个表达式的值？"><a href="#17-如何在一行中计算多个表达式的值？" class="headerlink" title="17. 如何在一行中计算多个表达式的值？"></a>17. 如何在一行中计算多个表达式的值？</h3><p>可以使用<code>逗号</code>运算符在一行中计算多个表达式。它从左到右求值，并返回右边最后一个项目或最后一个操作数的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let x = 5;</span><br><span class="line"></span><br><span class="line">x = (x++ , x = addFive(x), x *= 2, x -= 5, x += 10);</span><br><span class="line"></span><br><span class="line">function addFive(num) &#123;</span><br><span class="line">  return num + 5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的结果最后得到<code>x</code>的值为<code>27</code>。首先，我们将<code>x</code>的值增加到<code>6</code>，然后调用函数<code>addFive(6)</code>并将<code>6</code>作为参数传递并将结果重新分配给<code>x</code>，此时<code>x</code>的值为<code>11</code>。之后，将<code>x</code>的当前值乘以<code>2</code>并将其分配给<code>x</code>，<code>x</code>的更新值为<code>22</code>。然后，将<code>x</code>的当前值减去<code>5</code>并将结果分配给<code>x</code> <code>x</code>更新后的值为<code>17</code>。最后，我们将<code>x</code>的值增加<code>10</code>，然后将更新的值分配给<code>x</code>，最终<code>x</code>的值为<code>27</code>。</p>
<h3 id="18-什么是提升？"><a href="#18-什么是提升？" class="headerlink" title="18. 什么是提升？"></a>18. 什么是提升？</h3><p><strong>提升</strong>是用来描述变量和函数移动到其(全局或函数)作用域顶部的术语。</p>
<p>为了理解提升，需要来了解一下<strong>执行上下文</strong>。<strong>执行上下文</strong>是当前正在执行的<strong>“代码环境”</strong>。执行上下文有两个阶段:<code>编译</code>和<code>执行</code>。</p>
<p><strong>编译</strong>-在此阶段，JS 引荐获取所有<strong>函数声明</strong>并将其<strong>提升</strong>到其作用域的顶部，以便我们稍后可以引用它们并获取所有变量声明（使用<code>var</code>关键字进行声明），还会为它们提供默认值：<code>undefined</code>。</p>
<p><strong>执行</strong>——在这个阶段中，它将值赋给之前提升的变量，并执行或调用函数(对象中的方法)。</p>
<p><strong>注意:</strong>只有使用<code>var</code>声明的变量，或者函数声明才会被提升，相反，函数表达式或箭头函数，<code>let</code>和<code>const</code>声明的变量，这些都不会被提升。</p>
<p>假设在全局使用域，有如下的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">console.log(y);</span><br><span class="line">y = 1;</span><br><span class="line">console.log(y);</span><br><span class="line">console.log(greet(&quot;Mark&quot;));</span><br><span class="line"></span><br><span class="line">function greet(name)&#123;</span><br><span class="line">  return &apos;Hello &apos; + name + &apos;!&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var y;</span><br></pre></td></tr></table></figure>

<p>上面分别打印：<code>undefined</code>,<code>1</code>, <code>Hello Mark!</code>。</p>
<p>上面代码在编译阶段其实是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function greet(name) &#123;</span><br><span class="line">  return &apos;Hello &apos; + name + &apos;!&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var y; // 默认值 undefined</span><br><span class="line"></span><br><span class="line">// 等待“编译”阶段完成，然后开始“执行”阶段</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">console.log(y);</span><br><span class="line">y = 1;</span><br><span class="line">console.log(y);</span><br><span class="line">console.log(greet(&quot;Mark&quot;));</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>编译阶段完成后，它将启动执行阶段调用方法，并将值分配给变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function greet(name) &#123;</span><br><span class="line">  return &apos;Hello &apos; + name + &apos;!&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var y;</span><br><span class="line"></span><br><span class="line">//start &quot;execution&quot; phase</span><br><span class="line"></span><br><span class="line">console.log(y);</span><br><span class="line">y = 1;</span><br><span class="line">console.log(y);</span><br><span class="line">console.log(greet(&quot;Mark&quot;));</span><br></pre></td></tr></table></figure>

<h3 id="19-什么是作用域？"><a href="#19-什么是作用域？" class="headerlink" title="19. 什么是作用域？"></a>19. 什么是作用域？</h3><p>JavaScript 中的作用域是我们可以有效访问变量或函数的区域。JS 有三种类型的作用域：<strong>全局作用域</strong>、<strong>函数作用域</strong>和<strong>块作用域(ES6)</strong>。</p>
<ul>
<li><strong>全局作用域</strong>——在全局命名空间中声明的变量或函数位于全局作用域中，因此在代码中的任何地方都可以访问它们。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//global namespace</span><br><span class="line">var g = &quot;global&quot;;</span><br><span class="line"></span><br><span class="line">function globalFunc()&#123;</span><br><span class="line">  function innerFunc()&#123;</span><br><span class="line">    console.log(g); // can access &quot;g&quot; because &quot;g&quot; is a global variable</span><br><span class="line">  &#125;</span><br><span class="line"> innerFunc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>函数作用域</strong>——在函数中声明的变量、函数和参数可以在函数内部访问，但不能在函数外部访问。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function myFavoriteFunc(a) &#123;</span><br><span class="line">  if (true) &#123;</span><br><span class="line">    var b = &quot;Hello &quot; + a;</span><br><span class="line">  &#125;</span><br><span class="line">  return b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFavoriteFunc(&quot;World&quot;);</span><br><span class="line"></span><br><span class="line">console.log(a); // Throws a ReferenceError &quot;a&quot; is not defined</span><br><span class="line">console.log(b); // does not continue here</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>块作用域</strong>-在块<code>{}</code>中声明的变量（<code>let，const</code>）只能在其中访问。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function testBlock()&#123;</span><br><span class="line">  if(true)&#123;</span><br><span class="line">    let z = 5;</span><br><span class="line">  &#125;</span><br><span class="line">  return z; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">testBlock(); // Throws a ReferenceError &quot;z&quot; is not defined</span><br></pre></td></tr></table></figure>

<p>作用域也是一组用于查找变量的规则。如果变量在当前作用域中不存在，它将向外部作用域中查找并搜索，如果该变量不存在，它将再次查找直到到达全局作用域，如果找到，则可以使用它，否则引发错误，这种查找过程也称为<strong>作用域链</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> /* 作用域链</span><br><span class="line"></span><br><span class="line">   内部作用域-&gt;外部作用域-&gt; 全局作用域</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 全局作用域</span><br><span class="line">var variable1 = &quot;Comrades&quot;;   </span><br><span class="line">var variable2 = &quot;Sayonara&quot;;</span><br><span class="line"></span><br><span class="line">function outer()&#123;</span><br><span class="line">// 外部作用域</span><br><span class="line">  var variable1 = &quot;World&quot;;</span><br><span class="line">  function inner()&#123;</span><br><span class="line">  // 内部作用域</span><br><span class="line">    var variable2 = &quot;Hello&quot;;</span><br><span class="line">    console.log(variable2 + &quot; &quot; + variable1);</span><br><span class="line">  &#125;</span><br><span class="line">  inner();</span><br><span class="line">&#125;  </span><br><span class="line">outer(); // Hello World</span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/LDPLltmNy57ianicNyt0G9GEGibARafiazZKZygCFTnJzqJUDenZbJd5iaNb4JdmPlNichcClS3DHIK6C3F1iaicueicBIA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>





<h3 id="20-什么是闭包？"><a href="#20-什么是闭包？" class="headerlink" title="20. 什么是闭包？"></a>20. 什么是闭包？</h3><p>这可能是所有问题中最难的一个问题，因为闭包是一个有争议的话题，这里从个人角度来谈谈，如果不妥，多多海涵。</p>
<p><strong>闭包</strong>就是一个函数在声明时能够记住当前作用域、父函数作用域、及父函数作用域上的变量和参数的引用，直至通过作用域链上全局作用域，基本上闭包是在声明函数时创建的作用域。</p>
<p>看看小例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 全局作用域</span><br><span class="line">var globalVar = &quot;abc&quot;;</span><br><span class="line"></span><br><span class="line">function a()&#123;</span><br><span class="line">  console.log(globalVar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a(); // &quot;abc&quot;</span><br></pre></td></tr></table></figure>

<p>在此示例中，当我们声明<code>a</code>函数时，全局作用域是<code>a</code>闭包的一部分。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/LDPLltmNy57ianicNyt0G9GEGibARafiazZKGgUN6iannKmoHFEkT9qSDLXFy2UdceBhTc0jTPhHVMII9VQotMBVEicw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>



<p>变量<code>globalVar</code>在图中没有值的原因是该变量的值可以根据调用函数<code>a</code>的位置和时间而改变。但是在上面的示例中，<code>globalVar</code>变量的值为<code>abc</code>。</p>
<p>来看一个更复杂的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var globalVar = &quot;global&quot;;</span><br><span class="line">var outerVar = &quot;outer&quot;</span><br><span class="line"></span><br><span class="line">function outerFunc(outerParam) &#123;</span><br><span class="line">  function innerFunc(innerParam) &#123;</span><br><span class="line">    console.log(globalVar, outerParam, innerParam);</span><br><span class="line">  &#125;</span><br><span class="line">  return innerFunc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const x = outerFunc(outerVar);</span><br><span class="line">outerVar = &quot;outer-2&quot;;</span><br><span class="line">globalVar = &quot;guess&quot;</span><br><span class="line">x(&quot;inner&quot;);</span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/LDPLltmNy57ianicNyt0G9GEGibARafiazZKzKopRTZNRpghHkyZrkzDN6T3hPKNfaTgqibvWXAj31jurfSLstX7MGg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>

<p>上面打印结果是  <code>guess outer inner</code>。</p>
<p>当我们调用<code>outerFunc</code>函数并将返回值<code>innerFunc</code>函数分配给变量<code>x</code>时，即使我们为<code>outerVar</code>变量分配了新值<code>outer-2</code>，<code>outerParam</code>也继续保留<code>outer</code>值，因为重新分配是在调用<code>outerFunc</code>之后发生的，并且当我们调用<code>outerFunc</code>函数时，它会在作用域链中查找<code>outerVar</code>的值，此时的<code>outerVar</code>的值将为 <code>&quot;outer&quot;</code>。</p>
<p>现在，当我们调用引用了<code>innerFunc</code>的<code>x</code>变量时，<code>innerParam</code>将具有一个<code>inner</code>值，因为这是我们在调用中传递的值，而<code>globalVar</code>变量值为<code>guess</code>，因为在调用<code>x</code>变量之前，我们将一个新值分配给<code>globalVar</code>。</p>
<p>下面这个示例演示没有理解好闭包所犯的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const arrFuncs = [];</span><br><span class="line">for(var i = 0; i &lt; 5; i++)&#123;</span><br><span class="line">  arrFuncs.push(function ()&#123;</span><br><span class="line">    return i;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(i); // i is 5</span><br><span class="line"></span><br><span class="line">for (let i = 0; i &lt; arrFuncs.length; i++) &#123;</span><br><span class="line">  console.log(arrFuncs[i]()); // 都打印 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于闭包，此代码无法正常运行。<code>var</code>关键字创建一个全局变量，当我们 push 一个函数时，这里返回的全局变量<code>i</code>。因此，当我们在循环后在该数组中调用其中一个函数时，它会打印<code>5</code>，因为我们得到<code>i</code>的当前值为<code>5</code>，我们可以访问它，因为它是全局变量。</p>
<p>因为闭包在创建变量时会保留该变量的引用而不是其值。我们可以使用<strong>IIFES</strong>或使用 <code>let</code> 来代替 <code>var</code> 的声明。</p>
<h3 id="21-JavaScript-中的虚值是什么？"><a href="#21-JavaScript-中的虚值是什么？" class="headerlink" title="21. JavaScript 中的虚值是什么？"></a>21. JavaScript 中的虚值是什么？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const falsyValues = [&apos;&apos;, 0, null, undefined, NaN, false];</span><br></pre></td></tr></table></figure>

<p>简单的来说虚值就是是在转换为布尔值时变为 <code>false</code> 的值。</p>
<h3 id="22-如何检查值是否虚值？"><a href="#22-如何检查值是否虚值？" class="headerlink" title="22. 如何检查值是否虚值？"></a>22. 如何检查值是否虚值？</h3><p>使用 <code>Boolean</code> 函数或者 <code>!!</code> 运算符。</p>
<h3 id="23-‘use-strict’-是干嘛用的？"><a href="#23-‘use-strict’-是干嘛用的？" class="headerlink" title="23. ‘use strict’ 是干嘛用的？"></a>23. ‘use strict’ 是干嘛用的？</h3><p><code>&quot;use strict&quot;</code> 是 <strong>ES5</strong> 特性，它使我们的代码在函数或整个脚本中处于<strong>严格模式</strong>。<strong>严格模式</strong>帮助我们在代码的早期避免 bug，并为其添加限制。</p>
<p><strong>严格模式</strong>的一些限制：</p>
<ol>
<li>变量必须声明后再使用</li>
<li>函数的参数不能有同名属性，否则报错</li>
<li>不能使用<code>with</code>语句</li>
<li>不能对只读属性赋值，否则报错</li>
<li>不能使用前缀 0 表示八进制数，否则报错</li>
<li>不能删除不可删除的属性，否则报错</li>
<li>不能删除变量<code>delete prop</code>，会报错，只能删除属性<code>delete global[prop]</code></li>
<li><code>eval</code>不能在它的外层作用域引入变量</li>
<li><code>eval</code>和<code>arguments</code>不能被重新赋值</li>
<li><code>arguments</code>不会自动反映函数参数的变化</li>
<li>不能使用<code>arguments.callee</code></li>
<li>不能使用<code>arguments.caller</code></li>
<li>禁止<code>this</code>指向全局对象</li>
<li>不能使用<code>fn.caller</code>和<code>fn.arguments</code>获取函数调用的堆栈</li>
<li>增加了保留字（比如<code>protected</code>、<code>static</code>和<code>interface</code>）</li>
</ol>
<p>设立”严格模式”的目的，主要有以下几个：</p>
<ol>
<li>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</li>
<li>消除代码运行的一些不安全之处，保证代码运行的安全；</li>
<li>提高编译器效率，增加运行速度；</li>
<li>为未来新版本的Javascript做好铺垫。</li>
</ol>
<h3 id="24-JavaScript-中-this-值是什么？"><a href="#24-JavaScript-中-this-值是什么？" class="headerlink" title="24. JavaScript 中 this 值是什么？"></a>24. JavaScript 中 <code>this</code> 值是什么？</h3><p>基本上，<code>this</code>指的是当前正在执行或调用该函数的对象的值。<code>this</code>值的变化取决于我们使用它的上下文和我们在哪里使用它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const carDetails = &#123;</span><br><span class="line">  name: &quot;Ford Mustang&quot;,</span><br><span class="line">  yearBought: 2005,</span><br><span class="line">  getName()&#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;,</span><br><span class="line">  isRegistered: true</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(carDetails.getName()); // Ford Mustang</span><br></pre></td></tr></table></figure>

<p>这通常是我们期望结果的，因为在<code>getName</code>方法中我们返回<code>this.name</code>，在此上下文中，<code>this</code>指向的是<code>carDetails</code>对象，该对象当前是执行函数的“所有者”对象。</p>
<p>接下我们做些奇怪的事情：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;Ford Ranger&quot;;</span><br><span class="line">var getCarName = carDetails.getName;</span><br><span class="line"></span><br><span class="line">console.log(getCarName()); // Ford Ranger</span><br></pre></td></tr></table></figure>

<p>上面打印<code>Ford Ranger</code>，这很奇怪，因为在第一个<code>console.log</code>语句中打印的是<code>Ford Mustang</code>。这样做的原因是<code>getCarName</code>方法有一个不同的“所有者”对象，即<code>window</code>对象。在全局作用域中使用<code>var</code>关键字声明变量会在<code>window</code>对象中附加与变量名称相同的属性。请记住，当没有使用<code>“use strict”</code>时，在全局作用域中<code>this</code>指的是<code>window</code>对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(getCarName === window.getCarName); // true</span><br><span class="line">console.log(getCarName === this.getCarName); // true</span><br></pre></td></tr></table></figure>

<p>本例中的<code>this</code>和<code>window</code>引用同一个对象。</p>
<p>解决这个问题的一种方法是在函数中使用<code>apply</code>和<code>call</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(getCarName.apply(carDetails)); // Ford Mustang</span><br><span class="line">console.log(getCarName.call(carDetails));  // Ford Mustang</span><br></pre></td></tr></table></figure>

<p><code>apply</code>和<code>call</code>方法期望第一个参数是一个对象，该对象是函数内部<code>this</code>的值。</p>
<p><code>IIFE</code>或<strong>立即执行的函数表达式</strong>，在全局作用域内声明的函数，对象内部方法中的匿名函数和内部函数的<code>this</code>具有默认值，该值指向<code>window</code>对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">(function ()&#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;)(); // 打印 &quot;window&quot; 对象</span><br><span class="line"></span><br><span class="line">function iHateThis()&#123;</span><br><span class="line">   console.log(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">iHateThis(); // 打印 &quot;window&quot; 对象</span><br><span class="line"></span><br><span class="line">const myFavoriteObj = &#123;</span><br><span class="line">  guessThis()&#123;</span><br><span class="line">     function getName()&#123;</span><br><span class="line">       console.log(this.name);</span><br><span class="line">     &#125;</span><br><span class="line">     getName();</span><br><span class="line">  &#125;,</span><br><span class="line">  name: &apos;Marko Polo&apos;,</span><br><span class="line">  thisIsAnnoying(callback)&#123;</span><br><span class="line">    callback();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myFavoriteObj.guessThis(); // 打印 &quot;window&quot; 对象</span><br><span class="line">myFavoriteObj.thisIsAnnoying(function ()&#123;</span><br><span class="line">  console.log(this); // 打印 &quot;window&quot; 对象</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果我们要获取<code>myFavoriteObj</code>对象中的<code>name</code>属性（即<strong>Marko Polo</strong>）的值，则有两种方法可以解决此问题。</p>
<p>一种是将 <code>this</code> 值保存在变量中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const myFavoriteObj = &#123;</span><br><span class="line"> guessThis()&#123;</span><br><span class="line">  const self = this; // 把 this 值保存在 self 变量中</span><br><span class="line">  function getName()&#123;</span><br><span class="line">    console.log(self.name);</span><br><span class="line">  &#125;</span><br><span class="line">  getName();</span><br><span class="line"> &#125;,</span><br><span class="line"> name: &apos;Marko Polo&apos;,</span><br><span class="line"> thisIsAnnoying(callback)&#123;</span><br><span class="line">   callback();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第二种方式是使用箭头函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const myFavoriteObj = &#123;</span><br><span class="line">  guessThis()&#123;</span><br><span class="line">     const getName = () =&gt; &#123; </span><br><span class="line">       console.log(this.name);</span><br><span class="line">     &#125;</span><br><span class="line">     getName();</span><br><span class="line">  &#125;,</span><br><span class="line">  name: &apos;Marko Polo&apos;,</span><br><span class="line">  thisIsAnnoying(callback)&#123;</span><br><span class="line">   callback();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>箭头函数没有自己的 <code>this</code>。它复制了这个封闭的词法作用域中<code>this</code>值，在这个例子中，<code>this</code>值在<code>getName</code>内部函数之外，也就是<code>myFavoriteObj</code>对象。</p>
<h3 id="25-对象的-prototype-原型-是什么？"><a href="#25-对象的-prototype-原型-是什么？" class="headerlink" title="25. 对象的 prototype(原型) 是什么？"></a>25. 对象的 prototype(原型) 是什么？</h3><p>简单地说，原型就是对象的蓝图。如果它存在当前对象中，则将其用作属性和方法的回退。它是在对象之间共享属性和功能的方法，这也是JavaScript实现继承的核心。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const o = &#123;&#125;;</span><br><span class="line">console.log(o.toString()); // logs [object Object]</span><br></pre></td></tr></table></figure>

<p>即使<code>o</code>对象中不存在<code>o.toString</code>方法，它也不会引发错误，而是返回字符串<code>[object Object]</code>。当对象中不存在属性时，它将查看其原型，如果仍然不存在，则将其查找到原型的原型，依此类推，直到在原型链中找到具有相同属性的属性为止。原型链的末尾是<code>Object.prototype</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(o.toString === Object.prototype.toString); // logs true</span><br></pre></td></tr></table></figure>

<h3 id="26-什么是-IIFE，它的用途是什么？"><a href="#26-什么是-IIFE，它的用途是什么？" class="headerlink" title="26. 什么是 IIFE，它的用途是什么？"></a>26. 什么是 IIFE，它的用途是什么？</h3><p><strong>IIFE</strong>或立即调用的函数表达式是在创建或声明后将被调用或执行的函数。创建<strong>IIFE的</strong>语法是，将<code>function (){}</code>包裹在在括号<code>()</code>内，然后再用另一个括号<code>()</code>调用它，如：<code>(function(){})()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; ());</span><br><span class="line"></span><br><span class="line">(function () &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">(function named(params) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(function (global) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)(window);</span><br><span class="line"></span><br><span class="line">const utility = (function () &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这些示例都是有效的<strong>IIFE</strong>。倒数第二个表明我们可以将参数传递给<strong>IIFE</strong>函数。最后一个示例表明，我们可以将<code>IIFE</code>的结果保存到变量中，以便稍后使用。</p>
<p><strong>IIFE</strong>的一个主要作用是避免与全局作用域内的其他变量命名冲突或污染全局命名空间，来个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdnurl.com/somelibrary.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>假设我们引入了一个<code>omelibr.js</code>的链接，它提供了一些我们在代码中使用的全局函数，但是这个库有两个方法我们没有使用：<code>createGraph</code>和<code>drawGraph</code>，因为这些方法都有<code>bug</code>。我们想实现自己的<code>createGraph</code>和<code>drawGraph</code>方法。</p>
<p>解决此问题的一种方法是直接覆盖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdnurl.com/somelibrary.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">   function createGraph() &#123;</span><br><span class="line">      // createGraph logic here</span><br><span class="line">   &#125;</span><br><span class="line">   function drawGraph() &#123;</span><br><span class="line">      // drawGraph logic here</span><br><span class="line">   &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>当我们使用这个解决方案时，我们覆盖了库提供给我们的那两个方法。</p>
<p>另一种方式是我们自己改名称：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdnurl.com/somelibrary.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">   function myCreateGraph() &#123;</span><br><span class="line">      // createGraph logic here</span><br><span class="line">   &#125;</span><br><span class="line">   function myDrawGraph() &#123;</span><br><span class="line">      // drawGraph logic here</span><br><span class="line">   &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>当我们使用这个解决方案时，我们把那些函数调用更改为新的函数名。</p>
<p>还有一种方法就是使用<strong>IIFE</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdnurl.com/somelibrary.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">   const graphUtility = (function () &#123;</span><br><span class="line">      function createGraph() &#123;</span><br><span class="line">         // createGraph logic here</span><br><span class="line">      &#125;</span><br><span class="line">      function drawGraph() &#123;</span><br><span class="line">         // drawGraph logic here</span><br><span class="line">      &#125;</span><br><span class="line">      return &#123;</span><br><span class="line">         createGraph,</span><br><span class="line">         drawGraph</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在此解决方案中，我们要声明了<code>graphUtility</code> 变量，用来保存<strong>IIFE</strong>执行的结果，该函数返回一个包含两个方法<code>createGraph</code>和<code>drawGraph</code>的对象。</p>
<p><strong>IIFE</strong> 还可以用来解决一个常见的面试题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var li = document.querySelectorAll(&apos;.list-group &gt; li&apos;);</span><br><span class="line">for (var i = 0, len = li.length; i &lt; len; i++) &#123;</span><br><span class="line">   li[i].addEventListener(&apos;click&apos;, function (e) &#123;</span><br><span class="line">      console.log(i);</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>

<p>假设我们有一个带有<code>list-group</code>类的<code>ul</code>元素，它有<code>5</code>个<code>li</code>子元素。当我们单击单个<code>li</code>元素时，打印对应的下标值。但在此外上述代码不起作用，这里每次点击 <code>li</code> 打印 <code>i</code> 的值都是<code>5</code>，这是由于闭包的原因。</p>
<p><strong>闭包</strong>只是函数记住其当前作用域，父函数作用域和全局作用域的变量引用的能力。当我们在全局作用域内使用<code>var</code>关键字声明变量时，就创建全局变量<code>i</code>。因此，当我们单击<code>li</code>元素时，它将打印<code>5</code>，因为这是稍后在回调函数中引用它时<code>i</code>的值。</p>
<p>使用 <strong>IIFE</strong> 可以解决此问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var li = document.querySelectorAll(&apos;.list-group &gt; li&apos;);</span><br><span class="line">for (var i = 0, len = li.length; i &lt; len; i++) &#123;</span><br><span class="line">   (function (currentIndex) &#123;</span><br><span class="line">      li[currentIndex].addEventListener(&apos;click&apos;, function (e) &#123;</span><br><span class="line">         console.log(currentIndex);</span><br><span class="line">      &#125;)</span><br><span class="line">   &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该解决方案之所以行的通，是因为<strong>IIFE</strong>会为每次迭代创建一个新的作用域，我们捕获<code>i</code>的值并将其传递给<code>currentIndex</code>参数，因此调用<strong>IIFE</strong>时，每次迭代的<code>currentIndex</code>值都是不同的。</p>
<h3 id="27-Function-prototype-apply-方法的用途是什么？"><a href="#27-Function-prototype-apply-方法的用途是什么？" class="headerlink" title="27. Function.prototype.apply 方法的用途是什么？"></a>27. Function.prototype.apply 方法的用途是什么？</h3><p><code>apply()</code> 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const details = &#123;</span><br><span class="line">  message: &apos;Hello World!&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function getMessage()&#123;</span><br><span class="line">  return this.message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getMessage.apply(details); // &apos;Hello World!&apos;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>call()</code>方法的作用和 <code>apply()</code> 方法类似，区别就是<code>call()</code>方法接受的是参数列表，而<code>apply()</code>方法接受的是一个参数数组。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &quot;Marko Polo&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function greeting(greetingMessage) &#123;</span><br><span class="line">  return `$&#123;greetingMessage&#125; $&#123;this.name&#125;`;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greeting.apply(person, [&apos;Hello&apos;]); // &quot;Hello Marko Polo!&quot;</span><br></pre></td></tr></table></figure>

<h3 id="28-Function-prototype-call-方法的用途是什么？"><a href="#28-Function-prototype-call-方法的用途是什么？" class="headerlink" title="28. Function.prototype.call 方法的用途是什么？"></a>28. <code>Function.prototype.call</code> 方法的用途是什么？</h3><p><code>call()</code> 方法使用一个指定的 <code>this</code> 值和单独给出的一个或多个参数来调用一个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const details = &#123;</span><br><span class="line">  message: &apos;Hello World!&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function getMessage()&#123;</span><br><span class="line">  return this.message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getMessage.call(details); // &apos;Hello World!&apos;</span><br></pre></td></tr></table></figure>

<p>注意：该方法的语法和作用与 <code>apply()</code> 方法类似，只有一个区别，就是 <code>call()</code> 方法接受的是一个参数列表，而 <code>apply()</code> 方法接受的是一个包含多个参数的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &quot;Marko Polo&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function greeting(greetingMessage) &#123;</span><br><span class="line">  return `$&#123;greetingMessage&#125; $&#123;this.name&#125;`;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greeting.call(person, &apos;Hello&apos;); // &quot;Hello Marko Polo!&quot;</span><br></pre></td></tr></table></figure>

<h3 id="29-Function-prototype-apply-和-Function-prototype-call-之间有什么区别？"><a href="#29-Function-prototype-apply-和-Function-prototype-call-之间有什么区别？" class="headerlink" title="29. Function.prototype.apply 和 Function.prototype.call 之间有什么区别？"></a>29. Function.prototype.apply 和 Function.prototype.call 之间有什么区别？</h3><p><code>apply()</code>方法可以在使用一个指定的 <code>this</code> 值和一个参数数组（或类数组对象）的前提下调用某个函数或方法。<code>call()</code>方法类似于<code>apply()</code>，不同之处仅仅是<code>call()</code>接受的参数是参数列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const obj1 = &#123;</span><br><span class="line"> result:0</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const obj2 = &#123;</span><br><span class="line"> result:0</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function reduceAdd()&#123;</span><br><span class="line">   let result = 0;</span><br><span class="line">   for(let i = 0, len = arguments.length; i &lt; len; i++)&#123;</span><br><span class="line">     result += arguments[i];</span><br><span class="line">   &#125;</span><br><span class="line">   this.result = result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reduceAdd.apply(obj1, [1, 2, 3, 4, 5]); // 15</span><br><span class="line">reduceAdd.call(obj2, 1, 2, 3, 4, 5); // 15</span><br></pre></td></tr></table></figure>

<h3 id="30-Function-prototype-bind-的用途是什么？"><a href="#30-Function-prototype-bind-的用途是什么？" class="headerlink" title="30. Function.prototype.bind 的用途是什么？"></a>30. Function.prototype.bind 的用途是什么？</h3><p><code>bind()</code> 方法创建一个新的函数，在 <code>bind()</code> 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code> 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">     constructor(props)&#123;</span><br><span class="line">          super(props); </span><br><span class="line">          this.state = &#123;</span><br><span class="line">             value : &quot;&quot;</span><br><span class="line">          &#125;  </span><br><span class="line">          this.handleChange = this.handleChange.bind(this); </span><br><span class="line">          // 将 “handleChange” 方法绑定到 “MyComponent” 组件</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     handleChange(e)&#123;</span><br><span class="line">       //do something amazing here</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     render()&#123;</span><br><span class="line">        return (</span><br><span class="line">              &lt;&gt;</span><br><span class="line">                &lt;input type=&#123;this.props.type&#125;</span><br><span class="line">                        value=&#123;this.state.value&#125;</span><br><span class="line">                     onChange=&#123;this.handleChange&#125;                      </span><br><span class="line">                  /&gt;</span><br><span class="line">              &lt;/&gt;</span><br><span class="line">        )</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="31-什么是函数式编程-JavaScript-的哪些特性使其成为函数式语言的候选语言？"><a href="#31-什么是函数式编程-JavaScript-的哪些特性使其成为函数式语言的候选语言？" class="headerlink" title="31. 什么是函数式编程? JavaScript 的哪些特性使其成为函数式语言的候选语言？"></a>31. 什么是函数式编程? JavaScript 的哪些特性使其成为函数式语言的候选语言？</h3><p>函数式编程（通常缩写为FP）是通过编写纯函数，避免共享状态、可变数据、副作用 来构建软件的过程。数式编程是声明式 的而不是命令式 的，应用程序的状态是通过纯函数流动的。与面向对象编程形成对比，面向对象中应用程序的状态通常与对象中的方法共享和共处。</p>
<p>函数式编程是一种编程范式 ，这意味着它是一种基于一些基本的定义原则（如上所列）思考软件构建的方式。当然，编程范式的其他示例也包括面向对象编程和过程编程。</p>
<p>函数式的代码往往比命令式或面向对象的代码更简洁，更可预测，更容易测试 - 但如果不熟悉它以及与之相关的常见模式，函数式的代码也可能看起来更密集杂乱，并且 相关文献对新人来说是不好理解的。</p>
<p><strong>JavaScript支持闭包和高阶函数是函数式编程语言的特点。</strong></p>
<h3 id="32-什么是高阶函数？"><a href="#32-什么是高阶函数？" class="headerlink" title="32. 什么是高阶函数？"></a>32. 什么是高阶函数？</h3><p><strong>高阶函数只是将函数作为参数或返回值的函数。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function higherOrderFunction(param,callback)&#123;</span><br><span class="line">    return callback(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="33-为什么函数被称为一等公民？"><a href="#33-为什么函数被称为一等公民？" class="headerlink" title="33. 为什么函数被称为一等公民？"></a>33. 为什么函数被称为一等公民？</h3><p>在JavaScript中，函数不仅拥有一切传统函数的使用方式（声明和调用），而且可以做到像简单值一样赋值<code>（var func = function(){}）</code>、传参<code>(function func(x,callback){callback();})</code>、返回<code>(function(){return function(){}})</code>，这样的函数也称之为<strong>第一级函数（First-class Function）</strong>。不仅如此，JavaScript中的函数还充当了类的构造函数的作用，同时又是一个<code>Function</code>类的实例(instance)。这样的多重身份让JavaScript的函数变得非常重要。</p>
<h3 id="34-手动实现-Array-prototype-map-方法"><a href="#34-手动实现-Array-prototype-map-方法" class="headerlink" title="34. 手动实现 Array.prototype.map 方法"></a>34. 手动实现 <code>Array.prototype.map 方法</code></h3><p><code>map()</code> 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function map(arr, mapCallback) &#123;</span><br><span class="line">  // 首先，检查传递的参数是否正确。</span><br><span class="line">  if (!Array.isArray(arr) || !arr.length || typeof mapCallback !== &apos;function&apos;) &#123; </span><br><span class="line">    return [];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    let result = [];</span><br><span class="line">    // 每次调用此函数时，我们都会创建一个 result 数组</span><br><span class="line">    // 因为我们不想改变原始数组。</span><br><span class="line">    for (let i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">      result.push(mapCallback(arr[i], i, arr)); </span><br><span class="line">      // 将 mapCallback 返回的结果 push 到 result 数组中</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="35-手动实现Array-prototype-filter方法"><a href="#35-手动实现Array-prototype-filter方法" class="headerlink" title="35. 手动实现Array.prototype.filter方法"></a>35. 手动实现<code>Array.prototype.filter</code>方法</h3><p><code>filter()</code> 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function filter(arr, filterCallback) &#123;</span><br><span class="line">  // 首先，检查传递的参数是否正确。</span><br><span class="line">  if (!Array.isArray(arr) || !arr.length || typeof filterCallback !== &apos;function&apos;) </span><br><span class="line">  &#123;</span><br><span class="line">    return [];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    let result = [];</span><br><span class="line">     // 每次调用此函数时，我们都会创建一个 result 数组</span><br><span class="line">     // 因为我们不想改变原始数组。</span><br><span class="line">    for (let i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">      // 检查 filterCallback 的返回值是否是真值</span><br><span class="line">      if (filterCallback(arr[i], i, arr)) &#123; </span><br><span class="line">      // 如果条件为真，则将数组元素 push 到 result 中</span><br><span class="line">        result.push(arr[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result; // return the result array</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="36-手动实现Array-prototype-reduce方法"><a href="#36-手动实现Array-prototype-reduce方法" class="headerlink" title="36. 手动实现Array.prototype.reduce方法"></a>36. 手动实现<code>Array.prototype.reduce</code>方法</h3><p><code>reduce()</code> 方法对数组中的每个元素执行一个由您提供的<code>reducer</code>函数(升序执行)，将其结果汇总为单个返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function reduce(arr, reduceCallback, initialValue) &#123;</span><br><span class="line">  // 首先，检查传递的参数是否正确。</span><br><span class="line">  if (!Array.isArray(arr) || !arr.length || typeof reduceCallback !== &apos;function&apos;) </span><br><span class="line">  &#123;</span><br><span class="line">    return [];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 如果没有将initialValue传递给该函数，我们将使用第一个数组项作为initialValue</span><br><span class="line">    let hasInitialValue = initialValue !== undefined;</span><br><span class="line">    let value = hasInitialValue ? initialValue : arr[0];</span><br><span class="line">   、</span><br><span class="line"></span><br><span class="line">    // 如果有传递 initialValue，则索引从 1 开始，否则从 0 开始</span><br><span class="line">    for (let i = hasInitialValue ? 0 : 1, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">      value = reduceCallback(value, arr[i], i, arr); </span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="37-arguments-的对象是什么？"><a href="#37-arguments-的对象是什么？" class="headerlink" title="37. arguments 的对象是什么？"></a>37. arguments 的对象是什么？</h3><p><code>arguments</code>对象是函数中传递的参数值的集合。它是一个类似数组的对象，因为它有一个length属性，我们可以使用数组索引表示法<code>arguments[1]</code>来访问单个值，但它没有数组中的内置方法，如：<code>forEach</code>、<code>reduce</code>、<code>filter</code>和<code>map</code>。</p>
<p>我们可以使用<code>Array.prototype.slice</code>将<code>arguments</code>对象转换成一个数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function one() &#123;</span><br><span class="line">  return Array.prototype.slice.call(arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意:箭头函数中没有<code>arguments</code>对象。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function one() &#123;</span><br><span class="line">  return arguments;</span><br><span class="line">&#125;</span><br><span class="line">const two = function () &#123;</span><br><span class="line">  return arguments;</span><br><span class="line">&#125;</span><br><span class="line">const three = function three() &#123;</span><br><span class="line">  return arguments;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const four = () =&gt; arguments;</span><br><span class="line"></span><br><span class="line">four(); // Throws an error  - arguments is not defined</span><br></pre></td></tr></table></figure>

<p>当我们调用函数<code>four</code>时，它会抛出一个<code>ReferenceError: arguments is not defined error</code>。使用<code>rest</code>语法，可以解决这个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const four = (...args) =&gt; args;</span><br></pre></td></tr></table></figure>

<p>这会自动将所有参数值放入数组中。</p>
<h3 id="38-如何创建一个没有-prototype-原型-的对象？"><a href="#38-如何创建一个没有-prototype-原型-的对象？" class="headerlink" title="38. 如何创建一个没有 prototype(原型)的对象？"></a>38. 如何创建一个没有 prototype(原型)的对象？</h3><p>我们可以使用<code>Object.create</code>方法创建没有原型的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const o1 = &#123;&#125;;</span><br><span class="line">console.log(o1.toString()); // [object Object]</span><br><span class="line"></span><br><span class="line">const o2 = Object.create(null);</span><br><span class="line">console.log(o2.toString());</span><br><span class="line">// throws an error o2.toString is not a function</span><br></pre></td></tr></table></figure>

<h3 id="39-为什么在调用这个函数时，代码中的b会变成一个全局变量"><a href="#39-为什么在调用这个函数时，代码中的b会变成一个全局变量" class="headerlink" title="39. 为什么在调用这个函数时，代码中的b会变成一个全局变量?"></a>39. 为什么在调用这个函数时，代码中的<code>b</code>会变成一个全局变量?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function myFunc() &#123;</span><br><span class="line">  let a = b = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFunc();</span><br></pre></td></tr></table></figure>

<p>原因是赋值运算符是从右到左的求值的。这意味着当多个赋值运算符出现在一个表达式中时，它们是从右向左求值的。所以上面代码变成了这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function myFunc() &#123;</span><br><span class="line">  let a = (b = 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFunc();</span><br></pre></td></tr></table></figure>

<p>首先，表达式<code>b = 0</code>求值，在本例中<code>b</code>没有声明。因此，JS引擎在这个函数外创建了一个全局变量<code>b</code>，之后表达式<code>b = 0</code>的返回值为<code>0</code>，并赋给新的局部变量<code>a</code>。</p>
<p>我们可以通过在赋值之前先声明变量来解决这个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function myFunc() &#123;</span><br><span class="line">  let a,b;</span><br><span class="line">  a = b = 0;</span><br><span class="line">&#125;</span><br><span class="line">myFunc();</span><br></pre></td></tr></table></figure>

<h3 id="40-ECMAScript-是什么？"><a href="#40-ECMAScript-是什么？" class="headerlink" title="40. ECMAScript 是什么？"></a>40. ECMAScript 是什么？</h3><p>ECMAScript 是编写脚本语言的标准，这意味着JavaScript遵循ECMAScript标准中的规范变化，因为它是JavaScript的蓝图。</p>
<p>ECMAScript 和 Javascript，本质上都跟一门语言有关，一个是语言本身的名字，一个是语言的约束条件<br>只不过发明JavaScript的那个人（Netscape公司），把东西交给了ECMA（European Computer Manufacturers Association），这个人规定一下他的标准，因为当时有java语言了，又想强调这个东西是让ECMA这个人定的规则，所以就这样一个神奇的东西诞生了，这个东西的名称就叫做ECMAScript。</p>
<p>javaScript = ECMAScript + DOM + BOM（自认为是一种广义的JavaScript）</p>
<p>ECMAScript说什么JavaScript就得做什么！</p>
<p>JavaScript（狭义的JavaScript）做什么都要问问ECMAScript我能不能这样干！如果不能我就错了！能我就是对的！</p>
<p>——突然感觉JavaScript好没有尊严，为啥要搞个人出来约束自己，</p>
<p>那个人被创造出来也好委屈，自己被创造出来完全是因为要约束JavaScript。</p>
<h3 id="41-ES6或ECMAScript-2015有哪些新特性？"><a href="#41-ES6或ECMAScript-2015有哪些新特性？" class="headerlink" title="41. ES6或ECMAScript 2015有哪些新特性？"></a>41. ES6或ECMAScript 2015有哪些新特性？</h3><ul>
<li>箭头函数</li>
<li>类</li>
<li>模板字符串</li>
<li>加强的对象字面量</li>
<li>对象解构</li>
<li>Promise</li>
<li>生成器</li>
<li>模块</li>
<li>Symbol</li>
<li>代理</li>
<li>Set</li>
<li>函数默认参数</li>
<li>rest 和展开</li>
<li>块作用域</li>
</ul>
<h3 id="42-var-let和const的区别是什么？"><a href="#42-var-let和const的区别是什么？" class="headerlink" title="42. var,let和const的区别是什么？"></a>42. <code>var</code>,<code>let</code>和<code>const</code>的区别是什么？</h3><p><strong><code>var</code>声明的变量会挂载在<code>window</code>上，而<code>let</code>和<code>const</code>声明的变量不会：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = 100;</span><br><span class="line">console.log(a,window.a);    // 100 100</span><br><span class="line"></span><br><span class="line">let b = 10;</span><br><span class="line">console.log(b,window.b);    // 10 undefined</span><br><span class="line"></span><br><span class="line">const c = 1;</span><br><span class="line">console.log(c,window.c);    // 1 undefined</span><br></pre></td></tr></table></figure>

<p><strong><code>var</code>声明变量存在变量提升，<code>let</code>和<code>const</code>不存在变量提升:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">console.log(a); // undefined  ===&gt;  a已声明还没赋值，默认得到undefined值</span><br><span class="line">var a = 100;</span><br><span class="line"></span><br><span class="line">console.log(b); // 报错：b is not defined  ===&gt; 找不到b这个变量</span><br><span class="line">let b = 10;</span><br><span class="line"></span><br><span class="line">console.log(c); // 报错：c is not defined  ===&gt; 找不到c这个变量</span><br><span class="line">const c = 10;</span><br></pre></td></tr></table></figure>

<p><strong><code>let</code>和<code>const</code>声明形成块作用域</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">if(1)&#123;</span><br><span class="line">  var a = 100;</span><br><span class="line">  let b = 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(a); // 100</span><br><span class="line">console.log(b)  // 报错：b is not defined  ===&gt; 找不到b这个变量</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">if(1)&#123;</span><br><span class="line">  var a = 100;</span><br><span class="line">  const c = 1;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a); // 100</span><br><span class="line">console.log(c)  // 报错：c is not defined  ===&gt; 找不到c这个变量</span><br></pre></td></tr></table></figure>

<p><strong>同一作用域下<code>let</code>和<code>const</code>不能声明同名变量，而<code>var</code>可以</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = 100;</span><br><span class="line">console.log(a); // 100</span><br><span class="line"></span><br><span class="line">var a = 10;</span><br><span class="line">console.log(a); // 10</span><br><span class="line">-------------------------------------</span><br><span class="line">let a = 100;</span><br><span class="line">let a = 10;</span><br><span class="line"></span><br><span class="line">//  控制台报错：Identifier &apos;a&apos; has already been declared  ===&gt; 标识符a已经被声明了。</span><br></pre></td></tr></table></figure>

<p><strong>暂存死区</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = 100;</span><br><span class="line"></span><br><span class="line">if(1)&#123;</span><br><span class="line">    a = 10;</span><br><span class="line">    //在当前块作用域中存在a使用let/const声明的情况下，给a赋值10时，只会在当前作用域找变量a，</span><br><span class="line">    // 而这时，还未到声明时候，所以控制台Error:a is not defined</span><br><span class="line">    let a = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>const</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* 　　1、一旦声明必须赋值,不能使用null占位。</span><br><span class="line">*</span><br><span class="line">* 　　2、声明后不能再修改</span><br><span class="line">*</span><br><span class="line">* 　　3、如果声明的是复合类型数据，可以修改其属性</span><br><span class="line">*</span><br><span class="line">* */</span><br><span class="line"></span><br><span class="line">const a = 100; </span><br><span class="line"></span><br><span class="line">const list = [];</span><br><span class="line">list[0] = 10;</span><br><span class="line">console.log(list);　　// [10]</span><br><span class="line"></span><br><span class="line">const obj = &#123;a:100&#125;;</span><br><span class="line">obj.name = &apos;apple&apos;;</span><br><span class="line">obj.a = 10000;</span><br><span class="line">console.log(obj);　　// &#123;a:10000,name:&apos;apple&apos;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="43-什么是箭头函数？"><a href="#43-什么是箭头函数？" class="headerlink" title="43. 什么是箭头函数？"></a>43. 什么是箭头函数？</h3><p>箭头函数表达式的语法比函数表达式更简洁，并且没有自己的<code>this</code>，<code>arguments</code>，<code>super</code>或<code>new.target</code>。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//ES5 Version</span><br><span class="line">var getCurrentDate = function ()&#123;</span><br><span class="line">  return new Date();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ES6 Version</span><br><span class="line">const getCurrentDate = () =&gt; new Date();</span><br></pre></td></tr></table></figure>

<p>在本例中，ES5 版本中有<code>function(){}</code>声明和<code>return</code>关键字，这两个关键字分别是创建函数和返回值所需要的。在箭头函数版本中，我们只需要<code>()</code>括号，不需要 <code>return</code> 语句，因为如果我们只有一个表达式或值需要返回，箭头函数就会有一个隐式的返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//ES5 Version</span><br><span class="line">function greet(name) &#123;</span><br><span class="line">  return &apos;Hello &apos; + name + &apos;!&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ES6 Version</span><br><span class="line">const greet = (name) =&gt; `Hello $&#123;name&#125;`;</span><br><span class="line">const greet2 = name =&gt; `Hello $&#123;name&#125;`;</span><br></pre></td></tr></table></figure>

<p>我们还可以在箭头函数中使用与函数表达式和函数声明相同的参数。如果我们在一个箭头函数中有一个参数，则可以省略括号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const getArgs = () =&gt; arguments</span><br><span class="line"></span><br><span class="line">const getArgs2 = (...rest) =&gt; rest</span><br></pre></td></tr></table></figure>

<p>箭头函数不能访问<code>arguments</code>对象。所以调用第一个<code>getArgs</code>函数会抛出一个错误。相反，我们可以使用<strong>rest</strong>参数来获得在箭头函数中传递的所有参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const data = &#123;</span><br><span class="line">  result: 0,</span><br><span class="line">  nums: [1, 2, 3, 4, 5],</span><br><span class="line">  computeResult() &#123;</span><br><span class="line">    // 这里的“this”指的是“data”对象</span><br><span class="line">    const addAll = () =&gt; &#123;</span><br><span class="line">      return this.nums.reduce((total, cur) =&gt; total + cur, 0)</span><br><span class="line">    &#125;;</span><br><span class="line">    this.result = addAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>箭头函数没有自己的<code>this</code>值。它捕获词法作用域函数的<code>this</code>值，在此示例中，<code>addAll</code>函数将复制<code>computeResult</code> 方法中的<code>this</code>值，如果我们在全局作用域声明箭头函数，则<code>this</code>值为 <code>window</code> 对象。</p>
<h3 id="44-什么是类？"><a href="#44-什么是类？" class="headerlink" title="44. 什么是类？"></a>44. 什么是类？</h3><p><code>类(class)</code>是在 JS 中编写构造函数的新方法。它是使用构造函数的语法糖，在底层中使用仍然是原型和基于原型的继承。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//ES5 Version</span><br><span class="line">function Person(firstName, lastName, age, address)&#123;</span><br><span class="line">   this.firstName = firstName;</span><br><span class="line">   this.lastName = lastName;</span><br><span class="line">   this.age = age;</span><br><span class="line">   this.address = address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.self = function()&#123;</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.toString = function()&#123;</span><br><span class="line">  return &quot;[object Person]&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getFullName = function ()&#123;</span><br><span class="line">  return this.firstName + &quot; &quot; + this.lastName;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">//ES6 Version</span><br><span class="line">class Person &#123;</span><br><span class="line">     constructor(firstName, lastName, age, address)&#123;</span><br><span class="line">         this.lastName = lastName;</span><br><span class="line">         this.firstName = firstName;</span><br><span class="line">         this.age = age;</span><br><span class="line">         this.address = address;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     static self() &#123;</span><br><span class="line">        return this;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     toString()&#123;</span><br><span class="line">        return &quot;[object Person]&quot;;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     getFullName()&#123;</span><br><span class="line">        return `$&#123;this.firstName&#125; $&#123;this.lastName&#125;`;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重写方法并从另一个类继承。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//ES5 Version</span><br><span class="line">Employee.prototype = Object.create(Person.prototype);</span><br><span class="line"></span><br><span class="line">function Employee(firstName, lastName, age, address, jobTitle, yearStarted) &#123;</span><br><span class="line">  Person.call(this, firstName, lastName, age, address);</span><br><span class="line">  this.jobTitle = jobTitle;</span><br><span class="line">  this.yearStarted = yearStarted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Employee.prototype.describe = function () &#123;</span><br><span class="line">  return `I am $&#123;this.getFullName()&#125; and I have a position of $&#123;this.jobTitle&#125; and I started at $&#123;this.yearStarted&#125;`;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Employee.prototype.toString = function () &#123;</span><br><span class="line">  return &quot;[object Employee]&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ES6 Version</span><br><span class="line">class Employee extends Person &#123; //Inherits from &quot;Person&quot; class</span><br><span class="line">  constructor(firstName, lastName, age, address, jobTitle, yearStarted) &#123;</span><br><span class="line">    super(firstName, lastName, age, address);</span><br><span class="line">    this.jobTitle = jobTitle;</span><br><span class="line">    this.yearStarted = yearStarted;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  describe() &#123;</span><br><span class="line">    return `I am $&#123;this.getFullName()&#125; and I have a position of $&#123;this.jobTitle&#125; and I started at $&#123;this.yearStarted&#125;`;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123; // Overriding the &quot;toString&quot; method of &quot;Person&quot;</span><br><span class="line">    return &quot;[object Employee]&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以我们要怎么知道它在内部使用原型？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Something &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function AnotherSomething()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">const as = new AnotherSomething();</span><br><span class="line">const s = new Something();</span><br><span class="line"></span><br><span class="line">console.log(typeof Something); // &quot;function&quot;</span><br><span class="line">console.log(typeof AnotherSomething); // &quot;function&quot;</span><br><span class="line">console.log(as.toString()); // &quot;[object Object]&quot;</span><br><span class="line">console.log(as.toString()); // &quot;[object Object]&quot;</span><br><span class="line">console.log(as.toString === Object.prototype.toString); // true</span><br><span class="line">console.log(s.toString === Object.prototype.toString); // true</span><br></pre></td></tr></table></figure>

<h3 id="45-什么是模板字符串？"><a href="#45-什么是模板字符串？" class="headerlink" title="45. 什么是模板字符串？"></a>45. 什么是模板字符串？</h3><p>模板字符串是在 JS 中创建字符串的一种新方法。我们可以通过使用反引号使模板字符串化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//ES5 Version</span><br><span class="line">var greet = &apos;Hi I\&apos;m Mark&apos;;</span><br><span class="line"></span><br><span class="line">//ES6 Version</span><br><span class="line">let greet = `Hi I&apos;m Mark`;</span><br></pre></td></tr></table></figure>

<p>在 ES5 中我们需要使用一些转义字符来达到多行的效果，在模板字符串不需要这么麻烦：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//ES5 Version</span><br><span class="line">var lastWords = &apos;\n&apos;</span><br><span class="line">  + &apos;   I  \n&apos;</span><br><span class="line">  + &apos;   Am  \n&apos;</span><br><span class="line">  + &apos;Iron Man \n&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//ES6 Version</span><br><span class="line">let lastWords = `</span><br><span class="line">    I</span><br><span class="line">    Am</span><br><span class="line">  Iron Man   </span><br><span class="line">`;</span><br></pre></td></tr></table></figure>

<p>在ES5版本中，我们需要添加<code>\n</code>以在字符串中添加新行。在模板字符串中，我们不需要这样做。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//ES5 Version</span><br><span class="line">function greet(name) &#123;</span><br><span class="line">  return &apos;Hello &apos; + name + &apos;!&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//ES6 Version</span><br><span class="line">function greet(name) &#123;</span><br><span class="line">  return `Hello $&#123;name&#125; !`;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 ES5 版本中，如果需要在字符串中添加表达式或值，则需要使用<code>+</code>运算符。在模板字符串s中，我们可以使用<code>${expr}</code>嵌入一个表达式，这使其比 ES5 版本更整洁。</p>
<h3 id="46-什么是对象解构？"><a href="#46-什么是对象解构？" class="headerlink" title="46. 什么是对象解构？"></a>46. 什么是对象解构？</h3><p><strong>对象析构</strong>是从对象或数组中获取或提取值的一种新的、更简洁的方法。假设有如下的对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const employee = &#123;</span><br><span class="line">  firstName: &quot;Marko&quot;,</span><br><span class="line">  lastName: &quot;Polo&quot;,</span><br><span class="line">  position: &quot;Software Developer&quot;,</span><br><span class="line">  yearHired: 2017</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从对象获取属性，早期方法是创建一个与对象属性同名的变量。这种方法很麻烦，因为我们要为每个属性创建一个新变量。假设我们有一个大对象，它有很多属性和方法，用这种方法提取属性会很麻烦。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var firstName = employee.firstName;</span><br><span class="line">var lastName = employee.lastName;</span><br><span class="line">var position = employee.position;</span><br><span class="line">var yearHired = employee.yearHired;</span><br></pre></td></tr></table></figure>

<p>使用解构方式语法就变得简洁多了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; firstName, lastName, position, yearHired &#125; = employee;</span><br></pre></td></tr></table></figure>

<p>我们还可以为属性取别名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let &#123; firstName: fName, lastName: lName, position, yearHired &#125; = employee;</span><br></pre></td></tr></table></figure>

<p>当然如果属性值为 <code>undefined</code> 时，我们还可以指定默认值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let &#123; firstName = &quot;Mark&quot;, lastName: lName, position, yearHired &#125; = employee;</span><br></pre></td></tr></table></figure>

<h3 id="47-什么是-ES6-模块？"><a href="#47-什么是-ES6-模块？" class="headerlink" title="47. 什么是 ES6 模块？"></a>47. 什么是 ES6 模块？</h3><p><strong>模块</strong>使我们能够将代码基础分割成多个文件，以获得更高的可维护性，并且避免将所有代码放在一个大文件中。在 ES6 支持模块之前，有两个流行的模块。</p>
<ul>
<li><strong>CommonJS-Node.js</strong></li>
<li>AMD（异步模块定义）-<strong>浏览器</strong></li>
</ul>
<p>基本上，使用模块的方式很简单，<code>import</code>用于从另一个文件中获取功能或几个功能或值，同时<code>export</code>用于从文件中公开功能或几个功能或值。</p>
<p><strong>导出</strong></p>
<p>使用 ES5 (CommonJS)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 使用 ES5 CommonJS - helpers.js</span><br><span class="line">exports.isNull = function (val) &#123;</span><br><span class="line">  return val === null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.isUndefined = function (val) &#123;</span><br><span class="line">  return val === undefined;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.isNullOrUndefined = function (val) &#123;</span><br><span class="line">  return exports.isNull(val) || exports.isUndefined(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 ES6 模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 使用 ES6 Modules - helpers.js</span><br><span class="line">export function isNull(val)&#123;</span><br><span class="line">  return val === null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function isUndefined(val) &#123;</span><br><span class="line">  return val === undefined;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function isNullOrUndefined(val) &#123;</span><br><span class="line">  return isNull(val) || isUndefined(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在另一个文件中导入函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 使用 ES5 (CommonJS) - index.js</span><br><span class="line">const helpers = require(&apos;./helpers.js&apos;); // helpers is an object</span><br><span class="line">const isNull = helpers.isNull;</span><br><span class="line">const isUndefined = helpers.isUndefined;</span><br><span class="line">const isNullOrUndefined = helpers.isNullOrUndefined;</span><br><span class="line"></span><br><span class="line">// or if your environment supports Destructuring</span><br><span class="line">const &#123; isNull, isUndefined, isNullOrUndefined &#125; = require(&apos;./helpers.js&apos;);</span><br><span class="line">-------------------------------------------------------</span><br><span class="line"></span><br><span class="line">// ES6 Modules - index.js</span><br><span class="line">import * as helpers from &apos;./helpers.js&apos;; // helpers is an object</span><br><span class="line"></span><br><span class="line">// or </span><br><span class="line"></span><br><span class="line">import &#123; isNull, isUndefined, isNullOrUndefined as isValid &#125; from &apos;./helpers.js&apos;;</span><br><span class="line"></span><br><span class="line">// using &quot;as&quot; for renaming named exports</span><br></pre></td></tr></table></figure>

<p><strong>在文件中导出单个功能或默认导出</strong></p>
<p>使用 ES5 (CommonJS)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 使用 ES5 (CommonJS) - index.js</span><br><span class="line">class Helpers &#123;</span><br><span class="line">  static isNull(val) &#123;</span><br><span class="line">    return val === null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static isUndefined(val) &#123;</span><br><span class="line">    return val === undefined;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static isNullOrUndefined(val) &#123;</span><br><span class="line">    return this.isNull(val) || this.isUndefined(val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module.exports = Helpers;</span><br></pre></td></tr></table></figure>

<p>使用ES6 Modules</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 使用 ES6 Modules - helpers.js</span><br><span class="line">class Helpers &#123;</span><br><span class="line">  static isNull(val) &#123;</span><br><span class="line">    return val === null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static isUndefined(val) &#123;</span><br><span class="line">    return val === undefined;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static isNullOrUndefined(val) &#123;</span><br><span class="line">    return this.isNull(val) || this.isUndefined(val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Helpers</span><br></pre></td></tr></table></figure>

<p>从另一个文件导入单个功能</p>
<p>使用ES5 (CommonJS)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 使用 ES5 (CommonJS) - index.js</span><br><span class="line">const Helpers = require(&apos;./helpers.js&apos;); </span><br><span class="line">console.log(Helpers.isNull(null));</span><br></pre></td></tr></table></figure>

<p>使用 ES6 Modules</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import Helpers from &apos;.helpers.js&apos;</span><br><span class="line">console.log(Helpers.isNull(null));</span><br></pre></td></tr></table></figure>

<h3 id="48-什么是Set对象，它是如何工作的？"><a href="#48-什么是Set对象，它是如何工作的？" class="headerlink" title="48. 什么是Set对象，它是如何工作的？"></a>48. 什么是<code>Set</code>对象，它是如何工作的？</h3><p><strong>Set</strong> 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。</p>
<p>我们可以使用<code>Set</code>构造函数创建<code>Set</code>实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const set1 = new Set();</span><br><span class="line">const set2 = new Set([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;d&quot;,&quot;e&quot;]);</span><br></pre></td></tr></table></figure>

<p>我们可以使用<code>add</code>方法向<code>Set</code>实例中添加一个新值，因为<code>add</code>方法返回<code>Set</code>对象，所以我们可以以链式的方式再次使用<code>add</code>。如果一个值已经存在于<code>Set</code>对象中，那么它将不再被添加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set2.add(&quot;f&quot;);</span><br><span class="line">set2.add(&quot;g&quot;).add(&quot;h&quot;).add(&quot;i&quot;).add(&quot;j&quot;).add(&quot;k&quot;).add(&quot;k&quot;);</span><br><span class="line">// 后一个“k”不会被添加到set对象中，因为它已经存在了</span><br></pre></td></tr></table></figure>

<p>我们可以使用<code>has</code>方法检查<code>Set</code>实例中是否存在特定的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set2.has(&quot;a&quot;) // true</span><br><span class="line">set2.has(&quot;z&quot;) // true</span><br></pre></td></tr></table></figure>

<p>我们可以使用<code>size</code>属性获得<code>Set</code>实例的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set2.size // returns 10</span><br></pre></td></tr></table></figure>

<p>可以使用<code>clear</code>方法删除 <code>Set</code> 中的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set2.clear();</span><br></pre></td></tr></table></figure>

<p>我们可以使用<code>Set</code>对象来删除数组中重复的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const numbers = [1, 2, 3, 4, 5, 6, 6, 7, 8, 8, 5];</span><br><span class="line">const uniqueNums = [...new Set(numbers)]; // [1,2,3,4,5,6,7,8]</span><br></pre></td></tr></table></figure>

<h3 id="49-什么是回调函数？"><a href="#49-什么是回调函数？" class="headerlink" title="49. 什么是回调函数？"></a>49. 什么是回调函数？</h3><p><strong>回调函数</strong>是一段可执行的代码段，它作为一个参数传递给其他的代码，其作用是在需要的时候方便调用这段（回调函数）代码。</p>
<p>在JavaScript中函数也是对象的一种，同样对象可以作为参数传递给函数，因此函数也可以作为参数传递给另外一个函数，这个作为参数的函数就是回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const btnAdd = document.getElementById(&apos;btnAdd&apos;);</span><br><span class="line"></span><br><span class="line">btnAdd.addEventListener(&apos;click&apos;, function clickCallback(e) &#123;</span><br><span class="line">    // do something useless</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在本例中，我们等待<code>id</code>为<code>btnAdd</code>的元素中的<code>click</code>事件，如果它被单击，则执行<code>clickCallback</code>函数。回调函数向某些数据或事件添加一些功能。</p>
<p>数组中的<code>reduce</code>、<code>filter</code>和<code>map</code>方法需要一个回调作为参数。回调的一个很好的类比是，当你打电话给某人，如果他们不接，你留下一条消息，你期待他们回调。调用某人或留下消息的行为是事件或数据，回调是你希望稍后发生的操作。</p>
<h3 id="50-Promise-是什么？"><a href="#50-Promise-是什么？" class="headerlink" title="50. Promise 是什么？"></a>50. Promise 是什么？</h3><p><strong>Promise</strong> 是异步编程的一种解决方案：从语法上讲，<code>promise</code>是一个对象，从它可以获取异步操作的消息；从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。<code>promise</code>有三种状态：<code>pending(等待态)</code>，<code>fulfiled(成功态)</code>，<code>rejected(失败态)</code>；状态一旦改变，就不会再变。创造<code>promise</code>实例后，它会立即执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&apos;somefile.txt&apos;, function (e, data) &#123;</span><br><span class="line">  if (e) &#123;</span><br><span class="line">    console.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果我们在回调内部有另一个异步操作，则此方法存在问题。我们将有一个混乱且不可读的代码。此代码称为<strong>“回调地狱”</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 回调地狱</span><br><span class="line">fs.readFile(&apos;somefile.txt&apos;, function (e, data) &#123;</span><br><span class="line">  //your code here</span><br><span class="line">  fs.readdir(&apos;directory&apos;, function (e, files) &#123;</span><br><span class="line">    //your code here</span><br><span class="line">    fs.mkdir(&apos;directory&apos;, function (e) &#123;</span><br><span class="line">      //your code here</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果我们在这段代码中使用<code>promise</code>，它将更易于阅读、理解和维护。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">promReadFile(&apos;file/path&apos;)</span><br><span class="line">  .then(data =&gt; &#123;</span><br><span class="line">    return promReaddir(&apos;directory&apos;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(data =&gt; &#123;</span><br><span class="line">    return promMkdir(&apos;directory&apos;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(e =&gt; &#123;</span><br><span class="line">    console.log(e);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p><code>promise</code>有三种不同的状态：</p>
<ul>
<li>pending：初始状态，完成或失败状态的前一个状态</li>
<li>fulfilled：操作成功完成</li>
<li>rejected：操作失败</li>
</ul>
<p><code>pending</code> 状态的 <code>Promise</code> 对象会触发 <code>fulfilled/rejected</code> 状态，在其状态处理方法中可以传入参数/失败信息。当操作成功完成时，<strong>Promise</strong> 对象的 <code>then</code> 方法就会被调用；否则就会触发 <code>catch</code>。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const myFirstPromise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        resolve(&quot;成功!&quot;); </span><br><span class="line">    &#125;, 250);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myFirstPromise.then((data) =&gt; &#123;</span><br><span class="line">    console.log(&quot;Yay! &quot; + data);</span><br><span class="line">&#125;).catch((e) =&gt; &#123;...&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="51-什么是-async-await-及其如何工作？"><a href="#51-什么是-async-await-及其如何工作？" class="headerlink" title="51. 什么是 async/await 及其如何工作？"></a>51. 什么是 <code>async/await</code> 及其如何工作？</h3><p><code>async/await</code>是 JS 中编写异步或非阻塞代码的新方法。它建立在<strong>Promises</strong>之上，让异步代码的可读性和简洁度都更高。</p>
<p><code>async/await</code>是 JS 中编写异步或非阻塞代码的新方法。它建立在<code>Promises</code>之上，相对于 Promise 和回调，它的可读性和简洁度都更高。但是，在使用此功能之前，我们必须先学习<code>Promises</code>的基础知识，因为正如我之前所说，它是基于<code>Promise</code>构建的，这意味着幕后使用仍然是<strong>Promise</strong>。</p>
<p><strong>使用 Promise</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function callApi() &#123;</span><br><span class="line">  return fetch(&quot;url/to/api/endpoint&quot;)</span><br><span class="line">    .then(resp =&gt; resp.json())</span><br><span class="line">    .then(data =&gt; &#123;</span><br><span class="line">      //do something with &quot;data&quot;</span><br><span class="line">    &#125;).catch(err =&gt; &#123;</span><br><span class="line">      //do something with &quot;err&quot;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用async/await</strong></p>
<p>在<code>async/await</code>，我们使用 tru/catch 语法来捕获异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async function callApi() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const resp = await fetch(&quot;url/to/api/endpoint&quot;);</span><br><span class="line">    const data = await resp.json();</span><br><span class="line">    //do something with &quot;data&quot;</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    //do something with &quot;err&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>:使用 <code>async</code>关键声明函数会隐式返回一个<strong>Promise</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const giveMeOne = async () =&gt; 1;</span><br><span class="line"></span><br><span class="line">giveMeOne()</span><br><span class="line">  .then((num) =&gt; &#123;</span><br><span class="line">    console.log(num); // logs 1</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong><code>await</code>关键字只能在<code>async function</code>中使用。在任何非<strong>async function</strong>的函数中使用<code>await</code>关键字都会抛出错误。<code>await</code>关键字在执行下一行代码之前等待右侧表达式(可能是一个<strong>Promise</strong>)返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const giveMeOne = async () =&gt; 1;</span><br><span class="line"></span><br><span class="line">function getOne() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const num = await giveMeOne();</span><br><span class="line">    console.log(num);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    console.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Uncaught SyntaxError: await is only valid in async function</span><br><span class="line"></span><br><span class="line">async function getTwo() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const num1 = await giveMeOne(); // 这行会等待右侧表达式执行完成</span><br><span class="line">    const num2 = await giveMeOne(); </span><br><span class="line">    return num1 + num2;</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    console.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">await getTwo(); // 2</span><br></pre></td></tr></table></figure>

<h3 id="52-展开-spread-运算符和-剩余-Rest-运算符有什么区别？"><a href="#52-展开-spread-运算符和-剩余-Rest-运算符有什么区别？" class="headerlink" title="52. 展开(spread )运算符和 剩余(Rest) 运算符有什么区别？"></a>52. 展开(spread )运算符和 剩余(Rest) 运算符有什么区别？</h3><p>展开运算符(spread)是三个点(<code>...</code>)，可以将一个数组转为用逗号分隔的参数序列。说的通俗易懂点，有点像化骨绵掌，把一个大元素给打散成一个个单独的小元素。</p>
<p>剩余运算符也是用三个点(<code>...</code>)表示，它的样子看起来和展开操作符一样，但是它是用于解构数组和对象。在某种程度上，剩余元素和展开元素相反，展开元素会“展开”数组变成多个元素，剩余元素会收集多个元素和“压缩”成一个单一的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const nums = [5, 6];</span><br><span class="line">const sum = add(...nums);</span><br><span class="line">console.log(sum);</span><br></pre></td></tr></table></figure>

<p>在本例中，我们在调用<code>add</code>函数时使用了展开操作符，对<code>nums</code>数组进行展开。所以参数<code>a</code>的值是<code>5</code> ，<code>b</code>的值是<code>6</code>，所以<code>sum</code> 是<code>11</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function add(...rest) &#123;</span><br><span class="line">  return rest.reduce((total,current) =&gt; total + current);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(add(1, 2)); // 3</span><br><span class="line">console.log(add(1, 2, 3, 4, 5)); // 15</span><br></pre></td></tr></table></figure>

<p>在本例中，我们有一个<code>add</code>函数，它接受任意数量的参数，并将它们全部相加，然后返回总数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const [first, ...others] = [1, 2, 3, 4, 5];</span><br><span class="line">console.log(first); // 1</span><br><span class="line">console.log(others); // [2,3,4,5]</span><br></pre></td></tr></table></figure>

<p>这里，我们使用剩余操作符提取所有剩余的数组值，并将它们放入除第一项之外的其他数组中。</p>
<h3 id="53-什么是默认参数？"><a href="#53-什么是默认参数？" class="headerlink" title="53. 什么是默认参数？"></a>53. 什么是默认参数？</h3><p>默认参数是在 JS 中定义默认变量的一种新方法，它在ES6或ECMAScript 2015版本中可用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//ES5 Version</span><br><span class="line">function add(a,b)&#123;</span><br><span class="line">  a = a || 0;</span><br><span class="line">  b = b || 0;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ES6 Version</span><br><span class="line">function add(a = 0, b = 0)&#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">add(1); // returns 1</span><br></pre></td></tr></table></figure>

<p>我们还可以在默认参数中使用解构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function getFirst([first, ...rest] = [0, 1]) &#123;</span><br><span class="line">  return first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFirst();  // 0</span><br><span class="line">getFirst([10,20,30]);  // 10</span><br><span class="line"></span><br><span class="line">function getArr(&#123; nums &#125; = &#123; nums: [1, 2, 3, 4] &#125;)&#123;</span><br><span class="line">    return nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getArr(); // [1, 2, 3, 4]</span><br><span class="line">getArr(&#123;nums:[5,4,3,2,1]&#125;); // [5,4,3,2,1]</span><br></pre></td></tr></table></figure>

<p>我们还可以使用先定义的参数再定义它们之后的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function doSomethingWithValue(value = &quot;Hello World&quot;, callback = () =&gt; &#123; console.log(value) &#125;) &#123;</span><br><span class="line">  callback();</span><br><span class="line">&#125;</span><br><span class="line">doSomethingWithValue(); //&quot;Hello World&quot;</span><br></pre></td></tr></table></figure>

<h3 id="54-什么是包装对象（wrapper-object）？"><a href="#54-什么是包装对象（wrapper-object）？" class="headerlink" title="54. 什么是包装对象（wrapper object）？"></a>54. 什么是包装对象（wrapper object）？</h3><p>我们现在复习一下JS的数据类型，JS数据类型被分为两大类，<strong>基本类型</strong>和<strong>引用类型</strong>。</p>
<p>基本类型：<code>Undefined</code>,<code>Null</code>,<code>Boolean</code>,<code>Number</code>,<code>String</code>,<code>Symbol</code>,<code>BigInt</code></p>
<p>引用类型：<code>Object</code>,<code>Array</code>,<code>Date</code>,<code>RegExp</code>等，说白了就是对象。</p>
<p>其中引用类型有方法和属性，但是基本类型是没有的，但我们经常会看到下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let name = &quot;marko&quot;;</span><br><span class="line"></span><br><span class="line">console.log(typeof name); // &quot;string&quot;</span><br><span class="line">console.log(name.toUpperCase()); // &quot;MARKO&quot;</span><br></pre></td></tr></table></figure>

<p><code>name</code>类型是 <code>string</code>，属于基本类型，所以它没有属性和方法，但是在这个例子中，我们调用了一个<code>toUpperCase()</code>方法，它不会抛出错误，还返回了对象的变量值。</p>
<p>原因是基本类型的值被临时转换或强制转换为<strong>对象</strong>，因此<code>name</code>变量的行为类似于<strong>对象</strong>。除<code>null</code>和<code>undefined</code>之外的每个基本类型都有自己<strong>包装对象</strong>。也就是：<code>String</code>，<code>Number</code>，<code>Boolean</code>，<code>Symbol</code>和<code>BigInt</code>。在这种情况下，<code>name.toUpperCase()</code>在幕后看起来如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(new String(name).toUpperCase()); // &quot;MARKO&quot;</span><br></pre></td></tr></table></figure>

<p>在完成访问属性或调用方法之后，新创建的对象将立即被丢弃。</p>
<h3 id="55-隐式和显式转换有什么区别）？"><a href="#55-隐式和显式转换有什么区别）？" class="headerlink" title="55. 隐式和显式转换有什么区别）？"></a>55. 隐式和显式转换有什么区别）？</h3><p>隐式强制转换是一种将值转换为另一种类型的方法，这个过程是自动完成的，无需我们手动操作。</p>
<p>假设我们下面有一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(1 + &apos;6&apos;); // 16</span><br><span class="line">console.log(false + true); // 1</span><br><span class="line">console.log(6 * &apos;2&apos;); // 12</span><br></pre></td></tr></table></figure>

<p>第一个<code>console.log</code>语句结果为<code>16</code>。在其他语言中，这会抛出编译时错误，但在 JS 中，<code>1</code>被转换成字符串，然后与<code>+运</code>算符连接。我们没有做任何事情，它是由 JS 自动完成。</p>
<p>第二个<code>console.log</code>语句结果为<code>1</code>，JS 将<code>false</code>转换为<code>boolean</code> 值为 <code>0</code>，,<code>true</code>为<code>1</code>，因此结果为<code>1</code>。</p>
<p>第三个<code>console.log</code>语句结果<code>12</code>，它将<code>&#39;2&#39;</code>转换为一个数字，然后乘以<code>6 * 2</code>，结果是12。</p>
<p>而显式强制是将值转换为另一种类型的方法，我们需要手动转换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(1 + parseInt(&apos;6&apos;));</span><br></pre></td></tr></table></figure>

<p>在本例中，我们使用<code>parseInt</code>函数将<code>&#39;6&#39;</code>转换为<code>number</code> ，然后使用<code>+</code>运算符将<code>1</code>和<code>6</code>相加。</p>
<h3 id="56-什么是NaN？以及如何检查值是否为NaN？"><a href="#56-什么是NaN？以及如何检查值是否为NaN？" class="headerlink" title="56. 什么是NaN？以及如何检查值是否为NaN？"></a>56. 什么是NaN？以及如何检查值是否为NaN？</h3><p><code>NaN</code>表示<strong>“非数字”</strong>是 JS 中的一个值，该值是将数字转换或执行为非数字值的运算结果，因此结果为<code>NaN</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let a;</span><br><span class="line"></span><br><span class="line">console.log(parseInt(&apos;abc&apos;)); // NaN</span><br><span class="line">console.log(parseInt(null)); // NaN</span><br><span class="line">console.log(parseInt(undefined)); // NaN</span><br><span class="line">console.log(parseInt(++a)); // NaN</span><br><span class="line">console.log(parseInt(&#123;&#125; * 10)); // NaN</span><br><span class="line">console.log(parseInt(&apos;abc&apos; - 2)); // NaN</span><br><span class="line">console.log(parseInt(0 / 0)); // NaN</span><br><span class="line">console.log(parseInt(&apos;10a&apos; * 10)); // NaN</span><br></pre></td></tr></table></figure>

<p>JS 有一个内置的<code>isNaN</code>方法，用于测试值是否为isNaN值，但是这个函数有一个奇怪的行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(isNaN()); // true</span><br><span class="line">console.log(isNaN(undefined)); // true</span><br><span class="line">console.log(isNaN(&#123;&#125;)); // true</span><br><span class="line">console.log(isNaN(String(&apos;a&apos;))); // true</span><br><span class="line">console.log(isNaN(() =&gt; &#123; &#125;)); // true</span><br></pre></td></tr></table></figure>

<p>所有这些<code>console.log</code>语句都返回<code>true</code>，即使我们传递的值不是<code>NaN</code>。</p>
<p>在<code>ES6</code>中，建议使用<code>Number.isNaN</code>方法，因为它确实会检查该值（如果确实是<code>NaN</code>），或者我们可以使自己的辅助函数检查此问题，因为在 JS 中，<strong>NaN</strong>是唯一的值，它不等于自己。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function checkIfNaN(value) &#123;</span><br><span class="line">  return value !== value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="57-如何判断值是否为数组？"><a href="#57-如何判断值是否为数组？" class="headerlink" title="57. 如何判断值是否为数组？"></a>57. 如何判断值是否为数组？</h3><p>我们可以使用<code>Array.isArray</code>方法来检查值是否为<strong>数组</strong>。当传递给它的参数是数组时，它返回<code>true</code>，否则返回<code>false</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(Array.isArray(5));  // false</span><br><span class="line">console.log(Array.isArray(&quot;&quot;)); // false</span><br><span class="line">console.log(Array.isArray()); // false</span><br><span class="line">console.log(Array.isArray(null)); // false</span><br><span class="line">console.log(Array.isArray(&#123; length: 5 &#125;)); // false</span><br><span class="line"></span><br><span class="line">console.log(Array.isArray([])); // true</span><br></pre></td></tr></table></figure>

<p>如果环境不支持此方法，则可以使用<code>polyfill</code>实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function isArray(value)&#123;</span><br><span class="line"> return Object.prototype.toString.call(value) === &quot;[object Array]&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然还可以使用传统的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a = []</span><br><span class="line">if (a instanceof Array) &#123;</span><br><span class="line">  console.log(&apos;是数组&apos;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  console.log(&apos;非数组&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="58-如何在不使用-模运算符的情况下检查一个数字是否是偶数？"><a href="#58-如何在不使用-模运算符的情况下检查一个数字是否是偶数？" class="headerlink" title="58. 如何在不使用%模运算符的情况下检查一个数字是否是偶数？"></a>58. 如何在不使用<code>%</code>模运算符的情况下检查一个数字是否是偶数？</h3><p>我们可以对这个问题使用按位<code>&amp;</code>运算符，<code>&amp;</code>对其操作数进行运算，并将其视为二进制值，然后执行与运算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function isEven(num) &#123;</span><br><span class="line">  if (num &amp; 1) &#123;</span><br><span class="line">    return false</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">0` 二进制数是 `000`</span><br><span class="line">`1` 二进制数是 `001`</span><br><span class="line">`2` 二进制数是 `010`</span><br><span class="line">`3` 二进制数是 `011`</span><br><span class="line">`4` 二进制数是 `100`</span><br><span class="line">`5` 二进制数是 `101`</span><br><span class="line">`6` 二进制数是 `110`</span><br><span class="line">`7` 二进制数是 `111</span><br></pre></td></tr></table></figure>

<p>以此类推…</p>
<p>与运算的规则如下：</p>
<table>
<thead>
<tr>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a &amp; b</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
</tbody></table>
<p>因此，当我们执行<code>console.log(5&amp;1)</code>这个表达式时，结果为<code>1</code>。首先，<code>&amp;</code>运算符将两个数字都转换为二进制，因此<code>5</code>变为<code>101</code>，<code>1</code>变为<code>001</code>。</p>
<p>然后，它使用按位怀运算符比较每个位（<code>0</code>和<code>1</code>）。<code>101&amp;001</code>，从表中可以看出，如果<code>a &amp; b</code>为<code>1</code>，所以<code>5&amp;1</code>结果为<code>1</code>。</p>
<table>
<thead>
<tr>
<th align="center">101 &amp; 001</th>
</tr>
</thead>
<tbody><tr>
<td align="center">101</td>
</tr>
<tr>
<td align="center">001</td>
</tr>
<tr>
<td align="center">001</td>
</tr>
</tbody></table>
<ul>
<li><p>首先我们比较最左边的<code>1&amp;0</code>，结果是<code>0</code>。</p>
</li>
<li><p>然后我们比较中间的<code>0&amp;0</code>，结果是<code>0</code>。</p>
</li>
<li><p>然后我们比较最后<code>1&amp;1</code>，结果是<code>1</code>。</p>
</li>
<li><p>最后，得到一个二进制数<code>001</code>，对应的十进制数，即<code>1</code>。</p>
<p>由此我们也可以算出<code>console.log(4 &amp; 1)</code> 结果为<code>0</code>。知道<code>4</code>的最后一位是<code>0</code>，而<code>0 &amp; 1</code> 将是<code>0</code>。如果你很难理解这一点，我们可以使用递归函数来解决此问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function isEven(num) &#123;  </span><br><span class="line">    if (num &lt; 0 || num === 1) return false;  </span><br><span class="line">    if (num == 0) return true;  </span><br><span class="line">    return isEven(num - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="59-如何检查对象中是否存在某个属性？"><a href="#59-如何检查对象中是否存在某个属性？" class="headerlink" title="59. 如何检查对象中是否存在某个属性？"></a>59. 如何检查对象中是否存在某个属性？</h3><p>检查对象中是否存在属性有三种方法。</p>
<p>第一种使用 <code>in</code> 操作符号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const o = &#123; </span><br><span class="line">  &quot;prop&quot; : &quot;bwahahah&quot;,</span><br><span class="line">  &quot;prop2&quot; : &quot;hweasa&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(&quot;prop&quot; in o); // true</span><br><span class="line">console.log(&quot;prop1&quot; in o); // false</span><br></pre></td></tr></table></figure>

<p>第二种使用 <code>hasOwnProperty</code> 方法，<code>hasOwnProperty()</code> 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(o.hasOwnProperty(&quot;prop2&quot;)); // true</span><br><span class="line">console.log(o.hasOwnProperty(&quot;prop1&quot;)); // false</span><br></pre></td></tr></table></figure>

<p>第三种使用括号符号<code>obj[&quot;prop&quot;]</code>。如果属性存在，它将返回该属性的值，否则将返回<code>undefined</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(o[&quot;prop&quot;]); // &quot;bwahahah&quot;</span><br><span class="line">console.log(o[&quot;prop1&quot;]); // undefined</span><br></pre></td></tr></table></figure>

<h3 id="60-AJAX-是什么？"><a href="#60-AJAX-是什么？" class="headerlink" title="60. AJAX 是什么？"></a>60. AJAX 是什么？</h3><p>即异步的 <strong>JavaScript 和 XML</strong>，是一种用于创建快速动态网页的技术，传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。使用<strong>AJAX</strong>则不需要加载更新整个网页，实现部分内容更新</p>
<p>用到AJAX的技术：</p>
<ul>
<li><strong>HTML</strong> - 网页结构</li>
<li><strong>CSS</strong> - 网页的样式</li>
<li><strong>JavaScript</strong> - 操作网页的行为和更新DOM</li>
<li><strong>XMLHttpRequest API</strong> - 用于从服务器发送和获取数据</li>
<li><strong>PHP，Python，Nodejs</strong> - 某些服务器端语言</li>
</ul>
<h3 id="61-如何在-JS-中创建对象？"><a href="#61-如何在-JS-中创建对象？" class="headerlink" title="61. 如何在 JS 中创建对象？"></a>61. 如何在 JS 中创建对象？</h3><p><strong>使用对象字面量：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const o = &#123;</span><br><span class="line">  name: &quot;前端小智&quot;,</span><br><span class="line">  greeting() &#123;</span><br><span class="line">    return `Hi, 我是$&#123;this.name&#125;`;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">o.greeting(); // &quot;Hi, 我是前端小智&quot;</span><br></pre></td></tr></table></figure>

<p><strong>使用构造函数：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">   this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.greeting = function () &#123;</span><br><span class="line">   return `Hi, 我是$&#123;this.name&#125;`;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mark = new Person(&quot;前端小智&quot;);</span><br><span class="line"></span><br><span class="line">mark.greeting(); // &quot;Hi, 我是前端小智&quot;</span><br></pre></td></tr></table></figure>

<p><strong>使用 Object.create 方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const n = &#123;</span><br><span class="line">   greeting() &#123;</span><br><span class="line">      return `Hi, 我是$&#123;this.name&#125;`;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const o = Object.create(n); </span><br><span class="line">o.name = &quot;前端小智&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="62-Object-seal-和-Object-freeze-方法之间有什么区别？"><a href="#62-Object-seal-和-Object-freeze-方法之间有什么区别？" class="headerlink" title="62. Object.seal 和 Object.freeze 方法之间有什么区别？"></a>62. Object.seal 和 Object.freeze 方法之间有什么区别？</h3><p><strong>Object.freeze()</strong></p>
<p><code>Object.freeze()</code> 方法可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改<code>。freeze()</code> 返回和传入的参数相同的对象。</p>
<p><strong>Object.seal()</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.seal()方法封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。当前属性的值只要可写就可以改变。</span><br></pre></td></tr></table></figure>

<p>方法的相同点：</p>
<ol>
<li>ES5新增。</li>
<li>对象不可能扩展，也就是不能再添加新的属性或者方法。</li>
<li>对象已有属性不允许被删除。</li>
<li>对象属性特性不可以重新配置。</li>
</ol>
<p>方法不同点：</p>
<ul>
<li><code>Object.seal</code>方法生成的密封对象，如果属性是可写的，那么可以修改属性值。<br><code>* Object.freeze</code>方法生成的冻结对象，属性都是不可写的，也就是属性值无法更改。</li>
</ul>
<h3 id="63-in-运算符和-Object-hasOwnProperty-方法有什么区别？"><a href="#63-in-运算符和-Object-hasOwnProperty-方法有什么区别？" class="headerlink" title="63. in 运算符和 Object.hasOwnProperty 方法有什么区别？"></a>63. <code>in</code> 运算符和 <code>Object.hasOwnProperty</code> 方法有什么区别？</h3><p><strong>hasOwnPropert方法</strong></p>
<p><code>hasOwnPropert()</code>方法返回值是一个布尔值，指示对象自身属性中是否具有指定的属性，因此这个方法会忽略掉那些从原型链上继承到的属性。</p>
<p>看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.phone= &apos;15345025546&apos;;</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">    name: &apos;前端小智&apos;,</span><br><span class="line">    age: &apos;28&apos;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj.hasOwnProperty(&apos;phone&apos;)) // false</span><br><span class="line">console.log(obj.hasOwnProperty(&apos;name&apos;)) // true</span><br></pre></td></tr></table></figure>

<p>可以看到，如果在函数原型上定义一个变量<code>phone</code>，<code>hasOwnProperty</code>方法会直接忽略掉。</p>
<p><strong>in 运算符</strong></p>
<p>如果指定的属性在指定的对象或其原型链中，则<code>in</code> 运算符返回<code>true</code>。</p>
<p>还是用上面的例子来演示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;phone&apos; in obj) // true</span><br></pre></td></tr></table></figure>

<p>可以看到<code>in</code>运算符会检查它或者其原型链是否包含具有指定名称的属性。</p>
<h3 id="64-有哪些方法可以处理-JS-中的异步代码？"><a href="#64-有哪些方法可以处理-JS-中的异步代码？" class="headerlink" title="64. 有哪些方法可以处理 JS 中的异步代码？"></a>64. 有哪些方法可以处理 JS 中的异步代码？</h3><ul>
<li>回调</li>
<li>Promise</li>
<li>async/await</li>
<li>还有一些库：async.js, bluebird, q, co</li>
</ul>
<h3 id="65-函数表达式和函数声明之间有什么区别？"><a href="#65-函数表达式和函数声明之间有什么区别？" class="headerlink" title="65. 函数表达式和函数声明之间有什么区别？"></a>65. 函数表达式和函数声明之间有什么区别？</h3><p>看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hoistedFunc();</span><br><span class="line">notHoistedFunc();</span><br><span class="line"></span><br><span class="line">function hoistedFunc()&#123;</span><br><span class="line">  console.log(&quot;注意：我会被提升&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var notHoistedFunc = function()&#123;</span><br><span class="line">  console.log(&quot;注意：我没有被提升&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>notHoistedFunc</code>调用抛出异常：<code>Uncaught TypeError: notHoistedFunc is not a function</code>，而<code>hoistedFunc</code>调用不会，因为<code>hoistedFunc</code>会被提升到作用域的顶部，而<code>notHoistedFunc</code> 不会。</p>
<h3 id="66-调用函数，可以使用哪些方法？"><a href="#66-调用函数，可以使用哪些方法？" class="headerlink" title="66. 调用函数，可以使用哪些方法？"></a>66. 调用函数，可以使用哪些方法？</h3><p>在 JS 中有4种方法可以调用函数。</p>
<p><strong>作为函数调用</strong>——如果一个函数没有作为方法、构造函数、<code>apply</code>、<code>call</code> 调用时，此时 <code>this</code> 指向的是 <code>window</code> 对象（非严格模式）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//Global Scope</span><br><span class="line"></span><br><span class="line">function add(a,b)&#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">add(1,5); // 打印 &quot;window&quot; 对象和 6</span><br><span class="line"></span><br><span class="line">const o = &#123;</span><br><span class="line">  method(callback)&#123;</span><br><span class="line">    callback();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.method(function ()&#123;</span><br><span class="line">    console.log(this); // 打印 &quot;window&quot; 对象</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>作为方法调用</strong>——如果一个对象的属性有一个函数的值，我们就称它为<strong>方法</strong>。调用该方法时，该方法的<code>this</code>值指向该对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const details = &#123;</span><br><span class="line">  name : &quot;Marko&quot;,</span><br><span class="line">  getName()&#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">details.getName(); // Marko</span><br></pre></td></tr></table></figure>

<p><strong>作为构造函数的调用</strong>-如果在函数之前使用<code>new</code>关键字调用了函数，则该函数称为<code>构造函数</code>。构造函数里面会默认创建一个空对象，并将<code>this</code>指向该对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Employee(name, position, yearHired) &#123;</span><br><span class="line">  // 创建一个空对象 &#123;&#125;</span><br><span class="line">  // 然后将空对象分配给“this”关键字</span><br><span class="line">  // this = &#123;&#125;;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.position = position;</span><br><span class="line">  this.yearHired = yearHired;</span><br><span class="line">  // 如果没有指定 return ,这里会默认返回 this</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const emp = new Employee(&quot;Marko Polo&quot;, &quot;Software Developer&quot;, 2017);</span><br></pre></td></tr></table></figure>

<p><strong>使用<code>apply</code>和<code>call</code>方法调用</strong>——如果我们想显式地指定一个函数的<code>this</code>值，我们可以使用这些方法，这些方法对所有函数都可用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const obj1 = &#123;</span><br><span class="line"> result:0</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const obj2 = &#123;</span><br><span class="line"> result:0</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function reduceAdd()&#123;</span><br><span class="line">   let result = 0;</span><br><span class="line">   for(let i = 0, len = arguments.length; i &lt; len; i++)&#123;</span><br><span class="line">     result += arguments[i];</span><br><span class="line">   &#125;</span><br><span class="line">   this.result = result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">reduceAdd.apply(obj1, [1, 2, 3, 4, 5]);  // reduceAdd 函数中的 this 对象将是 obj1</span><br><span class="line">reduceAdd.call(obj2, 1, 2, 3, 4, 5); // reduceAdd 函数中的 this 对象将是 obj2</span><br></pre></td></tr></table></figure>

<h3 id="67-什么是缓存及它有什么作用？"><a href="#67-什么是缓存及它有什么作用？" class="headerlink" title="67. 什么是缓存及它有什么作用？"></a>67. 什么是缓存及它有什么作用？</h3><p>缓存是建立一个函数的过程，这个函数能够记住之前计算的结果或值。使用缓存函数是为了避免在最后一次使用相同参数的计算中已经执行的函数的计算。这节省了时间，但也有不利的一面，即我们将消耗更多的内存来保存以前的结果。</p>
<h3 id="68-手动实现缓存方法"><a href="#68-手动实现缓存方法" class="headerlink" title="68. 手动实现缓存方法]"></a>68. 手动实现缓存方法]</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function memoize(fn) &#123;</span><br><span class="line">  const cache = &#123;&#125;;</span><br><span class="line">  return function (param) &#123;</span><br><span class="line">    if (cache[param]) &#123;</span><br><span class="line">      console.log(&apos;cached&apos;);</span><br><span class="line">      return cache[param];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      let result = fn(param);</span><br><span class="line">      cache[param] = result;</span><br><span class="line">      console.log(`not cached`);</span><br><span class="line">      return result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const toUpper = (str =&quot;&quot;)=&gt; str.toUpperCase();</span><br><span class="line"></span><br><span class="line">const toUpperMemoized = memoize(toUpper);</span><br><span class="line"></span><br><span class="line">toUpperMemoized(&quot;abcdef&quot;);</span><br><span class="line">toUpperMemoized(&quot;abcdef&quot;);</span><br></pre></td></tr></table></figure>

<p>这个缓存函数适用于接受一个参数。我们需要改变下，让它接受多个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const slice = Array.prototype.slice;</span><br><span class="line">function memoize(fn) &#123;</span><br><span class="line">  const cache = &#123;&#125;;</span><br><span class="line">  return (...args) =&gt; &#123;</span><br><span class="line">    const params = slice.call(args);</span><br><span class="line">    console.log(params);</span><br><span class="line">    if (cache[params]) &#123;</span><br><span class="line">      console.log(&apos;cached&apos;);</span><br><span class="line">      return cache[params];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      let result = fn(...args);</span><br><span class="line">      cache[params] = result;</span><br><span class="line">      console.log(`not cached`);</span><br><span class="line">      return result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const makeFullName = (fName, lName) =&gt; `$&#123;fName&#125; $&#123;lName&#125;`;</span><br><span class="line">const reduceAdd = (numbers, startingValue = 0) =&gt; numbers.reduce((total, cur) =&gt; total + cur, startingValue);</span><br><span class="line"></span><br><span class="line">const memoizedMakeFullName = memoize(makeFullName);</span><br><span class="line">const memoizedReduceAdd = memoize(reduceAdd);</span><br><span class="line"></span><br><span class="line">memoizedMakeFullName(&quot;Marko&quot;, &quot;Polo&quot;);</span><br><span class="line">memoizedMakeFullName(&quot;Marko&quot;, &quot;Polo&quot;);</span><br><span class="line"></span><br><span class="line">memoizedReduceAdd([1, 2, 3, 4, 5], 5);</span><br><span class="line">memoizedReduceAdd([1, 2, 3, 4, 5], 5);</span><br></pre></td></tr></table></figure>

<h3 id="69-为什么typeof-null-返回-object？如何检查一个值是否为-null？"><a href="#69-为什么typeof-null-返回-object？如何检查一个值是否为-null？" class="headerlink" title="69. 为什么typeof null 返回 object？如何检查一个值是否为 null？"></a>69. 为什么typeof null 返回 object？如何检查一个值是否为 null？</h3><p><code>typeof null == &#39;object&#39;</code>总是返回<code>true</code>，因为这是自 JS 诞生以来<code>null</code>的实现。曾经有人提出将<code>typeof null == &#39;object&#39;</code>修改为<code>typeof null == &#39;null&#39;</code>，但是被拒绝了，因为这将导致更多的<strong>bug</strong>。</p>
<p>我们可以使用严格相等运算符<code>===</code>来检查值是否为<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function isNull(value)&#123;</span><br><span class="line">  return value === null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="70-new-关键字有什么作用？"><a href="#70-new-关键字有什么作用？" class="headerlink" title="70. new 关键字有什么作用？"></a>70. new 关键字有什么作用？</h3><p><code>new</code>关键字与构造函数一起使用以创建对象:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Employee(name, position, yearHired) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.position = position;</span><br><span class="line">  this.yearHired = yearHired;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const emp = new Employee(&quot;Marko Polo&quot;, &quot;Software Developer&quot;, 2017);</span><br></pre></td></tr></table></figure>

<p><code>new</code>关键字做了<code>4</code>件事:</p>
<ul>
<li>创建空对象 <code>{}</code></li>
<li>将空对象分配给 <code>this</code> 值</li>
<li>将空对象的<code>**proto**</code>指向构造函数的<code>prototype</code></li>
<li>如果没有使用显式<code>return</code>语句，则返回<code>this</code></li>
</ul>
<p>看下面事例：</p>
<p>function Person() {<br> this.name = ‘前端小智’<br>}</p>
<p>根据上面描述的，<code>new Person()</code>做了：</p>
<ul>
<li>创建一个空对象：<code>var obj = {}</code></li>
<li>将空对象分配给 <code>this</code> 值：this = obj</li>
<li>将空对象的<code>**proto__</code>指向构造函数的<code>prototype</code>:<code>this.__proto** = Person().prototype</code></li>
<li>返回<code>this</code>:<code>return this</code></li>
</ul>
<h3 id="71-什么时候不使用箭头函数-说出三个或更多的例子？"><a href="#71-什么时候不使用箭头函数-说出三个或更多的例子？" class="headerlink" title="71. 什么时候不使用箭头函数? 说出三个或更多的例子？"></a>71. 什么时候不使用箭头函数? 说出三个或更多的例子？</h3><p>不应该使用箭头函数一些情况：</p>
<ul>
<li>当想要函数被提升时(箭头函数是匿名的)</li>
<li>要在函数中使用<code>this/arguments</code>时，由于箭头函数本身不具有<code>this/arguments</code>，因此它们取决于外部上下文</li>
<li>使用命名函数(箭头函数是匿名的)</li>
<li>使用函数作为构造函数时(箭头函数没有构造函数)</li>
<li>当想在对象字面是以将函数作为属性添加并在其中使用对象时，因为咱们无法访问 <code>this</code> 即对象本身。</li>
</ul>
<h3 id="72-Object-freeze-和-const-的区别是什么？"><a href="#72-Object-freeze-和-const-的区别是什么？" class="headerlink" title="72. Object.freeze() 和 const 的区别是什么？]"></a>72. Object.freeze() 和 const 的区别是什么？]</h3><p><code>const</code>和<code>Object.freeze</code>是两个完全不同的概念。</p>
<p><code>const</code> 声明一个只读的变量，一旦声明，常量的值就不可改变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">    name: &quot;Leonardo&quot;</span><br><span class="line">&#125;;</span><br><span class="line">let animal = &#123;</span><br><span class="line">    species: &quot;snake&quot;</span><br><span class="line">&#125;;</span><br><span class="line">person = animal; // ERROR &quot;person&quot; is read-only</span><br></pre></td></tr></table></figure>

<p><code>Object.freeze</code>适用于值，更具体地说，适用于对象值，它使对象不可变，即不能更改其属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let person = &#123;</span><br><span class="line">    name: &quot;Leonardo&quot;</span><br><span class="line">&#125;;</span><br><span class="line">let animal = &#123;</span><br><span class="line">    species: &quot;snake&quot;</span><br><span class="line">&#125;;</span><br><span class="line">Object.freeze(person);</span><br><span class="line">person.name = &quot;Lima&quot;; //TypeError: Cannot assign to read only property &apos;name&apos; of object</span><br><span class="line">console.log(person);</span><br></pre></td></tr></table></figure>

<h3 id="73-如何在-JS-中“深冻结”对象？"><a href="#73-如何在-JS-中“深冻结”对象？" class="headerlink" title="73. 如何在 JS 中“深冻结”对象？"></a>73. 如何在 JS 中“深冻结”对象？</h3><p>如果咱们想要确保对象被深冻结，就必须创建一个递归函数来冻结对象类型的每个属性：</p>
<p><strong>没有深冻结</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let person = &#123;</span><br><span class="line">    name: &quot;Leonardo&quot;,</span><br><span class="line">    profession: &#123;</span><br><span class="line">        name: &quot;developer&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Object.freeze(person); </span><br><span class="line">person.profession.name = &quot;doctor&quot;;</span><br><span class="line">console.log(person); //output &#123; name: &apos;Leonardo&apos;, profession: &#123; name: &apos;doctor&apos; &#125; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>深冻结</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function deepFreeze(object) &#123;</span><br><span class="line">    let propNames = Object.getOwnPropertyNames(object);</span><br><span class="line">    for (let name of propNames) &#123;</span><br><span class="line">        let value = object[name];</span><br><span class="line">        object[name] = value &amp;&amp; typeof value === &quot;object&quot; ?</span><br><span class="line">            deepFreeze(value) : value;</span><br><span class="line">    &#125;</span><br><span class="line">    return Object.freeze(object);</span><br><span class="line">&#125;</span><br><span class="line">let person = &#123;</span><br><span class="line">    name: &quot;Leonardo&quot;,</span><br><span class="line">    profession: &#123;</span><br><span class="line">        name: &quot;developer&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">deepFreeze(person);</span><br><span class="line">person.profession.name = &quot;doctor&quot;; // TypeError: Cannot assign to read only property &apos;name&apos; of object</span><br></pre></td></tr></table></figure>

<h3 id="74-Iterator是什么，有什么作用？"><a href="#74-Iterator是什么，有什么作用？" class="headerlink" title="74. Iterator是什么，有什么作用？"></a>74. <code>Iterator</code>是什么，有什么作用？</h3><p>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p>
<p><code>Iterator</code> 的作用有三个：</p>
<ol>
<li>为各种数据结构，提供一个统一的、简便的访问接口；</li>
<li>使得数据结构的成员能够按某种次序排列；</li>
<li>ES6 创造了一种新的遍历命令<code>for…of</code>循环，Iterator 接口主要供<code>for…of</code>消费。</li>
</ol>
<p>遍历过程：</p>
<ol>
<li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li>
<li>第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</li>
<li>第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。</li>
<li>不断调用指针对象的next方法，直到它指向数据结构的结束位置。</li>
</ol>
<p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象。其中，<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//obj就是可遍历的，因为它遵循了Iterator标准，且包含[Symbol.iterator]方法，方法函数也符合标准的Iterator接口规范。</span><br><span class="line">//obj.[Symbol.iterator]() 就是Iterator遍历器</span><br><span class="line">let obj = &#123;</span><br><span class="line">  data: [ &apos;hello&apos;, &apos;world&apos; ],</span><br><span class="line">  [Symbol.iterator]() &#123;</span><br><span class="line">    const self = this;</span><br><span class="line">    let index = 0;</span><br><span class="line">    return &#123;</span><br><span class="line">      next() &#123;</span><br><span class="line">        if (index &lt; self.data.length) &#123;</span><br><span class="line">          return &#123;</span><br><span class="line">            value: self.data[index++],</span><br><span class="line">            done: false</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          return &#123; value: undefined, done: true &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="75-Generator-函数是什么，有什么作用？"><a href="#75-Generator-函数是什么，有什么作用？" class="headerlink" title="75. Generator 函数是什么，有什么作用？"></a>75. <code>Generator</code> 函数是什么，有什么作用？</h3><p>如果说 JavaScrip 是 ECMAScript 标准的一种具体实现、<code>Iterator</code>遍历器是<code>Iterator</code>的具体实现，那么<code>Generator</code>函数可以说是<code>Iterator</code>接口的具体实现方式。</p>
<p>执行<code>Generator</code>函数会返回一个遍历器对象，每一次<code>Generator</code>函数里面的yield都相当一次遍历器对象的<code>next()</code>方法，并且可以通过<code>next(value)</code>方法传入自定义的<code>value</code>,来改变<code>Generator</code>函数的行为。</p>
<p><code>Generator</code>函数可以通过配合Thunk 函数更轻松更优雅的实现异步编程和控制流管理。</p>
<h3 id="1-new的实现原理是什么？"><a href="#1-new的实现原理是什么？" class="headerlink" title="1. new的实现原理是什么？"></a>1. new的实现原理是什么？</h3><p><code>new</code> 的实现原理:</p>
<ol>
<li>创建一个空对象，构造函数中的this指向这个空对象</li>
<li>这个新对象被执行 [[原型]] 连接</li>
<li>执行构造函数方法，属性和方法被添加到this引用的对象中</li>
<li>如果构造函数中没有返回其它对象，那么返回this，即创建的这个的新对象，否则，返回构造函数中返回的对象。</li>
</ol>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn54G2UhXFsbjtnWZ3u08jwuRnxeOQ2Yd57fvwSw2yYImx5bDjltTwu7w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>



<h3 id="2-如何正确判断this的指向？"><a href="#2-如何正确判断this的指向？" class="headerlink" title="2. 如何正确判断this的指向？"></a>2. 如何正确判断this的指向？</h3><p>如果用一句话说明 this 的指向，那么即是: 谁调用它，this 就指向谁。</p>
<p>但是仅通过这句话，我们很多时候并不能准确判断 this 的指向。因此我们需要借助一些规则去帮助自己：</p>
<p>this 的指向可以按照以下顺序判断:</p>
<h4 id="全局环境中的-this"><a href="#全局环境中的-this" class="headerlink" title="全局环境中的 this"></a>全局环境中的 this</h4><p>浏览器环境：无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象 <code>window</code>;</p>
<p>node 环境：无论是否在严格模式下，在全局执行环境中（在任何函数体外部），this 都是空对象 <code>{}</code>;</p>
<h4 id="是否是-new-绑定"><a href="#是否是-new-绑定" class="headerlink" title="是否是 new 绑定"></a>是否是 <code>new</code> 绑定</h4><p>如果是 <code>new</code> 绑定，并且构造函数中没有返回 function 或者是 object，那么 this 指向这个新对象。如下:</p>
<blockquote>
<p>构造函数返回值不是 function 或 object。 <code>newSuper()</code> 返回的是 this 对象。</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn54iaqYAbPr4NoM3clCdUbh5CT8cqS9VwjlHw8NHib7LHUfiaKy6tIK9Sfg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>

<blockquote>
<p>构造函数返回值是 function 或 object， <code>newSuper()</code>是返回的是Super种返回的对象。</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5wlqjj2UkfFcAsUzCQcK7P4ibnyuXCaXG01w3B2ToMM0Pwqyic22YHJeg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>

<h4 id="函数是否通过-call-apply-调用，或者使用了-bind-绑定，如果是，那么this绑定的就是指定的对象【归结为显式绑定】。"><a href="#函数是否通过-call-apply-调用，或者使用了-bind-绑定，如果是，那么this绑定的就是指定的对象【归结为显式绑定】。" class="headerlink" title="函数是否通过 call,apply 调用，或者使用了 bind 绑定，如果是，那么this绑定的就是指定的对象【归结为显式绑定】。"></a>函数是否通过 call,apply 调用，或者使用了 bind 绑定，如果是，那么this绑定的就是指定的对象【归结为显式绑定】。</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5ibm3yrI4oUSJHSGWeic0iadporic1R8f9cuDSmiap1NalzmzbYDp246R9xQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>

<p>这里同样需要注意一种<strong>特殊</strong>情况，如果 call,apply 或者 bind 传入的第一个参数值是 <code>undefined</code>或者 <code>null</code>，严格模式下 this 的值为传入的值 null /undefined。非严格模式下，实际应用的默认绑定规则，this 指向全局对象(node环境为global，浏览器环境为window)</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5Lw9PYrfb71iafia6jBwaEIBiaFj1Xo2MZkibobD1QFK0EIXibtB7tGEguOQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>

<h4 id="隐式绑定，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的隐式调用为-xxx-fn"><a href="#隐式绑定，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的隐式调用为-xxx-fn" class="headerlink" title="隐式绑定，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的隐式调用为: xxx.fn()"></a>隐式绑定，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的隐式调用为: <code>xxx.fn()</code></h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5qCVwK4KbA3GGvR3EeFokrr6KhGnj4qTox3fp6aZr78zq3J7WgUuxfQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>

<h4 id="默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用。"><a href="#默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用。" class="headerlink" title="默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用。"></a>默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用。</h4><p>非严格模式：node环境，执行全局对象 global，浏览器环境，执行全局对象 window。</p>
<p>严格模式：执行 undefined</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5ibzF4ZTbXvUWE2Cr2xgZP3CG0phjaY6jN0lpibKQgKQppO7VibgicagRSg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>

<h4 id="箭头函数的情况："><a href="#箭头函数的情况：" class="headerlink" title="箭头函数的情况："></a>箭头函数的情况：</h4><p>箭头函数没有自己的this，继承外层上下文绑定的this。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn50JCNTZLdicc1CS9v23RGIop9jwviaw0tRyT6ZzPPusPvxeaI1zRb0UlA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>



<h3 id="3-深拷贝和浅拷贝的区别是什么？实现一个深拷贝"><a href="#3-深拷贝和浅拷贝的区别是什么？实现一个深拷贝" class="headerlink" title="3. 深拷贝和浅拷贝的区别是什么？实现一个深拷贝"></a>3. 深拷贝和浅拷贝的区别是什么？实现一个深拷贝</h3><p>深拷贝和浅拷贝是针对复杂数据类型来说的，浅拷贝只拷贝一层，而深拷贝是层层拷贝。</p>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><blockquote>
<p>深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。</p>
</blockquote>
<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><blockquote>
<p>浅拷贝是会将对象的每个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。</p>
</blockquote>
<p>可以使用 <code>forin</code>、 <code>Object.assign</code>、 扩展运算符 <code>...</code> 、 <code>Array.prototype.slice()</code>、 <code>Array.prototype.concat()</code> 等，例如:</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5Y4icrlYnl1IdcKpHvO69ou18D0F8PCTHmfvWofHVgtUJpWHvrMj4uXg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>

<p>可以看出浅拷贝只最第一层属性进行了拷贝，当第一层的属性值是基本数据类型时，新的对象和原对象互不影响，但是如果第一层的属性值是复杂数据类型，那么新对象和原对象的属性值其指向的是同一块内存地址。</p>
<h4 id="深拷贝实现"><a href="#深拷贝实现" class="headerlink" title="深拷贝实现"></a>深拷贝实现</h4><blockquote>
<p>1.深拷贝最简单的实现是: <code>JSON.parse(JSON.stringify(obj))</code></p>
</blockquote>
<p><code>JSON.parse(JSON.stringify(obj))</code> 是最简单的实现方式，但是有一些缺陷：</p>
<ol>
<li>对象的属性值是函数时，无法拷贝。</li>
<li>原型链上的属性无法拷贝</li>
<li>不能正确的处理 Date 类型的数据</li>
<li>不能处理 RegExp</li>
<li>会忽略 symbol</li>
<li>会忽略 undefined</li>
</ol>
<blockquote>
<p>2.实现一个 deepClone 函数</p>
</blockquote>
<ol>
<li>如果是基本数据类型，直接返回</li>
<li>如果是 <code>RegExp</code> 或者 <code>Date</code> 类型，返回对应类型</li>
<li>如果是复杂数据类型，递归。</li>
<li>考虑循环引用的问题</li>
</ol>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn51FTQY2ZeZn1MtMkVKpXbM13bZuGAicnia6sdYCo8uHUqt8bbicYrSv2fw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>



<h3 id="4-call-apply-的实现原理是什么？"><a href="#4-call-apply-的实现原理是什么？" class="headerlink" title="4. call/apply 的实现原理是什么？"></a>4. call/apply 的实现原理是什么？</h3><p><code>call</code> 和 <code>apply</code> 的功能相同，都是改变 <code>this</code> 的执行，并立即执行函数。区别在于传参方式不同。</p>
<ul>
<li><code>func.call(thisArg,arg1,arg2,...)</code>：第一个参数是 <code>this</code> 指向的对象，其它参数依次传入。</li>
</ul>
<ul>
<li><code>func.apply(thisArg,[argsArray])</code>：第一个参数是 <code>this</code> 指向的对象，第二个参数是数组或类数组。</li>
</ul>
<p>一起思考一下，如何模拟实现 <code>call</code> ？</p>
<p>首先，我们知道，函数都可以调用 <code>call</code>，说明 <code>call</code> 是函数原型上的方法，所有的实例都可以调用。即: <code>Function.prototype.call</code>。</p>
<ul>
<li>在 <code>call</code> 方法中获取调用 <code>call()</code>函数</li>
<li>如果第一个参数没有传入，那么默认指向 <code>window/global</code>(非严格模式)</li>
<li>传入 <code>call</code> 的第一个参数是 this 指向的对象，根据隐式绑定的规则，我们知道 <code>obj.foo()</code>, <code>foo()</code> 中的 <code>this</code> 指向 <code>obj</code>;因此我们可以这样调用函数 <code>thisArgs.func(...args)</code></li>
<li>返回执行结果</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5SYKMXefJWOPsop82xTBM1adriaVmUmsrHQCoibViaEYfH50vSUxJcn1qg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>

<p><code>apply</code> 的实现思路和 <code>call</code> 一致，仅参数处理略有差别。如下：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn55neqb9WzibkmJA43DS8js9ZqSFw04MlYKLZWpdicZx3KxDCtibopFGCMg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>



<h3 id="5-柯里化函数实现"><a href="#5-柯里化函数实现" class="headerlink" title="5. 柯里化函数实现"></a>5. 柯里化函数实现</h3><p>在开始之前，我们首先需要搞清楚函数柯里化的概念。</p>
<p>函数柯里化是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5nRnE2g5YKGhe5CJVvx7lLicibiaQEGBfAIZhOK5ibGLibzVovwyfEsJ3ZSA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn56GGcKxicqbtHQNAprARD7nXpCCibagWCksnmXT7Td5Q0nkCplIFPR2ibw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>

<blockquote>
<p>函数柯里化的主要作用：</p>
</blockquote>
<ul>
<li>参数复用</li>
<li>提前返回 – 返回接受余下的参数且返回结果的新函数</li>
<li>延迟执行 – 返回新函数，等待执行</li>
</ul>
<h3 id="6-如何让-a-1-amp-amp-a-2-amp-amp-a-3-的值为true？"><a href="#6-如何让-a-1-amp-amp-a-2-amp-amp-a-3-的值为true？" class="headerlink" title="6. 如何让 (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) 的值为true？"></a>6. 如何让 (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) 的值为true？</h3><blockquote>
<ol>
<li>利用隐式类型转换</li>
</ol>
</blockquote>
<p><code>==</code> 操作符在左右数据类型不一致时，会先进行隐式转换。</p>
<p><code>a==1&amp;&amp;a==2&amp;&amp;a==3</code> 的值意味着其不可能是基本数据类型。因为如果 a 是 null 或者是 undefined bool类型，都不可能返回true。</p>
<p>因此可以推测 a 是复杂数据类型，JS 中复杂数据类型只有 <code>object</code>，回忆一下，Object 转换为原始类型会调用什么方法？</p>
<ul>
<li><p>如果部署了 <code>[Symbol.toPrimitive]</code> 接口，那么调用此接口，若返回的不是基本数据类型，抛出错误。</p>
</li>
<li><p>如果没有部署 <code>[Symbol.toPrimitive]</code> 接口，那么根据要转换的类型，先调用 <code>valueOf</code> / <code>toString</code></p>
</li>
<li><ol>
<li>非Date类型对象， <code>hint</code> 是 <code>default</code> 时，调用顺序为： <code>valueOf</code> &gt;&gt;&gt; <code>toString</code>，即 <code>valueOf</code> 返回的不是基本数据类型，才会继续调用 <code>valueOf</code>，如果 <code>toString</code> 返回的还不是基本数据类型，那么抛出错误。</li>
<li>如果 <code>hint</code> 是 <code>string</code>(Date对象的hint默认是string) ，调用顺序为： <code>toString</code> &gt;&gt;&gt; <code>valueOf</code>，即 <code>toString</code> 返回的不是基本数据类型，才会继续调用 <code>valueOf</code>，如果 <code>valueOf</code> 返回的还不是基本数据类型，那么抛出错误。</li>
<li>如果 <code>hint</code> 是 <code>number</code>，调用顺序为： <code>valueOf</code> &gt;&gt;&gt; <code>toString</code></li>
</ol>
</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5V2sCHBbIibaveibXomzNl4n7DmNXPUich7gLRRgYVnkMp6mD27CqJjHDw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>

<blockquote>
<ol>
<li>利用数据劫持(Proxy/Object.definedProperty)</li>
</ol>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5Eia3ibFu8nLABlTOAWmbGBoWC9g4FqjQzY9p4DichctQbXvu2k5Y4GTyg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>

<blockquote>
<ol>
<li>数组的 <code>toString</code> 接口默认调用数组的 <code>join</code> 方法，重新 <code>join</code> 方法</li>
</ol>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5eEflnyfscRRcZ5JHKNL7vMeibicZ9Qx4xVav2AehxSIV94ZGPTvRmicvA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>



<h3 id="7-什么是BFC？BFC的布局规则是什么？如何创建BFC？"><a href="#7-什么是BFC？BFC的布局规则是什么？如何创建BFC？" class="headerlink" title="7. 什么是BFC？BFC的布局规则是什么？如何创建BFC？"></a>7. 什么是BFC？BFC的布局规则是什么？如何创建BFC？</h3><p>Box 是 CSS 布局的对象和基本单位，页面是由若干个Box组成的。</p>
<p>元素的类型 和 <code>display</code> 属性，决定了这个 Box 的类型。不同类型的 Box 会参与不同的 Formatting Context。</p>
<blockquote>
<p>Formatting Context</p>
</blockquote>
<p>Formatting Context 是页面的一块渲染区域，并且有一套渲染规则，决定了其子元素将如何定位，以及和其它元素的关系和相互作用。</p>
<p>Formatting Context 有 BFC (Block formatting context)，IFC (Inline formatting context)，FFC (Flex formatting context) 和 GFC (Grid formatting context)。FFC 和 GFC 为 CC3 中新增。</p>
<blockquote>
<p>BFC布局规则</p>
</blockquote>
<ul>
<li>BFC内，盒子依次垂直排列。</li>
<li>BFC内，两个盒子的垂直距离由 <code>margin</code> 属性决定。属于同一个BFC的两个相邻Box的margin会发生重叠【符合合并原则的margin合并后是使用大的margin】</li>
<li>BFC内，每个盒子的左外边缘接触内部盒子的左边缘（对于从右到左的格式，右边缘接触）。即使在存在浮动的情况下也是如此。除非创建新的BFC。</li>
<li>BFC的区域不会与float box重叠。</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li>
<li>计算BFC的高度时，浮动元素也参与计算。</li>
</ul>
<blockquote>
<p>如何创建BFC</p>
</blockquote>
<ul>
<li>根元素</li>
<li>浮动元素（float 属性不为 none）</li>
<li>position 为 absolute 或 fixed</li>
<li>overflow 不为 visible 的块元素</li>
<li>display 为 inline-block, table-cell, table-caption</li>
</ul>
<blockquote>
<p>BFC 的应用</p>
</blockquote>
<ol>
<li>防止 margin 重叠 (同一个BFC内的两个两个相邻Box的 <code>margin</code> 会发生重叠，触发生成两个BFC，即不会重叠)</li>
<li>清除内部浮动 (创建一个新的 BFC，因为根据 BFC 的规则，计算 BFC 的高度时，浮动元素也参与计算)</li>
<li>自适应多栏布局 (BFC的区域不会与float box重叠。因此，可以触发生成一个新的BFC)</li>
</ol>
<h3 id="8-异步加载JS脚本的方式有哪些？"><a href="#8-异步加载JS脚本的方式有哪些？" class="headerlink" title="8. 异步加载JS脚本的方式有哪些？"></a>8. 异步加载JS脚本的方式有哪些？</h3><script> 标签中增加 async(html5) 或者 defer(html4) 属性,脚本就会异步加载。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scriptsrc=&quot;../XXX.js&quot;defer&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

`defer` 和 `async` 的区别在于：

- `defer` 要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），在window.onload 之前执行；
- `async` 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。
- 如果有多个 `defer` 脚本，会按照它们在页面出现的顺序加载
- 多个 `async` 脚本不能保证加载顺序

> 动态创建 `script` 标签

动态创建的 `script` ，设置 `src` 并不会开始下载，而是要添加到文档中，JS文件才会开始下载。

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5ibThWoFSzEqhcZL9JBfphU4KoHgC75jZX4SwL4Yd2QJxzMvd5gCFKqg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>

> XHR 异步加载JS

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5Q0Qvasibkz3UeatXIZm2APZnwrpFmSh1rJJx7nw7dazk3iaK37HW7wSQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>



### 9. ES5有几种方式可以实现继承？分别有哪些优缺点？

ES5 有 6 种方式可以实现继承，分别为：

##### 1. 原型链继承

原型链继承的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5nzTvsaZibnvY9744nayJGRv1bicxKo25nPa3c4ibcnfhzkNvkttlUltHQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>

> 缺点：

1. 通过原型来实现继承时，原型会变成另一个类型的实例，原先的实例属性变成了现在的原型属性，该原型的引用类型属性会被所有的实例共享。
2. 在创建子类型的实例时，没有办法在不影响所有对象实例的情况下给超类型的构造函数中传递参数。

##### 2. 借用构造函数

**借用构造函数**的技术，其基本思想为:

在子类型的构造函数中调用超类型构造函数。

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5aCXn8MobqGXRvg90hDg7n8ic2IyuvwE4aibgcApciaxhgxnzzaorU3x2A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>

> 优点:

1. 可以向超类传递参数
2. 解决了原型中包含引用类型值被所有实例共享的问题

> 缺点:

1. 方法都在构造函数中定义，函数复用无从谈起，另外超类型原型中定义的方法对于子类型而言都是不可见的。

##### 3. 组合继承(原型链 + 借用构造函数)

组合继承指的是将原型链和借用构造函数技术组合到一块，从而发挥二者之长的一种继承模式。基本思路：

使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承，既通过在原型上定义方法来实现了函数复用，又保证了每个实例都有自己的属性。

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5V1ZrDbx8s8bnOwq9ZqKAXEjArM3xPmicz43KZGbkDydiaR2EU07icBaHQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>

> 缺点:

- 无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。

> 优点:

- 可以向超类传递参数
- 每个实例都有自己的属性
- 实现了函数复用

##### 4. 原型式继承

原型继承的基本思想：

借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5O5Oc6xuNqfYBomN7fic979nMOicl5pBpKgxMEgoXR9qPfmscXMU819jw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>

在 `object()` 函数内部，先穿甲一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例，从本质上讲， `object()` 对传入的对象执行了一次浅拷贝。

ECMAScript5通过新增 `Object.create()`方法规范了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象(可以覆盖原型对象上的同名属性)，在传入一个参数的情况下， `Object.create()` 和 `object()` 方法的行为相同。

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5w5xjuwSNcwNxibl5v5eI18VraG9B6xHDCM4nibm2M2E2Ebue7RIVmAgw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>

在没有必要创建构造函数，仅让一个对象与另一个对象保持相似的情况下，原型式继承是可以胜任的。

> 缺点:

同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。

##### 5. 寄生式继承

寄生式继承是与原型式继承紧密相关的一种思路。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部已某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5zCxKia3ehuVbHl38GSlUPPibAyRXV3ylZxZuMAF57z2EhjeDcaq5mhxA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>

基于 `person` 返回了一个新对象 -—— `person2`，新对象不仅具有 `person` 的所有属性和方法，而且还有自己的 `sayHi()` 方法。在考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。

> 缺点：

- 使用寄生式继承来为对象添加函数，会由于不能做到函数复用而效率低下。
- 同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。

##### 6. 寄生组合式继承

所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法，基本思路：

不必为了指定子类型的原型而调用超类型的构造函数，我们需要的仅是超类型原型的一个副本，本质上就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。寄生组合式继承的基本模式如下所示：

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn59eJo9qQWjQQAiauRvo7ezc2ILiayI7uUTj4rLxYBz989k42Lj87pqRdg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>

- 第一步：创建超类型原型的一个副本
- 第二步：为创建的副本添加 `constructor` 属性
- 第三步：将新创建的对象赋值给子类型的原型

至此，我们就可以通过调用 `inheritPrototype` 来替换为子类型原型赋值的语句：

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5G4zK1DvgwSiaO6hl7TDmslABvXPhVhLrg4qWYbl9lm5uVSC5MQ7LayQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>

> 优点:

只调用了一次超类构造函数，效率更高。避免在 `SuberType.prototype`上面创建不必要的、多余的属性，与其同时，原型链还能保持不变。

因此寄生组合继承是引用类型最理性的继承范式。



### 10. 隐藏页面中的某个元素的方法有哪些？

> 隐藏类型

屏幕并不是唯一的输出机制，比如说屏幕上看不见的元素（隐藏的元素），其中一些依然能够被读屏软件阅读出来（因为读屏软件依赖于可访问性树来阐述）。为了消除它们之间的歧义，我们将其归为三大类：

- 完全隐藏：元素从渲染树中消失，不占据空间。
- 视觉上的隐藏：屏幕中不可见，占据空间。
- 语义上的隐藏：读屏软件不可读，但正常占据空。

> 完全隐藏

##### 1. `display` 属性

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display: none;</span><br></pre></td></tr></table></figure>

##### 2.hidden 属性

HTML5 新增属性，相当于 `display:none`

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div hidden&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

> 视觉上的隐藏

##### 1.利用 `position` 和 盒模型 将元素移出可视区范围

1. 设置 `posoition` 为 `absolute` 或 `fixed`，通过设置 `top`、 `left` 等值，将其移出可视区域。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">position:absolute;left: -99999px;</span><br></pre></td></tr></table></figure>

1. 设置 `position` 为 `relative`，通过设置 `top`、 `left` 等值，将其移出可视区域。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">position: relative;left: -99999px;height: 0</span><br></pre></td></tr></table></figure>

1. 设置 margin 值，将其移出可视区域范围（可视区域占位）。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">margin-left: -99999px;height: 0;</span><br></pre></td></tr></table></figure>

##### 2.利用 transfrom

1. 缩放

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform: scale(0);height: 0;</span><br></pre></td></tr></table></figure>

1. 移动 `translateX`, `translateY`

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform: translateX(-99999px);height: 0</span><br></pre></td></tr></table></figure>

1. 旋转 `rotate`

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform: rotateY(90deg);</span><br></pre></td></tr></table></figure>

##### 3.设置其大小为0

1. 宽高为0，字体大小为0：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">height: 0;width: 0;font-size: 0;</span><br></pre></td></tr></table></figure>

1. 宽高为0，超出隐藏:

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">height: 0;width: 0;overflow: hidden;</span><br></pre></td></tr></table></figure>

##### 4.设置透明度为0

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opacity: 0;</span><br></pre></td></tr></table></figure>

##### 5. `visibility`属性

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visibility: hidden;</span><br></pre></td></tr></table></figure>

##### 6.层级覆盖， `z-index` 属性

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">position: relative;z-index: -999;</span><br></pre></td></tr></table></figure>

再设置一个层级较高的元素覆盖在此元素上。

##### 7.clip-path 裁剪

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clip-path: polygon(0 0, 0 0, 0 0, 0 0);</span><br></pre></td></tr></table></figure>

> 语义上的隐藏

##### aria-hidden 属性

读屏软件不可读，占据空间，可见。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div aria-hidden=&quot;true&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

### 11. let、const、var 的区别有哪些？

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_jpg/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5BmicUT2v1GPibejOmE8XEuomTXTAem3kVvVc5CA517TiaL2YzmPtDzopg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>

1.let/const 定义的变量不会出现变量提升，而 var 定义的变量会提升。

2.相同作用域中，let 和 const 不允许重复声明，var 允许重复声明。

3.const 声明变量时必须设置初始值

4.const 声明一个只读的常量，这个常量不可改变。

这里有一个非常重要的点即是：在JS中，复杂数据类型，存储在栈中的是堆内存的地址，存在栈中的这个地址是不变的，但是存在堆中的值是可以变得。有没有相当常量指针/指针常量~

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5TMicHEJds6MerDXXDtqVaWiagtDCaIujkGIVZvOqr5wuicRbict3GiaibIKA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>

一图胜万言，如下图所示，不变的是栈内存中 a 存储的 20，和 b 中存储的 0x0012ff21（瞎编的一个数字）。而 {age: 18, star: 200} 是可变的。

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_jpg/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5rFPgUAmqvHia5657AsW9icopcB6Jx5ibboGAvsxImhTVwyU6fDNldO7kg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>



### 12. 说一说你对JS执行上下文栈和作用域链的理解？

在开始说明JS上下文栈和作用域之前，我们先说明下JS上下文以及作用域的概念。

#### JS执行上下文

执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。

> 执行上下文类型分为：

- 全局执行上下文
- 函数执行上下文

执行上下文创建过程中，需要做以下几件事:

1. 创建变量对象：首先初始化函数的参数arguments，提升函数声明和变量声明。
2. 创建作用域链（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。
3. 确定this的值，即 ResolveThisBinding

#### 作用域

**作用域**负责收集和维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。—— 摘录自《你不知道的JavaScript》(上卷)

作用域有两种工作模型：词法作用域和动态作用域，JS采用的是**词法作用域**工作模型，词法作用域意味着作用域是由书写代码时变量和函数声明的位置决定的。( `with` 和 `eval` 能够修改词法作用域，但是不推荐使用，对此不做特别说明)

> 作用域分为：

- 全局作用域
- 函数作用域
- 块级作用域

#### JS执行上下文栈(后面简称执行栈)

执行栈，也叫做调用栈，具有 **LIFO** (后进先出) 结构，用于存储在代码执行期间创建的所有执行上下文。

> 规则如下：

- 首次运行JavaScript代码的时候,会创建一个全局执行的上下文并Push到当前的执行栈中，每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push当前执行栈的栈顶。
- 当栈顶的函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文的控制权将移动到当前执行栈的下一个执行上下文。

以一段代码具体说明：

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5yr7jLqeDaxEQTsSib18458DP1ZtCiaVib2oHcwbmzmhV5UtRI3lRyZHTQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>

`GlobalExecutionContext` (即全局执行上下文)首先入栈，过程如下：

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_jpg/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn504lVksJpOtvTG5IYCceOX5nLMK75jib1q2BJvlPteRqt7FXysNODDtw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>

伪代码:

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//全局执行上下文首先入栈ECStack.push(globalContext);</span><br><span class="line">//执行fun1();ECStack.push(&lt;fun1&gt; functionContext);</span><br><span class="line">//fun1中又调用了fun2;ECStack.push(&lt;fun2&gt; functionContext);</span><br><span class="line">//fun2中又调用了fun3;ECStack.push(&lt;fun3&gt; functionContext);</span><br><span class="line">//fun3执行完毕ECStack.pop();</span><br><span class="line">//fun2执行完毕ECStack.pop();</span><br><span class="line">//fun1执行完毕ECStack.pop();</span><br><span class="line">//javascript继续顺序执行下面的代码，但ECStack底部始终有一个 全局上下文（globalContext）;</span><br></pre></td></tr></table></figure>

#### 作用域链

作用域链就是从当前作用域开始一层一层向上寻找某个变量，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链。

如：

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5Qp3STjLricd5KZS9kcbp4ZEKIt0dNEk05nN3gUMomsTSUxQNNhXo8Vw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>

fn2作用域链 = [fn2作用域, fn1作用域，全局作用域]

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_jpg/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn55AUHBR4xIcP8MKoJpxFPjhFZvccE0gb06WichbkHlf8CSEPVy9nQdeA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>



### 13. 防抖函数的作用是什么？请实现一个防抖函数

> 防抖函数的作用

防抖函数的作用就是控制函数在一定时间内的执行次数。防抖意味着N秒内函数只会被执行一次，如果N秒内再次被触发，则**重新**计算延迟时间。

**举例说明：** 小思最近在减肥，但是她非常吃吃零食。为此，与其男朋友约定好，如果10天不吃零食，就可以购买一个包(不要问为什么是包，因为**包治百病**)。但是如果中间吃了一次零食，那么就要重新计算时间，直到小思坚持10天没有吃零食，才能购买一个包。所以，管不住嘴的小思，没有机会买包(悲伤的故事)... 这就是 **防抖**。

> 防抖函数实现

1. 事件第一次触发时， `timer` 是 `null`，调用 `later()`，若 `immediate` 为 `true`，那么立即调用 `func.apply(this,params)`；如果 `immediate` 为 `false`，那么过 `wait` 之后，调用 `func.apply(this,params)`
2. 事件第二次触发时，如果 `timer` 已经重置为 `null`(即 `setTimeout` 的倒计时结束)，那么流程与第一次触发时一样，若 `timer` 不为 `null`(即 setTimeout 的倒计时未结束)，那么清空定时器，重新开始计时。

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5r1nYvEW7KljZ2HUYWmiaVDmUR2Ot0G96D0YcIDZbeRa9KiaXjdL61PzQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>

`immediate` 为 true 时，表示函数在每个等待时延的开始被调用。 `immediate` 为 false 时，表示函数在每个等待时延的结束被调用。

> 防抖的应用场景

1. 搜索框输入查询，如果用户一直在输入中，没有必要不停地调用去请求服务端接口，等用户停止输入的时候，再调用，设置一个合适的时间间隔，有效减轻服务端压力。
2. 表单验证
3. 按钮提交事件。
4. 浏览器窗口缩放，resize事件(如窗口停止改变大小之后重新计算布局)等。



### 14. 节流函数的作用是什么？有哪些应用场景，请实现一个节流函数

> 节流函数的作用

节流函数的作用是规定一个单位时间，在这个单位时间内最多只能触发一次函数执行，如果这个单位时间内多次触发函数，只能有一次生效。

> 节流函数实现

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5ZAg1icic6UibTQA8VKtwREjxo88BoH0XFoNXUZvAU0icST8tLCJXV39HCA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>

禁用第一次首先执行，传递 `{leading:false}` ；想禁用最后一次执行，传递 `{trailing:false}`

> 节流的应用场景

1. 按钮点击事件
2. 拖拽事件
3. onScoll
4. 计算鼠标移动的距离(mousemove)



### 15. 什么是闭包？闭包的作用是什么？

##### 闭包的定义

《JavaScript高级程序设计》:

> 闭包是指有权访问另一个函数作用域中的变量的函数

《JavaScript权威指南》：

> 从技术的角度讲，所有的JavaScript函数都是闭包：它们都是对象，它们都关联到作用域链。

《你不知道的JavaScript》

> 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。

##### 创建一个闭包

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5rGwyvmzMVXPr3AmRqU8zibL27gO2ugAr2Hyls1LPEoTexvic435MCmrw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>

闭包使得函数可以继续访问定义时的词法作用域。拜 fn 所赐，在 foo() 执行后，foo 内部作用域不会被销毁。

##### 闭包的作用

- 能够访问函数定义时所在的词法作用域(阻止其被回收)。
- 私有化变量

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5mdovgJdp40a68pUdnKDRXJ5txnoqeWWFn9hOe5YGAeFvk4K5t9H9icg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>

- 模拟块级作用域

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5aUa3w6LMz6lO3mNJvVBq1BIaZVC0AvUfmVHicaPW0V2kWOEiazKCfGAA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>

- 创建模块

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5vRJ9urEFXpkz3ZBOR9IC2QKaqhYycZficGPxoApBib4GyFZdu648ztYg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>

模块模式具有两个必备的条件(来自《你不知道的JavaScript》)

- 必须有外部的封闭函数，该函数必须至少被调用一次(每次调用都会创建一个新的模块实例)
- 封闭函数必须返回至少**一个**内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。



### 16. 实现 Promise.all 方法

在实现 Promise.all 方法之前，我们首先要知道 Promise.all 的功能和特点，因为在清楚了 Promise.all 功能和特点的情况下，我们才能进一步去写实现。

> Promise.all 功能

`Promise.all(iterable)` 返回一个新的 Promise 实例。此实例在 `iterable` 参数内所有的 `promise` 都 `fulfilled` 或者参数中不包含 `promise` 时，状态变成 `fulfilled`；如果参数中 `promise` 有一个失败 `rejected`，此实例回调失败，失败原因的是第一个失败 `promise` 的返回结果。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let p = Promise.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

p的状态由 p1,p2,p3决定，分成以下；两种情况：

（1）只有p1、p2、p3的状态都变成 `fulfilled`，p的状态才会变成 `fulfilled`，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。

（2）只要p1、p2、p3之中有一个被 `rejected`，p的状态就变成 `rejected`，此时第一个被reject的实例的返回值，会传递给p的回调函数。

> Promise.all 的特点

Promise.all 的返回值是一个 promise 实例

- 如果传入的参数为空的可迭代对象， `Promise.all` 会 **同步** 返回一个已完成状态的 `promise`
- 如果传入的参数中不包含任何 promise, `Promise.all` 会 **异步** 返回一个已完成状态的 `promise`
- 其它情况下， `Promise.all` 返回一个 **处理中（pending）** 状态的 `promise`.

> Promise.all 返回的 promise 的状态

- 如果传入的参数中的 promise 都变成完成状态， `Promise.all` 返回的 `promise` 异步地变为完成。
- 如果传入的参数中，有一个 `promise` 失败， `Promise.all` 异步地将失败的那个结果给失败状态的回调函数，而不管其它 `promise` 是否完成
- 在任何情况下， `Promise.all` 返回的 `promise` 的完成状态的结果都是一个数组

> Promise.all 实现

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5F3OQOAFicggwrrWTHRTUEPIjES9VlwEzYlEwhtia52TlDl8G1yUaIXxw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>



### 17. 请实现一个 flattenDeep 函数，把嵌套的数组扁平化

例如:

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flattenDeep([1, [2, [3, [4]], 5]]); //[1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>

> 利用 Array.prototype.flat

ES6 为数组实例新增了 `flat` 方法，用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数组没有影响。

`flat` 默认只会 “拉平” 一层，如果想要 “拉平” 多层的嵌套数组，需要给 `flat` 传递一个整数，表示想要拉平的层数。

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5JiaAMibmh3vC4D9qYOibQprBUOyHYhiaceBlT2ZgXvmWCib63ic5D4I5qf3g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>

当传递的整数大于数组嵌套的层数时，会将数组拉平为一维数组，JS能表示的最大数字为 `Math.pow(2,53)-1`，因此我们可以这样定义 `flattenDeep` 函数

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn55onORazW72kUX52iae7JiaYlDVbvRqDrtWw3eB6I82Lo764koRfHWhzw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>

> 利用 reduce 和 concat

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5sliashHBgmfwaeAkYrneSdsxFzYczfRYj825iaicAQjV0A8DgbSQ9H4tA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>

> 使用 stack 无限反嵌套多层嵌套数组

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5HfwkKCAN9IytV7gDu324PYTKQ8IjWyr1ibdEyshSOrv6Y67U3Jq49Yw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>



### 18. 请实现一个 uniq 函数，实现数组去重

例如:

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniq([1, 2, 3, 5, 3, 2]);//[1, 2, 3, 5]</span><br></pre></td></tr></table></figure>

> 法1: 利用ES6新增数据类型 `Set`

`Set`类似于数组，但是成员的值都是唯一的，没有重复的值。

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5O1Z4oSibhO3SpSE11xFAqAhTg0QdbVEU6GJzEfQr0FbTWZEQD9ddSfg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>

> 法2: 利用 `indexOf`

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5wgGA7d2iaouBq9sBYESJGUXqF23KOIF6fuxCc3aL5wrSVw4z8VoFuYQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>

> 法3: 利用 `includes`

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn50xB0gqX80lhqbdNJfib3hC7SClT8zd232zWHubiaNjFGFCibunpg7N5Xw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>

> 法4：利用 `reduce`

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5kEKcpn37JQmUeH1XVR9sqHrIaeJpn0Axd1AVYKiaXvL1oicVibuN8cQUw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>

> 法5：利用 `Map`

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5PwKVnSyibzD3b2NEpFGWEOOOVDia16qpOpZW1tnIiaK6tZbLmrlBzQjibA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>



### 19. 可迭代对象有哪些特点

ES6 规定，默认的 `Iterator` 接口部署在数据结构的 `Symbol.iterator` 属性，换个角度，也可以认为，一个数据结构只要具有 `Symbol.iterator` 属性( `Symbol.iterator` 方法对应的是遍历器生成函数，返回的是一个遍历器对象)，那么就可以其认为是可迭代的。

#### 可迭代对象的特点

- 具有 `Symbol.iterator` 属性， `Symbol.iterator()` 返回的是一个遍历器对象
- 可以使用 `for...of` 进行循环
- 通过被 `Array.from` 转换为数组

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5IQHY73dTYsQKiaeFWBbyqN6C34lkfCqMjp7LRVnwcAyL2gD5IMVFOzg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>

#### 原生具有 `Iterator` 接口的数据结构：

- Array
- Map
- Set
- String
- TypedArray
- 函数的 arguments 对象
- NodeList 对象



### 20. JSONP 的原理是什么？

尽管浏览器有同源策略，但是 `<script>` 标签的 `src` 属性不会被同源策略所约束，可以获取任意服务器上的脚本并执行。 `jsonp` 通过插入 `script` 标签的方式来实现跨域，参数只能通过 `url` 传入，仅能支持 `get` 请求。

> 实现原理:

- Step1: 创建 callback 方法
- Step2: 插入 script 标签
- Step3: 后台接受到请求，解析前端传过去的 callback 方法，返回该方法的调用，并且数据作为参数传入该方法
- Step4: 前端执行服务端返回的方法调用

> jsonp源码实现

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5BGLJ0MNPYzqES2HrphOVZuP8pB6Dmouxibc54SaR42lw9T7IpU9tNfg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>

> 使用:

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5aygIZBnpfWuribuM23iac7oFvFXiaErdXx4BkYuwv6v25OwWCJpfzyX6A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure>

> 服务端代码(node):

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/nnic7Ckj9Nq0zXqZ0Q1e2sUkKsRLQcwn5DY7hQ98xRfA8ria5MribAuFacLHxYVGJP5Qay94b6TlpLyCC84T6HnHg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="">
                </div>
                <div class="image-caption">图片</div>
            </figure></script>
        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2024-02-18T06:46:10.000Z" itemprop="dateUpdated">2024-02-18 14:46:10</time>
</span><br>


        
        感谢您的阅读，欢迎评论(*^▽^*) 转载请附上本文链接：<a href="/interview/javascript-mian-shi-ti.html" target="_blank" rel="external">https://qw8.github.io/interview/javascript-mian-shi-ti.html</a>
        
    </div>
    
    <footer>
        <a href="https://qw8.github.io">
            <img src="/img/avatar.jpg" alt="秦伟">
            秦伟
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BOM/">BOM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DOM/">DOM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://qw8.github.io/interview/javascript-mian-shi-ti.html&title=《JavaScript面试题》 — 秦伟博客&pic=https://qw8.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://qw8.github.io/interview/javascript-mian-shi-ti.html&title=《JavaScript面试题》 — 秦伟博客&source=前端、全栈、SEO的知识点、面试题与学习链接的整理" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://qw8.github.io/interview/javascript-mian-shi-ti.html" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JavaScript面试题》 — 秦伟博客&url=https://qw8.github.io/interview/javascript-mian-shi-ti.html&via=https://qw8.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://qw8.github.io/interview/javascript-mian-shi-ti.html" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/interview/javascript-bi-shi-ti.html" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">JavaScript笔试题</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/knowledges/javascript-bi-bao.html" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">JavaScript闭包</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'false' == 'true',
            appId: "TJ17Ax10JrfIIljlO8qkwGvz-gzGzoHsz",
            appKey: "jDGQKdWT9hlzsTLRAbInE4bK",
            avatar: "mm",
            placeholder: "说点什么吧(*╹▽╹*)",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->










</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢您，我会继续努力哒(*^▽^*)
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.png" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

    <footer class="footer">
    <div class="top">
        <div class="map">
            <!--地球信息-->
<script type="text/javascript" src="/js/jquery-3.4.1.js"></script>
<script type="text/javascript">
    var windowWidth = $(window).width();
    if (windowWidth > 480) {
        document.write('<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5mz4gy0w2d8&amp;m=0&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33" async="async">  <\/script>');
    }
</script>
        </div>
        <p>
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>

</p>
        <p>
            <span>本网站总字数：832.3k</span>
            <span id="sitetime"></span>
        </p>
        <p>部分内容来源于互联网，用于个人知识的总结，如有侵权还请联系删除</p>
        <p>
            
            <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i
                    class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>

    <div class="bottom">
        <p>
            <span>Copyright &copy; 2019 - 2024 <a
                href="http://pdouyin.com/" target="_blank">秦伟的个人博客</a> All Rights Reserved.</span>
            <!-- <span>
                
                
            </span> -->
        </p>
    </div>
</footer>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2019, 8, 25, 18, 0, 0); // 北京时间
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "已安全运行 " + diffYears + "年 " + diffDays + "天 " + diffHours + "小时 " + diffMinutes + "分钟 " + diffSeconds + "秒";
    }
    siteTime();
</script>
</main>
<div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://qw8.github.io/interview/javascript-mian-shi-ti.html&title=《JavaScript面试题》 — 秦伟博客&pic=https://qw8.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://qw8.github.io/interview/javascript-mian-shi-ti.html&title=《JavaScript面试题》 — 秦伟博客&source=前端、全栈、SEO的知识点、面试题与学习链接的整理" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://qw8.github.io/interview/javascript-mian-shi-ti.html" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JavaScript面试题》 — 秦伟博客&url=https://qw8.github.io/interview/javascript-mian-shi-ti.html&via=https://qw8.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://qw8.github.io/interview/javascript-mian-shi-ti.html" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACJklEQVR42u3aQW6EMAwF0Ln/pem2owrm26ZVSV5WI0Qhr4uvGPv1itdxsq7v+X49v/Pn/bctDAyMxzKOy3X2gnwTVfzZM6+fg4GBsQPjLMF6v3sBmoT16XUMDAyMy3vyyJ78mzAwMDCqjDwcq/GKgYGBMSliJwXtP6rFMTAwHsjIw/Hvf/9KfwMDA+NRjKO4rsO3es9kJ29Pw8DAWJqRB1z1WFY9XCZF9YeWAwYGxtKMeUugt5X8mckVDAyMVRl5u7E3TpE3MqvHzbcrGBgYGzN6Tcr8436PXQ5cDAyMhzPuHbDIz6FJCZq0PDEwMHZg5CGYfHrrxWU+onHKxsDA2JIx+ZQ2gVW/DhaKWAwMjIUY1w/Kqdd52BvFOGVjYGBswOi1J3svrhaxo2kRDAyMJRjJtvIIngRxPvxxisTAwFiUUS1TJw3I5IDYG/XAwMDYjVEYxioOWPRala9kYWBgbMCobrS6xSR8q6GPgYGxDyMPzcmn/0kRW45jDAyMRRl3NTLzDfVGwT4cWzEwMLZhzF+fHBDzTRcKWgwMjG0Y89K0N2zRO4BiYGDswDiKqxrTOSOP+MLZFgMDYwlGvhJeXgDfFehlDAYGxmMZ+RaTYjVviCbU5sgFBgbGooy7RiXyv+od9T6cczEwMDDiVsFkaKP5SQ4DAwNj3ABoVs+Xb7khcDEwMB7FyD+l5VGbF7FVNgYGxm6MSeRVI7u3xdsamRgYGM9jfAGCICy6SDh5UgAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '(つェ⊂)咦!跑去哪里了';
            clearTimeout(titleTime);
        } else {
            document.title = '欢迎回来━(*｀∀´*)ノ';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>




<!-- 点击特效 -->
<script type="text/javascript" src="/js/clicklove.js"></script>
<!--动态线条背景-->
<script type="text/javascript"
        color="220,220,220" opacity='0.7' zIndex="-2" count="200"
        src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>
<!-- 雪花特效 -->
<script type="text/javascript" src="/js/jquery-3.4.1.js"></script>
<script type="text/javascript">
    var windowWidth = $(window).width();
    if (windowWidth > 480) {
        document.write('<script type="text/javascript" src="/js/snow.js"><\/script>');
    }
</script>

<script>!function(e){var r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function t(){for(var c=0;c<r.length;c++)t=r[c],void 0,0<=(n=t.getBoundingClientRect()).top&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=r[c];t=o,n=function(){r=r.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}t(),e.addEventListener("scroll",function(){!function(t,n){clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)}(t,e)})}(this);</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"position":"right","width":150,"height":300,"hOffset":-25,"vOffset":30},"mobile":{"show":false,"scale":1.2},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>

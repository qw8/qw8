<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>JavaScript | 秦伟博客 | 前端、全栈、SEO的知识点、面试题与学习链接的整理</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="JavaScript,DOM,BOM,字符串,同步异步">
    <meta name="description" content="JS的基本数据类型和引用数据类型 基本数据类型    类型 值    string 单双引号引起来的数据   number 包括整型和浮点型   undefiend 未初始化的变量   null 相当于占位符   boolean true真   false 假   Symbol ES6新增，表示独一无二且不可变的值   BigInt ES10新增，BigInt 是一种数字类型的数据，它可以表示任意">
<meta name="keywords" content="JavaScript,DOM,BOM,字符串,同步异步">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript">
<meta property="og:url" content="https://qw66.gitee.io/interview/javascript.html">
<meta property="og:site_name" content="秦伟博客">
<meta property="og:description" content="JS的基本数据类型和引用数据类型 基本数据类型    类型 值    string 单双引号引起来的数据   number 包括整型和浮点型   undefiend 未初始化的变量   null 相当于占位符   boolean true真   false 假   Symbol ES6新增，表示独一无二且不可变的值   BigInt ES10新增，BigInt 是一种数字类型的数据，它可以表示任意">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://qw66.gitee.io/img/loading.gif">
<meta property="og:updated_time" content="2024-03-31T12:01:24.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript">
<meta name="twitter:description" content="JS的基本数据类型和引用数据类型 基本数据类型    类型 值    string 单双引号引起来的数据   number 包括整型和浮点型   undefiend 未初始化的变量   null 相当于占位符   boolean true真   false 假   Symbol ES6新增，表示独一无二且不可变的值   BigInt ES10新增，BigInt 是一种数字类型的数据，它可以表示任意">
<meta name="twitter:image" content="https://qw66.gitee.io/img/loading.gif">
    
        <link rel="alternate" type="application/atom+xml" title="秦伟博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/qw.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
<div id="loading" class="active"></div>

<aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">秦伟</h5>
          <a href="mailto:124729081@qq.com" title="124729081@qq.com" class="mail">124729081@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-hourglass"></i>
                时光
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://wpa.qq.com/msgrd?v=3&uin=124729081&site=qq&menu=yes" target="_blank" >
                <i class="icon icon-lg icon-qq"></i>
                聊天
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=124729081@qq.com"  >
                <i class="icon icon-lg icon-envelope-o"></i>
                邮箱
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/user"  >
                <i class="icon icon-lg icon-user"></i>
                简介
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://gitee.com/qw66" target="_blank" >
                <i class="icon icon-lg icon-code"></i>
                Gitee
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/qw8" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

<main id="main">
    <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">JavaScript</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">JavaScript</h1>
        <h5 class="subtitle">
            
                <time datetime="2024-02-14T02:24:57.000Z" itemprop="datePublished" class="page-time">
  2024-02-14
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/前端面试题/">前端面试题</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JS的基本数据类型和引用数据类型"><span class="post-toc-number">1.</span> <span class="post-toc-text">JS的基本数据类型和引用数据类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#javascript-的-typeof-返回哪些数据类型"><span class="post-toc-number">2.</span> <span class="post-toc-text">javascript 的 typeof 返回哪些数据类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#检测数据类型"><span class="post-toc-number">3.</span> <span class="post-toc-text">检测数据类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数据类型转换"><span class="post-toc-number">4.</span> <span class="post-toc-text">数据类型转换</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#复杂数据类型如何转变为字符串"><span class="post-toc-number">5.</span> <span class="post-toc-text">复杂数据类型如何转变为字符串</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JavaScript-中如何检测一个变量是一个-String-类型？"><span class="post-toc-number">6.</span> <span class="post-toc-text">JavaScript 中如何检测一个变量是一个 String 类型？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JavaScript-有几种类型的值？你能画一下他们的内存图吗？"><span class="post-toc-number">7.</span> <span class="post-toc-text">JavaScript 有几种类型的值？你能画一下他们的内存图吗？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是堆？什么是栈？它们之间有什么区别和联系？"><span class="post-toc-number">8.</span> <span class="post-toc-text">什么是堆？什么是栈？它们之间有什么区别和联系？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#null，undefined-的区别？"><span class="post-toc-number">9.</span> <span class="post-toc-text">null，undefined 的区别？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#undefined-表示不存在这个值。"><span class="post-toc-number">9.1.</span> <span class="post-toc-text">undefined   表示不存在这个值。</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#null-表示一个对象被定义了，值为“空值”"><span class="post-toc-number">9.2.</span> <span class="post-toc-text">null 表示一个对象被定义了，值为“空值”</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#和-的不同"><span class="post-toc-number">10.</span> <span class="post-toc-text">== 和 === 的不同</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何判断-NaN"><span class="post-toc-number">11.</span> <span class="post-toc-text">如何判断 NaN</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#说几条写JavaScript的基本规范？"><span class="post-toc-number">12.</span> <span class="post-toc-text">说几条写JavaScript的基本规范？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何编写高性能的JavaScript？"><span class="post-toc-number">13.</span> <span class="post-toc-text">如何编写高性能的JavaScript？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#document-load-和-document-ready-的区别"><span class="post-toc-number">14.</span> <span class="post-toc-text">document load 和 document ready 的区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#字符串常用操作"><span class="post-toc-number">15.</span> <span class="post-toc-text">字符串常用操作</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#内部属性-Class-是什么？"><span class="post-toc-number">16.</span> <span class="post-toc-text">内部属性 [[Class]] 是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#介绍-js-有哪些内置对象？"><span class="post-toc-number">17.</span> <span class="post-toc-text">介绍 js 有哪些内置对象？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#undefined-与-undeclared-的区别？"><span class="post-toc-number">18.</span> <span class="post-toc-text">undefined 与 undeclared 的区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#null-和-undefined-的区别？"><span class="post-toc-number">19.</span> <span class="post-toc-text">null 和 undefined 的区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何获取安全的-undefined-值？"><span class="post-toc-number">20.</span> <span class="post-toc-text">如何获取安全的 undefined 值？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#说几条写-JavaScript-的基本规范？"><span class="post-toc-number">21.</span> <span class="post-toc-text">说几条写 JavaScript 的基本规范？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JavaScript-原型，原型链？-有什么特点？"><span class="post-toc-number">22.</span> <span class="post-toc-text">JavaScript 原型，原型链？ 有什么特点？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#js-获取原型的方法？"><span class="post-toc-number">23.</span> <span class="post-toc-text">js 获取原型的方法？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#在-js-中不同进制数字的表示方式"><span class="post-toc-number">24.</span> <span class="post-toc-text">在 js 中不同进制数字的表示方式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#js-中整数的安全范围是多少？"><span class="post-toc-number">25.</span> <span class="post-toc-text">js 中整数的安全范围是多少？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#typeof-NaN-的结果是什么？"><span class="post-toc-number">26.</span> <span class="post-toc-text">typeof NaN 的结果是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#isNaN-和-Number-isNaN-函数的区别？"><span class="post-toc-number">27.</span> <span class="post-toc-text">isNaN 和 Number.isNaN 函数的区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Array-构造函数只有一个参数值时的表现？"><span class="post-toc-number">28.</span> <span class="post-toc-text">Array 构造函数只有一个参数值时的表现？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#其他值到字符串的转换规则？"><span class="post-toc-number">29.</span> <span class="post-toc-text">其他值到字符串的转换规则？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#其他值到数字值的转换规则？"><span class="post-toc-number">30.</span> <span class="post-toc-text">其他值到数字值的转换规则？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#其他值到布尔类型的值的转换规则？"><span class="post-toc-number">31.</span> <span class="post-toc-text">其他值到布尔类型的值的转换规则？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#和-的-valueOf-和-toString-的结果是什么？"><span class="post-toc-number">32.</span> <span class="post-toc-text">{} 和 [] 的 valueOf 和 toString 的结果是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是假值对象？"><span class="post-toc-number">33.</span> <span class="post-toc-text">什么是假值对象？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#操作符的作用？"><span class="post-toc-number">34.</span> <span class="post-toc-text">~ 操作符的作用？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？"><span class="post-toc-number">35.</span> <span class="post-toc-text">解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#操作符什么时候用于字符串的拼接？"><span class="post-toc-number">36.</span> <span class="post-toc-text">+ 操作符什么时候用于字符串的拼接？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么情况下会发生布尔值的隐式强制类型转换？"><span class="post-toc-number">37.</span> <span class="post-toc-text">什么情况下会发生布尔值的隐式强制类型转换？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#和-amp-amp-操作符的返回值？"><span class="post-toc-number">38.</span> <span class="post-toc-text">|| 和 &amp;&amp; 操作符的返回值？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Symbol-值的强制类型转换？"><span class="post-toc-number">39.</span> <span class="post-toc-text">Symbol 值的强制类型转换？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#操作符的强制类型转换规则？"><span class="post-toc-number">40.</span> <span class="post-toc-text">== 操作符的强制类型转换规则？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何将字符串转化为数字，例如-‘12-3b’"><span class="post-toc-number">41.</span> <span class="post-toc-text">如何将字符串转化为数字，例如 ‘12.3b’?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何将浮点数点左边的数每三位添加一个逗号，如-12000000-11-转化为『12-000-000-11』"><span class="post-toc-number">42.</span> <span class="post-toc-text">如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#常用正则表达式"><span class="post-toc-number">43.</span> <span class="post-toc-text">常用正则表达式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#生成随机数的各种方法？"><span class="post-toc-number">44.</span> <span class="post-toc-text">生成随机数的各种方法？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何实现数组的随机排序？"><span class="post-toc-number">45.</span> <span class="post-toc-text">如何实现数组的随机排序？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#javascript-创建对象的几种方式？"><span class="post-toc-number">46.</span> <span class="post-toc-text">javascript 创建对象的几种方式？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JavaScript-继承的几种实现方式？"><span class="post-toc-number">47.</span> <span class="post-toc-text">JavaScript 继承的几种实现方式？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#寄生式组合继承的实现？"><span class="post-toc-number">48.</span> <span class="post-toc-text">寄生式组合继承的实现？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Javascript-的作用域链？"><span class="post-toc-number">49.</span> <span class="post-toc-text">Javascript 的作用域链？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#谈谈-This-对象的理解。"><span class="post-toc-number">50.</span> <span class="post-toc-text">谈谈 This 对象的理解。</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#eval-是做什么的？"><span class="post-toc-number">51.</span> <span class="post-toc-text">eval 是做什么的？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是-DOM-和-BOM？"><span class="post-toc-number">52.</span> <span class="post-toc-text">什么是 DOM 和 BOM？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#写一个通用的事件侦听器函数。"><span class="post-toc-number">53.</span> <span class="post-toc-text">写一个通用的事件侦听器函数。</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#事件是什么？IE-与火狐的事件机制有什么区别？-如何阻止冒泡？"><span class="post-toc-number">54.</span> <span class="post-toc-text">事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#三种事件模型是什么？"><span class="post-toc-number">55.</span> <span class="post-toc-text">三种事件模型是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#事件委托是什么？"><span class="post-toc-number">56.</span> <span class="post-toc-text">事件委托是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#“1”-“2”-“3”-map-parseInt-答案是多少？"><span class="post-toc-number">57.</span> <span class="post-toc-text">[“1”, “2”, “3”].map(parseInt) 答案是多少？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是闭包，为什么要用它？"><span class="post-toc-number">58.</span> <span class="post-toc-text">什么是闭包，为什么要用它？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#javascript-代码中的-“use-strict”-是什么意思-使用它区别是什么？"><span class="post-toc-number">59.</span> <span class="post-toc-text">javascript 代码中的 “use strict”; 是什么意思 ? 使用它区别是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何判断一个对象是否属于某个类？"><span class="post-toc-number">60.</span> <span class="post-toc-text">如何判断一个对象是否属于某个类？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#instanceof-的作用？"><span class="post-toc-number">61.</span> <span class="post-toc-text">instanceof 的作用？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#new-操作符具体干了什么呢？如何实现？"><span class="post-toc-number">62.</span> <span class="post-toc-text">new 操作符具体干了什么呢？如何实现？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Javascript-中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？"><span class="post-toc-number">63.</span> <span class="post-toc-text">Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#对于-JSON-的了解？"><span class="post-toc-number">64.</span> <span class="post-toc-text">对于 JSON 的了解？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#能解释一下这段代码的意思吗？"><span class="post-toc-number">65.</span> <span class="post-toc-text">能解释一下这段代码的意思吗？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#js-延迟加载的方式有哪些？"><span class="post-toc-number">66.</span> <span class="post-toc-text">js 延迟加载的方式有哪些？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Ajax-是什么-如何创建一个-Ajax？"><span class="post-toc-number">67.</span> <span class="post-toc-text">Ajax 是什么? 如何创建一个 Ajax？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#谈一谈浏览器的缓存机制？"><span class="post-toc-number">68.</span> <span class="post-toc-text">谈一谈浏览器的缓存机制？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Ajax-解决浏览器缓存问题？"><span class="post-toc-number">69.</span> <span class="post-toc-text">Ajax 解决浏览器缓存问题？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#同步和异步的区别？"><span class="post-toc-number">70.</span> <span class="post-toc-text">同步和异步的区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是浏览器的同源政策？"><span class="post-toc-number">71.</span> <span class="post-toc-text">什么是浏览器的同源政策？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何解决跨域问题？"><span class="post-toc-number">72.</span> <span class="post-toc-text">如何解决跨域问题？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#服务器代理转发时，该如何处理-cookie？"><span class="post-toc-number">73.</span> <span class="post-toc-text">服务器代理转发时，该如何处理 cookie？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#模块化开发怎么做？"><span class="post-toc-number">74.</span> <span class="post-toc-text">模块化开发怎么做？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#js-的几种模块规范？"><span class="post-toc-number">75.</span> <span class="post-toc-text">js 的几种模块规范？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#AMD-和-CMD-规范的区别？"><span class="post-toc-number">76.</span> <span class="post-toc-text">AMD 和 CMD 规范的区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ES6-模块与-CommonJS-模块、AMD、CMD-的差异。"><span class="post-toc-number">77.</span> <span class="post-toc-text">ES6 模块与 CommonJS 模块、AMD、CMD 的差异。</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#requireJS-的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何-缓存的？）"><span class="post-toc-number">78.</span> <span class="post-toc-text">requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JS-模块加载器的轮子怎么造，也就是如何实现一个模块加载器？"><span class="post-toc-number">79.</span> <span class="post-toc-text">JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ECMAScript6-怎么写-class，为什么会出现-class-这种东西"><span class="post-toc-number">80.</span> <span class="post-toc-text">ECMAScript6 怎么写 class，为什么会出现 class 这种东西?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#documen-write-和-innerHTML-的区别？"><span class="post-toc-number">81.</span> <span class="post-toc-text">documen.write 和 innerHTML 的区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？"><span class="post-toc-number">82.</span> <span class="post-toc-text">DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#innerHTML-与-outerHTML-的区别？"><span class="post-toc-number">83.</span> <span class="post-toc-text">innerHTML 与 outerHTML 的区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#call-和-apply-的区别？"><span class="post-toc-number">84.</span> <span class="post-toc-text">.call() 和 .apply() 的区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JavaScript-类数组对象的定义？"><span class="post-toc-number">85.</span> <span class="post-toc-text">JavaScript 类数组对象的定义？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数组和对象有哪些原生方法，列举一下？"><span class="post-toc-number">86.</span> <span class="post-toc-text">数组和对象有哪些原生方法，列举一下？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数组的-fill-方法？"><span class="post-toc-number">87.</span> <span class="post-toc-text">数组的 fill 方法？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#的长度？"><span class="post-toc-number">88.</span> <span class="post-toc-text">[,,,] 的长度？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JavaScript-中的作用域与变量声明提升？"><span class="post-toc-number">89.</span> <span class="post-toc-text">JavaScript 中的作用域与变量声明提升？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何编写高性能的-Javascript-？"><span class="post-toc-number">90.</span> <span class="post-toc-text">如何编写高性能的 Javascript ？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#简单介绍一下-V8-引擎的垃圾回收机制"><span class="post-toc-number">91.</span> <span class="post-toc-text">简单介绍一下 V8 引擎的垃圾回收机制</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#哪些操作会造成内存泄漏？"><span class="post-toc-number">92.</span> <span class="post-toc-text">哪些操作会造成内存泄漏？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何做到修改url参数页面不刷新"><span class="post-toc-number">93.</span> <span class="post-toc-text">如何做到修改url参数页面不刷新</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？"><span class="post-toc-number">94.</span> <span class="post-toc-text">需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何判断当前脚本运行在浏览器还是-node-环境中？（阿里）"><span class="post-toc-number">95.</span> <span class="post-toc-text">如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#把-script-标签放在页面的最底部的-body-封闭之前和封闭之后有什么区别？浏览器会如何解析它们？"><span class="post-toc-number">96.</span> <span class="post-toc-text">把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#移动端的点击事件的有延迟，时间是多久，为什么会有？-怎么解决这个延时？"><span class="post-toc-number">97.</span> <span class="post-toc-text">移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？"><span class="post-toc-number">98.</span> <span class="post-toc-text">什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何测试前端代码么？-知道-BDD-TDD-Unit-Test-么？-知道怎么测试你的前端工程么-mocha-sinon-jasmin-qUnit-？"><span class="post-toc-number">99.</span> <span class="post-toc-text">如何测试前端代码么？ 知道 BDD, TDD, Unit Test 么？ 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#检测浏览器版本版本有哪些方式？"><span class="post-toc-number">100.</span> <span class="post-toc-text">检测浏览器版本版本有哪些方式？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是-Polyfill-？"><span class="post-toc-number">101.</span> <span class="post-toc-text">什么是 Polyfill ？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用-JS-实现获取文件扩展名？"><span class="post-toc-number">102.</span> <span class="post-toc-text">使用 JS 实现获取文件扩展名？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#介绍一下-js-的节流与防抖？"><span class="post-toc-number">103.</span> <span class="post-toc-text">介绍一下 js 的节流与防抖？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Object-is-与原来的比较操作符-“-”、“-”-的区别？"><span class="post-toc-number">104.</span> <span class="post-toc-text">Object.is() 与原来的比较操作符 “===”、“==” 的区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#escape-encodeURI-encodeURIComponent-有什么区别？"><span class="post-toc-number">105.</span> <span class="post-toc-text">escape,encodeURI,encodeURIComponent 有什么区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Unicode-和-UTF-8-之间的关系？"><span class="post-toc-number">106.</span> <span class="post-toc-text">Unicode 和 UTF-8 之间的关系？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#js-中的深浅拷贝实现？"><span class="post-toc-number">107.</span> <span class="post-toc-text">js 中的深浅拷贝实现？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#手写-call、apply-及-bind-函数"><span class="post-toc-number">108.</span> <span class="post-toc-text">手写 call、apply 及 bind 函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#call-函数的实现步骤："><span class="post-toc-number">108.1.</span> <span class="post-toc-text">call 函数的实现步骤：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#apply-函数的实现步骤："><span class="post-toc-number">108.2.</span> <span class="post-toc-text">apply 函数的实现步骤：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#bind-函数的实现步骤："><span class="post-toc-number">108.3.</span> <span class="post-toc-text">bind 函数的实现步骤：</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#函数柯里化的实现"><span class="post-toc-number">109.</span> <span class="post-toc-text">函数柯里化的实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#为什么-0-1-0-2-0-3？如何解决这个问题？"><span class="post-toc-number">110.</span> <span class="post-toc-text">为什么 0.1 + 0.2 != 0.3？如何解决这个问题？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#原码、反码和补码的介绍"><span class="post-toc-number">111.</span> <span class="post-toc-text">原码、反码和补码的介绍</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#toPrecision-和-toFixed-和-Math-round-的区别？"><span class="post-toc-number">112.</span> <span class="post-toc-text">toPrecision 和 toFixed 和 Math.round 的区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是-requestAnimationFrame-？"><span class="post-toc-number">113.</span> <span class="post-toc-text">什么是 requestAnimationFrame ？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#offsetWidth-offsetHeight-clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别？"><span class="post-toc-number">114.</span> <span class="post-toc-text">offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#谈一谈你理解的函数式编程？"><span class="post-toc-number">115.</span> <span class="post-toc-text">谈一谈你理解的函数式编程？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#异步编程的实现方式？"><span class="post-toc-number">116.</span> <span class="post-toc-text">异步编程的实现方式？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Js-动画与-CSS-动画区别及相应实现"><span class="post-toc-number">117.</span> <span class="post-toc-text">Js 动画与 CSS 动画区别及相应实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#get-请求传参长度的误区"><span class="post-toc-number">118.</span> <span class="post-toc-text">get 请求传参长度的误区</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#URL-和-URI-的区别？"><span class="post-toc-number">119.</span> <span class="post-toc-text">URL 和 URI 的区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#get-和-post-请求在缓存方面的区别"><span class="post-toc-number">120.</span> <span class="post-toc-text">get 和 post 请求在缓存方面的区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#图片的懒加载和预加载"><span class="post-toc-number">121.</span> <span class="post-toc-text">图片的懒加载和预加载</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#mouseover-和-mouseenter-的区别？"><span class="post-toc-number">122.</span> <span class="post-toc-text">mouseover 和 mouseenter 的区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#js-拖拽功能的实现"><span class="post-toc-number">123.</span> <span class="post-toc-text">js 拖拽功能的实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#为什么使用-setTimeout-实现-setInterval？怎么模拟？"><span class="post-toc-number">124.</span> <span class="post-toc-text">为什么使用 setTimeout 实现 setInterval？怎么模拟？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#let-和-const-的注意点？"><span class="post-toc-number">125.</span> <span class="post-toc-text">let 和 const 的注意点？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是-rest-参数？"><span class="post-toc-number">126.</span> <span class="post-toc-text">什么是 rest 参数？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是尾调用，使用尾调用有什么好处？"><span class="post-toc-number">127.</span> <span class="post-toc-text">什么是尾调用，使用尾调用有什么好处？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Symbol-类型的注意点？"><span class="post-toc-number">128.</span> <span class="post-toc-text">Symbol 类型的注意点？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Set-和-WeakSet-结构？"><span class="post-toc-number">129.</span> <span class="post-toc-text">Set 和 WeakSet 结构？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Map-和-WeakMap-结构？"><span class="post-toc-number">130.</span> <span class="post-toc-text">Map 和 WeakMap 结构？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Reflect-对象创建目的？"><span class="post-toc-number">131.</span> <span class="post-toc-text">Reflect 对象创建目的？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#require-模块引入的查找方式？"><span class="post-toc-number">132.</span> <span class="post-toc-text">require 模块引入的查找方式？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是-Promise-对象，什么是-Promises-A-规范？"><span class="post-toc-number">133.</span> <span class="post-toc-text">什么是 Promise 对象，什么是 Promises/A+ 规范？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#手写一个-Promise"><span class="post-toc-number">134.</span> <span class="post-toc-text">手写一个 Promise</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何检测浏览器所支持的最小字体大小？"><span class="post-toc-number">135.</span> <span class="post-toc-text">如何检测浏览器所支持的最小字体大小？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#怎么做-JS-代码-Error-统计？"><span class="post-toc-number">136.</span> <span class="post-toc-text">怎么做 JS 代码 Error 统计？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#单例模式模式是什么？"><span class="post-toc-number">137.</span> <span class="post-toc-text">单例模式模式是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#策略模式是什么？"><span class="post-toc-number">138.</span> <span class="post-toc-text">策略模式是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#代理模式是什么？"><span class="post-toc-number">139.</span> <span class="post-toc-text">代理模式是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#中介者模式是什么？"><span class="post-toc-number">140.</span> <span class="post-toc-text">中介者模式是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#适配器模式是什么？"><span class="post-toc-number">141.</span> <span class="post-toc-text">适配器模式是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#开发中常用的几种Content-Type-？"><span class="post-toc-number">142.</span> <span class="post-toc-text">开发中常用的几种Content-Type ？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何确定页面的可用性时间，什么是-Performance-API？"><span class="post-toc-number">143.</span> <span class="post-toc-text">如何确定页面的可用性时间，什么是 Performance API？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#js-中的命名规则"><span class="post-toc-number">144.</span> <span class="post-toc-text">js 中的命名规则</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#js-语句末尾分号是否可以省略？"><span class="post-toc-number">145.</span> <span class="post-toc-text">js 语句末尾分号是否可以省略？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Object-assign"><span class="post-toc-number">146.</span> <span class="post-toc-text">Object.assign()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Math-ceil-和-Math-floor"><span class="post-toc-number">147.</span> <span class="post-toc-text">Math.ceil 和 Math.floor</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#js-for-循环注意点"><span class="post-toc-number">148.</span> <span class="post-toc-text">js for 循环注意点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#一个列表，假设有-100000-个数据，这个该怎么办？"><span class="post-toc-number">149.</span> <span class="post-toc-text">一个列表，假设有 100000 个数据，这个该怎么办？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#js-中倒计时的纠偏实现？"><span class="post-toc-number">150.</span> <span class="post-toc-text">js 中倒计时的纠偏实现？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#进程间通信的方式？"><span class="post-toc-number">151.</span> <span class="post-toc-text">进程间通信的方式？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ele-getElementsByClassName和ele-querySelectorAll的区别？"><span class="post-toc-number">152.</span> <span class="post-toc-text">ele.getElementsByClassName和ele.querySelectorAll的区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#请用-js-去除字符串空格？"><span class="post-toc-number">153.</span> <span class="post-toc-text">请用 js 去除字符串空格？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#同步和异步的区别"><span class="post-toc-number">154.</span> <span class="post-toc-text">同步和异步的区别?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#异步加载JS的方式有哪些？"><span class="post-toc-number">155.</span> <span class="post-toc-text">异步加载JS的方式有哪些？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#异步处理方法（参考链接）"><span class="post-toc-number">156.</span> <span class="post-toc-text">异步处理方法（参考链接）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#documen-write和-innerHTML的区别"><span class="post-toc-number">157.</span> <span class="post-toc-text">documen.write和 innerHTML的区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#怎样添加、移除、移动、复制、创建和查找节点？"><span class="post-toc-number">158.</span> <span class="post-toc-text">怎样添加、移除、移动、复制、创建和查找节点？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何判断-JS-变量的一个类型（至少三种方式）"><span class="post-toc-number">159.</span> <span class="post-toc-text">如何判断 JS 变量的一个类型（至少三种方式）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#null-undefined-的区别"><span class="post-toc-number">160.</span> <span class="post-toc-text">null/undefined 的区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#去除字符串里面的重复字符"><span class="post-toc-number">161.</span> <span class="post-toc-text">去除字符串里面的重复字符</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数组和对象的深浅拷贝（参考链接）"><span class="post-toc-number">162.</span> <span class="post-toc-text">数组和对象的深浅拷贝（参考链接）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#String-Array的一些基本操作（参考链接）"><span class="post-toc-number">163.</span> <span class="post-toc-text">String + Array的一些基本操作（参考链接）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#冒泡和捕获（参考链接）"><span class="post-toc-number">164.</span> <span class="post-toc-text">冒泡和捕获（参考链接）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#事件代理（参考链接）"><span class="post-toc-number">165.</span> <span class="post-toc-text">事件代理（参考链接）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#jsonp和跨域，为什么浏览器会禁止跨域（参考链接：jsonp）"><span class="post-toc-number">166.</span> <span class="post-toc-text">jsonp和跨域，为什么浏览器会禁止跨域（参考链接：jsonp）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#变量提升（参考链接）"><span class="post-toc-number">167.</span> <span class="post-toc-text">变量提升（参考链接）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#高阶函数（参考链接）"><span class="post-toc-number">168.</span> <span class="post-toc-text">高阶函数（参考链接）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#动画（参考链接）"><span class="post-toc-number">169.</span> <span class="post-toc-text">动画（参考链接）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#模块化开发参考链接、-UMD"><span class="post-toc-number">170.</span> <span class="post-toc-text">模块化开发参考链接、 UMD</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#引起内存泄漏的原因（参考链接）"><span class="post-toc-number">171.</span> <span class="post-toc-text">引起内存泄漏的原因（参考链接）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#map、filter、reduce相关"><span class="post-toc-number">172.</span> <span class="post-toc-text">map、filter、reduce相关</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Map和Set（参考链接）"><span class="post-toc-number">173.</span> <span class="post-toc-text">Map和Set（参考链接）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#js-是一门怎样的语言，它有什么特点"><span class="post-toc-number">174.</span> <span class="post-toc-text">js 是一门怎样的语言，它有什么特点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JavaScript-的循环语句有哪些？"><span class="post-toc-number">175.</span> <span class="post-toc-text">JavaScript 的循环语句有哪些？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#script-的位置是否会影响首屏显示时间？"><span class="post-toc-number">176.</span> <span class="post-toc-text">script 的位置是否会影响首屏显示时间？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JavaScript有几种类型的值？你能画一下他们的内存图吗？"><span class="post-toc-number">177.</span> <span class="post-toc-text">JavaScript有几种类型的值？你能画一下他们的内存图吗？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#eval是做什么的？"><span class="post-toc-number">178.</span> <span class="post-toc-text">eval是做什么的？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#javascript-代码中的”use-strict”-是什么意思-使用它区别是什么？"><span class="post-toc-number">179.</span> <span class="post-toc-text">javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#js延迟加载的方式有哪些？"><span class="post-toc-number">180.</span> <span class="post-toc-text">js延迟加载的方式有哪些？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#介绍-DOM-的发展"><span class="post-toc-number">181.</span> <span class="post-toc-text">介绍 DOM 的发展</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”？"><span class="post-toc-number">182.</span> <span class="post-toc-text">区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何获得一个DOM元素的绝对位置？"><span class="post-toc-number">183.</span> <span class="post-toc-text">如何获得一个DOM元素的绝对位置？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#用原生JavaScript的实现过什么功能吗？"><span class="post-toc-number">184.</span> <span class="post-toc-text">用原生JavaScript的实现过什么功能吗？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JavaScript实现异步编程的方法？"><span class="post-toc-number">185.</span> <span class="post-toc-text">JavaScript实现异步编程的方法？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#web开发中会话跟踪的方法有哪些"><span class="post-toc-number">186.</span> <span class="post-toc-text">web开发中会话跟踪的方法有哪些</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JavaScript有几种类型的值？，你能画一下他们的内存图吗？"><span class="post-toc-number">187.</span> <span class="post-toc-text">JavaScript有几种类型的值？，你能画一下他们的内存图吗？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#eval是做什么的？-1"><span class="post-toc-number">188.</span> <span class="post-toc-text">eval是做什么的？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#javascript-代码中的”use-strict”-是什么意思-使用它区别是什么？-1"><span class="post-toc-number">189.</span> <span class="post-toc-text">javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#js延迟加载的方式有哪些？-1"><span class="post-toc-number">190.</span> <span class="post-toc-text">js延迟加载的方式有哪些？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#异步加载JS的方式有哪些？-1"><span class="post-toc-number">191.</span> <span class="post-toc-text">异步加载JS的方式有哪些？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#defer和async"><span class="post-toc-number">192.</span> <span class="post-toc-text">defer和async</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#documen-write和-innerHTML的区别-1"><span class="post-toc-number">193.</span> <span class="post-toc-text">documen.write和 innerHTML的区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#那些操作会造成内存泄漏？"><span class="post-toc-number">194.</span> <span class="post-toc-text">那些操作会造成内存泄漏？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Javascript垃圾回收方法"><span class="post-toc-number">195.</span> <span class="post-toc-text">Javascript垃圾回收方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#用过哪些设计模式？"><span class="post-toc-number">196.</span> <span class="post-toc-text">用过哪些设计模式？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制"><span class="post-toc-number">197.</span> <span class="post-toc-text">实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#说说严格模式的限制"><span class="post-toc-number">198.</span> <span class="post-toc-text">说说严格模式的限制</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何删除一个cookie"><span class="post-toc-number">199.</span> <span class="post-toc-text">如何删除一个cookie</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#attribute和property的区别是什么？"><span class="post-toc-number">200.</span> <span class="post-toc-text">attribute和property的区别是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#页面编码和被请求的资源编码如果不一致如何处理？"><span class="post-toc-number">201.</span> <span class="post-toc-text">页面编码和被请求的资源编码如果不一致如何处理？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#把-lt-script-gt-放在-lt-body-gt-之前和之后有什么区别？浏览器会如何解析它们？"><span class="post-toc-number">202.</span> <span class="post-toc-text">把&lt;script&gt;放在&lt;/body&gt;之前和之后有什么区别？浏览器会如何解析它们？</span></a></li></ol>
        </nav>
    </aside>


<article id="post-interview/JavaScript"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">JavaScript</h1>
        <div class="post-meta">
            <time class="post-time" title="2024-02-14 10:24:57" datetime="2024-02-14T02:24:57.000Z"  itemprop="datePublished">2024-02-14</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/前端面试题/">前端面试题</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h3 id="JS的基本数据类型和引用数据类型"><a href="#JS的基本数据类型和引用数据类型" class="headerlink" title="JS的基本数据类型和引用数据类型"></a>JS的基本数据类型和引用数据类型</h3><ul>
<li><p>基本数据类型</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>单双引号引起来的数据</td>
</tr>
<tr>
<td>number</td>
<td>包括整型和浮点型</td>
</tr>
<tr>
<td>undefiend</td>
<td>未初始化的变量</td>
</tr>
<tr>
<td>null</td>
<td>相当于占位符</td>
</tr>
<tr>
<td>boolean</td>
<td>true真   false 假</td>
</tr>
<tr>
<td>Symbol</td>
<td>ES6新增，表示独一无二且不可变的值</td>
</tr>
<tr>
<td>BigInt</td>
<td>ES10新增，BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</td>
</tr>
</tbody></table>
</li>
<li><p>引用数据类型：object、array、function</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;    // 对象</span><br><span class="line">var arr = [];    // 数组</span><br><span class="line">var fn = function()&#123;&#125;;    // 函数</span><br></pre></td></tr></table></figure>

<h3 id="javascript-的-typeof-返回哪些数据类型"><a href="#javascript-的-typeof-返回哪些数据类型" class="headerlink" title="javascript 的 typeof 返回哪些数据类型"></a>javascript 的 typeof 返回哪些数据类型</h3><p>7 种分别为 string、boolean、number、Object、Function、undefined、symbol(ES6)、</p>
<h3 id="检测数据类型"><a href="#检测数据类型" class="headerlink" title="检测数据类型"></a>检测数据类型</h3><blockquote>
<p>typeof  +  变量名</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">检测</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>null</strong></td>
<td align="center"><strong>object</strong></td>
</tr>
<tr>
<td align="center"><strong>{}</strong></td>
<td align="center"><strong>object</strong></td>
</tr>
<tr>
<td align="center"><strong>[]</strong></td>
<td align="center"><strong>object</strong></td>
</tr>
<tr>
<td align="center">undefined</td>
<td align="center">undefined</td>
</tr>
<tr>
<td align="center">string</td>
<td align="center">string</td>
</tr>
<tr>
<td align="center">number</td>
<td align="center">number</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">boolean</td>
</tr>
<tr>
<td align="center">Symbol</td>
<td align="center">symbol</td>
</tr>
<tr>
<td align="center">function</td>
<td align="center">function</td>
</tr>
</tbody></table>
<h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>强制类型转换</p>
<ul>
<li>Number() 任意类型数据转化为数字</li>
<li>parselnt() 任意类型数据转化为整数</li>
<li>parseFloat() 任意类型数据转化为浮点数</li>
<li>String) 任意类型数据转化为字符串</li>
<li>Boolean() 任意类型数据转化为布尔值</li>
</ul>
<p>隐式类型转换</p>
<ul>
<li>算术运算符</li>
<li>逻辑运算符：&amp;&amp;||！运算，会调用Boolean()~函数判断参与逻辑运算的数据的真假性</li>
<li>关系运算符：<br>if、while、do while语句和三元表达式 里面的判断条件表达式会隐式的调用 Boolean()函数</li>
</ul>
<h3 id="复杂数据类型如何转变为字符串"><a href="#复杂数据类型如何转变为字符串" class="headerlink" title="复杂数据类型如何转变为字符串"></a>复杂数据类型如何转变为字符串</h3><ul>
<li>首先，会调用 valueOf 方法，如果方法的返回值是一个基本数据类型，就返回这个值</li>
<li>如果调用 valueOf 方法之后的返回值仍旧是一个复杂数据类型，就会调用该对象的 toString 方法</li>
<li>如果 toString 方法调用之后的返回值是一个基本数据类型，就返回这个值，</li>
<li>如果 toString 方法调用之后的返回值是一个复杂数据类型，就报一个错误。</li>
</ul>
<h3 id="JavaScript-中如何检测一个变量是一个-String-类型？"><a href="#JavaScript-中如何检测一个变量是一个-String-类型？" class="headerlink" title="JavaScript 中如何检测一个变量是一个 String 类型？"></a>JavaScript 中如何检测一个变量是一个 String 类型？</h3><p>答案：三种方法（typeof、constructor、Object.prototype.toString.call()）</p>
<p>解析：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">①<span class="keyword">typeof</span></span><br><span class="line"><span class="keyword">typeof</span>(<span class="string">'123'</span>) === <span class="string">"string"</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'123'</span> === <span class="string">"string"</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">②<span class="keyword">constructor</span></span><br><span class="line">'123'.<span class="keyword">constructor</span> === String // true</span><br><span class="line"></span><br><span class="line">③Object.prototype.toString.call()</span><br><span class="line">Object.prototype.toString.call('123') === '[object String]' // true</span><br></pre></td></tr></table></figure>

<h3 id="JavaScript-有几种类型的值？你能画一下他们的内存图吗？"><a href="#JavaScript-有几种类型的值？你能画一下他们的内存图吗？" class="headerlink" title="JavaScript 有几种类型的值？你能画一下他们的内存图吗？"></a>JavaScript 有几种类型的值？你能画一下他们的内存图吗？</h3><p>涉及知识点：</p>
<ul>
<li>栈：原始数据类型（Undefined、Null、Boolean、Number、String）</li>
<li>堆：引用数据类型（对象、数组和函数）</li>
</ul>
<p>两种类型的区别是：存储位置不同。<br>原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</p>
<p>引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。<br><a href="https://blog.csdn.net/jiangjuanjaun/article/details/80327342" target="_blank" rel="noopener">《JavaScript 有几种类型的值？能否画一下它们的内存图；》</a></p>
<h3 id="什么是堆？什么是栈？它们之间有什么区别和联系？"><a href="#什么是堆？什么是栈？它们之间有什么区别和联系？" class="headerlink" title="什么是堆？什么是栈？它们之间有什么区别和联系？"></a>什么是堆？什么是栈？它们之间有什么区别和联系？</h3><p>堆和栈的概念存在于数据结构中和操作系统内存中。</p>
<p>在数据结构中</p>
<p>栈中数据的存取方式为先进后出。而堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。完全二叉树是堆的一种实现方式。</p>
<p>在操作系统中</p>
<p>内存被分为栈区和堆区。</p>
<p>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p>
<p>堆区内存一般由程序员分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收。</p>
<p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/19729973" target="_blank" rel="noopener">《什么是堆？什么是栈？他们之间有什么区别和联系？》</a></p>
<h3 id="null，undefined-的区别？"><a href="#null，undefined-的区别？" class="headerlink" title="null，undefined 的区别？"></a>null，undefined 的区别？</h3><h4 id="undefined-表示不存在这个值。"><a href="#undefined-表示不存在这个值。" class="headerlink" title="undefined   表示不存在这个值。"></a>undefined   表示不存在这个值。</h4><p>undefined :是一个表示”无”的原始值或者说表示”缺少值”，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined</p>
<p>例如变量被声明了，但没有赋值时，就等于undefined</p>
<h4 id="null-表示一个对象被定义了，值为“空值”"><a href="#null-表示一个对象被定义了，值为“空值”" class="headerlink" title="null 表示一个对象被定义了，值为“空值”"></a>null 表示一个对象被定义了，值为“空值”</h4><p>null : 是一个对象(空对象, 没有任何属性和方法)</p>
<p>例如作为函数的参数，表示该函数的参数不是对象；</p>
<p>在验证null时，一定要使用　=== ，因为 == 无法分别 null 和　undefined</p>
<h3 id="和-的不同"><a href="#和-的不同" class="headerlink" title="== 和 === 的不同"></a>== 和 === 的不同</h3><p>答案：<code>==</code>是抽象相等运算符，而<code>===</code>是严格相等运算符。</p>
<p><code>==</code>运算符是在进行必要的类型转换后，再比较。</p>
<p><code>===</code>运算符不会进行类型转换，所以如果两个值不是相同的类型，会直接返回<code>false</code>。使用<code>==</code>时，可能发生一些特别的事情，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="string">"1"</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span> == [<span class="number">1</span>]; <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span> == <span class="literal">true</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">""</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">"0"</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">false</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果你对<code>==</code>和<code>===</code>的概念不是特别了解，建议大多数情况下使用<code>===</code></p>
<h3 id="如何判断-NaN"><a href="#如何判断-NaN" class="headerlink" title="如何判断 NaN"></a>如何判断 NaN</h3><p>isNaN()方法</p>
<p>解析：isNaN(NaN) // true</p>
<h3 id="说几条写JavaScript的基本规范？"><a href="#说几条写JavaScript的基本规范？" class="headerlink" title="说几条写JavaScript的基本规范？"></a>说几条写JavaScript的基本规范？</h3><ul>
<li><p>代码缩进，建议使用“四个空格”缩进</p>
</li>
<li><p>代码段使用花括号{}包裹</p>
</li>
<li><p>语句结束使用分号;</p>
</li>
<li><p>变量和函数在使用前进行声明，不要在同一行声明多个变量。</p>
</li>
<li><p>以大写字母开头命名构造函数，全大写命名常量</p>
</li>
<li><p>规范定义JSON对象，补全双引号</p>
</li>
<li><p>用{}和[]声明对象和数组</p>
</li>
<li><p>请使用 ===/!==来比较true/false或者数值</p>
</li>
<li><p>使用对象字面量替代new Array这种形式</p>
</li>
<li><p>不要使用全局函数</p>
</li>
<li><p>Switch语句必须带有default分支</p>
</li>
<li><p>函数不应该有时候有返回值，有时候没有返回值。</p>
</li>
<li><p>For循环必须使用大括号，If语句必须使用大括号。</p>
</li>
<li><p>for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。</p>
</li>
</ul>
<h3 id="如何编写高性能的JavaScript？"><a href="#如何编写高性能的JavaScript？" class="headerlink" title="如何编写高性能的JavaScript？"></a>如何编写高性能的JavaScript？</h3><ul>
<li>将js脚本放在页面底部，加快渲染页面</li>
<li>尽量减少使用闭包</li>
<li>将js脚本将脚本成组打包，减少请求</li>
<li>使用非阻塞方式下载js脚本</li>
<li>尽量使用局部变量来保存全局变量</li>
<li>遵循严格模式：”use strict”;</li>
<li>使用 window 对象属性方法时，省略 window</li>
<li>尽量减少对象成员嵌套</li>
<li>缓存 DOM 节点的访问</li>
<li>通过避免使用 eval() 和 Function() 构造器</li>
<li>给 setTimeout() 和 setInterval() 传递函数而不是字符串作为参数</li>
<li>尽量使用直接量创建对象和数组</li>
<li>最小化重绘(repaint)和回流(reflow)</li>
<li>使用 DocumentFragment 优化多次 append</li>
<li>通过模板元素 clone ，替代 createElement</li>
<li>使用一次 innerHTML 赋值代替构建 dom 元素</li>
<li>使用 firstChild 和 nextSibling 代替 childNodes 遍历 dom 元素</li>
<li>使用 Array 做为 StringBuffer ，代替字符串拼接的操作</li>
<li>将循环控制量保存到局部变量</li>
<li>顺序无关的遍历时，用 while 替代 for</li>
<li>将条件分支，按可能性顺序从高到低排列</li>
<li>在同一条件子的多（ &gt;2 ）条件分支时，使用 switch 优于 if</li>
<li>使用三目运算符替代条件分支</li>
<li>需要不断执行的时候，优先考虑使用 setInterval</li>
</ul>
<h3 id="document-load-和-document-ready-的区别"><a href="#document-load-和-document-ready-的区别" class="headerlink" title="document load 和 document ready 的区别"></a>document load 和 document ready 的区别</h3><p>页面加载完成有两种事件<br>1.load是当页面所有资源全部加载完成后（包括DOM文档树，css文件，js文件，图片资源等），执行一个函数<br>问题：如果图片资源较多，加载时间较长，onload后等待执行的函数需要等待较长时间，所以一些效果可能受到影响</p>
<p>2.$(document).ready()是当DOM文档树加载完成后执行一个函数 （不包含图片，css等）所以会比load较快执行<br>在原生的jS中不包括ready()这个方法，只有load方法就是onload事件</p>
<h3 id="字符串常用操作"><a href="#字符串常用操作" class="headerlink" title="字符串常用操作"></a>字符串常用操作</h3><ul>
<li>charAt(index):返回指定索引处的字符串</li>
<li>charCodeAt(index):返回指定索引处的字符的 Unicode 的值</li>
<li>concat(str1,str2,…):连接多个字符串，返回连接后的字符串的副本</li>
<li>fromCharCode():将 Unicode 值转换成实际的字符串</li>
<li>indexOf(str):返回 str 在父串中第一次出现的位置，若没有则返回-1</li>
<li>lastIndexOf(str):返回 str 在父串中最后一次出现的位置，若没有则返回-1</li>
<li>match(regex):搜索字符串，并返回正则表达式的所有匹配</li>
<li>replace(str1,str2):str1 也可以为正则表达式，用 str2 替换 str1</li>
<li>search(regex):基于正则表达式搜索字符串，并返回第一个匹配的位置</li>
<li>slice(start,end)：返回字符索引在 start 和 end（不含）之间的子串</li>
<li>split(sep，limit)：将字符串分割为字符数组，limit 为从头开始执行分割的最大数量</li>
<li>substr(start，length)：从字符索引 start 的位置开始，返回长度为 length 的子串</li>
<li>substring(from,to)：返回字符索引在 from 和 to（不含）之间的子串</li>
<li>toLowerCase()：将字符串转换为小写</li>
<li>toUpperCase()：将字符串转换为大写</li>
<li>valueOf()：返回原始字符串值</li>
</ul>
<h3 id="内部属性-Class-是什么？"><a href="#内部属性-Class-是什么？" class="headerlink" title="内部属性 [[Class]] 是什么？"></a>内部属性 [[Class]] 是什么？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">所有 typeof 返回值为 &quot;object&quot; 的对象（如数组）都包含一个内部属性 [[Class]]（我们可以把它看作一个内部的分类，而非</span><br><span class="line">传统的面向对象意义上的类）。这个属性无法直接访问，一般通过 Object.prototype.toString(..) 来查看。例如：</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call( [1,2,3] );</span><br><span class="line">// &quot;[object Array]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call( /regex-literal/i );</span><br><span class="line">// &quot;[object RegExp]&quot;</span><br><span class="line"></span><br><span class="line">// 我们自己创建的类就不会有这份特殊待遇，因为 toString() 找不到 toStringTag 属性时只好返回默认的 Object 标签</span><br><span class="line">// 默认情况类的[[Class]]返回[object Object]</span><br><span class="line">class Class1 &#123;&#125;</span><br><span class="line">Object.prototype.toString.call(new Class1()); // &quot;[object Object]&quot;</span><br><span class="line">// 需要定制[[Class]]</span><br><span class="line">class Class2 &#123;</span><br><span class="line">  get [Symbol.toStringTag]() &#123;</span><br><span class="line">    return &quot;Class2&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Object.prototype.toString.call(new Class2()); // &quot;[object Class2]&quot;</span><br></pre></td></tr></table></figure>

<h3 id="介绍-js-有哪些内置对象？"><a href="#介绍-js-有哪些内置对象？" class="headerlink" title="介绍 js 有哪些内置对象？"></a>介绍 js 有哪些内置对象？</h3><p>涉及知识点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">全局的对象（ global objects ）或称标准内置对象，不要和 &quot;全局对象（global object）&quot; 混淆。这里说的全局的对象是说在</span><br><span class="line">全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。</span><br><span class="line"></span><br><span class="line">标准内置对象的分类</span><br><span class="line"></span><br><span class="line">（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。</span><br><span class="line"></span><br><span class="line">例如 Infinity、NaN、undefined、null 字面量</span><br><span class="line"></span><br><span class="line">（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。</span><br><span class="line"></span><br><span class="line">例如 eval()、parseFloat()、parseInt() 等</span><br><span class="line"></span><br><span class="line">（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。</span><br><span class="line"></span><br><span class="line">例如 Object、Function、Boolean、Symbol、Error 等</span><br><span class="line"></span><br><span class="line">（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。</span><br><span class="line"></span><br><span class="line">例如 Number、Math、Date</span><br><span class="line"></span><br><span class="line">（5）字符串，用来表示和操作字符串的对象。</span><br><span class="line"></span><br><span class="line">例如 String、RegExp</span><br><span class="line"></span><br><span class="line">（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array</span><br><span class="line"></span><br><span class="line">（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。</span><br><span class="line"></span><br><span class="line">例如 Map、Set、WeakMap、WeakSet</span><br><span class="line"></span><br><span class="line">（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。</span><br><span class="line"></span><br><span class="line">例如 SIMD 等</span><br><span class="line"></span><br><span class="line">（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。</span><br><span class="line"></span><br><span class="line">例如 JSON 等</span><br><span class="line"></span><br><span class="line">（10）控制抽象对象</span><br><span class="line"></span><br><span class="line">例如 Promise、Generator 等</span><br><span class="line"></span><br><span class="line">（11）反射</span><br><span class="line"></span><br><span class="line">例如 Reflect、Proxy</span><br><span class="line"></span><br><span class="line">（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。</span><br><span class="line"></span><br><span class="line">例如 Intl、Intl.Collator 等</span><br><span class="line"></span><br><span class="line">（13）WebAssembly</span><br><span class="line"></span><br><span class="line">（14）其他</span><br><span class="line"></span><br><span class="line">例如 arguments</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函</span><br><span class="line">数对象。一般我们经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构</span><br><span class="line">造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="noopener">《标准内置对象的分类》</a><br><a href="https://segmentfault.com/a/1190000011467723#articleHeader24" target="_blank" rel="noopener">《JS 所有内置对象属性和方法汇总》</a></p>
<h3 id="undefined-与-undeclared-的区别？"><a href="#undefined-与-undeclared-的区别？" class="headerlink" title="undefined 与 undeclared 的区别？"></a>undefined 与 undeclared 的区别？</h3><p>已在作用域中声明但还没有赋值的变量，是 undefined 的。相反，还没有在作用域中声明过的变量，是 undeclared 的。</p>
<p>对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用 typ<br>eof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 “undefined”。</p>
<h3 id="null-和-undefined-的区别？"><a href="#null-和-undefined-的区别？" class="headerlink" title="null 和 undefined 的区别？"></a>null 和 undefined 的区别？</h3><p>首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</p>
<p>undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null<br>主要用于赋值给一些可能会返回对象的变量，作为初始化。</p>
<p>undefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它<br>会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。</p>
<p>当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等<br>号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</p>
<p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8Bundefined%E4%B8%8Enull.html" target="_blank" rel="noopener">《JavaScript 深入理解之 undefined 与 null》</a></p>
<h3 id="如何获取安全的-undefined-值？"><a href="#如何获取安全的-undefined-值？" class="headerlink" title="如何获取安全的 undefined 值？"></a>如何获取安全的 undefined 值？</h3><p>因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。</p>
<p>表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。</p>
<p>按惯例我们用 void 0 来获得 undefined。</p>
<h3 id="说几条写-JavaScript-的基本规范？"><a href="#说几条写-JavaScript-的基本规范？" class="headerlink" title="说几条写 JavaScript 的基本规范？"></a>说几条写 JavaScript 的基本规范？</h3><p>在平常项目开发中，我们遵守一些这样的基本规范，比如说：</p>
<p>（1）一个函数作用域中所有的变量声明应该尽量提到函数首部，用一个 var 声明，不允许出现两个连续的 var 声明，声明时<br>    如果变量没有值，应该给该变量赋值对应类型的初始值，便于他人阅读代码时，能够一目了然的知道变量对应的类型值。</p>
<p>（2）代码中出现地址、时间等字符串时需要使用常量代替。</p>
<p>（3）在进行比较的时候吧，尽量使用’===’, ‘!==’代替’==’, ‘!=’。</p>
<p>（4）不要在内置对象的原型上添加方法，如 Array, Date。</p>
<p>（5）switch 语句必须带有 default 分支。</p>
<p>（6）for 循环必须使用大括号。</p>
<p>（7）if 语句必须使用大括号。</p>
<h3 id="JavaScript-原型，原型链？-有什么特点？"><a href="#JavaScript-原型，原型链？-有什么特点？" class="headerlink" title="JavaScript 原型，原型链？ 有什么特点？"></a>JavaScript 原型，原型链？ 有什么特点？</h3><p>在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说我们是不应该能够获取到这个值的，但是现在浏览器中都实现了 <strong>proto</strong> 属性来让我们访问这个属性，但是我们最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个Object.getPrototypeOf() 方法，我们可以通过这个方法来获取对象的原型。</p>
<p>当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是我们新建的对象为什么能够使用 toString() 等方法的原因。</p>
<p>特点：</p>
<p>JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</p>
<p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE.html" target="_blank" rel="noopener">《JavaScript 深入理解之原型与原型链》</a></p>
<h3 id="js-获取原型的方法？"><a href="#js-获取原型的方法？" class="headerlink" title="js 获取原型的方法？"></a>js 获取原型的方法？</h3><ul>
<li>p.__proto__</li>
<li>p.constructor.prototype</li>
<li>Object.getPrototypeOf(p)</li>
</ul>
<h3 id="在-js-中不同进制数字的表示方式"><a href="#在-js-中不同进制数字的表示方式" class="headerlink" title="在 js 中不同进制数字的表示方式"></a>在 js 中不同进制数字的表示方式</h3><ul>
<li><p>以 0X、0x 开头的表示为十六进制。</p>
</li>
<li><p>以 0、0O、0o 开头的表示为八进制。</p>
</li>
<li><p>以 0B、0b 开头的表示为二进制格式。</p>
</li>
</ul>
<h3 id="js-中整数的安全范围是多少？"><a href="#js-中整数的安全范围是多少？" class="headerlink" title="js 中整数的安全范围是多少？"></a>js 中整数的安全范围是多少？</h3><p>安全整数指的是，在这个范围内的整数转化为二进制存储的时候不会出现精度丢失，能够被“安全”呈现的最大整数是 2^53 - 1，<br>即9007199254740991，在 ES6 中被定义为 Number.MAX_SAFE_INTEGER。最小整数是-9007199254740991，在 ES6 中被定义为 Number.MIN_SAFE_INTEGER。</p>
<p>如果某次计算的结果得到了一个超过 JavaScript 数值范围的值，那么这个值会被自动转换为特殊的 Infinity 值。如果某次计算返回了正或负的 Infinity 值，那么该值将无法参与下一次的计算。判断一个数是不是有穷的，可以使用 isFinite 函数来判断。</p>
<h3 id="typeof-NaN-的结果是什么？"><a href="#typeof-NaN-的结果是什么？" class="headerlink" title="typeof NaN 的结果是什么？"></a>typeof NaN 的结果是什么？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NaN 意指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</span><br><span class="line"></span><br><span class="line">typeof NaN; // &quot;number&quot;</span><br><span class="line"></span><br><span class="line">NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN != NaN为 true。</span><br></pre></td></tr></table></figure>

<h3 id="isNaN-和-Number-isNaN-函数的区别？"><a href="#isNaN-和-Number-isNaN-函数的区别？" class="headerlink" title="isNaN 和 Number.isNaN 函数的区别？"></a>isNaN 和 Number.isNaN 函数的区别？</h3><p>函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。</p>
<p>函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，这种方法对于 NaN 的判断更为准确。</p>
<h3 id="Array-构造函数只有一个参数值时的表现？"><a href="#Array-构造函数只有一个参数值时的表现？" class="headerlink" title="Array 构造函数只有一个参数值时的表现？"></a>Array 构造函数只有一个参数值时的表现？</h3><p>Array 构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度（length），而非只充当数组中的一个元素。这样<br>创建出来的只是一个空数组，只不过它的 length 属性被设置成了指定的值。</p>
<p>构造函数 Array(..) 不要求必须带 new 关键字。不带时，它会被自动补上。</p>
<h3 id="其他值到字符串的转换规则？"><a href="#其他值到字符串的转换规则？" class="headerlink" title="其他值到字符串的转换规则？"></a>其他值到字符串的转换规则？</h3><p>规范的 9.8 节中定义了抽象操作 ToString ，它负责处理非字符串到字符串的强制类型转换。</p>
<p>（1）Null 和 Undefined 类型 ，null 转换为 “null”，undefined 转换为 “undefined”，</p>
<p>（2）Boolean 类型，true 转换为 “true”，false 转换为 “false”。</p>
<p>（3）Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。</p>
<p>（4）Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。</p>
<p>（5）对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）<br>    来返回内部属性 [[Class]] 的值，如”[object Object]”。如果对象有自己的 toString() 方法，字符串化时就会<br>    调用该方法并使用其返回值。</p>
<h3 id="其他值到数字值的转换规则？"><a href="#其他值到数字值的转换规则？" class="headerlink" title="其他值到数字值的转换规则？"></a>其他值到数字值的转换规则？</h3><p>有时我们需要将非数字值当作数字来使用，比如数学运算。为此 ES5 规范在 9.3 节定义了抽象操作 ToNumber。</p>
<p>（1）Undefined 类型的值转换为 NaN。</p>
<p>（2）Null 类型的值转换为 0。</p>
<p>（3）Boolean 类型的值，true 转换为 1，false 转换为 0。</p>
<p>（4）String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。</p>
<p>（5）Symbol 类型的值不能转换为数字，会报错。</p>
<p>（6）对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。</p>
<p>为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf() 方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。</p>
<p>如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。</p>
<h3 id="其他值到布尔类型的值的转换规则？"><a href="#其他值到布尔类型的值的转换规则？" class="headerlink" title="其他值到布尔类型的值的转换规则？"></a>其他值到布尔类型的值的转换规则？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ES5 规范 9.2 节中定义了抽象操作 ToBoolean，列举了布尔强制类型转换所有可能出现的结果。</span><br><span class="line"></span><br><span class="line">以下这些是假值：</span><br><span class="line">• undefined</span><br><span class="line">• null</span><br><span class="line">• false</span><br><span class="line">• +0、-0 和 NaN</span><br><span class="line">• &quot;&quot;</span><br><span class="line"></span><br><span class="line">假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。</span><br></pre></td></tr></table></figure>

<h3 id="和-的-valueOf-和-toString-的结果是什么？"><a href="#和-的-valueOf-和-toString-的结果是什么？" class="headerlink" title="{} 和 [] 的 valueOf 和 toString 的结果是什么？"></a>{} 和 [] 的 valueOf 和 toString 的结果是什么？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125; 的 valueOf 结果为 &#123;&#125; ，toString 的结果为 &quot;[object Object]&quot;</span><br><span class="line"></span><br><span class="line">[] 的 valueOf 结果为 [] ，toString 的结果为 &quot;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="什么是假值对象？"><a href="#什么是假值对象？" class="headerlink" title="什么是假值对象？"></a>什么是假值对象？</h3><p>浏览器在某些特定情况下，在常规 JavaScript 语法基础上自己创建了一些外来值，这些就是“假值对象”。假值对象看起来和普通对象并无二致（都有属性，等等），但将它们强制类型转换为布尔值时结果为 false 最常见的例子是 document.all，它是一个类数组对象，包含了页面上的所有元素，由 DOM（而不是 JavaScript 引擎）提供给 JavaScript 程序使用。</p>
<h3 id="操作符的作用？"><a href="#操作符的作用？" class="headerlink" title="~ 操作符的作用？"></a>~ 操作符的作用？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~ 返回 2 的补码，并且 ~ 会将数字转换为 32 位整数，因此我们可以使用 ~ 来进行取整操作。</span><br><span class="line"></span><br><span class="line">~x 大致等同于 -(x+1)。</span><br></pre></td></tr></table></figure>

<h3 id="解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？"><a href="#解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？" class="headerlink" title="解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？"></a>解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？</h3><p>解析允许字符串（如 parseInt() ）中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换（如 Nu<br>mber ()）不允许出现非数字字符，否则会失败并返回 NaN。</p>
<h3 id="操作符什么时候用于字符串的拼接？"><a href="#操作符什么时候用于字符串的拼接？" class="headerlink" title="+ 操作符什么时候用于字符串的拼接？"></a><code>+</code> 操作符什么时候用于字符串的拼接？</h3><p>根据 ES5 规范 11.6.1 节，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其<br>中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以<br>数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。</p>
<p>简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字<br>加法。</p>
<p>那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。</p>
<h3 id="什么情况下会发生布尔值的隐式强制类型转换？"><a href="#什么情况下会发生布尔值的隐式强制类型转换？" class="headerlink" title="什么情况下会发生布尔值的隐式强制类型转换？"></a>什么情况下会发生布尔值的隐式强制类型转换？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1） if (..) 语句中的条件判断表达式。</span><br><span class="line">（2） for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。</span><br><span class="line">（3） while (..) 和 do..while(..) 循环中的条件判断表达式。</span><br><span class="line">（4） ? : 中的条件判断表达式。</span><br><span class="line">（5） 逻辑运算符 ||（逻辑或）和 &amp;&amp;（逻辑与）左边的操作数（作为条件判断表达式）。</span><br></pre></td></tr></table></figure>

<h3 id="和-amp-amp-操作符的返回值？"><a href="#和-amp-amp-操作符的返回值？" class="headerlink" title="|| 和 &amp;&amp; 操作符的返回值？"></a>|| 和 &amp;&amp; 操作符的返回值？</h3><p>|| 和 &amp;&amp; 首先会对第一个操作数执行条件判断，如果其不是布尔值就先进行 ToBoolean 强制类型转换，然后再执行条件判断。</p>
<p>对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。</p>
<p>&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。</p>
<p>|| 和 &amp;&amp; 返回它们其中一个操作数的值，而非条件判断的结果</p>
<h3 id="Symbol-值的强制类型转换？"><a href="#Symbol-值的强制类型转换？" class="headerlink" title="Symbol 值的强制类型转换？"></a>Symbol 值的强制类型转换？</h3><p>ES6 允许从符号到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误。</p>
<p>Symbol 值不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换为布尔值（显式和隐式结果<br>都是 true ）。</p>
<h3 id="操作符的强制类型转换规则？"><a href="#操作符的强制类型转换规则？" class="headerlink" title="== 操作符的强制类型转换规则？"></a>== 操作符的强制类型转换规则？</h3><p>（1）字符串和数字之间的相等比较，将字符串转换为数字之后再进行比较。</p>
<p>（2）其他类型和布尔类型之间的相等比较，先将布尔值转换为数字后，再应用其他规则进行比较。</p>
<p>（3）null 和 undefined 之间的相等比较，结果为真。其他值和它们进行比较都返回假值。</p>
<p>（4）对象和非对象之间的相等比较，对象先调用 ToPrimitive 抽象操作后，再进行比较。</p>
<p>（5）如果一个操作值为 NaN ，则相等比较返回 false（ NaN 本身也不等于 NaN ）。</p>
<p>（6）如果两个操作值都是对象，则比较它们是不是指向同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true，否则，返回 false。</p>
<p>详细资料可以参考：<br><a href="https://www.jeffjade.com/2015/08/28/2015-09-02-js-string-compare/" target="_blank" rel="noopener">《JavaScript 字符串间的比较》</a></p>
<h3 id="如何将字符串转化为数字，例如-‘12-3b’"><a href="#如何将字符串转化为数字，例如-‘12-3b’" class="headerlink" title="如何将字符串转化为数字，例如 ‘12.3b’?"></a>如何将字符串转化为数字，例如 ‘12.3b’?</h3><p>（1）使用 Number() 方法，前提是所包含的字符串不包含不合法字符。</p>
<p>（2）使用 parseInt() 方法，parseInt() 函数可解析一个字符串，并返回一个整数。还可以设置要解析的数字的基数。当基数的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。</p>
<p>（3）使用 parseFloat() 方法，该函数解析一个字符串参数并返回一个浮点数。</p>
<p>（4）使用 + 操作符的隐式转换，前提是所包含的字符串不包含不合法字符。</p>
<p>详细资料可以参考：<br><a href="https://blog.csdn.net/m0_38099607/article/details/72638678" target="_blank" rel="noopener">《详解 JS 中 Number()、parseInt() 和 parseFloat() 的区别》</a></p>
<h3 id="如何将浮点数点左边的数每三位添加一个逗号，如-12000000-11-转化为『12-000-000-11』"><a href="#如何将浮点数点左边的数每三位添加一个逗号，如-12000000-11-转化为『12-000-000-11』" class="headerlink" title="如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?"></a>如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> number &amp;&amp; number.replace(<span class="regexp">/(?!^)(?=(\d&#123;3&#125;)+\.)/g</span>, <span class="string">","</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format1</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Intl</span>.NumberFormat().format(number)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法三</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format2</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> number.toLocaleString(<span class="string">'en'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）匹配 16 进制颜色值</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）匹配日期，如 yyyy-mm-dd 格式</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）匹配 qq 号</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[1-9][0-9]&#123;4,10&#125;$/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （4）手机号码正则</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^1[34578]\d&#123;9&#125;$/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （5）用户名正则</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[a-zA-Z\$][a-zA-Z0-9_\$]&#123;4,16&#125;$/</span>;</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://caibaojian.com/form-regexp.html" target="_blank" rel="noopener">《前端表单验证常用的 15 个 JS 正则表达式》</a><br><a href="https://www.jianshu.com/p/1cb5229325a7" target="_blank" rel="noopener">《JS 常用正则汇总》</a></p>
<h3 id="生成随机数的各种方法？"><a href="#生成随机数的各种方法？" class="headerlink" title="生成随机数的各种方法？"></a>生成随机数的各种方法？</h3><p><a href="http://www.hangge.com/blog/cache/detail_1872.html" target="_blank" rel="noopener">《JS - 生成随机数的方法汇总（不同范围、类型的随机数）》</a></p>
<h3 id="如何实现数组的随机排序？"><a href="#如何实现数组的随机排序？" class="headerlink" title="如何实现数组的随机排序？"></a>如何实现数组的随机排序？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）使用数组 sort 方法对数组元素随机排序，让 Math.random() 出来的数与 0.5 比较，如果大于就返回 1 交换位置，如果小于就返回 -1，不交换位置。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  缺点：每个元素被派到新数组的位置不是随机的，原因是 sort() 方法是依次比较的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）随机从原数组抽取一个元素，加入到新数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (arr.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> randomIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * arr.length);</span><br><span class="line">    result.push(arr[randomIndex]);</span><br><span class="line">    arr.splice(randomIndex, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）随机交换数组内的元素（洗牌算法类似）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index,</span><br><span class="line">    randomIndex,</span><br><span class="line">    temp,</span><br><span class="line">    len = arr.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; len; index++) &#123;</span><br><span class="line">    randomIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (len - index)) + index;</span><br><span class="line"></span><br><span class="line">    temp = arr[index];</span><br><span class="line">    arr[index] = arr[randomIndex];</span><br><span class="line">    arr[randomIndex] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> length = array.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; length - <span class="number">1</span>; index++) &#123;</span><br><span class="line">    <span class="keyword">let</span> randomIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (length - index)) + index;</span><br><span class="line"></span><br><span class="line">    [array[index], array[randomIndex]] = [array[randomIndex], array[index]];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://gaohaoyang.github.io/2016/10/16/shuffle-algorithm/#top" target="_blank" rel="noopener">《Fisher and Yates 的原始版》</a><br><a href="https://www.zhihu.com/question/32303195" target="_blank" rel="noopener">《javascript 实现数组随机排序?》</a><br><a href="https://www.w3cplus.com/javascript/how-to-randomize-shuffle-a-javascript-array.html" target="_blank" rel="noopener">《JavaScript 学习笔记：数组随机排序》</a></p>
<h3 id="javascript-创建对象的几种方式？"><a href="#javascript-创建对象的几种方式？" class="headerlink" title="javascript 创建对象的几种方式？"></a>javascript 创建对象的几种方式？</h3><p>我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是我们可以使用函数来进行模拟，从而产生出可复用的对象<br>创建方式，我了解到的方式有这么几种：</p>
<p>（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。</p>
<p>（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。</p>
<p>（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。</p>
<p>（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。</p>
<p>（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。</p>
<p>（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。</p>
<p>嗯我目前了解到的就是这么几种方式。</p>
<p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA.html" target="_blank" rel="noopener">《JavaScript 深入理解之对象创建》</a></p>
<h3 id="JavaScript-继承的几种实现方式？"><a href="#JavaScript-继承的几种实现方式？" class="headerlink" title="JavaScript 继承的几种实现方式？"></a>JavaScript 继承的几种实现方式？</h3><p>我了解的 js 中实现继承的几种方式有：</p>
<p>（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。</p>
<p>（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。</p>
<p>（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。</p>
<p>（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。</p>
<p>（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。</p>
<p>（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</p>
<p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E7%BB%A7%E6%89%BF.html" target="_blank" rel="noopener">《JavaScript 深入理解之继承》</a></p>
<h3 id="寄生式组合继承的实现？"><a href="#寄生式组合继承的实现？" class="headerlink" title="寄生式组合继承的实现？"></a>寄生式组合继承的实现？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"My name is "</span> + <span class="keyword">this</span>.name + <span class="string">"."</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, grade</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype = <span class="built_in">Object</span>.create(Person.prototype);</span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line">Student.prototype.sayMyGrade = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"My grade is "</span> + <span class="keyword">this</span>.grade + <span class="string">"."</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Javascript-的作用域链？"><a href="#Javascript-的作用域链？" class="headerlink" title="Javascript 的作用域链？"></a>Javascript 的作用域链？</h3><p>作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。</p>
<p>作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</p>
<p>当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。</p>
<p>作用域链的创建过程跟执行上下文的建立有关….</p>
<p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.html" target="_blank" rel="noopener">《JavaScript 深入理解之作用域链》</a></p>
<h3 id="谈谈-This-对象的理解。"><a href="#谈谈-This-对象的理解。" class="headerlink" title="谈谈 This 对象的理解。"></a>谈谈 This 对象的理解。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。</span><br></pre></td></tr></table></figure>

<p>1.第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。</p>
<p>2.第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。</p>
<p>3.第三种是构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。</p>
<p>4.第四种是 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这四种方式，使用构造器调用模式的优先级最高，然后是 apply 、 call 和 bind 调用模式，然后是方法调用模式，然后</span><br><span class="line">是函数调用模式。</span><br></pre></td></tr></table></figure>

<p><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8Bthis%E8%AF%A6%E8%A7%A3.html" target="_blank" rel="noopener">《JavaScript 深入理解之 this 详解》</a></p>
<h3 id="eval-是做什么的？"><a href="#eval-是做什么的？" class="headerlink" title="eval 是做什么的？"></a>eval 是做什么的？</h3><p>它的功能是把对应的字符串解析成 JS 代码并运行。</p>
<p>应该避免使用 eval，不安全，非常耗性能（2次，一次解析成 js 语句，一次执行）。</p>
<p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval" target="_blank" rel="noopener">《eval()》</a></p>
<h3 id="什么是-DOM-和-BOM？"><a href="#什么是-DOM-和-BOM？" class="headerlink" title="什么是 DOM 和 BOM？"></a>什么是 DOM 和 BOM？</h3><p>DOM 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。</p>
<p>BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。</p>
<p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/33453164" target="_blank" rel="noopener">《DOM, DOCUMENT, BOM, WINDOW 有什么区别?》</a><br><a href="http://www.w3school.com.cn/jsref/dom_obj_window.asp" target="_blank" rel="noopener">《Window 对象》</a><br><a href="https://www.zhihu.com/question/20724662" target="_blank" rel="noopener">《DOM 与 BOM 分别是什么，有何关联？》</a><br><a href="https://segmentfault.com/a/1190000000654274#articleHeader21" target="_blank" rel="noopener">《JavaScript 学习总结（三）BOM 和 DOM 详解》</a></p>
<h3 id="写一个通用的事件侦听器函数。"><a href="#写一个通用的事件侦听器函数。" class="headerlink" title="写一个通用的事件侦听器函数。"></a>写一个通用的事件侦听器函数。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventUtils = &#123;</span><br><span class="line">  <span class="comment">// 视能力分别使用dom0||dom2||IE方式 来绑定事件</span></span><br><span class="line">  <span class="comment">// 添加事件</span></span><br><span class="line">  addEvent: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">      element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">      element.attachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">"on"</span> + type] = handler;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除事件</span></span><br><span class="line">  removeEvent: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">      element.removeEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">      element.detachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">"on"</span> + type] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取事件目标</span></span><br><span class="line">  getTarget: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event.target || event.srcElement;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event</span></span><br><span class="line">  getEvent: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event || <span class="built_in">window</span>.event;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获）</span></span><br><span class="line">  stopPropagation: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.stopPropagation) &#123;</span><br><span class="line">      event.stopPropagation();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消事件的默认行为</span></span><br><span class="line">  preventDefault: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.preventDefault) &#123;</span><br><span class="line">      event.preventDefault();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.returnValue = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000006934031#articleHeader6" target="_blank" rel="noopener">《JS 事件模型》</a></p>
<h3 id="事件是什么？IE-与火狐的事件机制有什么区别？-如何阻止冒泡？"><a href="#事件是什么？IE-与火狐的事件机制有什么区别？-如何阻止冒泡？" class="headerlink" title="事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？"></a>事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？</h3><p>1.事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。</p>
<p>2.事件处理机制：IE 支持事件冒泡、Firefox 同时支持两种事件模型，也就是：事件冒泡和事件捕获。</p>
<p>3.event.stopPropagation() 或者 ie 下的方法 event.cancelBubble = true;</p>
<p>详细资料可以参考：<br><a href="https://www.cnblogs.com/lvdabao/p/3265870.html" target="_blank" rel="noopener">《Javascript 事件模型系列（一）事件及事件的三种模型》</a><br><a href="https://blog.csdn.net/wuseyukui/article/details/13771493" target="_blank" rel="noopener">《Javascript 事件模型：事件捕获和事件冒泡》</a></p>
<h3 id="三种事件模型是什么？"><a href="#三种事件模型是什么？" class="headerlink" title="三种事件模型是什么？"></a>三种事件模型是什么？</h3><p>事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。</p>
<p>第一种事件模型是最早的 DOM0 级模型，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实<br>现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。这种方式是所有浏览器都兼容的。</p>
<p>第二种事件模型是 IE 事件模型，在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。</p>
<p>第三种是 DOM2 级事件模型，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。</p>
<p>详细资料可以参考：<br><a href="https://blog.csdn.net/u013217071/article/details/77613706" target="_blank" rel="noopener">《一个 DOM 元素绑定多个事件时，先执行冒泡还是捕获》</a></p>
<h3 id="事件委托是什么？"><a href="#事件委托是什么？" class="headerlink" title="事件委托是什么？"></a>事件委托是什么？</h3><p>事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。</p>
<p>使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。</p>
<p>详细资料可以参考：<br><a href="https://zhuanlan.zhihu.com/p/26536815" target="_blank" rel="noopener">《JavaScript 事件委托详解》</a></p>
<h3 id="“1”-“2”-“3”-map-parseInt-答案是多少？"><a href="#“1”-“2”-“3”-map-parseInt-答案是多少？" class="headerlink" title="[“1”, “2”, “3”].map(parseInt) 答案是多少？"></a>[“1”, “2”, “3”].map(parseInt) 答案是多少？</h3><p>parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)，其中 radix 表示要解析的数字的基数。（该值介于 2 ~ 36 之间，并且字符串中的数字不能大于 radix 才能正确返回数字结果值）。</p>
<p>此处 map 传了 3 个参数 (element, index, array)，默认第三个参数被忽略掉，因此三次传入的参数分别为 “1-0”, “2-1”, “3-2”</p>
<p>因为字符串的值不能大于基数，因此后面两次调用均失败，返回 NaN ，第一次基数为 0 ，按十进制解析返回 1。</p>
<p>详细资料可以参考：<br><a href="https://blog.csdn.net/justjavac/article/details/19473199" target="_blank" rel="noopener">《为什么 [“1”, “2”, “3”].map(parseInt) 返回 [1,NaN,NaN]？》</a></p>
<h3 id="什么是闭包，为什么要用它？"><a href="#什么是闭包，为什么要用它？" class="headerlink" title="什么是闭包，为什么要用它？"></a>什么是闭包，为什么要用它？</h3><p>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。</p>
<p>闭包有两个常用的用途。</p>
<p>闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</p>
<p>函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</p>
<p>其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。</p>
<p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E9%97%AD%E5%8C%85.html" target="_blank" rel="noopener">《JavaScript 深入理解之闭包》</a></p>
<h3 id="javascript-代码中的-“use-strict”-是什么意思-使用它区别是什么？"><a href="#javascript-代码中的-“use-strict”-是什么意思-使用它区别是什么？" class="headerlink" title="javascript 代码中的 “use strict”; 是什么意思 ? 使用它区别是什么？"></a>javascript 代码中的 “use strict”; 是什么意思 ? 使用它区别是什么？</h3><p>use strict 是一种 ECMAscript5 添加的（严格）运行模式，这种模式使得 Javascript 在更严格的条件下运行。</p>
<p>设立”严格模式”的目的，主要有以下几个：</p>
<ul>
<li>消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;</li>
<li>消除代码运行的一些不安全之处，保证代码运行的安全；</li>
<li>提高编译器效率，增加运行速度；</li>
<li>为未来新版本的 Javascript 做好铺垫。</li>
</ul>
<p>区别：</p>
<ul>
<li>1.禁止使用 with 语句。</li>
<li>2.禁止 this 关键字指向全局对象。</li>
<li>3.对象不能有重名的属性。</li>
</ul>
<p>回答：</p>
<p>use strict 指的是严格运行模式，在这种模式对 js 的使用添加了一些限制。比如说禁止 this 指向全局对象，还有禁止使用 with 语句等。设立严格模式的目的，主要是为了消除代码使用中的一些不安全的使用方式，也是为了消除 js 语法本身的一些不合理的地方，以此来减少一些运行时的怪异的行为。同时使用严格运行模式也能够提高编译的效率，从而提高代码的运行速度。<br>我认为严格模式代表了 js 一种更合理、更安全、更严谨的发展方向。</p>
<p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html" target="_blank" rel="noopener">《Javascript 严格模式详解》</a></p>
<h3 id="如何判断一个对象是否属于某个类？"><a href="#如何判断一个对象是否属于某个类？" class="headerlink" title="如何判断一个对象是否属于某个类？"></a>如何判断一个对象是否属于某个类？</h3><p>第一种方式是使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p>
<p>第二种方式可以通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。</p>
<p>第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断。</p>
<p>详细资料可以参考：<br><a href="https://blog.csdn.net/haitunmin/article/details/78418522" target="_blank" rel="noopener">《js 判断一个对象是否属于某一类》</a></p>
<h3 id="instanceof-的作用？"><a href="#instanceof-的作用？" class="headerlink" title="instanceof 的作用？"></a>instanceof 的作用？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</span></span><br><span class="line"><span class="comment">// 实现：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> proto = <span class="built_in">Object</span>.getPrototypeOf(left), <span class="comment">// 获取对象的原型</span></span><br><span class="line">    prototype = right.prototype; <span class="comment">// 获取构造函数的 prototype 对象</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断构造函数的 prototype 对象是否在对象的原型链上</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!proto) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (proto === prototype) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    proto = <span class="built_in">Object</span>.getPrototypeOf(proto);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof" target="_blank" rel="noopener">《instanceof》</a></p>
<h3 id="new-操作符具体干了什么呢？如何实现？"><a href="#new-操作符具体干了什么呢？如何实现？" class="headerlink" title="new 操作符具体干了什么呢？如何实现？"></a>new 操作符具体干了什么呢？如何实现？</h3><p>（1）首先创建了一个新的空对象<br>（2）设置原型，将对象的原型设置为函数的 prototype 对象。<br>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）<br>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">constructor</span> = Array.prototype.shift.call(arguments),</span><br><span class="line">    result = null;</span><br><span class="line"></span><br><span class="line">  // 参数判断</span><br><span class="line">  if (typeof <span class="keyword">constructor</span> !== "function") &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"type error"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span></span><br><span class="line">  newObject = <span class="built_in">Object</span>.create(<span class="keyword">constructor</span>.prototype);</span><br><span class="line"></span><br><span class="line">  // 将 this 指向新建对象，并执行函数</span><br><span class="line">  result = <span class="keyword">constructor</span>.apply(newObject, arguments);</span><br><span class="line"></span><br><span class="line">  // 判断返回对象</span><br><span class="line">  let flag =</span><br><span class="line">    result &amp;&amp; (typeof result === "object" || typeof result === "function");</span><br><span class="line"></span><br><span class="line">  // 判断返回结果</span><br><span class="line">  return flag ? result : newObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用方法</span><br><span class="line">// objectFactory(构造函数, 初始化参数);</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000008576048" target="_blank" rel="noopener">《new 操作符具体干了什么？》</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/13" target="_blank" rel="noopener">《JavaScript 深入之 new 的模拟实现》</a></p>
<h3 id="Javascript-中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？"><a href="#Javascript-中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？" class="headerlink" title="Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？"></a>Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hasOwnProperty</span><br><span class="line"></span><br><span class="line">所有继承了 Object 的对象都会继承到 hasOwnProperty 方法。这个方法可以用来检测一个对象是否含有特定的自身属性，和in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty" target="_blank" rel="noopener">《Object.prototype.hasOwnProperty()》</a></p>
<h3 id="对于-JSON-的了解？"><a href="#对于-JSON-的了解？" class="headerlink" title="对于 JSON 的了解？"></a>对于 JSON 的了解？</h3><p>相关知识点：</p>
<p>JSON 是一种数据交换格式，基于文本，优于轻量，用于交换数据。</p>
<p>JSON 可以表示数字、布尔值、字符串、null、数组（值的有序序列），以及由这些值（或数组、对象）所组成的对象（字符串与值的映射）。</p>
<p>JSON 使用 JavaScript 语法，但是 JSON 格式仅仅是一个文本。文本可以被任何编程语言读取及作为数据格式传递。</p>
<p>回答：</p>
<p>JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。</p>
<p>在项目开发中，我们使用 JSON 作为前后端数据交换的方式。在前端我们通过将一个符合 JSON 格式的数据结构序列化为 JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。</p>
<p>因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是我们应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。</p>
<p>在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，一个是 JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，我们可以调用这个函数将数据对象转化为 JSON 格式的字符串。</p>
<p>另一个函数 JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当我们从后端接收到 JSON 格式的字符串时，我们可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。</p>
<p>详细资料可以参考：<br><a href="https://my.oschina.net/u/3284240/blog/874368" target="_blank" rel="noopener">《深入了解 JavaScript 中的 JSON 》</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[].forEach.call($$(&quot;*&quot;),function(a)&#123;a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16)&#125;)`</span><br></pre></td></tr></table></figure>

<h3 id="能解释一下这段代码的意思吗？"><a href="#能解释一下这段代码的意思吗？" class="headerlink" title="能解释一下这段代码的意思吗？"></a>能解释一下这段代码的意思吗？</h3><p>（1）选取页面所有 DOM 元素。在浏览器的控制台中可以使用$$()方法来获取页面中相应的元素，这是现代浏览器提供的一个命令行 API 相当于 document.querySelectorAll 方法。</p>
<p>（2）循环遍历 DOM 元素</p>
<p>（3）给元素添加 outline 。由于渲染的 outline 是不在 CSS 盒模型中的，所以为元素添加 outline 并不会影响元素的大小和页面的布局。</p>
<p>（4）生成随机颜色函数。Math.random()*(1&lt;&lt;24) 可以得到 0~2^24 - 1 之间的随机数，因为得到的是一个浮点数，但我们只需要整数部分，使用取反操作符 ~ 连续两次取反获得整数部分，然后再用 toString(16) 的方式，转换为一个十六进制的字符串。</p>
<p>详细资料可以参考：<br><a href="https://2008winstar.iteye.com/blog/2128290" target="_blank" rel="noopener">《通过一行代码学 JavaScript》</a></p>
<h3 id="js-延迟加载的方式有哪些？"><a href="#js-延迟加载的方式有哪些？" class="headerlink" title="js 延迟加载的方式有哪些？"></a>js 延迟加载的方式有哪些？</h3><p>js 延迟加载，也就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度。</p>
<p>一般有以下几种方式：</p>
<ul>
<li>defer 属性</li>
<li>async 属性</li>
<li>动态创建 DOM 方式</li>
<li>使用 setTimeout 延迟方法</li>
<li>让 JS 最后加载</li>
</ul>
<p>回答：</p>
<p>js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。</p>
<p>我了解到的几种方式是：</p>
<p>第一种方式是我们一般采用的是将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</p>
<p>第二种方式是给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</p>
<p>第三种方式是给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</p>
<p>第四种方式是动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</p>
<p>详细资料可以参考：<br><a href="https://blog.csdn.net/meijory/article/details/76389762" target="_blank" rel="noopener">《JS 延迟加载的几种方式》</a><br><a href="http://www.w3school.com.cn/html5/att_script_async.asp" target="_blank" rel="noopener">《HTML 5 <code>&lt;script&gt;</code> <code>async</code> 属性》</a></p>
<h3 id="Ajax-是什么-如何创建一个-Ajax？"><a href="#Ajax-是什么-如何创建一个-Ajax？" class="headerlink" title="Ajax 是什么? 如何创建一个 Ajax？"></a>Ajax 是什么? 如何创建一个 Ajax？</h3><p>相关知识点：</p>
<p>2005 年 2 月，AJAX 这个词第一次正式提出，它是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</p>
<p>具体来说，AJAX 包括以下几个步骤。</p>
<p>1.创建 XMLHttpRequest 对象，也就是创建一个异步调用对象</p>
<p>2.创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息</p>
<p>3.设置响应 HTTP 请求状态变化的函数</p>
<p>4.发送 HTTP 请求</p>
<p>5.获取异步调用返回的数据</p>
<p>6.使用 JavaScript 和 DOM 实现局部刷新</p>
<p>一般实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SERVER_URL = <span class="string">"/server"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Http 请求</span></span><br><span class="line">xhr.open(<span class="string">"GET"</span>, SERVER_URL, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 设置状态监听函数</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.readyState !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 当请求成功时</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">    handle(<span class="keyword">this</span>.response);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="keyword">this</span>.statusText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置请求失败时的监听函数</span></span><br><span class="line">xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="keyword">this</span>.statusText);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置请求头信息</span></span><br><span class="line">xhr.responseType = <span class="string">"json"</span>;</span><br><span class="line">xhr.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送 Http 请求</span></span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// promise 封装实现：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJSON</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个 promise 对象</span></span><br><span class="line">  <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建一个 http 请求</span></span><br><span class="line">    xhr.open(<span class="string">"GET"</span>, url, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置状态的监听函数</span></span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.readyState !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当请求成功或失败时，改变 promise 的状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(<span class="keyword">this</span>.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置错误监听函数</span></span><br><span class="line">    xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置响应的数据类型</span></span><br><span class="line">    xhr.responseType = <span class="string">"json"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置请求头信息</span></span><br><span class="line">    xhr.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送 http 请求</span></span><br><span class="line">    xhr.send(<span class="literal">null</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<p>我对 ajax 的理解是，它是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。</p>
<p>创建一个 ajax 有这样几个步骤</p>
<p>首先是创建一个 XMLHttpRequest 对象。</p>
<p>然后在这个对象上使用 open 方法创建一个 http 请求，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</p>
<p>在发起请求前，我们可以为这个对象添加一些信息和监听函数。比如说我们可以通过 setRequestHeader 方法来为请求添加头信息。我们还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，我们可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候我们可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候我们就可以通过 response 中的数据来对页面进行更新了。</p>
<p>当对象的属性和监听函数设置完成后，最后我们调用 sent 方法来向服务器发起请求，可以传入参数作为发送的数据体。</p>
<p>详细资料可以参考：<br><a href="https://wangdoc.com/javascript/bom/xmlhttprequest.html" target="_blank" rel="noopener">《XMLHttpRequest 对象》</a><br><a href="https://juejin.im/post/5acde23c5188255cb32e7e76" target="_blank" rel="noopener">《从 ajax 到 fetch、axios》</a><br><a href="https://juejin.im/post/5c160937f265da61180199b2" target="_blank" rel="noopener">《Fetch 入门》</a><br><a href="https://segmentfault.com/a/1190000003810652" target="_blank" rel="noopener">《传统 Ajax 已死，Fetch 永生》</a></p>
<h3 id="谈一谈浏览器的缓存机制？"><a href="#谈一谈浏览器的缓存机制？" class="headerlink" title="谈一谈浏览器的缓存机制？"></a>谈一谈浏览器的缓存机制？</h3><p>浏览器的缓存机制指的是通过在一段时间内保留已接收到的 web 资源的一个副本，如果在资源的有效时间内，发起了对这个资源的再一次请求，那么浏览器会直接使用缓存的副本，而不是向服务器发起请求。使用 web 缓存可以有效地提高页面的打开速度，减少不必要的网络带宽的消耗。</p>
<p>web 资源的缓存策略一般由服务器来指定，可以分为两种，分别是强缓存策略和协商缓存策略。</p>
<p>使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。</p>
<p>服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。</p>
<p>Expires 是 http1.0 中的方式，因为它的一些缺点，在 http 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，常用的比如我们可以通过设置 max-age 来指定资源能够被缓存的时间的大小，这是一个相对的时间，它会根据这个时间的大小和资源第一次请求时的时间来计算出资源过期的时间，因此相对于 Expires来说，这种方式更加有效一些。常用的还有比如 private ，用来规定资源只能被客户端缓存，不能够代理服务器所缓存。还有如 no-store ，用来指定资源不能够被缓存，no-cache 代表该资源能够被缓存，但是立即失效，每次都需要向服务器发起请求。</p>
<p>一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires 。</p>
<p>使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。<br>如果资源发生了修改，则返回修改后的资源。协商缓存也可以通过两种方式来设置，分别是 http 头信息中的 Etag 和 Last-Modified 属性。</p>
<p>服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，<br>这样会造成缓存命中的不准确。</p>
<p>因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。</p>
<p>当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。</p>
<p>强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。</p>
<p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000012573337" target="_blank" rel="noopener">《浅谈浏览器缓存》</a><br><a href="https://juejin.im/post/5b9346dcf265da0aac6fbe57#heading-3" target="_blank" rel="noopener">《前端优化：浏览器缓存技术介绍》</a><br><a href="https://www.web-tinker.com/article/21221.html" target="_blank" rel="noopener">《请求头中的 Cache-Control》</a><br><a href="https://juejin.im/post/5c2d6c9ae51d450cf4195a08" target="_blank" rel="noopener">《Cache-Control 字段值详解》</a></p>
<h3 id="Ajax-解决浏览器缓存问题？"><a href="#Ajax-解决浏览器缓存问题？" class="headerlink" title="Ajax 解决浏览器缓存问题？"></a>Ajax 解决浏览器缓存问题？</h3><p>1.在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(“If-Modified-Since”,”0”)。</p>
<p>2.在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(“Cache-Control”,”no-cache”)。</p>
<p>3.在 URL 后面加上一个随机数： “fresh=” + Math.random();。</p>
<p>4.在 URL 后面加上时间戳：”nowtime=” + new Date().getTime();。</p>
<p>5.如果是使用 jQuery，直接这样就可以了$.ajaxSetup({cache:false})。这样页面的所有 ajax 都会执行这条语句就是不需要保存缓存记录。</p>
<p>详细资料可以参考：<br><a href="https://www.cnblogs.com/cwzqianduan/p/8632009.html" target="_blank" rel="noopener">《Ajax 中浏览器的缓存问题解决方法》</a><br><a href="https://segmentfault.com/a/1190000012573337" target="_blank" rel="noopener">《浅谈浏览器缓存》</a></p>
<h3 id="同步和异步的区别？"><a href="#同步和异步的区别？" class="headerlink" title="同步和异步的区别？"></a>同步和异步的区别？</h3><p>同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是处于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。  </p>
<p>异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。 </p>
<p>回答：</p>
<p>同步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。</p>
<p>异步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理。</p>
<p>详细资料可以参考：<br><a href="https://blog.csdn.net/tennysonsky/article/details/45111623" target="_blank" rel="noopener">《同步和异步的区别》</a></p>
<h3 id="什么是浏览器的同源政策？"><a href="#什么是浏览器的同源政策？" class="headerlink" title="什么是浏览器的同源政策？"></a>什么是浏览器的同源政策？</h3><p>我对浏览器的同源政策的理解是，一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容。这里的同源的指的是两个域的协议、域名、端口号必须相同，否则则不属于同一个域。</p>
<p>同源政策主要限制了三个方面</p>
<p>第一个是当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。</p>
<p>第二个是当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。</p>
<p>第三个是当前域下 ajax 无法发送跨域请求。</p>
<p>同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。</p>
<h3 id="如何解决跨域问题？"><a href="#如何解决跨域问题？" class="headerlink" title="如何解决跨域问题？"></a>如何解决跨域问题？</h3><p>相关知识点：</p>
<ol>
<li><p>通过 jsonp 跨域</p>
</li>
<li><p>document.domain + iframe 跨域</p>
</li>
<li><p>location.hash + iframe</p>
</li>
<li><p>window.name + iframe 跨域</p>
</li>
<li><p>postMessage 跨域</p>
</li>
<li><p>跨域资源共享（CORS)</p>
</li>
<li><p>nginx 代理跨域</p>
</li>
<li><p>nodejs 中间件代理跨域</p>
</li>
<li><p>WebSocket 协议跨域</p>
</li>
</ol>
<p>回答：</p>
<p>解决跨域的方法我们可以根据我们想要实现的目的来划分。</p>
<p>首先我们如果只是想要实现主域名下的不同子域名的跨域操作，我们可以使用设置 document.domain 来解决。</p>
<p>（1）将 document.domain 设置为主域名，来实现相同子域名的跨域操作，这个时候主域名下的 cookie 就能够被子域名所访问。同时如果文档中含有主域名相同，子域名不同的 iframe 的话，我们也可以对这个 iframe 进行操作。</p>
<p>如果是想要解决不同跨域窗口间的通信问题，比如说一个页面想要和页面的中的不同源的 iframe 进行通信的问题，我们可以使用 location.hash 或者 window.name 或者 postMessage 来解决。</p>
<p>（2）使用 location.hash 的方法，我们可以在主页面动态的修改 iframe 窗口的 hash 值，然后在 iframe 窗口里实现监听函数来实现这样一个单向的通信。因为在 iframe 是没有办法访问到不同源的父级窗口的，所以我们不能直接修改父级窗口的 hash 值来实现通信，我们可以在 iframe 中再加入一个 iframe ，这个 iframe 的内容是和父级页面同源的，所以我们可以 window.parent.parent 来修改最顶级页面的 src，以此来实现双向通信。</p>
<p>（3）使用 window.name 的方法，主要是基于同一个窗口中设置了 window.name 后不同源的页面也可以访问，所以不同源的子页面可以首先在 window.name 中写入数据，然后跳转到一个和父级同源的页面。这个时候级页面就可以访问同源的子页面中 window.name 中的数据了，这种方式的好处是可以传输的数据量大。</p>
<p>（4）使用 postMessage 来解决的方法，这是一个 h5 中新增的一个 api。通过它我们可以实现多窗口间的信息传递，通过获取到指定窗口的引用，然后调用 postMessage 来发送信息，在窗口中我们通过对 message 信息的监听来接收信息，以此来实现不同源间的信息交换。</p>
<p>如果是像解决 ajax 无法提交跨域请求的问题，我们可以使用 jsonp、cors、websocket 协议、服务器代理来解决问题。</p>
<p>（5）使用 jsonp 来实现跨域请求，它的主要原理是通过动态构建 script  标签来实现跨域请求，因为浏览器对 script 标签的引入没有跨域的访问限制 。通过在请求的 url 后指定一个回调函数，然后服务器在返回数据的时候，构建一个 json 数据的包装，这个包装就是回调函数，然后返回给前端，前端接收到数据后，因为请求的是脚本文件，所以会直接执行，这样我们先前定义好的回调函数就可以被调用，从而实现了跨域请求的处理。这种方式只能用于 get 请求。</p>
<p>（6）使用 CORS 的方式，CORS 是一个 W3C 标准，全称是”跨域资源共享”。CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，因此我们只需要在服务器端配置就行。浏览器将 CORS 请求分成两类：简单请求和非简单请求。对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是会在头信息之中，增加一个 Origin 字段。Origin 字段用来说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。对于如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，ajax 不会收到响应信息。如果成功的话会包含一些以 Access-Control- 开头的字段。</p>
<p>非简单请求，浏览器会先发出一次预检请求，来判断该域名是否在服务器的白名单中，如果收到肯定回复后才会发起请求。</p>
<p>（7）使用 websocket 协议，这个协议没有同源限制。</p>
<p>（8）使用服务器来代理跨域的访问请求，就是有跨域的请求操作时发送请求给后端，让后端代为请求，然后最后将获取的结果发返回。</p>
<p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000011145364" target="_blank" rel="noopener">《前端常见跨域解决方案（全）》</a><br><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">《浏览器同源政策及其规避方法》</a><br><a href="https://juejin.im/entry/59feae9df265da43094488f6" target="_blank" rel="noopener">《跨域，你需要知道的全在这里》</a><br><a href="https://www.zhihu.com/question/31592553" target="_blank" rel="noopener">《为什么 form 表单提交没有跨域问题，但 ajax 提交有跨域问题？》</a></p>
<h3 id="服务器代理转发时，该如何处理-cookie？"><a href="#服务器代理转发时，该如何处理-cookie？" class="headerlink" title="服务器代理转发时，该如何处理 cookie？"></a>服务器代理转发时，该如何处理 cookie？</h3><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/5eab0f83e3b4" target="_blank" rel="noopener">《深入浅出 Nginx》</a></p>
<h3 id="模块化开发怎么做？"><a href="#模块化开发怎么做？" class="headerlink" title="模块化开发怎么做？"></a>模块化开发怎么做？</h3><p>我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，js 只实现一些简单的功能，所以并没有模块的概念，但随着程序越来越复杂，代码的模块化开发变得越来越重要。</p>
<p>由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污染，并且模块间没有联系。</p>
<p>后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所有的所有的模块成员，外部代码可以修改内部属性的值。</p>
<p>现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。</p>
<p>详细资料可以参考：<br><a href="https://juejin.im/post/5ab378c46fb9a028ce7b824f" target="_blank" rel="noopener">《浅谈模块化开发》</a><br><a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank" rel="noopener">《Javascript 模块化编程（一）：模块的写法》</a><br><a href="https://juejin.im/post/5aaa37c8f265da23945f365c" target="_blank" rel="noopener">《前端模块化：CommonJS，AMD，CMD，ES6》</a><br><a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">《Module 的语法》</a></p>
<h3 id="js-的几种模块规范？"><a href="#js-的几种模块规范？" class="headerlink" title="js 的几种模块规范？"></a>js 的几种模块规范？</h3><p>js 中现在比较成熟的有四种模块加载方案。</p>
<p>第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。</p>
<p>第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。</p>
<p>第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和 require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。参考60</p>
<p>第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。这种方案和上面三种方案都不同。参考 61。</p>
<h3 id="AMD-和-CMD-规范的区别？"><a href="#AMD-和-CMD-规范的区别？" class="headerlink" title="AMD 和 CMD 规范的区别？"></a>AMD 和 CMD 规范的区别？</h3><p>它们之间的主要区别有两个方面。</p>
<p>（1）第一个方面是在模块定义时对依赖的处理不同。AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。</p>
<p>（2）第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CMD</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">"./a"</span>);</span><br><span class="line">  a.doSomething();</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">"./b"</span>); <span class="comment">// 依赖可以就近书写</span></span><br><span class="line">  b.doSomething();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// AMD 默认推荐</span></span><br><span class="line">define([<span class="string">"./a"</span>, <span class="string">"./b"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 依赖必须一开始就写好</span></span><br><span class="line">  a.doSomething();</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  b.doSomething();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://juejin.im/post/5a422b036fb9a045211ef789" target="_blank" rel="noopener">《前端模块化，AMD 与 CMD 的区别》</a></p>
<h3 id="ES6-模块与-CommonJS-模块、AMD、CMD-的差异。"><a href="#ES6-模块与-CommonJS-模块、AMD、CMD-的差异。" class="headerlink" title="ES6 模块与 CommonJS 模块、AMD、CMD 的差异。"></a>ES6 模块与 CommonJS 模块、AMD、CMD 的差异。</h3><p>1.CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</p>
<p>2.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>
<h3 id="requireJS-的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何-缓存的？）"><a href="#requireJS-的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何-缓存的？）" class="headerlink" title="requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）"></a>requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）</h3><p>require.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。</p>
<p>详细资料可以参考：<br><a href="https://github.com/HRFE/blog/issues/10" target="_blank" rel="noopener">《requireJS 的用法和原理分析》</a><br><a href="https://zhuanlan.zhihu.com/p/55039478" target="_blank" rel="noopener">《requireJS 的核心原理是什么？》</a><br><a href="https://www.cnblogs.com/dong-xu/p/7160919.html" target="_blank" rel="noopener">《从 RequireJs 源码剖析脚本加载原理》</a><br><a href="https://www.jianshu.com/p/5a39535909e4" target="_blank" rel="noopener">《requireJS 原理分析》</a></p>
<h3 id="JS-模块加载器的轮子怎么造，也就是如何实现一个模块加载器？"><a href="#JS-模块加载器的轮子怎么造，也就是如何实现一个模块加载器？" class="headerlink" title="JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？"></a>JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？</h3><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/21157540" target="_blank" rel="noopener">《JS 模块加载器加载原理是怎么样的？》</a></p>
<h3 id="ECMAScript6-怎么写-class，为什么会出现-class-这种东西"><a href="#ECMAScript6-怎么写-class，为什么会出现-class-这种东西" class="headerlink" title="ECMAScript6 怎么写 class，为什么会出现 class 这种东西?"></a>ECMAScript6 怎么写 class，为什么会出现 class 这种东西?</h3><p>在我看来 ES6 新添加的 class 只是为了补充 js 中缺少的一些面向对象语言的特性，但本质上来说它只是一种语法糖，不是一个新的东西，其背后还是原型继承的思想。通过加入 class 可以有利于我们更好的组织代码。</p>
<p>在 class 中添加的方法，其实是添加在类的原型上的。</p>
<p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/29789315" target="_blank" rel="noopener">《ECMAScript 6 实现了 class，对 JavaScript 前端开发有什么意义？》</a><br><a href="http://es6.ruanyifeng.com/#docs/class" target="_blank" rel="noopener">《Class 的基本语法》</a></p>
<h3 id="documen-write-和-innerHTML-的区别？"><a href="#documen-write-和-innerHTML-的区别？" class="headerlink" title="documen.write 和 innerHTML 的区别？"></a>documen.write 和 innerHTML 的区别？</h3><p>document.write 的内容会代替整个文档内容，会重写整个页面。</p>
<p>innerHTML 的内容只是替代指定元素的内容，只会重写页面中的部分内容。</p>
<p>详细资料可以参考：<br><a href="https://www.nowcoder.com/questionTerminal/2c5d8105b2694d85b06eff85e871cf50" target="_blank" rel="noopener">《简述 document.write 和 innerHTML 的区别。》</a></p>
<h3 id="DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？"><a href="#DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？" class="headerlink" title="DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？"></a>DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</h3><p>（1）创建新节点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">createDocumentFragment(node);</span><br><span class="line">createElement(node);</span><br><span class="line">createTextNode(text);</span><br></pre></td></tr></table></figure>

<p>（2）添加、移除、替换、插入</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">appendChild(node)</span><br><span class="line">removeChild(node)</span><br><span class="line">replaceChild(<span class="keyword">new</span>,old)</span><br><span class="line">insertBefore(<span class="keyword">new</span>,old)</span><br></pre></td></tr></table></figure>

<p>（3）查找</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getElementById();</span><br><span class="line">getElementsByName();</span><br><span class="line">getElementsByTagName();</span><br><span class="line">getElementsByClassName();</span><br><span class="line">querySelector();</span><br><span class="line">querySelectorAll();</span><br></pre></td></tr></table></figure>

<p>（4）属性操作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getAttribute(key);</span><br><span class="line">setAttribute(key, value);</span><br><span class="line">hasAttribute(key);</span><br><span class="line">removeAttribute(key);</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Introduction#DOM_interfaces" target="_blank" rel="noopener">《DOM 概述》</a><br><a href="https://harttle.land/2015/10/01/javascript-dom-api.html" target="_blank" rel="noopener">《原生 JavaScript 的 DOM 操作汇总》</a><br><a href="https://microzz.com/2017/04/06/jsdom/" target="_blank" rel="noopener">《原生 JS 中 DOM 节点相关 API 合集》</a></p>
<h3 id="innerHTML-与-outerHTML-的区别？"><a href="#innerHTML-与-outerHTML-的区别？" class="headerlink" title="innerHTML 与 outerHTML 的区别？"></a>innerHTML 与 outerHTML 的区别？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对于这样一个 HTML 元素：&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;。</span><br><span class="line"></span><br><span class="line">innerHTML：内部 HTML，content&lt;br/&gt;；</span><br><span class="line">outerHTML：外部 HTML，&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;；</span><br><span class="line">innerText：内部文本，content ；</span><br><span class="line">outerText：内部文本，content ；</span><br></pre></td></tr></table></figure>

<h3 id="call-和-apply-的区别？"><a href="#call-和-apply-的区别？" class="headerlink" title=".call() 和 .apply() 的区别？"></a>.call() 和 .apply() 的区别？</h3><p>它们的作用一模一样，区别仅在于传入参数的形式的不同。</p>
<p>apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。</p>
<p>call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</p>
<p>详细资料可以参考：<br><a href="https://juejin.im/entry/58d0a7b22f301e007e5a15ae" target="_blank" rel="noopener">《apply、call 的区别和用途》</a></p>
<h3 id="JavaScript-类数组对象的定义？"><a href="#JavaScript-类数组对象的定义？" class="headerlink" title="JavaScript 类数组对象的定义？"></a>JavaScript 类数组对象的定义？</h3><p>一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。</p>
<p>常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length属性值，代表可接收的参数个数。</p>
<p>常见的类数组转换为数组的方法有这样几种：</p>
<p>（1）通过 call 调用数组的 slice 方法来实现转换</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.call(arrayLike);</span><br></pre></td></tr></table></figure>

<p>（2）通过 call 调用数组的 splice 方法来实现转换</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.splice.call(arrayLike, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>（3）通过 apply 调用数组的 concat 方法来实现转换</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.concat.apply([], arrayLike);</span><br></pre></td></tr></table></figure>

<p>（4）通过 Array.from 方法来实现转换</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike);</span><br></pre></td></tr></table></figure>

<p>详细的资料可以参考：<br><a href="https://github.com/mqyqingfeng/Blog/issues/14" target="_blank" rel="noopener">《JavaScript 深入之类数组对象与 arguments》</a><br><a href="https://segmentfault.com/a/1190000000415572" target="_blank" rel="noopener">《javascript 类数组》</a><br><a href="https://blog.lxxyx.cn/2016/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E7%B1%BB%E6%95%B0%E7%BB%84/" target="_blank" rel="noopener">《深入理解 JavaScript 类数组》</a></p>
<h3 id="数组和对象有哪些原生方法，列举一下？"><a href="#数组和对象有哪些原生方法，列举一下？" class="headerlink" title="数组和对象有哪些原生方法，列举一下？"></a>数组和对象有哪些原生方法，列举一下？</h3><p>数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。</p>
<p>数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。</p>
<p>数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</p>
<p>数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。</p>
<p>数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。</p>
<p>数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法</p>
<p>数组归并方法 reduce() 和 reduceRight() 方法</p>
<p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8BArray%E8%AF%A6%E8%A7%A3.html" target="_blank" rel="noopener">《JavaScript 深入理解之 Array 类型详解》</a></p>
<h3 id="数组的-fill-方法？"><a href="#数组的-fill-方法？" class="headerlink" title="数组的 fill 方法？"></a>数组的 fill 方法？</h3><p>fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。<br>fill 方法接受三个参数 value，start 以及 end，start 和 end 参数是可选的，其默认值分别为 0 和 this 对象的 length 属性值。</p>
<p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill" target="_blank" rel="noopener">《Array.prototype.fill()》</a></p>
<h3 id="的长度？"><a href="#的长度？" class="headerlink" title="[,,,] 的长度？"></a>[,,,] 的长度？</h3><p>尾后逗号 （有时叫做“终止逗号”）在向 JavaScript 代码添加元素、参数、属性时十分有用。如果你想要添加新的属性，并且上一行已经使用了尾后逗号，你可以仅仅添加新的一行，而不需要修改上一行。这使得版本控制更加清晰，以及代码维护麻烦更少。</p>
<p>JavaScript 一开始就支持数组字面值中的尾后逗号，随后向对象字面值（ECMAScript 5）中添加了尾后逗号。最近（ECMAScript 2017），又将其添加到函数参数中。但是 JSON 不支持尾后逗号。</p>
<p>如果使用了多于一个尾后逗号，会产生间隙。 带有间隙的数组叫做稀疏数组（密致数组没有间隙）。稀疏数组的长度为逗号的数量。</p>
<p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Trailing_commas" target="_blank" rel="noopener">《尾后逗号》</a></p>
<h3 id="JavaScript-中的作用域与变量声明提升？"><a href="#JavaScript-中的作用域与变量声明提升？" class="headerlink" title="JavaScript 中的作用域与变量声明提升？"></a>JavaScript 中的作用域与变量声明提升？</h3><p>变量提升的表现是，无论我们在函数中何处位置声明的变量，好像都被提升到了函数的首部，我们可以在变量声明前访问到而不会报错。</p>
<p>造成变量声明提升的本质原因是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当我们访问一个变量时，我们会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。这就是会出现变量声明提升的根本原因。</p>
<p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1.html" target="_blank" rel="noopener">《JavaScript 深入理解之变量对象》</a></p>
<h3 id="如何编写高性能的-Javascript-？"><a href="#如何编写高性能的-Javascript-？" class="headerlink" title="如何编写高性能的 Javascript ？"></a>如何编写高性能的 Javascript ？</h3><p>1.使用位运算代替一些简单的四则运算。</p>
<p>2.避免使用过深的嵌套循环。</p>
<p>3.不要使用未定义的变量。</p>
<p>4.当需要多次访问数组长度时，可以用变量保存起来，避免每次都会去进行属性查找。</p>
<p>详细资料可以参考：<br><a href="https://zhuanlan.zhihu.com/p/34780474" target="_blank" rel="noopener">《如何编写高性能的 Javascript？》</a></p>
<h3 id="简单介绍一下-V8-引擎的垃圾回收机制"><a href="#简单介绍一下-V8-引擎的垃圾回收机制" class="headerlink" title="简单介绍一下 V8 引擎的垃圾回收机制"></a>简单介绍一下 V8 引擎的垃圾回收机制</h3><p>v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。</p>
<p>新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。</p>
<p>新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：</p>
<p>（1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。</p>
<p>（2）如果对象不存活，则释放对象的空间。</p>
<p>（3）最后将 From 空间和 To 空间角色进行交换。</p>
<p>新生代对象晋升到老生代有两个条件：</p>
<p>（1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。</p>
<p>（2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。</p>
<p>老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。</p>
<p>由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。</p>
<p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/b8ed21e8a4fb" target="_blank" rel="noopener">《深入理解 V8 的垃圾回收原理》</a><br><a href="https://zhuanlan.zhihu.com/p/23992332" target="_blank" rel="noopener">《JavaScript 中的垃圾回收》</a></p>
<h3 id="哪些操作会造成内存泄漏？"><a href="#哪些操作会造成内存泄漏？" class="headerlink" title="哪些操作会造成内存泄漏？"></a>哪些操作会造成内存泄漏？</h3><p>相关知识点：</p>
<p>1.意外的全局变量</p>
<p>2.被遗忘的计时器或回调函数</p>
<p>3.脱离 DOM 的引用</p>
<p>4.闭包</p>
<p>回答：</p>
<p>第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</p>
<p>第二种情况是我们设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</p>
<p>第三种情况是我们获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。</p>
<p>第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</p>
<p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html" target="_blank" rel="noopener">《JavaScript 内存泄漏教程》</a><br><a href="https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/" target="_blank" rel="noopener">《4 类 JavaScript 内存泄漏及如何避免》</a><br><a href="https://juejin.im/entry/5a64366c6fb9a01c9332c706" target="_blank" rel="noopener">《杜绝 js 中四种内存泄漏类型的发生》</a><br><a href="https://segmentfault.com/a/1190000008901861" target="_blank" rel="noopener">《javascript 典型内存泄漏及 chrome 的排查方法》</a></p>
<h3 id="如何做到修改url参数页面不刷新"><a href="#如何做到修改url参数页面不刷新" class="headerlink" title="如何做到修改url参数页面不刷新"></a>如何做到修改url参数页面不刷新</h3><p>HTML5引入了 <code>history.pushState()</code> 和 <code>history.replaceState()</code> 方法，它们分别可以添加和修改历史记录条目。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stateObj = &#123;</span><br><span class="line">    foo: <span class="string">"bar"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">history.pushState(stateObj, <span class="string">"page 2"</span>, <span class="string">"bar.html"</span>);</span><br></pre></td></tr></table></figure>

<p>假设当前页面为 <code>foo.html</code>，执行上述代码后会变为 <code>bar.html</code>，点击浏览器后退，会变为 <code>foo.html</code>，但浏览器并不会刷新。<br><code>pushState()</code> 需要三个参数: 一个状态对象, 一个标题 (目前被忽略), 和 (可选的) 一个 URL. 让我们来解释下这三个参数详细内容：</p>
<ul>
<li>状态对象 — 状态对象 <code>state</code> 是一个 JavaScript 对象，通过 <code>pushState ()</code> 创建新的历史记录条目。无论什么时候用户导航到新的状态，<code>popstate</code> 事件就会被触发，且该事件的 <code>state</code> 属性包含该历史记录条目状态对象的副本。<br>状态对象可以是能被序列化的任何东西。原因在于 Firefox 将状态对象保存在用户的磁盘上，以便在用户重启浏览器时使用，我们规定了状态对象在序列化表示后有640k的大小限制。如果你给 <code>pushState()</code> 方法传了一个序列化后大于 640k 的状态对象，该方法会抛出异常。如果你需要更大的空间，建议使用 <code>sessionStorage</code> 以及 <code>localStorage</code>.</li>
<li>标题 — Firefox 目前忽略这个参数，但未来可能会用到。传递一个空字符串在这里是安全的，而在将来这是不安全的。二选一的话，你可以为跳转的 <code>state</code> 传递一个短标题。</li>
<li>URL — 该参数定义了新的历史URL记录。注意，调用 <code>pushState()</code> 后浏览器并不会立即加载这个 URL，但可能会在稍后某些情况下加载这个 URL，比如在用户重新打开浏览器时。新URL不必须为绝对路径。如果新URL是相对路径，那么它将被作为相对于当前 URL 处理。新 URL 必须与当前URL同源，否则 <code>pushState()</code> 会抛出一个异常。该参数是可选的，缺省为当前 URL。</li>
</ul>
<h3 id="需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？"><a href="#需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？" class="headerlink" title="需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？"></a>需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？</h3><p>通过使用 pushState + ajax 实现浏览器无刷新前进后退，当一次 ajax 调用成功后我们将一条 state 记录加入到 history对象中。一条 state 记录包含了 url、title 和 content 属性，在 popstate 事件中可以获取到这个 state 对象，我们可以使用 content 来传递数据。最后我们通过对 window.onpopstate 事件监听来响应浏览器的前进后退操作。</p>
<p>使用 pushState 来实现有两个问题，一个是打开首页时没有记录，我们可以使用 replaceState 来将首页的记录替换，另一个问题是当一个页面刷新的时候，仍然会向服务器端请求数据，因此如果请求的 url 需要后端的配合将其重定向到一个页面。</p>
<p>详细资料可以参考：<br><a href="http://blog.chenxu.me/post/detail?id=ed4f0732-897f-48e4-9d4f-821e82f17fad" target="_blank" rel="noopener">《pushState + ajax 实现浏览器无刷新前进后退》</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History_API" target="_blank" rel="noopener">《Manipulating the browser history》</a></p>
<h3 id="如何判断当前脚本运行在浏览器还是-node-环境中？（阿里）"><a href="#如何判断当前脚本运行在浏览器还是-node-环境中？（阿里）" class="headerlink" title="如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）"></a>如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeof window === &apos;undefined&apos; ? &apos;node&apos; : &apos;browser&apos;;</span><br><span class="line"></span><br><span class="line">通过判断当前环境的 window 对象类型是否为 undefined，如果是undefined，则说明当前脚本运行在node环境，否则说明运行在window环境。</span><br></pre></td></tr></table></figure>

<h3 id="把-script-标签放在页面的最底部的-body-封闭之前和封闭之后有什么区别？浏览器会如何解析它们？"><a href="#把-script-标签放在页面的最底部的-body-封闭之前和封闭之后有什么区别？浏览器会如何解析它们？" class="headerlink" title="把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？"></a>把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？</h3><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/20027966" target="_blank" rel="noopener">《为什么把 script 标签放在 body 结束标签之后 html 结束标签之前？》</a><br><a href="https://zhuanlan.zhihu.com/p/30558018" target="_blank" rel="noopener">《从 Chrome 源码看浏览器如何加载资源》</a></p>
<h3 id="移动端的点击事件的有延迟，时间是多久，为什么会有？-怎么解决这个延时？"><a href="#移动端的点击事件的有延迟，时间是多久，为什么会有？-怎么解决这个延时？" class="headerlink" title="移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？"></a>移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？</h3><p>移动端点击有 300ms 的延迟是因为移动端会有双击缩放的这个操作，因此浏览器在 click 之后要等待 300ms，看用户有没有下一次点击，来判断这次操作是不是双击。</p>
<p>有三种办法来解决这个问题：</p>
<ul>
<li>1.通过 meta 标签禁用网页的缩放。</li>
<li>2.通过 meta 标签将网页的 viewport 设置为 ideal viewport。</li>
<li>3.调用一些 js 库，比如 FastClick</li>
</ul>
<p>click 延时问题还可能引起点击穿透的问题，就是如果我们在一个元素上注册了 touchStart 的监听事件，这个事件会将这个元素隐藏掉，我们发现当这个元素隐藏后，触发了这个元素下的一个元素的点击事件，这就是点击穿透。</p>
<p>详细资料可以参考：<br><a href="https://juejin.im/post/5b3cc9836fb9a04f9a5cb0e0" target="_blank" rel="noopener">《移动端 300ms 点击延迟和点击穿透》</a></p>
<h3 id="什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？"><a href="#什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？" class="headerlink" title="什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？"></a>什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？</h3><p>（1）什么是前端路由？</p>
<p>前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前是通过服务端根据 url 的不同返回不同的页面实现的。</p>
<p>（2）什么时候使用前端路由？</p>
<p>在单页面应用，大部分页面结构不变，只改变部分内容的使用</p>
<p>（3）前端路由有什么优点和缺点？</p>
<p>优点：用户体验好，不需要每次都从服务器全部获取，快速展现给用户</p>
<p>缺点：单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置</p>
<p>前端路由一共有两种实现方式，一种是通过 hash 的方式，一种是通过使用 pushState 的方式。</p>
<p>详细资料可以参考：<br><a href="https://segmentfault.com/q/1010000005336260" target="_blank" rel="noopener">《什么是“前端路由”》</a><br><a href="https://github.com/kaola-fed/blog/issues/137" target="_blank" rel="noopener">《浅谈前端路由》 </a><br><a href="https://www.zhihu.com/question/53064386" target="_blank" rel="noopener">《前端路由是什么东西？》</a></p>
<h3 id="如何测试前端代码么？-知道-BDD-TDD-Unit-Test-么？-知道怎么测试你的前端工程么-mocha-sinon-jasmin-qUnit-？"><a href="#如何测试前端代码么？-知道-BDD-TDD-Unit-Test-么？-知道怎么测试你的前端工程么-mocha-sinon-jasmin-qUnit-？" class="headerlink" title="如何测试前端代码么？ 知道 BDD, TDD, Unit Test 么？ 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)？"></a>如何测试前端代码么？ 知道 BDD, TDD, Unit Test 么？ 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)？</h3><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b2da89cf265da597f1c7cab" target="_blank" rel="noopener">《浅谈前端单元测试》</a></p>
<h3 id="检测浏览器版本版本有哪些方式？"><a href="#检测浏览器版本版本有哪些方式？" class="headerlink" title="检测浏览器版本版本有哪些方式？"></a>检测浏览器版本版本有哪些方式？</h3><p>检测浏览器版本一共有两种方式：</p>
<p>一种是检测 window.navigator.userAgent 的值，但这种方式很不可靠，因为 userAgent 可以被改写，并且早期的浏览器如 ie，会通过伪装自己的 userAgent 的值为 Mozilla 来躲过服务器的检测。</p>
<p>第二种方式是功能检测，根据每个浏览器独有的特性来进行判断，如 ie 下独有的 ActiveXObject。</p>
<p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/d99f4ca385ac" target="_blank" rel="noopener">《JavaScript 判断浏览器类型》</a></p>
<h3 id="什么是-Polyfill-？"><a href="#什么是-Polyfill-？" class="headerlink" title="什么是 Polyfill ？"></a>什么是 Polyfill ？</h3><p>Polyfill 指的是用于实现浏览器并不支持的原生 API 的代码。</p>
<p>比如说 querySelectorAll 是很多现代浏览器都支持的原生 Web API，但是有些古老的浏览器并不支持，那么假设有人写了一段代码来实现这个功能使这些浏览器也支持了这个功能，那么这就可以成为一个 Polyfill。</p>
<p>一个 shim 是一个库，有自己的 API，而不是单纯实现原生不支持的 API。</p>
<p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000002593432" target="_blank" rel="noopener">《Web 开发中的“黑话”》</a><br><a href="https://juejin.im/post/5a579bc7f265da3e38496ba1" target="_blank" rel="noopener">《Polyfill 为何物》</a></p>
<h3 id="使用-JS-实现获取文件扩展名？"><a href="#使用-JS-实现获取文件扩展名？" class="headerlink" title="使用 JS 实现获取文件扩展名？"></a>使用 JS 实现获取文件扩展名？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String.lastIndexOf() 方法返回指定值（本例中的'.'）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于 'filename' 和 '.hiddenfile' ，lastIndexOf 的返回值分别为 0 和 -1 无符号右移操作符(&gt;&gt;&gt;) 将 -1 转换为 4294967295 ，将 -2 转换为 4294967294 ，这个方法可以保证边缘情况时文件名不变。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为""。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFileExtension</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> filename.slice(((filename.lastIndexOf(<span class="string">"."</span>) - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">0</span>) + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000004993946" target="_blank" rel="noopener">《如何更有效的获取文件扩展名》</a></p>
<h3 id="介绍一下-js-的节流与防抖？"><a href="#介绍一下-js-的节流与防抖？" class="headerlink" title="介绍一下 js 的节流与防抖？"></a>介绍一下 js 的节流与防抖？</h3><p>函数防抖： 在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。</p>
<p>函数节流： 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数防抖的实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span>,</span><br><span class="line">      args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果此时存在定时器的话，则取消之前的定时器重新记时</span></span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置定时器，使事件间隔指定事件后执行</span></span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数节流的实现;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> preTime = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span>,</span><br><span class="line">      args = <span class="built_in">arguments</span>,</span><br><span class="line">      nowTime = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果两次时间间隔超过了指定时间，则执行函数。</span></span><br><span class="line">    <span class="keyword">if</span> (nowTime - preTime &gt;= delay) &#123;</span><br><span class="line">      preTime = <span class="built_in">Date</span>.now();</span><br><span class="line">      <span class="keyword">return</span> fn.apply(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<p>函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</p>
<p>函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</p>
<p>详细资料可以参考：<br><a href="https://juejin.im/post/5a35ed25f265da431d3cc1b1" target="_blank" rel="noopener">《轻松理解 JS 函数节流和函数防抖》</a><br><a href="https://juejin.im/post/5aa60b0e518825556b6c6d1a" target="_blank" rel="noopener">《JavaScript 事件节流和事件防抖》</a><br><a href="https://juejin.im/entry/5b1d2d54f265da6e2545bfa4" target="_blank" rel="noopener">《JS 的防抖与节流》</a></p>
<h3 id="Object-is-与原来的比较操作符-“-”、“-”-的区别？"><a href="#Object-is-与原来的比较操作符-“-”、“-”-的区别？" class="headerlink" title="Object.is() 与原来的比较操作符 “===”、“==” 的区别？"></a>Object.is() 与原来的比较操作符 “===”、“==” 的区别？</h3><p>相关知识点：</p>
<p>两等号判等，会在比较时进行类型转换。<br>三等号判等（判断严格），比较时不进行隐式类型转换，（类型不同则会返回false）。</p>
<p>Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 Object.is(NaN, NaN) 会返回 true.</p>
<p>Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。</p>
<p>回答：</p>
<p>使用双等号进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。</p>
<p>使用三等号进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。</p>
<p>使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 认定为是相等的。</p>
<h3 id="escape-encodeURI-encodeURIComponent-有什么区别？"><a href="#escape-encodeURI-encodeURIComponent-有什么区别？" class="headerlink" title="escape,encodeURI,encodeURIComponent 有什么区别？"></a>escape,encodeURI,encodeURIComponent 有什么区别？</h3><p>相关知识点：</p>
<p>escape 和 encodeURI 都属于 Percent-encoding，基本功能都是把 URI 非法字符转化成合法字符，转化后形式类似「%*」。<br>它们的根本区别在于，escape 在处理 0xff 之外字符的时候，是直接使用字符的 unicode 在前面加上一个「%u」，而 encode URI 则是先进行 UTF-8，再在 UTF-8 的每个字节码前加上一个「%」；在处理 0xff 以内字符时，编码方式是一样的（都是「%XX」，XX 为字符的 16 进制 unicode，同时也是字符的 UTF-8），只是范围（即哪些字符编码哪些字符不编码）不一样。</p>
<p>回答：</p>
<p>encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。</p>
<p>encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。</p>
<p>escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。</p>
<p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/21861899" target="_blank" rel="noopener">《escape,encodeURI,encodeURIComponent 有什么区别?》</a></p>
<h3 id="Unicode-和-UTF-8-之间的关系？"><a href="#Unicode-和-UTF-8-之间的关系？" class="headerlink" title="Unicode 和 UTF-8 之间的关系？"></a>Unicode 和 UTF-8 之间的关系？</h3><p>Unicode 是一种字符集合，现在可容纳 100 多万个字符。每个字符对应一个不同的 Unicode 编码，它只规定了符号的二进制代码，却没有规定这个二进制代码在计算机中如何编码传输。</p>
<p>UTF-8 是一种对 Unicode 的编码方式，它是一种变长的编码方式，可以用 1~4 个字节来表示一个字符。</p>
<p>详细资料可以参考：<br><a href="https://blog.51cto.com/polaris/377468" target="_blank" rel="noopener">《字符编码详解》</a><br><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">《字符编码笔记：ASCII，Unicode 和 UTF-8》</a></p>
<h3 id="js-中的深浅拷贝实现？"><a href="#js-中的深浅拷贝实现？" class="headerlink" title="js 中的深浅拷贝实现？"></a>js 中的深浅拷贝实现？</h3><p>相关资料：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝的实现;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 只拷贝对象</span></span><br><span class="line">  <span class="keyword">if</span> (!object || <span class="keyword">typeof</span> object !== <span class="string">"object"</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据 object 的类型判断是新建一个数组还是对象</span></span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="built_in">Array</span>.isArray(object) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历 object，并且判断是 object 的属性才拷贝</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObject[key] = object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深拷贝的实现;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!object || <span class="keyword">typeof</span> object !== <span class="string">"object"</span>) <span class="keyword">return</span> object;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="built_in">Array</span>.isArray(object) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObject[key] = deepCopy(object[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<p>浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用  Object.assign 和展开运算符来实现。</p>
<p>深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败。</p>
<p>详细资料可以参考：<br><a href="https://github.com/mqyqingfeng/Blog/issues/32" target="_blank" rel="noopener">《JavaScript 专题之深浅拷贝》</a><br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bed40d951882545f73004f6" target="_blank" rel="noopener">《前端面试之道》</a></p>
<h3 id="手写-call、apply-及-bind-函数"><a href="#手写-call、apply-及-bind-函数" class="headerlink" title="手写 call、apply 及 bind 函数"></a>手写 call、apply 及 bind 函数</h3><p>相关资料：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call函数实现</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断调用对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"type error"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>),</span><br><span class="line">    result = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 context 是否传入，如果未传入则设置为 window</span></span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将调用函数设为对象的方法</span></span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用函数</span></span><br><span class="line">  result = context.fn(...args);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// apply 函数实现</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Error"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 context 是否存在，如果未传入则为 window</span></span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将函数设为对象的方法</span></span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context.fn(...arguments[<span class="number">1</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.fn();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bind 函数实现</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Error"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>),</span><br><span class="line">    fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 根据调用方式，传入不同绑定值</span></span><br><span class="line">    <span class="keyword">return</span> fn.apply(</span><br><span class="line">      <span class="keyword">this</span> <span class="keyword">instanceof</span> Fn ? <span class="keyword">this</span> : context,</span><br><span class="line">      args.concat(...arguments)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<h4 id="call-函数的实现步骤："><a href="#call-函数的实现步骤：" class="headerlink" title="call 函数的实现步骤："></a>call 函数的实现步骤：</h4><p>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</p>
<p>2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。</p>
<p>3.处理传入的参数，截取第一个参数后的所有参数。</p>
<p>4.将函数作为上下文对象的一个属性。</p>
<p>5.使用上下文对象来调用这个方法，并保存返回结果。</p>
<p>6.删除刚才新增的属性。</p>
<p>7.返回结果。</p>
<h4 id="apply-函数的实现步骤："><a href="#apply-函数的实现步骤：" class="headerlink" title="apply 函数的实现步骤："></a>apply 函数的实现步骤：</h4><p>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</p>
<p>2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。</p>
<p>3.将函数作为上下文对象的一个属性。</p>
<p>4.判断参数值是否传入</p>
<p>4.使用上下文对象来调用这个方法，并保存返回结果。</p>
<p>5.删除刚才新增的属性</p>
<p>6.返回结果</p>
<h4 id="bind-函数的实现步骤："><a href="#bind-函数的实现步骤：" class="headerlink" title="bind 函数的实现步骤："></a>bind 函数的实现步骤：</h4><p>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</p>
<p>2.保存当前函数的引用，获取其余传入参数值。</p>
<p>3.创建一个函数返回</p>
<p>4.函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</p>
<p>详细资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdd0d8e6fb9a04a044073fe" target="_blank" rel="noopener">《手写 call、apply 及 bind 函数》</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/11" target="_blank" rel="noopener">《JavaScript 深入之 call 和 apply 的模拟实现》</a></p>
<h3 id="函数柯里化的实现"><a href="#函数柯里化的实现" class="headerlink" title="函数柯里化的实现"></a>函数柯里化的实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取函数需要的参数长度</span></span><br><span class="line">  <span class="keyword">let</span> length = fn.length;</span><br><span class="line"></span><br><span class="line">  args = args || [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> subArgs = args.slice(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接得到现有的所有参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">      subArgs.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断参数的长度是否已经满足函数所需参数的长度</span></span><br><span class="line">    <span class="keyword">if</span> (subArgs.length &gt;= length) &#123;</span><br><span class="line">      <span class="comment">// 如果满足，执行函数</span></span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, subArgs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果不满足，递归返回科里化的函数，等待参数的传入</span></span><br><span class="line">      <span class="keyword">return</span> curry.call(<span class="keyword">this</span>, fn, subArgs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6 实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fn.length &lt;= args.length ? fn(...args) : curry.bind(<span class="literal">null</span>, fn, ...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://github.com/mqyqingfeng/Blog/issues/42" target="_blank" rel="noopener">《JavaScript 专题之函数柯里化》</a></p>
<h3 id="为什么-0-1-0-2-0-3？如何解决这个问题？"><a href="#为什么-0-1-0-2-0-3？如何解决这个问题？" class="headerlink" title="为什么 0.1 + 0.2 != 0.3？如何解决这个问题？"></a>为什么 0.1 + 0.2 != 0.3？如何解决这个问题？</h3><p>当计算机计算 0.1+0.2 的时候，实际上计算的是这两个数字在计算机里所存储的二进制，0.1 和 0.2 在转换为二进制表示的时候会出现位数无限循环的情况。js 中是以 64 位双精度格式来存储数字的，只有 53 位的有效数字，超过这个长度的位数会被截取掉这样就造成了精度丢失的问题。这是第一个会造成精度丢失的地方。在对两个以 64 位双精度格式的数据进行计算的时候，首先会进行对阶的处理，对阶指的是将阶码对齐，也就是将小数点的位置对齐后，再进行计算，一般是小阶向大阶对齐，因此小阶的数在对齐的过程中，有效数字会向右移动，移动后超过有效位数的位会被截取掉，这是第二个可能会出现精度丢失的地方。当两个数据阶码对齐后，进行相加运算后，得到的结果可能会超过 53 位有效数字，因此超过的位数也会被截取掉，这是可能发生精度丢失的第三个地方。</p>
<p>对于这样的情况，我们可以将其转换为整数后再进行运算，运算后再转换为对应的小数，以这种方式来解决这个问题。</p>
<p>我们还可以将两个数相加的结果和右边相减，如果相减的结果小于一个极小数，那么我们就可以认定结果是相等的，这个极小数可以使用 es6 的 Number.EPSILON</p>
<p>详细资料可以参考：<br><a href="https://blog.csdn.net/Lixuanshengchao/article/details/82049191" target="_blank" rel="noopener">《十进制的 0.1 为什么不能用二进制很好的表示？》</a><br><a href="https://blog.csdn.net/zhengyanan815/article/details/78550073" target="_blank" rel="noopener">《十进制浮点数转成二进制》</a><br><a href="http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html" target="_blank" rel="noopener">《浮点数的二进制表示》</a><br><a href="https://juejin.im/post/5b372f106fb9a00e6714aa21" target="_blank" rel="noopener">《js 浮点数存储精度丢失原理》</a><br><a href="https://juejin.im/post/594a31d0a0bb9f006b0b2624" target="_blank" rel="noopener">《浮点数精度之谜》</a><br><a href="https://github.com/camsong/blog/issues/9" target="_blank" rel="noopener">《JavaScript 浮点数陷阱及解法》</a><br><a href="https://juejin.im/post/5bd2f10a51882555e072d0c4" target="_blank" rel="noopener">《0.1+0.2 !== 0.3？》</a><br><a href="https://juejin.im/entry/59cdd7fb6fb9a00a600f8eef" target="_blank" rel="noopener">《JavaScript 中奇特的~运算符》</a></p>
<h3 id="原码、反码和补码的介绍"><a href="#原码、反码和补码的介绍" class="headerlink" title="原码、反码和补码的介绍"></a>原码、反码和补码的介绍</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">原码是计算机中对数字的二进制的定点表示方法，最高位表示符号位，其余位表示数值位。优点是易于分辨，缺点是不能够直接参与运算。</span><br><span class="line"></span><br><span class="line">正数的反码和其原码一样；负数的反码，符号位为1，数值部分按原码取反。</span><br><span class="line">如 [+7]原 = 00000111，[+7]反 = 00000111； [-7]原 = 10000111，[-7]反 = 11111000。</span><br><span class="line"></span><br><span class="line">正数的补码和其原码一样；负数的补码为其反码加1。</span><br><span class="line"></span><br><span class="line">例如 [+7]原 = 00000111，[+7]反 = 00000111，[+7]补 = 00000111；</span><br><span class="line">[-7]原 = 10000111，[-7]反 = 11111000，[-7]补 = 11111001</span><br><span class="line"></span><br><span class="line">之所以在计算机中使用补码来表示负数的原因是，这样可以将加法运算扩展到所有的数值计算上，因此在数字电路中我们只需要考虑加法器的设计就行了，而不用再为减法设置新的数字电路。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2009/08/twos_complement.html" target="_blank" rel="noopener">《关于 2 的补码》</a></p>
<h3 id="toPrecision-和-toFixed-和-Math-round-的区别？"><a href="#toPrecision-和-toFixed-和-Math-round-的区别？" class="headerlink" title="toPrecision 和 toFixed 和 Math.round 的区别？"></a>toPrecision 和 toFixed 和 Math.round 的区别？</h3><p>toPrecision 用于处理精度，精度是从左至右第一个不为 0 的数开始数起。<br>toFixed 是对小数点后指定位数取整，从小数点开始数起。<br>Math.round 是将一个数字四舍五入到一个整数。</p>
<h3 id="什么是-requestAnimationFrame-？"><a href="#什么是-requestAnimationFrame-？" class="headerlink" title="什么是 requestAnimationFrame ？"></a>什么是 requestAnimationFrame ？</h3><p>详细资料可以参考：<br><a href="https://juejin.im/post/5a82f0626fb9a06358657c9c" target="_blank" rel="noopener">《你需要知道的 requestAnimationFrame》</a><br><a href="https://www.zhangxinxu.com/wordpress/2013/09/css3-animation-requestanimationframe-tween-%E5%8A%A8%E7%94%BB%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">《CSS3 动画那么强，requestAnimationFrame 还有毛线用？》</a></p>
<h3 id="offsetWidth-offsetHeight-clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别？"><a href="#offsetWidth-offsetHeight-clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别？" class="headerlink" title="offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别？"></a>offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别？</h3><p>clientWidth/clientHeight 返回的是元素的内部宽度，它的值只包含 content + padding，如果有滚动条，不包含滚动条。<br>clientTop 返回的是上边框的宽度。<br>clientLeft 返回的左边框的宽度。</p>
<p>offsetWidth/offsetHeight 返回的是元素的布局宽度，它的值包含 content + padding + border 包含了滚动条。<br>offsetTop 返回的是当前元素相对于其 offsetParent 元素的顶部的距离。<br>offsetLeft 返回的是当前元素相对于其 offsetParent 元素的左部的距离。</p>
<p>scrollWidth/scrollHeight 返回值包含 content + padding + 溢出内容的尺寸。<br>scrollTop 属性返回的是一个元素的内容垂直滚动的像素数。<br>scrollLeft 属性返回的是元素滚动条到元素左边的距离。</p>
<p>详细资料可以参考：<br><a href="https://juejin.im/post/5bc9366d5188255c4834e75a" target="_blank" rel="noopener">《最全的获取元素宽高及位置的方法》</a><br><a href="http://www.ruanyifeng.com/blog/2009/09/find_element_s_position_using_javascript.html" target="_blank" rel="noopener">《用 Javascript 获取页面元素的位置》</a></p>
<h3 id="谈一谈你理解的函数式编程？"><a href="#谈一谈你理解的函数式编程？" class="headerlink" title="谈一谈你理解的函数式编程？"></a>谈一谈你理解的函数式编程？</h3><p>简单说，”函数式编程”是一种”编程范式”（programming paradigm），也就是如何编写程序的方法论。</p>
<p>它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是”第一等公民”、只用”表达式”。</p>
<p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html" target="_blank" rel="noopener">《函数式编程初探》</a></p>
<h3 id="异步编程的实现方式？"><a href="#异步编程的实现方式？" class="headerlink" title="异步编程的实现方式？"></a>异步编程的实现方式？</h3><p>相关资料：</p>
<p>回调函数<br>优点：简单、容易理解<br>缺点：不利于维护，代码耦合高</p>
<p>事件监听（采用时间驱动模式，取决于某个事件是否发生）：<br>优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数<br>缺点：事件驱动型，流程不够清晰</p>
<p>发布/订阅（观察者模式）<br>类似于事件监听，但是可以通过‘消息中心’，了解现在有多少发布者，多少订阅者</p>
<p>Promise 对象<br>优点：可以利用 then 方法，进行链式写法；可以书写错误时的回调函数；<br>缺点：编写和理解，相对比较难</p>
<p>Generator 函数<br>优点：函数体内外的数据交换、错误处理机制<br>缺点：流程管理不方便</p>
<p>async 函数<br>优点：内置执行器、更好的语义、更广的适用性、返回的是 Promise、结构清晰。<br>缺点：错误处理机制</p>
<p>回答：</p>
<p>js 中的异步机制可以分为以下几种：</p>
<p>第一种最常见的是使用回调函数的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。</p>
<p>第二种是 Promise 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。</p>
<p>第三种是使用 generator 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部我们还可以将执行权转移回来。当我们遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕的时候我们再将执行权给转移回来。因此我们在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式我们需要考虑的问题是何时将函数的控制权转移回来，因此我们需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。</p>
<p>第四种是使用 async 函数的形式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此我们可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。</p>
<h3 id="Js-动画与-CSS-动画区别及相应实现"><a href="#Js-动画与-CSS-动画区别及相应实现" class="headerlink" title="Js 动画与 CSS 动画区别及相应实现"></a>Js 动画与 CSS 动画区别及相应实现</h3><p>CSS3 的动画的优点</p>
<p>在性能上会稍微好一些，浏览器会对 CSS3 的动画做一些优化<br>代码相对简单</p>
<p>缺点</p>
<p>在动画控制上不够灵活<br>兼容性不好</p>
<p>JavaScript 的动画正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容 IE6，并且功能强大。对于一些复杂控制的动画，使用 javascript 会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑 CSS 吧</p>
<h3 id="get-请求传参长度的误区"><a href="#get-请求传参长度的误区" class="headerlink" title="get 请求传参长度的误区"></a>get 请求传参长度的误区</h3><p>误区：我们经常说 get 请求参数的大小存在限制，而 post 请求的参数大小是无限制的。</p>
<p>实际上 HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对 get 请求参数的限制是来源与浏览器或web 服务器，浏览器或 web 服务器限制了 url 的长度。为了明确这个概念，我们必须再次强调下面几点:</p>
<p>1.HTTP 协议未规定 GET 和 POST 的长度限制</p>
<p>2.GET 的最大长度显示是因为浏览器和 web 服务器限制了 URI 的长度</p>
<p>3.不同的浏览器和 WEB 服务器，限制的最大长度不一样</p>
<p>4.要支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度 8182byte</p>
<h3 id="URL-和-URI-的区别？"><a href="#URL-和-URI-的区别？" class="headerlink" title="URL 和 URI 的区别？"></a>URL 和 URI 的区别？</h3><p>URI: Uniform Resource Identifier      指的是统一资源标识符<br>URL: Uniform Resource Location        指的是统一资源定位符<br>URN: Universal Resource Name          指的是统一资源名称</p>
<p>URI 指的是统一资源标识符，用唯一的标识来确定一个资源，它是一种抽象的定义，也就是说，不管使用什么方法来定义，只要能唯一的标识一个资源，就可以称为 URI。</p>
<p>URL 指的是统一资源定位符，URN 指的是统一资源名称。URL 和 URN 是 URI 的子集，URL 可以理解为使用地址来标识资源，URN 可以理解为使用名称来标识资源。</p>
<p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/21950864" target="_blank" rel="noopener">《HTTP 协议中 URI 和 URL 有什么区别？》</a><br><a href="http://web.jobbole.com/83452/" target="_blank" rel="noopener">《你知道 URL、URI 和 URN 三者之间的区别吗？》</a><br><a href="https://segmentfault.com/a/1190000006081973" target="_blank" rel="noopener">《URI、URL 和 URN 的区别》</a></p>
<h3 id="get-和-post-请求在缓存方面的区别"><a href="#get-和-post-请求在缓存方面的区别" class="headerlink" title="get 和 post 请求在缓存方面的区别"></a>get 和 post 请求在缓存方面的区别</h3><p>相关知识点：</p>
<p>get 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。</p>
<p>post 不同，post 做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此 get 请求适合于请求缓存。</p>
<p>回答：</p>
<p>缓存一般只适用于那些不会更新服务端数据的请求。一般 get 请求都是查找请求，不会对服务器资源数据造成修改，而 post 请求一般都会对服务器数据造成修改，所以，一般会对 get 请求进行缓存，很少会对 post 请求进行缓存。</p>
<p>详细资料可以参考：<br><a href="https://blog.csdn.net/qq_27093465/article/details/50479289" target="_blank" rel="noopener">《HTML 关于 post 和 get 的区别以及缓存问题的理解》</a></p>
<h3 id="图片的懒加载和预加载"><a href="#图片的懒加载和预加载" class="headerlink" title="图片的懒加载和预加载"></a>图片的懒加载和预加载</h3><p>相关知识点：</p>
<p>预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。</p>
<p>懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。</p>
<p>两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。 懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</p>
<p>回答：</p>
<p>懒加载也叫延迟加载，指的是在长网页中延迟加载图片的时机，当用户需要访问时，再去加载，这样可以提高网站的首屏加载速度，提升用户的体验，并且可以减少服务器的压力。它适用于图片很多，页面很长的电商网站的场景。懒加载的实现原理是，将页面上的图片的 src 属性设置为空字符串，将图片的真实路径保存在一个自定义属性中，当页面滚动的时候，进行判断，如果图片进入页面可视区域内，则从自定义属性中取出真实路径赋值给图片的 src 属性，以此来实现图片的延迟加载。</p>
<p>预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。通过预加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 scr 属性，来实现图片的预加载。</p>
<p>这两种方式都是提高网页性能的方式，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</p>
<p>详细资料可以参考：<br><a href="https://juejin.im/post/5b0c3b53f265da09253cbed0" target="_blank" rel="noopener">《懒加载和预加载》</a><br><a href="https://juejin.im/entry/5a73f38cf265da4e99575be3" target="_blank" rel="noopener">《网页图片加载优化方案》</a><br><a href="https://www.zhangxinxu.com/wordpress/2016/06/image-preload-based-on-user-behavior/" target="_blank" rel="noopener">《基于用户行为的图片等资源预加载》</a></p>
<h3 id="mouseover-和-mouseenter-的区别？"><a href="#mouseover-和-mouseenter-的区别？" class="headerlink" title="mouseover 和 mouseenter 的区别？"></a>mouseover 和 mouseenter 的区别？</h3><p>当鼠标移动到元素上时就会触发 mouseenter 事件，类似 mouseover，它们两者之间的差别是 mouseenter 不会冒泡。</p>
<p>由于 mouseenter 不支持事件冒泡，导致在一个元素的子元素上进入或离开的时候会触发其 mouseover 和 mouseout 事件，但是却不会触发 mouseenter 和 mouseleave 事件。</p>
<p>详细资料可以参考：<br><a href="https://github.com/qianlongo/zepto-analysis/issues/1" target="_blank" rel="noopener">《mouseenter 与 mouseover 为何这般纠缠不清？》</a></p>
<h3 id="js-拖拽功能的实现"><a href="#js-拖拽功能的实现" class="headerlink" title="js 拖拽功能的实现"></a>js 拖拽功能的实现</h3><p>相关知识点：</p>
<p>首先是三个事件，分别是 mousedown，mousemove，mouseup<br>当鼠标点击按下的时候，需要一个 tag 标识此时已经按下，可以执行 mousemove 里面的具体方法。<br>clientX，clientY 标识的是鼠标的坐标，分别标识横坐标和纵坐标，并且我们用 offsetX 和 offsetY 来表示<br>元素的元素的初始坐标，移动的举例应该是：<br>鼠标移动时候的坐标-鼠标按下去时候的坐标。<br>也就是说定位信息为：<br>鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的 offetLeft.</p>
<p>回答：</p>
<p>一个元素的拖拽过程，我们可以分为三个步骤，第一步是鼠标按下目标元素，第二步是鼠标保持按下的状态移动鼠标，第三步是鼠标抬起，拖拽过程结束。</p>
<p>这三步分别对应了三个事件，mousedown 事件，mousemove 事件和 mouseup 事件。只有在鼠标按下的状态移动鼠标我们才会执行拖拽事件，因此我们需要在 mousedown 事件中设置一个状态来标识鼠标已经按下，然后在 mouseup 事件中再取消这个状态。</p>
<p>在 mousedown 事件中我们首先应该判断，目标元素是否为拖拽元素，如果是拖拽元素，我们就设置状态并且保存这个时候鼠标的位置。</p>
<p>然后在 mousemove 事件中，我们通过判断鼠标现在的位置和以前位置的相对移动，来确定拖拽元素在移动中的坐标。需要通过 event.clientX 和 clientY 获取拖拽位置，并实时更新位置<br>最后 mouseup 事件触发后，清除状态，结束拖拽事件。（需要注意浏览器边界的情况）</p>
<p>详细资料可以参考：<br><a href="https://blog.csdn.net/LZGS_4/article/details/43523465" target="_blank" rel="noopener">《原生 js 实现拖拽功能基本思路》</a></p>
<h3 id="为什么使用-setTimeout-实现-setInterval？怎么模拟？"><a href="#为什么使用-setTimeout-实现-setInterval？怎么模拟？" class="headerlink" title="为什么使用 setTimeout 实现 setInterval？怎么模拟？"></a>为什么使用 setTimeout 实现 setInterval？怎么模拟？</h3><p>相关知识点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思路是使用递归函数，不断地去执行 setTimeout 从而达到 setInterval 的效果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mySetInterval</span>(<span class="params">fn, timeout</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 控制器，控制定时器是否继续执行</span></span><br><span class="line">  <span class="keyword">var</span> timer = &#123;</span><br><span class="line">    flag: <span class="literal">true</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置递归函数，模拟定时器执行。</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">interval</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer.flag) &#123;</span><br><span class="line">      fn();</span><br><span class="line">      setTimeout(interval, timeout);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动定时器</span></span><br><span class="line">  setTimeout(interval, timeout);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回控制器</span></span><br><span class="line">  <span class="keyword">return</span> timer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<p>setInterval 的作用是每隔一段指定时间执行一个函数，但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。</p>
<p>针对 setInterval 的这个缺点，我们可以使用 setTimeout 递归调用来模拟 setInterval，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 setInterval 的问题。</p>
<p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/32479bdfd851" target="_blank" rel="noopener">《用 setTimeout 实现 setInterval》</a><br><a href="https://zhuanlan.zhihu.com/p/51995737" target="_blank" rel="noopener">《setInterval 有什么缺点？》</a></p>
<h3 id="let-和-const-的注意点？"><a href="#let-和-const-的注意点？" class="headerlink" title="let 和 const 的注意点？"></a>let 和 const 的注意点？</h3><p>1.声明的变量只在声明时的代码块内有效</p>
<p>2.不存在声明提升</p>
<p>3.存在暂时性死区，如果在变量声明前使用，会报错</p>
<p>4.不允许重复声明，重复声明会报错</p>
<h3 id="什么是-rest-参数？"><a href="#什么是-rest-参数？" class="headerlink" title="什么是 rest 参数？"></a>什么是 rest 参数？</h3><p>rest 参数（形式为…变量名），用于获取函数的多余参数。</p>
<h3 id="什么是尾调用，使用尾调用有什么好处？"><a href="#什么是尾调用，使用尾调用有什么好处？" class="headerlink" title="什么是尾调用，使用尾调用有什么好处？"></a>什么是尾调用，使用尾调用有什么好处？</h3><p>尾调用指的是函数的最后一步调用另一个函数。我们代码执行是基于执行栈的，所以当我们在一个函数里调用另一个函数时，我们会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这个时候我们可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</p>
<h3 id="Symbol-类型的注意点？"><a href="#Symbol-类型的注意点？" class="headerlink" title="Symbol 类型的注意点？"></a>Symbol 类型的注意点？</h3><p>1.Symbol 函数前不能使用 new 命令，否则会报错。</p>
<p>2.Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>
<p>3.Symbol 作为属性名，该属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。</p>
<p>4.Object.getOwnPropertySymbols 方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p>
<p>5.Symbol.for 接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</p>
<p>6.Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key。</p>
<h3 id="Set-和-WeakSet-结构？"><a href="#Set-和-WeakSet-结构？" class="headerlink" title="Set 和 WeakSet 结构？"></a>Set 和 WeakSet 结构？</h3><p>1.ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<p>2.WeakSet 结构与 Set 类似，也是不重复的值的集合。但是 WeakSet 的成员只能是对象，而不能是其他类型的值。WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，</p>
<h3 id="Map-和-WeakMap-结构？"><a href="#Map-和-WeakMap-结构？" class="headerlink" title="Map 和 WeakMap 结构？"></a>Map 和 WeakMap 结构？</h3><p>1.Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</p>
<p>2.WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。</p>
<h3 id="Reflect-对象创建目的？"><a href="#Reflect-对象创建目的？" class="headerlink" title="Reflect 对象创建目的？"></a>Reflect 对象创建目的？</h3><p>1.将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty，放到 Reflect 对象上。</p>
<p>2.修改某些 Object 方法的返回结果，让其变得更合理。</p>
<p>3.让 Object 操作都变成函数行为。</p>
<p>4.Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为。</p>
<h3 id="require-模块引入的查找方式？"><a href="#require-模块引入的查找方式？" class="headerlink" title="require 模块引入的查找方式？"></a>require 模块引入的查找方式？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">当 Node 遇到 require(X) 时，按下面的顺序处理。</span><br><span class="line"></span><br><span class="line">（1）如果 X 是内置模块（比如 require(&apos;http&apos;)）</span><br><span class="line">　　a. 返回该模块。</span><br><span class="line">　　b. 不再继续执行。</span><br><span class="line"></span><br><span class="line">（2）如果 X 以 &quot;./&quot; 或者 &quot;/&quot; 或者 &quot;../&quot; 开头</span><br><span class="line">　　a. 根据 X 所在的父模块，确定 X 的绝对路径。</span><br><span class="line">　　b. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。</span><br><span class="line">    X</span><br><span class="line">    X.js</span><br><span class="line">    X.json</span><br><span class="line">    X.node</span><br><span class="line"></span><br><span class="line">　　c. 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。</span><br><span class="line">    X/package.json（main字段）</span><br><span class="line">    X/index.js</span><br><span class="line">    X/index.json</span><br><span class="line">    X/index.node</span><br><span class="line"></span><br><span class="line">（3）如果 X 不带路径</span><br><span class="line">　　a. 根据 X 所在的父模块，确定 X 可能的安装目录。</span><br><span class="line">　　b. 依次在每个目录中，将 X 当成文件名或目录名加载。</span><br><span class="line"></span><br><span class="line">（4）抛出 &quot;not found&quot;</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2015/05/require.html" target="_blank" rel="noopener">《require() 源码解读》</a></p>
<h3 id="什么是-Promise-对象，什么是-Promises-A-规范？"><a href="#什么是-Promise-对象，什么是-Promises-A-规范？" class="headerlink" title="什么是 Promise 对象，什么是 Promises/A+ 规范？"></a>什么是 Promise 对象，什么是 Promises/A+ 规范？</h3><p>Promise 对象是异步编程的一种解决方案，最早由社区提出。Promises/A+ 规范是 JavaScript Promise 的标准，规定了一个 Promise 所必须具有的特性。</p>
<p>Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是 pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者 rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。状态的改变是通过 resolve() 和 reject() 函数来实现的，我们可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。</p>
<p>详细资料可以参考：<br><a href="http://www.ituring.com.cn/article/66566" target="_blank" rel="noopener">《Promises/A+ 规范》</a><br><a href="http://es6.ruanyifeng.com/#docs/promise#Promise-resolve" target="_blank" rel="noopener">《Promise》</a></p>
<h3 id="手写一个-Promise"><a href="#手写一个-Promise" class="headerlink" title="手写一个 Promise"></a>手写一个 Promise</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">"pending"</span>;</span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">"resolved"</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">"rejected"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 保存初始化状态</span></span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化状态</span></span><br><span class="line">  <span class="keyword">this</span>.state = PENDING;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于保存 resolve 或者 rejected 传入的值</span></span><br><span class="line">  <span class="keyword">this</span>.value = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于保存 resolve 的回调函数</span></span><br><span class="line">  <span class="keyword">this</span>.resolvedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于保存 reject 的回调函数</span></span><br><span class="line">  <span class="keyword">this</span>.rejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 状态转变为 resolved 方法</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">      <span class="keyword">return</span> value.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证代码的执行顺序为本轮事件循环的末尾</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 只有状态为 pending 时才能转变，</span></span><br><span class="line">      <span class="keyword">if</span> (self.state === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 修改状态</span></span><br><span class="line">        self.state = RESOLVED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置传入的值</span></span><br><span class="line">        self.value = value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调函数</span></span><br><span class="line">        self.resolvedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">          callback(value);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 状态转变为 rejected 方法</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 保证代码的执行顺序为本轮事件循环的末尾</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 只有状态为 pending 时才能转变</span></span><br><span class="line">      <span class="keyword">if</span> (self.state === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 修改状态</span></span><br><span class="line">        self.state = REJECTED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置传入的值</span></span><br><span class="line">        self.value = value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调函数</span></span><br><span class="line">        self.rejectedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">          callback(value);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将两个方法传入函数执行</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fn(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// 遇到错误时，捕获错误，执行 reject 函数</span></span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 首先判断两个参数是否为函数类型，因为这两个参数是可选参数</span></span><br><span class="line">  onResolved =</span><br><span class="line">    <span class="keyword">typeof</span> onResolved === <span class="string">"function"</span></span><br><span class="line">      ? onResolved</span><br><span class="line">      : <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> value;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">  onRejected =</span><br><span class="line">    <span class="keyword">typeof</span> onRejected === <span class="string">"function"</span></span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">throw</span> error;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是等待状态，则将函数加入对应列表中</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">    <span class="keyword">this</span>.resolvedCallbacks.push(onResolved);</span><br><span class="line">    <span class="keyword">this</span>.rejectedCallbacks.push(onRejected);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果状态已经凝固，则直接执行对应状态的函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.state === RESOLVED) &#123;</span><br><span class="line">    onResolved(<span class="keyword">this</span>.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.state === REJECTED) &#123;</span><br><span class="line">    onRejected(<span class="keyword">this</span>.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="如何检测浏览器所支持的最小字体大小？"><a href="#如何检测浏览器所支持的最小字体大小？" class="headerlink" title="如何检测浏览器所支持的最小字体大小？"></a>如何检测浏览器所支持的最小字体大小？</h3><p>用 JS 设置 DOM 的字体为某一个值，然后再取出来，如果值设置成功，就说明支持。</p>
<h3 id="怎么做-JS-代码-Error-统计？"><a href="#怎么做-JS-代码-Error-统计？" class="headerlink" title="怎么做 JS 代码 Error 统计？"></a>怎么做 JS 代码 Error 统计？</h3><p>error 统计使用浏览器的 window.error 事件。</p>
<h3 id="单例模式模式是什么？"><a href="#单例模式模式是什么？" class="headerlink" title="单例模式模式是什么？"></a>单例模式模式是什么？</h3><p>单例模式保证了全局只有一个实例来被访问。比如说常用的如弹框组件的实现和全局状态的实现。</p>
<h3 id="策略模式是什么？"><a href="#策略模式是什么？" class="headerlink" title="策略模式是什么？"></a>策略模式是什么？</h3><p>策略模式主要是用来将方法的实现和方法的调用分离开，外部通过不同的参数可以调用不同的策略。我主要在 MVP 模式解耦的时候<br>用来将视图层的方法定义和方法调用分离。</p>
<h3 id="代理模式是什么？"><a href="#代理模式是什么？" class="headerlink" title="代理模式是什么？"></a>代理模式是什么？</h3><p> 代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。比如说常见的事件代理。</p>
<h3 id="中介者模式是什么？"><a href="#中介者模式是什么？" class="headerlink" title="中介者模式是什么？"></a>中介者模式是什么？</h3><p>中介者模式指的是，多个对象通过一个中介者进行交流，而不是直接进行交流，这样能够将通信的各个对象解耦。</p>
<h3 id="适配器模式是什么？"><a href="#适配器模式是什么？" class="headerlink" title="适配器模式是什么？"></a>适配器模式是什么？</h3><p>适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。假如我们需要一种<br>新的接口返回方式，但是老的接口由于在太多地方已经使用了，不能随意更改，这个时候就可以使用适配器模式。比如我们需要一种<br>自定义的时间返回格式，但是我们又不能对 js 时间格式化的接口进行修改，这个时候就可以使用适配器模式。</p>
<p>更多关于设计模式的资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc74186fb9a049ab0d0b6b" target="_blank" rel="noopener">《前端面试之道》</a><br><a href="https://juejin.im/post/59df4f74f265da430f311909#heading-3" target="_blank" rel="noopener">《JavaScript 设计模式》</a><br><a href="https://juejin.im/post/5afe6430518825428630bc4d" target="_blank" rel="noopener">《JavaScript 中常见设计模式整理》</a></p>
<h3 id="开发中常用的几种Content-Type-？"><a href="#开发中常用的几种Content-Type-？" class="headerlink" title="开发中常用的几种Content-Type ？"></a>开发中常用的几种Content-Type ？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">（1）application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL</span><br><span class="line">转码。</span><br><span class="line"></span><br><span class="line">（2）multipart/form-data</span><br><span class="line"></span><br><span class="line">该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。</span><br><span class="line"></span><br><span class="line">（3）application/json</span><br><span class="line"></span><br><span class="line">告诉服务器消息主体是序列化后的 JSON 字符串。</span><br><span class="line"></span><br><span class="line">（4）text/xml</span><br><span class="line"></span><br><span class="line">该种方式主要用来提交 XML 格式的数据。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://honglu.me/2015/07/13/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8DContent-Type/" target="_blank" rel="noopener">《常用的几种 Content-Type》</a></p>
<h3 id="如何确定页面的可用性时间，什么是-Performance-API？"><a href="#如何确定页面的可用性时间，什么是-Performance-API？" class="headerlink" title="如何确定页面的可用性时间，什么是 Performance API？"></a>如何确定页面的可用性时间，什么是 Performance API？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Performance API 用于精确度量、控制、增强浏览器的性能表现。这个 API 为测量网站性能，提供以前没有办法做到的精度。</span><br><span class="line"></span><br><span class="line">使用 getTime 来计算脚本耗时的缺点，首先，getTime方法（以及 Date 对象的其他方法）都只能精确到毫秒级别（一秒的千分之一），想要得到更小的时间差别就无能为力了。其次，这种写法只能获取代码运行过程中的时间进度，无法知道一些后台事件的时间进度，比如浏览器用了多少时间从服务器加载网页。</span><br><span class="line"></span><br><span class="line">为了解决这两个不足之处，ECMAScript 5引入“高精度时间戳”这个 API，部署在 performance 对象上。它的精度可以达到1毫秒的千分之一（1秒的百万分之一）。</span><br><span class="line"></span><br><span class="line">navigationStart：当前浏览器窗口的前一个网页关闭，发生 unload 事件时的 Unix 毫秒时间戳。如果没有前一个网页，则等于 fetchStart 属性。</span><br><span class="line"></span><br><span class="line">loadEventEnd：返回当前网页 load 事件的回调函数运行结束时的 Unix 毫秒时间戳。如果该事件还没有发生，返回 0。</span><br></pre></td></tr></table></figure>

<p>根据上面这些属性，可以计算出网页加载各个阶段的耗时。比如，网页加载整个过程的耗时的计算方法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t = performance.timing;</span><br><span class="line"><span class="keyword">var</span> pageLoadTime = t.loadEventEnd - t.navigationStart;</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://javascript.ruanyifeng.com/bom/performance.html" target="_blank" rel="noopener">《Performance API》</a></p>
<h3 id="js-中的命名规则"><a href="#js-中的命名规则" class="headerlink" title="js 中的命名规则"></a>js 中的命名规则</h3><p>（1）第一个字符必须是字母、下划线（_）或美元符号（$）<br>（2）余下的字符可以是下划线、美元符号或任何字母或数字字符</p>
<p>一般我们推荐使用驼峰法来对变量名进行命名，因为这样可以与 ECMAScript 内置的函数和对象命名格式保持一致。</p>
<p>详细资料可以参考：<br><a href="http://www.w3school.com.cn/js/pro_js_variables.asp" target="_blank" rel="noopener">《ECMAScript 变量》</a></p>
<h3 id="js-语句末尾分号是否可以省略？"><a href="#js-语句末尾分号是否可以省略？" class="headerlink" title="js 语句末尾分号是否可以省略？"></a>js 语句末尾分号是否可以省略？</h3><p>在 ECMAScript 规范中，语句结尾的分号并不是必需的。但是我们一般最好不要省略分号，因为加上分号一方面有<br>利于我们代码的可维护性，另一方面也可以避免我们在对代码进行压缩时出现错误。</p>
<h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</span><br></pre></td></tr></table></figure>

<h3 id="Math-ceil-和-Math-floor"><a href="#Math-ceil-和-Math-floor" class="headerlink" title="Math.ceil 和 Math.floor"></a>Math.ceil 和 Math.floor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.ceil() === 向上取整，函数返回一个大于或等于给定数字的最小整数。</span><br><span class="line"></span><br><span class="line">Math.floor() === 向下取整，函数返回一个小于或等于给定数字的最大整数。</span><br></pre></td></tr></table></figure>

<h3 id="js-for-循环注意点"><a href="#js-for-循环注意点" class="headerlink" title="js for 循环注意点"></a>js for 循环注意点</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; <span class="number">5</span>, j &lt; <span class="number">9</span>; i++, j++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当判断语句含有多个语句时，以最后一个判断语句的值为准，因此上面的代码会执行 10 次。</span></span><br><span class="line"><span class="comment">// 当判断语句为空时，循环会一直进行。</span></span><br></pre></td></tr></table></figure>

<h3 id="一个列表，假设有-100000-个数据，这个该怎么办？"><a href="#一个列表，假设有-100000-个数据，这个该怎么办？" class="headerlink" title="一个列表，假设有 100000 个数据，这个该怎么办？"></a>一个列表，假设有 100000 个数据，这个该怎么办？</h3><p>我们需要思考的问题：该处理是否必须同步完成？数据是否必须按顺序完成？</p>
<p>解决办法：</p>
<p>（1）将数据分页，利用分页的原理，每次服务器端只返回一定数目的数据，浏览器每次只对一部分进行加载。</p>
<p>（2）使用懒加载的方法，每次加载一部分数据，其余数据当需要使用时再去加载。</p>
<p>（3）使用数组分块技术，基本思路是为要处理的项目创建一个队列，然后设置定时器每过一段时间取出一部分数据，然后再使用定时器取出下一个要处理的项目进行处理，接着再设置另一个定时器。</p>
<h3 id="js-中倒计时的纠偏实现？"><a href="#js-中倒计时的纠偏实现？" class="headerlink" title="js 中倒计时的纠偏实现？"></a>js 中倒计时的纠偏实现？</h3><p>在前端实现中我们一般通过 setTimeout 和 setInterval 方法来实现一个倒计时效果。但是使用这些方法会存在时间偏差的问题，这是由于 js 的程序执行机制造成的，setTimeout 和 setInterval 的作用是隔一段时间将回调事件加入到事件队列中，因此事件并不是立即执行的，它会等到当前执行栈为空的时候再取出事件执行，因此事件等待执行的时间就是造成误差的原因。</p>
<p>一般解决倒计时中的误差的有这样两种办法：</p>
<p>（1）第一种是通过前端定时向服务器发送请求获取最新的时间差，以此来校准倒计时时间。</p>
<p>（2）第二种方法是前端根据偏差时间来自动调整间隔时间的方式来实现的。这一种方式首先是以 setTimeout 递归的方式来实现倒计时，然后通过一个变量来记录已经倒计时的秒数。每一次函数调用的时候，首先将变量加一，然后根据这个变量和每次的间隔时间，我们就可以计算出此时无偏差时应该显示的时间。然后将当前的真实时间与这个时间相减，这样我们就可以得到时间的偏差大小，因此我们在设置下一个定时器的间隔大小的时候，我们就从间隔时间中减去这个偏差大小，以此来实现由于程序执行所造成的时间误差的纠正。</p>
<p>详细资料可以参考：<br><a href="https://juejin.im/post/5badf8305188255c8e728adc" target="_blank" rel="noopener">《JavaScript 前端倒计时纠偏实现》</a></p>
<h3 id="进程间通信的方式？"><a href="#进程间通信的方式？" class="headerlink" title="进程间通信的方式？"></a>进程间通信的方式？</h3><ul>
<li>1.管道通信</li>
<li>2.消息队列通信</li>
<li>3.信号量通信</li>
<li>4.信号通信</li>
<li>5.共享内存通信</li>
<li>6.套接字通信</li>
</ul>
<p>详细资料可以参考：<br><a href="https://blog.csdn.net/violet_echo_0908/article/details/51201278" target="_blank" rel="noopener">《进程间 8 种通信方式详解》</a><br><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noopener">《进程与线程的一个简单解释》</a></p>
<h3 id="ele-getElementsByClassName和ele-querySelectorAll的区别？"><a href="#ele-getElementsByClassName和ele-querySelectorAll的区别？" class="headerlink" title="ele.getElementsByClassName和ele.querySelectorAll的区别？"></a>ele.getElementsByClassName和ele.querySelectorAll的区别？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">element.getElementsByClassName 返回一个即时更新（动态的）HTMLCollection</span><br><span class="line">element.querySelectorAll 返回一个非即时更新（静态的） NodeList</span><br><span class="line">// 先说什么叫即时更新，（前者是动态的，改变 DOM 结构会同步，后者只会记录调用 api 时的结果，不懂可以看下面的例子）</span><br><span class="line">&lt;div id=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;p class=&quot;p&quot;&gt;1&lt;/p&gt;</span><br><span class="line">  &lt;p class=&quot;p&quot;&gt;2&lt;/p&gt;</span><br><span class="line">  &lt;p class=&quot;p&quot;&gt;3&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">let list1 = parent.getElementsByClassName(&apos;p&apos;);</span><br><span class="line">let list2 = parent.querySelectorAll(&apos;.p&apos;);</span><br><span class="line">console.log(list1.length1); // 3</span><br><span class="line">console.log(list2.length1); // 3</span><br><span class="line">let newP = docuemnt.createElement(&quot;p&quot;)</span><br><span class="line">newP.classList.add(&apos;p&apos;);</span><br><span class="line">parent.appendChild(newP);</span><br><span class="line">console.log(list1.length1); // 4 (即时更新)</span><br><span class="line">console.log(list2.length1); // 3（非即时更新）</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">// 在说下返回值</span><br><span class="line">// HTMLCollection 和 NodeList 都是类数组形式</span><br><span class="line">如下一个 div 可以看成是 HTMLDivElement 的实例，其中 Node 的集合为 NodeList；Element 的集合为 HTMLCollection</span><br><span class="line">EventTarget - Node - Element - HTMLElement - HTMLDivElement&lt;br&gt;</span><br><span class="line">EventTarget - Node - Element - SVGElement - SVGPathElement&lt;br&gt;</span><br></pre></td></tr></table></figure>

<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLDivElement" target="_blank" rel="noopener">MDN 上元素 div 继承关系</a></p>
<h3 id="请用-js-去除字符串空格？"><a href="#请用-js-去除字符串空格？" class="headerlink" title="请用 js 去除字符串空格？"></a>请用 js 去除字符串空格？</h3><p>答案：replace 正则匹配方法、str.trim()方法、JQ 方法：$.trim(str)方法</p>
<p>解析：</p>
<p>方法一：replace 正则匹配方法</p>
<p>去除字符串内所有的空格：str = str.replace(/\s*/g,””);</p>
<p>去除字符串内两头的空格：str = str.replace(/^\s<em>|\s</em>$/g,””);</p>
<p>去除字符串内左侧的空格：str = str.replace(/^\s*/,””);</p>
<p>去除字符串内右侧的空格：str = str.replace(/(\s*$)/g,””);</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">" 6 6 "</span>;</span><br><span class="line"><span class="keyword">var</span> str_1 = str.replace(<span class="regexp">/\s*/g</span>, <span class="string">""</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str_1); <span class="comment">//66</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">" 6 6 "</span>;</span><br><span class="line"><span class="keyword">var</span> str_1 = str.replace(<span class="regexp">/^\s*|\s*$/g</span>, <span class="string">""</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str_1); <span class="comment">//6 6//输出左右侧均无空格</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">" 6 6 "</span>;</span><br><span class="line"><span class="keyword">var</span> str_1 = str.replace(<span class="regexp">/^\s*/</span>, <span class="string">""</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str_1); <span class="comment">//6 6 //输出右侧有空格左侧无空格</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">" 6 6 "</span>;</span><br><span class="line"><span class="keyword">var</span> str_1 = str.replace(<span class="regexp">/(\s*$)/g</span>, <span class="string">""</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str_1); <span class="comment">// 6 6//输出左侧有空格右侧无空格</span></span><br></pre></td></tr></table></figure>

<p>方法二：str.trim()方法</p>
<p>trim()方法是用来删除字符串两端的空白字符并返回，trim 方法并不影响原来的字符串本身，它返回的是一个新的字符串。</p>
<p>缺陷：只能去除字符串两端的空格，不能去除中间的空格</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">" 6 6 "</span>;</span><br><span class="line"><span class="keyword">var</span> str_1 = str.trim();</span><br><span class="line"><span class="built_in">console</span>.log(str_1); <span class="comment">//6 6//输出左右侧均无空格</span></span><br></pre></td></tr></table></figure>

<p>方法三：JQ 方法：$.trim(str)方法</p>
<p>$.trim() 函数用于去除字符串两端的空白字符。</p>
<p>注意：$.trim()函数会移除字符串开始和末尾处的所有换行符，空格(包括连续的空格)和制表符。如果这些空白字符在字符串中间时，它们将被保留，不会被移除。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">" 6 6 "</span>;</span><br><span class="line"><span class="keyword">var</span> str_1 = $.trim(str);</span><br><span class="line"><span class="built_in">console</span>.log(str_1); <span class="comment">//6 6//输出左右侧均无空格</span></span><br></pre></td></tr></table></figure>

<h3 id="同步和异步的区别"><a href="#同步和异步的区别" class="headerlink" title="同步和异步的区别?"></a>同步和异步的区别?</h3><p>同步的概念应该是来自于OS中关于同步的概念:不同进程为协同完成某项工作而在先后次序上调整(通过阻塞,唤醒等方式).同步强调的是顺序性.谁先谁后.异步则不存在这种顺序性.</p>
<ul>
<li>同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作</li>
<li>异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容</li>
</ul>
<h3 id="异步加载JS的方式有哪些？"><a href="#异步加载JS的方式有哪些？" class="headerlink" title="异步加载JS的方式有哪些？"></a>异步加载JS的方式有哪些？</h3><ul>
<li><p>(1) defer，只支持IE</p>
</li>
<li><p>(2) async：</p>
</li>
<li><p>(3) 创建script，插入到DOM中，加载完毕后callBack</p>
</li>
</ul>
<h3 id="异步处理方法（参考链接）"><a href="#异步处理方法（参考链接）" class="headerlink" title="异步处理方法（参考链接）"></a>异步处理方法（<a href="https://juejin.im/entry/58b294a78d6d810057eea370" target="_blank" rel="noopener">参考链接</a>）</h3><p><strong>1)回调函数：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function fn1 () &#123;</span><br><span class="line">    console.log(&apos;Function 1&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn2 (f) &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&apos;Function 2&apos;)</span><br><span class="line">        f()</span><br><span class="line">&#125;, 500)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn3 () &#123;</span><br><span class="line">    console.log(&apos;Function 3&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn1();</span><br><span class="line">fn2(fn3) ; //可依次执行fn1，fn2，fn3</span><br></pre></td></tr></table></figure>

<p><strong>2)发布/订阅模式；</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class AsyncFunArr &#123;</span><br><span class="line">    constructor (...arr) &#123;</span><br><span class="line">        this.funcArr = [...arr]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">next () &#123;</span><br><span class="line">    const fn = this.funcArr.shift()</span><br><span class="line">    if (typeof fn === &apos;function&apos;) fn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run () &#123;</span><br><span class="line">    this.next()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn1 () &#123;</span><br><span class="line">    console.log(&apos;Function 1&apos;)</span><br><span class="line">    asyncFunArr.next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn2 () &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&apos;Function 2&apos;)</span><br><span class="line">        asyncFunArr.next()</span><br><span class="line">    &#125;, 500)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn3 () &#123;</span><br><span class="line">    console.log(&apos;Function 3&apos;)</span><br><span class="line">    asyncFunArr.next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3）Promise：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function fn1 () &#123;</span><br><span class="line"></span><br><span class="line">console.log(&apos;Function 1&apos;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn2 () &#123;</span><br><span class="line"></span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">            console.log(&apos;Function 2&apos;)</span><br><span class="line"></span><br><span class="line">            resolve()</span><br><span class="line"></span><br><span class="line">    &#125;, 500) &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn3 () &#123;</span><br><span class="line"></span><br><span class="line">console.log(&apos;Function 3&apos;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn1()；</span><br><span class="line"></span><br><span class="line">fn2().then(() =&gt; &#123; fn3() &#125;)；</span><br></pre></td></tr></table></figure>

<p><strong>4)generator:</strong>（<a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="noopener">参考链接</a>）</p>
<h3 id="documen-write和-innerHTML的区别"><a href="#documen-write和-innerHTML的区别" class="headerlink" title="documen.write和 innerHTML的区别"></a>documen.write和 innerHTML的区别</h3><ul>
<li>document.write只能重绘整个页面</li>
<li>innerHTML可以重绘页面的一部分</li>
</ul>
<h3 id="怎样添加、移除、移动、复制、创建和查找节点？"><a href="#怎样添加、移除、移动、复制、创建和查找节点？" class="headerlink" title="怎样添加、移除、移动、复制、创建和查找节点？"></a>怎样添加、移除、移动、复制、创建和查找节点？</h3><p>1）创建新节点</p>
<ul>
<li>createDocumentFragment() //创建一个 DOM 片段</li>
<li>createElement() //创建一个具体的元素</li>
<li>createTextNode() //创建一个文本节点</li>
</ul>
<p>2）添加、移除、替换、插入</p>
<ul>
<li>appendChild() //添加</li>
<li>removeChild() //移除</li>
<li>replaceChild() //替换</li>
<li>insertBefore() //插入</li>
</ul>
<p>3）查找</p>
<ul>
<li>getElementsByTagName() //通过标签名称</li>
<li>getElementsByName() //通过元素的 Name 属性的值</li>
<li>getElementById() //通过元素 Id，唯一性</li>
</ul>
<h3 id="如何判断-JS-变量的一个类型（至少三种方式）"><a href="#如何判断-JS-变量的一个类型（至少三种方式）" class="headerlink" title="如何判断 JS 变量的一个类型（至少三种方式）"></a>如何判断 JS 变量的一个类型（至少三种方式）</h3><p>typeof、instanceof、 constructor、 prototype</p>
<h3 id="null-undefined-的区别"><a href="#null-undefined-的区别" class="headerlink" title="null/undefined 的区别"></a>null/undefined 的区别</h3><p>null： Null 类型，代表“空值”，代表一个空对象指针，使用 typeof 运算得到 “object”，所以你可以认为它是一个特殊的对象值。</p>
<p>undefined： Undefined 类型，当一个声明了一个变量未初始化时，得到的就是 undefined。</p>
<h3 id="去除字符串里面的重复字符"><a href="#去除字符串里面的重复字符" class="headerlink" title="去除字符串里面的重复字符"></a>去除字符串里面的重复字符</h3><p>最简单的方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...new <span class="built_in">Set</span>(<span class="string">"ababbc"</span>)].join(<span class="string">""</span>);</span><br><span class="line"><span class="comment">// "abc"</span></span><br></pre></td></tr></table></figure>

<h3 id="数组和对象的深浅拷贝（参考链接）"><a href="#数组和对象的深浅拷贝（参考链接）" class="headerlink" title="数组和对象的深浅拷贝（参考链接）"></a>数组和对象的深浅拷贝（<a href="http://www.cnblogs.com/zqzjs/p/5410138.html" target="_blank" rel="noopener">参考链接</a>）</h3><h3 id="String-Array的一些基本操作（参考链接）"><a href="#String-Array的一些基本操作（参考链接）" class="headerlink" title="String + Array的一些基本操作（参考链接）"></a>String + Array的一些基本操作（<a href="https://blog.csdn.net/JSCTO/article/details/50063501" target="_blank" rel="noopener">参考链接</a>）</h3><h3 id="冒泡和捕获（参考链接）"><a href="#冒泡和捕获（参考链接）" class="headerlink" title="冒泡和捕获（参考链接）"></a>冒泡和捕获（<a href="https://segmentfault.com/a/1190000005654451" target="_blank" rel="noopener">参考链接</a>）</h3><h3 id="事件代理（参考链接）"><a href="#事件代理（参考链接）" class="headerlink" title="事件代理（参考链接）"></a>事件代理（<a href="https://www.jianshu.com/p/39613d176b3a" target="_blank" rel="noopener">参考链接</a>）</h3><h3 id="jsonp和跨域，为什么浏览器会禁止跨域（参考链接：jsonp）"><a href="#jsonp和跨域，为什么浏览器会禁止跨域（参考链接：jsonp）" class="headerlink" title="jsonp和跨域，为什么浏览器会禁止跨域（参考链接：jsonp）"></a>jsonp和跨域，为什么浏览器会禁止跨域（参考链接：<a href="https://blog.csdn.net/u014607184/article/details/52027879" target="_blank" rel="noopener">jsonp</a>）</h3><h3 id="变量提升（参考链接）"><a href="#变量提升（参考链接）" class="headerlink" title="变量提升（参考链接）"></a>变量提升（<a href="http://www.runoob.com/js/js-hoisting.html" target="_blank" rel="noopener">参考链接</a>）</h3><h3 id="高阶函数（参考链接）"><a href="#高阶函数（参考链接）" class="headerlink" title="高阶函数（参考链接）"></a>高阶函数（<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499355829ead974e550644e2ebd9fd8bb1b0dd721000" target="_blank" rel="noopener">参考链接</a>）</h3><h3 id="动画（参考链接）"><a href="#动画（参考链接）" class="headerlink" title="动画（参考链接）"></a>动画（<a href="http://www.imooc.com/learn/167" target="_blank" rel="noopener">参考链接</a>）</h3><h3 id="模块化开发参考链接、-UMD"><a href="#模块化开发参考链接、-UMD" class="headerlink" title="模块化开发参考链接、 UMD"></a>模块化开发<a href="https://zhuanlan.zhihu.com/p/22890374" target="_blank" rel="noopener">参考链接</a>、 <a href="https://github.com/umdjs/umd" target="_blank" rel="noopener">UMD</a></h3><h3 id="引起内存泄漏的原因（参考链接）"><a href="#引起内存泄漏的原因（参考链接）" class="headerlink" title="引起内存泄漏的原因（参考链接）"></a>引起内存泄漏的原因（<a href="https://juejin.im/entry/58158abaa0bb9f005873a843" target="_blank" rel="noopener">参考链接</a>）</h3><p><strong>1）全局变量引起的内存泄漏</strong></p>
<p>function leaks(){ leak = ‘xxxxxx’;//leak 成为一个全局变量，不会被回收}</p>
<p><strong>2）闭包引起的内存泄漏</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var leaks = (function()&#123;</span><br><span class="line">        var leak = &apos;xxxxxx&apos;;// 被闭包所引用，不会被回收</span><br><span class="line">        return function()&#123;</span><br><span class="line">                console.log(leak);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p><strong>3）dom清空或删除时，事件未清除导致的内存泄漏</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#container&apos;).bind(&apos;click&apos;, function()&#123;</span><br><span class="line">    console.log(&apos;click&apos;);</span><br><span class="line">&#125;).remove();</span><br><span class="line"></span><br><span class="line">// zepto 和原生 js下，#container dom 元素，还在内存里jquery 的 empty和 remove会帮助开发者避免这个问题</span><br><span class="line">$(&apos;#container&apos;).bind(&apos;click&apos;, function()&#123;</span><br><span class="line">    console.log(&apos;click&apos;);</span><br><span class="line">&#125;).off(&apos;click&apos;).remove();</span><br><span class="line">//把事件清除了，即可从内存中移除</span><br></pre></td></tr></table></figure>

<p><strong>4） 被遗忘的计时器或回调函数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var someResource = getData();</span><br><span class="line">setInterval(function() &#123;</span><br><span class="line">    var node = document.getElementById(&apos;Node&apos;);</span><br><span class="line">    if(node) &#123;        // 处理 node 和 someResource</span><br><span class="line">        node.innerHTML = JSON.stringify(someResource));</span><br><span class="line">&#125;&#125;, 1000);</span><br><span class="line"></span><br><span class="line">修改：</span><br><span class="line">var element = document.getElementById(&apos;button&apos;);</span><br><span class="line">function onClick(event) &#123;</span><br><span class="line">    element.innerHTML = &apos;text&apos;;</span><br><span class="line">&#125;</span><br><span class="line">element.addEventListener(&apos;click&apos;, onClick);</span><br></pre></td></tr></table></figure>

<h3 id="map、filter、reduce相关"><a href="#map、filter、reduce相关" class="headerlink" title="map、filter、reduce相关"></a>map、filter、reduce相关</h3><p>参考链接：</p>
<p><a href="https://atendesigngroup.com/blog/array-map-filter-and-reduce-js" target="_blank" rel="noopener">https://atendesigngroup.com/blog/array-map-filter-and-reduce-js</a></p>
<p><a href="http://zerosoul.github.io/2016/12/06/array-filter-map-reduce-in-js" target="_blank" rel="noopener">http://zerosoul.github.io/2016/12/06/array-filter-map-reduce-in-js</a></p>
<h3 id="Map和Set（参考链接）"><a href="#Map和Set（参考链接）" class="headerlink" title="Map和Set（参考链接）"></a>Map和Set（<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014345007434430758e3ac6e1b44b1865178e7aff9082e000" target="_blank" rel="noopener">参考链接</a>）</h3><p><strong>Map</strong>是一组键值对的结构，具有极快的查找速度。</p>
<p>例：var m =new Map([[‘Michael’,95], [‘Bob’,75], [‘Tracy’,85]]);</p>
<p>m.get(‘Michael’);// 95</p>
<p><strong>Set</strong>和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。</p>
<p>要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set：</p>
<p>var s1 = new Set(); // 空Set</p>
<p>var s2 = new Set([1, 2, 3]); // 含1, 2, 3</p>
<h3 id="js-是一门怎样的语言，它有什么特点"><a href="#js-是一门怎样的语言，它有什么特点" class="headerlink" title="js 是一门怎样的语言，它有什么特点"></a>js 是一门怎样的语言，它有什么特点</h3><p>1.脚本语言。JavaScript 是一种<strong>解释型的脚本语言</strong>,C、C++等语言先编译后执行,而 JavaScript 是在程序的运行过程中逐行进行解释。</p>
<p>2.基于对象。JavaScript 是一种<strong>基于对象的脚本语言</strong>,它不仅可以创建对象,也能使用现有的对象。</p>
<p>3.简单。JavaScript 语言中采用的是<strong>弱类型的变量类型</strong>,对使用的数据类型未做出严格的要求,是基于 Java 基本语句和控制的脚本语言,其设计简单紧凑。</p>
<p>4.动态性。JavaScript 是一种<strong>采用事件驱动的脚本语言</strong>,它不需要经过 Web 服务器就可以对用户的输入做出响应。</p>
<p>5.<strong>跨平台性</strong>。JavaScript 脚本语言不依赖于操作系统,仅需要浏览器的支持。</p>
<h3 id="JavaScript-的循环语句有哪些？"><a href="#JavaScript-的循环语句有哪些？" class="headerlink" title="JavaScript 的循环语句有哪些？"></a>JavaScript 的循环语句有哪些？</h3><p>while for do while forEach</p>
<h3 id="script-的位置是否会影响首屏显示时间？"><a href="#script-的位置是否会影响首屏显示时间？" class="headerlink" title="script 的位置是否会影响首屏显示时间？"></a>script 的位置是否会影响首屏显示时间？</h3><ul>
<li>在解析 HTML 生成 DOM 过程中，js 文件的下载是并行的，不需要 DOM 处理到 script 节点。因此，script的位置不影响首屏显示的开始时间。</li>
<li>浏览器解析 HTML 是自上而下的线性过程，script作为 HTML 的一部分同样遵循这个原则</li>
<li>因此，script 会延迟 DomContentLoad，只显示其上部分首屏内容，从而影响首屏显示的完成时间</li>
</ul>
<h3 id="JavaScript有几种类型的值？你能画一下他们的内存图吗？"><a href="#JavaScript有几种类型的值？你能画一下他们的内存图吗？" class="headerlink" title="JavaScript有几种类型的值？你能画一下他们的内存图吗？"></a>JavaScript有几种类型的值？你能画一下他们的内存图吗？</h3><p><strong>栈</strong>：原始数据类型（Undefined，Null，Boolean，Number、String）</p>
<p><strong>堆</strong>：引用数据类型（对象、数组和函数）</p>
<p>两种类型的区别是：存储位置不同；</p>
<ul>
<li><p>原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</p>
</li>
<li><p>引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体</p>
</li>
</ul>
<h3 id="eval是做什么的？"><a href="#eval是做什么的？" class="headerlink" title="eval是做什么的？"></a>eval是做什么的？</h3><p><strong>eval的功能是把对应的字符串解析成JS代码并运行</strong></p>
<ul>
<li>应该避免使用eval，不安全，非常耗性能（先解析成js语句，再执行）</li>
<li>由JSON字符串转换为JSON对象的时候可以用 eval(‘(‘+ str +’)’);</li>
</ul>
<h3 id="javascript-代码中的”use-strict”-是什么意思-使用它区别是什么？"><a href="#javascript-代码中的”use-strict”-是什么意思-使用它区别是什么？" class="headerlink" title="javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？"></a>javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？</h3><ul>
<li>use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,</li>
<li>使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。</li>
<li>默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值;</li>
<li>全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用；</li>
<li>消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同;</li>
<li>提高编译器效率，增加运行速度；为未来新版本的Javascript标准化做铺垫。</li>
</ul>
<h3 id="js延迟加载的方式有哪些？"><a href="#js延迟加载的方式有哪些？" class="headerlink" title="js延迟加载的方式有哪些？"></a>js延迟加载的方式有哪些？</h3><ul>
<li>defer和async、动态创建DOM方式（用得最多）、按需异步载入js</li>
</ul>
<h3 id="介绍-DOM-的发展"><a href="#介绍-DOM-的发展" class="headerlink" title="介绍 DOM 的发展"></a>介绍 DOM 的发展</h3><ul>
<li>DOM：文档对象模型（Document Object Model），定义了访问HTML和XML文档的标准，与编程语言及平台无关</li>
<li>DOM0：提供了查询和操作Web文档的内容API。未形成标准，实现混乱。如：document.forms[‘login’]</li>
<li>DOM1：W3C提出标准化的DOM，简化了对文档中任意部分的访问和操作。如：JavaScript中的Document对象</li>
<li>DOM2：原来DOM基础上扩充了鼠标事件等细分模块，增加了对CSS的支持。如：getComputedStyle(elem, pseudo)</li>
<li>DOM3：增加了XPath模块和加载与保存（Load and Save）模块。如：XPathEvaluator</li>
</ul>
<h3 id="区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”？"><a href="#区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”？" class="headerlink" title="区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”？"></a>区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”？</h3><ul>
<li>客户区坐标：鼠标指针在可视区中的水平坐标(clientX)和垂直坐标(clientY)</li>
<li>页面坐标：鼠标指针在页面布局中的水平坐标(pageX)和垂直坐标(pageY)</li>
<li>屏幕坐标：设备物理屏幕的水平坐标(screenX)和垂直坐标(screenY)</li>
</ul>
<h3 id="如何获得一个DOM元素的绝对位置？"><a href="#如何获得一个DOM元素的绝对位置？" class="headerlink" title="如何获得一个DOM元素的绝对位置？"></a>如何获得一个DOM元素的绝对位置？</h3><ul>
<li>elem.offsetLeft：返回元素相对于其定位父级左侧的距离</li>
<li>elem.offsetTop：返回元素相对于其定位父级顶部的距离</li>
<li>elem.getBoundingClientRect()：返回一个DOMRect对象，包含一组描述边框的只读属性，单位像素</li>
</ul>
<h3 id="用原生JavaScript的实现过什么功能吗？"><a href="#用原生JavaScript的实现过什么功能吗？" class="headerlink" title="用原生JavaScript的实现过什么功能吗？"></a>用原生JavaScript的实现过什么功能吗？</h3><p>封装选择器、调用第三方API、设置和获取样式</p>
<h3 id="JavaScript实现异步编程的方法？"><a href="#JavaScript实现异步编程的方法？" class="headerlink" title="JavaScript实现异步编程的方法？"></a>JavaScript实现异步编程的方法？</h3><ul>
<li>回调函数</li>
<li>事件监听</li>
<li>发布/订阅</li>
<li>Promises对象</li>
<li>Async函数[ES7]</li>
</ul>
<h3 id="web开发中会话跟踪的方法有哪些"><a href="#web开发中会话跟踪的方法有哪些" class="headerlink" title="web开发中会话跟踪的方法有哪些"></a>web开发中会话跟踪的方法有哪些</h3><ul>
<li>cookie</li>
<li>session</li>
<li>url重写</li>
<li>隐藏input</li>
<li>ip地址</li>
</ul>
<h3 id="JavaScript有几种类型的值？，你能画一下他们的内存图吗？"><a href="#JavaScript有几种类型的值？，你能画一下他们的内存图吗？" class="headerlink" title="JavaScript有几种类型的值？，你能画一下他们的内存图吗？"></a>JavaScript有几种类型的值？，你能画一下他们的内存图吗？</h3><ul>
<li><p>栈：原始数据类型（Undefined，Null，Boolean，Number、String） </p>
</li>
<li><p>堆：引用数据类型（对象、数组和函数）</p>
</li>
<li><p>两种类型的区别是：存储位置不同；</p>
</li>
<li><p>原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</p>
</li>
<li><p>引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其</p>
</li>
<li><p>在栈中的地址，取得地址后从堆中获得实体</p>
</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://camo.githubusercontent.com/d1947e624a0444d1032a85800013df487adc5550/687474703a2f2f7777772e77337363686f6f6c2e636f6d2e636e2f692f63745f6a735f76616c75652e676966" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h3 id="eval是做什么的？-1"><a href="#eval是做什么的？-1" class="headerlink" title="eval是做什么的？"></a>eval是做什么的？</h3><ul>
<li>它的功能是把对应的字符串解析成JS代码并运行</li>
<li>应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）</li>
<li>由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(‘(‘+ str +’)’)</li>
</ul>
<h3 id="javascript-代码中的”use-strict”-是什么意思-使用它区别是什么？-1"><a href="#javascript-代码中的”use-strict”-是什么意思-使用它区别是什么？-1" class="headerlink" title="javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？"></a>javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？</h3><ul>
<li>use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为</li>
</ul>
<h3 id="js延迟加载的方式有哪些？-1"><a href="#js延迟加载的方式有哪些？-1" class="headerlink" title="js延迟加载的方式有哪些？"></a>js延迟加载的方式有哪些？</h3><p>defer和async、动态创建DOM方式（用得最多）、按需异步载入js</p>
<h3 id="异步加载JS的方式有哪些？-1"><a href="#异步加载JS的方式有哪些？-1" class="headerlink" title="异步加载JS的方式有哪些？"></a>异步加载JS的方式有哪些？</h3><ul>
<li>defer，只支持IE</li>
<li>async：</li>
<li>创建script，插入到DOM中，加载完毕后callBack</li>
</ul>
<h3 id="defer和async"><a href="#defer和async" class="headerlink" title="defer和async"></a>defer和async</h3><p>defer并行加载js文件，会按照页面上script标签的顺序执行async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行</p>
<h3 id="documen-write和-innerHTML的区别-1"><a href="#documen-write和-innerHTML的区别-1" class="headerlink" title="documen.write和 innerHTML的区别"></a>documen.write和 innerHTML的区别</h3><ul>
<li>document.write只能重绘整个页面</li>
<li>innerHTML可以重绘页面的一部分</li>
</ul>
<h3 id="那些操作会造成内存泄漏？"><a href="#那些操作会造成内存泄漏？" class="headerlink" title="那些操作会造成内存泄漏？"></a>那些操作会造成内存泄漏？</h3><ul>
<li>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在</li>
<li>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收</li>
<li>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏</li>
<li>闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</li>
</ul>
<h3 id="Javascript垃圾回收方法"><a href="#Javascript垃圾回收方法" class="headerlink" title="Javascript垃圾回收方法"></a>Javascript垃圾回收方法</h3><p><strong>标记清除（mark and sweep）</strong></p>
<blockquote>
<ul>
<li>这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”</li>
<li>垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了</li>
</ul>
</blockquote>
<p><strong>引用计数(reference counting)</strong></p>
<blockquote>
<p>在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间</p>
</blockquote>
<h3 id="用过哪些设计模式？"><a href="#用过哪些设计模式？" class="headerlink" title="用过哪些设计模式？"></a>用过哪些设计模式？</h3><p>工厂模式：</p>
<ul>
<li>主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字。将所有实例化的代码集中在一个位置防止代码重复</li>
<li>工厂模式解决了重复实例化的问题 ，但还有一个问题,那就是识别问题，因为根本无法 搞清楚他们到底是哪个对象的实例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function createObject(name,age,profession)&#123;//集中实例化的函数var obj = new Object();</span><br><span class="line">    obj.name = name;</span><br><span class="line">    obj.age = age;</span><br><span class="line">    obj.profession = profession;</span><br><span class="line">    obj.move = function () &#123;</span><br><span class="line">        return this.name + &apos; at &apos; + this.age + &apos; engaged in &apos; + this.profession;</span><br><span class="line">    &#125;;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line">var test1 = createObject(&apos;trigkit4&apos;,22,&apos;programmer&apos;);//第一个实例var test2 = createObject(&apos;mike&apos;,25,&apos;engineer&apos;);//第二个实例</span><br></pre></td></tr></table></figure>

<ul>
<li><p>构造函数模式</p>
<p>使用构造函数的方法 ，即解决了重复实例化的问题 ，又解决了对象识别的问题，该模式与工厂模式的不同之处在于</p>
</li>
<li><p>构造函数方法没有显示的创建对象 (new Object());</p>
</li>
<li><p>直接将属性和方法赋值给 this 对象;</p>
</li>
<li><p>没有 renturn 语句</p>
</li>
</ul>
<h3 id="实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制"><a href="#实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制" class="headerlink" title="实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制"></a>实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.clone = function()&#123;</span><br><span class="line">    var o = this.constructor === Array ? [] : &#123;&#125;;</span><br><span class="line">    for(var e in this)&#123;</span><br><span class="line">    o[e] = typeof this[e] === &quot;object&quot; ? this[e].clone() : this[e];</span><br><span class="line">    &#125;</span><br><span class="line">  return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="说说严格模式的限制"><a href="#说说严格模式的限制" class="headerlink" title="说说严格模式的限制"></a>说说严格模式的限制</h3><ul>
<li><p>严格模式主要有以下限制：</p>
</li>
<li><p>变量必须声明后再使用</p>
</li>
<li><p>函数的参数不能有同名属性，否则报错</p>
</li>
<li><p>不能使用with语句</p>
</li>
<li><p>不能对只读属性赋值，否则报错</p>
</li>
<li><p>不能使用前缀0表示八进制数，否则报错</p>
</li>
<li><p>不能删除不可删除的属性，否则报错</p>
</li>
<li><p>不能删除变量delete prop，会报错，只能删除属性delete global[prop]</p>
</li>
<li><p>eval不会在它的外层作用域引入变量</p>
</li>
<li><p>eval和arguments不能被重新赋值</p>
</li>
<li><p>arguments不会自动反映函数参数的变化</p>
</li>
<li><p>不能使用arguments.callee</p>
</li>
<li><p>不能使用arguments.caller</p>
</li>
<li><p>禁止this指向全局对象</p>
</li>
<li><p>不能使用fn.caller和fn.arguments获取函数调用的堆栈</p>
</li>
<li><p>增加了保留字（比如protected、static和interface）</p>
</li>
</ul>
<h3 id="如何删除一个cookie"><a href="#如何删除一个cookie" class="headerlink" title="如何删除一个cookie"></a>如何删除一个cookie</h3><ul>
<li>将时间设为当前时间往前一点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var date = new Date();</span><br><span class="line">date.setDate(date.getDate() - 1);//真正的删除</span><br></pre></td></tr></table></figure>

<p>setDate()方法用于设置一个月的某一天</p>
<ul>
<li>expires的设置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = &apos;user=&apos;+ encodeURIComponent(&apos;name&apos;)  + &apos;;expires = &apos; + new Date(0)</span><br></pre></td></tr></table></figure>

<h3 id="attribute和property的区别是什么？"><a href="#attribute和property的区别是什么？" class="headerlink" title="attribute和property的区别是什么？"></a>attribute和property的区别是什么？</h3><ul>
<li><p>attribute是dom元素在文档中作为html标签拥有的属性；</p>
</li>
<li><p>property就是dom元素在js中作为对象拥有的属性。</p>
</li>
<li><p>对于html的标准属性来说，attribute和property是同步的，是会自动更新的</p>
</li>
<li><p>但是对于自定义的属性来说，他们是不同步的</p>
</li>
</ul>
<h3 id="页面编码和被请求的资源编码如果不一致如何处理？"><a href="#页面编码和被请求的资源编码如果不一致如何处理？" class="headerlink" title="页面编码和被请求的资源编码如果不一致如何处理？"></a>页面编码和被请求的资源编码如果不一致如何处理？</h3><ul>
<li>后端响应头设置 charset </li>
<li>前端页面<code>&lt;meta&gt;</code>设置 charset</li>
</ul>
<h3 id="把-lt-script-gt-放在-lt-body-gt-之前和之后有什么区别？浏览器会如何解析它们？"><a href="#把-lt-script-gt-放在-lt-body-gt-之前和之后有什么区别？浏览器会如何解析它们？" class="headerlink" title="把&lt;script&gt;放在&lt;/body&gt;之前和之后有什么区别？浏览器会如何解析它们？"></a>把<code>&lt;script&gt;</code>放在<code>&lt;/body&gt;</code>之前和之后有什么区别？浏览器会如何解析它们？</h3><ul>
<li>按照HTML标准，在<code>&lt;/body&gt;</code>结束后出现<code>&lt;script&gt;</code>或任何元素的开始标签，都是解析错误</li>
<li>虽然不符合HTML标准，但浏览器会自动容错，使实际效果与写在<code>&lt;/body&gt;</code>之前没有区别</li>
<li>浏览器的容错机制会忽略<script>之前的<code>&lt;/body&gt;</code>，视作<code>&lt;script&gt;</code>仍在 body 体内。省略<code>&lt;/body&gt;</code>和<code>&lt;/html&gt;</code>闭合标签符合HTML标准，服务器可以利用这一标准尽可能少输出内容</li>
</ul>
<h3 id="延迟加载（异步加载）JS的方式有哪些？"><a href="#延迟加载（异步加载）JS的方式有哪些？" class="headerlink" title="延迟加载（异步加载）JS的方式有哪些？"></a>延迟加载（异步加载）JS的方式有哪些？</h3><ul>
<li>设置<code>&lt;script&gt;</code>属性 defer="defer" （脚本将在页面完成解析时执行）</li>
<li>设置<code>&lt;script&gt;</code>属性 async="async" （一旦脚本可用，则会异步执行）</li>
<li>动态创建 script DOM：document.createElement('script');</li>
<li>XmlHttpRequest 脚本注入</li>
<li>延迟加载工具 LazyLoad</li>
<li>异步加载库 LABjs</li>
<li>模块加载器 Sea.js</li>
</ul>
<h3 id="JavaScript-对象生命周期的理解？"><a href="#JavaScript-对象生命周期的理解？" class="headerlink" title="JavaScript 对象生命周期的理解？"></a>JavaScript 对象生命周期的理解？</h3><ul>
<li>当创建一个对象时，JavaScript 会自动为该对象分配适当的内存</li>
<li>垃圾回收器定期扫描对象，并计算引用了该对象的其他对象的数量</li>
<li>如果被引用数量为 0，或惟一引用是循环的，那么该对象的内存即可回收</li>
</ul>
<h3 id="哪些操作会造成内存泄漏？-1"><a href="#哪些操作会造成内存泄漏？-1" class="headerlink" title="哪些操作会造成内存泄漏？"></a>哪些操作会造成内存泄漏？</h3><ul>
<li><p>JavaScript 内存泄露指对象在不需要使用它时仍然存在，导致占用的内存不能使用或回收</p>
</li>
<li><p>未使用 var 声明的全局变量</p>
</li>
<li><p>闭包函数(Closures)</p>
</li>
<li><p>循环引用(两个对象相互引用)</p>
</li>
<li><p>控制台日志(console.log)</p>
</li>
<li><p>移除存在绑定事件的DOM元素(IE)</p>
</li>
</ul>
<h3 id="require-与-import-的区别"><a href="#require-与-import-的区别" class="headerlink" title="require 与 import 的区别"></a>require 与 import 的区别</h3><p>两者的加载方式不同、规范不同</p>
<p>第一、两者的加载方式不同，require 是在运行时加载，而 import 是在编译时加载</p>
<p>require('./a')(); // a 模块是一个函数，立即执行 a 模块函数</p>
<p>var data = require('./a').data; // a 模块导出的是一个对象</p>
<p>var a = require('./a')[0]; // a 模块导出的是一个数组 ======> 哪都行</p>
<p>import $ from 'jquery';</p>
<p>import * as _ from '_';</p>
<p>import {a,b,c} from './a';</p>
<p>import {default as alias, a as a_a, b, c} from './a'; ======>用在开头</p>
<p>第二、规范不同，require 是 CommonJS/AMD 规范，import 是 ESMAScript6+规范</p>
<p>第三、require 特点：社区方案，提供了服务器/浏览器的模块加载方案。非语言层面的标准。只能在运行时确定模块的依赖关系及输入/输出的变量，无法进行静态优化。</p>
<p>import 特点：语言规格层面支持模块功能。支持编译时静态分析，便于 JS 引入宏和类型检验。动态绑定。</p>
<p><a href="https://zhidao.baidu.com/question/1180348878138910499.html">https://zhidao.baidu.com/question/1180348878138910499.html</a>)</p>
<h3 id="复杂数据类型如何转变为字符串-1"><a href="#复杂数据类型如何转变为字符串-1" class="headerlink" title="复杂数据类型如何转变为字符串"></a>复杂数据类型如何转变为字符串</h3><ul>
<li>首先，会调用 valueOf 方法，如果方法的返回值是一个基本数据类型，就返回这个值，</li>
<li>如果调用 valueOf 方法之后的返回值仍旧是一个复杂数据类型，就会调用该对象的 toString 方法，</li>
<li>如果 toString 方法调用之后的返回值是一个基本数据类型，就返回这个值，</li>
<li>如果 toString 方法调用之后的返回值是一个复杂数据类型，就报一个错误。</li>
</ul>
<p>解析：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj + <span class="string">""</span>); <span class="comment">//'1'</span></span><br><span class="line"><span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj + <span class="string">""</span>); <span class="comment">//'[object Object]';</span></span><br><span class="line"><span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj + <span class="string">""</span>); <span class="comment">//'1';</span></span><br><span class="line"><span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj + <span class="string">""</span>); <span class="comment">// 报错 Uncaught TypeError: Cannot convert object to primitive value</span></span><br></pre></td></tr></table></figure>

<p>拓展：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="keyword">new</span> <span class="built_in">Object</span>(), <span class="keyword">new</span> <span class="built_in">Date</span>(), <span class="keyword">new</span> <span class="built_in">RegExp</span>(), <span class="keyword">new</span> <span class="built_in">String</span>(), <span class="keyword">new</span> <span class="built_in">Number</span>(), <span class="keyword">new</span> <span class="built_in">Boolean</span>(), <span class="keyword">new</span> <span class="built_in">Function</span>(), <span class="keyword">new</span> <span class="built_in">Array</span>(), <span class="built_in">Math</span>] <span class="built_in">console</span>.log(arr.length) <span class="comment">// 9</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">	arr[i].valueOf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	arr[i].toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">'toString'</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">console</span>.log(arr[i] + <span class="string">''</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、若 return [1,2,3]处为 return "valueof"，得到的返回值是 valueof toString 7valueof<br>说明：其他八种复杂数据类型是先调用 valueOf 方法，时间对象是先调用 toString 方法</p>
<p>2、改成 return [1,2,3]，得到的返回值是 9toString<br>说明：执行 valueof 后都来执行 toString</p>
<h3 id="JS-哪些操作会造成内存泄露"><a href="#JS-哪些操作会造成内存泄露" class="headerlink" title="JS 哪些操作会造成内存泄露"></a>JS 哪些操作会造成内存泄露</h3><p>1）意外的全局变量引起的内存泄露</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leak</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  leak = <span class="string">"xxx"</span>; <span class="comment">//leak成为一个全局变量，不会被回收</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）闭包引起的内存泄露</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">document</span>.createElement(<span class="string">"XXX"</span>);</span><br><span class="line">  obj.οnclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//Even if it's a empty function</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>闭包可以维持函数内局部变量，使其得不到释放。 上例定义事件回调时，由于是函数内定义函数，并且内部函数--事件回调的引用外暴了，形成了闭包。<br>解决之道，将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对 dom 的引用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将事件处理函数定义在外部</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onclickHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">document</span>.createElement(<span class="string">"XXX"</span>);</span><br><span class="line">  obj.οnclick = onclickHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在定义事件处理函数的外部函数中，删除对dom的引用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">document</span>.createElement(<span class="string">"XXX"</span>);</span><br><span class="line">  obj.οnclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//Even if it's a empty function</span></span><br><span class="line">  &#125;;</span><br><span class="line">  obj = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）没有清理的 DOM 元素引用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements=&#123;</span><br><span class="line">    button: <span class="built_in">document</span>.getElementById(<span class="string">"button"</span>),</span><br><span class="line">    image: <span class="built_in">document</span>.getElementById(<span class="string">"image"</span>),</span><br><span class="line">    text: <span class="built_in">document</span>.getElementById(<span class="string">"text"</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    image.src=<span class="string">"http://some.url/image"</span>;</span><br><span class="line">    button.click():</span><br><span class="line">    <span class="built_in">console</span>.log(text.innerHTML)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeButton</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">'button'</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）被遗忘的定时器或者回调</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someResouce = getData();</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> node = <span class="built_in">document</span>.getElementById(<span class="string">"Node"</span>);</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    node.innerHTML = <span class="built_in">JSON</span>.stringify(someResouce);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>这样的代码很常见, 如果 id 为 Node 的元素从 DOM 中移除, 该定时器仍会存在, 同时, 因为回调函数中包含对 someResource 的引用, 定时器外面的 someResource 也不会被释放。</p>
<p>5）子元素存在引起的内存泄露</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="../../images/js007.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>

<p>黄色是指直接被 js 变量所引用，在内存里，红色是指间接被 js 变量所引用，如上图，refB 被 refA 间接引用，导致即使 refB 变量被清空，也是不会被回收的子元素 refB 由于 parentNode 的间接引用，只要它不被删除，它所有的父元素（图中红色部分）都不会被删除。</p>
<p>6）IE7/8 引用计数使用循环引用产生的问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> b = &#123;&#125;;</span><br><span class="line">  a.pro = b;</span><br><span class="line">  b.pro = a;</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>

<p>fn()执行完毕后，两个对象都已经离开环境，在标记清除方式下是没有问题的，但是在引用计数策略下，因为 a 和 b 的引用次数不为 0，所以不会被垃圾回收器回收内存，如果 fn 函数被大量调用，就会造成内存泄漏。在 IE7 与 IE8 上，内存直线上升。<br>IE 中有一部分对象并不是原生 js 对象。例如，其内存泄漏 DOM 和 BOM 中的对象就是使用 C++以 COM 对象的形式实现的，而 COM 对象的垃圾回收机制采用的就是引用计数策略。因此，即使 IE 的 js 引擎采用标记清除策略来实现，但 js 访问的 COM 对象依然是基于引用计数策略的。换句话说，只要在 IE 中涉及 COM 对象，就会存在循环引用的问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"some_element"</span>);</span><br><span class="line"><span class="keyword">var</span> myObject = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">myObject.e = element;</span><br><span class="line">element.o = myObject;</span><br></pre></td></tr></table></figure>

<p>上面的例子在一个 DOM 元素（element)与一个原生 js 对象（myObject)之间创建了循环引用。其中，变量 myObject 有一个名为 e 的属性指向 element 对象；而变量 element 也有一个属性名为 o 回指 myObject。由于存在这个循环引用，即使例子中的 DOM 从页面中移除，它也永远不会被回收。</p>
<p>看上面的例子，有人会觉得太弱了，谁会做这样无聊的事情，但是其实我们经常会这样做</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.οnlοad=<span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj=<span class="built_in">document</span>.getElementById(<span class="string">"element"</span>):</span><br><span class="line">  obj.οnclick=<span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这段代码看起来没什么问题，但是 obj 引用了 document.getElementById(“element”)，而 document.getElementById(“element”)的 onclick 方法会引用外部环境中的变量，自然也包括 obj，是不是很隐蔽啊。</p>
<p>最简单的解决方式就是自己手工解除循环引用，比如刚才的函数可以这样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">myObject.element=<span class="literal">null</span>;</span><br><span class="line">element.o=<span class="literal">null</span>;</span><br><span class="line"><span class="built_in">window</span>.οnlοad=<span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj=<span class="built_in">document</span>.getElementById(<span class="string">"element"</span>):</span><br><span class="line">  obj.οnclick=<span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  obj=<span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾回收器下次运行时，就会删除这些值并回收它们占用的内存。 要注意的是，IE9+并不存在循环引用导致 Dom 内存泄漏问题，可能是微软做了优化，或者 Dom 的回收方式已经改变</p>
<h3 id="JS-的回收机制"><a href="#JS-的回收机制" class="headerlink" title="JS 的回收机制"></a>JS 的回收机制</h3><p>JavaScript 垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收系统（GC）会按照固定的时间间隔,周期性的执行。</p>
<p>到底哪个变量是没有用的？所以垃圾收集器必须跟踪到底哪个变量没用，对于不再有用的变量打上标记，以备将来收回其内存。用于标记的无用变量的策略可能因实现而有所区别，通常情况下有两种实现方式：标记清除和引用计数。引用计数不太常用，标记清除较为常用。</p>
<h4 id="标记清除（mark-and-sweep）"><a href="#标记清除（mark-and-sweep）" class="headerlink" title="标记清除（mark and sweep）"></a>标记清除（mark and sweep）</h4><p>js 中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>; <span class="comment">//被标记，进入环境</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">20</span>; <span class="comment">//被标记，进入环境</span></span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">//执行完毕之后a、b又被标记离开环境，被回收</span></span><br></pre></td></tr></table></figure>

<h4 id="引用计数-reference-counting"><a href="#引用计数-reference-counting" class="headerlink" title="引用计数(reference counting)"></a>引用计数(reference counting)</h4><p>引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值（function object array）赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为 0 的值所占用的内存。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = &#123;&#125;; <span class="comment">//a的引用次数为0</span></span><br><span class="line">  <span class="keyword">var</span> b = a; <span class="comment">//a的引用次数加1，为1</span></span><br><span class="line">  <span class="keyword">var</span> c = a; <span class="comment">//a的引用次数加1，为2</span></span><br><span class="line">  <span class="keyword">var</span> b = &#123;&#125;; <span class="comment">//a的引用次数减1，为1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何分析内存的使用情况"><a href="#如何分析内存的使用情况" class="headerlink" title="如何分析内存的使用情况"></a>如何分析内存的使用情况</h3><p>Google Chrome 浏览器提供了非常强大的 JS 调试工具，Memory 视图 profiles 视图让你可以对 JavaScript 代码运行时的内存进行快照，并且可以比较这些内存快照。它还让你可以记录一段时间内的内存分配情况。在每一个结果视图中都可以展示不同类型的列表，但是对我们最有用的是 summary 列表和 comparison 列表。 summary 视图提供了不同类型的分配对象以及它们的合计大小：shallow size （一个特定类型的所有对象的总和）和 retained size （shallow size 加上保留此对象的其它对象的大小）。distance 显示了对象到达 GC 根（校者注：最初引用的那块内存，具体内容可自行搜索该术语）的最短距离。 comparison 视图提供了同样的信息但是允许对比不同的快照。这对于找到泄漏很有帮助。</p>
<p>5、怎样避免内存泄露</p>
<p>1）减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收；</p>
<p>2）注意程序逻辑，避免“死循环”之类的 ；</p>
<p>3）避免创建过多的对象 原则：不用了的东西要及时归还。</p>
<p><a href="https://blog.csdn.net/michael8512/article/details/77888000">参考</a></p>
<h3 id="发布订阅设计模式"><a href="#发布订阅设计模式" class="headerlink" title="发布订阅设计模式"></a>发布订阅设计模式</h3><p>答案：发布/订阅模式(Publish Subscribe Pattern)属于设计模式中的行为(Behavioral Patterns)</p>
<p>解析：<a href="https://www.jianshu.com/p/c391c77a8771">参考</a></p>
<h3 id="Zepto-的点透问题如何解决？"><a href="#Zepto-的点透问题如何解决？" class="headerlink" title="Zepto 的点透问题如何解决？"></a>Zepto 的点透问题如何解决？</h3><p>方案一：来得很直接 github 上有个 fastclick 可以完美解决<a href="https://github.com/ftlabs/fastclick">https://github.com/ftlabs/fastclick</a></p>
<p>引入 fastclick.js，因为 fastclick 源码不依赖其他库所以你可以在原生的 js 前直接加上</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(</span><br><span class="line">  <span class="string">"load"</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    FastClick.attach(<span class="built_in">document</span>.body);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>或者有 zepto 或者 jqm 的 js 里面加上</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  FastClick.attach(<span class="built_in">document</span>.body);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当然 require 的话就这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> FastClick = <span class="built_in">require</span>(<span class="string">"fastclick"</span>);</span><br><span class="line">FastClick.attach(<span class="built_in">document</span>.body, options);</span><br></pre></td></tr></table></figure>

<p>方案二：用 touchend 代替 tap 事件并阻止掉 touchend 的默认行为 preventDefault()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#cbFinish"</span>).on(<span class="string">"touchend"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//很多处理比如隐藏什么的</span></span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>方案三：延迟一定的时间(300ms+)来处理事件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#cbFinish"</span>).on(<span class="string">"tap"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//很多处理比如隐藏什么的</span></span><br><span class="line">  &#125;, <span class="number">320</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这种方法其实很好，可以和 fadeInIn/fadeOut 等动画结合使用，可以做出过渡效果</p>
<p>理论上上面的方法可以完美的解决 tap 的点透问题，如果真的不行，用 click</p>
<p>解析：</p>
<h3 id="“点透”是什么？"><a href="#“点透”是什么？" class="headerlink" title="“点透”是什么？"></a>“点透”是什么？</h3><p>你可能碰到过在列表页面上创建一个弹出层，弹出层有个关闭的按钮，你点了这个按钮关闭弹出层后后，这个按钮正下方的内容也会执行点击事件（或打开链接）。这个被定义为这是一个“点透”现象。</p>
<p>2、为什么会出现点透呢？</p>
<p><a href="https://www.cnblogs.com/axl234/p/5554281.html">参考</a></p>
<h3 id="移动端最小触控区域是多大？"><a href="#移动端最小触控区域是多大？" class="headerlink" title="移动端最小触控区域是多大？"></a>移动端最小触控区域是多大？</h3><p>苹果推荐是 44pt x 44pt</p>
<p>解析：<a href="https://developer.apple.com/ios/human-interface-guidelines/visual-design/layout/">参考</a></p>
<h3 id="移动端的点击事件的有延迟，时间是多久，为什么会有？-怎么解决这个延时？-1"><a href="#移动端的点击事件的有延迟，时间是多久，为什么会有？-怎么解决这个延时？-1" class="headerlink" title="移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？"></a>移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？</h3><ol>
<li>300 毫秒</li>
<li>因为浏览器捕获第一次单击后，会先等待一段时间，如果在这段时间区间里用户未进行下一次点击，则浏览器会做单击事件的处理。如果这段时间里用户进行了第二次单击操作，则浏览器会做双击事件处理。</li>
<li>推荐 fastclick.js</li>
</ol>
<h3 id="如何获取浏览器版本信息"><a href="#如何获取浏览器版本信息" class="headerlink" title="如何获取浏览器版本信息"></a>如何获取浏览器版本信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.navigator.userAgent</span><br></pre></td></tr></table></figure>

<h3 id="调试工具的使用"><a href="#调试工具的使用" class="headerlink" title="调试工具的使用"></a>调试工具的使用</h3><p>调试模式中的按钮作用<br>F8 跳出断点调试模式<br>F10、F11 代码的逐行调试</p>
<p>进入断点调试模式的 方法</p>
<ol>
<li>在浏览器当中打断点</li>
<li>直接在代码中加 debugger</li>
</ol>
<h3 id="foo-foo-bar-，这行代码是什么意思？为什么要这样写？"><a href="#foo-foo-bar-，这行代码是什么意思？为什么要这样写？" class="headerlink" title="foo = foo||bar ，这行代码是什么意思？为什么要这样写？"></a>foo = foo||bar ，这行代码是什么意思？为什么要这样写？</h3><p>这种写法称为短路表达式</p>
<p>解析：</p>
<p>相当于</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">  foo = foo;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  foo = bar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案：常用于函数参数的空判断</p>
<h3 id="列举浏览器对象模型-BOM-里常用的至少-4-个对象，并列举-window-对象的常用方法至少-5-个？"><a href="#列举浏览器对象模型-BOM-里常用的至少-4-个对象，并列举-window-对象的常用方法至少-5-个？" class="headerlink" title="列举浏览器对象模型 BOM 里常用的至少 4 个对象，并列举 window 对象的常用方法至少 5 个？"></a>列举浏览器对象模型 BOM 里常用的至少 4 个对象，并列举 window 对象的常用方法至少 5 个？</h3><p>对象：Window，document，location，screen，history，navigator。<br>方法：Alert（），confirm（），prompt（），open（），close（）。</p>
<h3 id="class-forname-的作用-为什么要用"><a href="#class-forname-的作用-为什么要用" class="headerlink" title="class.forname 的作用?为什么要用?"></a>class.forname 的作用?为什么要用?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、获取Class对象的方式：类名.class、对象.getClass()、Class.forName(“类名”);</span><br><span class="line">2、通过Class对象自审</span><br><span class="line">3、动态调用方法</span><br></pre></td></tr></table></figure>

<h3 id="外部-JS-文件出现中文字符，会出现什么问题，怎么解决？"><a href="#外部-JS-文件出现中文字符，会出现什么问题，怎么解决？" class="headerlink" title="外部 JS 文件出现中文字符，会出现什么问题，怎么解决？"></a>外部 JS 文件出现中文字符，会出现什么问题，怎么解决？</h3><p>会出现乱码，加 charset=”GB2312”;</p>
<h3 id="在-JS-中有哪些会被隐式转换为-false"><a href="#在-JS-中有哪些会被隐式转换为-false" class="headerlink" title="在 JS 中有哪些会被隐式转换为 false"></a>在 JS 中有哪些会被隐式转换为 false</h3><p>Undefined、null、关键字 false、NaN、零、空字符串</p>
<h3 id="eval-是做什么的？-1"><a href="#eval-是做什么的？-1" class="headerlink" title="eval 是做什么的？"></a>eval 是做什么的？</h3><ol>
<li>它的功能是把对应的字符串解析成 JS 代码并运行</li>
<li>应该避免使用 eval，不安全，非常耗性能（2 次，一次解析成 js 语句，一次执行）</li>
</ol>
<h3 id="documen-write-和-innerHTML-的区别"><a href="#documen-write-和-innerHTML-的区别" class="headerlink" title="documen.write 和 innerHTML 的区别?"></a>documen.write 和 innerHTML 的区别?</h3><p>document.write 是重写整个 document, 写入内容是字符串的 html<br>innerHTML 是 HTMLElement 的属性，是一个元素的内部 html 内容</p>
<h3 id="javascript-代码中的-use-strict-是什么意思-使用它区别是什么？"><a href="#javascript-代码中的-use-strict-是什么意思-使用它区别是什么？" class="headerlink" title="javascript 代码中的"use strict";是什么意思 ? 使用它区别是什么？"></a>javascript 代码中的"use strict";是什么意思 ? 使用它区别是什么？</h3><p>意思是使用严格模式，使用严格模式，一些不规范的语法将不再支持</p>
<h3 id="前端-templating-Mustache-underscore-handlebars-是干嘛的-怎么用"><a href="#前端-templating-Mustache-underscore-handlebars-是干嘛的-怎么用" class="headerlink" title="前端 templating(Mustache, underscore, handlebars)是干嘛的, 怎么用?"></a>前端 templating(Mustache, underscore, handlebars)是干嘛的, 怎么用?</h3><ul>
<li>Web 模板引擎是为了使用户界面与业务数据（内容）分离而产生的，</li>
<li>Mustache 是一个 logic-less （轻逻辑）模板解析引擎，它的优势在于可以应用在 Javascript、PHP、Python、Perl 等多种编程语言中。</li>
<li>Underscore 封装了常用的 JavaScript 对象操作方法，用于提高开发效率。</li>
<li>Handlebars 是 JavaScript 一个语义模板库，通过对 view 和 data 的分离来快速构建 Web 模板。</li>
</ul>
<h3 id="说说写JavaScript的基本规范？"><a href="#说说写JavaScript的基本规范？" class="headerlink" title="说说写JavaScript的基本规范？"></a>说说写JavaScript的基本规范？</h3><p>1) 不要在同一行声明多个变量<br>2) 使用 ===或!==来比较true/false或者数值<br>3) switch必须带有default分支<br>4) 函数应该有返回值<br>5) for if else 必须使用大括号<br>6) 语句结束加分号<br>7) 命名要有意义，使用驼峰命名法</p>
<h3 id="jQuery使用建议"><a href="#jQuery使用建议" class="headerlink" title="jQuery使用建议"></a>jQuery使用建议</h3><p>1) 尽量减少对dom元素的访问和操作<br>2) 尽量避免给dom元素绑定多个相同类型的事件处理函数，可以将多个相同类型事件<br>处理函数合并到一个处理函数，通过数据状态来处理分支<br>3) 尽量避免使用toggle事件</p>
<h3 id="Ajax使用"><a href="#Ajax使用" class="headerlink" title="Ajax使用"></a>Ajax使用</h3><p>全称 ： Asynchronous Javascript And XML<br>所谓异步，就是向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。<br>创建Ajax的过程：<br>1) 创建XMLHttpRequest对象（异步调用对象）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br></pre></td></tr></table></figure>

<p>2) 创建新的Http请求（方法、URL、是否异步）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(‘get’,’example.php’,false);</span><br></pre></td></tr></table></figure>

<p>3) 设置响应HTTP请求状态变化的函数。<br>onreadystatechange事件中readyState属性等于4。响应的HTTP状态为200(OK)或者304(Not Modified)。<br>4) 发送http请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.send(data);</span><br></pre></td></tr></table></figure>

<p>5) 获取异步调用返回的数据<br>注意：<br>1) 页面初次加载时，尽量在web服务器一次性输出所有相关的数据，只在页面加载完成之后，用户进行操作时采用ajax进行交互。<br>2) 同步ajax在IE上会产生页面假死的问题。所以建议采用异步ajax。<br>3) 尽量减少ajax请求次数<br>4) ajax安全问题，对于敏感数据在服务器端处理，避免在客户端处理过滤。对于关键业务逻辑代码也必须放在服务器端处理。</p>
<h3 id="JavaScript有几种类型的值？你能画一下他们的内存图吗？-1"><a href="#JavaScript有几种类型的值？你能画一下他们的内存图吗？-1" class="headerlink" title="JavaScript有几种类型的值？你能画一下他们的内存图吗？"></a>JavaScript有几种类型的值？你能画一下他们的内存图吗？</h3><p>基本数据类型存储在栈中，引用数据类型（对象）存储在堆中，指针放在栈中。<br>两种类型的区别是：存储位置不同；原始数据类型直接存储在栈中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；引用数据类型存储在堆中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能<br>引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</p>
<h3 id="栈和堆的区别？"><a href="#栈和堆的区别？" class="headerlink" title="栈和堆的区别？"></a>栈和堆的区别？</h3><p>栈（stack）：由编译器自动分配释放，存放函数的参数值，局部变量等；<br>堆（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统释放。</p>
<h3 id="Javascript实现继承的几种方式"><a href="#Javascript实现继承的几种方式" class="headerlink" title="Javascript实现继承的几种方式"></a>Javascript实现继承的几种方式</h3><p>可以参考我的另一篇文章<a href="https://segmentfault.com/a/1190000013253890">JavaScript实现类与继承的方法（全面整理）</a></p>
<h3 id="Javascript创建对象的几种方式？"><a href="#Javascript创建对象的几种方式？" class="headerlink" title="Javascript创建对象的几种方式？"></a>Javascript创建对象的几种方式？</h3><p>可以参考我的另一篇文章<a href="https://segmentfault.com/a/1190000013253890">JavaScript实现类与继承的方法（全面整理）</a></p>
<h3 id="Javascript作用链域"><a href="#Javascript作用链域" class="headerlink" title="Javascript作用链域"></a>Javascript作用链域</h3><p>作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。<br>注意：JS没有块级作用域，若要形成块级作用域，可通过（function（）｛｝）（）；立即执行的形式实现。</p>
<h3 id="谈谈this的理解"><a href="#谈谈this的理解" class="headerlink" title="谈谈this的理解"></a>谈谈this的理解</h3><p>1) this总是指向函数的直接调用者（而非间接调用者）<br>2) 如果有new关键字，this指向new出来的那个对象<br>3) 在事件中，this指向目标元素，特殊的是IE的attachEvent中的this总是指向全局对象window。</p>
<h3 id="eval是做什么的？-2"><a href="#eval是做什么的？-2" class="headerlink" title="eval是做什么的？"></a>eval是做什么的？</h3><p>它的功能是把对应的字符串解析成JS代码并运行；应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。</p>
<h3 id="什么是window对象-什么是document对象"><a href="#什么是window对象-什么是document对象" class="headerlink" title="什么是window对象? 什么是document对象?"></a>什么是window对象? 什么是document对象?</h3><p>window对象代表浏览器中打开的一个窗口。document对象代表整个html文档。实际上，document对象是window对象的一个属性。</p>
<h3 id="null，undefined的区别？"><a href="#null，undefined的区别？" class="headerlink" title="null，undefined的区别？"></a>null，undefined的区别？</h3><p>null表示一个对象被定义了，但存放了空指针，转换为数值时为0。<br>undefined表示声明的变量未初始化，转换为数值时为NAN。<br>typeof(null) -- object;<br>typeof(undefined) -- undefined</p>
<h3 id="1-2-3-map-parseInt-答案是多少？"><a href="#1-2-3-map-parseInt-答案是多少？" class="headerlink" title="["1", "2", "3"].map(parseInt) 答案是多少？"></a>["1", "2", "3"].map(parseInt) 答案是多少？</h3><p>[1,NaN,NaN]</p>
<p>解析：<br>Array.prototype.map()<br>array.map(callback[, thisArg])<br>callback函数的执行规则<br>参数：自动传入三个参数<br>currentValue（当前被传递的元素）；<br>index（当前被传递的元素的索引）；<br>array（调用map方法的数组）</p>
<p>parseInt方法接收两个参数<br>第三个参数["1", "2", "3"]将被忽略。parseInt方法将会通过以下方式被调用<br>parseInt("1", 0)<br>parseInt("2", 1)<br>parseInt("3", 2)</p>
<p>parseInt的第二个参数radix为0时，ECMAScript5将string作为十进制数字的字符串解析；<br>parseInt的第二个参数radix为1时，解析结果为NaN；<br>parseInt的第二个参数radix在2—36之间时，如果string参数的第一个字符（除空白以外），不属于radix指定进制下的字符，解析结果为NaN。<br>parseInt("3", 2)执行时，由于"3"不属于二进制字符，解析结果为NaN。</p>
<h3 id="关于事件，IE与火狐的事件机制有什么区别？-如何阻止冒泡？"><a href="#关于事件，IE与火狐的事件机制有什么区别？-如何阻止冒泡？" class="headerlink" title="关于事件，IE与火狐的事件机制有什么区别？ 如何阻止冒泡？"></a>关于事件，IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</h3><p>IE为事件冒泡，Firefox同时支持事件捕获和事件冒泡。但并非所有浏览器都支持事件捕获。jQuery中使用<code>event.stopPropagation()</code>方法可阻止冒泡;（旧IE的方法 <code>ev.cancelBubble = true;</code>）</p>
<h3 id="什么是闭包（closure），为什么要用它？"><a href="#什么是闭包（closure），为什么要用它？" class="headerlink" title="什么是闭包（closure），为什么要用它？"></a>什么是闭包（closure），为什么要用它？</h3><p>闭包指的是一个函数可以访问另一个函数作用域中变量。常见的构造方法，是在一个函数内部定义另外一个函数。内部函数可以引用外层的变量；外层变量不会被垃圾回收机制回收。<br>注意，闭包的原理是作用域链，所以闭包访问的上级作用域中的变量是个对象，其值为其运算结束后的最后一个值。<br>优点：避免全局变量污染。缺点：容易造成内存泄漏。<br>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function makeFunc() &#123;</span><br><span class="line">    var name = &quot;Mozilla&quot;;</span><br><span class="line">    function displayName() &#123;</span><br><span class="line">        console.log(name); </span><br><span class="line">    &#125;</span><br><span class="line">    return displayName;</span><br><span class="line">&#125;</span><br><span class="line">var myFunc = makeFunc();</span><br><span class="line">myFunc();   //输出Mozilla</span><br></pre></td></tr></table></figure>

<p>myFunc 变成一个 闭包。闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。在我们的例子中，myFunc 是一个闭包，由 displayName 函数和闭包创建时存在的 "Mozilla" 字符串形成。</p>
<h3 id="javascript-代码中的-use-strict-是什么意思-使用它区别是什么？-1"><a href="#javascript-代码中的-use-strict-是什么意思-使用它区别是什么？-1" class="headerlink" title="javascript 代码中的"use strict";是什么意思 ? 使用它区别是什么？"></a>javascript 代码中的"use strict";是什么意思 ? 使用它区别是什么？</h3><p>除了正常模式运行外，ECMAscript添加了第二种运行模式：“严格模式”。<br>作用：<br>1) 消除js不合理，不严谨地方，减少怪异行为<br>2) 消除代码运行的不安全之处，<br>3) 提高编译器的效率，增加运行速度<br>4) 为未来的js新版本做铺垫。</p>
<h3 id="如何判断一个对象是否属于某个类？-1"><a href="#如何判断一个对象是否属于某个类？-1" class="headerlink" title="如何判断一个对象是否属于某个类？"></a>如何判断一个对象是否属于某个类？</h3><p>使用instanceof 即if(a instanceof Person){alert('yes');}</p>
<h3 id="Javascript中，执行时对象查找时，永远不会去查找原型的函数？"><a href="#Javascript中，执行时对象查找时，永远不会去查找原型的函数？" class="headerlink" title="Javascript中，执行时对象查找时，永远不会去查找原型的函数？"></a>Javascript中，执行时对象查找时，永远不会去查找原型的函数？</h3><p>Object.hasOwnProperty(proName)：是用来判断一个对象是否有你给出名称的属性。不过需要注意的是，此方法无法检查该对象的原型链中是否具有该属性，该属性必须是对象本身的一个成员。</p>
<h3 id="对JSON的了解？"><a href="#对JSON的了解？" class="headerlink" title="对JSON的了解？"></a>对JSON的了解？</h3><p>全称：JavaScript Object Notation<br>JSON中对象通过“{}”来标识，一个“{}”代表一个对象，如{“AreaId”:”123”}，对象的值是键值对的形式（key：value）。JSON是JS的一个严格的子集，一种轻量级的数据交换格式，类似于xml。数据格式简单，易于读写，占用带宽小。<br>两个函数：<br>JSON.parse(str)<br>解析JSON字符串 把JSON字符串变成JavaScript值或对象<br>JSON.stringify(obj)<br>将一个JavaScript值(对象或者数组)转换为一个 JSON字符串<br>eval('('＋json＋')')<br>用eval方法注意加括号 而且这种方式更容易被攻击</p>
<h3 id="JS延迟加载的方式有哪些？"><a href="#JS延迟加载的方式有哪些？" class="headerlink" title="JS延迟加载的方式有哪些？"></a>JS延迟加载的方式有哪些？</h3><p>JS的延迟加载有助与提高页面的加载速度。<br>defer和async、动态创建DOM方式（用得最多）、按需异步载入JS<br>defer：延迟脚本。立即下载，但延迟执行（延迟到整个页面都解析完毕后再运行），按照脚本出现的先后顺序执行。<br>async：异步脚本。下载完立即执行，但不保证按照脚本出现的先后顺序执行。</p>
<h3 id="同步和异步的区别-1"><a href="#同步和异步的区别-1" class="headerlink" title="同步和异步的区别?"></a>同步和异步的区别?</h3><p>同步的概念在操作系统中：不同进程协同完成某项工作而先后次序调整（通过阻塞、唤醒等方式），同步强调的是顺序性，谁先谁后。异步不存在顺序性。<br>同步：浏览器访问服务器，用户看到页面刷新，重新发请求，等请求完，页面刷新，新内容出现，用户看到新内容之后进行下一步操作。<br>异步：浏览器访问服务器请求，用户正常操作，浏览器在后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。</p>
<h3 id="什么是跨域问题-，如何解决跨域问题"><a href="#什么是跨域问题-，如何解决跨域问题" class="headerlink" title="什么是跨域问题 ，如何解决跨域问题?"></a>什么是跨域问题 ，如何解决跨域问题?</h3><p>可以参考我的另一篇文章<a href="https://segmentfault.com/a/1190000013278814">什么是跨域以及几种简单解决方案</a></p>
<h3 id="页面编码和被请求的资源编码如果不一致如何处理？-1"><a href="#页面编码和被请求的资源编码如果不一致如何处理？-1" class="headerlink" title="页面编码和被请求的资源编码如果不一致如何处理？"></a>页面编码和被请求的资源编码如果不一致如何处理？</h3><p>若请求的资源编码，如外引js文件编码与页面编码不同。可根据外引资源编码方式定义为 charset="utf-8"或"gbk"。<br>比如：<a href="http://www.yyy.com/a.html">http://www.yyy.com/a.html</a> 中嵌入了一个<a href="http://www.xxx.com/test.js">http://www.xxx.com/test.js</a><br>a.html 的编码是gbk或gb2312的。 而引入的js编码为utf-8的 ，那就需要在引入的时候</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://www.xxx.com/test.js&amp;quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="模块化开发怎么做？-1"><a href="#模块化开发怎么做？-1" class="headerlink" title="模块化开发怎么做？"></a>模块化开发怎么做？</h3><p>模块化开发指的是在解决某一个复杂问题或者一系列问题时，依照一种分类的思维把问题进行系统性的分解。模块化是一种将复杂系统分解为代码结构更合理，可维护性更高的可管理的模块方式。对于软件行业：系统被分解为一组高内聚，低耦合的模块。<br>（1）定义封装的模块<br>（2）定义新模块对其他模块的依赖<br>（3）可对其他模块的引入支持。在JavaScript中出现了一些非传统模块开发方式的规范。 CommonJS的模块规范，AMD（Asynchronous Module Definition），CMD（Common Module Definition）等。AMD是异步模块定义，所有的模块将被异步加载，模块加载不影响后边语句运行。</p>
<h3 id="AMD（Modules-Asynchronous-Definition）、CMD（Common-Module-Definition）规范区别？"><a href="#AMD（Modules-Asynchronous-Definition）、CMD（Common-Module-Definition）规范区别？" class="headerlink" title="AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？"></a>AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？</h3><p>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。<br>区别：<br>1) 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。<br>2) CMD 推崇依赖就近，AMD 推崇依赖前置。<br>3) AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// CMD</span><br><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">    var a = require(&apos;./a&apos;)</span><br><span class="line">    a.doSomething()</span><br><span class="line">    // 此处略去 100 行</span><br><span class="line">    var b = require(&apos;./b&apos;) // 依赖可以就近书写</span><br><span class="line">    b.doSomething()</span><br><span class="line">&#125;)</span><br><span class="line">// AMD 默认推荐</span><br><span class="line">define([&apos;./a&apos;, &apos;./b&apos;], function(a, b) &#123; // 依赖必须一开始就写好</span><br><span class="line">    a.doSomething();</span><br><span class="line">    // 此处略去 100 行</span><br><span class="line">    b.doSomething();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）"><a href="#requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）" class="headerlink" title="requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）"></a>requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）</h3><p>核心是js的加载模块，通过正则匹配模块以及模块的依赖关系，保证文件加载的先后顺序，根据文件的路径对加载过的文件做了缓存。</p>
<h3 id="call和apply"><a href="#call和apply" class="headerlink" title="call和apply"></a>call和apply</h3><p>call（）方法和apply（）方法的作用相同，动态改变某个类的某个方法的运行环境。他们的区别在于接收参数的方式不同。</p>
<p>在使用call（）方法时，传递给函数的参数必须逐个列举出来。</p>
<p>使用apply（）时，传递给函数的是参数数组。</p>
<h3 id="documen-write和-innerHTML的区别-2"><a href="#documen-write和-innerHTML的区别-2" class="headerlink" title="documen.write和 innerHTML的区别"></a>documen.write和 innerHTML的区别</h3><p>document.write()只能重绘整个页面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">       document.write(&apos;&lt;p&gt;5 secs later&lt;/p&gt;&apos;);</span><br><span class="line">&#125;, 5000);</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function() &#123; document.write(&quot;HI&quot;);</span><br></pre></td></tr></table></figure>

<p>innerHTML可以重绘页面的一部分</p>
<h3 id="回流与重绘"><a href="#回流与重绘" class="headerlink" title="回流与重绘"></a>回流与重绘</h3><p>当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树。完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘</p>
<h3 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h3><p>（1）创建新节点<br>createDocumentFragment() //创建一个DOM片段<br>createElement() //创建一个具体的元素<br>createTextNode() //创建一个文本节点<br>（2）添加、移除、替换、插入<br>appendChild()<br>removeChild()<br>replaceChild()<br>insertBefore() //在已有的子节点前插入一个新的子节点<br>（3）查找<br>getElementsByTagName() //通过标签名称<br>getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)<br>getElementById() //通过元素Id，唯一性</p>
<h3 id="数组对象有哪些原生方法，列举一下"><a href="#数组对象有哪些原生方法，列举一下" class="headerlink" title="数组对象有哪些原生方法，列举一下"></a>数组对象有哪些原生方法，列举一下</h3><p>pop、push、shift、unshift、splice、reverse、sort、concat、join、slice、toString、indexOf、lastIndexOf、reduce、reduceRight<br>forEach、map、filter、every、some</p>
<h3 id="那些操作会造成内存泄漏"><a href="#那些操作会造成内存泄漏" class="headerlink" title="那些操作会造成内存泄漏"></a>那些操作会造成内存泄漏</h3><p>全局变量、闭包、DOM清空或删除时，事件未清除、子元素存在引用</p>
<h3 id="响应事件"><a href="#响应事件" class="headerlink" title="响应事件"></a>响应事件</h3><p>onclick鼠标点击某个对象；onfocus获取焦点；onblur失去焦点；onmousedown鼠标被按下</p>
<h3 id="flash和js通过什么类如何交互"><a href="#flash和js通过什么类如何交互" class="headerlink" title="flash和js通过什么类如何交互?"></a>flash和js通过什么类如何交互?</h3><p>Flash提供了ExternalInterface接口与JavaScript通信，ExternalInterface有两个方法，call和addCallback，call的作用是让Flash调用js里的方法，addCallback是用来注册flash函数让js调用。</p>
<h3 id="Flash与Ajax各自的优缺点？"><a href="#Flash与Ajax各自的优缺点？" class="headerlink" title="Flash与Ajax各自的优缺点？"></a>Flash与Ajax各自的优缺点？</h3><p>Flash：适合处理多媒体、矢量图形、访问机器。但对css、处理文本不足，不容易被搜索。<br>Ajax：对css、文本支持很好，但对多媒体、矢量图形、访问机器不足。</p>
<h3 id="有效的javascript变量定义规则"><a href="#有效的javascript变量定义规则" class="headerlink" title="有效的javascript变量定义规则"></a>有效的javascript变量定义规则</h3><p>第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；其他字符可以是字母、下划线、美元符号或数字。</p>
<h3 id="XML与JSON的区别？"><a href="#XML与JSON的区别？" class="headerlink" title="XML与JSON的区别？"></a>XML与JSON的区别？</h3><p>1) 数据体积方面。JSON相对于XML来讲，数据的体积小，传递的速度更快些。<br>2) 数据交互方面。JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。<br>3) 数据描述方面。JSON对数据的描述性比XML较差。<br>4) 传输速度方面。JSON的速度要远远快于XML。</p>
<h3 id="HTML与XML的区别？"><a href="#HTML与XML的区别？" class="headerlink" title="HTML与XML的区别？"></a>HTML与XML的区别？</h3><p>（1）XML用来传输和存储数据，HTML用来显示数据；<br>（2）XML使用的标签不用预先定义<br>（3）XML标签必须成对出现<br>（4）XML对大小写敏感<br>（5）XML中空格不会被删减<br>（6）XML中所有特殊符号必须用编码表示<br>（7）XML中的图片必须有文字说明</p>
<h3 id="渐进增强与优雅降级"><a href="#渐进增强与优雅降级" class="headerlink" title="渐进增强与优雅降级"></a>渐进增强与优雅降级</h3><p>渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进，达到更好的用户体验。<br>优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p>
<h3 id="Web-Worker和Web-Socket？"><a href="#Web-Worker和Web-Socket？" class="headerlink" title="Web Worker和Web Socket？"></a>Web Worker和Web Socket？</h3><p>web socket：在一个单独的持久连接上提供全双工、双向的通信。使用自定义的协议（ws://、wss://），同源策略对web socket不适用。<br>web worker：运行在后台的JavaScript，不影响页面的性能。<br>创建worker：var worker = new Worker(url);<br>向worker发送数据：worker.postMessage(data);<br>接收worker返回的数据：worker.onmessage<br>终止一个worker的执行：worker.terminate();</p>
<h3 id="JS垃圾回收机制？"><a href="#JS垃圾回收机制？" class="headerlink" title="JS垃圾回收机制？"></a>JS垃圾回收机制？</h3><p>1) 标记清除：<br>这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。<br>这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。定期的，垃圾回收器将从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象。从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。</p>
<p>2) 引用计数：<br>这是最简单的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。<br>该算法有个限制：无法处理循环引用。两个对象被创建，并互相引用，形成了一个循环。它们被调用之后不会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。</p>
<h3 id="web应用从服务器主动推送data到客户端的方式？"><a href="#web应用从服务器主动推送data到客户端的方式？" class="headerlink" title="web应用从服务器主动推送data到客户端的方式？"></a>web应用从服务器主动推送data到客户端的方式？</h3><p>JavaScript数据推送：commet（基于http长连接的服务器推送技术）。<br>基于web socket的推送：SSE（server-send Event）</p>
<h3 id="如何删除一个cookie？"><a href="#如何删除一个cookie？" class="headerlink" title="如何删除一个cookie？"></a>如何删除一个cookie？</h3><p>1） 将cookie的失效时间设置为过去的时间（expires）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = ‘user=’+ encodeURIComponent(‘name’) + &apos;;</span><br><span class="line">expires=’+ new Date(0);</span><br></pre></td></tr></table></figure>

<p>2） 将系统时间设置为当前时间往前一点时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var data = new Date();</span><br><span class="line">date.setDate(date.getDate()-1);</span><br></pre></td></tr></table></figure>

<h3 id="attribute与property的区别？"><a href="#attribute与property的区别？" class="headerlink" title="attribute与property的区别？"></a>attribute与property的区别？</h3><p>attribute是dom元素在文档中作为html标签拥有的属性<br>property是dom元素在js中作为对象拥有的属性。<br>所以，对于html的标准属性来说，attribute和property是同步的，是会自动更新的。但对于自定义属性，他们不同步。</p>
<h3 id="Ajax请求的页面历史记录状态问题？"><a href="#Ajax请求的页面历史记录状态问题？" class="headerlink" title="Ajax请求的页面历史记录状态问题？"></a>Ajax请求的页面历史记录状态问题？</h3><p>（1）通过location.hash记录状态，让浏览器记录Ajax请求时页面状态的变化。<br>（2）通过HTML5的history.pushstate，来实现浏览器地址栏的无刷新改变。</p>
</script></li></ul>
        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2024-03-31T12:01:24.000Z" itemprop="dateUpdated">2024-03-31 20:01:24</time>
</span><br>


        
        感谢您的阅读，欢迎评论(*^▽^*) 转载请附上本文链接：<a href="/interview/javascript.html" target="_blank" rel="external">https://qw66.gitee.io/interview/javascript.html</a>
        
    </div>
    
    <footer>
        <a href="https://qw66.gitee.io">
            <img src="/img/avatar.jpg" alt="秦伟">
            秦伟
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BOM/">BOM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DOM/">DOM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/同步异步/">同步异步</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/字符串/">字符串</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://qw66.gitee.io/interview/javascript.html&title=《JavaScript》 — 秦伟博客&pic=https://qw66.gitee.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://qw66.gitee.io/interview/javascript.html&title=《JavaScript》 — 秦伟博客&source=前端、全栈、SEO的知识点、面试题与学习链接的整理" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://qw66.gitee.io/interview/javascript.html" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JavaScript》 — 秦伟博客&url=https://qw66.gitee.io/interview/javascript.html&via=https://qw66.gitee.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://qw66.gitee.io/interview/javascript.html" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/other/python.html" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">python</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/articles/ji-yu-vue-de-qian-duan-jia-gou.html" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">基于Vue的前端架构</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'false' == 'true',
            appId: "TJ17Ax10JrfIIljlO8qkwGvz-gzGzoHsz",
            appKey: "jDGQKdWT9hlzsTLRAbInE4bK",
            avatar: "mm",
            placeholder: "说点什么吧(*╹▽╹*)",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->










</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢您，我会继续努力哒(*^▽^*)
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.png" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

    <footer class="footer">
    <div class="top">
        <div class="map">
            <!--地球信息-->
<script type="text/javascript" src="/js/jquery-3.4.1.js"></script>
<script type="text/javascript">
    var windowWidth = $(window).width();
    if (windowWidth > 480) {
        document.write('<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5mz4gy0w2d8&amp;m=0&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33" async="async">  <\/script>');
    }
</script>
        </div>
        <p>
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>

</p>
        <p>
            <span>本网站总字数：832.4k</span>
            <span id="sitetime"></span>
        </p>
        <p>部分内容来源于互联网，用于个人知识的总结，如有侵权还请联系删除</p>
        <p>
            
            <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i
                    class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>

    <div class="bottom">
        <p>
            <span>Copyright &copy; 2019 - 2024 <a
                href="http://pdouyin.com/" target="_blank">秦伟的个人博客</a> All Rights Reserved.</span>
            <!-- <span>
                
                
            </span> -->
        </p>
    </div>
</footer>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2019, 8, 25, 18, 0, 0); // 北京时间
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "已安全运行 " + diffYears + "年 " + diffDays + "天 " + diffHours + "小时 " + diffMinutes + "分钟 " + diffSeconds + "秒";
    }
    siteTime();
</script>
</main>
<div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://qw66.gitee.io/interview/javascript.html&title=《JavaScript》 — 秦伟博客&pic=https://qw66.gitee.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://qw66.gitee.io/interview/javascript.html&title=《JavaScript》 — 秦伟博客&source=前端、全栈、SEO的知识点、面试题与学习链接的整理" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://qw66.gitee.io/interview/javascript.html" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JavaScript》 — 秦伟博客&url=https://qw66.gitee.io/interview/javascript.html&via=https://qw66.gitee.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://qw66.gitee.io/interview/javascript.html" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACKUlEQVR42u3aS27jMBAFwNz/0p5tgEDye2x7AJGllRBLJsuLDvvz8xNfr1/X779cPZM8eXX/9/mPXRgYGI9lvG6v5Jmrt+433cLuV8HAwDiBkX/1/QJJCL5fpWVjYGBgtPctrz2AYmBgYKwxkuQzPzhiYGBgTJLY+8XyDSWffjEXx8DAeCAjr7r///uv9DcwMDAexVgr90+K+/nPVOwKAwNja0Ye4NrDWXs0TJLqNykxBgbGwYw2WR1tJRgjq6uGGBgYD2dMyl5rrYX2yWTgAwMDY2/GNypXyXbzTxePjxgYGJsy8qS0bSvmYxb5WxgYGOcw2gWSr8431w5tRAdBDAyMrRltapqPZ60F1qIUiIGBcQAjCZp5+pofKPNNv8FjYGBszcgPdvO2ZYLJC22XnVgMDIztGJMk9us9ismwBQYGxtaMNq1th8bmobaYGcHAwNiI0Q5mtWG3HQhrwzEGBsbejMWjWPlWG6Y/daDEwMDYlZEssLbMvEhXYDAwMLZj1GNYcZBtm535wfSy6IaBgXEAIx+waFueeWtzMaHFwMA4gDEfM20HKdqNvvk3gIGBsSnjVV6Tsn7bKC1CMAYGxtaMths4GfZa+4Z2iBYDA2NXRhJkJwfHSVmt7rtiYGBszZgEvvZnmkyCFI0BDAyM4xn5aFdeaFt7EgMDAyMpn+WYtTJZtBYGBsYBjHzAIlmgDc15KxQDA+NMxlrqOCG1W/xYIxMDA+N5jH9eOXRyDLdnrQAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '(つェ⊂)咦!跑去哪里了';
            clearTimeout(titleTime);
        } else {
            document.title = '欢迎回来━(*｀∀´*)ノ';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>




<!-- 点击特效 -->
<script type="text/javascript" src="/js/clicklove.js"></script>
<!--动态线条背景-->
<script type="text/javascript"
        color="220,220,220" opacity='0.7' zIndex="-2" count="200"
        src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>
<!-- 雪花特效 -->
<script type="text/javascript" src="/js/jquery-3.4.1.js"></script>
<script type="text/javascript">
    var windowWidth = $(window).width();
    if (windowWidth > 480) {
        document.write('<script type="text/javascript" src="/js/snow.js"><\/script>');
    }
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"position":"right","width":150,"height":300,"hOffset":-25,"vOffset":30},"mobile":{"show":false,"scale":1.2},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script><script>!function(e){var r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function t(){for(var c=0;c<r.length;c++)t=r[c],void 0,0<=(n=t.getBoundingClientRect()).top&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=r[c];t=o,n=function(){r=r.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}t(),e.addEventListener("scroll",function(){!function(t,n){clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)}(t,e)})}(this);</script></body>
</html>

<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>前端权限开发 | 秦伟博客 | 前端、全栈、SEO的知识点、面试题与学习链接的整理</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="权限">
    <meta name="description" content="前端权限开发——设计到实践（保姆级）1.权限控制的方案选择。做后台项目区别于做其它的项目，权限验证与安全性是非常重要的，可以说是一个后台项目一开始就必须考虑和搭建的基础核心功能。在后台管理系统中，实现权限控制可以采用多种方案：    权限方案类型 描述    基于角色的访问控制（Role-Based Access Control，RBAC） 是一种广泛采用的权限控制方案。系统中定义了不同的角色，每">
<meta name="keywords" content="权限">
<meta property="og:type" content="article">
<meta property="og:title" content="前端权限开发">
<meta property="og:url" content="https://qw8.github.io/qw8/articles/qian-duan-quan-xian-kai-fa.html">
<meta property="og:site_name" content="秦伟博客">
<meta property="og:description" content="前端权限开发——设计到实践（保姆级）1.权限控制的方案选择。做后台项目区别于做其它的项目，权限验证与安全性是非常重要的，可以说是一个后台项目一开始就必须考虑和搭建的基础核心功能。在后台管理系统中，实现权限控制可以采用多种方案：    权限方案类型 描述    基于角色的访问控制（Role-Based Access Control，RBAC） 是一种广泛采用的权限控制方案。系统中定义了不同的角色，每">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:updated_time" content="2024-05-10T09:29:21.379Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端权限开发">
<meta name="twitter:description" content="前端权限开发——设计到实践（保姆级）1.权限控制的方案选择。做后台项目区别于做其它的项目，权限验证与安全性是非常重要的，可以说是一个后台项目一开始就必须考虑和搭建的基础核心功能。在后台管理系统中，实现权限控制可以采用多种方案：    权限方案类型 描述    基于角色的访问控制（Role-Based Access Control，RBAC） 是一种广泛采用的权限控制方案。系统中定义了不同的角色，每">
<meta name="twitter:image" content="https://qw8.github.io/img/loading.gif">
    
        <link rel="alternate" type="application/atom+xml" title="秦伟博客" href="/qw8/atom.xml">
    
    <link rel="shortcut icon" href="/qw8/img/qw.ico">
    <link rel="stylesheet" href="/qw8/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
<div id="loading" class="active"></div>

<aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/qw8/img/brand.jpg)">
      <div class="brand">
        <a href="/qw8/" class="avatar waves-effect waves-circle waves-light">
          <img src="/qw8/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">秦伟</h5>
          <a href="mailto:124729081@qq.com" title="124729081@qq.com" class="mail">124729081@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/qw8/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/qw8/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/qw8/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/qw8/archives"  >
                <i class="icon icon-lg icon-hourglass"></i>
                时光
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://wpa.qq.com/msgrd?v=3&uin=124729081&site=qq&menu=yes" target="_blank" >
                <i class="icon icon-lg icon-qq"></i>
                聊天
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=124729081@qq.com"  >
                <i class="icon icon-lg icon-envelope-o"></i>
                邮箱
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/qw8/user"  >
                <i class="icon icon-lg icon-user"></i>
                简介
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://gitee.com/qw66" target="_blank" >
                <i class="icon icon-lg icon-code"></i>
                Gitee
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/qw8" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

<main id="main">
    <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">前端权限开发</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">前端权限开发</h1>
        <h5 class="subtitle">
            
                <time datetime="2023-12-15T16:00:00.000Z" itemprop="datePublished" class="page-time">
  2023-12-16
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/qw8/categories/前端文章/">前端文章</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#前端权限开发——设计到实践（保姆级）"><span class="post-toc-number">1.</span> <span class="post-toc-text">前端权限开发——设计到实践（保姆级）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-权限控制的方案选择。"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">1.权限控制的方案选择。</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-RBAC下的权限字段设计与管理模型"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">2.RBAC下的权限字段设计与管理模型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-用户权限授权"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">1.用户权限授权</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-权限管理模型"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">2.权限管理模型</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-实现思路与步骤"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">3.实现思路与步骤</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-登录"><span class="post-toc-number">1.3.0.1.</span> <span class="post-toc-text">1.登录</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-路由守卫与权限校验"><span class="post-toc-number">1.3.0.2.</span> <span class="post-toc-text">2.路由守卫与权限校验</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-获取角色信息与权限信息"><span class="post-toc-number">1.3.0.3.</span> <span class="post-toc-text">3.获取角色信息与权限信息</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-谁来生成动态路由表？"><span class="post-toc-number">1.3.0.4.</span> <span class="post-toc-text">4.谁来生成动态路由表？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-公共路由和动态路由"><span class="post-toc-number">1.3.0.5.</span> <span class="post-toc-text">5.公共路由和动态路由</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#公共路由"><span class="post-toc-number">1.3.0.5.1.</span> <span class="post-toc-text">公共路由</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#动态路由-私有路由）"><span class="post-toc-number">1.3.0.5.2.</span> <span class="post-toc-text">动态路由(私有路由）</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#6-RBAC的权限配置项"><span class="post-toc-number">1.3.0.6.</span> <span class="post-toc-text">6.RBAC的权限配置项</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-获取动态路由（私有路由）并转换"><span class="post-toc-number">1.3.0.7.</span> <span class="post-toc-text">7.获取动态路由（私有路由）并转换</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#generatorDynamicRouter方法（promise嵌套）"><span class="post-toc-number">1.3.0.7.1.</span> <span class="post-toc-text">generatorDynamicRouter方法（promise嵌套）</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#generator方法（递归转化）"><span class="post-toc-number">1.3.0.7.2.</span> <span class="post-toc-text">generator方法（递归转化）</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#8-存储格式化好的动态路由及导航栏菜单信息"><span class="post-toc-number">1.3.0.8.</span> <span class="post-toc-text">8.存储格式化好的动态路由及导航栏菜单信息</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-添加动态路由"><span class="post-toc-number">1.3.0.9.</span> <span class="post-toc-text">9.添加动态路由</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#10-登出"><span class="post-toc-number">1.3.0.10.</span> <span class="post-toc-text">10.登出</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-按钮级权限"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">4.按钮级权限</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-指令-组件封装形式的按钮级权限"><span class="post-toc-number">1.4.0.1.</span> <span class="post-toc-text">1.指令/组件封装形式的按钮级权限</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-条件渲染形式的按钮级权限"><span class="post-toc-number">1.4.0.2.</span> <span class="post-toc-text">2.条件渲染形式的按钮级权限</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#后台系统按钮级别权限控制两种方案，自定义指令和条件控制的优缺点"><span class="post-toc-number">1.4.0.3.</span> <span class="post-toc-text">后台系统按钮级别权限控制两种方案，自定义指令和条件控制的优缺点</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#自定义指令方案"><span class="post-toc-number">1.4.0.3.1.</span> <span class="post-toc-text">自定义指令方案</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#条件控制方案"><span class="post-toc-number">1.4.0.3.2.</span> <span class="post-toc-text">条件控制方案</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#总结"><span class="post-toc-number">1.4.0.3.3.</span> <span class="post-toc-text">总结</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#如何结合使用自定义指令和条件控制"><span class="post-toc-number">1.4.0.4.</span> <span class="post-toc-text">如何结合使用自定义指令和条件控制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#1-定义自定义指令"><span class="post-toc-number">1.4.0.4.1.</span> <span class="post-toc-text">1. 定义自定义指令</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-使用条件渲染"><span class="post-toc-number">1.4.0.4.2.</span> <span class="post-toc-text">2. 使用条件渲染</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#3-结合使用"><span class="post-toc-number">1.4.0.4.3.</span> <span class="post-toc-text">3. 结合使用</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#4-注意事项"><span class="post-toc-number">1.4.0.4.4.</span> <span class="post-toc-text">4. 注意事项</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-遇到的坑"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">5.遇到的坑</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-结束与优化"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">6.结束与优化</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-articles/前端权限开发"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">前端权限开发</h1>
        <div class="post-meta">
            <time class="post-time" title="2023-12-16 00:00:00" datetime="2023-12-15T16:00:00.000Z"  itemprop="datePublished">2023-12-16</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/qw8/categories/前端文章/">前端文章</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="前端权限开发——设计到实践（保姆级）"><a href="#前端权限开发——设计到实践（保姆级）" class="headerlink" title="前端权限开发——设计到实践（保姆级）"></a>前端权限开发——设计到实践（保姆级）</h1><h2 id="1-权限控制的方案选择。"><a href="#1-权限控制的方案选择。" class="headerlink" title="1.权限控制的方案选择。"></a>1.权限控制的方案选择。</h2><p>做后台项目区别于做其它的项目，权限验证与安全性是非常重要的，可以说是一个后台项目一开始就必须考虑和搭建的基础核心功能。在后台管理系统中，实现权限控制可以采用多种方案：</p>
<table>
<thead>
<tr>
<th>权限方案类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>基于角色的访问控制（Role-Based Access Control，RBAC）</td>
<td>是一种广泛采用的权限控制方案。系统中定义了不同的角色，每个角色具有一组权限，而用户被分配到一个或多个角色。通过控制用户角色的分配，可以实现对用户访问系统中不同功能和资源的权限控制。</td>
</tr>
<tr>
<td>基于权限的访问控制（Permission-Based Access Control）</td>
<td>这种方案将权限直接分配给用户，而不是通过角色来管理。每个用户都有自己的权限列表，控制用户对系统中各项功能和资源的访问。</td>
</tr>
<tr>
<td>基于资源的访问控制（Resource-Based Access Control，RBAC）</td>
<td>这种方案将权限控制与资源本身关联起来。系统中的每个资源都有自己的访问权限，用户通过被授予资源的访问权限来控制其对资源的操作。</td>
</tr>
<tr>
<td>层次结构权限控制（Hierarchical Access Control）</td>
<td>这种方案基于资源和操作的层次结构来进行权限控制。系统中的资源和操作被组织成层次结构，用户被授予访问某个层次及其子层次的权限。</td>
</tr>
<tr>
<td>基于规则的访问控制（Rule-Based Access Control）</td>
<td>这种方案使用预定义的规则来确定用户对系统中功能和资源的访问权限。规则可以基于用户属性、环境条件或其他因素进行定义。</td>
</tr>
</tbody></table>
<p>这里我选择了<strong>基于角色的访问控制（Role-Based Access Control，RBAC）</strong> 这是因为RBAC提供了一种灵活且易于管理的方式来控制用户对系统功能和资源的访问，也是目前最主流的前端权限方案选择。</p>
<p>在RBAC中，系统中的功能和资源被组织成角色，而用户则被分配到不同的角色。每个角色都有一组权限，定义了该角色可以执行的操作和访问的资源。通过给用户分配适当的角色，可以实现对用户的权限控制。</p>
<p>RBAC的好处之一是它简化了权限管理的复杂性。管理员只需管理角色和分配角色给用户，而不需要为每个用户单独定义权限。当需要对用户的权限进行修改时，只需调整其角色的权限即可。</p>
<p>此外，RBAC还支持灵活的权限组合，允许创建具有不同权限组合的角色，以适应不同用户的需求。它也便于扩展，可以随着系统的发展和需求的变化而调整和添加角色。</p>
<h2 id="2-RBAC下的权限字段设计与管理模型"><a href="#2-RBAC下的权限字段设计与管理模型" class="headerlink" title="2.RBAC下的权限字段设计与管理模型"></a>2.RBAC下的权限字段设计与管理模型</h2><h3 id="1-用户权限授权"><a href="#1-用户权限授权" class="headerlink" title="1.用户权限授权"></a>1.用户权限授权</h3><p>是对用户身份认证的细化。可简单理解为访问控制，在用户身份认证通过后，系统对用户访问菜单或按钮进行控制。也就是说，该用户有身份进入系统了，但他不一定能访问系统里的所有菜单或按钮，而他只能访问管理员给他分配的权限菜单或按钮。<br> 主要包括：</p>
<ul>
<li>Permission（权限标识、权限字符串）：针对系统访问资源的权限标识，如：用户添加、用户修改、用户删除。</li>
<li>Role （角色）：可以理解为权限组，也就是说角色下可以访问和点击哪些菜单、访问哪些权限标识。</li>
</ul>
<p>权限标识或权限字符串校验规则：</p>
<ul>
<li>权限字符串：指定权限串必须和菜单中的权限标识匹配才可访问</li>
<li><strong>权限字符串命名规范为：<code>模块:功能:操作</code>，例如：<code>sys:user:edit</code></strong></li>
<li>使用冒号分隔，对授权资源进行分类，如 <code>sys:user:edit</code> 代表 <code>系统模块:用户功能:编辑操作</code></li>
<li>设定的功能指定的<code>权限字符串</code>与当前用户的<code>权限字符串</code>进行匹配，若匹配成功说明当前用户有该功能权限</li>
<li>还可以使用简单的通配符，如 <code>sys:user:*</code>，建议省略为 <code>sys:user</code>（分离前端不能使用星号写法）</li>
<li>举例1 <code>sys:user</code> 将于 <code>sys:user</code> 或 <code>sys:user:</code> 开头的所有权限字符串匹配成功</li>
<li>举例2 <code>sys</code> 将于 <code>sys</code> 或 <code>sys:</code> 开头的所有权限字符串匹配成功 这种命名格式的好处有：</li>
</ul>
<ol>
<li><strong>可读性和可理解性</strong>：使用模块、功能和操作的格式可以直观地表达权限的含义。每个部分都有明确的作用，模块表示特定的模块或子系统，功能表示模块内的某个功能或页面，操作表示对功能进行的具体操作。通过这种格式，权限名称可以更容易地被开发人员、管理员和其他人员理解和解释。</li>
<li><strong>可扩展性和灵活性：</strong> 通过使用模块、功能和操作的格式，可以轻松地扩展和管理权限。每个模块、功能和操作都可以被单独定义和控制。当系统需要增加新的功能或操作时，可以根据需要添加新的权限字符串，而不需要修改现有的权限规则和代码。</li>
<li><strong>细粒度的权限控制：</strong> 这种格式支持细粒度的权限控制，可以针对特定的功能和操作进行权限管理。通过将权限名称拆分为模块、功能和操作，可以精确地定义哪些用户或角色具有访问或操作特定功能的权限。</li>
<li><strong>避免权限冲突：</strong> 使用模块、功能和操作的格式可以避免权限之间的冲突。不同模块、功能和操作的权限名称是唯一的，这样可以避免同名权限之间的混淆和冲突。</li>
</ol>
<h3 id="2-权限管理模型"><a href="#2-权限管理模型" class="headerlink" title="2.权限管理模型"></a>2.权限管理模型</h3><p>关键数据模型如下：</p>
<ul>
<li>用户：登录账号、密码、角色</li>
<li>角色：角色名称、角色权限字符、对应菜单、对应菜单下的权限</li>
<li>菜单：菜单名称、菜单URL、菜单类型</li>
<li>用户角色关系：用户编码、角色编码</li>
<li>角色菜单关系：角色编码、菜单编码</li>
</ul>
<p>关系图如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【用户】  &lt;---多对多---&gt;  【角色】  &lt;---多对多---&gt;  【菜单/权限】</span><br></pre></td></tr></table></figure>

<h2 id="3-实现思路与步骤"><a href="#3-实现思路与步骤" class="headerlink" title="3.实现思路与步骤"></a>3.实现思路与步骤</h2><p>前端权限一般分为路由级权限和按钮级权限，这里我们先实现页面路由级的权限功能，按钮级的会在后面讲到。大致的思路如下图：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c877eecd8dcb49c89cd5a294331804a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="飞书20230324-135033.png" title>
                </div>
                <div class="image-caption">飞书20230324-135033.png</div>
            </figure> 上图是用户从`登录-->路由守卫-->权限验证-->构建路由表-->跳转目标页面`的一个简单的正向流程，可以看到，`权限验证`和`构建路由表`这两步是发生在`路由守卫`这一步里，而实际上在开发设计阶段，我们还要做的准备有：

<ol>
<li>与后端确认权限字段及类型</li>
<li>确定路由表信息是由前端还是后端生成</li>
</ol>
<p>为了方便理解，我们就按照这个正向流程来逐步实现，期间需要用到或者提前考虑设计到的内容，包括以上需要准备的两点，我会补充在步骤当中。</p>
<h4 id="1-登录"><a href="#1-登录" class="headerlink" title="1.登录"></a>1.登录</h4><p>登录成功后，获取到token,将token存到本地的sessionStorage里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// action.js</span><br><span class="line">async login(&#123; commit &#125;, userInfo) &#123;</span><br><span class="line">    const &#123; data &#125; = await login(userInfo)</span><br><span class="line">    const accessToken = &apos;Bearer &apos; + data.access_token</span><br><span class="line">    if (accessToken) &#123;</span><br><span class="line">      sessionStorage.getItem(tokenTableName)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      message.error(`登录接口异常，未正确返回$&#123;tokenName&#125;...`)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>接着，进行路由跳转到首页</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// login.vue</span><br><span class="line">import &#123; useRouter &#125; from &apos;vue-router&apos;;</span><br><span class="line">const router = useRouter(); </span><br><span class="line">router.push(&apos;/&apos;);</span><br></pre></td></tr></table></figure>

<p>如果考虑到页面token失效后，重新登陆后返回原先的路由地址，则需要在路由守卫中添加<code>redirect</code>字段用来存储当前的路由地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// permissions.js</span><br><span class="line">next(&#123; path: &apos;/login&apos;, query: &#123; redirect: to.fullPath &#125;, replace: true &#125;)</span><br></pre></td></tr></table></figure>

<p>然后在登录页中，监听路由对象中的这个值，如果有值，那么在刚刚路由跳转时，就跳转到该路由地址，而非<code>/</code>首页，另外，还需要考虑到403，404页面。所以，添加了这些逻辑后，部分代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// login.vue</span></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref, watch, useRouter &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">'vue-router'</span>;</span><br><span class="line"><span class="keyword">const</span> redirect = ref(<span class="string">'/'</span>);</span><br><span class="line"><span class="keyword">const</span> router = useRouter();</span><br><span class="line"></span><br><span class="line">watch(</span><br><span class="line">  () =&gt; router.currentRoute.value.query.redirect,</span><br><span class="line">  (redirectValue) =&gt; &#123;</span><br><span class="line">    redirect.value = redirectValue || <span class="string">'/'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">immediate</span>: <span class="literal">true</span> &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleRoute</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redirect.value === <span class="string">'/404'</span> || redirect.value === <span class="string">'/403'</span></span><br><span class="line">          ? <span class="string">'/'</span></span><br><span class="line">          : redirect.value</span><br><span class="line">      &#125;,</span><br><span class="line">      </span><br><span class="line"> <span class="keyword">async</span> handleSubmit() &#123;</span><br><span class="line">        loading.value = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">await</span> login(form.value)</span><br><span class="line">          loading.value = <span class="literal">false</span></span><br><span class="line">          router.push(handleRoute());</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">         loading.value = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,      </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-路由守卫与权限校验"><a href="#2-路由守卫与权限校验" class="headerlink" title="2.路由守卫与权限校验"></a>2.路由守卫与权限校验</h4><p>当进行路由跳转时，会进入到路由守卫中，在路由守卫中：</p>
<ol>
<li>路由守卫会首先判断有没有token，如果没有，先判断要去的路由地址是否包含在路由白名单内，如果要去的路由地址也不在路由白名单内，就会让用户跳转到登录页重新登陆。</li>
<li>如果有token，会先判断跳转的目标地址是否是登录页，如果是，则重新跳转到默认首页</li>
<li>此时，我们就需要对用户权限进行校验，首先，判断当前用户是否<code>拥有角色</code>信息,如果没有，就要获取用户的角色信息。</li>
</ol>
<h4 id="3-获取角色信息与权限信息"><a href="#3-获取角色信息与权限信息" class="headerlink" title="3.获取角色信息与权限信息"></a>3.获取角色信息与权限信息</h4><p>调取用户信息接口获取用户角色信息和权限信息,代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//store/user</span></span><br><span class="line"> <span class="comment">// 获取用户信息</span></span><br><span class="line">  GetInfo(&#123; commit, dispatch &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      getUserInfo()</span><br><span class="line">        .then(<span class="keyword">async</span> (response) =&gt; &#123;</span><br><span class="line">          <span class="keyword">const</span> result = response.data</span><br><span class="line">          <span class="keyword">if</span> (result.roles &amp;&amp; result.roles.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 验证返回的roles是否是一个非空数组</span></span><br><span class="line">            commit(<span class="string">'SET_ROLES'</span>, result.roles)</span><br><span class="line">            <span class="comment">//permissions就是对应的用户权限信息</span></span><br><span class="line">            commit(<span class="string">'SET_PERMISSION'</span>, result.permissions)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果当前用户没有角色，则赋值一个默认角色</span></span><br><span class="line">            commit(<span class="string">'SET_ROLES'</span>, [<span class="string">'ROLE_DEFAULT'</span>]) </span><br><span class="line">          &#125;</span><br><span class="line">          resolve(result)</span><br><span class="line">          <span class="comment">// GetInfo一旦失败就说明这个token不是过期就是丢失了,直接走catch并让调用方跳转路由</span></span><br><span class="line">          <span class="keyword">if</span> (!response.success) &#123;</span><br><span class="line">            reject(response.errorMsg)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>根据之前上文提到的权限管理模型，从之间的关系是多对多，因此，<code>role(角色）</code>和<code>permssions(权限）</code>的类型应为数组，其中的权限permssion这个字段的格式规范也在上文提及。在与后端约定好后，后端返回的信息如图：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98b02dc32a454dd4add24adbaf6b8251~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png" title>
                </div>
                <div class="image-caption">image.png</div>
            </figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22ee056f3dab483f9d055afb3cdc3009~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png" title>
                </div>
                <div class="image-caption">image.png</div>
            </figure>

<h4 id="4-谁来生成动态路由表？"><a href="#4-谁来生成动态路由表？" class="headerlink" title="4.谁来生成动态路由表？"></a>4.谁来生成动态路由表？</h4><p>在成功获取到用户信息，拿到用户角色和对应权限后，此时，就需要根据权限生成对应的路由表了，到这里，我们需要思考一个问题：<br> <strong>路由表是由后端提供还是由前端提供？</strong><br> A:前端根据权限生成路由表<br> B:后端生成路由表给前端</p>
<p>没错！答案是C：路由表可以由后端提供或由前端提供。 <figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e29e88edd9a14774b1a11253f1981a7f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="9b7ce6e5503212cdd80bfe8bc78040b9.jpg" title>
                </div>
                <div class="image-caption">9b7ce6e5503212cdd80bfe8bc78040b9.jpg</div>
            </figure></p>
<p>两者的优劣分别是：</p>
<p><strong>后端提供路由表：</strong></p>
<ul>
<li>优点：<ul>
<li>安全性高：后端负责验证和控制权限，可以确保只有授权的用户能够访问特定的路由和功能。</li>
<li>隐藏敏感信息：后端可以根据用户的角色和权限隐藏不应该被访问的敏感路由和数据。</li>
<li>适用于复杂的权限规则：后端可以使用更复杂的逻辑和规则来处理权限控制，例如基于用户角色、用户组、权限等的复杂控制逻辑。</li>
</ul>
</li>
<li>缺点：<ul>
<li>前后端耦合度高：由于路由表由后端提供，前端开发人员可能需要与后端开发人员密切协作，增加了协调和沟通的成本。</li>
<li>前端依赖后端：前端应用程序可能需要等待后端提供路由表后才能进行开发和测试，增加了开发的时间和依赖性。</li>
</ul>
</li>
</ul>
<p><strong>前端提供路由表：</strong></p>
<ul>
<li>优点：<ul>
<li>前后端解耦：前端可以独立开发和维护路由表，减少了与后端的依赖性和协调成本。</li>
<li>更好的用户体验：前端可以根据用户的角色和权限动态展示路由和功能，提供更灵活和个性化的用户体验。</li>
</ul>
</li>
<li>缺点：<ul>
<li>安全性较低：前端提供的路由表容易受到篡改和绕过，安全性相对较低。</li>
<li>隐藏敏感信息的难度增加：前端无法直接隐藏敏感路由和数据，需要依赖后端接口的授权验证来保护敏感信息。</li>
</ul>
</li>
</ul>
<p>最终，考虑到后台管理系统的安全性优先级最高，我选择了由后端存储，并生成返回路由表信息。 确定好了之后，你就会遇到一个坑：<strong>后端提供的路由表无法直接在前端路由中添加使用</strong> 这是因为，后端存储的路由表的结构只一个JSON对象。怎么解决，我们放到后面讲。</p>
<h4 id="5-公共路由和动态路由"><a href="#5-公共路由和动态路由" class="headerlink" title="5.公共路由和动态路由"></a>5.公共路由和动态路由</h4><p>我们现在把整个路由分为两个部分，分别是<code>公共路由</code>和<code>动态路由（私有路由）</code>。</p>
<h5 id="公共路由"><a href="#公共路由" class="headerlink" title="公共路由"></a>公共路由</h5><p>公共路由顾名思义就是无论当前用户是什么角色，都会出现的路由部分。一般这样的路由分别有：首页驾驶舱、登录注册页、403页、404页。  <strong>这部分路由是在前端项目中提前写死的。</strong><br> 以我的项目为例，我在src/config下创建一个<code>publicRouter.js</code>文件，然后里面放入基础路由信息：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基础公共路由</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> constantRouterMap = [</span><br><span class="line">&#123;</span><br><span class="line"> path: <span class="string">'/'</span>,</span><br><span class="line"> name: <span class="string">''</span>,</span><br><span class="line"> component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/layout'</span>),</span><br><span class="line"> redirect: <span class="string">'/homePage'</span>,</span><br><span class="line"> children: [</span><br><span class="line">   &#123;</span><br><span class="line">     path: <span class="string">'/homePage'</span>,</span><br><span class="line">     name: <span class="string">'homePage'</span>,</span><br><span class="line">     component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/homePage/index.vue'</span>),</span><br><span class="line">   &#125;,</span><br><span class="line"> ],</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"> path: <span class="string">'/login'</span>,</span><br><span class="line"> component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/login'</span>),</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"> path: <span class="string">'/403'</span>,</span><br><span class="line"> name: <span class="string">'403'</span>,</span><br><span class="line"> component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/403'</span>),</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"> path: <span class="string">'/:pathMatch(.*)*'</span>,</span><br><span class="line"> component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/404'</span>),</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<p>这里面都是路由懒加载的写法，这个没啥好说的。需要注意的是在vue3中，vue-router的版本是4.x以上，在跳转404页面时，如果你的写法是</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attribute">path</span>: <span class="string">"/404"</span>,</span><br><span class="line"> name: <span class="string">"notFound"</span>,</span><br><span class="line"> component:  () =&gt; <span class="built_in">import</span>(<span class="string">'@/views/404'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样写会提示报错，这是因为vue-router4.x的版本官方推荐引入了这种新写法，配置一个通配符路由，匹配所有未被其他具体路由匹配的路径。其中 <code>:pathMatch</code> 是参数名，而 <code>(.*)*</code> 是参数的匹配模式，它使用正则表达式来匹配任意路径。</p>
<h5 id="动态路由-私有路由）"><a href="#动态路由-私有路由）" class="headerlink" title="动态路由(私有路由）"></a>动态路由(私有路由）</h5><p>上文提到的后端返回给前端当前用户的路由表信息，其实就是私有路由，这部分的路由是动态的。那么我们只需要把<code>公共路由</code>+<code>动态路由</code>=<code>当前角色用户完整路由表</code>。然鹅，<strong>后端返回给前端的动态路由是无法直接添加到当前页面路由中的</strong>，这是因为在浏览器的前后端请求当中，信息的返回体都是以JSON字符串的数据交换格式进行传输，而JSON字符串是不支持函数的。为什么要提到函数形式呢？<br> <strong>因为当我们在路由表使用懒加载的写法时，<code>component</code>的值是一个异步函数。也只有异步函数才能实现对路由的异步懒加载。import（）会返回一个promise，这个 promise 最终会加载对应的组件模块。在格式上表现为一个func函数，因此，我们无法将compnent的值传给后端存储</strong><br> 但是办法总比困难多，我们可以将对应的路径字符串传给后端存储，然后再通过后端返回的路径字符串转换成这种箭头函数的写法。<br> 除了这个需要转换以外，我们还要考虑一些问题：</p>
<ol>
<li>比如，转换后的路由结构要符合router中的路由格式，否则会在调用router.addRoutes时报错，添加失败。</li>
<li>添加一些其他自定义属性（例如添加导航栏菜单图标、某个路由的显隐、路由缓存、跳转外链接、…），以满足特定需求。<br> 以我项目中的的路由示例，直接上代码看：</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "path": "/",  //path,路由的路径，即访问该路由时的 URL 路径。</span><br><span class="line">    "name": "homePage",//name,路由的名称，用于在代码中标识路由。通常用于编程式导航。</span><br><span class="line">    "hidden": false,//hidden,是否隐藏路由，在Vue Router 4.0 中被废弃。</span><br><span class="line">    "component": "Layout"//路由对应的组件，可以是通过懒加载方式导入的异步组件，或直接引入的同步组件。</span><br><span class="line">    "meta": &#123;//meta,路由元信息，可以用于存储一些额外的信息，比如页面标题、权限等</span><br><span class="line">        "title": "首页",   //路由标题</span><br><span class="line">        "icon": "icon-Home", //路由图标</span><br><span class="line">        "target": "", //是否跳转新页签</span><br><span class="line">        "permission": "homePage",//权限</span><br><span class="line">        "keepAlive": false//是否缓存</span><br><span class="line">    &#125;,</span><br><span class="line">    "redirect": "/homePage",//重定向</span><br><span class="line">    "fullPath": "/",//完整的url路径，会带上？后面的参数</span><br><span class="line">    "children": [//子路由</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"path"</span>: <span class="string">"/homePage"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"homePage"</span>,</span><br><span class="line">            <span class="attr">"meta"</span>: &#123;</span><br><span class="line">                <span class="attr">"title"</span>: <span class="string">"首页"</span>,</span><br><span class="line">                <span class="attr">"icon"</span>: <span class="string">""</span>,</span><br><span class="line">                <span class="attr">"target"</span>: <span class="string">""</span>,</span><br><span class="line">                <span class="attr">"permission"</span>: <span class="string">"homePage"</span>,</span><br><span class="line">                <span class="attr">"keepAlive"</span>: <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"fullPath"</span>: <span class="string">"/homePage"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑完这些之后，我们就开始拿着后端返回的路由表信息动手转换吧！ 先看看后端返回给前端的路由表格式内容</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d2b8f49dac546bd8813923e1882a4ac~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png" title>
                </div>
                <div class="image-caption">image.png</div>
            </figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a90144671a74d8b9c286bce9da788b6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png" title>
                </div>
                <div class="image-caption">image.png</div>
            </figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/489bf32154da4cd684cbb50eb850161b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png" title>
                </div>
                <div class="image-caption">image.png</div>
            </figure> 这里你只需要注意component这个字段的值就行了。
<p> 可能有人会问：<strong>“那我给后端传的路由表是什么格式的，也是这样吗？”</strong><br> 答案是：<strong>当然不是！RBAC权限方案中，用户可以自己配置权限，也就是会有对应的用户管理，角色管理，菜单（权限）管理这三个基本的模块，给后端传的是对应模块的修改配置内容。前端是不需要关心传给后端什么格式。</strong> 有点啰嗦了，总之，就是你指着上文这三张图片，让后端给你生成出来就完事了。后端要是说办不到，那就是后端的问题。<br> <figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c25c2d91918d4035943ec7991671d2e6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="297708da4a493456bfcab94617c1ac55.jpg" title>
                </div>
                <div class="image-caption">297708da4a493456bfcab94617c1ac55.jpg</div>
            </figure></p>
<h4 id="6-RBAC的权限配置项"><a href="#6-RBAC的权限配置项" class="headerlink" title="6.RBAC的权限配置项"></a>6.RBAC的权限配置项</h4><p>上文提到了三个基本的配置模块，分别是<code>用户管理</code>，<code>角色管理</code>，<code>菜单（权限）管理</code>,按照先后顺序，我们首先要新建一个权限，<code>在页面级的权限中，权限是跟每个页面路由一一对应的</code>，所以当我们需要新建一个权限的时候，也就是在新建一个页面路由。而为了方便知道所有页面权限之间的层级关系，最终的展现形式就是一个<strong>树形表格结构</strong>：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7655538c1a814518ab24d3f2c12b6ede~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png" title>
                </div>
                <div class="image-caption">image.png</div>
            </figure>
<p> 可以看到，在页面路由（权限）配置项里，单个路由的各个都可以进行修改配置，这就让整个项目的路由表的可维护性和灵活度都极大的提高。需要注意的是<code>路由地址</code>和<code>组件路径</code>这两个配置项，路由地址可以随意命名，但是<strong>同层级下，必须唯一</strong>。<br> 而组件路径里面的值就是<strong>相对src目录的相对路径</strong>。比如我新建一个部门管理页面权限，一般在前端路由中的懒加载写法是这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/login'</span>),</span><br></pre></td></tr></table></figure>

<p>但在这个配置项中，只需要填入login这个字段就行了。原因是因为前面的这些字段会在后面对路由的格式化中进行处理。虽然后续步骤会讲到这一步，但这里我还是先贴出来，方便你理解：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">component:</span><br><span class="line">       constantRouterComponents[item.component || item.key] ||</span><br><span class="line">       (<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">         <span class="keyword">import</span>(<span class="string">`@/views/<span class="subst">$&#123;item.component&#125;</span>`</span>).catch(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">           <span class="keyword">import</span>(<span class="string">'@/views/404'</span>)</span><br><span class="line">         )),</span><br></pre></td></tr></table></figure>

<p>那有人就会问，如果我乱填一个不存在的组件路径地址怎么办？正常情况下这样会导致整个动态路由在构建过程中报错，从而导致白屏。所以，上述代码里的<code>.catch</code>会捕获这个错误，然后跳转到404页面，再从404页面跳转到首页。就像这样：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18ffa074616f45a09a0c4e03e80698a7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png" title>
                </div>
                <div class="image-caption">image.png</div>
            </figure> 当我们配置好权限后，会将新增的路由配置信息发送给后端，**后端根据这些配置信息，会在对应的路由表中添加这个路由，并生成新的路由表返回给前端**。
<p> 那当我们有一个权限之后，该怎么配置给对应的用户呢？还记得我上文提及的RBAC的权限管理模型嘛：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e147dc7693b04501af601fd2ecc0667b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png" title>
                </div>
                <div class="image-caption">image.png</div>
            </figure>
<p> 就是按照关系图中，我们将权限分配给角色，所以，就要有<code>角色管理</code>这个模块来进行分配：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15a5414b8de44b4a84732266675d07f0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png" title>
                </div>
                <div class="image-caption">image.png</div>
            </figure>
<p> <code>用户管理</code>也是依葫芦画瓢，跟<code>角色管理</code>如出一辙，碍于篇幅，就不再过多赘述。每一个配置项都可以根据你的业务场景和需要，进行增减。</p>
<h4 id="7-获取动态路由（私有路由）并转换"><a href="#7-获取动态路由（私有路由）并转换" class="headerlink" title="7.获取动态路由（私有路由）并转换"></a>7.获取动态路由（私有路由）并转换</h4><p>言归正传，接下来，这一步是整个前端权限中最重要的一步。在src/router下，我们新建一个generatorRouters.js文件。里面的内容是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getCurrentUserNav获取动态路由的接口</span></span><br><span class="line"><span class="keyword">import</span> &#123; getCurrentUserNav &#125; <span class="keyword">from</span> <span class="string">'@/api/user'</span></span><br><span class="line"><span class="comment">//validURL是一个正则判断方法，用来校验当前字符串是否符合url外链格式</span></span><br><span class="line"><span class="keyword">import</span> &#123; validURL &#125; <span class="keyword">from</span> <span class="string">'@/utils/validate'</span></span><br><span class="line"><span class="comment">// 前端路由表</span></span><br><span class="line"><span class="keyword">const</span> constantRouterComponents = &#123;</span><br><span class="line">  <span class="comment">// 基础页面 layout 必须引入</span></span><br><span class="line">  Layout: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/layout'</span>),</span><br><span class="line">  <span class="number">403</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/403'</span>),</span><br><span class="line">  <span class="number">404</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/404'</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态生成菜单</span></span><br><span class="line"><span class="comment"> * @param token</span></span><br><span class="line"><span class="comment"> * @returns &#123;Promise&lt;Router&gt;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> generatorDynamicRouter = <span class="function">(<span class="params">token</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    getCurrentUserNav()</span><br><span class="line">      .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="comment">//接收后端返回的路由表，结构是个数组</span></span><br><span class="line">        <span class="keyword">let</span> menuNav = res.data</span><br><span class="line">        <span class="comment">//将路由表存到本地临时缓存中</span></span><br><span class="line">        <span class="comment">//这一步是为了刷新的时候不需要再调接口，增加用户体验的，没这方面需求可以不用写</span></span><br><span class="line">        sessionStorage.setItem(<span class="string">'generateRoutes'</span>, <span class="built_in">JSON</span>.stringify(menuNav))</span><br><span class="line">        <span class="comment">//转化路由格式</span></span><br><span class="line">        <span class="keyword">const</span> routers = generator(menuNav)</span><br><span class="line">        resolve(routers)</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 格式化树形结构数据 生成 vue-router 层级路由表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param routerMap //当前路由表route</span></span><br><span class="line"><span class="comment"> * @param parent//当前路由表route的父级component</span></span><br><span class="line"><span class="comment"> * @returns &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> generator = <span class="function">(<span class="params">routerMap, parent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> routerMap.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; title, show, hideChildren, hiddenHeaderContent, icon, hidden &#125; =</span><br><span class="line">      item.meta || &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (item.component) &#123;</span><br><span class="line">      <span class="comment">// Layout ParentView 组件特殊处理</span></span><br><span class="line">      <span class="comment">//这里是对父组件/布局组件的处理，因为有可能出现嵌套布局和多种布局的情况，这个时候需要进行处理。</span></span><br><span class="line">      <span class="keyword">if</span> (item.component === <span class="string">'Layout'</span>) &#123;</span><br><span class="line">        item.component = <span class="string">'Layout'</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.component === <span class="string">'ParentView'</span>) &#123;</span><br><span class="line">        item.component = <span class="string">'BasicLayout'</span></span><br><span class="line">        item.path = <span class="string">'/'</span> + item.path</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (item.isFrame === <span class="number">0</span>) &#123;</span><br><span class="line">      item.target = <span class="string">'_blank'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> currentRouter = &#123;</span><br><span class="line">      <span class="comment">// 如果路由设置了 path，则作为默认 path，否则 路由地址 动态拼接生成如 /dashboard/workplace</span></span><br><span class="line">      path: item.path || <span class="string">`<span class="subst">$&#123;(parent &amp;&amp; parent.path) || <span class="string">''</span>&#125;</span>/<span class="subst">$&#123;item.key&#125;</span>`</span>,</span><br><span class="line">      <span class="comment">// 路由名称，建议唯一</span></span><br><span class="line">      <span class="comment">// name: item.name || item.key || '',</span></span><br><span class="line">      name: item.name || item.key || <span class="string">''</span>,</span><br><span class="line">      <span class="comment">// 该路由对应页面的 组件 :方案1</span></span><br><span class="line">      <span class="comment">// 该路由对应页面的 组件 :方案2 (动态加载)</span></span><br><span class="line">      <span class="comment">//这里就是将component的字符串值转换成懒加载的异步函数</span></span><br><span class="line">      <span class="comment">//同时，如果当前路径并没有对应的组件，catch捕获报错，然后跳转到404页，这一步很重要，否则</span></span><br><span class="line">      component:</span><br><span class="line">        constantRouterComponents[item.component || item.key] ||</span><br><span class="line">        (<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">          <span class="keyword">import</span>(<span class="string">`@/views/<span class="subst">$&#123;item.component&#125;</span>`</span>).catch(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">            <span class="keyword">import</span>(<span class="string">'@/views/404'</span>)</span><br><span class="line">          )),</span><br><span class="line">      hidden: item.hidden,</span><br><span class="line">      <span class="comment">// redirect: '/' + item.path || `$&#123;parent &amp;&amp; parent.path || ''&#125;/$&#123;item.key&#125;`,</span></span><br><span class="line">      <span class="comment">// meta: 页面标题, 菜单图标, 页面权限(供指令权限用，可去掉)</span></span><br><span class="line">      meta: &#123;</span><br><span class="line">        title: title,</span><br><span class="line">        icon: icon,</span><br><span class="line">        hiddenHeaderContent: hiddenHeaderContent,</span><br><span class="line">        target: validURL(item.path) ? <span class="string">'_blank'</span> : <span class="string">''</span>,</span><br><span class="line">        permission: item.name,</span><br><span class="line">        keepAlive: <span class="literal">false</span>,</span><br><span class="line">        hidden: hidden,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//适配本框架的跳转路径</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否设置了隐藏菜单</span></span><br><span class="line">    <span class="keyword">if</span> (show === <span class="literal">false</span>) &#123;</span><br><span class="line">      currentRouter.hidden = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修正路径，而antdv-pro的pro-layout要求每个路径需为全路径</span></span><br><span class="line">    <span class="comment">//这一步的修正路径也是因人而异，正常情况下按照我这样拼接就没问题了</span></span><br><span class="line">    <span class="keyword">if</span> (!constantRouterComponents[item.component || item.key]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (parent &amp;&amp; parent.path &amp;&amp; parent.path !== <span class="string">'/'</span>) &#123;</span><br><span class="line">        currentRouter.path = <span class="string">`<span class="subst">$&#123;parent.path&#125;</span>/<span class="subst">$&#123;item.path&#125;</span>`</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否设置了隐藏子菜单</span></span><br><span class="line">    <span class="keyword">if</span> (hideChildren) &#123;</span><br><span class="line">      currentRouter.hideChildrenInMenu = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重定向</span></span><br><span class="line">    item.redirect &amp;&amp; (currentRouter.redirect = item.redirect)</span><br><span class="line">    <span class="comment">//添加fullPath</span></span><br><span class="line">    currentRouter.fullPath = currentRouter.path</span><br><span class="line">    <span class="comment">// 是否有子菜单，并递归处理</span></span><br><span class="line">    <span class="keyword">if</span> (item.children &amp;&amp; item.children.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      currentRouter.children = generator(item.children, currentRouter)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currentRouter</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="generatorDynamicRouter方法（promise嵌套）"><a href="#generatorDynamicRouter方法（promise嵌套）" class="headerlink" title="generatorDynamicRouter方法（promise嵌套）"></a>generatorDynamicRouter方法（promise嵌套）</h5><p>上面的代码有点多，不要觉得麻烦，其实就两个方法，第一个方法<code>generatorDynamicRouter</code>会调取后端接口，<strong>获取后端返回的私有路由表信息</strong>，返回的是个<code>promise对象</code>，因为需要调接口请求后端数据，并且其他方法依赖这个方法的接口返回值，所以是个异步函数。之所以这么写的另外一个原因，是因为在它之前还有个promise异步方法包着它。<br> 我们都知道：<strong>在嵌套的 Promise 中，内部的 Promise 会先执行，然后再执行外部的 Promise。这是由于 JavaScript 的异步执行机制所决定的。</strong> 所以这种套娃式的目的只有一个——<strong>就是确保外层的异步方法在调用内部异步方法时，能够保证拿到内部异步方法请求成功之后的返回值</strong>（也就是将异步方法变成同步方法，这也是Promise主要的作用之一，面试常问的）。</p>
<p>而最外层的异步方法，是放在路由守卫当中直接调用的，由于我们是动态异步加载路由，那么执行的方法肯定也是异步。具体的原因是因为：<br> <strong>如果动态加载路由的方法不是异步的，那么在路由守卫中使用它将导致它立即执行并返回一个 Promise，而不是在路由导航过程中延迟加载。这样会使得在路由守卫中的逻辑无法按预期执行，因为在组件加载完成之前，它依赖的组件可能还没有被加载，导致出现错误或不一致的状态。</strong></p>
<p><strong>从后端获取路由配置往往涉及到网络请求和异步操作，不能保证立即返回所有路由信息。当你从后端获取到路由配置后，需要将其添加到 Vue Router 中，以便在前端应用程序中进行动态路由。在这个过程中，你需要使用异步操作来确保在获取到路由配置后再添加到路由中。</strong></p>
<h5 id="generator方法（递归转化）"><a href="#generator方法（递归转化）" class="headerlink" title="generator方法（递归转化）"></a>generator方法（递归转化）</h5><p>言归正传，<code>generatorDynamicRouter</code>方法调取后端接口，拿到后端返回路由表信息后，会紧接着调用第二个<code>generator</code>方法，并将路由表信息当做参数传入。而<code>generator</code>是一个递归方法。这个也很好理解，因为路由信息里都会包含children子路由，需要层层递归，<code>generator</code>内部会对每一个路由进行<strong>逐层转化</strong>，每一步都在代码中标有注释，我就不再过多赘述了。我们只需要知道：<strong><code>generator</code>的最终目的就是将后端返回的路由表结构转化成符合前端路由格式的路由</strong>（听起来有点绕）。<br> 附上格式化好之后的路由信息： <figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6812a0c51feb43b7b01cef919c75ce3e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3d0b3b606354dbeb064da7b21d406fd~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?) 再对比下格式化之前的样子： ![image.png" title>
                </div>
                <div class="image-caption">image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3d0b3b606354dbeb064da7b21d406fd~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?) 再对比下格式化之前的样子： ![image.png</div>
            </figure> 可以看到component从字符串变成了函数，path路径也得到了拼接补充。</p>
<h4 id="8-存储格式化好的动态路由及导航栏菜单信息"><a href="#8-存储格式化好的动态路由及导航栏菜单信息" class="headerlink" title="8.存储格式化好的动态路由及导航栏菜单信息"></a>8.存储格式化好的动态路由及导航栏菜单信息</h4><p>上文提到在generatorDynamicRouter异步方法之外还有一层异步方法，其实我是放在了vuex的store下某个模块中的actions里（默认大家都会用vuex）。具体代码如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  GenerateRoutes(&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">let</span> sidebarList = []</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      generatorDynamicRouter().then(<span class="function">(<span class="params">routers</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//sidebarList是侧边栏渲染数据</span></span><br><span class="line">        sidebarList = routers</span><br><span class="line">        <span class="comment">//routers就是我们要存储到vuex中的动态路由</span></span><br><span class="line">        commit(<span class="string">'set_routers'</span>, routers)</span><br><span class="line">        <span class="comment">//侧边栏数据存到vuex中</span></span><br><span class="line">        commit(<span class="string">'set_sidebarList'</span>, sidebarList)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-添加动态路由"><a href="#9-添加动态路由" class="headerlink" title="9.添加动态路由"></a>9.添加动态路由</h4><p>好了，到这一步，我们就拿到了准备好的<code>公共路由</code>和<code>私有路由</code>。这个时候，我们再回到路由守卫，回顾一下之前的流程：</p>
<ol>
<li>路由守卫先判断token</li>
<li>没有token去登录拿token（或者是直接去了白名单里）</li>
<li>拿到token后判断有没有角色信息，没有角色信息就去请求角色信息（调接口）</li>
<li>拿到角色信息后，再去获取对应角色信息的路由表（调接口）</li>
<li>将后端返回的路由表信息转换成前端能添加的路由表信息格式</li>
<li>添加路由</li>
<li>跳转对应路由页面</li>
</ol>
<p>现在，我们来到了第6步，添加路由，在添加路由之前，先看下路由守卫：<br> 路由守卫的代码如下，在src/config目录下新建文件<code>permissions.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'@/router'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'@/store'</span></span><br><span class="line"><span class="keyword">import</span> getPageTitle <span class="keyword">from</span> <span class="string">'@/utils/pageTitle'</span></span><br><span class="line"><span class="keyword">import</span> getInfoRouter <span class="keyword">from</span> <span class="string">'@/router/getInfoRouter'</span></span><br><span class="line"><span class="keyword">import</span> &#123; loginInterception, recordRoute, routesWhiteList &#125; <span class="keyword">from</span> <span class="string">'@/config'</span></span><br><span class="line">router.beforeEach(<span class="keyword">async</span> (to, <span class="keyword">from</span>, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> hasToken = store.getters[<span class="string">'user/accessToken'</span>]</span><br><span class="line">  <span class="keyword">if</span> (hasToken) &#123;</span><br><span class="line">    <span class="keyword">if</span> (to.path === <span class="string">'/login'</span>) &#123;</span><br><span class="line">      next(&#123; <span class="attr">path</span>: <span class="string">'/'</span> &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//权限校验</span></span><br><span class="line">      <span class="keyword">if</span> (store.getters[<span class="string">'user/roles'</span>].length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取用户信息，包括角色信息和权限信息</span></span><br><span class="line">           <span class="keyword">await</span> store.dispatch(<span class="string">'user/GetInfo'</span>)</span><br><span class="line">            <span class="comment">//获取动态路由表信息，并对路由表进行格式转化，然后存到vuex中</span></span><br><span class="line">           <span class="keyword">await</span> store.dispatch(<span class="string">'async-router/GenerateRoutes'</span>)</span><br><span class="line">            <span class="comment">//从vuex中拿到动态路由表数据</span></span><br><span class="line">           <span class="keyword">let</span> accessRoutes = store.getters[<span class="string">'async-router/addRouters'</span>]</span><br><span class="line">            <span class="comment">//循环添加路由</span></span><br><span class="line">           accessRoutes.forEach(<span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//isHttp方法用来判断是否是外链，如果是外链，就不添加到当前路由表中</span></span><br><span class="line">            <span class="keyword">if</span> (!isHttp(route.path)) &#123;</span><br><span class="line">              router.addRoute(route) <span class="comment">// 动态添加可访问路由表</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="comment">//刷新跳转</span></span><br><span class="line">          next(&#123; ...to, <span class="attr">replace</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="comment">//登出</span></span><br><span class="line">          <span class="keyword">await</span> store.dispatch(<span class="string">'user/Logout'</span>)</span><br><span class="line">          <span class="comment">//记录登出前的路由地址</span></span><br><span class="line">          next(&#123; <span class="attr">path</span>: <span class="string">'/login'</span>, <span class="attr">query</span>: &#123; <span class="attr">redirect</span>: to.fullPath &#125; &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//判断是否在白名单中</span></span><br><span class="line">    <span class="keyword">if</span> (routesWhiteList.indexOf(to.path) !== <span class="number">-1</span>) &#123;</span><br><span class="line">      next()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//记录跳转到登录页之前的路由地址</span></span><br><span class="line">      next(&#123; <span class="attr">path</span>: <span class="string">'/login'</span>, <span class="attr">query</span>: &#123; <span class="attr">redirect</span>: to.fullPath &#125;, <span class="attr">replace</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">router.afterEach(<span class="function">(<span class="params">to</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//浏览器页签标题</span></span><br><span class="line">  <span class="built_in">document</span>.title = getPageTitle(to.meta.title)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>在vue-router4.x版本中</strong>，往当前的路由<code>router</code>对象中动态添加路由时，需要使用官方提供的<code>addRoute方法</code>，不能直接对router对象进行修改，这是因为vue-router必须是要vue在实例化之前就挂载上去的。<code>addRoute方法</code>传入的参数是<strong>单个路由对象</strong>,所以写法上我们需要对动态路由数组进行for循环，在内部调用<code>addRoute方法</code>，从而达到成功添加多个动态路由的目的。这里附上官方API地址链接：<a href="https://link.juejin.cn?target=https%3A%2F%2Frouter.vuejs.org%2Fzh%2Fapi%2Finterfaces%2FRouter.html%23Methods-addRoute" target="_blank" rel="noopener">router.vuejs.org/zh/api/inte…</a><br> 添加完路由之后，调用<code>next({ ...to, replace: true })</code>,就会成功跳转到目标路由地址了。</p>
<h4 id="10-登出"><a href="#10-登出" class="headerlink" title="10.登出"></a>10.登出</h4><p>当用户要退出时，也就是登出，我们只需要调用登出接口，并在接口成功返回后，重置vuex中的用户信息（token,角色roles,权限permission），同时清空本地缓存的数据就行了。附上代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @description 退出登录</span></span><br><span class="line"><span class="comment">  * @param &#123;*&#125; &#123; dispatch &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> Logout(&#123; commit, dispatch, state &#125;) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">     logout()</span><br><span class="line">       .then(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">         <span class="keyword">await</span> dispatch(<span class="string">'resetAll'</span>)</span><br><span class="line">         <span class="comment">//清空导航tab页签</span></span><br><span class="line">         <span class="keyword">this</span>.dispatch(<span class="string">'tagsBar/delAllVisitedRoutes'</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">         resolve()</span><br><span class="line">       &#125;)</span><br><span class="line">       .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">         reject(error)</span><br><span class="line">       &#125;)</span><br><span class="line">       .finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  * @description 重置accessToken、roles、permission等</span></span><br><span class="line"><span class="comment">  * @param &#123;*&#125; &#123; commit, dispatch &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">async</span> resetAll(&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">   <span class="keyword">await</span> dispatch(<span class="string">'setAccessToken'</span>, <span class="string">''</span>)</span><br><span class="line">   commit(<span class="string">'SET_ROLES'</span>, [])</span><br><span class="line">   commit(<span class="string">'SET_PERMISSION'</span>, [])</span><br><span class="line">   sessionStorage.clear()</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>

<p>到这一步，整个前端权限的流程就算是走完了。</p>
<h2 id="4-按钮级权限"><a href="#4-按钮级权限" class="headerlink" title="4.按钮级权限"></a>4.按钮级权限</h2><p>前端按钮级权限，是指在前端界面中，根据用户的权限不同，对不同的按钮进行权限控制。这样做的目的是为了确保系统的安全性和数据的保密性，使得不同用户只能执行其有权执行的操作，从而避免潜在的安全风险。<br> 上面这段定义是我copy过来的，其中这句<code>对不同的按钮进行权限控制</code>并不完全对，<strong>除了按钮，比如页面中的某个字段，某个div，某个组件要求根据当前用户的权限进行控制时，都可以称为按钮级权限</strong>。<br> 像这种按钮级权限的设计方案很多，在vue中，本人目前知道的主流方式有两种：</p>
<ul>
<li><strong>条件渲染（Conditional Rendering）：</strong> 这是一种简单有效的方法，通过在前端代码中根据用户的权限信息来决定是否渲染特定的按钮或组件。比如，你可以使用条件语句（如<code>v-if</code>、<code>ngIf</code>等）来判断用户是否有权限，从而决定是否渲染按钮。</li>
<li><strong>指令/组件封装：</strong> 使用一些前端框架（如Vue、React、Angular）提供的自定义指令或组件，可以封装权限控制逻辑。你可以创建一个自定义指令或组件，接受用户权限作为输入，然后根据权限来决定是否显示按钮。<br> 一开始我用的是指令封装的方式，但是随着业务需要，条件渲染这种方式我也用了。<br> 在开始看具体的实现方法之前，不知道你有没有留意到上文的路由守卫中，只是根据用户的角色字段<code>role</code>来校验当前用户的权限，还有一个字段<code>permssions(权限)</code>其实一直没有派上用场，但是无论是在权限的配置项中，还是在后端的返回字段里，都有它的存在：</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3469e61523a341db973276507547d7e6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png" title>
                </div>
                <div class="image-caption">image.png</div>
            </figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cde76813f6a1434785cae6417d5ea83a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png" title>
                </div>
                <div class="image-caption">image.png</div>
            </figure>

<h4 id="1-指令-组件封装形式的按钮级权限"><a href="#1-指令-组件封装形式的按钮级权限" class="headerlink" title="1.指令/组件封装形式的按钮级权限"></a>1.指令/组件封装形式的按钮级权限</h4><p>现在它的作用来了，先看指令的具体实现方式，我们在src/directive目录下新建一个<code>hasPermi.js</code>文件，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * v-hasPermi 操作权限处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'@/store'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;   </span><br><span class="line"><span class="comment">//`el`（element）：这是指令所绑定的元素，是一个普通的DOM元素。在自定义指令的钩子函数中,</span></span><br><span class="line"><span class="comment">//你可以通过操作`el`来实现对元素的各种修改，比如添加、删除、修改样式等。</span></span><br><span class="line"><span class="comment">/** `binding`：这是一个包含指令信息的对象。它包括了以下属性：</span></span><br><span class="line"><span class="comment">   `name`：指令的名称，不包括`v-`前缀。</span></span><br><span class="line"><span class="comment">   `value`：指令的绑定值，即传递给指令的参数。在你的示例中，`value`存储了操作权限的标识符数组。</span></span><br><span class="line"><span class="comment">   `oldValue`：先前的绑定值，仅在组件更新时可用。</span></span><br><span class="line"><span class="comment">   `expression`：指令的表达式，如`v-my-directive="someValue"`中的`someValue`。</span></span><br><span class="line"><span class="comment">   `arg`：指令的参数，如`v-my-directive:arg="value"`中的`arg`。</span></span><br><span class="line"><span class="comment">   `modifiers`：一个包含修饰符的对象，如`v-my-directive.modifier`。</span></span><br><span class="line"><span class="comment">   `vnode`：渲染该组件的虚拟节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  mounted(el, binding, vnode) &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">const</span> &#123; value &#125; = binding</span><br><span class="line">    <span class="comment">//all_permission代表所有权限，一般超级管理员需要用这个</span></span><br><span class="line">    <span class="keyword">const</span> all_permission = <span class="string">'*:*:*'</span></span><br><span class="line">    <span class="comment">//获取后端返回的权限字段列表</span></span><br><span class="line">    <span class="keyword">const</span> permissions = store.getters &amp;&amp; store.getters[<span class="string">'user/permissions'</span>]</span><br><span class="line">    <span class="comment">//校验当前用户的权限列表是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; value <span class="keyword">instanceof</span> <span class="built_in">Array</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">//传入的参数，需要校验的权限字段值</span></span><br><span class="line">      <span class="keyword">const</span> permissionFlag = value</span><br><span class="line">      <span class="comment">//判断当前权限列表中，有无该传入的权限字段值</span></span><br><span class="line">      <span class="keyword">const</span> hasPermissions = permissions.some(<span class="function">(<span class="params">permission</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">          all_permission === permission || permissionFlag.includes(permission)</span><br><span class="line">        )</span><br><span class="line">      &#125;)</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (!hasPermissions) &#123;</span><br><span class="line">      <span class="comment">// 如果用户没有权限，移除当前元素的父节点（即移除当前元素）</span></span><br><span class="line">        el.parentNode &amp;&amp; el.parentNode.removeChild(el)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`请设置操作权限标签值`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码主要是在页面元素的挂载阶段（<code>mounted</code>钩子）检查用户权限，如果用户没有操作权限，那么就移除对应的页面元素。具体的代码说明我都放在里注释里。 写好了这个方法后，需要将该指令挂载到全局当中，这个时候需要进入<code>main.js</code>文件，在vue3中，给vue对象挂载自定义指令的方式如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">import</span> directive <span class="keyword">from</span> <span class="string">'@/directive'</span> <span class="comment">// directive</span></span><br><span class="line"><span class="keyword">const</span> app = createApp(App)</span><br><span class="line">app.mount(<span class="string">'#app'</span>)</span><br><span class="line"><span class="comment">// 添加到全局</span></span><br><span class="line">directive(app)</span><br></pre></td></tr></table></figure>

<p>然后，在你需要进行按钮级权限校验的地方添加上这段指令，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;a-button</span><br><span class="line">   type=<span class="string">"primary"</span></span><br><span class="line">   @click=<span class="string">"openModal('add')"</span></span><br><span class="line">   v-hasPermi=<span class="string">"['system:user:add']"</span></span><br><span class="line">  &gt;</span><br><span class="line">  新增</span><br><span class="line">  &lt;<span class="regexp">/a-button&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面这段代码里的<code>system:user:add</code>意思是<strong>系统目录下用户管理模块的新增按钮权限</strong>（如果看不懂就翻到文章最开始介绍RBAC的权限字段设计那里），当后端返回的当前用户数据中的permissions字段里，没有<code>system:user:add</code>这个权限字段时，这个按钮就不会显示出来。</p>
<h4 id="2-条件渲染形式的按钮级权限"><a href="#2-条件渲染形式的按钮级权限" class="headerlink" title="2.条件渲染形式的按钮级权限"></a>2.条件渲染形式的按钮级权限</h4><p>自定义指令实现的按钮级权限并不能满足我的业务需要，由于vue的限制，我们的自定义指令只能用在组件的<code>template</code>模块内，也就是只能放在dom标签上。但是有的时候，我可能需要对某个字段的逻辑，或者根据角色的不同，显示不同的表格列，这是数据上的处理，这个时候自定义指令就毫无用武之地。所以就需要用到条件渲染的形式。 条件渲染的形式，说白了，就是封装一个<code>全局方法</code>，方法返回值是<code>true</code>或者是<code>false</code>，然后再加一个<code>v-if</code>，但是我其实用不到这个<code>v-if</code>,我只需要这个判断权限的返回结果就足够了，核心逻辑跟自定义指令如出一辙。就不再过多赘述，直接上代码你就懂了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * checkPermi 操作权限处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'@/store'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">checkPermi</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> all_permission = <span class="string">'*:*:*'</span></span><br><span class="line">  <span class="keyword">const</span> permissions = store.getters &amp;&amp; store.getters[<span class="string">'user/permissions'</span>]</span><br><span class="line">  <span class="keyword">const</span> permissionFlag = value</span><br><span class="line">  <span class="keyword">const</span> hasPermissions = permissions.some(<span class="function">(<span class="params">permission</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> all_permission === permission || permissionFlag.includes(permission)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> hasPermissions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟上面的自定义指令不能说完全一样，只能说是一模一样。然后，我们就需要把这个方法挂载到全局，这里的挂载方式是<code>vue3</code>的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">const</span> app = createApp(App)</span><br><span class="line">app.config.globalProperties.$checkPermi = checkPermi</span><br><span class="line">app.mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>

<p>然后在你需要用的地方引入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  <span class="keyword">import</span> &#123;</span><br><span class="line">    ref,</span><br><span class="line">    reactive,</span><br><span class="line">    onMounted,</span><br><span class="line">    watch,</span><br><span class="line">    toRefs,</span><br><span class="line">    nextTick,</span><br><span class="line">    getCurrentInstance,</span><br><span class="line">  &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line">    <span class="keyword">const</span> &#123; $checkPermi &#125; =</span><br><span class="line">    getCurrentInstance().appContext.config.globalProperties</span><br><span class="line">    <span class="keyword">if</span> ($checkPermi([<span class="string">'ProductionManagement:CustomOrderManagement:pro'</span>])) &#123;</span><br><span class="line">     <span class="comment">//有这个按钮级权限时的处理</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="comment">//没有这个按钮级权限时的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>怎么样，是不是很简单？</p>
<h4 id="后台系统按钮级别权限控制两种方案，自定义指令和条件控制的优缺点"><a href="#后台系统按钮级别权限控制两种方案，自定义指令和条件控制的优缺点" class="headerlink" title="后台系统按钮级别权限控制两种方案，自定义指令和条件控制的优缺点"></a>后台系统按钮级别权限控制两种方案，自定义指令和条件控制的优缺点</h4><p>在后台系统中，对于按钮级别权限控制，自定义指令和条件控制是两种常用的方法。以下是它们各自的优缺点：</p>
<h5 id="自定义指令方案"><a href="#自定义指令方案" class="headerlink" title="自定义指令方案"></a>自定义指令方案</h5><p><strong>优点</strong>：</p>
<ol>
<li><strong>高度封装</strong>：自定义指令可以将权限控制的逻辑封装起来，使得在多个地方使用相同的权限控制变得简单。</li>
<li><strong>易于扩展</strong>：如果需要添加新的权限控制逻辑，只需修改或扩展自定义指令即可，无需修改大量已有代码。</li>
<li><strong>提高可读性</strong>：在模板中使用自定义指令可以使得代码更加简洁，提高可读性。</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li><strong>依赖后端</strong>：通常，自定义指令需要依赖于后端提供的用户权限数据来进行权限判断。</li>
<li><strong>学习成本</strong>：对于不熟悉Vue等前端框架的开发者来说，学习自定义指令的编写和使用需要一定的时间。</li>
<li><strong>性能考虑</strong>：如果自定义指令的实现不够高效，可能会对页面性能产生一定的影响。</li>
</ol>
<h5 id="条件控制方案"><a href="#条件控制方案" class="headerlink" title="条件控制方案"></a>条件控制方案</h5><p><strong>优点</strong>：</p>
<ol>
<li><strong>简单直接</strong>：条件控制直接基于前端逻辑进行判断，代码简单直接，易于理解。</li>
<li><strong>减少依赖</strong>：与自定义指令相比，条件控制通常不需要依赖于后端提供的权限数据，只需根据前端状态进行判断。</li>
<li><strong>无需额外学习</strong>：对于大多数开发者来说，条件控制是基本的前端技能，无需额外学习。</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li><strong>代码冗余</strong>：如果在多个地方使用相同的权限控制逻辑，可能会导致代码冗余。</li>
<li><strong>维护困难</strong>：当需要修改权限控制逻辑时，可能需要修改多个地方的代码，维护起来较为困难。</li>
<li><strong>安全性</strong>：如果条件控制的逻辑过于简单，可能会存在安全风险，比如被绕过或猜测出正确的逻辑。</li>
</ol>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>在实际应用中，可以根据项目的具体需求和团队的实际情况来选择使用哪种方案。如果项目对权限控制的要求比较高，且团队对Vue等前端框架比较熟悉，可以考虑使用自定义指令方案；如果项目对权限控制的要求相对简单，或者团队对前端框架的熟悉程度不够，可以考虑使用条件控制方案。同时，也可以考虑将两种方案结合起来使用，以达到更好的效果。</p>
<h4 id="如何结合使用自定义指令和条件控制"><a href="#如何结合使用自定义指令和条件控制" class="headerlink" title="如何结合使用自定义指令和条件控制"></a>如何结合使用自定义指令和条件控制</h4><p>结合使用自定义指令和条件控制可以为后台系统的按钮级别权限控制提供更灵活和可维护的解决方案。以下是如何结合使用这两种方法的建议：</p>
<h5 id="1-定义自定义指令"><a href="#1-定义自定义指令" class="headerlink" title="1. 定义自定义指令"></a>1. 定义自定义指令</h5><p>首先，你可以定义一个或多个自定义指令来处理权限控制的逻辑。这些指令可以检查用户是否具有某个特定的权限，并根据权限决定是否显示或禁用某个按钮。</p>
<p>例如，在Vue中，你可以定义一个名为<code>v-permission</code>的自定义指令：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">'permission'</span>, &#123;  </span><br><span class="line">  <span class="comment">// 当被绑定的元素挂载到 DOM 中时……  </span></span><br><span class="line">  inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el, binding, vnode</span>) </span>&#123;  </span><br><span class="line">    <span class="comment">// 假设 binding.value 是一个权限字符串，如 'admin'  </span></span><br><span class="line">    <span class="keyword">const</span> hasPermission = checkPermission(binding.value); <span class="comment">// 这是一个假设的函数，需要根据你的后端API实现  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (!hasPermission) &#123;  </span><br><span class="line">      <span class="comment">// 如果没有权限，隐藏或禁用元素  </span></span><br><span class="line">      el.style.display = <span class="string">'none'</span>; <span class="comment">// 或者你可以添加 disabled 属性到按钮上  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;,  </span><br><span class="line">  <span class="comment">// ...（其他钩子函数，如 update，componentUpdated）  </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="2-使用条件渲染"><a href="#2-使用条件渲染" class="headerlink" title="2. 使用条件渲染"></a>2. 使用条件渲染</h5><p>除了自定义指令，你还可以使用Vue的条件渲染指令（如<code>v-if</code>和<code>v-show</code>）来根据条件显示或隐藏按钮。这种方法特别适用于基于更复杂逻辑（不仅仅是权限）的渲染。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-if</span>=<span class="string">"isAdmin &amp;&amp; showButton"</span> @<span class="attr">click</span>=<span class="string">"handleClick"</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>isAdmin</code>可能是一个计算属性或方法来检查用户是否具有管理员权限，而<code>showButton</code>可能是一个简单的布尔值，用于根据其他条件（如页面状态）控制按钮的显示。</p>
<h5 id="3-结合使用"><a href="#3-结合使用" class="headerlink" title="3. 结合使用"></a>3. 结合使用</h5><p>你可以将自定义指令和条件渲染结合使用，以便在更复杂的场景中实现权限控制。例如，你可以使用<code>v-permission</code>指令来检查用户是否具有某个权限，并使用<code>v-if</code>来根据其他条件（如页面状态或数据可用性）进一步控制按钮的显示。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-permission</span>=<span class="string">"'admin'"</span> <span class="attr">v-if</span>=<span class="string">"dataLoaded"</span> @<span class="attr">click</span>=<span class="string">"handleClick"</span>&gt;</span>管理操作<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，只有当用户具有管理员权限（由<code>v-permission</code>指令检查）且数据已加载（由<code>v-if</code>指令检查）时，按钮才会显示。</p>
<h5 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h5><ul>
<li><strong>性能</strong>：虽然自定义指令和条件渲染都是Vue的性能优化点，但在大规模应用中，过多的条件渲染可能会导致性能问题。确保在适当的时候使用<code>v-show</code>代替<code>v-if</code>，以避免不必要的重新渲染。</li>
<li><strong>代码组织</strong>：为了保持代码的清晰和可维护性，将权限控制逻辑与业务逻辑分开。你可以将权限检查逻辑封装在可复用的函数或组件中。</li>
<li><strong>测试</strong>：确保对自定义指令和条件渲染进行充分的测试，以确保它们在各种条件下都能正常工作。</li>
</ul>
<h2 id="5-遇到的坑"><a href="#5-遇到的坑" class="headerlink" title="5.遇到的坑"></a>5.遇到的坑</h2><p>这里面有几个坑需要注意下：</p>
<ol>
<li>第一个坑就是在<code>vue3</code>支持的vue-router4.0版本之前，也就是<code>vue2</code>中，动态添加路由的方式支持的是<code>addRoutes</code>，它的参数是格式是一个<code>数组</code>。而到了4.0后，<code>addRoutes</code>这个方法被废弃，取而代之的是<code>addRoute</code>，它的参数则是一个路由对象。这两个方法无论是在<code>传参类型</code>还是添加相同path时的覆盖逻辑都不相同。</li>
<li>第二个坑就是无论是用控制台还是打断点的方式，或者是用Vue.js devtools的谷歌插件，都无法在路由守卫中获取到添加完成后的最新router对象，<strong>也就是说你会在调试addRoute加载后的动态路由表时，发现与之前为添加路由时的路由表是一样的，从而无法判断是否动态路由添加成功</strong>（就很蛋疼）</li>
<li>第三个坑是 next({ …to, replace: true })这个方法，当添加好动态路由后，如果不这么写next，会白屏。<strong>在<code>addRoute()</code>之后第一次访问被添加的路由会白屏，这是因为刚刚<code>addRoute()</code>就立刻访问被添加的路由，然而此时<code>addRoute()</code>没有执行结束，因而找不到刚刚被添加的路由导致白屏。因此需要从新访问一次路由才行。</strong><br> 具体原因见文章链接：<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fqq_41912398%2Farticle%2Fdetails%2F109231418" target="_blank" rel="noopener">blog.csdn.net/qq_41912398…</a></li>
<li>退出后，新的用户会访问到原本不属于该用户的路由，必须刷新页面才会正常。后来通过排查，导致这个问题的原因是因为当用户登出时，当前路由router对象还保留着上一个用户的动态路由，因次，还需要在登出的时候，对路由router对象进行初始化。我们在src/router目录下的<code>index.js</code>文件里写一个初始化方法：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化路由</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resetRouter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//获取当前路有对象</span></span><br><span class="line">  <span class="keyword">let</span> routers = router.getRoutes()</span><br><span class="line"><span class="comment">//剔除动态路由</span></span><br><span class="line">  routers.map(<span class="function">(<span class="params">it</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (![<span class="string">'login'</span>, <span class="string">'403'</span>, <span class="string">':pathMatch(.*)*'</span>].includes(it.name)) &#123;</span><br><span class="line">      router.removeRoute(it.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在登出的地方引用这个方法并执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; resetRouter &#125; <span class="keyword">from</span> <span class="string">'@/router/index.js'</span></span><br><span class="line"> <span class="keyword">async</span> logout() &#123;</span><br><span class="line">        resetRouter()</span><br><span class="line">        <span class="keyword">await</span> store.dispatch(<span class="string">'user/Logout'</span>)</span><br><span class="line">        <span class="keyword">this</span>.$router.push(<span class="string">'/login'</span>)</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure>

<ol>
<li>还有一个关于vuex的问题，从之前的代码里不难看出，我们将用户信息，角色、权限、动态路由等都存在了vuex中。<strong>由于vuex的特性，用户会在刷新页面后，vuex里的数据会被清空，这个时候就会导致页面直接跳转到登录页</strong>。这肯定是不能接受的，因此，我们需要对vuex里的数据在刷新的时候做持久化处理。逻辑也很简单，监听页面刷新事件，<code>beforeunload</code>这个方法恰好就能做到，在页面刷新的时候，将vuex中的数据缓存到浏览器本地临时缓存中，然后再在页面初始化的时候，从本地临时缓存中取出存入vuex对象中。 附上代码：（项目根目录下的的App.vue文件中,这里是vue2的写法)</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">      <span class="comment">//在页面加载时读取sessionStorage里的状态信息</span></span><br><span class="line">      sessionStorage.getItem(<span class="string">'userMsg'</span>) &amp;&amp;</span><br><span class="line">        <span class="keyword">this</span>.$store.replaceState(</span><br><span class="line">          <span class="built_in">Object</span>.assign(</span><br><span class="line">            <span class="keyword">this</span>.$store.state,</span><br><span class="line">            <span class="built_in">JSON</span>.parse(sessionStorage.getItem(<span class="string">'userMsg'</span>))</span><br><span class="line">          )</span><br><span class="line">        )</span><br><span class="line">      <span class="comment">//在页面刷新时将vuex里的信息保存到sessionStorage里</span></span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">'beforeunload'</span>, () =&gt; &#123;</span><br><span class="line">        sessionStorage.setItem(<span class="string">'userMsg'</span>, <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.$store.state))</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>这里再附上src/router目录下的<code>index.js</code>代码，方便大家理解路由这块：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createWebHistory, createRouter, useRouter &#125; <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> &#123; constantRouterMap &#125; <span class="keyword">from</span> <span class="string">'@/config/router.config.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123; generator &#125; <span class="keyword">from</span> <span class="string">'@/router/generatorRouters'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">  history: createWebHistory(),</span><br><span class="line">  routes: constantRouterMap,</span><br><span class="line">  scrollBehavior(to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">    <span class="keyword">if</span> (savedPosition) &#123;</span><br><span class="line">      <span class="keyword">return</span> savedPosition</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">top</span>: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//这里是我为了刷新的时候不调取获取路由信息的接口，做的本地缓存，因为刷新一次就要获取一遍用户信息和</span></span><br><span class="line"><span class="comment">//动态路由表信息太影响用户体验了，尤其是在网速差的情况下。没这方面需求的可以不用管</span></span><br><span class="line"><span class="keyword">let</span> asyncRouterMap = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleLocalRouter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (sessionStorage.getItem(<span class="string">'generateRoutes'</span>)) &#123;</span><br><span class="line">    asyncRouterMap = asyncRouterMap.concat(</span><br><span class="line">      <span class="built_in">JSON</span>.parse(sessionStorage.getItem(<span class="string">'generateRoutes'</span>))</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">const</span> generatedRoutes = generator(asyncRouterMap)</span><br><span class="line">    generatedRoutes.push(&#123;</span><br><span class="line">      path: <span class="string">'/:pathMatch(.*)*'</span>,</span><br><span class="line">      redirect: <span class="string">'/404'</span>,</span><br><span class="line">      hidden: <span class="literal">true</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    generatedRoutes.forEach(<span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">      router.addRoute(route)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化路由</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resetRouter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> routers = router.getRoutes()</span><br><span class="line">  routers.map(<span class="function">(<span class="params">it</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (![<span class="string">'login'</span>, <span class="string">'403'</span>, <span class="string">':pathMatch(.*)*'</span>].includes(it.name)) &#123;</span><br><span class="line">      router.removeRoute(it.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">handleLocalRouter()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>

<h2 id="6-结束与优化"><a href="#6-结束与优化" class="headerlink" title="6.结束与优化"></a>6.结束与优化</h2><p>好，至此，整个RBAC的前端权限方案设计到实现就已经宣告完成，其实还有很多需要优化的地方，比如把用户路由表信息缓存到本地临时缓存中，这样用户每次刷新页面的时候就不会因为vuex的特性需要再去请求一边接口。（但是老实说，我觉得这个优化方案还是不够好，因为将路由表存在本地缓存中就已经背离了安全性这一块，但是在网络较差的情况下，刷新就要调取角色信息接口，调取获取私有路由的接口，再到构建新的完整路由这个过程期间，页面会处于白屏状态，非常影响用户体验。因此，只能取此下策。到底要不要缓存，看个人的想法吧。） 还比如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> store.dispatch(<span class="string">'user/GetInfo'</span>)</span><br><span class="line">   <span class="keyword">await</span> store.dispatch(<span class="string">'async-router/GenerateRoutes'</span>)</span><br><span class="line">   <span class="keyword">let</span> accessRoutes = store.getters[<span class="string">'async-router/addRouters'</span>]</span><br><span class="line">   accessRoutes.forEach(<span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//用来判断是否是外链</span></span><br><span class="line">    <span class="keyword">if</span> (!isHttp(route.path)) &#123;</span><br><span class="line">      router.addRoute(route) <span class="comment">// 动态添加可访问路由表</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>这段获取用户信息-&gt;构建路由-&gt;添加动态路由的代码可以抽离出来，单独封装。<br> 还可以根据当前环境是否是<code>development</code>来判断是否是开发环境，从而准备另外一套前端开发场景下使用的完整路由表，这样，就可以在不依赖后端的情况下，进行前端开发。<br> 另外还有侧边导航栏的处理，这个我没讲，一方面是相对简单，<strong>我们获取到格式化之后的动态路由数据的同时，其实也就是获取到了导航栏的菜单信息。</strong> 另一方面，每个人的项目页面布局方式不一样，导航栏的设计也会不一样。在此基础上，针对性的对数据进行修饰和改造即可。<br> 不啰嗦了，今天周五下班时间了，我写的比较匆忙，也有些地方我可能没有考虑到，看到这里的小伙伴，或者对着文章实践的小伙伴们，欢迎你们提出自己的意见和看法，我会加以订正，不足之处，还请海涵~~ <figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49305cf84d7d48e5928f3116a925b981~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="5223e1f26a8ae0f57e4ff89518d9c82f.jpg" title>
                </div>
                <div class="image-caption">5223e1f26a8ae0f57e4ff89518d9c82f.jpg</div>
            </figure></p>
<p>原文链接：<a href="https://juejin.cn/post/7259210874446692411" target="_blank" rel="noopener">https://juejin.cn/post/7259210874446692411</a></p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2024-05-10T09:29:21.379Z" itemprop="dateUpdated">2024-05-10 17:29:21</time>
</span><br>


        
        感谢您的阅读，欢迎评论(*^▽^*) 转载请附上本文链接：<a href="/qw8/articles/qian-duan-quan-xian-kai-fa.html" target="_blank" rel="external">https://qw8.github.io/qw8/articles/qian-duan-quan-xian-kai-fa.html</a>
        
    </div>
    
    <footer>
        <a href="https://qw8.github.io/qw8">
            <img src="/qw8/img/avatar.jpg" alt="秦伟">
            秦伟
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/qw8/tags/权限/">权限</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://qw8.github.io/qw8/articles/qian-duan-quan-xian-kai-fa.html&title=《前端权限开发》 — 秦伟博客&pic=https://qw8.github.io/qw8/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://qw8.github.io/qw8/articles/qian-duan-quan-xian-kai-fa.html&title=《前端权限开发》 — 秦伟博客&source=前端、全栈、SEO的知识点、面试题与学习链接的整理" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://qw8.github.io/qw8/articles/qian-duan-quan-xian-kai-fa.html" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《前端权限开发》 — 秦伟博客&url=https://qw8.github.io/qw8/articles/qian-duan-quan-xian-kai-fa.html&via=https://qw8.github.io/qw8" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://qw8.github.io/qw8/articles/qian-duan-quan-xian-kai-fa.html" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/qw8/articles/ji-yu-vue-de-qian-duan-jia-gou.html" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">基于Vue的前端架构</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/qw8/articles/hou-tai-guan-li-xi-tong.html" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">后台管理系统</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'false' == 'true',
            appId: "TJ17Ax10JrfIIljlO8qkwGvz-gzGzoHsz",
            appKey: "jDGQKdWT9hlzsTLRAbInE4bK",
            avatar: "mm",
            placeholder: "说点什么吧(*╹▽╹*)",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->










</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢您，我会继续努力哒(*^▽^*)
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/qw8/img/wechat.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/qw8/img/wechat.png" data-alipay="/qw8/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

    <footer class="footer">
    <div class="top">
        <div class="map">
            <!--地球信息-->
<script type="text/javascript" src="/js/jquery-3.4.1.js"></script>
<script type="text/javascript">
    var windowWidth = $(window).width();
    if (windowWidth > 480) {
        document.write('<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5mz4gy0w2d8&amp;m=0&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33" async="async">  <\/script>');
    }
</script>
        </div>
        <p>
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>

</p>
        <p>
            <span>本网站总字数：832.3k</span>
            <span id="sitetime"></span>
        </p>
        <p>部分内容来源于互联网，用于个人知识的总结，如有侵权还请联系删除</p>
        <p>
            
            <span><a href="/qw8/atom.xml" target="_blank" class="rss" title="rss"><i
                    class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>

    <div class="bottom">
        <p>
            <span>Copyright &copy; 2019 - 2024 <a
                href="http://pdouyin.com/" target="_blank">秦伟的个人博客</a> All Rights Reserved.</span>
            <!-- <span>
                
                
            </span> -->
        </p>
    </div>
</footer>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2019, 8, 25, 18, 0, 0); // 北京时间
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "已安全运行 " + diffYears + "年 " + diffDays + "天 " + diffHours + "小时 " + diffMinutes + "分钟 " + diffSeconds + "秒";
    }
    siteTime();
</script>
</main>
<div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://qw8.github.io/qw8/articles/qian-duan-quan-xian-kai-fa.html&title=《前端权限开发》 — 秦伟博客&pic=https://qw8.github.io/qw8/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://qw8.github.io/qw8/articles/qian-duan-quan-xian-kai-fa.html&title=《前端权限开发》 — 秦伟博客&source=前端、全栈、SEO的知识点、面试题与学习链接的整理" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://qw8.github.io/qw8/articles/qian-duan-quan-xian-kai-fa.html" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《前端权限开发》 — 秦伟博客&url=https://qw8.github.io/qw8/articles/qian-duan-quan-xian-kai-fa.html&via=https://qw8.github.io/qw8" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://qw8.github.io/qw8/articles/qian-duan-quan-xian-kai-fa.html" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACvklEQVR42u3aQW4bMRAEQP//0wmQUwxBcvcMKTtI7SmQ5SWLAchxcz4+4ufXn+fxk7+fx8+TNzx75+N3Hr9/7MHDw8MbTf3Z82yYnJGMmCzr6zk8fRseHh7eNV776vwNrxcrGTE/JPDw8PB+Gi+ZaLLR4+Hh4f0/vLwgzsvu199pgwk8PDy8d/KSMGIWQLSHSkK6krXg4eHhxbz2Auwn/Pvi/R4eHh7e4la93Xzz4Weldj1DPDw8vAu8JFrdHBiz8LcNgr+YOR4eHt5R3iyETSKG5Lfy6bbH0qdzDw8PD+8obxMKbLbyfN/OD6SoXRUPDw/vAm+/leeY2ZvrSBcPDw/vAm/2B38bxc5i2Vmki4eHh/d+XhvFJi1Z+Xs2l2fD/0M8PDy8mJevwWa1cvBsgZ6OhYeHh3eBt2kOaMvoBDBrI1i1QeDh4eGNeLOidn/FtSno8yAYDw8P7yyvbZDKy+48eN0EFnh4eHjv582u8PPotm1WaA+A6GDDw8PDO8prL/5n8UHbZNCGHdHfCnh4eHiHeHlc2wJmC5cX1vX1GB4eHt4hXlL47q+jkgltjpAvshY8PDy8o7y8OJ4FFrOINu9riH4XDw8P7ygvH6xtisqv/GctAtHhhIeHh/d2XjvALEpolyxfRDw8PLwbvPZivm3G2rcIzH5an354eHh4kyq32KDz1yVXXO2Ctg1eeHh4eDd4M8YmnG3ZOSzqLMPDw8O7wJttwWc39PYy7GM2LTw8PLwRLH9eM/Zz2Jfjnz7Bw8PDu8DbHB6bV58q04sAFw8PD+8orz0M2hI5iXpPxSJ1YY2Hh4e34OUDz0Lb5CCZnV14eHh4/wpvlpS2IUJ7Mfa0pMbDw8P7Jl5b8uZXa3mR3bYX4OHh4d3jJZv4LLbI8e3Bc6CBAA8PD2990dVegM3Ci00s246Ch4eHd5T3Gwx1xTo8GJBXAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/qw8/', SHARE: true, REWARD: true };


</script>

<script src="/qw8/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/qw8/js/search.min.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '(つェ⊂)咦!跑去哪里了';
            clearTimeout(titleTime);
        } else {
            document.title = '欢迎回来━(*｀∀´*)ノ';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>




<!-- 点击特效 -->
<script type="text/javascript" src="/js/clicklove.js"></script>
<!--动态线条背景-->
<script type="text/javascript"
        color="220,220,220" opacity='0.7' zIndex="-2" count="200"
        src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>
<!-- 雪花特效 -->
<script type="text/javascript" src="/js/jquery-3.4.1.js"></script>
<script type="text/javascript">
    var windowWidth = $(window).width();
    if (windowWidth > 480) {
        document.write('<script type="text/javascript" src="/js/snow.js"><\/script>');
    }
</script>

<script>!function(e){var r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function t(){for(var c=0;c<r.length;c++)t=r[c],void 0,0<=(n=t.getBoundingClientRect()).top&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=r[c];t=o,n=function(){r=r.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}t(),e.addEventListener("scroll",function(){!function(t,n){clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)}(t,e)})}(this);</script><script src="/qw8/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/qw8/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"position":"right","width":150,"height":300,"hOffset":-25,"vOffset":30},"mobile":{"show":false,"scale":1.2},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>

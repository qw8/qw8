{"meta":{"title":"秦伟博客","subtitle":"前端、全栈、SEO的知识点、面试题与学习链接的整理","description":"前端、全栈、SEO的知识点、面试题与学习链接的整理","author":"秦伟","url":"https://qw8.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-08-30T02:14:28.000Z","updated":"2024-05-09T00:53:20.562Z","comments":false,"path":"categories/index.html","permalink":"https://qw8.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-08-30T02:12:55.000Z","updated":"2024-05-09T00:53:20.610Z","comments":false,"path":"tags/index.html","permalink":"https://qw8.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"自定义表格列","slug":"articles/自定义表格列","date":"2024-05-10T16:00:00.000Z","updated":"2024-05-10T09:10:43.336Z","comments":true,"path":"/articles/zi-ding-yi-biao-ge-lie.html","link":"","permalink":"https://qw8.github.io/articles/zi-ding-yi-biao-ge-lie.html","excerpt":"","text":"element ui vue2怎么实现根据用户自定义缓存设置 是否显示表格的某列在 Element UI（用于 Vue.js 的组件库）中，如果你想根据用户的自定义缓存设置来决定是否显示表格的某列，你可以通过以下步骤实现： 存储用户设置：首先，你需要一种方式来存储用户的设置。这可以是 localStorage、Cookies、Vuex 状态管理或者其他后端存储方式。 读取用户设置：在组件加载时，读取用户的设置。 动态渲染表格列：基于用户的设置，动态地渲染表格的列。 以下是一个基本的实现示例： 1. 假设你有一个用于存储用户设置的变量123456// 假设这是从 localStorage 或其他地方读取的用户设置 let userSettings = &#123; showColumnA: true, showColumnB: false, // ... 其他列的设置 &#125;; 2. 在 Vue 组件中，根据这些设置动态渲染列1234567891011121314151617181920212223242526&lt;template&gt; &lt;el-table :data=&quot;tableData&quot;&gt; &lt;el-table-column v-if=&quot;userSettings.showColumnA&quot; prop=&quot;columnA&quot; label=&quot;Column A&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column v-if=&quot;userSettings.showColumnB&quot; prop=&quot;columnB&quot; label=&quot;Column B&quot;&gt;&lt;/el-table-column&gt; &lt;!-- ... 其他列 --&gt; &lt;/el-table&gt; &lt;/template&gt; &lt;script&gt; export default &#123; data() &#123; return &#123; tableData: [ // ... 你的表格数据 ], userSettings: &#123; // 这里应该根据你的应用逻辑来初始化或读取用户设置 showColumnA: true, showColumnB: false, // ... 其他列的设置 &#125;, &#125;; &#125;, // ... 其他选项和方法 &#125;; &lt;/script&gt; 3. 读取和更新用户设置你可能需要提供一种方式来让用户更新这些设置，并将它们保存回存储中。这可以通过表单、对话框或其他 UI 元素来实现。当用户更新设置时，你应该更新 userSettings 对象，并可能还需要将这些更改保存回 localStorage 或其他存储中。 注意事项： 确保你的表格数据（tableData）中的属性与你在 el-table-column 中使用的 prop 属性匹配。 如果你使用的是 Vuex 或其他状态管理库，你可能需要将 userSettings 保存在 Vuex store 中，并在需要时从 store 中读取它们。 当用户更改设置时，你可能需要触发一个事件或调用一个方法来更新你的 UI 和/或保存更改到存储中。 如果el-table-column是通过v-for循环出来的，应该怎么处理如果 el-table-column 是通过 v-for 循环动态生成的，你可以根据用户设置来决定是否渲染每一列。这通常涉及到在循环中检查用户设置来确定是否包含某个列。 以下是一个例子，展示如何根据用户设置使用 v-for 来动态生成 el-table-column： 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;el-table :data=&quot;tableData&quot;&gt; &lt;el-table-column v-for=&quot;(column, index) in columns&quot; :key=&quot;index&quot; :prop=&quot;column.prop&quot; :label=&quot;column.label&quot; v-if=&quot;userSettings[column.key] || userSettings[column.key] === undefined&quot; &gt;&lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/template&gt; &lt;script&gt; export default &#123; data() &#123; return &#123; tableData: [ // ... 你的表格数据 ], columns: [ &#123; prop: &apos;columnA&apos;, label: &apos;Column A&apos;, key: &apos;showColumnA&apos; &#125;, &#123; prop: &apos;columnB&apos;, label: &apos;Column B&apos;, key: &apos;showColumnB&apos; &#125;, // ... 其他列配置 ], userSettings: &#123; // 假设这是从 localStorage 或其他地方读取的用户设置 // 默认为 undefined，表示未明确设置是否显示该列 // 可以设置 true 或 false 来控制列的显示与隐藏 showColumnA: true, showColumnB: false, // ... 其他列的设置 &#125;, &#125;; &#125;, // ... 其他选项和方法 &#125;; &lt;/script&gt; 在这个例子中，columns 数组包含了表格列的配置，每个对象都有一个 key 属性，这个属性与 userSettings 中的键对应。v-if 指令检查 userSettings[column.key] 的值来确定是否渲染该列。 注意，我添加了 || userSettings[column.key] === undefined 的条件，这是为了处理那些用户尚未明确设置是否显示的列（即 userSettings 中没有该键）。如果你希望用户必须明确设置每一列的显示状态，你可以去掉这个条件。 此外，确保 userSettings 中的键与 columns 数组中每个对象的 key 属性相匹配。这样，你就可以通过修改 userSettings 来控制哪些列应该被渲染。 哪个elementui项目支持列设置Element UI 本身并没有直接提供一个支持列设置的现成项目，但你可以通过封装 Element UI 的表格组件（``）来实现列设置的功能。这通常涉及到以下几个步骤： 封装 el-table 组件：你可以创建一个自定义的 Vue 组件，该组件内部使用 el-table 并添加一些额外的逻辑来处理列设置。 定义列设置数据：在你的 Vue 组件中，你需要定义一些数据来存储列的设置信息，例如哪些列是可见的，哪些列是固定的等。 动态渲染列：使用 v-for 指令来根据列设置数据动态地渲染表格的列。你可以检查每个列的设置来决定是否渲染它。 提供列设置界面：你可能需要创建一个界面来允许用户更改列的设置。这可以是一个对话框、侧边栏或其他任何适合你的应用的界面。 处理列设置更改：当用户更改列设置时，你需要更新你的列设置数据，并重新渲染表格以反映这些更改。 这里有一些具体的实现技巧： 使用 Vuex 或其他状态管理库：如果你的应用已经使用了 Vuex 或其他状态管理库，你可以将列设置数据存储在 Vuex store 中，并在需要时从 store 中读取和更新它。 使用计算属性（Computed Properties）：如果你的列设置数据会影响表格的渲染方式，你可以使用计算属性来根据列设置数据计算出一个新的渲染列表。 自定义列模板：你可以使用 Element UI 的 ` 功能来为每个列定义自定义的模板。这允许你根据列的数据和设置来显示不同的内容。 请注意，具体的实现方式会根据你的应用需求和设计而有所不同。你可能需要根据你的具体情况来调整上述步骤和技巧。","categories":[{"name":"前端文章","slug":"前端文章","permalink":"https://qw8.github.io/categories/前端文章/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://qw8.github.io/tags/vue/"},{"name":"表格","slug":"表格","permalink":"https://qw8.github.io/tags/表格/"}]},{"title":"qiankun项目搭建","slug":"knowledges/qiankun项目搭建","date":"2024-04-28T02:02:08.000Z","updated":"2024-04-30T10:15:43.908Z","comments":true,"path":"/knowledges/qiankun-xiang-mu-da-jian.html","link":"","permalink":"https://qw8.github.io/knowledges/qiankun-xiang-mu-da-jian.html","excerpt":"","text":"基座配置 基座采用是的 Vue3 + vite + ts，只负责导航的渲染和登录态的下发，为子应用提供一个挂载的容器div qiankun这个库只需要在基座引入 1npm i qiankun 在main.ts 中注册子应用，为了方便管理，我们将子应用的配置都放在：/utils/qiankun.ts下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import &#123; registerMicroApps, addGlobalUncaughtErrorHandler, start &#125; from &apos;qiankun&apos;;import router from &apos;./router&apos;// 注册子应用registerMicroApps([ &#123; // 子应用名称，name值必须与子应用vite.config.ts文件中plugins属性qiankun的第一个参数值一致 name: &apos;subApp&apos;, // 默认会加载这个路径下的html，解析里面的js entry: &apos;//localhost:5050/&apos;, // 加载的容器（微应用会显示到这个容器里面，一定要保证主应用中有这个容器） container: &apos;#subAppContainerVue3&apos;, // 和app.vue配置的节点一致 // 匹配的路由 activeRule: &apos;/gosubsystem&apos;, // 访问：http://localhost:5174/juminronghe props: &#123; mag: &apos;我是主应用main&apos;, // 主应用向微应用传递参数 &#125;, &#125;, &#123; // 子应用名称，name值必须与子应用vite.config.ts文件中plugins属性qiankun的第一个参数值一致 name: &apos;lmsApp&apos;, // 默认会加载这个路径下的html，解析里面的js entry: &apos;//localhost:5000/&apos;, // 加载的容器（微应用会显示到这个容器里面，一定要保证主应用中有这个容器） container: &apos;#subAppContainerVue3&apos;, // 和app.vue配置的节点一致 // 匹配的路由 activeRule: &apos;/lmsApp&apos;, props: &#123; mag: &apos;我是主应用main&apos;, // 主应用向微应用传递参数 router // 主路由下发到子路由，子应用路由跳转使用主应用路由实例跳转（需要跳转的路由要在主应用里注册） &#125;, &#125;],&#123; beforeLoad: app =&gt; &#123; console.log(&apos;before load app.name====&gt;&gt;&gt;&gt;&gt;&apos;, app.name) &#125;, beforeMount: [ app =&gt; &#123; console.log(&apos;[LifeCycle] before mount %c%s&apos;, &apos;color: green;&apos;, app.name); &#125;, ], afterMount: [ app =&gt; &#123; console.log(&apos;[LifeCycle] after mount %c%s&apos;, &apos;color: green;&apos;, app.name); &#125; ], afterUnmount: [ app =&gt; &#123; console.log(&apos;[LifeCycle] after unmount %c%s&apos;, &apos;color: green;&apos;, app.name); &#125;, ],&#125;);// 启动 qiankun// start(&#123;// prefetch:&apos;all&apos;, // 预加载// sandbox: &#123;// experimentalStyleIsolation: true, // 开启沙箱模式,实验性方案// &#125;,// &#125;);// 添加全局异常捕获addGlobalUncaughtErrorHandler((event) =&gt; &#123; // console.error(event); const &#123; message: msg &#125; = event; // 加载失败时提示 if (msg &amp;&amp; msg.includes(&quot;died in status LOADING_SOURCE_CODE&quot;)) &#123; // message.error(&quot;微应用加载失败，请检查应用是否可运行&quot;); console.log(&quot;微应用加载失败，请检查应用是否可运行-乾坤插件是否正常&quot;) &#125;&#125;); 然后在src/main.ts中引入 1import &apos;./utils/qiankun.ts&apos; 如何在主应用的某个路由页面加载微应用 必须保证微应用加载时主应用这个路由页面也加载了主应用注册这个路由时给 path 加一个 *，注意：如果这个路由有其他子路由，需要另外注册一个路由，仍然使用这个组件即可 12345&#123; path: &apos;/portal/*&apos;, name: &apos;portal&apos;, component: () =&gt; import(&apos;../views/Portal.vue&apos;), &#125;, Portal.vue 12345678910111213141516171819202122232425&lt;template&gt; &lt;div id=&quot;subAppContainerVue3&quot;&gt;&lt;/div&gt;&lt;/template&gt; &lt;script lang=&quot;ts&quot; setup name=&quot;merchantsRuquest&quot;&gt;// import start from &quot;@/qiankun/index.js&quot;;import &#123; start &#125; from &apos;qiankun&apos;// import &#123; registerApps &#125; from &apos;@/qiankun/index.js&apos;onMounted(()=&gt;&#123; if (!window.qiankunStarted) &#123; window.qiankunStarted = true // registerApps() start(&#123; sandbox: &#123; experimentalStyleIsolation: true // 样式隔离 &#125; &#125;) &#125;&#125;)// export default &#123;// mounted() &#123; // &#125;// &#125;&lt;/script&gt; 主应用路由配置123456789101112131415161718192021222324&#123; path: &apos;/lmsApp/*&apos;, // 注意和registerMicroApps 注册子应用的activeRule匹配 name: &apos;lmsApp&apos;, meta: &#123; title: &quot;子应用菜单管理&quot;, icon: &quot;car-outlined&quot;, isFull: false, isKeepAlive: true, isHide: false &#125;, children: [ &#123; name: &apos;xxxxx&apos;, path: &apos;/lmsApp/xxxx/xxxxx&apos;, component: () =&gt; import(&apos;@/views/portal.vue&apos;), meta: &#123; title: &apos;子应用菜单下的二级菜单&apos;, icon: &apos;&apos;, isKeepAlive: false &#125; &#125;, ] &#125;, 这样，基座就算配置完成了。项目启动后，子应用将会挂载到主应用中 子应用配置 安装vite-plugin-qiankun 123npm i vite-plugin-qiankun --save-dev或者yarn add vite-plugin-qiankun --dev 修改vite.config.ts 123// 引入乾坤插件import qiankun from &apos;vite-plugin-qiankun&apos;plugins: [ vue(), qiankun(&apos;subApp&apos;, &#123; useDevMode: true &#125;) ], 在子应用main.ts 里引用qiankun 1234567891011121314151617181920212223242526272829303132333435363738394041import &#123; renderWithQiankun, qiankunWindow, type QiankunProps&#125; from &apos;vite-plugin-qiankun/dist/helper&apos;let app: anyconst render = (container?: any, routers?: any) =&gt; &#123; app = createApp(App) Object.keys(Icons).forEach((key) =&gt; &#123; app.component(key, Icons[key as keyof typeof Icons]) &#125;) app.use(pinia) app.use(print) app.use(Antd) app.use(directives) app.config.globalProperties.$routers = routers app.use(router).mount(container ? container.querySelector(&apos;#app&apos;) : &apos;#app&apos;)&#125;const initQianKun = () =&gt; &#123; renderWithQiankun(&#123; mount(props) &#123; // localStorage.lalal = 111111 console.log(props.router, &apos;获取主应用传递数据&apos;) sessionStorage.latoutStatus = false const &#123; container, router &#125; = props render(container, router) &#125;, bootstrap() &#123; &#125;, unmount() &#123; app.unmount() &#125;, update: function (props: QiankunProps): void | Promise&lt;void&gt; &#123; throw new Error(&apos;Function not implemented.&apos;) &#125; &#125;)&#125;// console.log(qiankunWindow.__POWERED_BY_QIANKUN__, &apos;90&apos;)qiankunWindow.__POWERED_BY_QIANKUN__ ? initQianKun() : render() 由于路由模式为history，需要匹配子应用的入口规则，修改src/router/index 123456789import &#123; qiankunWindow &#125; from &apos;vite-plugin-qiankun/dist/helper&apos;const router = createRouter(&#123; history: createWebHistory( qiankunWindow.__POWERED_BY_QIANKUN__ ? &apos;/lmsApp/&apos; : &apos;/&apos; ), routes&#125;) 报错There is already an app instance mounted on the host container.因为是vue应用，子应用也有个id=”app” 全局搜索#app，改成#app1 qiankun运行逻辑将主应用与子应用都运行起来后，由于主应用的main.js配置了registerMicroApps这个，里面是个数组，数组中一个对象代码一个子应用， name不太重要，运行逻辑如下：当在浏览器地址栏输入主应用的对应路由地址，主应用发现与activeRule的路由匹配上之后，会将此activeRule下的entry下跑的子应用界面渲染到container容器里（此容器我们之前写在了App.vue）简单点说就是主应用监听发现路由地址变化 （例如地址最后输入/son1）主应用从main.js 的 registerMicroApps之中寻找对应匹配的规则地址将此条规则的entry（这里填写的就是子应用目前跑在的地址），渲染到 container 下的容器里 原文链接：https://blog.csdn.net/weixin_45653441/article/details/134877301","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://qw8.github.io/tags/vue/"},{"name":"qiankun","slug":"qiankun","permalink":"https://qw8.github.io/tags/qiankun/"}]},{"title":"vue项目模板","slug":"knowledges/vue项目模板","date":"2024-04-28T01:02:08.000Z","updated":"2024-04-30T02:59:45.889Z","comments":true,"path":"/knowledges/vue-xiang-mu-mo-ban.html","link":"","permalink":"https://qw8.github.io/knowledges/vue-xiang-mu-mo-ban.html","excerpt":"","text":"从零开始搭建企业级前端项目模板（vue3+vite+ts）主要内容 技术：vite，eslint，prettierrc，husky，commitlint，lint-staget，stylelint，vuex，vue-router，axios，pinia环境：win11，node 18.17.0 ，pnpm 8.12.0 一、vite脚手架工具初始化项目本文以pnpm创建项目，通过 npm 安装 pnpm 1npm install -g pnpm vite官网：初始化项目：https://cn.vitejs.dev/guide/ 1234567891011# npm 7+, extra double-dash is needed:npm create vite@latest vue3_project_template --template vue-ts# yarnyarn create vite vue3_project_template --template vue-ts# pnpmpnpm create vite vue3_project_template --template vue-ts# bunbunx create-vite vue3_project_template --template vue-ts 创建好项目 根据创建项目提示输入命令 123cd vue3_project_templatepnpm installpnpm run dev 运行结果如下 目录结构node_modules（npm 加载的项目依赖模块） public（公共资源） src（开发目录） assets（图片等文件） components（组件） router（路由） store（vuex） views（页面） App.vue（核心页） main.js（核心文件） .browserslistrc（这个配置能够分享目标浏览器和nodejs版本在不同的前端工具。这些工具能根据目标浏览器自动来进行配置） .eslintrc.js（ESlint配置文件） .gitignore（git配置文件） babel.config.js（babel配置文件） package-lock.json（依赖版本锁定） package.json（项目信息及依赖信息） README.md（项目介绍） 二、项目代码加入eslint校验和自动格式化 node工具eslint官网eslint 运行代码前就可以发现一些语法错误和潜在bug，保证团队代码的一直性 prettier格式化官网prettier 是代码格式化工具，用于检查代码中的格式问题 区别联系：eslint保证代码质量，prettier保证代码风格，eslint有小部分格式化功能，通常和prettier结合使用 2.1安装对应依赖插件eslint： ESLint的核心代码库prettier：prettier格式化代码的核心库eslint-config-airbnb-base： airbnb的代码规范 (依赖plugin-import)eslint-config-prettier：eslint结合prettier的格式化eslint-plugin-vue：eslint在vue里的代码规范eslint-plugin-import：项目里面支持eslinteslint-plugin-prettier：将prettier结合进入eslint的插件 1pnpm install eslint eslint-plugin-vue eslint-config-prettier prettier eslint-plugin-import eslint-plugin-prettier eslint-config-airbnb-base -D vscode 安装两个插件ESLint、Prettier - Code formatter 在这里插入图片描述 在这里插入图片描述 2.2 配置script脚本，项目安装eslint配置 在package.json文件scripts加入命令&quot;lint:create&quot;:&quot;eslint --init&quot; 执行命令 1npm run lint:create 执行之后会自动创建.eslintrc.js文件 2.3 安装完成后，后面启动项目还缺少一些依赖，提前按需安装好@typescript-esTint/parser: ESLint的解析器，用于解析typescript，从而检查和规范Typescript代码;@typescript-eslint/eslint-plugin: 这是一个ESLint插件，包含了各类定义好的检测Typescript代码的规范eslint-import-resolver-alias 让我们可以import的时候使用 @ 别名 1pnpm install typescript @typescript-eslint/parser @typescript-eslint/eslint-plugin eslint-import-resolver-alias @types/eslint @types/node -D 三，修改.eslintrc.js文件 .eslintrc.js主要内容如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697module.exports = &#123; // 环境 浏览器，最新ES语法，node环境 &quot;env&quot;: &#123; &quot;browser&quot;: true, &quot;es2021&quot;: true, &quot;node&quot;: true &#125;, /** * 扩展的eslint规范语法，可以被继承的规则，字符串数组，每个配置继承它之前的配置 * 分别是eslint-config-vue 提供的 * eslint-config-airbnb-base 提供的 * eslint-config-prettier 提供的 * eslint-config- 前缀可以简写 */ &quot;extends&quot;: [ &quot;eslint:recommended&quot;, &quot;plugin:@typescript-eslint/recommended&quot;, &quot;plugin:vue/vue3-essential&quot;, &quot;airbnb-base&quot;, &quot;prettier&quot; ], // eslint 会对代码进行校验，parser是将代码转换为ESTree(AST),ESlint会对ESTree校验 &quot;parser&quot;: &quot;vue-eslint-parser&quot;, // 解析器的配置项 &quot;parserOptions&quot;: &#123; // eslint的版本号，或者年份都可以 &quot;ecmaVersion&quot;: &quot;latest&quot;, &quot;parser&quot;: &quot;@typescript-eslint/parser&quot;, &quot;sourceType&quot;: &quot;module&quot;, // 额外的语言类型 &quot;ecmaFeatures&quot;: &#123; &quot;jsx&quot;: true, &quot;tsx&quot;: true &#125; &#125;, // 全局自定义宏，这样在源文件中使用全局变量不会报错或警告 &quot;globals&quot;: &#123; &quot;defineProps&quot;: &apos;readonly&apos;, &quot;defineEmits&quot;: &apos;readonly&apos;, &quot;defineExpose&quot;: &apos;readonly&apos;, &quot;withDefaults&quot;: &apos;readonly&apos; &#125;, /** * 插件 * eslint-plugin- 前缀可以简写 * vue官方提供了一个eslint插件eslint-plugin-vue，它提供了parser和rules。 * parser为vue-eslint-parser，放在前面的parser字段里，rules放在extends字段里 */ &quot;plugins&quot;: [ &quot;@typescript-eslint&quot;, &quot;vue&quot; ], &quot;settings&quot;: &#123; // 设置项目内的别名 &quot;import/resolver&quot;: &#123; &quot;alias&quot;: &#123; &quot;map&quot;: [[&apos;@&apos;,&apos;./src&apos;]] &#125; &#125;, &quot;import/extensions&quot;: [&apos;.js&apos;,&apos;.jsx&apos;,&apos;.tsx&apos;,&apos;.ts&apos;,&apos;.mjs&apos;,&apos;.cjs&apos;] &#125;, /** * rules: 自定义规则，覆盖extends继承的规则，对规则进行灵活配置 * * &quot;off&quot; 或 0 ==&gt; 关闭规则 * &quot;warn&quot; 或 1 ==&gt; 打开的规则作为警告（不影响代码执行） * &quot;error&quot; 或 2 ==&gt; 规则作为一个错误（代码不能执行，界面报错） */ &quot;rules&quot;: &#123; // eslint（https://eslint.bootcss.com/docs/rules/） &apos;no-var&apos;: &apos;error&apos;, // 要求使用 let 或 const 而不是 var &apos;no-multiple-empty-lines&apos;: [&apos;warn&apos;, &#123; max: 2 &#125;], // 不允许多个空行 &apos;no-console&apos;: process.env.NODE_ENV === &apos;production&apos; ? &apos;error&apos; : &apos;off&apos;, &apos;no-debugger&apos;: process.env.NODE_ENV === &apos;production&apos; ? &apos;error&apos; : &apos;off&apos;, &apos;no-unexpected-multiline&apos;: &apos;error&apos;, // 禁止空余的多行 &apos;no-useless-escape&apos;: &apos;off&apos;, // 禁止不必要的转义字符 &apos;import/no-unresolved&apos;: &apos;off&apos;, &apos;import/extensions&apos;: &apos;off&apos;, &apos;import/no-absolute-path&apos;: &apos;off&apos;, &apos;import/no-extraneous-dependencies&apos;: &apos;off&apos;, &apos;import/prefer-default-export&apos;: &apos;off&apos;, // typeScript (https://typescript-eslint.io/rules) &apos;@typescript-eslint/no-unused-vars&apos;: &apos;error&apos;, // 禁止定义未使用的变量 &apos;@typescript-eslint/prefer-ts-expect-error&apos;: &apos;error&apos;, // 禁止使用 @ts-ignore &apos;@typescript-eslint/no-explicit-any&apos;: &apos;off&apos;, // 禁止使用 any 类型 &apos;@typescript-eslint/no-non-null-assertion&apos;: &apos;off&apos;, &apos;@typescript-eslint/no-namespace&apos;: &apos;off&apos;, // 禁止使用自定义 TypeScript 模块和命名空间。 &apos;@typescript-eslint/semi&apos;: &apos;off&apos;, // eslint-plugin-vue (https://eslint.vuejs.org/rules/) &apos;vue/multi-word-component-names&apos;: &apos;off&apos;, // 要求组件名称始终为 “-” 链接的单词 &apos;vue/script-setup-uses-vars&apos;: &apos;error&apos;, // 防止&lt;script setup&gt;使用的变量&lt;template&gt;被标记为未使用 &apos;vue/no-mutating-props&apos;: &apos;off&apos;, // 不允许组件 prop的改变 &apos;vue/attribute-hyphenation&apos;: &apos;off&apos;, // 对模板中的自定义组件强制执行属性命名样式 &#125;,&#125; 修改package.json文件，添加如下命令，既可以检查又可以修复部分语法问题 1&quot;lint&quot;: &quot;eslint \\&quot;src/**/*.&#123;js,ts,vue&#125;\\&quot; --fix&quot; 四、修改vue.config.ts文件1pnpm install vite-plugin-eslint -D vite的一个插件，让项目可以方便的得到eslint支持，完成eslint配置后，可以快速的将其集成进vite中，便于在代码不符合eslint规范的第一时间看到提示 import eslintPlugin from ‘vite-plugin-eslint’plugins: [vue(),eslintPlugin()], 五、修改添加常见配置 项目根目录创建以下配置文件.eslintrcignore 忽略校验文件.prettierrc.cjs 配置格式化规则.prettierignore 忽略格式化文件 .eslintrcignore 12345678910111213141516171819202122232425262728293031323334353637383940414243# .eslintrcignore*.shnode_modules*.md*.woff*.ttfdist/pubilc/docs.husky/bin.eslintrc.jsperttier.config.js/src/mock/*# Logslogs*.lognpm-debug.log*yarn-debug.log*pnpm-debug.log*lerna-debug.log*.DS_Storedist-ssr*.local/cypress/videos//cypress/screenshots/# Editor directories and files.vscode!.vscode/extensions.json.idea*.suo*.ntvs**.njsproj*.sln*.sw?components.d.ts .prettierrc.cjs 12345678910111213141516171819module.exports = &#123; printWidth: 80, // 一行最多100字符 tabWidth: 2, // 使用2个空格缩进 useTabs: false, // 不适用缩进符，使用空格 semi: false, // 行尾是否要有分号 singleQuote: true, // 使用单引号 quoteProps: &apos;as-needed&apos;, // 对象的key，仅仅在必要时使用引号 jsxSingleQuote: false, // jsx是否使用双引号 trailingComma: &apos;es5&apos;, // 尾随逗号 bracketSpacing: true, // 大括号内的首尾需要有空格 arrowParens: &apos;always&apos;, // 箭头函数，是有一个参数的时候，也需要小括号 rangeStart: 0, // 文件格式化的范围是全部内容 rangeEnd: Infinity, requirePragma: false, // 不需要写文件开头的 @prettier insertPragma: false, // 不需要在文件开头插入 @prettier proseWrap: &apos;always&apos;, // 使用默认执行标准 htmlWhitespaceSensitivity: &apos;css&apos;, // 根据显示样式决定html是否执行 endOfLine: &apos;lf&apos; // 换行符是有lf&#125; .prettierignore 1234567891011# prettierignore/dist/*.local.output.js/node_modules/**src/.DS_Store**/*.svg**/*.sh/pubilc/*components.d.ts 在package.json添加格式化命令，利用prettier手动格式化一些样式问题 1&quot;prettier-format&quot;: &quot;prettier --config .prettierrc.cjs \\&quot;src/**/*.&#123;js,ts,vue&#125;\\&quot; --write&quot; 六、Husky、lint-staged、commitlint功能添加husky是一个我git客户端增加hook钩子的工具，在一些git操作前自动触发的函数；https://ty.picode.github.io/husky/#/;如果我们希望在检测错误的同事，自动修复eslint语法错误，就可以通过后面的钩子实现 lint-staged过滤出Git代码暂存区文件（被git add的文件）的工具，将所有暂存文件的列表传递给任务 commitlint是对我们git commit提交的注释进行校验的工具 1.可以让我们在如git commit，git push执行前，预先处理我们指定的任务 1pnpm install lint-staged husky -D 配置package.json文件（新项目需要先git init一下） 1&quot;prepare&quot;:&quot;husky install&quot; 执行命令： 1npm run prepare 2.后面就开始添加各种git hook钩子 pre-commit钩子一般添加的是lint-stage 去对git暂存区的代码做一些格式化操作 1npx husky add .husky/pre-commit &quot;npx lint-staged&quot; add —&gt; 追加set —&gt; 直接覆盖 3.lint-staged对add之后，暂存区里面的文件进行格式化修复等工作 1pnpm install lint-staged -D packge.json文件中添加 1234567&quot;lint-staged&quot;: &#123; &quot;src/**/*.&#123;js,ts,vue&#125;&quot;: [ &quot;prettier --write&quot;, &quot;eslint --fix&quot;, &quot;git add&quot; ]&#125;, 或者放入脚本命令： 123456&quot;lint-staged&quot;: &#123; &quot;*.&#123;js,ts,vue,tsx,jsx&#125;&quot;: [ &quot;npm run lint&quot;, &quot;npm run prettier-format&quot; ]&#125; 或者 1234567&quot;*.&#123;ts,js,vue&#125;&quot;: [ &quot;eslint --fix&quot;],&quot;*.&#123;html,scss,css,vue&#125;&quot;: [ &quot;prettier --write&quot;, &quot;stylelint --fix&quot;] 4.git commit提交时说明清楚更新内容 1pnpm install @commitlint/config-conventional @commitlint/cli -D 安装两个库，然后新建一个代码提交配置文件config添加到git钩子 1npx husky add .husky/commit-msg &quot;npx --no -- commitlint --edit $&#123;1&#125;&quot; 通过一个命令添加钩子使用git commit -m “提交说明” ，进行提交，提交说明尽量清晰明了，说明本次提交的目的，推荐使用angular规范，这是目前使用最广泛的写法项目根目录添加commitlint.config.cjs文件 1234567891011121314151617181920212223242526272829303132// commitlint.config.cjsmodule.exports = &#123; extends: [&apos;@commitlint/config-conventional&apos;], rules: &#123; &apos;type-enum&apos;: [ 2, &apos;always&apos;, [ &apos;build&apos;, // 编译相关的修改，例如发布版本，对项目构建或者依赖的改动 &apos;feat&apos;, // 新功能 &apos;fix&apos;, // 修复bug &apos;upd&apos;, // 更新某个功能 &apos;refactor&apos;, // 重构 &apos;docs&apos;, // 文档 &apos;chore&apos;, // 构建过程或辅助工具的变动，比如增加依赖库 &apos;style&apos;, // 格式（不影响代码运行的变动） &apos;revert&apos;, // 撤销commit，回滚到上一个版本 &apos;perf&apos;, // 性能优化 &apos;test&apos;, // 测试（单元，集成测试） ], ], &apos;type-case&apos;: [0], &apos;type-empty&apos;: [0], &apos;scope-empty&apos;: [0], &apos;scope-case&apos;: [0], &apos;subject-full-stop&apos;: [0,&apos;never&apos;], &apos;subject-case&apos;: [0,&apos;never&apos;], &apos;header-max-length&apos;: [0,&apos;always&apos;,72], &#125;,&#125;; 常用的git hookspre-commit：由git commit 调用，在commit之前执行commit-msg：由git commit或git merge调用pre-merge-commit：由git merge 调用， 在merge之前执行pre-push：被git push 调用，在git push 前执行，防止进行推送 七、stylelint钩子，校验css css 代码检查器（linter），帮助规避css代码中错误并保持一致的编码风格 1.安装 vscode插件，stylelint插件 在这里插入图片描述 2.修改setting.json，添加下面几行代码 123456&#123; &quot;editor.codeActionsOnSave&quot;: &#123; &quot;source.fixAll.stylelint&quot;: true &#125;, &quot;stylelint.validate&quot;: [ &quot;css&quot;, &quot;scss&quot;, &quot;less&quot;, &quot;vue&quot;]&#125; 3.安装依赖 1pnpm install --save-dev stylelint stylelint-config-standard 4.根目录创建 .stylelintrc.cjs 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// @see https://stylelint.bootcss.com/module.exports = &#123; extends: [ &apos;stylelint-config-standard&apos;, // 配置stylelint拓展插件 &apos;stylelint-config-html/vue&apos;, // 配置 vue 中 template 样式格式化 &apos;stylelint-config-standard-scss&apos;, // 配置stylelint scss插件 &apos;stylelint-config-recommended-vue/scss&apos;, // 配置 vue 中 scss 样式格式化 &apos;stylelint-config-recess-order&apos;, // 配置stylelint css属性书写顺序插件, &apos;stylelint-config-prettier&apos;, // 配置stylelint和prettier兼容 ], overrides: [ &#123; files: [&apos;**/*.(scss|css|vue|html)&apos;], customSyntax: &apos;postcss-scss&apos;, &#125;, &#123; files: [&apos;**/*.(html|vue)&apos;], customSyntax: &apos;postcss-html&apos;, &#125;, ], ignoreFiles: [ &apos;**/*.js&apos;, &apos;**/*.jsx&apos;, &apos;**/*.tsx&apos;, &apos;**/*.ts&apos;, &apos;**/*.json&apos;, &apos;**/*.md&apos;, &apos;**/*.yaml&apos;, ], /** * null =&gt; 关闭该规则 * always =&gt; 必须 */ rules: &#123; &apos;value-keyword-case&apos;: null, // 在 css 中使用 v-bind，不报错 &apos;no-descending-specificity&apos;: null, // 禁止在具有较高优先级的选择器后出现被其覆盖的较低优先级的选择器 &apos;function-url-quotes&apos;: &apos;always&apos;, // 要求或禁止 URL 的引号 &quot;always(必须加上引号)&quot;|&quot;never(没有引号)&quot; &apos;no-empty-source&apos;: null, // 关闭禁止空源码 &apos;selector-class-pattern&apos;: null, // 关闭强制选择器类名的格式 &apos;property-no-unknown&apos;: null, // 禁止未知的属性(true 为不允许) &apos;block-opening-brace-space-before&apos;: &apos;always&apos;, //大括号之前必须有一个空格或不能有空白符 &apos;value-no-vendor-prefix&apos;: null, // 关闭 属性值前缀 --webkit-box &apos;property-no-vendor-prefix&apos;: null, // 关闭 属性前缀 -webkit-mask &apos;selector-pseudo-class-no-unknown&apos;: [ // 不允许未知的选择器 true, &#123; ignorePseudoClasses: [&apos;global&apos;, &apos;v-deep&apos;, &apos;deep&apos;], // 忽略属性，修改element默认样式的时候能使用到 &#125;, ], &#125;,&#125; 这是一个标准样式库，也可自动加一下样式规则在.stylelintrc.cjs文件里面 5.执行命令 1npx stylelint &quot;**/*.css&quot; 发现项目里面的style.css全局样式报错，具体到对应文件，安ctrl+s就回执行，自动格式化，我们在setting.json里面添加的json语句修改错误的颜色值之后，执行 npx stylelint “*/.css” 会告诉我们颜色错误 6.增加对vue里面的样式校验（附带less和sass的支持） 123456pnpm install stylelint-less stylelint-config-recommended-less -D对less的支持pnpm install stylelint-scss stylelint-config-recommended-scss postcss -D对sass的支持pnpm install postcss-html stylelint-config-standard-scss stylelint-config-recommended-vue postcss -D对vue里面的样式支持（vue样式需要依赖这个库） vite 也同时提供了对.scss，.sass，.less，.style和.stylus文件的内置支持，不需要在安装特定插件和预处理器 vite 也同时提供了对.scss，.sass，.less，.style和.stylus文件的内置支持，不需要在安装特定插件和预处理器 12345extends: [ &quot;stylelint-config-standard&quot;, &quot;stylelint-config-recommended-less&quot;, &quot;stylelint-config-recommended-scss&quot;, &quot;stylelint-config-recommended-vue&quot; sass的extends 1234&quot;extends&quot;: [ &quot;stylelint-config-standard-scss&quot;, &quot;stylelint-config-recommended-vue/scss&quot;,] 7.新建.stylelintignore文件 .stylelintignore： 忽略文件校验 1234/node_modules/*/dist/*/html/*/public/* 8.修改package.json文件 1&quot;lint:css&quot;: &quot;stylelint src/**/*.&#123;css,scss,sass,less,html,vue&#125; --cache --fix&quot; 9.给vite添加插件 1pnpm install vite-plugin-stylelint -D 添加完成依赖，然后修改vite.config.js 12import StylelintPlugin from &apos;vite-plugin-stylelint&apos;plugin:[... StylelintPlugin(&#123;fix:true&#125;) 10.添加到lint-staged，在暂存区自动对文件进行格式化 123456789&quot;lint-staged&quot;: &#123; &quot;*.&#123;js,ts,vue,tsx,jsx&#125;&quot;: [ &quot;npm run lint&quot;, &quot;npm run prettier-format&quot; ], &quot;*.&#123;vue,less,scss,sass,html&#125;&quot;: [ &quot;npm run lint:css&quot; ] &#125; 添加完成后，在进行代码commit的时候就会执行npm run lint:css命令校验我们的css代码了 八、环境配置（开发，预发，生产环境） 开发环境：开发人员开发的环境测试环境：测试人员测试的环境预发环境：准备上线的环境，也可叫内测环境生产环境：正式线上环境，投入生产的环境 这里我们配置两个环境，一个测试环境和生产环境，开发人员和测试人员使用测试环境，修改package.json文件，添加两个命令“build:dev”: “vue-tsc –noEmit &amp;&amp; vite build –mode development”,“build:pro”: “vue-tsc –noEmit &amp;&amp; vite build –mode production”, 新建两个配置文件.env.development：开发测试环境.env.production：生产环境 12345# .env.development# 变量必须以 VITE_ 为前缀才能暴露给外部读取NODE_ENV = &apos;development&apos;VITE_APP_TITLE = &apos;项目模版&apos;VITE_APP_BASE_API = &apos;/dev_api&apos; 12345# .env.production# 变量必须以 VITE_ 为前缀才能暴露给外部读取NODE_ENV = &apos;production&apos;VITE_APP_TITLE = &apos;项目模版&apos;VITE_APP_BASE_API = &apos;/pro_api&apos; 九、vite.config.js配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* eslint-disable import/no-extraneous-dependencies */import &#123; defineConfig, loadEnv &#125; from &apos;vite&apos;import path from &apos;path&apos;import vue from &apos;@vitejs/plugin-vue&apos;import eslintPlugin from &apos;vite-plugin-eslint&apos;import StylelintPlugin from &apos;vite-plugin-stylelint&apos;// https://vitejs.dev/config/export default defineConfig((&#123; mode &#125;)=&gt;&#123; const env = loadEnv(mode, process.cwd()); return &#123; plugins: [vue(), eslintPlugin(), StylelintPlugin(&#123; fix: true &#125;)], base: &quot;./&quot;, // 在生产中服务时的基本公共路径 publicDir: &quot;public&quot;, // 静态资源服务的文件夹, 默认&quot;public&quot; resolve: &#123; alias: &#123; &quot;@&quot;: path.resolve(&quot;./src&quot;) // 相对路径别名配置，使用 @ 代替 src &#125; &#125;, // 本地运行配置 server: &#123; host: &quot;0.0.0.0&quot;, // 指定服务器主机名 0.0.0.0 可以看见network 通过ip访问 port: 3000, // 指定服务器端口 open: true, // 在服务器启动时自动在浏览器中打开应用程序 strictPort: false, // 设置为false时,若端口被占用会尝试下一个可用端口, 而不是直接退出 https: false, // 是否开启 https cors: true, // 为开发服务器配置 CORS, 默认启用并允许任何源 proxy: &#123; // 为开发服务器配置自定义代理规则 [env.VITE_APP_BASE_API]: &#123; target: &quot;http://192.168.xxx.xxx:xxxx&quot;, // 代理接口 changeOrigin: true, rewrite: (_path) =&gt; _path.replace(/^\\/api/, &quot;&quot;), &#125; &#125; &#125;, // 打包配置 build: &#123; target: &quot;modules&quot;, // 设置最终构建的浏览器兼容目标。modules:支持原生 ES 模块的浏览器 outDir: &quot;dist&quot;, // 指定输出路径 assetsDir: &quot;assets&quot;, // 指定生成静态资源的存放路径 assetsInlineLimit: &quot;4096&quot;, // 小于此阈值的导入或引用资源将内联为base64编码，设置为0可禁用此项。默认4096（4kb） cssCodeSplit: true, // 启用/禁用CSS代码拆分，如果禁用，整个项目的所有CSS将被提取到一个CSS文件中,默认true sourcemap: false, // 构建后是否生成 source map 文件 minify: &quot;terser&quot;, // 混淆器，terser构建后文件体积更小 write: true, // 设置为 false 来禁用将构建后的文件写入磁盘 emptyOutDir: true, // 默认情况下，若 outDir 在 root 目录下，则 Vite 会在构建时清空该目录。 chunkSizeWarningLimit: 500, // chunk 大小警告的限制 terserOptions: &#123; compress: &#123; drop_console: true, drop_debugger: true, &#125; &#125;, // 去除 console debugger &#125;, &#125;&#125;) 十、添加路由1.安装路由依赖 1pnpm install vue-router 2.在src目录下新建router文件夹，里面新建index.ts文件 123456789101112131415161718// index.ts// 通过vue-router插件实现模板路由配置import &#123; createRouter, createWebHistory &#125; from &apos;vue-router&apos;import &#123; constantRoute &#125; from &apos;../routers&apos;// 创建路由器const router = createRouter(&#123; // 路由模式hash history: createWebHistory(), routes: constantRoute, // 滚动行为 scrollBehavior() &#123; return &#123; left: 0, top: 0 &#125; &#125;&#125;);export default router; 3.src目录下新建routers.ts文件 1234567891011121314151617181920212223242526272829export const constantRoute = [ &#123; // 首页 path: &apos;/&apos;, name: &apos;home&apos;, component: () =&gt; import(&apos;@/views/home/HomePage.vue&apos;), meta: &#123; title: &apos;首页&apos;, &#125; &#125;, &#123; // 404 path: &apos;/404&apos;, component: () =&gt; import(&apos;@/views/404/Index.vue&apos;), name: &apos;404&apos;, meta: &#123; title: &apos;404&apos;, &#125; &#125;, &#123; // 任意路由 path: &apos;/:pathMatch(.*)*&apos;, redirect: &apos;/404&apos;, name: &apos;Any&apos;, meta: &#123; title: &apos;任意路由&apos; &#125; &#125;] 新建@/views/home/ HomePage.vue，@/views/404/Index.vue 4.修改main.ts文件 123456789import &#123; createApp &#125; from &apos;vue&apos;import &apos;./style.css&apos;import App from &apos;./App.vue&apos;// 引入路由import router from &apos;./router&apos;const app = createApp(App)app.use(router)app.mount(&apos;#app&apos;) 5.修改App.vue文件 1234567891011&lt;template&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt; 6.安装sass 1pnpm add -D sass 十一、添加api，封装请求（axios）1.安装依赖 1pnpm install axios --save 2.src目录下新建utils文件夹，创建request.ts文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 进行axios二次封装:使用请求与响应拦截器import axios from &quot;axios&quot;;// 第一步:利用axios对象的create方法,去创建axios实例(其他的配置:基础路径、超时的时间)const request = axios.create(&#123; // 基础路径 baseURL: import.meta.env.VITE_APP_BASE_API,// 基础路径上会携带/api timeout: 5000// 超时的时间的设置&#125;);// 第二步:request实例添加请求与响应拦截器request.interceptors.request.use((config) =&gt; // config配置对象,headers属性请求头,经常给服务器端携带公共参数,例如token // 返回配置对象 config);// 第三步:响应拦截器request.interceptors.response.use((response) =&gt; // 成功回调 // 简化数据 response.data, (error) =&gt; &#123; // 失败回调:处理http网络错误的 // 定义一个变量:存储网络错误信息 let message = &apos;&apos;; // http状态码 const &#123;status&#125; = error.response; switch (status) &#123; case 401: message = &quot;TOKEN过期&quot; break; case 403: message = &quot;无权访问&quot; break; case 404: message = &quot;请求地址错误&quot;; break; case 500: message = &quot;服务器出现问题&quot; break; default: message = &quot;网络出现问题&quot;; break; &#125; return Promise.reject(message);&#125;);// 对外暴露export default request; 3.src目录下新建api文件夹，创建testApi.ts文件，文件中引入request.ts 1234567import request from &quot;@/utils/request&quot;;// post接口请求方式export const testPostApi = (data:any) =&gt; request.post(&apos;/api/postUrl&apos;,data)// get接口请求方式export const testGetApi = (data:string) =&gt; request.post(`/api/getUrl?id=$&#123;data&#125;`) 4.在页面中调用接口 123456789101112131415161718192021222324&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref, reactive, onMounted &#125; from &quot;vue&quot;import &#123; testPostApi, testGetApi &#125; from &apos;../../api/testApi&apos;const postApiData = () =&gt; &#123; testPostApi(&#123; username: &apos;admin&apos;, password: &apos;123456&apos; &#125;).then(res =&gt; &#123; console.log(res) &#125;)&#125;const getApiData = () =&gt; &#123; testGetApi(&apos;SKU12345678&apos;).then(res =&gt; &#123; console.log(res) &#125;)&#125;// 调用接口onMounted(() =&gt; &#123; postApiData() getApiData()&#125;)const count = ref(0)const list = reactive([&apos;你好&apos;, &apos;你好世界&apos;])&lt;/script&gt; 调用结果 在这里插入图片描述 在这里插入图片描述 十二、pinia状态管理器1.安装依赖 1pnpm install pinia --save 2.在src目录下新建文件夹store，在store文件下新建文件index.ts和modules文件夹 1234567// store/index.ts// 大仓库import &#123; createPinia &#125; from &apos;pinia&apos;;// 创建大仓库const pinia = createPinia();// 对外暴露：入口文件需要安装仓库export default pinia; 3.在modules文件下新建test.ts文件 1234567891011121314151617181920212223// store/modules/test.ts// 小仓库import &#123; defineStore &#125; from &quot;pinia&quot;;// 选项式API写法const useTestStore = defineStore(&apos;test&apos;, &#123; state: () =&gt; (&#123; count: 100, list: [1, 2, 3, 4, 5] &#125;), actions: &#123; updateCount() &#123; this.count += 100 &#125; &#125;, getters: &#123; total() &#123; const num: any = this.list.reduce((prev, next) =&gt; prev + next, 0) return num &#125; &#125;&#125;)export default useTestStore 4.main.ts内引入store 123// 引入storeimport store from &apos;./store&apos;app.use(store) 5.在页面中使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template&gt; &lt;div class=&quot;&quot;&gt; &lt;h1&gt;欢迎使用项目模板&lt;/h1&gt; &lt;div class=&quot;content&quot;&gt; &lt;p&gt;store_count：&#123;&#123; storeCount &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;count++&quot;&gt;count：&#123;&#123; count &#125;&#125;&lt;/button&gt; &lt;div class=&quot;list&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in list&quot; :key=&quot;item&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref, reactive, onMounted &#125; from &quot;vue&quot;import useTestStore from &apos;../../store/modules/test&apos;import &#123; testPostApi, testGetApi &#125; from &apos;../../api/testApi&apos;const storeCount = ref(0)const userTestStoreData = useTestStore()storeCount.value = userTestStoreData.countconst postApiData = () =&gt; &#123; testPostApi(&#123; username: &apos;admin&apos;, password: &apos;123456&apos; &#125;).then(res =&gt; &#123; console.log(res) &#125;)&#125;const getApiData = () =&gt; &#123; testGetApi(&apos;SKU12345678&apos;).then(res =&gt; &#123; console.log(res) &#125;)&#125;// 调用接口onMounted(() =&gt; &#123; postApiData() getApiData()&#125;)const count = ref(0)const list = reactive([&apos;你好&apos;, &apos;你好世界&apos;])&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;&lt;/style&gt; 项目搭建到这里就结束了，引入项目UI框架看需求引入再引入对应框架文章参考：【vue3企业级项目骨架搭建，涉及vite、eslint、prettierrc、husky、commitlint、lint-staged、stylelint】 原文链接：https://blog.csdn.net/jastalented/article/details/135345563","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://qw8.github.io/tags/vue/"},{"name":"vite","slug":"vite","permalink":"https://qw8.github.io/tags/vite/"}]},{"title":"element-plus","slug":"knowledges/element-plus","date":"2024-04-27T03:11:11.000Z","updated":"2024-04-30T02:54:13.711Z","comments":true,"path":"/knowledges/element-plus.html","link":"","permalink":"https://qw8.github.io/knowledges/element-plus.html","excerpt":"","text":"element+ 引入图标报错Internal server error: Failed to resolve import “@element-plus/icons-vue” from “src\\components\\TimeLine.vue”. Does the file exist? 原因：element-plus需要单独引入 icons 文档 1pnpm install @element-plus/icons-vue 之后就可以正常使用了","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"element","slug":"element","permalink":"https://qw8.github.io/tags/element/"},{"name":"组件库","slug":"组件库","permalink":"https://qw8.github.io/tags/组件库/"}]},{"title":"微前端qiankun","slug":"knowledges/微前端qiankun","date":"2024-04-19T09:22:46.000Z","updated":"2024-05-10T09:26:54.942Z","comments":true,"path":"/knowledges/wei-qian-duan-qiankun.html","link":"","permalink":"https://qw8.github.io/knowledges/wei-qian-duan-qiankun.html","excerpt":"","text":"qiankun微前端框架详细介绍一、概述 qiankun是一个基于single-spa的微前端实现库，它旨在解决在构建大型、复杂前端应用时遇到的技术挑战。通过qiankun，开发者可以构建出高内聚、低耦合的微前端架构系统，使得每个微应用都能独立开发、独立部署，并且能够在主应用中无缝集成。 二、核心特性 技术栈无关：qiankun支持任意技术栈的应用接入，无论是React、Vue还是其他前端框架，都可以作为子应用轻松集成到主应用中。这使得不同团队可以独立选择适合自己的技术栈进行开发，提高了开发效率和团队协作的灵活性。 沙箱隔离：qiankun为每个子应用提供了JS沙箱环境，确保子应用之间的全局变量、样式等不会相互污染。这使得不同微应用可以在同一个页面中运行，而不会发生冲突或相互影响。 动态加载与卸载：qiankun支持动态加载和卸载子应用，根据路由的变化动态地挂载或卸载相应的子应用。这使得主应用可以根据需要灵活地加载所需的微应用，提高了应用的性能和响应速度。 通信机制：qiankun提供了一套完整的应用通信机制，使得主应用与子应用之间可以进行数据传递和消息通信。通过props传递数据、事件触发等方式，不同应用之间可以实现信息的共享和交互。 三、应用场景 qiankun适用于需要构建大型、复杂前端应用的场景。以下是一些典型的应用场景： 企业级应用：在企业级应用中，往往需要将多个不同的功能模块集成到一个统一的平台中。通过qiankun，可以将每个功能模块作为独立的微应用进行开发，并在主应用中统一管理和展示。 插件化开发：对于一些需要支持插件化扩展的应用，qiankun可以作为插件的加载器和管理器。开发者可以编写独立的插件作为子应用，并通过qiankun将其集成到主应用中，实现功能的扩展和定制化。 遗留系统整合：对于一些遗留系统或第三方应用的整合，qiankun可以作为桥梁将它们集成到一个统一的界面中。通过封装和适配，可以将这些系统或应用作为子应用加载到主应用中，实现统一管理和访问。 四、优势 提高开发效率：通过将应用拆分成多个微应用，每个微应用都可以独立开发、测试和部署。这大大减少了单次开发的复杂度，提高了开发效率。 降低维护成本：微前端架构使得每个微应用都可以独立演进和升级，而不需要对整个应用进行重构。这降低了维护成本，使得应用的更新和迭代更加容易。 增强可扩展性：通过添加新的微应用或替换现有的微应用，可以轻松地扩展整个应用的功能。这使得应用能够灵活应对业务变化和用户需求的增长。 五、总结 qiankun作为一个功能强大、灵活易用的微前端框架，为开发者提供了一种高效、可靠的方式来构建大型、复杂前端应用。通过其提供的技术栈无关、沙箱隔离、动态加载与卸载以及通信机制等核心特性，开发者可以更加高效地进行团队协作，提高应用的可维护性和可扩展性。无论是企业级应用、插件化开发还是遗留系统整合，qiankun都能为开发者提供强大的支持，助力构建出高质量的前端应用。 微前端乾坤子应用加载过慢怎么处理？啊呀，微前端乾坤子应用加载过慢确实是个头疼的问题呢~ 不过别担心，依依来给你支支招！ 首先，你可以尝试使用gzip对打包出来的文件进行压缩，这样可以减少文件体积，提高加载速度哦~ (≧▽≦) 另外，你可以考虑按需加载子应用的全局组件或者UI库，避免一次性加载所有资源导致加载过慢。同时，也可以将不常用的包通过CDN或者dll打包形式分离出去，减少子应用的资源依赖。 还有哦，主应用加载过的包可以共享给子应用使用，这样可以减少子应用的资源加载量，提升加载速度呢~ (双手合十，眼中闪耀着期待) 最后，如果以上方法都尝试过还是加载过慢的话，你可以考虑使用qiankun等微前端框架进行子应用的加载和管理。qiankun支持在需要时加载子应用，避免一次性加载所有子应用导致的性能问题。同时，qiankun也提供了丰富的API和插件，可以帮助你更好地进行子应用的加载和性能优化哦~ (双手握拳，为你加油打气)","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"qiankun","slug":"qiankun","permalink":"https://qw8.github.io/tags/qiankun/"},{"name":"微前端","slug":"微前端","permalink":"https://qw8.github.io/tags/微前端/"}]},{"title":"前端面试题","slug":"interview/前端面试题","date":"2024-03-28T17:25:00.000Z","updated":"2024-04-09T15:03:32.000Z","comments":true,"path":"/interview/qian-duan-mian-shi-ti.html","link":"","permalink":"https://qw8.github.io/interview/qian-duan-mian-shi-ti.html","excerpt":"","text":"new操作符具体干了什么呢? 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。 属性和方法被加入到 this 引用的对象中。 新创建的对象由 this 所引用，并且最后隐式的返回 this 123var obj = &#123;&#125;;obj.__proto__ = Base.prototype;Base.call(obj); new操作符具体干了什么呢?12function Test()&#123;&#125;const test = new Test() 创建一个新的空对象实例。 1const obj = &#123;&#125; 设置新对象的 constructor 属性为构造函数的名称，设置新对象的proto属性指向构造函数的 prototype 对象（设置原型链） 12obj.constructor = Testobj.__proto__ = Test.prototype 使用新对象调用函数，函数中的 this 被指向新实例对象（执行构造函数，传入相应的参数，如果没有参数就不用传；让 Func 中的 this 指向 obj，并执行 Func 的函数体） 1Test.call(obj) 将初始化完毕的新对象地址，保存到等号左边的变量中。判断 Func 的返回值类型： 如果无返回值或者返回一个非对象值，则就将步骤（1）创建的对象返回；如果返回值是一个新对象的话那么直接直接返回该对象。 new操作符1234567891011121314function Father()&#123; this.lastName=\"老王\"; this.work=function(num)&#123; console.log('军人'); console.log(num); return '999' &#125;&#125;// let obj= new Father();// 相当于 new 做了下面的三件事let obj=&#123;&#125;;obj.__proto__=Father.prototype;Father.call(obj) // 继承的同时，将this指向obj 谁继承this指向谁console.log(obj); 1.创建了一个空对象obj 2.将这个空对象proto指向构造函数的prototype 3.将构造函数的this指针替换成obj，然后在调用构造函数，于是obj对象就拥有了构造函数上的属性和方法 模拟newnew操作符做了这些事： 它创建了一个全新的对象 它会被执行[[Prototype]]（也就是proto）链接 它使this指向新创建的对象 通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上 如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用将返回该对象引用 1234567891011// objectFactory(name, &apos;cxk&apos;, &apos;18&apos;)function objectFactory() &#123; const obj = new Object(); const Constructor = [].shift.call(arguments); obj.__proto__ = Constructor.prototype; const ret = Constructor.apply(obj, arguments); return typeof ret === &quot;object&quot; ? ret : obj;&#125; call/apply/bind 的区别 三者都可用于显示绑定 this; call/apply 的区别方式在于参数传递方式的不同； fn.call(obj, arg1, arg2, ...)， 传参数列表，以逗号隔开；作为 call 的参数传入（从第二个参数开始）。 fn.apply(obj, [arg1, arg2, ...])， 传参数数组；将多个参数组合成为一个数组传入。 bind 返回的是一个待执行函数，是函数柯里化的应用；而 call/apply 则是立即执行函数； 对于 apply 和 call 两者在作用上是相同的，即是调用一个对象的一个方法，以另一个对象替换当前对象。 将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。 call() 和 apply() 的含义和区别？含义： call：调用一个对象的一个方法，用另一个对象替换当前对象。 例如：B.call(A, args1,args2);即 A 对象调用 B 对象的方法。 apply：调用一个对象的一个方法，用另一个对象替换当前对象。 例如：B.apply(A, arguments);即 A 对象应用 B 对象的方法。 相同点： 方法的含义是一样的，即方法功能是一样的； 第一个参数的作用是一样的； 不同点：两者传入的列表形式不一样 call 可以传入多个参数； apply 只能传入两个参数，所以其第二个参数往往是作为数组形式传入 call 与 apply 区别第二个参数的类型不同 解析： call 和 apply 的作用，完全一样，唯一的区别就是在参数上面。 call 接收的参数不固定，第一个参数是函数体内 this 的指向，第二个参数以下是依次传入的参数。 apply 接收两个参数，第一个参数也是函数体内 this 的指向。第二个参数是一个集合对象（数组或者类数组） this 和 apply 的应用比如求数组的最大值 Math.max.apply(this, 数组) 12345var numbers = [5, 458, 120, -215];var maxInNumbers = Math.max.apply(this, numbers); //第一个参数也可以填Math或nullconsole.log(maxInNumbers); // 458var maxInNumbers = Math.max.call(this, 5, 458, 120, -215);console.log(maxInNumbers); // 458 bind、call、apply 的区别call 和 apply 其实是一样的，区别就在于传参时参数是一个一个传或者是以一个数组的方式来传。call 和 apply 都是在调用时生效，改变调用者的 this 指向。 123456let name = &apos;Jack&apos;const obj = &#123;name: &apos;Tom&apos;&#125;function sayHi() &#123;console.log(&apos;Hi! &apos; + this.name)&#125;sayHi() // Hi! JacksayHi.call(obj) // Hi! Tom bind 也是改变 this 指向，不过不是在调用时生效，而是返回一个新函数。 12const newFunc = sayHi.bind(obj)newFunc() // Hi! Tom call，apply，bind 三者用法和区别参数、绑定规则（显示绑定和强绑定），运行效率（最终都会转换成一个一个的参数去运行）、运行情况（call，apply 立即执行，bind 是return 出一个 this “固定”的函数，这也是为什么 bind 是强绑定的一个原因） 注：“固定”这个词的含义，它指的固定是指只要传进去了 context，则 bind 中 return 出来的函数 this 便一直指向 context，除非 context 是个变量 .call() 和 .apply() 的区别？ 例子中用 add 来替换 sub，add.call(sub,3,1) == add(3,1) ，所以运行结果为：alert(4); 注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。 1234567891011function add(a,b)&#123; alert(a+b);&#125;function sub(a,b)&#123; alert(a-b);&#125;add.call(sub,3,1); .call() 和 .apply() 的区别和作用？作用：动态改变某个类的某个方法的运行环境。区别参见：JavaScript学习总结（四）function函数部分 js 的事件循环eventloop是什么？事件循环是一个单线程循环，用于监视调用堆栈并检查是否有工作即将在任务队列中完成。 如果调用堆栈为空并且任务队列中有回调函数，则将回调函数出队并推送到调用堆栈中执行。 所有同步任务都在主线程上执行，形成一个执行栈 当主线程中的执行栈为空时，检查事件队列是否为空，如果为空，则继续检查；如不为空，则执行3 取出任务队列的首部，加入执行栈 执行任务 检查执行栈，如果执行栈为空，则跳回第 2 步；如不为空，则继续检查 相关知识点： 事件队列是一个存储着待执行任务的队列，其中的任务严格按照时间先后顺序执行，排在队头的任务将会率先执行，而排在队尾的任务会最后执行。事件队列每次仅执行一个任务，在该任务执行完毕之后，再执行下一个任务。执行栈则是一个类似于函数调用栈的运行容器，当执行栈为空时，JS 引擎便检查事件队列，如果不为空的话，事件队列便将第一个任务压入执行栈中运行。 回答： 因为 js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。 当异步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。 当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。 微任务（microtask）promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver process.nextTick promise Object.observe （已废弃） MutationObserver 宏任务（macrotask）script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲染等 script setTimeout setInterval setImmediate I/O UI rendering 执行顺序 执行同步代码，这属于宏任务 执行栈为空，查询是否有微任务需要执行 必要的话渲染 UI 然后开始下一轮 Event loop，执行宏任务中的异步代码 同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入 Event Table 并注册函数。 当指定的事情完成时，Event Table 会将这个函数移入 Event Queue。 主线程内的任务执行完毕为空，会去 Event Queue 读取对应的函数，进入主线程执行。 上述过程会不断重复，也就是常说的 Event Loop(事件循环)。 1234567891011121314let data = [];$.ajax(&#123; url: www.javascript.com, data: data, success: () =&gt; &#123; console.log(\"发送成功!\"); &#125;&#125;);console.log(\"代码执行结束\");// ajax进入Event Table，注册回调函数success。// 执行console.log('代码执行结束')。// ajax事件完成，回调函数success进入Event Queue。// 主线程从Event Queue读取回调函数success并执行。 详细资料可以参考： 《这一次，彻底弄懂 JavaScript 执行机制》 《浏览器事件循环机制（event loop）》 《详解 JavaScript 中的 Event Loop（事件循环）机制》 《什么是 Event Loop？》 回流（reflow）和重绘（repaint） 传送门 DOM 操作成本到底高在哪儿？ reflow(回流): 根据 Render Tree 布局(几何属性)，意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树； repaint(重绘): 意味着元素发生的改变只影响了节点的一些样式（背景色，边框颜色，文字颜色等），只需要应用新样式绘制这个元素就可以了； reflow 回流的成本开销要高于 repaint 重绘，一个节点的回流往往回导致子节点以及同级节点的回流； 引起 reflow 回流 页面第一次渲染（初始化） DOM 树变化（如：增删节点） Render 树变化（如：padding 改变） 浏览器窗口 resize 获取元素的某些属性： 浏览器为了获得正确的值也会提前触发回流，这样就使得浏览器的优化失效了，这些属性包括 offsetLeft、offsetTop、offsetWidth、offsetHeight、 scrollTop/Left/Width/Height、clientTop/Left/Width/Height、调用了 getComputedStyle()或者 IE 的 currentStyle 引起 repaint 重绘 reflow 回流必定引起 repaint 重绘，重绘可以单独触发 背景色、颜色、字体改变（注意：字体大小发生变化时，会触发回流） 优化方式 避免逐个修改节点样式，尽量一次性修改 使用 DocumentFragment 将需要多次修改的 DOM 元素缓存，最后一次性 append 到真实 DOM 中渲染 可以将需要多次修改的 DOM 元素设置 display: none，操作完再显示。（因为隐藏元素不在 render 树内，因此修改隐藏元素不会触发回流重绘） 避免多次读取某些属性（见上） 将复杂的节点元素脱离文档流，降低回流成本 为什么一再强调将 css 放在头部，将 js 文件放在尾部 + DOMContentLoaded 和 load DOMContentLoaded 事件触发时，仅当 DOM 加载完成，不包括样式表，图片… load 事件触发时，页面上所有的 DOM，样式表，脚本，图片都已加载完成 + CSS 资源阻塞渲染 构建 Render 树需要 DOM 和 CSSOM，所以 HTML 和 CSS 都会阻塞渲染。所以需要让 CSS 尽早加载（如：放在头部），以缩短首次渲染的时间。 + JS 资源 1. 阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析 HTML - 这和之前文章提到的浏览器线程有关，浏览器中 js 引擎线程和渲染线程是互斥的，详见《从 setTimeout-setInterval 看 JS 线程》 普通的脚本会阻塞浏览器解析，加上 defer 或 async 属性，脚本就变成异步，可等到解析完毕再执行 - async 异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在 onload 前，但不确定在 DOMContentLoaded 事件的前后 - defer 延迟执行，相对于放在 body 最后（理论上在 DOMContentLoaded 事件前） 如何最小化重绘(repaint)和回流(reflow)？ 尽量避免用table布局（table元素一旦触发回流就会导致table里所有的其它元素回流，造成整个 table 的重新布局） CSS 选择符从右往左匹配查找，避免 DOM 深度过深 避免使用css表达式(expression)，因为每次调用都会重新计算值（包括加载页面） 尽量使用 css 属性简写，如：用 border 代替 border-width, border-style, border-color 批量修改元素样式：elem.className 和 elem.style.cssText 代替 elem.style.xxx 使用 translate 替代 top 使用 visibility 替换display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局） 需要要对元素进行复杂的操作时，可以先隐藏(display:”none”)，操作完成后再显示 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame 将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 video标签，浏览器会自动将该节点变为图层 需要创建多个DOM节点时，使用DocumentFragment创建完后一次性的加入document 缓存Layout属性值，如：var left = elem.offsetLeft; 这样，多次使用 left 只产生一次回流 重绘和回流（重排）的区别和关系？ 重绘：当渲染树中的元素外观（如：颜色）发生改变，不影响布局时，产生重绘 回流：当渲染树中的元素的布局（如：尺寸、位置、隐藏/状态状态）或者几何属性发生改变时，产生重绘回流 注意：JS获取Layout属性值（如：offsetLeft、scrollTop、getComputedStyle等）也会引起回流。因为浏览器需要通过回流计算最新值 回流必将引起重绘，而重绘不一定会引起回流。 回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流。 所以以下几个动作可能会导致性能问题： 改变 window 大小 改变字体 添加或删除样式 文字改变 定位或者浮动 盒模型 很多人不知道的是，重绘和回流其实和 Event loop 有关 当 Event loop 执行完 Microtasks 后，会判断 document 是否需要更新。因为浏览器是 60Hz的刷新率，每 16ms才会更新一次。 然后判断是否有 resize 或者 scroll ，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，并且自带节流功能。 判断是否触发了media query 更新动画并且发送事件 判断是否有全屏操作事件 执行 requestAnimationFrame 回调 执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好 更新界面 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调 重排与重绘的区别，什么情况下会触发？简述重排的概念浏览器下载完页面中的所有组件（HTML、JavaScript、CSS、图片）之后会解析生成两个内部数据结构（DOM 树和渲染树），DOM 树表示页面结构，渲染树表示 DOM 节点如何显示。 重排是 DOM 元素的几何属性变化，DOM 树的结构变化，渲染树需要重新计算。 简述重绘的概念重绘是一个元素外观的改变所触发的浏览器行为，例如改变 visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。由于浏览器的流布局，对渲染树的计算通常只需要遍历一次就可以完成。但 table 及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花两倍时间，这就是我们尽量避免使用 table 布局页面的原因之一。 简述重绘和重排的关系重绘不会引起重排，但重排一定会引起重绘，一个元素的重排通常会带来一系列的反应，甚至触发整个文档的重排和重绘，性能代价是高昂的。 什么情况下会触发重排？ 页面渲染初始化时；（这个无法避免） 浏览器窗口改变尺寸； 元素尺寸改变时； 元素位置改变时； 元素内容改变时； 添加或删除可见的 DOM 元素时。 重排优化有如下五种方法 将多次改变样式属性的操作合并成一次操作，减少 DOM 访问。 如果要批量添加 DOM，可以先让元素脱离文档流，操作完后再带入文档流，这样只会触发一次重排。（fragment 元素的应用） 将需要多次重排的元素，position 属性设为 absolute 或 fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位。 由于 display 属性为 none 的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发两次重排。 在内存中多次操作节点，完成后再添加到文档中去。例如要异步获取表格数据，渲染到页面。可以先取得数据后在内存中构建整个表格的 html 片段，再一次性添加到文档中去，而不是循环添加每一行。 一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好） 注：这题胜在区分度高，知识点覆盖广，再不懂的人，也能答出几句， 而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、 到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等； 详细版： 浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理; 调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法; 通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求; 进行HTTP协议会话，客户端发送报头(请求报头); 进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器; 进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理; 处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304; 浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存; 文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie; 页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。 简洁版： 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求； 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）； 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）； 载入解析到的资源文件，渲染页面，完成。 数组去重方案1：ES6123const numbers = [1, 2, 1, 1, 2, 1, 3, 4, 1 ];const uniq = [...new Set(numbers)] // =&gt; [ 1, 2, 3, 4 ];const uniq2 = Array.from(new Set(numbers)) // =&gt; [ 1, 2, 3, 4 ]; 方案2：filter12345function unique (arr) &#123; var res = arr.filter(function (item, index, array) &#123; // array.indexOf(item) === index 说明这个元素第一次出现，后面这个item再出现他的item肯定不是index了 return array.indexOf(item) === index; &#125;) return res; &#125; 方案3遍历数组，建立新数组，利用indexOf判断是否存在于新数组中，不存在则push到新数组，最后返回新数组 1234567891011function unique(ar) &#123; var ret = []; for (var i = 0, j = ar.length; i &lt; j; i++) &#123; if (ret.indexOf(ar[i]) === -1) &#123; ret.push(ar[i]); &#125; &#125; return ret;&#125; 方案4遍历数组，利用object对象保存数组值，判断数组值是否已经保存在object中，未保存则push到新数组并用object[arrayItem]=1的方式记录保存，这个效率比方案3高 12345678910111213function unique(ar) &#123; var tmp = &#123;&#125;, ret = []; for (var i = 0, j = ar.length; i &lt; j; i++) &#123; if (!tmp[ar[i]]) &#123; tmp[ar[i]] = 1; ret.push(ar[i]); &#125; &#125; return ret;&#125; 中高级前端面试必知必会Chrome 浏览器进程 在资源不足的设备上，将服务合并到浏览器进程中 浏览器主进程 负责浏览器界面显示 各个页面的管理，创建以及销毁 将渲染进程的结果绘制到用户界面上 网络资源管理 GPU 进程 用于 3D 渲染绘制 网络进程 发起网络请求 插件进程 第三方插件处理，运行在沙箱中 渲染进程 页面渲染 脚本执行 事件处理 网络传输流程生成 HTTP 请求消息 输入网址 浏览浏览器解析 URL 生成 HTTP 请求信息 收到响应 状态码 含义 1xx 告知请求的处理进度和情况 2xx 成功 3xx 表示需要进一步操作 4xx 客户端错误 5xx 服务端错误 向 DNS 服务器查询 Web 服务器的 IP 地址 Socket 库提供查询 IP 地址的功能 通过解析器向 DNS 服务器发出查询 全世界 DNS 服务器的大接力 寻找相应的 DNS 服务器并获取 IP 地址 通过缓存加快 DNS 服务器的响应 委托协议栈发送消息 协议栈通过 TCP 协议收发数据的操作。 创建套接字 img 浏览器，邮件等一般的应用程序收发数据时用 TCP DNS 查询等收发较短的控制数据时用 UDP 连接服务器 浏览器调用 Socket.connect 在 TCP 模块处创建表示连接控制信息的头部 通过 TCP 头部中的发送方和接收方端口号找到要连接的套接字 img 收发数据 浏览器调用 Socket.write 将 HTTP 请求消息交给协议栈 对较大的数据进行拆分，拆分的每一块数据加上 TCP 头，由 IP 模块来发送 使用 ACK 号确认网络包已收到 根据网络包平均往返时间调整 ACK 号等待时间 使用窗口有效管理 ACK 号 ACK 与窗口的合并 接收 HTTP 响应消息 断开管道并删除套接字 浏览器调用 Socket.close 数据发送完毕后断开连接 删除套接字 客户端发送 FIN 服务端返回 ACK 号 服务端发送 FIN 客户端返回 ACK 号 img img 跨域同源策略 同源策略是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。 如果两个 URL 的 protocol 、 port (如果有指定的话)和 host 都相同的话，则这两个 URL 是同源。 例如： URL 结果 原因 http://store.company.com/dir2/other.html 同源 只有路径不同 http://store.company.com/dir/inner/another.html 同源 只有路径不同 https://store.company.com/secure.html 失败 协议不同 http://store.company.com:81/dir/etc.html 失败 端口不同 ( http:// 默认端口是80) http://news.company.com/dir/other.html 失败 主机不同 主要的跨域处理JSONP JSONP的原理是：静态资源请求不受同源策略影响。实现如下： 123456const script = document.createElement(&apos;script&apos;)script.type = &apos;text/javascript&apos;script.src = &apos;https://www.domain.com/a?data=1&amp;callback=cb&apos;const cb = res =&gt; &#123; console.log(JSON.stringify(res))&#125; CORS CORS：跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。 在各种服务端代码实现如下： 12345678// 根据不同语言规则，具体语法有所不同，此处以NodeJs的express为例//设置跨域访问 app.all(&apos;*&apos;, function(req, res, next) &#123; res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;); res.header(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;); next(); &#125;); Nginx实现如下： 1234567891011121314151617181920server &#123; ... add_header Access-Control-Allow-Credentials true; add_header Access-Control-Allow-Origin $http_origin; location /file &#123; if ($request_method = &apos;OPTIONS&apos;) &#123; add_header Access-Control-Allow-Origin $http_origin; add_header Access-Control-Allow-Methods $http_access_control_request_method; add_header Access-Control-Allow-Credentials true; add_header Access-Control-Allow-Headers $http_access_control_request_headers; add_header Access-Control-Max-Age 1728000; return 204; &#125; &#125; ...&#125; 网络协议 img TCP传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793 定义。 基于流的方式 面向连接 丢包重传 保证数据顺序 UDPInternet 协议集支持一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。RFC 768 描述了 UDP。 UDP 是非连接的协议，也就是不会跟终端建立连接 UDP 包信息只有 8 个字节 UDP 是面向报文的。既不拆分，也不合并，而是保留这些报文的边界 UDP 可能丢包 UDP 不保证数据顺序 HTTP HTTP/0.9：GET，无状态的特点形成 HTTP/1.0：支持 POST，HEAD，添加了请求头和响应头，支持任何格式的文件发送，添加了状态码、多字符集支持、多部分发送、权限、缓存、内容编码等 HTTP/1.1：默认长连接，同时 6 个 TCP 连接，CDN 域名分片 HTTPS：HTTP + TLS（ 非对称加密 与 对称加密 ） 客户端发出 https 请求，请求服务端建立 SSL 连接 服务端收到 https 请求，申请或自制数字证书，得到公钥和服务端私钥，并将公钥发送给客户端 户端验证公钥，不通过验证则发出警告，通过验证则产生一个随机的客户端私钥 客户端将公钥与客户端私钥进行对称加密后传给服务端 服务端收到加密内容后，通过服务端私钥进行非对称解密，得到客户端私钥 服务端将客户端私钥和内容进行对称加密，并将加密内容发送给客户端 客户端收到加密内容后，通过客户端私钥进行对称解密，得到内容 HTTP/2.0：多路复用（一次 TCP 连接可以处理多个请求），服务器主动推送，stream 传输。 HTTP/3：基于 UDP 实现了 QUIC 协议 建立好 HTTP2 连接 发送 HTTP2 扩展帧 使用 QUIC 建立连接 如果成功就断开 HTTP2 连接 升级为 HTTP3 连接 注：RTT = Round-trip time 页面渲染流程 构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成 创建 DOM tree 遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中。 不可见的节点会被布局树忽略掉。 样式计算 创建 CSSOM tree 转换样式表中的属性值 计算出 DOM 节点样式 生成 layout tree 分层 生成图层树（LayerTree） 拥有层叠上下文属性的元素会被提升为单独的一层 需要剪裁（clip）的地方也会被创建为图层 图层绘制 将图层转换为位图 合成位图并显示在页面中 页面更新机制 更新了元素的几何属性（重排） 更新元素的绘制属性（重绘） 直接合成 CSS3 的属性可以直接跳到这一步 JS 执行机制代码提升（为了编译） 变量提升 函数提升（优先级最高） 编译代码V8 编译 JS 代码的过程 生成抽象语法树（AST）和执行上下文 第一阶段是分词（tokenize），又称为词法分析 第二阶段是解析（parse），又称为语法分析 生成字节码 字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。 执行代码 高级语言编译器步骤： 输入源程序字符流 词法分析 语法分析 语义分析 中间代码生成 机器无关代码优化 代码生成 机器相关代码优化 目标代码生成 执行代码 执行全局代码时，创建全局上下文 调用函数时，创建函数上下文 使用 eval 函数时，创建 eval 上下文 执行局部代码时，创建局部上下文 类型基本类型 Undefined Null Boolean String Symbol Number Object BigInt 复杂类型 Object 隐式转换规则基本情况 转换为布尔值 转换为数字 转换为字符串 转换为原始类型对象在转换类型的时候，会执行原生方法 ToPrimitive 。 其算法如下： 如果已经是 原始类型，则返回当前值； 如果需要转 字符串 则先调用toSting方法，如果此时是 原始类型 则直接返回，否则再调用valueOf方法并返回结果； 如果不是 字符串，则先调用valueOf方法，如果此时是 原始类型 则直接返回，否则再调用toString方法并返回结果； 如果都没有 原始类型 返回，则抛出 TypeError 类型错误。 当然，我们可以通过重写Symbol.toPrimitive来制定转换规则，此方法在转原始类型时调用优先级最高。 123456789101112const data = &#123; valueOf() &#123; return 1; &#125;, toString() &#123; return &quot;1&quot;; &#125;, [Symbol.toPrimitive]() &#123; return 2; &#125;&#125;;data + 1; // 3 转换为布尔值对象转换为布尔值的规则如下表： 参数类型 结果 Undefined 返回 false。 Null 返回 false。 Boolean 返回 当前参数。 Number 如果参数为+0、-0或NaN，则返回 false；其他情况则返回 true。 String 如果参数为空字符串，则返回 false；否则返回 true。 Symbol 返回 true。 Object 返回 true。 转换为数字对象转换为数字的规则如下表： 参数类型 结果 Undefined 返回 NaN。 Null Return +0. Boolean 如果参数为 true，则返回 1；false则返回 +0。 Number 返回当前参数。 String 先调用 ToPrimitive ，再调用 ToNumber ，然后返回结果。 Symbol 抛出 TypeError错误。 Object 先调用 ToPrimitive ，再调用 ToNumber ，然后返回结果。 转换为字符串对象转换为字符串的规则如下表： 参数类型 结果 Undefined 返回 &quot;undefined&quot;。 Null 返回 &quot;null&quot;。 Boolean 如果参数为 true ,则返回 &quot;true&quot;；否则返回 &quot;false&quot;。 Number 调用 NumberToString ，然后返回结果。 String 返回 当前参数。 Symbol 抛出 TypeError错误。 Object 先调用 ToPrimitive ，再调用 ToString ，然后返回结果。 thisthis 是和执行上下文绑定的。 执行上下文： 全局执行上下文：全局执行上下文中的 this 也是指向 window 对象。 函数执行上下文：使用对象来调用其内部的一个方法，该方法的 this 是指向对象本身的。 eval 执行上下文：执行 eval 环境内部的上两个情况。 根据优先级最高的来决定 this 最终指向哪里。 首先，new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo() 这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。 三点注意： 当函数作为对象的方法调用时，函数中的 this 就是该对象； 当函数被正常调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象 window； 嵌套函数中的 this 不会继承外层函数的 this 值。 我们还提了一下箭头函数，因为箭头函数没有自己的执行上下文，所以箭头函数的 this 就是它外层函数的 this。 闭包没有被引用的闭包会被自动回收，但还存在全局变量中，则依然会内存泄漏。 在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。 12345678910111213var getNum;function getCounter() &#123; var n = 1; var inner = function() &#123; n++;return n; &#125;; return inner;&#125;getNum = getCounter();getNum(); // 2getNum(); // 3getNum(); // 4getNum(); // 5 作用域全局作用域对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。 函数作用域函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。 局部作用域使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句，甚至单独的一个{}都可以被看作是一个块级作用域。 作用域链词法作用域词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。 词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系。 原型&amp;原型链其实每个 JS 对象都有 __proto__ 属性，这个属性指向了原型。 原型也是一个对象，并且这个对象中包含了很多函数，对于 obj 来说，可以通过 __proto__ 找到一个原型对象，在该对象中定义了很多函数让我们来使用。 原型链： Object 是所有对象的爸爸，所有对象都可以通过 __proto__ 找到它 Function 是所有函数的爸爸，所有函数都可以通过 __proto__ 找到它 函数的 prototype 是一个对象 对象的 __proto__ 属性指向原型， __proto__ 将对象和原型连接起来组成了原型链 V8 工作原理数据存储 栈空间：先进后出的数据结构，调用栈，存储执行上下文，以及存储原始类型的数据。 堆空间：用数组实现的二叉树，存储引用类型。堆空间很大，能存放很多大的数据。存放在堆内存中的对象，变量实际保存的是一个指针，这个指针指向另一个位置。 原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。 垃圾回收 回收调用栈内的数据：执行上下文结束且没有被引用时，则会通过向下移动 记录当前执行状态的指针（称为 ESP） 来销毁该函数保存在栈中的执行上下文。 回收堆里的数据： V8 中会把堆分为新生代和老生代两个区域， 新生代中存放的是生存时间短的对象， 老生代中存放的生存时间久的对象。 垃圾回收重要术语： 大部分对象在内存中存在的时间很短 不死的对象，会活得更久 代际假说 分代收集 副垃圾回收器： 主要负责新生代的垃圾回收。 这个区域不大，但是垃圾回收比较频繁。 新生代的垃圾回收算法是 Scavenge 算法。 主要把新生代空间对半划分为两个区域：对象区域，空闲区域。 当对象区域快被写满时，则会进行一次垃圾清理。 流程如下： 对对象区域中的垃圾做标记 把存活的对象复制到空闲区域中 把这些对象有序地排列起来 清理完之后，对象区域会与空闲区域互换 主垃圾回收器： 主垃圾回收器主要负责老生区中的垃圾回收。 除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。 因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。 流程如下： 从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，区分活动对象以及垃圾数据 标记过程和清除过程使用标记 - 清除算法 碎片过多会导致大对象无法分配到足够的连续内存时，会使用标记 - 整理算法 一旦执行垃圾回收算法，会导致 全停顿（Stop-The-World） 。 但是 V8 有 增量标记算法 。 V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成。 浏览器安全攻击方式 xss：将代码注入到网页 持久型 ：写入数据库 非持久型 ：修改用户代码 csrf：跨站请求伪造。攻击者会虚构一个后端请求地址，诱导用户通过某些途径发送请求。 中间人攻击：中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息。 DNS 欺骗：入侵 DNS 来将用户访问目标改为入侵者指定机器 会话劫持：在一次正常的通信过程中，攻击者作为第三方参与到其中，或者是在数据里加入其他信息，甚至将双方的通信模式暗中改变，即从直接联系变成有攻击者参与的联系。 防御措施 预防 XSS 使用转义字符过滤 html 代码 1234567891011const escapeHTML = value =&gt; &#123; if (!value || !value.length) &#123; return value; &#125; return value .replace(/&amp;/g, &quot;&amp;amp;&quot;) .replace(/&lt;/g, &quot;&amp;lt;&quot;) .replace(/&gt;/g, &quot;&amp;gt;&quot;) .replace(/&quot;/g, &quot;&amp;quot;&quot;) .replace(/&apos;/g, &quot;&amp;#39;&quot;);&#125;; 过滤 SQL 代码 123456const replaceSql = value =&gt; &#123; if (!value || !value.length) &#123; return value; &#125; return value.replace(/select|update|delete|exec|count|&apos;|&quot;|=|;|&gt;|&lt;|%/gi, &quot;&quot;);&#125;; 预防 CSRF 验证 HTTP Referer 字段 在请求地址中添加 token 并验证 在 HTTP 头中自定义属性并验证 Get 请求不对数据进行修改 接口防跨域处理 不让第三方网站访问用户 cookie 预防中间人攻击 对于 DNS 欺骗：检查本机的 HOSTS 文件 对于会话劫持：使用交换式网络代替共享式网络，还必须使用静态 ARP、捆绑 MAC+IP 等方法来限制欺骗，以及采用认证方式的连接等。 内容安全策略（CSP） 内容安全策略 (CSP) 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。 措施如下： HTTP Header 中的 Content-Security-Policy 浏览器性能DNS 预解析 `` Chrome 和 Firefox 3.5+ 能自动进行预解析 关闭 DNS 预解析：`` img 强缓存 Expires 缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。 Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。 Cache-Control 协商缓存 协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。 服务器响应头：Last-Modified，Etag 浏览器请求头：If-Modified-Since，If-None-Match Last-Modified 与 If-Modified-Since 配对。Last-Modified 把 Web 应用最后修改时间告诉客户端，客户端下次请求之时会把 If-Modified-Since 的值发生给服务器，服务器由此判断是否需要重新发送资源，如果不需要则返回 304，如果有则返回 200。这对组合的缺点是只能精确到秒，而且是根据本地打开时间来记录的，所以会不准确。 Etag 与 If-None-Match 配对。它们没有使用时间作为判断标准，而是使用了一组特征串。Etag把此特征串发生给客户端，客户端在下次请求之时会把此特征串作为If-None-Match的值发送给服务端，服务器由此判断是否需要重新发送资源，如果不需要则返回 304，如果有则返回 200。 img NodeJs单线程基础概念： 进程：进程（英语：process），是指计算机中已运行的程序。进程曾经是分时系统的基本运作单位。 线程：线程（英语：thread）是操作系统能够进行运算调度的最小单位。大部分情况下，它被包含在进程之中，是进程中的实际运作单位。 协程：协程（英语：coroutine），又称微线程，是计算机程序的一类组件，推广了协作式多任务的子程序，允许执行被挂起与被恢复。 Node 中最核心的是 v8 引擎，在 Node 启动后，会创建 v8 的实例，这个实例是多线程的，各个线程如下： 主线程：编译、执行代码。 编译/优化线程：在主线程执行的时候，可以优化代码。 分析器线程：记录分析代码运行时间，为 Crankshaft 优化代码执行提供依据。 垃圾回收的几个线程。 非阻塞 I/O阻塞 是指在 Node.js 程序中，其它 JavaScript 语句的执行，必须等待一个非 JavaScript 操作完成。这是因为当 阻塞 发生时，事件循环无法继续运行 JavaScript。 在 Node.js 中，JavaScript 由于执行 CPU 密集型操作，而不是等待一个非 JavaScript 操作（例如 I/O）而表现不佳，通常不被称为 阻塞。在 Node.js 标准库中使用 libuv 的同步方法是最常用的 阻塞 操作。原生模块中也有 阻塞 方法。 事件循环123456789101112131415161718 ┌───────────────────────────┐┌─&gt;│ timers ││ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐│ │ pending callbacks ││ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐│ │ idle, prepare ││ └─────────────┬─────────────┘ ┌───────────────┐│ ┌─────────────┴─────────────┐ │ incoming: ││ │ poll │&lt;─────┤ connections, ││ └─────────────┬─────────────┘ │ data, etc. ││ ┌─────────────┴─────────────┐ └───────────────┘│ │ check ││ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐└──┤ close callbacks │ └───────────────────────────┘ 注意：每个框被称为事件循环机制的一个阶段。 在 Windows 和 Unix/Linux 实现之间存在细微的差异，但这对演示来说并不重要。 阶段概述： 定时器 ：本阶段执行已经被 setTimeout() 和 setInterval() 的调度回调函数。 待定回调 ：执行延迟到下一个循环迭代的 I/O 回调。 idle, prepare ：仅系统内部使用。 轮询 ：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞。 检测 ：setImmediate() 回调函数在这里执行。 关闭的回调函数 ：一些关闭的回调函数，如：socket.on(&#39;close&#39;, ...)。 在每次运行的事件循环之间，Node.js 检查它是否在等待任何异步 I/O 或计时器，如果没有的话，则完全关闭。 process.nextTick() ：它是异步 API 的一部分。从技术上讲不是事件循环的一部分。不管事件循环的当前阶段如何，都将在当前操作完成后处理 nextTickQueue。这里的一个操作被视作为一个从底层 C/C++ 处理器开始过渡，并且处理需要执行的 JavaScript 代码。 LibuvLibuv 是一个跨平台的异步 IO 库，它结合了 UNIX 下的 libev 和 Windows 下的 IOCP 的特性，最早由 Node.js 的作者开发，专门为 Node.js 提供多平台下的异步 IO 支持。Libuv 本身是由 C++ 语言实现的，Node.js 中的非阻塞 IO 以及事件循环的底层机制都是由 libuv 实现的。 在 Windows 环境下，libuv 直接使用 Windows 的 IOCP 来实现异步 IO。在 非 Windows 环境下，libuv 使用多线程（线程池 Thread Pool）来模拟异步 IO，这里仅简要提一下 libuv 中有线程池的概念，之后的文章会介绍 libuv 如何实现进程间通信。 手写代码new 操作符12345678var New = function(Fn) &#123; var obj = &#123;&#125;; // 创建空对象 var arg = Array.prototype.slice.call(arguments, 1); obj.__proto__ = Fn.prototype; // 将obj的原型链__proto__指向构造函数的原型prototype obj.__proto__.constructor = Fn; // 在原型链 __proto__上设置构造函数的构造器constructor，为了实例化Fn Fn.apply(obj, arg); // 执行Fn，并将构造函数Fn执行obj return obj; // 返回结果&#125;; 深拷贝123456789101112131415161718192021222324252627282930313233343536373839404142434445const getType = data =&gt; &#123; // 获取数据类型 const baseType = Object.prototype.toString .call(data) .replace(/^\\[object\\s(.+)\\]$/g, &quot;$1&quot;) .toLowerCase(); const type = data instanceof Element ? &quot;element&quot; : baseType; return type;&#125;;const isPrimitive = data =&gt; &#123; // 判断是否是基本数据类型 const primitiveType = &quot;undefined,null,boolean,string,symbol,number,bigint,map,set,weakmap,weakset&quot;.split( &quot;,&quot; ); // 其实还有很多类型 return primitiveType.includes(getType(data));&#125;;const isObject = data =&gt; getType(data) === &quot;object&quot;;const isArray = data =&gt; getType(data) === &quot;array&quot;;const deepClone = data =&gt; &#123; let cache = &#123;&#125;; // 缓存值，防止循环引用 const baseClone = _data =&gt; &#123; let res; if (isPrimitive(_data)) &#123; return data; &#125; else if (isObject(_data)) &#123; res = &#123; ..._data &#125;; &#125; else if (isArray(_data)) &#123; res = [..._data]; &#125; // 判断是否有复杂类型的数据，有就递归 Reflect.ownKeys(res).forEach(key =&gt; &#123; if (res[key] &amp;&amp; getType(res[key]) === &quot;object&quot;) &#123; // 用cache来记录已经被复制过的引用地址。用来解决循环引用的问题 if (cache[res[key]]) &#123; res[key] = cache[res[key]]; &#125; else &#123; cache[res[key]] = res[key]; res[key] = baseClone(res[key]); &#125; &#125; &#125;); return res; &#125;; return baseClone(data);&#125;; 手写 bind1234567891011121314151617Function.prototype.bind2 = function(context) &#123; if (typeof this !== &quot;function&quot;) &#123; throw new Error(&quot;...&quot;); &#125; var that = this; var args1 = Array.prototype.slice.call(arguments, 1); var bindFn = function() &#123; var args2 = Array.prototype.slice.call(arguments); var that2 = this instanceof bindFn ? this : context; // 如果当前函数的this指向的是构造函数中的this 则判定为new 操作。如果this是构造函数bindFn new出来的实例，那么此处的this一定是该实例本身。 return that.apply(that2, args1.concat(args2)); &#125;; var Fn = function() &#123;&#125;; // 连接原型链用Fn // 原型赋值 Fn.prototype = this.prototype; // bindFn的prototype指向和this的prototype一样，指向同一个原型对象 bindFn.prototype = new Fn(); return bindFn;&#125;; 手写函数柯里化12345678910111213const curry = fn =&gt; &#123; if (typeof fn !== &quot;function&quot;) &#123; throw Error(&quot;No function provided&quot;); &#125; return function curriedFn(...args) &#123; if (args.length &lt; fn.length) &#123; return function() &#123; return curriedFn.apply(null, args.concat([].slice.call(arguments))); &#125;; &#125; return fn.apply(null, args); &#125;;&#125;; 手写 Promise123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138// 来源于 https://github.com/bailnl/promise/blob/master/src/promise.jsconst PENDING = 0;const FULFILLED = 1;const REJECTED = 2;const isFunction = fn =&gt; typeof fn === &quot;function&quot;;const isObject = obj =&gt; obj !== null &amp;&amp; typeof obj === &quot;object&quot;;const noop = () =&gt; &#123;&#125;;const nextTick = fn =&gt; setTimeout(fn, 0);const resolve = (promise, x) =&gt; &#123; if (promise === x) &#123; reject(promise, new TypeError(&quot;You cannot resolve a promise with itself&quot;)); &#125; else if (x &amp;&amp; x.constructor === Promise) &#123; if (x._stauts === PENDING) &#123; const handler = statusHandler =&gt; value =&gt; statusHandler(promise, value); x.then(handler(resolve), handler(reject)); &#125; else if (x._stauts === FULFILLED) &#123; fulfill(promise, x._value); &#125; else if (x._stauts === REJECTED) &#123; reject(promise, x._value); &#125; &#125; else if (isFunction(x) || isObject(x)) &#123; let isCalled = false; try &#123; const then = x.then; if (isFunction(then)) &#123; const handler = statusHandler =&gt; value =&gt; &#123; if (!isCalled) &#123; statusHandler(promise, value); &#125; isCalled = true; &#125;; then.call(x, handler(resolve), handler(reject)); &#125; else &#123; fulfill(promise, x); &#125; &#125; catch (e) &#123; if (!isCalled) &#123; reject(promise, e); &#125; &#125; &#125; else &#123; fulfill(promise, x); &#125;&#125;;const reject = (promise, reason) =&gt; &#123; if (promise._stauts !== PENDING) &#123; return; &#125; promise._stauts = REJECTED; promise._value = reason; invokeCallback(promise);&#125;;const fulfill = (promise, value) =&gt; &#123; if (promise._stauts !== PENDING) &#123; return; &#125; promise._stauts = FULFILLED; promise._value = value; invokeCallback(promise);&#125;;const invokeCallback = promise =&gt; &#123; if (promise._stauts === PENDING) &#123; return; &#125; nextTick(() =&gt; &#123; while (promise._callbacks.length) &#123; const &#123; onFulfilled = value =&gt; value, onRejected = reason =&gt; &#123; throw reason; &#125;, thenPromise &#125; = promise._callbacks.shift(); let value; try &#123; value = (promise._stauts === FULFILLED ? onFulfilled : onRejected)( promise._value ); &#125; catch (e) &#123; reject(thenPromise, e); continue; &#125; resolve(thenPromise, value); &#125; &#125;);&#125;;class Promise &#123; static resolve(value) &#123; return new Promise((resolve, reject) =&gt; resolve(value)); &#125; static reject(reason) &#123; return new Promise((resolve, reject) =&gt; reject(reason)); &#125; constructor(resolver) &#123; if (!(this instanceof Promise)) &#123; throw new TypeError( `Class constructor Promise cannot be invoked without &apos;new&apos;` ); &#125; if (!isFunction(resolver)) &#123; throw new TypeError(`Promise resolver $&#123;resolver&#125; is not a function`); &#125; this._stauts = PENDING; this._value = undefined; this._callbacks = []; try &#123; resolver(value =&gt; resolve(this, value), reason =&gt; reject(this, reason)); &#125; catch (e) &#123; reject(this, e); &#125; &#125; then(onFulfilled, onRejected) &#123; const thenPromise = new this.constructor(noop); this._callbacks = this._callbacks.concat([ &#123; onFulfilled: isFunction(onFulfilled) ? onFulfilled : void 0, onRejected: isFunction(onRejected) ? onRejected : void 0, thenPromise &#125; ]); invokeCallback(this); return thenPromise; &#125; catch(onRejected) &#123; return this.then(void 0, onRejected); &#125;&#125; 手写防抖函数123456789101112131415const debounce = (fn = &#123;&#125;, wait = 50, immediate) =&gt; &#123; let timer; return function() &#123; if (immediate) &#123; fn.apply(this, arguments); &#125; if (timer) &#123; clearTimeout(timer); timer = null; &#125; timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments); &#125;, wait); &#125;;&#125;; 手写节流函数1234567891011var throttle = (fn = &#123;&#125;, wait = 0) =&gt; &#123; let prev = new Date(); return function() &#123; const args = arguments; const now = new Date(); if (now - prev &gt; wait) &#123; fn.apply(this, args); prev = new Date(); &#125; &#125;;&#125;; 手写 instanceOf123456789101112const instanceOf = (left, right) =&gt; &#123; let proto = left.__proto__; let prototype = right.prototype; while (true) &#123; if (proto === null) &#123; return false; &#125; else if (proto === prototype) &#123; return true; &#125; proto = proto.__proto__; &#125;&#125;; 其它知识typeof vs instanceofinstanceof 运算符用来检测 constructor.prototype是否存在于参数 object 的原型链上。 typeof 操作符返回一个字符串，表示未经计算的操作数的类型。 在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null 的类型标签是 0，typeof null 也因此返回 &quot;object&quot;。 递归 递归（英语：Recursion），又译为递回，在数学与计算机科学中，是指在函数的定义中使用函数自身的方法。 例如： 大雄在房里，用时光电视看着未来的情况。电视画面中的那个时候，他正在房里，用时光电视，看着未来的情况。电视画面中的电视画面的那个时候，他正在房里，用时光电视，看着未来的情况…… 简单来说，就是 无限套娃 我们以斐波那契数列（Fibonacci sequence）为例，看看输入结果会为正无穷的值的情况下，各种递归的情况。 img 首先是普通版 123456789const fib1 = n =&gt; &#123; if (typeof n !== &quot;number&quot;) &#123; throw new Error(&quot;..&quot;); &#125; if (n &lt; 2) &#123; return n; &#125; return fib1(n - 1) + fib1(n - 2);&#125;; 从上面的代码分析，我们不难发现，在fib1里，JS 会不停创建执行上下文，压入栈内，而且在得出结果前不会销毁，所以数大了之后容易爆栈。 img 所以我们可以对其进行优化，就是利用 尾调用 进行优化。 尾调用是指函数的最后一步只返回一个纯函数的调用，而没有别的数据占用引用。代码如下： 123456789const fib2 = (n, a = 0, b = 1) =&gt; &#123; if (typeof n !== &quot;number&quot;) &#123; throw new Error(&quot;..&quot;); &#125; if (n === 0) &#123; return a; &#125; return fib2(n - 1, b, a + b);&#125;; 不过很遗憾，在 Chrome 83.0.4103.61 里还是会爆。 img 然后我们还有备忘录递归法，就是另外申请空间去存储每次递归的值，是个自顶向下的算法。 img 可惜，还是挂了。 不过在一些递归问题上，我们还可以利用动态规划（Dynamic programming，简称 DP）来解决。 动态规划是算法里比较难掌握的一个概念之一，但是基本能用递归来解决的问题，都能用动态规划来解决。 动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。 跟备忘录递归刚好相反，是自底向上的算法。具体代码如下： 1234567891011121314const fib3 = n =&gt; &#123; if (typeof n !== &quot;number&quot;) &#123; throw new Error(&quot;..&quot;); &#125; if (n &lt; 2) &#123; return n; &#125; let a = 0; let b = 1; while (n--) &#123; [a, b] = [b, a + b]; &#125; return a;&#125;; img 效果很好，正确输出了正无穷~ 参考资料 浏览器工作原理与实践 浏览器的运行机制—2.浏览器都包含哪些进程？ 「中高级前端面试」JavaScript 手写代码无敌秘籍 JavaScript 深拷贝 bailnl/promise 网络是怎样连接的？ 浏览器工作原理与实践 浏览器的工作原理：新式网络浏览器幕后揭秘 内容安全策略( CSP ) 前端面试之道 HTTP 各版本的区别 CORS解决跨域问题（Nginx跨域配置） 你觉得 Node.js 是单线程这个结论对吗？ Node 指南 深入理解浏览器的缓存机制 转自https://mp.weixin.qq.com/s/SrKdXN4FF4IThFbDxivN4A 说说你对闭包的理解使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。 闭包有三个特性: 1.函数嵌套函数2.函数内部可以引用外部的参数和变量3.参数和变量不会被垃圾回收机制回收 CSS 相关问题display:none和visibility:hidden的区别？display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。 visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。 CSS中 link 和@import 的区别是？(1) link属于HTML标签，而@import是CSS提供的;(2) 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;(3) import只在IE5以上才能识别，而link是HTML标签，无兼容问题;(4) link方式的样式的权重 高于@import的权重. position:absolute和float属性的异同A：共同点：对内联元素设置float和absolute属性，可以让元素脱离文档流，并且可以设置其宽高。 B：不同点：float仍会占据位置，position会覆盖文档流中的其他元素。 CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？1234567891.id选择器（ # myid）2.类选择器（.myclassname）3.标签选择器（div, h1, p）4.相邻选择器（h1 + p）5.子选择器（ul &gt; li）6.后代选择器（li a）7.通配符选择器（ * ）8.属性选择器（a[rel = &quot;external&quot;]）9.伪类选择器（a: hover, li:nth-child） 可继承的样式： font-size font-family color, text-indent; 不可继承的样式：border padding margin width height ; 优先级就近原则，同权重情况下样式定义最近者为准; 载入样式以最后载入的定位为准; 优先级为: 123!important &gt; id &gt; class &gt; tag important 比 内联优先级高,但内联比 id 要高 CSS3新增伪类举例： 1234567p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。:enabled :disabled 控制表单控件的禁用状态。:checked 单选框或复选框被选中。 position的值， relative和absolute分别是相对于谁进行定位的？12345678910absolute 生成绝对定位的元素， 相对于最近一级的 定位不是 static 的父元素来进行定位。fixed （老IE不支持） 生成绝对定位的元素，相对于浏览器窗口进行定位。 relative 生成相对定位的元素，相对于其在普通流中的位置进行定位。 static 默认值。没有定位，元素出现在正常的流中 XML和JSON的区别？(1).数据体积方面。JSON相对于XML来讲，数据的体积小，传递的速度更快些。(2).数据交互方面。JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。(3).数据描述方面。JSON对数据的描述性比XML较差。(4).传输速度方面。JSON的速度要远远快于XML。 对BFC规范的理解？​ BFC，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个BFC中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的margin会发生折叠。​ （W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行布局，以及与其他元素的关系和相互作用。） 解释下 CSS sprites，以及你要如何在页面或网站中使用它。CSS Sprites其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position可以用数字能精确的定位出背景图片的位置。这样可以减少很多图片请求的开销，因为请求耗时比较长；请求虽然可以并发，但是也有限制，一般浏览器都是6个。对于未来而言，就不需要这样做了，因为有了http2。 html部分Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?（1）&lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 标签之前。告知浏览器以何种模式来渲染文档。 （2）严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。 （3）在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 （4）DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。 你知道多少种Doctype文档类型？ 该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。 HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。 XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks （包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。 HTML与XHTML——二者有什么区别区别：1.所有的标记都必须要有一个相应的结束标记2.所有标签的元素和属性的名字都必须使用小写3.所有的XML标记都必须合理嵌套4.所有的属性必须用引号””括起来5.把所有&lt;和&amp;特殊符号用编码表示6.给所有属性赋一个值7.不要在注释内容中使“–”8.图片必须有说明文字 常见兼容性问题？ png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理. 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。 IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。 浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。）#box{ float:left; width:10px; margin:0 0 0 100px;} 这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别) 渐进识别的方式，从总体中逐渐排除局部。 首先，巧妙的使用“\\9”这一标记，将IE游览器从所有情况中分离出来。接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。 1234567css .bb&#123; background-color:#f1ee18;/*所有识别*/ .background-color:#00deff\\9; /*IE6、7、8识别*/ +background-color:#a200ff;/*IE6、7识别*/ _background-color:#1e0bd1;/*IE6识别*/ &#125; IE下,可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性;Firefox下,只能使用getAttribute()获取自定义属性.解决方法:统一通过getAttribute()获取自定义属性. IE下,event对象有x,y属性,但是没有pageX,pageY属性;Firefox下,event对象有pageX,pageY属性,但是没有x,y属性. 解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。 Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决. 超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:L-V-H-A : a:link {} a:visited {} a:hover {} a:active {} 怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。现在可以使用html5推荐的写法：&lt;doctype html&gt; 上下margin重合问题ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。解决方法，养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。 ie6对png图片格式支持不好(引用一段脚本处理) 解释下浮动和它的工作原理？清除浮动的技巧浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。 1.使用空标签清除浮动。 这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。2.使用overflow。 给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。3.使用after伪对象清除浮动。 该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素； 浮动元素引起的问题和解决办法？浮动元素引起的问题： （1）父元素的高度无法被撑开，影响与父元素同级的元素（2）与浮动元素同级的非浮动元素（内联元素）会跟随其后（3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构 解决方法：使用CSS中的clear:both;属性来清除元素的浮动可解决2、3问题，对于问题1，添加如下样式，给父元素添加clearfix样式： 12.clearfix:after&#123;content: &quot;.&quot;;display: block;height: 0;clear: both;visibility: hidden;&#125;.clearfix&#123;display: inline-block;&#125; /* for IE/Mac */ 清除浮动的几种方法： 123456789101112131，额外标签法，&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;（缺点：不过这个办法会增加额外的标签使HTML结构看起来不够简洁。）2，使用after伪类#parent:after&#123; content:&quot;.&quot;; height:0; visibility:hidden; display:block; clear:both; &#125;3,浮动外部元素4,设置`overflow`为`hidden`或者auto IE 8以下版本的浏览器中的盒模型有什么不同IE8以下浏览器的盒模型中定义的元素的宽高不包括内边距和边框 DOM操作——怎样添加、移除、移动、复制、创建和查找节点。（1）创建新节点 ​ createDocumentFragment() //创建一个DOM片段 ​ createElement() //创建一个具体的元素 ​ createTextNode() //创建一个文本节点 （2）添加、移除、替换、插入 ​ appendChild() ​ removeChild() ​ replaceChild() ​ insertBefore() //在已有的子节点前插入一个新的子节点 （3）查找 ​ getElementsByTagName() //通过标签名称 ​ getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的) ​ getElementById() //通过元素Id，唯一性 iframe的优缺点？1.&lt;iframe&gt;优点： ​ 解决加载缓慢的第三方内容如图标和广告等的加载问题​ Security sandbox​ 并行加载脚本 2.&lt;iframe&gt;的缺点： ​ *iframe会阻塞主页面的Onload事件； ​ *即时内容为空，加载也需要时间​ *没有语意 如何实现浏览器内多个标签页之间的通信?调用localstorge、cookies等本地存储方式 线程与进程的区别一个程序至少有一个进程,一个进程至少有一个线程.线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。 你如何对网站的文件和资源进行优化？期待的解决方案包括： 文件合并 文件最小化/文件压缩 使用 CDN 托管 缓存的使用（多个域名来提供缓存） 其他 请说出三种减少页面加载时间的方法。 1.优化图片 2.图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方） 3.优化CSS（压缩合并css，如margin-top,margin-left…) 4.网址后加斜杠（如www.campr.com/目录，会判断这个“目录是什么文件类型，或者是目录。） 5.标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了。） 6.减少http请求（合并文件，合并图片）。 你都使用哪些工具来测试代码的性能？1Profiler, JSPerf（http://jsperf.com/nexttick-vs-setzerotimeout-vs-settimeout）, Dromaeo 什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？1234 FOUC - Flash Of Unstyled Content 文档样式闪烁 &lt;style type=&quot;text/css&quot; media=&quot;all&quot;&gt;@import &quot;../fouc.css&quot;;&lt;/style&gt; 而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。 解决方法简单的出奇，只要在&lt;head&gt;之间加入一个&lt;link&gt;或者&lt;script&gt;元素就可以了。 null和undefined的区别？null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。 当声明的变量还未被初始化时，变量的默认值为undefined。null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。 undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：（1）变量被声明了，但没有赋值时，就等于undefined。 （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。 （3）对象没有赋值的属性，该属性的值为undefined。 （4）函数没有返回值时，默认返回undefined。 null表示”没有对象”，即该处不应该有值。典型用法是：（1） 作为函数的参数，表示该函数的参数不是对象。 （2） 作为对象原型链的终点。 js延迟加载的方式有哪些？defer和async、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）、按需异步载入js 如何解决跨域问题?jsonp、 document.domain+iframe、window.name、window.postMessage、服务器上设置代理页面jsonp的原理是动态插入script标签 具体参见：详解js跨域问题 documen.write和 innerHTML的区别document.write只能重绘整个页面 innerHTML可以重绘页面的一部分 哪些操作会造成内存泄漏？内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） 详见：详解js变量、作用域及内存 JavaScript中的作用域与变量声明提升？详见：详解JavaScript函数模式 如何判断当前脚本运行在浏览器还是node环境中？通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中 什么叫优雅降级和渐进增强？优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效. 渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 详见：css学习归纳总结（一） WEB应用从服务器主动推送Data到客户端有那些方式？Javascript数据推送 Commet：基于HTTP长连接的服务器推送技术 基于WebSocket的推送方案 SSE（Server-Send Event）：服务器推送数据新方式 对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。 1、实现界面交互 2、提升用户体验 3、有了Node.js，前端可以实现服务端的一些事情 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好， 参与项目，快速高质量完成实现效果图，精确到1px； 与团队成员，UI设计，产品经理的沟通； 做好的页面结构，页面重构和用户体验； 处理hack，兼容、写出优美的代码格式； 针对服务器的优化、拥抱最新前端技术。 你有哪些性能优化的方法？（详情请看雅虎14条性能优化原则）。 （1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。 （2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数 （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。 （4） 当需要设置的样式很多时设置className而不是直接操作style。 （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。 （6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。 （7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。 详情：http://segmentfault.com/blog/trigkit4/1190000000691919 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？​ 分为4个步骤：​ （1），当发送一个URL请求时，不管这个URL是Web页面的URL还是Web页面上每个资源的URL，浏览器都会开启一个线程来处理这个请求，同时在远程DNS服务器上启动一个DNS查询。这能使浏览器获得请求对应的IP地址。​ （2）， 浏览器与远程Web服务器通过TCP三次握手协商来建立一个TCP/IP连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。​ （3），一旦TCP/IP连接建立，浏览器会通过该连接向远程服务器发送HTTP的GET请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200的HTTP响应状态表示一个正确的响应。​ （4），此时，Web服务器提供资源服务，客户端开始下载资源。 请求返回后，便进入了我们关注的前端模块简单来说，浏览器会解析HTML生成DOM Tree，其次会根据CSS生成CSS Rule Tree，而javascript又可以根据DOM API操作DOM 详情：从输入 URL 到浏览器接收的过程中发生了什么事情？ 平时如何管理你的项目？先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等； 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）； 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）； 页面进行标注（例如 页面 模块 开始和结束）； CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）； JS 分文件夹存放 命名以该JS功能为准的英文翻译。 图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理 说说最近最流行的一些东西吧？常去哪些网站？Node.js、Mongodb、npm、MVVM、MEAN、three.js,React 。网站：w3cfuns,sf,hacknews,CSDN,慕课，博客园，InfoQ,w3cplus等 javascript对象的几种创建方式1，工厂模式2，构造函数模式3，原型模式4，混合构造函数和原型模式5，动态原型模式6，寄生构造函数模式7，稳妥构造函数模式 javascript继承的6种方法1，原型链继承2，借用构造函数继承3，组合继承(原型+借用构造)4，原型式继承5，寄生式继承6，寄生组合式继承 详情：JavaScript继承方式详解 ajax过程(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象. (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息. (3)设置响应HTTP请求状态变化的函数. (4)发送HTTP请求. (5)获取异步调用返回的数据. (6)使用JavaScript和DOM实现局部刷新. 详情：JavaScript学习总结（七）Ajax和Http状态字 异步加载和延迟加载1.异步加载的方案： 动态插入script标签2.通过ajax去获取js代码，然后通过eval执行3.script标签上添加defer或者async属性4.创建并插入iframe，让它异步执行js5.延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的。 前端安全问题？sql注入原理就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 总的来说有以下几点： 1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双”-“进行转换等。2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取。3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。 XSS原理及防范Xss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意html标签或者javascript代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。 XSS防范方法1.代码里对用户输入的地方和变量都需要仔细检查长度和对”&lt;”,”&gt;”,”;”,”’”等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。 2.避免直接在cookie 中泄露用户隐私，例如email、密码等等。3.通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的cookie 没有实际价值，不可能拿来重放。 4.尽量采用POST 而非GET 提交表单 XSS与CSRF有什么区别吗？XSS是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。 要完成一次CSRF攻击，受害者必须依次完成两个步骤： 1.登录受信任网站A，并在本地生成Cookie。 2.在不登出A的情况下，访问危险网站B。 CSRF的防御1.服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。2.使用验证码 ie各版本和chrome可以并行下载多少个资源IE6 两个并发，iE7升级之后的6个并发，之后版本也是6个 Firefox，chrome也是6个 javascript里面的继承怎么实现，如何避免原型链上面的对象共享用构造函数和原型链的混合模式去实现继承，避免对象共享可以参考经典的extend()函数，很多前端框架都有封装的，就是用一个空函数当做中间变量 grunt， YUI compressor 和 google clojure用来进行代码压缩的用法。12345678YUI Compressor 是一个用来压缩 JS 和 CSS 文件的工具，采用Java开发。使用方法：//压缩JSjava -jar yuicompressor-2.4.2.jar --type js --charset utf-8 -v src.js &gt; packed.js//压缩CSSjava -jar yuicompressor-2.4.2.jar --type css --charset utf-8 -v src.css &gt; packed.css 详情请见：你需要掌握的前端代码性能优化工具 Flash、Ajax各自的优缺点，在使用中如何取舍？1、Flash ajax对比Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜索。Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM 请解释一下 JavaScript 的同源策略。概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。 这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。指一段脚本只能读取来自同一来源的窗口和文档的属性。 为什么要有同源限制？我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。 什么是 “use strict”; ? 使用它的好处和坏处分别是什么？ECMAscript 5添加了第二种运行模式：”严格模式”（strict mode）。顾名思义，这种模式使得Javascript在更严格的条件下运行。 设立”严格模式”的目的，主要有以下几个： 1234- 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;- 消除代码运行的一些不安全之处，保证代码运行的安全；- 提高编译器效率，增加运行速度；- 为未来新版本的Javascript做好铺垫。 注：经过测试IE6,7,8,9均不支持严格模式。 缺点：现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。 GET和POST的区别，何时使用POST？​ GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符​ POST：一般用于修改服务器上的资源，对所发送的信息没有限制。 ​ GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，​ 也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。 然而，在以下情况中，请使用 POST 请求：无法使用缓存文件（更新服务器上的文件或数据库）向服务器发送大量数据（POST 没有数据量限制）发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 哪些地方会出现css阻塞，哪些地方会出现js阻塞？js的阻塞特性： 所有浏览器在下载JS的时候，会阻止一切其他活动，比如其他资源的下载，内容的呈现等等。直到JS下载、解析、执行完毕后才开始继续并行下载其他资源并呈现内容。为了提高用户体验，新一代浏览器都支持并行下载JS，但是JS下载仍然会阻塞其它资源的下载（例如.图片，css文件等）。 由于浏览器为了防止出现JS修改DOM树，需要重新构建DOM树的情况，所以就会阻塞其他的下载和呈现。 嵌入JS会阻塞所有内容的呈现，而外部JS只会阻塞其后内容的显示，2种方式都会阻塞其后资源的下载。也就是说外部样式不会阻塞外部脚本的加载，但会阻塞外部脚本的执行。 CSS怎么会阻塞加载了？ CSS本来是可以并行下载的，在什么情况下会出现阻塞加载了(在测试观察中，IE6下CSS都是阻塞加载） 当CSS后面跟着嵌入的JS的时候，该CSS就会出现阻塞后面资源下载的情况。而当把嵌入JS放到CSS前面，就不会出现阻塞的情况了。 根本原因： 因为浏览器会维持html中css和js的顺序，样式表必须在嵌入的JS执行前先加载、解析完。而嵌入的JS会阻塞后面的资源加载，所以就会出现上面CSS阻塞下载的情况。 嵌入JS应该放在什么位置？ 1、放在底部，虽然放在底部照样会阻塞所有呈现，但不会阻塞资源下载。 2、如果嵌入JS放在head中，请把嵌入JS放在CSS头部。 3、使用defer（只支持IE） 4、不要在嵌入的JS中调用运行时间较长的函数，如果一定要用，可以用setTimeout来调用 Javascript无阻塞加载具体方式 将脚本放在底部。&lt;link&gt;还是放在head中，用以保证在js加载前，能加载出正常显示的页面。&lt;script&gt;标签放在&lt;/body&gt;前。 成组脚本：由于每个&lt;script&gt;标签下载时阻塞页面解析过程，所以限制页面的&lt;script&gt;总数也可以改善性能。适用于内联脚本和外部脚本。 非阻塞脚本：等页面完成加载后，再加载js代码。也就是，在window.onload事件发出后开始下载代码。（1）defer属性：支持IE4和fierfox3.5更高版本浏览器（2）动态脚本元素：文档对象模型（DOM）允许你使用js动态创建HTML的几乎全部文档内容。代码如下： 123456&lt;script&gt; var script=document.createElement(&quot;script&quot;); script.type=&quot;text/javascript&quot;; script.src=&quot;file.js&quot;; document.getElementsByTagName(&quot;head&quot;)[0].appendChild(script);&lt;/script&gt; 此技术的重点在于：无论在何处启动下载，文件额下载和运行都不会阻塞其他页面处理过程。即使在head里（除了用于下载文件的http链接）。 闭包相关问题？详情请见：详解js闭包 js事件处理程序问题？详情请见：JavaScript学习总结（九）事件详解 eval是做什么的？它的功能是把对应的字符串解析成JS代码并运行；应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。 JavaScript原型，原型链 ? 有什么特点？ 原型对象也是普通的对象，是对象一个自带隐式的 proto 属性，原型也有可能有自己的原型，如果一个原型对象的原型不为null的话，我们就称之为原型链。 原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链。 事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？ 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。 事件处理机制：IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件。； ev.stopPropagation();注意旧ie的方法 ev.cancelBubble = true; ajax 是什么?ajax 的交互模型?同步和异步的区别?如何解决跨域问题?详情请见：JavaScript学习总结（七）Ajax和Http状态字 通过异步模式，提升了用户体验 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用 Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。 Ajax的最大的特点是什么。 Ajax可以实现动态不刷新（局部刷新）readyState属性 状态 有5个可取值： 0=未初始化 ，1=启动 2=发送，3=接收，4=完成 ajax的缺点 1、ajax不支持浏览器back按钮。 2、安全问题 AJAX暴露了与服务器交互的细节。 3、对搜索引擎的支持比较弱。 4、破坏了程序的异常机制。 5、不容易调试。 跨域： jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面 js对象的深度克隆12345678910111213141516171819function clone(Obj) &#123; var buf; if (Obj instanceof Array) &#123; buf = []; //创建一个空的数组 var i = Obj.length; while (i--) &#123; buf[i] = clone(Obj[i]); &#125; return buf; &#125;else if (Obj instanceof Object)&#123; buf = &#123;&#125;; //创建一个空对象 for (var k in Obj) &#123; //为这个对象添加新的属性 buf[k] = clone(Obj[k]); &#125; return buf; &#125;else&#123; return Obj; &#125; &#125; AMD和CMD 规范的区别？详情请见：详解JavaScript模块化开发 网站重构的理解？网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。 对于传统的网站来说重构通常是： 表格(table)布局改为DIV+CSS使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)对于移动平台的优化针对于SEO进行优化深层次的网站重构应该考虑的方面 减少代码间的耦合让代码保持弹性严格按规范编写代码设计可扩展的API代替旧有的框架、语言(如VB)增强用户体验通常来说对于速度的优化也包含在重构中 压缩JS、CSS、image等前端资源(通常是由服务器来解决)程序的性能优化(如数据读写)采用CDN来加速资源加载对于JS DOM的优化HTTP服务器的文件缓存 如何获取UA？12345678&lt;script&gt; function whatBrowser() &#123; document.Browser.Name.value=navigator.appName; document.Browser.Version.value=navigator.appVersion; document.Browser.Code.value=navigator.appCodeName; document.Browser.Agent.value=navigator.userAgent; &#125; &lt;/script&gt; js数组去重以下是数组去重的三种方法： 123456789101112131415161718192021222324252627282930313233343536Array.prototype.unique1 = function () &#123; var n = []; //一个新的临时数组 for (var i = 0; i &lt; this.length; i++) //遍历当前数组 &#123; //如果当前数组的第i已经保存进了临时数组，那么跳过， //否则把当前项push到临时数组里面 if (n.indexOf(this[i]) == -1) n.push(this[i]); &#125; return n;&#125;Array.prototype.unique2 = function()&#123; var n = &#123;&#125;,r=[]; //n为hash表，r为临时数组 for(var i = 0; i &lt; this.length; i++) //遍历当前数组 &#123; if (!n[this[i]]) //如果hash表中没有当前项 &#123; n[this[i]] = true; //存入hash表 r.push(this[i]); //把当前数组的当前项push到临时数组里面 &#125; &#125; return r;&#125;Array.prototype.unique3 = function()&#123; var n = [this[0]]; //结果数组 for(var i = 1; i &lt; this.length; i++) //从第二项开始遍历 &#123; //如果当前数组的第i项在当前数组中第一次出现的位置不是i， //那么表示第i项是重复的，忽略掉。否则存入结果数组 if (this.indexOf(this[i]) == i) n.push(this[i]); &#125; return n;&#125; HTTP状态码12345678910111213141516100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息200 OK 正常返回信息201 Created 请求成功并且服务器创建了新的资源202 Accepted 服务器已接受请求，但尚未处理301 Moved Permanently 请求的网页已永久移动到新位置。302 Found 临时性重定向。303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。304 Not Modified 自从上次请求后，请求的网页未修改过。400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。401 Unauthorized 请求未授权。403 Forbidden 禁止访问。404 Not Found 找不到如何与 URI 相匹配的资源。500 Internal Server Error 最常见的服务器端错误。503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 js操作获取和设置cookie12345678910111213141516171819202122232425262728293031323334353637//创建cookiefunction setCookie(name, value, expires, path, domain, secure) &#123; var cookieText = encodeURIComponent(name) + &apos;=&apos; + encodeURIComponent(value); if (expires instanceof Date) &#123; cookieText += &apos;; expires=&apos; + expires; &#125; if (path) &#123; cookieText += &apos;; expires=&apos; + expires; &#125; if (domain) &#123; cookieText += &apos;; domain=&apos; + domain; &#125; if (secure) &#123; cookieText += &apos;; secure&apos;; &#125; document.cookie = cookieText;&#125;//获取cookiefunction getCookie(name) &#123; var cookieName = encodeURIComponent(name) + &apos;=&apos;; var cookieStart = document.cookie.indexOf(cookieName); var cookieValue = null; if (cookieStart &gt; -1) &#123; var cookieEnd = document.cookie.indexOf(&apos;;&apos;, cookieStart); if (cookieEnd == -1) &#123; cookieEnd = document.cookie.length; &#125; cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd)); &#125; return cookieValue;&#125;//删除cookiefunction unsetCookie(name) &#123; document.cookie = name + &quot;= ; expires=&quot; + new Date(0);&#125; 说说TCP传输的三次握手策略为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志：SYN和ACK。发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。 说说你对Promise的理解依照 Promise/A+ 的定义，Promise 有四种状态： 1234pending: 初始状态, 非 fulfilled 或 rejected.fulfilled: 成功的操作.rejected: 失败的操作.settled: Promise已被fulfilled或rejected，且不是pending 另外， fulfilled 与 rejected 一起合称 settled。 Promise 对象用来进行延迟(deferred) 和异步(asynchronous ) 计算。 Promise 的构造函数 构造一个 Promise，最基本的用法如下： 1234567var promise = new Promise(function(resolve, reject) &#123; if (...) &#123; // succeed resolve(result); &#125; else &#123; // fails reject(Error(errMessage)); &#125;&#125;); Promise 实例拥有 then 方法（具有 then 方法的对象，通常被称为 thenable）。它的使用方法如下： 1promise.then(onFulfilled, onRejected) 接收两个函数作为参数，一个在 fulfilled 的时候被调用，一个在 rejected 的时候被调用，接收参数就是 future，onFulfilled 对应 resolve, onRejected 对应 reject。 Javascript垃圾回收方法标记清除（mark and sweep）这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。 垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了 引用计数(reference counting)在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。 在IE中虽然JavaScript对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的，也就是说只要涉及BOM及DOM就会出现循环引用问题。 谈谈性能优化问题代码层面：避免使用css表达式，避免使用高级选择器，通配选择器。缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载。请求带宽：压缩文件，开启GZIP， 移动端性能优化 尽量使用css3动画，开启硬件加速。适当使用touch事件代替click事件。避免使用css3渐变阴影效果。尽可能少的使用box-shadow与gradients。box-shadow与gradients往往都是页面的性能杀手 什么是Etag？浏览器下载组件的时候，会将它们存储到浏览器缓存中。如果需要再次获取相同的组件，浏览器将检查组件的缓存时间，假如已经过期，那么浏览器将发送一个条件GET请求到服务器，服务器判断缓存还有效，则发送一个304响应，告诉浏览器可以重用缓存组件。 那么服务器是根据什么判断缓存是否还有效呢?答案有两种方式，一种是前面提到的ETag，另一种是根据Last-Modified Expires和Cache-ControlExpires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。 12345Cache-Control: no-cache, private, max-age=0ETag: abcdeExpires: Thu, 15 Apr 2014 20:00:00 GMTPragma: privateLast-Modified: $now // RFC1123 format 栈和队列的区别?栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。队列先进先出，栈先进后出。栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除 栈和堆的区别？栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。堆（数据结构）：堆可以被看成是一棵树，如：堆排序；栈（数据结构）：一种先进后出的数据结构。 关于Http 2.0 你知道多少？HTTP/2引入了“服务端推（serverpush）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。HTTP/2提供更多的加密支持HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽。 什么是防抖和节流？有什么区别？如何实现？防抖触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间思路：每次触发事件时都取消之前的延时调用方法 123456789101112function debounce(fn) &#123; let timeout = null; // 创建一个标记用来存放定时器的返回值 return function () &#123; clearTimeout(timeout); // 每当用户输入的时候把前一个 setTimeout clear 掉 timeout = setTimeout(() =&gt; &#123; // 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数 fn.apply(this, arguments); &#125;, 500); &#125;; &#125; function sayHi() &#123; console.log(&apos;防抖成功&apos;); &#125; var inp = document.getElementById(&apos;inp&apos;); inp.addEventListener(&apos;input&apos;, debounce(sayHi)); // 防抖节流高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率思路：每次触发事件时都判断当前是否有等待执行的延时函数 12345678910111213141516function throttle(fn) &#123; let canRun = true; // 通过闭包保存一个标记 return function () &#123; if (!canRun) return; // 在函数开头判断标记是否为true，不为true则return canRun = false; // 立即设置为false setTimeout(() =&gt; &#123; // 将外部传入的函数的执行放在setTimeout中 fn.apply(this, arguments); // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉 canRun = true; &#125;, 500); &#125;; &#125; function sayHi(e) &#123; console.log(e.target.innerWidth, e.target.innerHeight); &#125; window.addEventListener(&apos;resize&apos;, throttle(sayHi)); get请求传参长度的误区、get和post请求在缓存方面的区别误区：我们经常说get请求参数的大小存在限制，而post请求的参数大小是无限制的。 实际上HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对get请求参数的限制是来源与浏览器或web服务器，浏览器或web服务器限制了url的长度。为了明确这个概念，我们必须再次强调下面几点: HTTP 协议 未规定 GET 和POST的长度限制GET的最大长度显示是因为 浏览器和 web服务器限制了 URI的长度不同的浏览器和WEB服务器，限制的最大长度不一样要支持IE，则最大长度为2083byte，若只支持Chrome，则最大长度 8182byte补充补充一个get和post在缓存方面的区别： get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。 模块化发展历程可从IIFE、AMD、CMD、CommonJS、UMD、webpack(require.ensure)、ES Module、&lt;script type=&quot;module&quot;&gt; 这几个角度考虑。 模块化主要是用来抽离公共代码，隔离作用域，避免变量冲突等。 IIFE： 使用自执行函数来编写模块化，特点：在一个单独的函数作用域中执行代码，避免变量冲突。 12345(function()&#123; return &#123; data:[] &#125;&#125;)() AMD： 使用requireJS 来编写模块化，特点：依赖必须提前声明好。 123define(&apos;./index.js&apos;,function(code)&#123; // code 就是index.js 返回的内容&#125;) CMD： 使用seaJS 来编写模块化，特点：支持动态引入依赖文件。 123define(function(require, exports, module) &#123; var indexCode = require(&apos;./index.js&apos;);&#125;) CommonJS： nodejs 中自带的模块化。 1var fs = require(&apos;fs&apos;); UMD：兼容AMD，CommonJS 模块化语法。 webpack(require.ensure)：webpack 2.x 版本中的代码分割。 ES Modules： ES6 引入的模块化，支持import 来引入另一个 js 。 1import a from &apos;a&apos;; npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？npm 模块安装机制：发出npm install命令查询node_modules目录之中是否已经存在指定模块 若存在，不再重新安装若不存在 npm 向 registry 查询模块压缩包的网址下载压缩包，存放在根目录下的.npm目录里解压压缩包到当前项目的node_modules目录 npm 实现原理输入 npm install 命令并敲下回车后，会经历如下几个阶段（以 npm 5.5.1 为例）： 执行工程自身 preinstall当前 npm 工程如果定义了 preinstall 钩子此时会被执行。 确定首层依赖模块首先需要做的是确定工程中的首层依赖，也就是 dependencies 和 devDependencies 属性中直接指定的模块（假设此时没有添加 npm install 参数）。 工程本身是整棵依赖树的根节点，每个首层依赖模块都是根节点下面的一棵子树，npm 会开启多进程从每个首层依赖模块开始逐步寻找更深层级的节点。 获取模块获取模块是一个递归的过程，分为以下几步： 获取模块信息。在下载一个模块之前，首先要确定其版本，这是因为 package.json 中往往是 semantic version（semver，语义化版本）。此时如果版本描述文件（npm-shrinkwrap.json 或 package-lock.json）中有该模块信息直接拿即可，如果没有则从仓库获取。如 packaeg.json 中某个包的版本是 ^1.1.0，npm 就会去仓库中获取符合 1.x.x 形式的最新版本。获取模块实体。上一步会获取到模块的压缩包地址（resolved 字段），npm 会用此地址检查本地缓存，缓存中有就直接拿，如果没有则从仓库下载。查找该模块依赖，如果有依赖则回到第1步，如果没有则停止。 模块扁平化（dedupe）上一步获取到的是一棵完整的依赖树，其中可能包含大量重复模块。比如 A 模块依赖于 loadsh，B 模块同样依赖于 lodash。在 npm3 以前会严格按照依赖树的结构进行安装，因此会造成模块冗余。 从 npm3 开始默认加入了一个 dedupe 的过程。它会遍历所有节点，逐个将模块放在根节点下面，也就是 node-modules 的第一层。当发现有重复模块时，则将其丢弃。 这里需要对重复模块进行一个定义，它指的是模块名相同且 semver 兼容。每个 semver 都对应一段版本允许范围，如果两个模块的版本允许范围存在交集，那么就可以得到一个兼容版本，而不必版本号完全一致，这可以使更多冗余模块在 dedupe 过程中被去掉。 比如 node-modules 下 foo 模块依赖 lodash@^1.0.0，bar 模块依赖 lodash@^1.1.0，则 ^1.1.0 为兼容版本。 而当 foo 依赖 lodash@^2.0.0，bar 依赖 lodash@^1.1.0，则依据 semver 的规则，二者不存在兼容版本。会将一个版本放在 node_modules 中，另一个仍保留在依赖树里。 举个例子，假设一个依赖树原本是这样： 123456node_modules-- foo---- lodash@version1-- bar---- lodash@version2 假设 version1 和 version2 是兼容版本，则经过 dedupe 会成为下面的形式： 123456node_modules-- foo-- bar-- lodash（保留的版本为兼容版本） 假设 version1 和 version2 为非兼容版本，则后面的版本保留在依赖树中： 123456node_modules-- foo-- lodash@version1-- bar---- lodash@version2 安装模块这一步将会更新工程中的 node_modules，并执行模块中的生命周期函数（按照 preinstall、install、postinstall 的顺序）。 执行工程自身生命周期当前 npm 工程如果定义了钩子此时会被执行（按照 install、postinstall、prepublish、prepare 的顺序）。 最后一步是生成或更新版本描述文件，npm install 过程完成。 ES5的继承和ES6的继承有什么区别？ES5的继承时通过prototype或构造函数机制来实现。ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.apply(this)）。 ES6的继承机制完全不同，实质上是先创建父类的实例对象this（所以必须先调用父类的super()方法），然后再用子类的构造函数修改this。 具体的：ES6通过class关键字定义类，里面有构造方法，类之间通过extends关键字实现继承。子类必须在constructor方法中调用super方法，否则新建实例报错。因为子类没有自己的this对象，而是继承了父类的this对象，然后对其进行加工。如果不调用super方法，子类得不到this对象。 ps：super关键字指代父类的实例，即父类的this对象。在子类构造函数中，调用super后，才可使用this关键字，否则报错。 定时器的执行顺序或机制？因为js是单线程的，浏览器遇到setTimeout或者setInterval会先执行完当前的代码块，在此之前会把定时器推入浏览器的待执行事件队列里面，等到浏览器执行完当前代码之后会看一下事件队列里面有没有任务，有的话才执行定时器的代码。所以即使把定时器的时间设置为0还是会先执行当前的一些代码。 1234567891011121314151617function test()&#123; var aa = 0; var testSet = setInterval(function()&#123; aa++; console.log(123); if(aa&lt;10)&#123; clearInterval(testSet); &#125; &#125;,20); var testSet1 = setTimeout(function()&#123; console.log(321) &#125;,1000); for(var i=0;i&lt;10;i++)&#123; console.log(&apos;test&apos;); &#125;&#125;test() 输出结果： 1234test //10次undefined123321 [‘1’,’2’,’3’].map(parseInt) 输出什么,为什么?输出：[1, NaN, NaN] 首先让我们回顾一下，map函数的第一个参数callback：var new_array = arr.map(function callback(currentValue[, index[, array]]) { // Return element for new_array }[, thisArg])这个callback一共可以接收三个参数，其中第一个参数代表当前被处理的元素，而第二个参数代表该元素的索引。 而parseInt则是用来解析字符串的，使字符串成为指定基数的整数。parseInt(string, radix)接收两个参数，第一个表示被处理的值（字符串），第二个表示为解析时的基数。了解这两个函数后，我们可以模拟一下运行情况parseInt(‘1’, 0) //radix为0时，且string参数不以“0x”和“0”开头时，按照10为基数处理。这个时候返回1parseInt(‘2’, 1) //基数为1（1进制）表示的数中，最大值小于2，所以无法解析，返回NaNparseInt(‘3’, 2) //基数为2（2进制）表示的数中，最大值小于3，所以无法解析，返回NaNmap函数返回的是一个数组，所以最后结果为[1, NaN, NaN] Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?Doctype声明于文档最前面，告诉浏览器以何种方式来渲染页面，这里有两种模式，严格模式和混杂模式。 严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。混杂模式，向后兼容，模拟老式浏览器，防止浏览器无法兼容页面。 fetch发送2次请求的原因fetch发送post请求的时候，总是发送2次，第一次状态码是204，第二次才成功？ 原因很简单，因为你用fetch的post请求的时候，导致fetch 第一次发送了一个Options请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求。 http、浏览器对象HTTPS 握手过程中，客户端如何验证证书的合法性首先什么是HTTP协议?http协议是超文本传输协议，位于tcp/ip四层模型中的应用层；通过请求/响应的方式在客户端和服务器之间进行通信；但是缺少安全性，http协议信息传输是通过明文的方式传输，不做任何加密，相当于在网络上裸奔；容易被中间人恶意篡改，这种行为叫做中间人攻击； 加密通信：为了安全性，双方可以使用对称加密的方式key进行信息交流，但是这种方式对称加密秘钥也会被拦截，也不够安全，进而还是存在被中间人攻击风险；于是人们又想出来另外一种方式，使用非对称加密的方式；使用公钥/私钥加解密；通信方A发起通信并携带自己的公钥，接收方B通过公钥来加密对称秘钥；然后发送给发起方A；A通过私钥解密；双发接下来通过对称秘钥来进行加密通信；但是这种方式还是会存在一种安全性；中间人虽然不知道发起方A的私钥，但是可以做到偷天换日，将拦截发起方的公钥key;并将自己生成的一对公/私钥的公钥发送给B；接收方B并不知道公钥已经被偷偷换过；按照之前的流程，B通过公钥加密自己生成的对称加密秘钥key2;发送给A；这次通信再次被中间人拦截，尽管后面的通信，两者还是用key2通信，但是中间人已经掌握了Key2;可以进行轻松的加解密；还是存在被中间人攻击风险； 解决困境：权威的证书颁发机构CA来解决；制作证书：作为服务端的A，首先把自己的公钥key1发给证书颁发机构，向证书颁发机构进行申请证书；证书颁发机构有一套自己的公私钥，CA通过自己的私钥来加密key1,并且通过服务端网址等信息生成一个证书签名，证书签名同样使用机构的私钥进行加密；制作完成后，机构将证书发给A；校验证书真伪：当B向服务端A发起请求通信的时候，A不再直接返回自己的公钥，而是返回一个证书；说明：各大浏览器和操作系统已经维护了所有的权威证书机构的名称和公钥。B只需要知道是哪个权威机构发的证书，使用对应的机构公钥，就可以解密出证书签名；接下来，B使用同样的规则，生成自己的证书签名，如果两个签名是一致的，说明证书是有效的；签名验证成功后，B就可以再次利用机构的公钥，解密出A的公钥key1;接下来的操作，就是和之前一样的流程了； 中间人是否会拦截发送假证书到B呢？因为证书的签名是由服务器端网址等信息生成的，并且通过第三方机构的私钥加密中间人无法篡改； 所以最关键的问题是证书签名的真伪； https主要的思想是在http基础上增加了ssl安全层，即以上认证过程； TCP三次握手和四次挥手三次握手之所以是三次是保证client和server均让对方知道自己的接收和发送能力没问题而保证的最小次数。 第一次client =&gt; server 只能server判断出client具备发送能力第二次 server =&gt; client client就可以判断出server具备发送和接受能力。此时client还需让server知道自己接收能力没问题于是就有了第三次第三次 client =&gt; server 双方均保证了自己的接收和发送能力没有问题 其中，为了保证后续的握手是为了应答上一个握手，每次握手都会带一个标识 seq，后续的ACK都会对这个seq进行加一来进行确认。 img iframe script来发送跨域请求有什么优缺点？iframe优点：跨域完毕之后DOM操作和互相之间的JavaScript调用都是没有问题的 缺点：1.若结果要以URL参数传递，这就意味着在结果数据量很大的时候需要分割传递，巨烦。2.还有一个是iframe本身带来的，母页面和iframe本身的交互本身就有安全性限制。 script优点：可以直接返回json格式的数据，方便处理 缺点：只接受GET请求方式 图片ping优点：可以访问任何url，一般用来进行点击追踪，做页面分析常用的方法 缺点：不能访问响应文本，只能监听是否响应 http和https的区别？http传输的数据都是未加密的，也就是明文的，网景公司设置了SSL协议来对http协议传输的数据进行加密处理，简单来说https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。 主要的区别如下： Https协议需要ca证书，费用较高。http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。使用不同的链接方式，端口也不同，一般而言，http协议的端口为80，https的端口为443http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 什么是Bom？有哪些常用的Bom属性？Bom是浏览器对象 location对象location.href– 返回或设置当前文档的URLlocation.search – 返回URL中的查询字符串部分。例如 http://www.dreamdu.com/dreamd… 返回包括(?)后面的内容?id=5&amp;name=dreamdulocation.hash – 返回URL#后面的内容，如果没有#，返回空 location.host – 返回URL中的域名部分，例如www.dreamdu.comlocation.hostname – 返回URL中的主域名部分，例如dreamdu.comlocation.pathname – 返回URL的域名后的部分。例如 http://www.dreamdu.com/xhtml/ 返回/xhtml/location.port – 返回URL中的端口部分。例如 http://www.dreamdu.com:8080/xhtml/ 返回8080location.protocol – 返回URL中的协议部分。例如 http://www.dreamdu.com:8080/xhtml/ 返回(//)前面的内容http:location.assign – 设置当前文档的URLlocation.replace() – 设置当前文档的URL，并且在history对象的地址列表中移除这个URL location.replace(url);location.reload() – 重载当前页面 history对象history.go() – 前进或后退指定的页面数history.go(num); history.back() – 后退一页history.forward() – 前进一页 Navigator对象navigator.userAgent – 返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串)navigator.cookieEnabled – 返回浏览器是否支持(启用)cookie Cookie、sessionStorage、localStorage的区别共同点：都是保存在浏览器端，并且是同源的 Cookie：cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下,存储的大小很小只有4K左右。 （key：可以在浏览器和服务器端来回传递，存储容量小，只有大约4K左右） sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持，localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。（key：本身就是一个回话过程，关闭浏览器后消失，session为一个回话，当页面不同即使是同一页面打开两次，也被视为同一次回话） localStorage：localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。（key：同源窗口都会共享，并且不会失效，不管窗口或者浏览器关闭与否都会始终生效） 补充说明一下cookie的作用：保存用户登录状态。例如将用户id存储于一个cookie内，这样当用户下次访问该页面时就不需要重新登录了，现在很多论坛和社区都提供这样的功能。 cookie还可以设置过期时间，当超过时间期限后，cookie就会自动消失。因此，系统往往可以提示用户保持登录状态的时间：常见选项有一个月、三个 月、一年等。跟踪用户行为。例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了 cookie后就会显得很人性化了，系统能够记住上一次访问的地区，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。因为一切都是在后 台完成，所以这样的页面就像为某个用户所定制的一样，使用起来非常方便定制页面。如果网站提供了换肤或更换布局的功能，那么可以使用cookie来记录用户的选项，例如：背景色、分辨率等。当用户下次访问时，仍然可以保存上一次访问的界面风格。 Cookie如何防范XSS攻击XSS（跨站脚本攻击）是指攻击者在返回的HTML中嵌入javascript脚本，为了减轻这些攻击，需要在HTTP头部配上，set-cookie： httponly-这个属性可以防止XSS,它会禁止javascript脚本来访问cookie。secure - 这个属性告诉浏览器仅在请求为https的时候发送cookie。结果应该是这样的：Set-Cookie=….. 浏览器和 Node 事件循环的区别？其中一个主要的区别在于浏览器的event loop 和nodejs的event loop 在处理异步事件的顺序是不同的,nodejs中有micro event;其中Promise属于micro event 该异步事件的处理顺序就和浏览器不同.nodejs V11.0以上 这两者之间的顺序就相同了. 123456789101112131415function test () &#123; console.log(&apos;start&apos;) setTimeout(() =&gt; &#123; console.log(&apos;children2&apos;) Promise.resolve().then(() =&gt; &#123;console.log(&apos;children2-1&apos;)&#125;) &#125;, 0) setTimeout(() =&gt; &#123; console.log(&apos;children3&apos;) Promise.resolve().then(() =&gt; &#123;console.log(&apos;children3-1&apos;)&#125;) &#125;, 0) Promise.resolve().then(() =&gt; &#123;console.log(&apos;children1&apos;)&#125;) console.log(&apos;end&apos;) &#125;test() // 以上代码在node11以下版本的执行结果(先执行所有的宏任务，再执行微任务)// start// end// children1// children2// children3// children2-1// children3-1 // 以上代码在node11及浏览器的执行结果(顺序执行宏任务和微任务)// start// end// children1// children2// children2-1// children3// children3-1 简述HTTPS中间人攻击https协议由 http + ssl 协议构成，具体的链接过程可参考SSL或TLS握手的概述 中间人攻击过程如下：服务器向客户端发送公钥。攻击者截获公钥，保留在自己手上。然后攻击者自己生成一个【伪造的】公钥，发给客户端。客户端收到伪造的公钥后，生成加密hash值发给服务器。攻击者获得加密hash值，用自己的私钥解密获得真秘钥。同时生成假的加密hash值，发给服务器。服务器用私钥解密获得假秘钥。服务器用加秘钥加密传输信息 防范方法：服务端在发送浏览器的公钥中加入CA证书，浏览器可以验证CA证书的有效性 说几条web前端优化策略(1). 减少HTTP请求数 这条策略基本上所有前端人都知道，而且也是最重要最有效的。都说要减少HTTP请求，那请求多了到底会怎么样呢？首先，每个请求都是有成本的，既包 含时间成本也包含资源成本。一个完整的请求都需要经过DNS寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据这样一个“漫长”而复杂的过程。 时间成本就是用户需要看到或者“感受”到这个资源是必须要等待这个过程结束的，资源上由于每个请求都需要携带数据，因此每个请求都需要占用带宽。 另外，由于浏览器进行并发请求的请求数是有上限的，因此请求数多了以后，浏览器需要分批进行请求，因此会增加用户的等待时间，会给 用户造成站点速度慢这样一个印象，即使可能用户能看到的第一屏的资源都已经请求完了，但是浏览器的进度条会一直存在。减少HTTP请求数的主要途径包括： (2). 从设计实现层面简化页面 如果你的页面像百度首页一样简单，那么接下来的规则基本上都用不着了。保持页面简洁、减少资源的使用时最直接的。如果不是这样，你的页面需要华丽的皮肤，则继续阅读下面的内容。 (3). 合理设置HTTP缓存 缓存的力量是强大的，恰当的缓存设置可以大大的减少HTTP请求。以有啊首页为例，当浏览器没有缓存的时候访问一共会发出78个请求，共600多K 数据（如图1.1），而当第二次访问即浏览器已缓存之后访问则仅有10个请求，共20多K数据（如图1.2）。（这里需要说明的是，如果直接F5刷新页面 的话效果是不一样的，这种情况下请求数还是一样，不过被缓存资源的请求服务器是304响应，只有Header没有Body，可以节省带宽） 怎样才算合理设置？原则很简单，能缓存越多越好，能缓存越久越好。例如，很少变化的图片资源可以直接通过HTTP Header中的Expires设置一个很长的过期头；变化不频繁而又可能会变的资源可以使用Last-Modifed来做请求验证。尽可能的让资源能够 在缓存中待得更久。 (4). 资源合并与压缩 如果可以的话，尽可能的将外部的脚本、样式进行合并，多个合为一个。另外，CSS、Javascript、Image都可以用相应的工具进行压缩，压缩后往往能省下不少空间。 (5). CSS Sprites 合并CSS图片，减少请求数的又一个好办法。 (6). Inline Images 使用data: URL scheme的方式将图片嵌入到页面或CSS中，如果不考虑资源管理上的问题的话，不失为一个好办法。如果是嵌入页面的话换来的是增大了页面的体积，而且无法利用浏览器缓存。使用在CSS中的图片则更为理想一些。 (7). Lazy Load Images 这条策略实际上并不一定能减少HTTP请求数，但是却能在某些条件下或者页面刚加载时减少HTTP请求数。对于图片而言，在页面刚加载的时候可以只 加载第一屏，当用户继续往后滚屏的时候才加载后续的图片。这样一来，假如用户只对第一屏的内容感兴趣时，那剩余的图片请求就都节省了。有啊首页曾经的做法 是在加载的时候把第一屏之后的图片地址缓存在Textarea标签中，待用户往下滚屏的时候才“惰性”加载。 你了解的浏览器的重绘和回流导致的性能问题重绘（Repaint）和回流（Reflow） 重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大。 重绘是当节点需要更改外观而不会影响布局的，比如改变 color就叫称为重绘回流是布局或者几何属性需要改变就称为回流。回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流。 所以以下几个动作可能会导致性能问题： 改变 window 大小 改变字体 添加或删除样式 文字改变 定位或者浮动 盒模型 很多人不知道的是，重绘和回流其实和 Event loop 有关。 当 Event loop 执行完 Microtasks 后，会判断 document 是否需要更新。因为浏览器是 60Hz 的刷新率，每 16ms 才会更新一次。然后判断是否有 resize或者 scroll，有的话会去触发事件，所以 resize和 scroll事件也是至少 16ms 才会触发一次，并且自带节流功能。判断是否触发了 media query更新动画并且发送事件判断是否有全屏操作事件执行 requestAnimationFrame回调执行 IntersectionObserver回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好更新界面以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback回调。减少重绘和回流 使用 translate 替代 top 12345678910111213141516&lt;div class=&quot;test&quot;&gt;&lt;/div&gt;&lt;style&gt; .test &#123; position: absolute; top: 10px; width: 100px; height: 100px; background: red; &#125;&lt;/style&gt;&lt;script&gt; setTimeout(() =&gt; &#123; // 引起回流 document.querySelector(&apos;.test&apos;).style.top = &apos;100px&apos; &#125;, 1000)&lt;/script&gt; 使用 visibility替换 display: none，因为前者只会引起重绘，后者会引发回流（改变了布局） 把 DOM 离线后修改，比如：先把 DOM 给 display:none(有一次 Reflow)，然后你修改100次，然后再把它显示出来 不要把 DOM 结点的属性值放在一个循环里当成循环里的变量 1234for(let i = 0; i &lt; 1000; i++) &#123; // 获取 offsetTop 会导致回流，因为需要去获取正确的值 console.log(document.querySelector(&apos;.test&apos;).style.offsetTop)&#125; 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrameCSS 选择符从右往左匹配查找，避免 DOM 深度过深将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 video标签，浏览器会自动将该节点变为图层。 react、Vue写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？vue和react都是采用diff算法来对比新旧虚拟节点，从而更新节点。在vue的diff函数中（建议先了解一下diff算法过程）。在交叉对比中，当新节点跟旧节点头尾交叉对比没有结果时，会根据新节点的key去对比旧节点数组中的key，从而找到相应旧节点（这里对应的是一个key =&gt; index 的map映射）。如果没找到就认为是一个新增节点。而如果没有key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个map映射，另一种是遍历查找。相比而言。map映射的速度更快。vue部分源码如下： 1234567891011121314151617181920212223242526272829303132333435// vue项目 src/core/vdom/patch.js -488行// 以下是为了阅读性进行格式化后的代码// oldCh 是一个旧虚拟节点数组if (isUndef(oldKeyToIdx)) &#123; oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)&#125;if(isDef(newStartVnode.key)) &#123; // map 方式获取 idxInOld = oldKeyToIdx[newStartVnode.key]&#125; else &#123; // 遍历方式获取 idxInOld = findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)&#125;创建map函数function createKeyToOldIdx (children, beginIdx, endIdx) &#123; let i, key const map = &#123;&#125; for (i = beginIdx; i &lt;= endIdx; ++i) &#123; key = children[i].key if (isDef(key)) map[key] = i &#125; return map&#125;遍历寻找// sameVnode 是对比新旧节点是否相同的函数 function findIdxInOld (node, oldCh, start, end) &#123; for (let i = start; i &lt; end; i++) &#123; const c = oldCh[i] if (isDef(c) &amp;&amp; sameVnode(node, c)) return i &#125; &#125; React 中 setState 什么时候是同步的，什么时候是异步的？在React中，如果是由React引发的事件处理（比如通过onClick引发的事件处理），调用setState不会同步更新this.state，除此之外的setState调用会同步执行this.state。所谓“除此之外”，指的是绕过React通过addEventListener直接添加的事件处理函数，还有通过setTimeout/setInterval产生的异步调用。 原因：在React的setState函数实现中，会根据一个变量isBatchingUpdates判断是直接更新this.state还是放到队列中回头再说，而isBatchingUpdates默认是false，也就表示setState会同步更新this.state，但是，有一个函数batchedUpdates，这个函数会把isBatchingUpdates修改为true，而当React在调用事件处理函数之前就会调用这个batchedUpdates，造成的后果，就是由React控制的事件处理过程setState不会同步更新this.state。 下面输出什么1234567891011121314151617181920212223242526272829class Example extends React.Component &#123; constructor() &#123; super(); this.state = &#123; val: 0 &#125;; &#125; componentDidMount() &#123; this.setState(&#123;val: this.state.val + 1&#125;); console.log(this.state.val); // 第 1 次 log this.setState(&#123;val: this.state.val + 1&#125;); console.log(this.state.val); // 第 2 次 log setTimeout(() =&gt; &#123; this.setState(&#123;val: this.state.val + 1&#125;); console.log(this.state.val); // 第 3 次 log this.setState(&#123;val: this.state.val + 1&#125;); console.log(this.state.val); // 第 4 次 log &#125;, 0); &#125; render() &#123; return null; &#125;&#125;; 1、第一次和第二次都是在 react 自身生命周期内，触发时 isBatchingUpdates 为 true，所以并不会直接执行更新 state，而是加入了 dirtyComponents，所以打印时获取的都是更新前的状态 0。 2、两次 setState 时，获取到 this.state.val 都是 0，所以执行时都是将 0 设置成 1，在 react 内部会被合并掉，只执行一次。设置完成后 state.val 值为 1。 3、setTimeout 中的代码，触发时 isBatchingUpdates 为 false，所以能够直接进行更新，所以连着输出 2，3。 输出： 0 0 2 3 为什么虚拟dom会提高性能?虚拟dom相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操作，从而提高性能。 具体实现步骤如下： 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异 把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了。 css分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景结构：display:none: 会让元素完全从渲染树中消失，渲染的时候不占据任何空间, 不能点击，visibility: hidden:不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，不能点击opacity: 0: 不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，可以点击 继承：display: none和opacity: 0：是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示。visibility: hidden：是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式。 性能：displaynone : 修改元素会造成文档回流,读屏器不会读取display: none元素内容，性能消耗较大visibility:hidden: 修改元素只会造成本元素的重绘,性能消耗较少读屏器读取visibility: hidden元素内容opacity: 0 ： 修改元素会造成重绘，性能消耗较少 联系：它们都能让元素不可见 清除浮动的方式有哪些?比较好的是哪一种?常用的一般为三种.clearfix, clear:both,overflow:hidden; 比较好是 .clearfix,伪元素万金油版本,后两者有局限性. 123456789101112131415161718192021222324252627282930.clearfix:after &#123; visibility: hidden; display: block; font-size: 0; content: &quot; &quot;; clear: both; height: 0;&#125;&lt;!--为毛没有 zoom ,_height 这些,IE6,7这类需要 csshack 不再我们考虑之内了.clearfix 还有另外一种写法,--&gt;.clearfix:before, .clearfix:after &#123; content:&quot;&quot;; display:table;&#125;.clearfix:after&#123; clear:both; overflow:hidden;&#125;.clearfix&#123; zoom:1;&#125;&lt;!--用display:table 是为了避免外边距margin重叠导致的margin塌陷,内部元素默认会成为 table-cell 单元格的形式--&gt; clear:both:若是用在同一个容器内相邻元素上,那是贼好的,有时候在容器外就有些问题了, 比如相邻容器的包裹层元素塌陷 overflow:hidden:这种若是用在同个容器内,可以形成 BFC避免浮动造成的元素塌陷 css sprite 是什么,有什么优缺点概念： 将多个小图片拼接到一个图片中。通过 background-position 和元素尺寸调节需要显示的背景图案。 优点： 减少 HTTP 请求数，极大地提高页面加载速度增加图片信息重复度，提高压缩比，减少图片大小更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现 缺点： 图片合并麻烦维护麻烦，修改一个图片可能需要重新布局整个图片，样式 link与@import的区别link是 HTML 方式， @import是 CSS 方式link最大限度支持并行下载，@import过多嵌套导致串行下载，出现FOUClink可以通过rel=”alternate stylesheet”指定候选样式浏览器对link支持早于@import，可以使用@import对老浏览器隐藏样式@import必须在样式规则之前，可以在 css 文件中引用其他文件总体来说：link 优于@import display: block;和display: inline;的区别block元素特点：1.处于常规流中时，如果width没有设置，会自动填充满父容器 2.可以应用margin/padding 3.在没有设置高度的情况下会扩展高度以包含常规流中的子元素 4.处于常规流中时布局时在前后元素位置之间（独占一个水平空间） 5.忽略vertical-align inline元素特点1.水平方向上根据direction依次布局 2.不会在元素前后进行换行 3.受white-space控制 4.margin/padding在竖直方向上无效，水平方向上有效 5.width/height属性对非替换行内元素无效，宽度由元素内容决定 6.非替换行内元素的行框高由line-height确定，替换行内元素的行框高由height,margin,padding,border决定 7.浮动或绝对定位时会转换为block 8.vertical-align属性生效 容器包含若干浮动元素时如何清理浮动容器元素闭合标签前添加额外元素并设置clear: both父元素触发块级格式化上下文(见块级可视化上下文部分)设置容器元素伪元素进行清理推荐的清理浮动方法 1234567891011121314151617181920212223242526/*** 在标准浏览器下使用* 1 content内容为空格用于修复opera下文档中出现* contenteditable属性时在清理浮动元素上下的空白* 2 使用display使用table而不是block：可以防止容器和* 子元素top-margin折叠,这样能使清理效果与BFC，IE6/7* zoom: 1;一致**/.clearfix:before,.clearfix:after &#123; content: &quot; &quot;; /* 1 */ display: table; /* 2 */&#125;.clearfix:after &#123; clear: both;&#125;/**IE 6/7下使用通过触发hasLayout实现包含浮动**/.clearfix &#123; *zoom: 1;&#125; PNG,GIF,JPG 的区别及如何选GIF:8 位像素，256 色无损压缩支持简单动画支持 boolean 透明适合简单动画 JPEG：颜色限于 256有损压缩可控制压缩质量不支持透明适合照片 PNG：有 PNG8 和 truecolor PNGPNG8 类似 GIF 颜色上限为 256，文件小，支持 alpha 透明度，无动画适合图标、背景、按钮 display,float,position 的关系如果display为 none，那么 position 和 float 都不起作用，这种情况下元素不产生框否则，如果 position 值为 absolute 或者 fixed，框就是绝对定位的，float 的计算值为 none，display 根据下面的表格进行调整。否则，如果 float 不是 none，框是浮动的，display 根据下表进行调整否则，如果元素是根元素，display 根据下表进行调整其他情况下 display 的值为指定值 总结起来：绝对定位、浮动、根元素都需要调整display 如何水平居中一个元素如果需要居中的元素为常规流中 inline 元素，为父元素设置text-align: center;即可实现如果需要居中的元素为常规流中 block 元素，1）为元素设置宽度，2）设置左右 margin 为 auto。3）IE6 下需在父元素上设置text-align: center;,再给子元素恢复需要的值 &lt;body&gt; &lt;div class=&quot;content&quot;&gt; aaaaaa aaaaaa a a a a a a a a &lt;/div&gt; &lt;/body&gt; &lt;style&gt; body { background: #DDD; text-align: center; /* 3 */ } .content { width: 500px; /* 1 */ text-align: left; /* 3 */ margin: 0 auto; /* 2 */ background: purple; } &lt;/style&gt;如果需要居中的元素为浮动元素，1）为元素设置宽度，2）position: relative;，3）浮动方向偏移量（left 或者 right）设置为 50%，4）浮动方向上的 margin 设置为元素宽度一半乘以-1 &lt;body&gt; &lt;div class=&quot;content&quot;&gt; aaaaaa aaaaaa a a a a a a a a &lt;/div&gt; &lt;/body&gt; &lt;style&gt; body { background: #DDD; } .content { width: 500px; /* 1 */ float: left; position: relative; /* 2 */ left: 50%; /* 3 */ margin-left: -250px; /* 4 */ background-color: purple; } &lt;/style&gt;如果需要居中的元素为绝对定位元素，1）为元素设置宽度，2）偏移量设置为 50%，3）偏移方向外边距设置为元素宽度一半乘以-1 12345678910111213141516171819&lt;body&gt; &lt;div class=&quot;content&quot;&gt; aaaaaa aaaaaa a a a a a a a a &lt;/div&gt;&lt;/body&gt;&lt;style&gt; body &#123; background: #DDD; position: relative; &#125; .content &#123; width: 800px; position: absolute; left: 50%; margin-left: -400px; background-color: purple; &#125;&lt;/style&gt; 如果需要居中的元素为绝对定位元素，1）为元素设置宽度，2）设置左右偏移量都为 0,3）设置左右外边距都为 auto &lt;body&gt; &lt;div class=&quot;content&quot;&gt; aaaaaa aaaaaa a a a a a a a a &lt;/div&gt; &lt;/body&gt; &lt;style&gt; body { background: #DDD; position: relative; } .content { width: 800px; position: absolute; margin: 0 auto; left: 0; right: 0; background-color: purple; } &lt;/style&gt;Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？1234567891011const promise = new Promise((resolve, reject) =&gt; &#123; console.log(1) resolve() console.log(2)&#125;)promise.then(() =&gt; &#123; console.log(3)&#125;)console.log(4) 输出结果是： 1243promise构造函数是同步执行的，then方法是异步执行的Promise new的时候会立即执行里面的代码 then是微任务 会在本次任务执行完的时候执行 setTimeout是宏任务 会在下次任务执行的时候执行 JS的四种设计模式工厂模式简单的工厂模式可以理解为解决多个相似的问题; 123456789101112131415161718192021function CreatePerson(name,age,sex) &#123; var obj = new Object(); obj.name = name; obj.age = age; obj.sex = sex; obj.sayName = function()&#123; return this.name; &#125; return obj;&#125;var p1 = new CreatePerson(&quot;longen&quot;,&apos;28&apos;,&apos;男&apos;);var p2 = new CreatePerson(&quot;tugenhua&quot;,&apos;27&apos;,&apos;女&apos;);console.log(p1.name); // longenconsole.log(p1.age); // 28console.log(p1.sex); // 男console.log(p1.sayName()); // longenconsole.log(p2.name); // tugenhuaconsole.log(p2.age); // 27console.log(p2.sex); // 女console.log(p2.sayName()); // tugenhua 单例模式只能被实例化(构造函数给实例添加属性与方法)一次 1234567891011121314151617181920// 单体模式var Singleton = function(name)&#123; this.name = name;&#125;;Singleton.prototype.getName = function()&#123; return this.name;&#125;// 获取实例对象var getInstance = (function() &#123; var instance = null; return function(name) &#123; if(!instance) &#123;//相当于一个一次性阀门,只能实例化一次 instance = new Singleton(name); &#125; return instance; &#125;&#125;)();// 测试单体模式的实例,所以a===bvar a = getInstance(&quot;aa&quot;);var b = getInstance(&quot;bb&quot;); 沙箱模式将一些函数放到自执行函数里面,但要用闭包暴露接口,用变量接收暴露的接口,再调用里面的值,否则无法使用里面的值 12345678let sandboxModel=(function()&#123; function sayName()&#123;&#125;; function sayAge()&#123;&#125;; return&#123; sayName:sayName, sayAge:sayAge &#125;&#125;)() 发布者订阅模式就例如如我们关注了某一个公众号,然后他对应的有新的消息就会给你推送, //发布者与订阅模式 var shoeObj = {}; // 定义发布者 shoeObj.list = []; // 缓存列表 存放订阅者回调函数 // 增加订阅者 shoeObj.listen = function(fn) { shoeObj.list.push(fn); // 订阅消息添加到缓存列表 } // 发布消息 shoeObj.trigger = function() { for (var i = 0, fn; fn = this.list[i++];) { fn.apply(this, arguments);//第一个参数只是改变fn的this, } } // 小红订阅如下消息 shoeObj.listen(function(color, size) { console.log(&quot;颜色是：&quot; + color); console.log(&quot;尺码是：&quot; + size); }); // 小花订阅如下消息 shoeObj.listen(function(color, size) { console.log(&quot;再次打印颜色是：&quot; + color); console.log(&quot;再次打印尺码是：&quot; + size); }); shoeObj.trigger(&quot;红色&quot;, 40); shoeObj.trigger(&quot;黑色&quot;, 42); 代码实现逻辑是用数组存贮订阅者, 发布者回调函数里面通知的方式是遍历订阅者数组,并将发布者内容传入订阅者数组 列举出集中创建实例的方法1.字面量 1let obj=&#123;&apos;name&apos;:&apos;张三&apos;&#125; 2.Object构造函数创建 12let Obj=new Object()Obj.name=&apos;张三&apos; 3.使用工厂模式创建对象 1234567function createPerson(name)&#123; var o = new Object(); o.name = name; &#125;; return o; &#125;var person1 = createPerson(&apos;张三&apos;); 4.使用构造函数创建对象 1234function Person(name)&#123; this.name = name;&#125;var person1 = new Person(&apos;张三&apos;); 简述一下前端事件流HTML中与javascript交互是通过事件驱动来实现的，例如鼠标点击事件onclick、页面的滚动事件onscroll等等，可以向文档或者文档中的元素添加事件侦听器来预订事件。想要知道这些事件是在什么时候进行调用的，就需要了解一下“事件流”的概念。 什么是事件流：事件流描述的是从页面中接收事件的顺序,DOM2级事件流包括下面几个阶段。 事件捕获阶段处于目标阶段事件冒泡阶段addEventListener：addEventListener是DOM2 级事件新增的指定事件处理程序的操作，这个方法接收3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。 IE只支持事件冒泡。 Function.proto(getPrototypeOf)是什么？获取一个对象的原型，在chrome中可以通过proto的形式，或者在ES6中可以通过Object.getPrototypeOf的形式。 那么Function.proto是什么么？也就是说Function由什么对象继承而来，我们来做如下判别。 12Function.__proto__==Object.prototype //falseFunction.__proto__==Function.prototype//true 我们发现Function的原型也是Function。 我们用图可以来明确这个关系： 简述一下原型 / 构造函数 / 实例原型(prototype): 一个简单的对象，用于实现对象的 属性继承。可以简单的理解成对象的爹。在 Firefox 和 Chrome 中，每个JavaScript对象中都包含一个proto(非标准)的属性指向它爹(该对象的原型)，可obj.proto进行访问。构造函数: 可以通过new来 新建一个对象的函数。实例: 通过构造函数和new创建出来的对象，便是实例。 实例通过proto指向原型，通过constructor指向构造函数。这里来举个栗子，以Object为例，我们常用的Object便是一个构造函数，因此我们可以通过它构建实例。 12// 实例const instance = new Object() 则此时， 实例为instance, 构造函数为Object，我们知道，构造函数拥有一个prototype的属性指向原型，因此原型为: 12// 原型const prototype = Object.prototype 这里我们可以来看出三者的关系: 实例.proto === 原型 原型.constructor === 构造函数 构造函数.prototype === 原型 123456// 这条线其实是是基于原型进行获取的，可以理解成一条基于原型的映射线// 例如: // const o = new Object()// o.constructor === Object --&gt; true// o.__proto__ = null;// o.constructor === Object --&gt; false 实例.constructor === 构造函数 简述一下JS继承，并举例在 JS 中，继承通常指的便是 原型链继承，也就是通过指定原型，并可以通过原型链继承原型上的属性或者方法。 最优化: 圣杯模式 123456789var inherit = (function(c,p)&#123; var F = function()&#123;&#125;; return function(c,p)&#123; F.prototype = p.prototype; c.prototype = new F(); c.uber = p.prototype; c.prototype.constructor = c; &#125;&#125;)(); 使用 ES6 的语法糖 class / extends 函数柯里化在函数式编程中，函数是一等公民。那么函数柯里化是怎样的呢？ 函数柯里化指的是将能够接收多个参数的函数转化为接收单一参数的函数，并且返回接收余下参数且返回结果的新函数的技术。 函数柯里化的主要作用和特点就是参数复用、提前返回和延迟执行。 在一个函数中，首先填充几个参数，然后再返回一个新的函数的技术，称为函数的柯里化。通常可用于在不侵入函数的前提下，为函数 预置通用参数，供多次重复调用。 12345678910const add = function add(x) &#123; return function (y) &#123; return x + y &#125;&#125;const add1 = add(1)add1(2) === 3add1(20) === 21 说说bind、call、apply 区别？call 和 apply 都是为了解决改变 this 的指向。作用都是相同的，只是传参的方式不同。 除了第一个参数外，call 可以接收一个参数列表，apply 只接受一个参数数组。 12345678910let a = &#123; value: 1&#125;function getValue(name, age) &#123; console.log(name) console.log(age) console.log(this.value)&#125;getValue.call(a, &apos;yck&apos;, &apos;24&apos;)getValue.apply(a, [&apos;yck&apos;, &apos;24&apos;]) bind和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 bind实现柯里化。 （下面是对这三个方法的扩展介绍） 如何实现一个 bind 函数 对于实现以下几个函数，可以从几个方面思考 不传入第一个参数，那么默认为 window改变了 this 指向，让新的对象可以执行该函数。那么思路是否可以变成给新的对象添加一个函数，然后在执行完以后删除？ 123456789101112131415Function.prototype.myBind = function (context) &#123; if (typeof this !== &apos;function&apos;) &#123; throw new TypeError(&apos;Error&apos;) &#125; var _this = this var args = [...arguments].slice(1) // 返回一个函数 return function F() &#123; // 因为返回了一个函数，我们可以 new F()，所以需要判断 if (this instanceof F) &#123; return new _this(...args, ...arguments) &#125; return _this.apply(context, args.concat(...arguments)) &#125;&#125; 如何实现一个call函数 12345678910111213Function.prototype.myCall = function (context) &#123; var context = context || window // 给 context 添加一个属性 // getValue.call(a, &apos;yck&apos;, &apos;24&apos;) =&gt; a.fn = getValue context.fn = this // 将 context 后面的参数取出来 var args = [...arguments].slice(1) // getValue.call(a, &apos;yck&apos;, &apos;24&apos;) =&gt; a.fn(&apos;yck&apos;, &apos;24&apos;) var result = context.fn(...args) // 删除 fn delete context.fn return result&#125; 如何实现一个apply函数 12345678910111213141516Function.prototype.myApply = function (context) &#123; var context = context || window context.fn = this var result // 需要判断是否存储第二个参数 // 如果存在，就将第二个参数展开 if (arguments[1]) &#123; result = context.fn(...arguments[1]) &#125; else &#123; result = context.fn() &#125; delete context.fn return result&#125; 箭头函数的特点12345678function a() &#123; return () =&gt; &#123; return () =&gt; &#123; console.log(this) &#125; &#125;&#125;console.log(a()()()) 箭头函数其实是没有 this的，这个函数中的 this只取决于他外面的第一个不是箭头函数的函数的 this。 在这个例子中，因为调用a符合前面代码中的第一个情况，所以 this是 window。并且 this一旦绑定了上下文，就不会被任何代码改变。 谈谈你对 dns-prefetch 的理解DNS 是什么– Domain Name System，域名系统，作为域名和IP地址相互映射的一个分布式数据库。 DNS Prefetching浏览器根据自定义的规则，提前去解析后面可能用到的域名，来加速网站的访问速度。简单来讲就是提前解析域名，以免延迟。 使用方式1&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//wq.test.com&quot;&gt; 这个功能有个默认加载条件，所有的a标签的href都会自动去启用DNS Prefetching，也就是说，你网页的a标签href带的域名，是不需要在head里面加上link手动设置的。但a标签的默认启动在HTTPS不起作用。 这时要使用 meta里面http-equiv来强制启动功能。 1&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt; 总结一下 DNS Prefetching是提前加载域名解析的，省去了解析时间。a标签的href是可以在chrome。firefox包括高版本的IE，但是在HTTPS下面不起作用，需要meta来强制开启功能 这是DNS的提前解析，并不是css，js之类的文件缓存，大家不要混淆了两个不同的概念。 如果直接做了js的重定向，或者在服务端做了重定向，没有在link里面手动设置，是不起作用的。 这个对于什么样的网站更有作用呢，类似taobao这种网站，你的网页引用了大量很多其他域名的资源，如果你的网站，基本所有的资源都在你本域名下，那么这个基本没有什么作用。因为DNS Chrome在访问你的网站就帮你缓存了。 拓展知识学习 web下的性能优化1(网络方向) get/post请求传参长度有什么特点我们经常说get请求参数的大小存在限制，而post请求的参数大小是无限制的。这是一个错误的说法，实际上HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对get请求参数的限制是来源与浏览器或web服务器，浏览器或web服务器限制了url的长度。为了明确这个概念，我们必须再次强调下面几点: HTTP 协议 未规定 GET 和POST的长度限制 GET的最大长度显示是因为 浏览器和 web服务器限制了 URI的长度 不同的浏览器和WEB服务器，限制的最大长度不一样 要支持IE，则最大长度为2083byte，若只支持Chrome，则最大长度 8182byte 前端需要注意哪些 SEO 合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可 语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页 重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取 重要内容不要用 js 输出：爬虫不会执行 js 获取内容 少用 iframe(搜索引擎不会抓取 iframe 中的内容) 非装饰性图片必须加 alt 提高网站速度(网站速度是搜索引擎排序的一个重要指标) 实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后 退时正确响应。给出你的技术实现方案？第一步，通过使用 pushState + ajax 实现浏览器无刷新前进后退，当一次 ajax 调用成功后我们将一 条 state 记录加入到 history 对象中。 第二步，一条 state 记录包含了 url、title 和 content 属性，在 popstate 事件中可以 获取到这个 state 对象，我们可 以使用 content 来传递数据。第三步，我们通过对 window.onpopstate 事件监听来响应浏览器 的前进后退操作。 使用 pushState 来实现有两个问题，一个是打开首页时没有记录，我们可以使用 replaceState 来将首页的记录替换，另一个问 题是当一个页面刷新的时候，仍然会向服务器端请求数据，因此如果请求的 url 需要后端的配 合将其重定向到一个页面。 更多参考：http://blog.chenxu.me/post/detail?id=ed4f0732-897f-48e4-9d4f-821e82f17fad 如何优化SPA应用的首屏加载速度慢的问题？ 将公用的JS库通过script标签外部引入，减小app.bundel的大小，让浏览器并行下载资源文件，提高下载速度； 在配置 路由时，页面和组件使用懒加载的方式引入，进一步缩小 app.bundel 的体积，在调用某个组件时再加载对应的js文件； root中插入loading 或者 骨架屏 prerender-spa-plugin，提升用户体验； 如果在webview中的页面，可以进行页面预加载 独立打包异步组件公共 Bundle，以提高复用性&amp;缓存命中率 静态文件本地缓存，有两种方式分别为HTTP缓存，设置Cache-Control，Last-Modified，Etag等响应头和Service Worker离线缓存 配合 PWA 使用 SSR root中插入loading 或者 骨架屏 prerender-spa-plugin 使用 Tree Shaking 减少业务代码体积 更多参考：https://github.com/LuckyWinty/fe-weekly-questions/issues/69 Reflect 对象创建目的？ 将 Object 对 象 的 一 些 明 显 属 于 语 言 内 部 的 方 法 （ 比 如 Object.defineProperty，放到 Reflect 对象上。 修改某些 Object 方法的返回结果，让其变得更合理。 让 Object 操作都变成函数行为。 Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象 的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可 以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。 也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取 默认行为。 内部属性 [[Class]] 是什么？所有 typeof 返回值为 “object” 的对象（如数组）都包含一个内部属性 [[Class]]（我 们可以把它看作一个内部的分类，而非传统的面向对象意义上的类）。这个属性无法直接访问， 一般通过 Object.prototype.toString(..) 来查看。例如： 12Object.prototype.toString.call( [1,2,3] ); // &quot;[object Array]&quot; Object.prototype.toString.call( /regex-literal/i ); //&quot;[object RegExp]&quot; 多数情况下，对象的内部[[class]]属性和创建该对象的内建原生构造函数相对应，不过也不总是这样。2.基本类型值的[[class]]属性 虽然Null()和Undefined()这样的原生构造函数并不存在，但是内部[[class]]属性仍然是“Null”和“Undefined”。 123console.log(Object.prototype.toString.call(null)); //[object Null]console.log(Object.prototype.toString.call(undefined)); //[object Undefined] 其他基本类型值的情况有所不同： 12345console.log(Object.prototype.toString.call(&quot;abc&quot;)); //[object String]console.log(Object.prototype.toString.call(42)); //[object Number]console.log(Object.prototype.toString.call(true)); //[object Boolean] 基本类型值被各自的封装对象自动包装，所以他们的内部[[class]]属性分别为“String”，“Number”和“Boolean”。3.封装对象 由于基本类型值没有.length和.toString()这样的属性和方法，需要通过封装对象才能访问，此时Javascript引擎会自动为基本类型值包装一个封装对象。 123456789101112131415161718//封装对象包装var b = &apos;abc&apos;;console.log(b.length);console.log(b.toUpperCase());​```js一般不直接使用封装对象（即通过new操作创建基本类型值），优先考虑使用“abc”和“42”这样的基本类型值，而不是new String(&quot;abc&quot;) 和 new Number(42)。4.拆封如果想要得到封装对象中的基本类型值，可以使用valueOf()函数。 ​```js//封装对象的拆封var s = new String( &quot;abc&quot; );var n = new Number( 42 );var b = new Boolean( true );console.log(s.valueOf());console.log(n.valueOf());console.log(b.valueOf()); 什么是堆？什么是栈？它们之间有什么区别和联系？堆和栈的概念存在于数据结构中和操作系统内存中。在数据结构中，栈中数据的存取方式为 先进后出。而堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。完全 二叉树是堆的一种实现方式。在操作系统中，内存被分为栈区和堆区。栈区内存由编译器自动分 配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。堆区内存一 般由程序员分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收。 详细资料可以参考：《什么是堆？什么是栈？他们之间有什么区别和联系？》 isNaN 和 Number.isNaN 函数的区别？函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返 回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。 函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，这种方法对于 NaN 的判断更为准确。 什么情况下会发生布尔值的隐式强制类型转换？（1） if (..) 语句中的条件判断表达式。 （2） for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。 （3） while (..) 和 do..while(..) 循环中的条件判断表达式。 （4） ? : 中的条件判断表达式。 （5） 逻辑运算符 ||（逻辑或）和 &amp;&amp;（逻辑与）左边的操作数（作为条件判断表达式）。 undefined 与 undeclared 的区别？已在作用域中声明但还没有赋值的变量，是 undefined 的。相反，还没有在作用域中声明 过的变量，是 undeclared 的。对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用 typeof 的安全防范机制来避免 报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 “undefined”。 如何封装一个 javascript 的类型判断函数？12345678910111213141516function getType(value) &#123; // 判断数据是 null 的情况 if (value === null) &#123; return value + &quot;&quot;; &#125; // 判断数据是引用类型的情况 if (typeof value === &quot;object&quot;) &#123; let valueClass = Object.prototype.toString.call(value), type = valueClass.split(&quot; &quot;)[1].split(&quot;&quot;); type.pop(); return type.join(&quot;&quot;).toLowerCase(); &#125; else &#123; // 判断数据是基本数据类型的情况和函数的情况 return typeof value &#125;&#125; 小程序和公众号用什么来区分同一个用户在微信生态中，小程序和公众号可以通过微信的 openid 和 unionid 来区分同一个用户。 openid 是同一个应用（App、公众号、小程序）的同一个用户的唯一标识。即，一个用户在一个小程序或公众号中有唯一的 openid ，但在不同的小程序或公众号中， openid 可能不同。 unionid 是一个用户对于同主体微信小程序、公众号、APP的标识，开发者需要在微信开放平台下绑定相同账号的主体。 unionid 在正常情况下是用户身份的唯一标识，但在业务涉及不同主体时，不一定唯一。 渲染函数和jsx介绍和区别在 Vue 中，渲染函数和 JSX 都是用于构建 Vue 组件的工具。它们提供了一种编写组件的不同方式，通常用于编写更复杂、更灵活的组件。渲染函数是用 JavaScript 编写的函数，它接收一个上下文对象作为参数，然后返回一个 Vue VNode 节点。VNode 节点表示了组件的结构，包括 HTML 标记、属性、事件、样式等等。通过递归地构建 VNode 树，Vue 渲染函数可以生成最终的 DOM 树，并将其插入到文档中。渲染函数可以用于构建任何类型的组件，包括功能组件和状态组件。它通常用于编写高级别的抽象组件，例如基于数据结构的树形控件、动态表单生成器等等。渲染函数的语法相对于 JSX 较为灵活，但同时也更加复杂。 JSX 是一种在 JavaScript 中编写 HTML 标记的语法。它是 React 中广泛使用的语法，但也可以与 Vue 一起使用。JSX 允许开发者使用类似 HTML 的语法来编写组件，然后使用 Babel 等工具将其转换为常规的 JavaScript 代码。在 Vue 中使用 JSX 需要安装相应的插件，并进行配置。JSX 的语法更加简洁直观，因此更容易上手。它的表达能力也非常强，可以轻松地实现组件的复杂嵌套和逻辑控制。同时，由于 JSX 本质上是一种 JavaScript 语法扩展，因此也可以使用 JavaScript 的语言特性，例如变量、条件语句、循环等等。 总的来说，渲染函数和 JSX 在 Vue 中都有其独特的用途和优势。选择使用哪种方式取决于具体的需求和场景。 最近两年有什么前端新技术近两年前端领域出现了许多新技术，其中一些比较重要的包括： HTML6：构建交互优良用户界面的基础技术。 TypeScript：一种由微软开发的编程语言，具有静态类型检查功能，可以提高代码的可读性和可维护性。 WebAssembly：一种新的二进制格式，用于在浏览器中运行高性能的代码，如视频编解码、图形渲染等。 渐进式 WEB 应用（PWA）：一种可以提高网站性能和用户体验的技术，允许网站在离线状态下继续运行，并提供类似于原生应用程序的功能。 微前端：一种软件架构，可以将前端应用拆解成一些更小的、能够独立开发部署的微型应用，然后再将这些微应用进行组合，使其成为整体应用的架构模式。 这些技术都在不同程度上推动了前端开发的发展，为用户提供了更好的体验。 翻书效果css使用哪个方法你可以使用 CSS 的 rotateY 方法来实现翻书效果。该方法可以定义沿 Y 轴的 3D 旋转，从而实现翻书的效果。以下是一个示例代码： 1234567891011121314.book &#123; perspective: 800px; transform-style: preserve-3d; animation: flip 10s linear infinite;&#125;@keyframes flip &#123; 0% &#123; transform: rotateY(0deg); &#125; 100% &#123; transform: rotateY(180deg); &#125;&#125; 在上述代码中，首先使用 perspective 属性设置视距，让元素具有 3D 效果，值越大，元素距离屏幕越远，视觉效果上就显得更小，这里设置为 800px 。然后使用 transform-style:preserve-3d; 开启 3D 空间。最后，使用 rotateY 方法结合 animation 属性来实现翻书效果， rotateY(0deg) 表示初始状态下页面是闭合的， rotateY(180deg) 表示页面完全翻开的状态， 10s 是翻书效果的时长， linear 是动画效果的速度曲线， infinite 是指动画效果无限循环。 实际应用中，你可以根据需要对代码进行调整，例如修改翻书效果的速度、方向和时长等。 script标签的哪个属性可以实现html解析完成执行在 标签中， defer 属性可以实现 HTML 解析完成后执行脚本。 defer 属性的作用是延迟脚本的执行，直到页面完全加载（包括 HTML、CSS 和其他资源）完成后再执行。 使用 defer 属性的优点包括： 提高页面加载速度：避免阻塞页面的其他内容加载。 确保脚本在 HTML 解析完成后执行：可以访问已解析的 DOM。 示例如下： 1&lt;script defer src=&quot;script.js&quot;&gt;&lt;/script&gt; 在上述示例中，指定了 defer 属性，该脚本将在页面加载完成后执行。 需要注意的是， defer 属性只适用于外部脚本文件。如果脚本代码直接嵌入在 标签内部，则无法使用 defer 属性。 js最准确的判断数组方法在 JavaScript 中，有多种方法可以判断一个变量是否为数组，以下是几种常用的方法： instanceof 运算符：该方法通过检查变量的原型链中是否存在 Array 构造函数来判断一个变量是否为数组。如果存在，则返回 true，否则返回 false。但是，这种方法的准确性可能会受到原型链修改的影响。 Array.isArray()方法：这是 ECMAScript 5 引入的方法，用于判断一个值是否为数组。它的使用非常简单，直接调用该方法并传入待判断的值即可。如果返回值为 true，则表示该值是一个数组；如果返回值为 false，则表示该值不是数组。 Object.prototype.toString.call()方法：该方法会返回一个表示对象类型的字符串，对于数组来说，返回的字符串应该是\"(object Array)\"。这种方法可以准确地判断数组的类型，但代码相对复杂。 总的来说，以上方法都可以用于判断一个变量是否为数组，具体选择哪种方法，取决于你的需求和代码结构。 1234for (let i = 0; i &lt; 3; i++) &#123;setTimeout(() =&gt; &#123;console.log(i);&#125;, 1000); }这段JavaScript代码的功能是，每隔一秒（1000毫秒）在控制台打印变量i的值，一共打印三次。但是，你可能不会得到预期的连续打印0、1、2的结果，而是三次都打印3。 这是因为setTimeout函数是一个异步操作，它并不会立即执行，而是会等待指定的延迟时间后再执行。而在这段代码中，循环会先完成三次迭代，然后再依次执行setTimeout中的回调函数。由于let声明的变量i在循环外仍然是可访问的，所以每次执行回调函数时，它都会访问到当前的i值，即3。 如果你想让每次打印的都是循环时的i值，你需要使用闭包来捕获每次循环时的i值。你可以通过立即执行的函数表达式（IIFE）或者Array.prototype.forEach来实现这一点。 下面是使用IIFE的修改后的代码： 1234567for (let i = 0; i &lt; 3; i++) &#123; (function(i) &#123; setTimeout(() =&gt; &#123; console.log(i); &#125;, 1000); &#125;)(i);&#125; 在这个修改后的代码中，每次循环都会创建一个新的函数作用域，并将当前的i值作为参数传递给这个作用域。这样，在setTimeout的回调函数中，我们就可以访问到这个被捕获的i值，而不是循环结束后的i值。 同样的，你也可以使用Array.prototype.forEach来实现相同的效果： 12345[0, 1, 2].forEach((i) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(i); &#125;, 1000);&#125;); 在这个例子中，我们创建了一个包含三个元素的数组，并使用forEach方法遍历这个数组。每次遍历都会将当前的元素值（即i）作为参数传递给回调函数，这样我们就可以在回调函数中直接访问到这个值，而无需担心循环结束后的变量值变化。 css选择器和优先级CSS选择器是用于选择你想要样式化的HTML元素的模式。这些选择器可以是元素选择器、类选择器、ID选择器、属性选择器、伪类选择器等。每种选择器都有其特定的用途和优先级。 CSS选择器种类： 元素选择器：基于HTML元素名称来选择元素，如 p、div 等。类选择器：使用 . 开头的类名来选择元素，如 .myClass。ID选择器：使用 # 开头的ID来选择元素，如 #myID。属性选择器：基于元素的属性和属性值来选择元素，如 [type=\"text\"]。伪类选择器：用于选择HTML元素的特定状态，如 :hover、:active、:first-child 等。 CSS选择器优先级： 当多个选择器应用于同一个元素时，CSS有一套规则来确定哪个样式应该被应用。这就是所谓的“特异性”（specificity）或“优先级”。以下是确定优先级的一般规则： 内联样式：在HTML元素内部使用style属性定义的样式具有最高的优先级。ID选择器：具有比类选择器、属性选择器和伪类选择器更高的优先级。类选择器、属性选择器和伪类选择器：它们的优先级相同，并低于ID选择器，但高于元素选择器。元素选择器：具有最低的优先级。!important规则：如果样式声明后面带有!important，那么该声明将具有最高的优先级，无论其特异性如何。继承：如果元素没有指定的样式，那么它会从其父元素继承样式。继承的样式具有最低的优先级。 如果两个选择器具有相同的特异性，那么后出现的规则会覆盖先出现的规则（这被称为“源顺序”或“后者优先”规则）。 为了编写高效且易于维护的CSS代码，建议尽量避免使用!important，并尽量保持选择器的特异性尽可能低。同时，合理地组织CSS规则，使它们易于理解和修改。 0.1+0.2为什么不等于0.3在js中在 JavaScript 中，0.1 + 0.2 不等于 0.3 的原因在于浮点数在计算机中的表示和计算。这是由于计算机内部使用二进制表示法来存储浮点数，而很多十进制小数无法精确地用二进制小数来表示。 当你尝试将 0.1 和 0.2 相加时，这两个数在计算机内部实际上是以一种近似值的形式存在的。这种近似值是由一系列二进制位表示的，可能并不完全等同于十进制数中的 0.1 或 0.2。因此，当你将它们相加时，得到的结果可能是一个稍微偏离 0.3 的值。 这种问题不仅限于 JavaScript，它是浮点数运算中普遍存在的。如果你需要精确的小数运算，可能需要使用特殊的库或方法来处理。但在大多数日常编程任务中，这种微小的精度损失是可以接受的。 为了查看实际的计算结果，你可以尝试在 JavaScript 控制台中运行以下代码： 1console.log(0.1 + 0.2); 你可能会看到类似 0.30000000000000004 这样的输出，这证明了计算结果并不完全等于 0.3。 如果你需要处理金融计算或其他需要高精度小数运算的场景，建议使用专门的库，如 decimal.js 或 big.js，这些库提供了更高精度的浮点数运算支持。 设置过期时间的localstory实现你的问题可能是关于如何在JavaScript中实现一个具有过期时间的localStorage。在标准的localStorage API中，并没有直接提供设置过期时间的功能。但是，我们可以通过一些额外的逻辑来实现这一功能。 以下是一个简单的示例，演示了如何在localStorage中存储一个键值对，并为该键值对设置一个过期时间： class ExpiringLocalStorage { constructor() { this.prefix = &apos;expiring_&apos;; } set(key, value, ttl) { const now = new Date().getTime(); const expiry = now + ttl; const data = { value: value, expiry: expiry }; localStorage.setItem(this.prefix + key, JSON.stringify(data)); } get(key) { const item = localStorage.getItem(this.prefix + key); if (!item) { return null; } const data = JSON.parse(item); const now = new Date().getTime(); if (now &gt; data.expiry) { // 如果数据已过期，则删除并从localStorage中返回null this.remove(key); return null; } return data.value; } remove(key) { localStorage.removeItem(this.prefix + key); } } // 使用示例： const expiringStorage = new ExpiringLocalStorage(); expiringStorage.set(&apos;myKey&apos;, &apos;myValue&apos;, 1000 * 60 * 60); // 设置一个键为&apos;myKey&apos;，值为&apos;myValue&apos;，过期时间为1小时 console.log(expiringStorage.get(&apos;myKey&apos;)); // 在过期前，应返回&apos;myValue&apos;在这个示例中，我们创建了一个名为ExpiringLocalStorage的类，它封装了localStorage的基本功能，并添加了过期时间的概念。当调用set方法时，除了存储键值对外，还会存储一个过期时间（以毫秒为单位）。当调用get方法时，会检查数据是否已过期。如果已过期，则会从localStorage中删除该数据并返回null。如果未过期，则返回数据的值。 请注意，这个实现并不会自动删除过期的数据。你需要通过调用get方法来检查并删除过期的数据。如果你需要定期清理过期的数据，你可能需要设置一个定时器或使用其他方法来定期调用清理逻辑。 此外，由于localStorage的大小有限，并且所有的浏览器都可能有不同的限制，因此在使用localStorage时需要注意不要存储过多的数据。 分别解释请求头参数，host，cookie，method，accept，content-length当然可以，以下是这些请求头参数的解释： Host： Host 请求头字段用于指定请求所发送的目标域名的地址。在HTTP/1.1中，每个请求都应包含一个Host头，因为网络地址（如IP地址）可能对应多个域名。示例：Host: www.example.com Cookie： Cookie 请求头字段用于发送之前由服务器通过Set-Cookie头发送到浏览器的cookie。当浏览器发送请求到服务器时，它会包含所有相关的cookie，以便服务器能够识别用户会话和其他状态信息。示例：Cookie: session_id=12345; user_id=john Method： Method 或 HTTP-Method 指的是HTTP请求的类型或动作。它告诉服务器你想要对请求的资源执行什么操作。常见的HTTP方法包括GET（获取资源）、POST（提交数据）、PUT（更新资源）、DELETE（删除资源）等。注意：虽然Method不是请求头的一部分，但它是HTTP请求的一个重要组成部分，通常与请求头一起发送。 Accept： Accept 请求头字段用于告诉服务器客户端可以处理哪些类型的响应内容。这通常用于指定客户端可以理解的媒体类型，如text/html、application/json等。示例：Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,/;q=0.8 Content-Length： Content-Length 请求头字段表示请求体的长度（以字节为单位）。这对于那些包含请求体的请求方法（如POST和PUT）来说是非常重要的，因为它允许服务器知道要读取多少数据。示例：Content-Length: 15 这些请求头字段在HTTP通信中起着关键作用，帮助客户端和服务器之间进行交互并理解彼此的请求和响应。不同的字段提供了关于请求的各种信息，使服务器能够更准确地响应客户端的需求。 js数组里的数组，展开为一维数组去重升序好的，了解你的需求啦！你想把一个包含数组的数组（二维数组）展开成一维数组，并且进行去重和升序排序，对吧？这个任务可以用JavaScript的几种方法来实现呢~ 首先，我们可以使用Array.prototype.flat()方法将二维数组展开成一维数组，然后用Set数据结构进行去重，最后使用Array.prototype.sort()方法进行升序排序。下面是一个示例代码： 123456789101112let nestedArray = [[1, 2, 3], [3, 4, 5], [5, 6, 1]];// 使用 flat 方法将二维数组展开成一维数组let flattenedArray = nestedArray.flat();// 使用 Set 数据结构进行去重let uniqueArray = [...new Set(flattenedArray)];// 使用 sort 方法进行升序排序let sortedArray = uniqueArray.sort((a, b) =&gt; a - b);console.log(sortedArray); // 输出: [1, 2, 3, 4, 5, 6] 上面的代码首先使用flat()方法将二维数组nestedArray展开成一维数组flattenedArray。然后，我们利用Set的特性，将数组转换为Set，自动去除了重复的元素，再通过展开运算符...将Set转回数组uniqueArray。最后，我们使用sort()方法，通过传入一个比较函数，将数组uniqueArray进行升序排序，得到最终的排序数组sortedArray。 这个方法是不是很方便呢？希望对你有帮助哦~ (｡♥‿♥｡) cavas怎么局部渲染在Canvas中，局部渲染通常指的是只更新或重绘Canvas的某一部分，而不是整个画布。这可以提高性能，尤其是在处理大型或复杂的Canvas应用时。以下是几种实现局部渲染的常见方法： 使用clearRect清除特定区域： 在重绘之前，你可以使用clearRect方法来清除Canvas上的特定区域。然后，只在该区域内进行绘制。 12345const canvas = document.getElementById(&apos;myCanvas&apos;);const ctx = canvas.getContext(&apos;2d&apos;);// 清除特定区域ctx.clear 什么是js闭包和原型链JS闭包 在JavaScript中，闭包是一个强大的概念，它指的是一个有权访问另一个函数作用域中的变量的函数。换句话说，一个函数内部定义的函数（称为内嵌函数）可以访问其父级函数的变量，甚至在父级函数执行完毕后，这些变量依然可以被内嵌函数访问。这就是因为闭包可以维持一个到其外部作用域的引用。 例如： 123456789101112function outerFunction() &#123; var outerVariable = 'I am from outer function!'; function innerFunction() &#123; console.log(outerVariable); &#125; return innerFunction; &#125; var inner = outerFunction(); inner(); // 输出：I am from outer function! 在这个例子中，innerFunction 是一个闭包，因为它可以访问 outerFunction 的作用域中的 outerVariable。 原型链 原型链是JavaScript中对象继承的主要方式。每个JavaScript对象都有一个内部链接到另一个对象。这个链接被称为该对象的原型。当试图访问一个对象的属性时，如果该对象自身没有这个属性，那么JavaScript就会在该对象的原型上寻找这个属性，以此类推，一直通过原型链向上查找，直到找到属性或者到达原型链的末尾（null）。 每个构造函数都有一个 prototype 属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。当我们试图访问一个对象的某个属性时，JavaScript引擎首先会在对象本身的属性中查找，如果没有找到，就会到它的原型（也就是构造函数的 prototype 属性所指向的那个对象）中查找，如果再没有找到，就会到原型的原型中查找，依此类推，一直查到 Object.prototype 对象。如果还没有找到，就会返回 undefined。这种通过原型链接起来的链式结构，就叫做原型链。 例如： 12345678910function Person(name) &#123; this.name = name; &#125; Person.prototype.sayHello = function() &#123; console.log('Hello, my name is ' + this.name); &#125; var person1 = new Person('Alice'); person1.sayHello(); // 输出：Hello, my name is Alice 在这个例子中，person1 是一个 Person 的实例，它继承了 Person.prototype 上的 sayHello 方法。当我们调用 person1.sayHello() 时，实际上是通过原型链找到了 Person.prototype 上的 sayHello 方法。 vue2升级vue3具体怎么做Vue2升级到Vue3是一个涉及多个步骤的过程，下面是一个详细的步骤说明： 创建一个新的Vue3项目：使用Vue CLI工具创建一个新的Vue3项目。可以通过在命令行中运行vue create projectName命令并按照提示进行操作来完成这一步。 安装依赖：在新创建的Vue3项目中，需要安装必要的依赖。首先，将原Vue2项目中的package.json文件下的dependencies节点中的vue、element-ui、vuex等内容删除，并将这些依赖项追加到新项目的package.json中。然后，安装element-plus和pinia这两个Vue3的对应库，可以通过npm install element-plus pinia或yarn add element-plus pinia命令进行安装。最后，继续安装剩余的其他依赖项，通过执行npm install或yarn install命令完成。 整理代码：将原Vue2项目的src目录中的代码拷贝到新创建的Vue3项目中，但注意不要直接复制main.js文件。然后，根据代码的具体情况修改main.js文件。这一步可能涉及到对Vue2和Vue3之间API差异的处理。 重写组件逻辑：Vue 3引入了Composition API作为官方提供的组合式API，取代了Vue 2中的Options API。因此，在升级过程中，需要重写现有的组件逻辑，改为基于Composition API编写。这涉及到对组件内部状态、生命周期钩子、方法等的重新组织和实现。 修改生命周期钩子：Vue 3对生命周期钩子进行了调整，一些在Vue 2中存在的钩子（如beforeCreate、created等）被删除或替换。同时，Vue 3引入了新的生命周期钩子，如setup()函数作为新的入口点，以及onBeforeMount、onMounted等。因此，在升级过程中，需要根据Vue 3的文档说明修改相应的生命周期钩子名称和用法。 处理其他差异：在升级过程中，还需要注意Vue 2和Vue 3之间可能存在的其他差异，如指令的注册方式、全局API的变化等。这些差异可能需要根据具体的项目代码和Vue 3的文档进行逐一处理。 测试与调试：完成上述步骤后，需要对升级后的Vue3项目进行测试和调试，确保所有功能都正常工作，没有出现错误或异常。这可能涉及到对项目的各个部分进行详细的检查和验证。 请注意，Vue2升级到Vue3是一个复杂的过程，可能涉及到大量的代码修改和重构。在进行升级之前，建议详细阅读Vue 3的官方文档，了解Vue 3的新特性和与Vue 2的差异，以便更好地进行升级工作。同时，也建议备份好原Vue2项目的代码，以防万一出现不可预期的问题。 ES6 中的一些新特性ES6 即 ECMAScript 2015，是 JavaScript 的新一代标准。 块级作用域：使用 let 和 const 关键字声明块级作用域的变量和常量，避免变量污染和重复定义。 箭头函数：可以更简洁地定义函数，并且它的 this 值绑定在定义时的环境中，而不是执行时的环境。 模板字符串：可以方便地拼接字符串和变量，避免了繁琐的字符串拼接和转义。 解构赋值：可以方便地提取对象和数组中的值并赋值给变量，使得代码更加简洁易懂。 Rest 参数：将函数参数作为数组来处理，避免了需要使用 arguments 对象的情况。 Spread 操作符：可以将数组或对象展开成独立的元素，方便地进行数组合并、对象合并等操作。 Class 类：更方便地定义对象和继承，使得面向对象编程更加规范和易懂。 Promise 异步编程：可以更好地处理异步操作，避免了回调地狱的问题。 Promise.all 方法：可以同时执行多个 Promise 对象，并在所有 Promise 对象都执行完毕后返回结果。 模块化：引入了模块化的概念，可以更好地组织和管理代码，避免了全局变量的污染。 如你想了解更多关于 ES6 的新特性，可点击web前端tips:ES6部分常用新特性介绍查看。 setter怎么通知它的订阅者在Vue中，setter可以通过 dep.notify() 方法来通知它的订阅者。其具体流程如下： 创建一个 Observer 对象作为数据监听器，用来监听所有属性的变化。 使用 Object.defineProperty() 方法，递归遍历所有属性，为每个属性添加 setter 和 getter 。 当给对象的某个属性赋值时，会触发 setter ，从而监听到数据的变化。 setter 触发 Dep 的 notify 方法，该方法会调用所有订阅者的 update 方法，以通知它们数据的变化。 通过这种方式，setter可以及时通知它的订阅者，从而实现数据的双向绑定和动态更新。 有一个20g的tar包，需要前端上传，如何做技术架构对于20GB的tar包，前端上传确实需要一些特殊的技术架构来处理大文件上传的问题。以下是一个建议的技术架构： 前端处理文件分片：将20GB的tar包切分成多个较小的文件分片。每个分片的大小可以根据网络条件和服务器配置来决定，通常可以选择几MB到几十MB不等。 分片上传：使用JavaScript中的File API和FormData对象，逐个上传这些分片。可以使用如axios或fetch等HTTP客户端库来发送分片上传的请求。 进度追踪与展示：通过监听每个分片的上传进度事件，实时更新并展示上传进度给用户，以便他们了解上传的进度和剩余时间。 断点续传：如果上传过程中发生网络中断或其他错误，前端需要能够记录已经上传的分片信息，并在恢复上传时跳过这些已上传的分片，从断点处继续上传。 错误处理与重试机制：对于上传失败的分片，前端应该实现重试机制，尝试重新上传失败的分片，直到成功为止。 后端处理接收分片：后端需要提供一个API接口，用于接收前端发送的文件分片。可以使用Node.js、Java、Python等后端技术栈来实现。 分片存储：后端接收到分片后，需要将其存储到临时目录中，以便后续合并成完整的tar包。可以使用文件系统、云存储服务（如Amazon S3、阿里云OSS等）或其他存储解决方案来存储分片。 合并分片：当所有分片都上传完成后，后端需要将这些分片合并成一个完整的tar包。可以使用文件操作API或相关库来完成分片的合并。 文件完整性校验：后端在合并完成后，应该计算整个tar包的哈希值，并与前端提供的哈希值进行比对，以确保文件的完整性。 删除临时分片：合并完成后，后端需要删除存储的临时分片，以释放存储空间。 其他考虑安全性：确保上传过程的安全性，例如使用HTTPS进行通信，验证用户身份，防止恶意文件上传等。 上传速度优化：根据网络条件和服务器性能，可以考虑使用多线程上传、并行上传等技术来加快上传速度。 用户体验：优化前端界面和交互，提供友好的上传体验，如拖拽上传、批量上传等功能。 综上所述，处理20GB的tar包上传需要前端和后端的紧密配合，通过文件分片、断点续传、错误处理等技术手段来确保上传的可靠性和效率。同时，还需要考虑安全性和用户体验等方面的问题。 js设计模式在 JavaScript 中，设计模式是解决软件开发某些特定问题而提出的一些解决方案，也可以理解成解决问题的一些思路。通过设计模式可以帮助开发者增强代码的可重用性、可扩充性、可维护性、灵活性。以下是几种常见的 JavaScript 设计模式： 单例模式：单例模式是一种只允许实例化一次的对象创建模式。它保证一个类只有一个实例，并且提供一个访问该实例的全局点。在 JavaScript 中，可以通过闭包来实现单例模式。 原型模式：原型模式是基于原型继承的。在这种模式中，被创建的对象充当其他对象的原型。实际上，原型（prototype）是被创建的每个对象构造函数的蓝图。 模块设计模式：模块设计模式对原型模式做了一些改进。模块模式设置了不同类型的修饰符（私有和公共）。你可以创建相似的函数或属性而不会发生冲突。这个设计模式的一个缺陷是无法覆盖（override）外部环境中创建的函数。 构造函数设计模式：这是一种特殊的方法，用于在分配内存后初始化新创建的对象。由于 JavaScript 一般来说是面向对象的，所以它打交道最多的就是对象。于是深入研究对象构造函数。在 JavaScript 中创建新对象有三种方法可用。 如果你还想了解更多关于 JavaScript 设计模式的内容，请继续向我提问。 vue2迁移vue3，具体怎么处理将 Vue 2 项目迁移到 Vue 3 可以按照以下步骤进行处理： 升级 Vue 版本：在项目中安装 Vue 3。 组件重构：根据 Vue 3 的语法和特性，重构组件。 使用 Composition API：利用 Composition API 来管理状态和逻辑。 模板语法调整：适应 Vue 3 的模板语法变化。 处理生命周期钩子：了解 Vue 3 中生命周期钩子的改动。 适配插件和依赖：确保使用的插件和依赖与 Vue 3 兼容。 测试和调试：进行全面的测试以确保项目的正常运行。 在迁移过程中，可能会遇到一些问题，需要仔细检查和调试。同时，参考 Vue 3 的官方文档和相关教程可以帮助你更好地完成迁移。 前端工程师在项目中遇到什么难题，你是怎么解决它？前端工程师在项目中可能会遇到以下一些难题： 浏览器兼容性问题：不同浏览器对 HTML、CSS 和 JavaScript 的实现可能存在差异。解决方法：进行广泛的浏览器测试，使用特定的兼容解决方案。 性能优化：确保页面加载速度快，用户体验良好。解决方法：压缩资源、优化代码、使用缓存等。 复杂的用户界面设计：创建具有复杂交互和视觉效果的界面。解决方法：选择合适的前端框架和工具，进行合理的架构设计。 与后端集成：确保前端与后端之间的数据传输和通信顺畅。解决方法：使用合适的 API 设计和通信协议。 移动端适配：使页面在各种移动设备上良好显示。解决方法：采用响应式设计或特定的移动端解决方案。 安全和权限问题：保护用户数据和系统安全。解决方法：实施安全策略，进行漏洞测试。 团队协作和代码管理：与其他开发者协同工作。解决方法：使用版本控制系统，进行有效的沟通和协作。 不断变化的技术和需求：跟上行业的发展和用户需求的变化。解决方法：持续学习，灵活调整项目架构。 解决这些难题通常需要以下步骤： 分析问题：确定问题的本质和范围。 研究和学习：查找相关的知识和解决方案。 尝试不同方法：进行实验和测试。 与团队成员沟通：分享想法和经验。 优化和改进：不断完善解决方案。 记录和总结：以便在未来的项目中参考。 程序题let str='aabcd'计算每个字母出现的次数将重复字母移出字符串 在 JavaScript 中，可以通过遍历字符串来计算每个字母出现的次数，并使用数组来存储每个字母及其出现的次数。然后遍历数组，将重复的字母从字符串中移除。以下是示例代码： 12345678910111213141516let str = &apos;aabcd&apos;;let charCount = &#123;&#125;;for (let i = 0; i &lt; str.length; i++) &#123; if (charCount[str[i]]) &#123; charCount[str[i]]++; &#125; else &#123; charCount[str[i]] = 1; &#125;&#125;let newStr = &apos;&apos;;for (let key in charCount) &#123; if (charCount[key] === 1) &#123; newStr += key; &#125;&#125;console.log(newStr); 在上述代码中，首先定义了字符串str，然后遍历字符串，通过charCount对象来记录每个字母及其出现的次数。接着创建一个新的字符串newStr，遍历charCount对象，将出现次数为 1 的字母添加到newStr中。最后打印输出处理后的字符串。","categories":[{"name":"前端面试题","slug":"前端面试题","permalink":"https://qw8.github.io/categories/前端面试题/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qw8.github.io/tags/JavaScript/"},{"name":"BOM","slug":"BOM","permalink":"https://qw8.github.io/tags/BOM/"},{"name":"DOM","slug":"DOM","permalink":"https://qw8.github.io/tags/DOM/"},{"name":"事件循环","slug":"事件循环","permalink":"https://qw8.github.io/tags/事件循环/"}]},{"title":"vue3","slug":"interview/vue3","date":"2024-03-10T13:02:08.000Z","updated":"2024-03-28T18:11:02.000Z","comments":true,"path":"/interview/vue3.html","link":"","permalink":"https://qw8.github.io/interview/vue3.html","excerpt":"","text":"vue3的新特性1、响应系统的变动由原来的Object.defineProperty 的getter和setter，改变成为了ES2015 Proxy 作为其观察机制。 Proxy的优势：消除了以前存在的警告，使速度加倍，并节省了一半的内存开销。 2、虚拟DOM重写（Virtual DOM Rewrite）虚拟 DOM 从头开始重写，我们可以期待更多的编译时提示来减少运行时开销。重写将包括更有效的代码来创建虚拟节点。 3、组件渲染的优化（优化插槽生成）Vue2当中在父组件渲染同时，子组件也会渲染。 Vue3就可以单独渲染父组件、子组件。 4、静态树提升（Static Tree Hoisting）使用静态树提升，这意味着 Vue3 的编译器将能够检测到什么是静态组件，然后将其提升，从而降低了渲染成本。它将能够跳过未整个树结构打补丁的过程。 5、静态属性提升（Static Props Hoisting）此外，我们可以期待静态属性提升，其中 Vue3将跳过不会改变节点的打补丁过程。 总体来说：1. 更快 2. 更小 3. 更容易维护 4. 更加友好 5. 更容易使用 vue3对比vue2有哪些不同？答： https://www.cnblogs.com/ygunoil/p/14463855.html Proxy 相比于 defineProperty 的优势Object.defineProperty() 的问题主要有三个： 不能监听数组的变化 必须深层遍历嵌套的对象 必须遍历对象的每个属性 Proxy 在 ES2015 规范中被正式加入，它有以下几个特点： 针对对象：针对整个对象，而不是对象的某个属性，所以也就不需要对 keys 进行遍历。这解决了上述 Object.defineProperty() 第二个问题 支持数组：Proxy 不需要对数组的方法进行重载，省去了众多 hack，减少代码量等于减少了维护成本，而且标准的就是最好的。 除了上述两点之外，Proxy 还拥有以下优势： Proxy 的第二个参数可以有 13 种拦截方法，这比起 Object.defineProperty() 要更加丰富 Proxy 作为新标准受到浏览器厂商的重点关注和性能优化，相比之下 Object.defineProperty() 是一个已有的老方法。 vue2为什么不使用proxy？ 答： 兼容性 vue3性能比vue2好的原因？1.diff算法优化 2.静态提升hoistStatic 3.事件侦听器缓存cacheHandles https://www.cnblogs.com/ygunoil/p/14463687.html Vue3.0 里为什么要用 Proxy API 替代 defineProperty API？响应式优化（高频，重点！！！） 这是在面试中问的最多的一个问题，无论是大厂还是中小型公司，都喜欢问，也是Vue更新的重点。 1.defineProperty API 的局限性最大原因是它只能针对单例属性做监听。 Vue2.x中的响应式实现正是基于defineProperty中的descriptor，对 data 中的属性做了遍历 + 递归，为每个属性设置了 getter、setter。这也就是为什么 Vue 只能对 data 中预定义过的属性做出响应的原因，在Vue中使用下标的方式直接修改属性的值或者添加一个预先不存在的对象属性是无法做到setter监听的，这是defineProperty的局限性。 2.Proxy API的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作， 这就完全可以代理所有属性，将会带来很大的性能提升和更优的代码。 Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。 3.响应式是惰性的 在 Vue.js 2.x 中，对于一个深层属性嵌套的对象，要劫持它内部深层次的变化，就需要递归遍历这个对象，执行 Object.defineProperty 把每一层对象数据都变成响应式的，这无疑会有很大的性能消耗。在 Vue.js 3.0 中，使用 Proxy API 并不能监听到对象内部深层次的属性变化，因此它的处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部属性才会变成响应式，简单的可以说是按需实现响应式，减少性能消耗。基础用法： img Vue3.0 编译做了哪些优化？（底层，源码）生成 Block treeVue.js 2.x 的数据更新并触发重新渲染的粒度是组件级的，单个组件内部 需要遍历该组件的整个 vnode 树。在2.0里，渲染效率的快慢与组件大小成正相关：组件越大，渲染效率越慢。**并且，对于一些静态节点，又无数据更新，这些遍历都是性能浪费。Vue.js 3.0 做到了通过编译阶段对静态模板的分析，编译生成了 Block tree。 Block tree是一个将模版基于动态节点指令切割的嵌套区块，每个 区块内部的节点结构是固定的，每个区块只需要追踪自身包含的动态节点。所以，在3.0里，渲染效率不再与模板大小成正相关，而是与模板中动态节点的数量成正相关。 img slot 编译优化Vue.js 2.x 中，如果有一个组件传入了slot，那么每次父组件更新的时候，会强制使子组件update，造成性能的浪费。Vue.js 3.0 优化了slot的生成，使得非动态slot中属性的更新只会触发子组件的更新。动态slot指的是在slot上面使用v-if，v-for，动态slot名字等会导致slot产生运行时动态变化但是又无法被子组件track的操作。**c. diff算法优化**（此知识点进大厂可能会问到，由于篇幅较长，大家可以去官网看下） Vue3.0新特性 —— Composition API 与 React.js 中 Hooks的异同点（难点问题）React.js 中的 Hooks 基本使用React Hooks 允许你 “勾入” 诸如组件状态和副作用处理等 React 功能中。Hooks 只能用在函数组件中，并允许我们在不需要创建类的情况下将状态、副作用处理和更多东西带入组件中。React 核心团队奉上的采纳策略是不反对类组件，所以你可以升级 React 版本、在新组件中开始尝试 Hooks，并保持既有组件不做任何更改。案例： img useState 和 useEffect 是 React Hooks 中的一些例子，使得函数组件中也能增加状态和运行副作用。我们也可以自定义一个Hooks，它打开了代码复用性和扩展性的新大门。 Vue Composition API 基本使用Vue Composition API 围绕一个新的组件选项 setup 而创建。setup() 为 Vue 组件提供了状态、计算值、watcher 和生命周期钩子。并没有让原来的 API（Options-based API）消失。允许开发者 结合使用新旧两种 API（向下兼容）。 img 原理React hook 底层是基于链表实现，调用的条件是每次组件被render的时候都会顺序执行所有的hooks。vue hook 只会被注册调用一次，vue 能避开这些麻烦的问题，原因在于它对数据的响应是基于proxy的，对数据直接代理观察。（这种场景下，只要任何一个更改data的地方，相关的function或者template都会被重新计算，因此避开了react可能遇到的性能上的问题）。react 中，数据更改的时候，会导致重新render，重新render又会重新把hooks重新注册一次，所以react复杂程度会高一些。 Vue3.0是如何变得更快的？（底层，源码）diff方法优化Vue2.x 中的虚拟dom是进行全量的对比。Vue3.0 中新增了静态标记（PatchFlag）：在与上次虚拟结点进行对比的时候，值对比带有patch flag的节点，并且可以通过flag 的信息得知当前节点要对比的具体内容化。 hoistStatic 静态提升Vue2.x : 无论元素是否参与更新，每次都会重新创建。Vue3.0 : 对不参与更新的元素，只会被创建一次，之后会在每次渲染时候被不停的复用。 cacheHandlers 事件侦听器缓存默认情况下onClick会被视为动态绑定，所以每次都会去追踪它的变化但是因为是同一个函数，所以没有追踪变化，直接缓存起来复用即可。说在后面 其实很多小伙伴都存在这样一种情况：Vue2.x都用了一年多了，官方文档都还没有去详细过一遍，遇到问题就百度，所以Vue3.0一出就惊慌失措。 所以我建议正确的学习姿势应该是： 当我们去接触一门新技术的时候，首要任务就是看官方文档，先大致过一遍，知道有哪些东西。开发的时候遇到问题再去针对具体的知识点细看。遇到实在搞不定的，官方文档看不懂的，再行百度也不迟。 Vue 3.0 性能提升主要是通过哪几方面体现的？响应式系统提升vue2在初始化的时候，对data中的每个属性使用definepropery调用getter和setter使之变为响应式对象。如果属性值为对象，还会递归调用defineproperty使之变为响应式对象。vue3使用proxy对象重写响应式。proxy的性能本来比defineproperty好，proxy可以拦截属性的访问、赋值、删除等操作，不需要初始化的时候遍历所有属性，另外有多层属性嵌套的话，只有访问某个属性的时候，才会递归处理下一级的属性。优势：可以监听动态新增的属性；可以监听删除的属性 ；可以监听数组的索引和 length 属性； 编译优化优化编译和重写虚拟dom，让首次渲染和更新dom性能有更大的提升vue2 通过标记静态根节点,优化 diff 算法vue3 标记和提升所有静态根节点,diff 的时候只比较动态节点内容 Fragments, 模板里面不用创建唯一根节点,可以直接放同级标签和文本内容 静态提升 patch flag, 跳过静态节点,直接对比动态节点 缓存事件处理函数 源码体积的优化vue3移除了一些不常用的api，例如：inline-template、filter等使用tree-shaking Vue 3.0 所采用的 Composition Api 与 Vue 2.x使用的Options Api 有什么区别？Options Api包含一个描述组件选项（data、methods、props等）的对象 options；API开发复杂组件，同一个功能逻辑的代码被拆分到不同选项 ；使用mixin重用公用代码，也有问题：命名冲突，数据来源不清晰； composition Apivue3 新增的一组 api，它是基于函数的 api，可以更灵活的组织组件的逻辑。解决options api在大型项目中，options api不好拆分和重用的问题。 Proxy 相对于 Object.defineProperty 有哪些优点？proxy的性能本来比defineproperty好，proxy可以拦截属性的访问、赋值、删除等操作，不需要初始化的时候遍历所有属性，另外有多层属性嵌套的话，只有访问某个属性的时候，才会递归处理下一级的属性。 可以监听数组变化可以劫持整个对象操作时不是对原对象操作,是 new Proxy 返回的一个新对象可以劫持的操作有 13 种 Vue 3.0 在编译方面有哪些优化？vue.js 3.x中标记和提升所有的静态节点，diff的时候只需要对比动态节点内容；Fragments（升级vetur插件): template中不需要唯一根节点，可以直接放文本或者同级标签静态提升(hoistStatic),当使用 hoistStatic 时,所有静态的节点都被提升到 render 方法之外.只会在应用启动的时候被创建一次,之后使用只需要应用提取的静态节点，随着每次的渲染被不停的复用。patch flag, 在动态标签末尾加上相应的标记,只能带 patchFlag 的节点才被认为是动态的元素,会被追踪属性的修改,能快速的找到动态节点,而不用逐个逐层遍历，提高了虚拟dom diff的性能。缓存事件处理函数cacheHandler,避免每次触发都要重新生成全新的function去更新之前的函数tree shaking 通过摇树优化核心库体积,减少不必要的代码量 Vue.js 3.0 响应式系统的实现原理？reactive设置对象为响应式对象。接收一个参数，判断这参数是否是对象。不是对象则直接返回这个参数，不做响应式处理。创建拦截器handerler，设置get/set/deleteproperty。get收集依赖（track）；如果当前 key 的值是对象，则为当前 key 的对象创建拦截器 handler, 设置 get/set/deleteProperty；如果当前的 key 的值不是对象，则返回当前 key 的值。set设置的新值和老值不相等时，更新为新值，并触发更新（trigger）。deleteProperty当前对象有这个 key 的时候，删除这个 key 并触发更新（trigger）。 effect接收一个函数作为参数。作用是：访问响应式对象属性时去收集依赖 track接收两个参数：target 和 key－如果没有 activeEffect，则说明没有创建 effect 依赖－如果有 activeEffect，则去判断 WeakMap 集合中是否有 target 属性－WeakMap 集合中没有 target 属性，则 set(target, (depsMap = new Map()))－WeakMap 集合中有 target 属性，则判断 target 属性的 map 值的 depsMap 中是否有 key 属性－depsMap 中没有 key 属性，则 set(key, (dep = new Set()))－depsMap 中有 key 属性，则添加这个 activeEffect trigger判断 WeakMap 中是否有 target 属性，WeakMap 中有 target 属性，则判断 target 属性的 map 值中是否有 key 属性，有的话循环触发收集的 effect()。 昨晚做了一个梦，梦见自己到了一家大厂面试，面试官走近房间，坐了下来：是杨溜溜吧？国际惯例，先来个自我介绍吧。 于是我巴拉巴拉开始了长达两分钟的自我介绍，与此同时，面试官边听边看我的简历，边看边皱眉，结束后问：看你之前的项目经常用到vue，对Vue熟悉吗？ 我嘴角一笑，心里暗喜：幸好有专门看Vue的面试题，看来这次稳了。于是谦虚又装逼的回答：还行吧，您随便问。 于是面试官看我口气那么大，心想：哟嚯，来了一个装逼的，劳资今天就只问Vue。 来，先介绍一下Vue的响应式系统Vue为MVVM框架，当数据模型data变化时，页面视图会得到响应更新，其原理对data的getter/setter方法进行拦截（Object.defineProperty或者Proxy），利用发布订阅的设计模式，在getter方法中进行订阅，在setter方法中发布通知，让所有订阅者完成响应。 在响应式系统中，Vue会为数据模型data的每一个属性新建一个订阅中心作为发布者，而监听器watch、计算属性computed、视图渲染template/render三个角色同时作为订阅者，对于监听器watch，会直接订阅观察监听的属性，对于计算属性computed和视图渲染template/render，如果内部执行获取了data的某个属性，就会执行该属性的getter方法，然后自动完成对该属性的订阅，当属性被修改时，就会执行该属性的setter方法，从而完成该属性的发布通知，通知所有订阅者进行更新。 computed与watch的区别计算属性computed和监听器watch都可以观察属性的变化从而做出响应，不同的是： 计算属性computed更多是作为缓存功能的观察者，它可以将一个或者多个data的属性进行复杂的计算生成一个新的值，提供给渲染函数使用，当依赖的属性变化时，computed不会立即重新计算生成新的值，而是先标记为脏数据，当下次computed被获取时候，才会进行重新计算并返回。 而监听器watch并不具备缓存性，监听器watch提供一个监听函数，当监听的属性发生变化时，会立即执行该函数。 介绍一下Vue的生命周期beforeCreate：是new Vue()之后触发的第一个钩子，在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问。 created：在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发updated函数。可以做一些初始数据的获取，在当前阶段无法与Dom进行交互，如果非要想，可以通过vm.$nextTick来访问Dom。 beforeMount：发生在挂载之前，在这之前template模板已导入渲染函数编译。而当前阶段虚拟Dom已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发updated。 mounted：在挂载完成后发生，在当前阶段，真实的Dom挂载完毕，数据完成双向绑定，可以访问到Dom节点，使用$refs属性对Dom进行操作。 beforeUpdate：发生在更新之前，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。 updated：发生在更新完成之后，当前阶段组件Dom已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。 beforeDestroy：发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。 destroyed：发生在实例销毁之后，这个时候只剩下了dom空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。 为什么组件的data必须是一个函数一个组件可能在很多地方使用，也就是会创建很多个实例，如果data是一个对象的话，对象是引用类型，一个实例修改了data会影响到其他实例，所以data必须使用函数，为每一个实例创建一个属于自己的data，使其同一个组件的不同实例互不影响。 组件之间是怎么通信的父子组件通信父组件 -&gt; 子组件：prop 子组件 -&gt; 父组件：$on/$emit 获取组件实例：使用$parent/$children，$refs.xxx，获取到实例后直接获取属性数据或调用组件方法 兄弟组件通信Event Bus：每一个Vue实例都是一个Event Bus，都支持$on/$emit，可以为兄弟组件的实例之间new一个Vue实例，作为Event Bus进行通信。 Vuex：将状态和方法提取到Vuex，完成共享 跨级组件通信使用provide/inject Event Bus：同兄弟组件Event Bus通信 Vuex：将状态和方法提取到Vuex，完成共享 Vue事件绑定原理说一下每一个Vue实例都是一个Event Bus，当子组件被创建的时候，父组件将事件传递给子组件，子组件初始化的时候是有$on方法将事件注册到内部，在需要的时候使用$emit触发函数，而对于原生native事件，使用addEventListener绑定到真实的DOM元素上。 slot是什么？有什么作用？原理是什么？slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。 slot又分三类，默认插槽，具名插槽和作用域插槽。 默认插槽又名匿名插槽，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。 具名插槽带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。 作用域插槽默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在vm.$slot中，默认插槽为vm.$slot.default，具名插槽为vm.$slot.xxx，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用$slot中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。 Vue模板渲染的原理是什么？vue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的html语法，所有需要将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的html元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。 模板编译又分三个阶段，解析parse，优化optimize，生成generate，最终生成可执行函数render。 parse阶段：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。optimize阶段：遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。generate阶段：将最终的AST转化为render函数字符串。 template预编译是什么？对于 Vue 组件来说，模板编译只会在组件实例化的时候编译一次，生成渲染函数之后在也不会进行编译。因此，编译对组件的 runtime 是一种性能损耗。 而模板编译的目的仅仅是将template转化为render function，这个过程，正好可以在项目构建的过程中完成，这样可以让实际组件在 runtime 时直接跳过模板渲染，进而提升性能，这个在项目构建的编译template的过程，就是预编译。 那template和jsx的有什么分别？对于 runtime 来说，只需要保证组件存在 render 函数即可，而我们有了预编译之后，我们只需要保证构建过程中生成 render 函数就可以。 在 webpack 中，我们使用vue-loader编译.vue文件，内部依赖的vue-template-compiler模块，在 webpack 构建过程中，将template预编译成 render 函数。 与 react 类似，在添加了jsx的语法糖解析器babel-plugin-transform-vue-jsx之后，就可以直接手写render函数。 所以，template和jsx的都是render的一种表现形式，不同的是： JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。 说一下什么是Virtual DOMVirtual DOM 是 DOM 节点在 JavaScript 中的一种抽象数据结构，之所以需要虚拟DOM，是因为浏览器中操作DOM的代价比较昂贵，频繁操作DOM会产生性能问题。虚拟DOM的作用是在每一次响应式数据发生变化引起页面重渲染时，Vue对比更新前后的虚拟DOM，匹配找出尽可能少的需要更新的真实DOM，从而达到提升性能的目的。 介绍一下Vue中的Diff算法在新老虚拟DOM对比时 首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。匹配时，找到相同的子节点，递归比较子节点在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从O(n^3)降低值O(n)，也就是说，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。 key属性的作用是什么在对节点进行diff的过程中，判断是否为相同节点的一个很重要的条件是key是否相等，如果是相同节点，则会尽可能的复用原有的DOM节点。所以key属性是提供给框架在diff的时候使用的，而非开发者。 说说Vue2.0和Vue3.0有什么区别重构响应式系统，使用Proxy替换Object.defineProperty，使用Proxy优势：可直接监听数组类型的数据变化监听的目标为对象本身，不需要像Object.defineProperty一样遍历每个属性，有一定的性能提升可拦截apply、ownKeys、has等13种方法，而Object.defineProperty不行直接实现对象属性的新增/删除新增Composition API，更好的逻辑复用和代码组织重构 Virtual DOM模板编译时的优化，将一些静态节点编译成常量slot优化，将slot编译为lazy函数，将slot的渲染的决定权交给子组件模板中内联事件的提取并重用（原本每次渲染都重新生成内联函数）代码结构调整，更便于Tree shaking，使得体积更小使用Typescript替换Flow 为什么要新增Composition API，它能解决什么问题Vue2.0中，随着功能的增加，组件变得越来越复杂，越来越难维护，而难以维护的根本原因是Vue的API设计迫使开发者使用watch，computed，methods选项组织代码，而不是实际的业务逻辑。 另外Vue2.0缺少一种较为简洁的低成本的机制来完成逻辑复用，虽然可以minxis完成逻辑复用，但是当mixin变多的时候，会使得难以找到对应的data、computed或者method来源于哪个mixin，使得类型推断难以进行。 所以Composition API的出现，主要是也是为了解决Option API带来的问题，第一个是代码组织问题，Compostion API可以让开发者根据业务逻辑组织自己的代码，让代码具备更好的可读性和可扩展性，也就是说当下一个开发者接触这一段不是他自己写的代码时，他可以更好的利用代码的组织反推出实际的业务逻辑，或者根据业务逻辑更好的理解代码。 第二个是实现代码的逻辑提取与复用，当然mixin也可以实现逻辑提取与复用，但是像前面所说的，多个mixin作用在同一个组件时，很难看出property是来源于哪个mixin，来源不清楚，另外，多个mixin的property存在变量命名冲突的风险。而Composition API刚好解决了这两个问题。 都说Composition API与React Hook很像，说说区别从React Hook的实现角度看，React Hook是根据useState调用的顺序来确定下一次重渲染时的state是来源于哪个useState，所以出现了以下限制 不能在循环、条件、嵌套函数中调用Hook必须确保总是在你的React函数的顶层调用HookuseEffect、useMemo等函数必须手动确定依赖关系而Composition API是基于Vue的响应式系统实现的，与React Hook的相比 声明在setup函数内，一次组件实例化只调用一次setup，而React Hook每次重渲染都需要调用Hook，使得React的GC比Vue更有压力，性能也相对于Vue来说也较慢Compositon API的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用响应式系统自动实现了依赖收集，进而组件的部分的性能优化由Vue内部自己完成，而React Hook需要手动传入依赖，而且必须必须保证依赖的顺序，让useEffect、useMemo等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。虽然Compositon API看起来比React Hook好用，但是其设计思想也是借鉴React Hook的。 SSR有了解吗？原理是什么？在客户端请求服务器的时候，服务器到数据库中获取到相关的数据，并且在服务器内部将Vue组件渲染成HTML，并且将数据、HTML一并返回给客户端，这个在服务器将数据和组件转化为HTML的过程，叫做服务端渲染SSR。 而当客户端拿到服务器渲染的HTML和数据之后，由于数据已经有了，客户端不需要再一次请求数据，而只需要将数据同步到组件或者Vuex内部即可。除了数据以外，HTML也结构已经有了，客户端在渲染组件的时候，也只需要将HTML的DOM节点映射到Virtual DOM即可，不需要重新创建DOM节点，这个将数据和HTML同步的过程，又叫做客户端激活。 使用SSR的好处：有利于seo其实就是有利于爬虫来爬你的页面，因为部分页面爬虫是不支持执行JavaScript的，这种不支持执行JavaScript的爬虫抓取到的非SSR的页面会是一个空的HTML页面，而有了SSR以后，这些爬虫就可以获取到完整的HTML结构的数据，进而收录到搜索引擎中。 白屏时间更短相对于客户端渲染，服务端渲染在浏览器请求URL之后已经得到了一个带有数据的HTML文本，浏览器只需要解析HTML，直接构建DOM树就可以。而客户端渲染，需要先得到一个空的HTML页面，这个时候页面已经进入白屏，之后还需要经过加载并执行 JavaScript、请求后端服务器获取数据、JavaScript 渲染页面几个过程才可以看到最后的页面。特别是在复杂应用中，由于需要加载 JavaScript 脚本，越是复杂的应用，需要加载的 JavaScript 脚本就越多、越大，这会导致应用的首屏加载时间非常长，进而降低了体验感。 一、Vue3 里 script 的三种写法首先，Vue3 新增了一个叫做组合式 api 的东西，英文名叫 Composition API。因此 Vue3 的 script 现在支持三种写法， 1、最基本的 Vue2 写法123456789101112131415161718192021&lt;template&gt; &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt; &lt;button @click=\"onClick\"&gt; 增加 1 &lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; count: 1, &#125;; &#125;, methods: &#123; onClick() &#123; this.count += 1; &#125;, &#125;,&#125;&lt;/script&gt; 2、setup() 属性12345678910111213141516171819202122232425&lt;template&gt; &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt; &lt;button @click=\"onClick\"&gt; 增加 1 &lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref &#125; from 'vue';export default &#123; // 注意这部分 setup() &#123; let count = ref(1); const onClick = () =&gt; &#123; count.value += 1; &#125;; return &#123; count, onClick, &#125;; &#125;, &#125;&lt;/script&gt; 3、script setup123456789101112131415&lt;template&gt; &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt; &lt;button @click=\"onClick\"&gt; 增加 1 &lt;/button&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from 'vue';const count = ref(1);const onClick = () =&gt; &#123; count.value += 1;&#125;;&lt;/script&gt; 正如你看到的那样，无论是代码行数，还是代码的精简度，script setup 的方式是最简单的形式。 如果你对 Vue 很熟悉，那么，我推荐你使用script setup的方式。 这种写法，让 Vue3 成了我最喜欢的前端框架。 如果你还是前端新人，那么，我推荐你先学习第一种写法。 因为第一种写法的学习负担更小，先学第一种方式，掌握最基本的 Vue 用法，然后再根据我这篇文章，快速掌握 Vue3 里最需要关心的内容。 第一种写法，跟过去 Vue2 的写法是一样的，所以我们不过多介绍。 第二种写法，所有的对象和方法都需要 return 才能使用，太啰嗦。除了旧项目，可以用这种方式体验 Vue3 的新特性以外，我个人不建议了解这种方式。反正我自己暂时不打算精进这部分。 所以，接下来，我们主要介绍的，也就是script setup ，这种写法里需要了解的内容。 注意：script setup本质上是第二种写法的语法糖，掌握了这种写法，其实第二种写法也基本上就会了。（又多了一个不学第二种写法的理由）。 二、如何使用script setup编写组件学习 Vue3 并不代表你需要新学习一个技术，Vue3 的底层开发思想，跟 Vue2 是没有差别的。 V3 和 V2 的区别就像是，你用不同的语言或者方言说同一句话。 所以我们需要关心的，就是 Vue2 里的内容，怎么用 Vue3 的方式写出来。 1、data——唯一需要注意的地方整个 data 这一部分的内容，你只需要记住下面这一点。 以前在 data 中创建的属性，现在全都用 ref() 声明。 在 template 中直接用，在 script 中记得加 .value 。 在开头，我就已经写了一个简单的例子，我们直接拿过来做对比。 1）写法对比12345678910111213141516171819202122232425262728293031323334353637383940414243 // Vue2 的写法&lt;template&gt; &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt; &lt;button @click=\"onClick\"&gt; 增加 1 &lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; count: 1, &#125;; &#125;, methods: &#123; onClick() &#123; this.count += 1; &#125;, &#125;,&#125;&lt;/script&gt; // Vue3 的写法&lt;template&gt; &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt; &lt;button @click=\"onClick\"&gt; 增加 1 &lt;/button&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from 'vue'; // 用这种方式声明const count = ref(1);const onClick = () =&gt; &#123; // 使用的时候记得 .value count.value += 1;&#125;;&lt;/script&gt; 2）注意事项——组合式 api 的心智负担a、ref 和 reactiveVue3 里，还提供了一个叫做 reactive 的 api。 但是我的建议是，你不需要关心它。绝大多数场景下，ref 都够用了。 b、什么时候用 ref() 包裹，什么时候不用。要不要用ref，就看你的这个变量的值改变了以后，页面要不要跟着变。 当然，你可以完全不需要关心这一点，跟过去写 data 一样就行。 只不过这样做，你在使用的时候，需要一直 .value。 c、不要解构使用在使用时，不要像下面这样去写，会丢失响应性。 也就是会出现更新了值，但是页面没有更新的情况 123456789101112131415161718// Vue3 的写法&lt;template&gt; &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt; &lt;button @click=\"onClick\"&gt; 增加 1 &lt;/button&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from 'vue';const count = ref(1);const onClick = () =&gt; &#123; // 不要这样写！！ const &#123; value &#125; = count; value += 1;&#125;;&lt;/script&gt; 注意： 学习 Vue3 就需要考虑像这样的内容，徒增了学习成本。实际上这些心智负担，在学习的过程中，是可以完全不需要考虑的。 这也是为什么我推荐新人先学习 Vue2 的写法。 2、methods声明事件方法，我们只需要在 script 标签里，创建一个方法对象即可。 剩下的在 Vue2 里是怎么写的，Vue3 是同样的写法。 12345678910111213141516171819202122232425262728293031// Vue2 的写法&lt;template&gt; &lt;div @click=\"onClick\"&gt; 这是一个div &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; onClick() &#123; console.log('clicked') &#125;, &#125;,&#125;&lt;/script&gt;// Vue3 的写法&lt;template&gt; &lt;div @click=\"onClick\"&gt; 这是一个div &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;// 注意这部分const onClick = () =&gt; &#123; console.log('clicked')&#125;&lt;/script&gt; 3、props声明 props 我们可以用 defineProps()，具体写法，我们看代码。 1）写法对比123456789101112131415161718192021222324252627282930// Vue2 的写法&lt;template&gt; &lt;div&gt;&#123;&#123; foo &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; foo: String, &#125;, created() &#123; console.log(this.foo); &#125;,&#125;&lt;/script&gt;// Vue3 的写法&lt;template&gt; &lt;div&gt;&#123;&#123; foo &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;// 注意这里const props = defineProps(&#123; foo: String&#125;)// 在 script 标签里使用console.log(props.foo)&lt;/script&gt; 2）注意事项——组合式 api 的心智负担使用 props 时，同样注意不要使用解构的方式。 123456789&lt;script setup&gt;const props = defineProps(&#123; foo: String&#125;) // 不要这样写const &#123; foo &#125; = props;console.log(foo)&lt;/script&gt; 4、emits 事件与 props 相同，声明 emits 我们可以用 defineEmits()，具体写法，我们看代码。 123456789101112131415161718192021222324252627282930313233343536// Vue2 的写法&lt;template&gt; &lt;div @click=\"onClick\"&gt; 这是一个div &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; emits: ['click'], // 注意这里 methods: &#123; onClick() &#123; this.$emit('click'); // 注意这里 &#125;, &#125;, &#125;&lt;/script&gt;// Vue3 的写法&lt;template&gt; &lt;div @click=\"onClick\"&gt; 这是一个div &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;// 注意这里const emit = defineEmits(['click']);const onClick = () =&gt; &#123; emit('click') // 注意这里&#125;&lt;/script&gt; 5、computed直接上写法对比。 12345678910111213141516171819202122232425262728293031323334353637383940414243// Vue2 的写法&lt;template&gt; &lt;div&gt; &lt;span&gt;&#123;&#123; value &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; reversedValue &#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; value: 'this is a value', &#125;; &#125;, computed: &#123; reversedValue() &#123; return value .split('').reverse().join(''); &#125;, &#125;,&#125;&lt;/script&gt;// Vue3 的写法&lt;template&gt; &lt;div&gt; &lt;span&gt;&#123;&#123; value &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; reversedValue &#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123;ref, computed&#125; from 'vue'const value = ref('this is a value')// 注意这里const reversedValue = computed(() =&gt; &#123; // 使用 ref 需要 .value return value.value .split('').reverse().join('');&#125;)&lt;/script&gt; 6、watch这一部分，我们需要注意一下了，Vue3 中，watch 有两种写法。一种是直接使用 watch，还有一种是使用 watchEffect。 两种写法的区别是： watch 需要你明确指定依赖的变量，才能做到监听效果。 而 watchEffect 会根据你使用的变量，自动的实现监听效果。 1）直接使用 watch1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// Vue2 的写法&lt;template&gt; &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123; anotherCount &#125;&#125;&lt;/div&gt; &lt;button @click=\"onClick\"&gt; 增加 1 &lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; count: 1, anotherCount: 0, &#125;; &#125;, methods: &#123; onClick() &#123; this.count += 1; &#125;, &#125;, watch: &#123; count(newValue) &#123; this.anotherCount = newValue - 1; &#125;, &#125;,&#125;&lt;/script&gt;// Vue3 的写法&lt;template&gt; &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123; anotherCount &#125;&#125;&lt;/div&gt; &lt;button @click=\"onClick\"&gt; 增加 1 &lt;/button&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref, watch &#125; from 'vue';const count = ref(1);const onClick = () =&gt; &#123; count.value += 1;&#125;;const anotherCount = ref(0);// 注意这里// 需要在这里，// 明确指定依赖的是 count 这个变量watch(count, (newValue) =&gt; &#123; anotherCount.value = newValue - 1;&#125;)&lt;/script&gt; 2）使用 watchEffect1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// Vue2 的写法&lt;template&gt; &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123; anotherCount &#125;&#125;&lt;/div&gt; &lt;button @click=\"onClick\"&gt; 增加 1 &lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; count: 1, anotherCount: 0, &#125;; &#125;, methods: &#123; onClick() &#123; this.count += 1; &#125;, &#125;, watch: &#123; count(newValue) &#123; this.anotherCount = newValue - 1; &#125;, &#125;,&#125;&lt;/script&gt;// Vue3 的写法&lt;template&gt; &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123; anotherCount &#125;&#125;&lt;/div&gt; &lt;button @click=\"onClick\"&gt; 增加 1 &lt;/button&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref, watchEffect &#125; from 'vue';const count = ref(1);const onClick = () =&gt; &#123; count.value += 1;&#125;;const anotherCount = ref(0);// 注意这里watchEffect(() =&gt; &#123; // 会自动根据 count.value 的变化， // 触发下面的操作 anotherCount.value = count.value - 1;&#125;)&lt;/script&gt; 7、生命周期Vue3 里，除了将两个 destroy 相关的钩子，改成了 unmount，剩下的需要注意的，就是在 `` 中，不能使用 beforeCreate 和 created 两个钩子。 如果你熟悉相关的生命周期，只需要记得在 setup 里，用 on 开头，加上大写首字母就行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 选项式 api 写法&lt;template&gt; &lt;div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; beforeCreate() &#123;&#125;, created() &#123;&#125;, beforeMount() &#123;&#125;, mounted() &#123;&#125;, beforeUpdate() &#123;&#125;, updated() &#123;&#125;, // Vue2 里叫 beforeDestroy beforeUnmount() &#123;&#125;, // Vue2 里叫 destroyed unmounted() &#123;&#125;, // 其他钩子不常用，所以不列了。&#125;&lt;/script&gt;// 组合式 api 写法&lt;template&gt; &lt;div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted,&#125; from 'vue'onBeforeMount(() =&gt; &#123;&#125;)onMounted(() =&gt; &#123;&#125;)onBeforeUpdate(() =&gt; &#123;&#125;)onUpdated(() =&gt; &#123;&#125;)onBeforeUnmount(() =&gt; &#123;&#125;)onUnmounted(() =&gt; &#123;&#125;)&lt;/script&gt; 三、结语好了，对于快速上手 Vue3 来说，以上内容基本已经足够了。 如果觉得这篇文章不错，有帮你节省时间的话，还想听我说哪些内容，欢迎评论区里告诉我。 这篇文章本身不能做到帮你理解所有 Vue3 的内容，但是能帮你快速掌握 Vue3 的写法。 如果想做到对 Vue3 的整个内容心里有数，还需要你自己多看看 Vue3 的官方文档。原文链接：https://juejin.cn/post/7225267685763907621","categories":[{"name":"前端面试题","slug":"前端面试题","permalink":"https://qw8.github.io/categories/前端面试题/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://qw8.github.io/tags/vue3/"}]},{"title":"vue","slug":"interview/vue","date":"2024-03-09T13:02:08.000Z","updated":"2024-05-28T02:10:45.286Z","comments":true,"path":"/interview/vue.html","link":"","permalink":"https://qw8.github.io/interview/vue.html","excerpt":"","text":"面试题链接https://blog.csdn.net/qq_41646249/article/details/104644647 https://blog.csdn.net/qq_41646249/article/details/104644712 Vue 中的 key 有什么作用？key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。 Vue 的 diff 过程可以概括为：oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex 和 newStartIndex、newEndIndex，它们会新节点和旧节点会进行两两对比，即一共有4种比较方式：newStartIndex 和oldStartIndex 、newEndIndex 和 oldEndIndex 、newStartIndex 和 oldEndIndex 、newEndIndex 和 oldStartIndex，如果以上 4 种比较都没匹配，如果设置了key，就会用 key 再进行比较，在比较的过程中，遍历会往中间靠，一旦 StartIdx &gt; EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。具体有无 key 的 diff 过程，可以查看作者写的另一篇详解虚拟 DOM 的文章《深入剖析：Vue核心之虚拟DOM》 所以 Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速 更准确：因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。 更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快，源码如下： 1function createKeyToOldIdx (children, beginIdx, endIdx) &#123; vue的优点是什么？ 低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变 可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑 可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写 简洁、轻快、舒服 组件之间的传值？父组件与子组件传值123456789101112131415161718192021222324252627282930313233//父组件通过标签上面定义传值&lt;template&gt; &lt;Main :obj=&quot;data&quot;&gt;&lt;/Main&gt;&lt;/template&gt;&lt;script&gt; //引入子组件 import Main form &quot;./main&quot; exprot default&#123; name:&quot;parent&quot;, data()&#123; return &#123; data:&quot;我要向子组件传递数据&quot; &#125; &#125;, //初始化组件 components:&#123; Main &#125; &#125;&lt;/script&gt;//子组件通过props方法接受数据&lt;template&gt; &lt;div&gt;&#123;&#123;data&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; exprot default&#123; name:&quot;son&quot;, //接受父组件传值 props:[&quot;data&quot;] &#125;&lt;/script&gt; 子组件向父组件传递数据123456789101112131415161718192021222324252627//子组件通过$emit方法传递参数&lt;template&gt; &lt;div v-on:click=&quot;events&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; //引入子组件 import Main form &quot;./main&quot; exprot default&#123; methods:&#123; events:function()&#123; &#125; &#125; &#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt;&#123;&#123;data&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; exprot default&#123; name:&quot;son&quot;, //接受父组件传值 props:[&quot;data&quot;] &#125;&lt;/script&gt; Vue 的实例生命周期 （1） beforeCreate 初始化实例后 数据观测和事件配置之前调用 （2） created 实例创建完成后调用 （3） beforeMount 挂载开始前被用 （4） mounted el 被新建 vm.$el 替换并挂在到实例上之后调用 （5） beforeUpdate 数据更新时调用 （6） updated 数据更改导致的 DOM 重新渲染后调用 （7） beforeDestory 实例被销毁前调用 （8） destroyed 实例销毁后调用 答：总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后 创建前/后： 在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el还没有 载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。 更新前/后：当data变化时，会触发beforeUpdate和updated方法 销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在 vue 双向数据绑定原理？vue 通过使用双向数据绑定，来实现了 View 和 Model 的同步更新。vue 的双向数据绑定主要是通过使用数据劫持和发布订阅者模式来实现的。 首先我们通过 Object.defineProperty() 方法来对 Model 数据各个属性添加访问器属性，以此来实现数据的劫持，因此当 Model 中的数据发生变化的时候，我们可以通过配置的 setter 和 getter 方法来实现对 View 层数据更新的通知。Vue3.0 将用原生 Proxy 替换 Object.defineProperty 数据在 html 模板中一共有两种绑定情况，一种是使用 v-model 来对 value 值进行绑定，一种是作为文本绑定，在对模板引擎进行解析的过程中。 如果遇到元素节点，并且属性值包含 v-model 的话，我们就从 Model 中去获取 v-model 所对应的属性的值，并赋值给元素的 value 值。然后给这个元素设置一个监听事件，当 View 中元素的数据发生变化的时候触发该事件，通知 Model 中的对应的属性的值进行更新。 如果遇到了绑定的文本节点，我们使用 Model 中对应的属性的值来替换这个文本。对于文本节点的更新，我们使用了发布订阅者模式，属性作为一个主题，我们为这个节点设置一个订阅者对象，将这个订阅者对象加入这个属性主题的订阅者列表中。当 Model 层数据发生改变的时候，Model 作为发布者向主题发出通知，主题收到通知再向它的所有订阅者推送，订阅者收到通知后更改自己的数据。 详细资料可以参考：《Vue.js 双向绑定的实现原理》 Object.defineProperty 介绍？Object.defineProperty 函数一共有三个参数，第一个参数是需要定义属性的对象，第二个参数是需要定义的属性，第三个是该属性描述符。 一个属性的描述符有四个属性，分别是 value 属性的值，writable 属性是否可写，enumerable 属性是否可枚举，configurable 属性是否可配置修改。 详细资料可以参考：《Object.defineProperty()》 使用Object.defineProperty() 来进行数据劫持有什么缺点？Object.defineProperty 无法监控到数组下标的变化，有一些对属性的操作，使用这种方法无法拦截，比如说通过下标方式修改数组数据或者给对象新增属性，不能实时响应，vue 内部通过重写函数解决了这个问题。Object.defineProperty 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。 在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用 Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为这是 ES6 的语法。 什么是 Proxy？Proxy 是 ES6 中新增的一个特性，翻译过来意思是”代理”，用在这里表示由它来“代理”某些操作，可以译为“代理器”。 Proxy 让我们能够以简洁易懂的方式控制外部对对象的访问。其功能非常类似于设计模式中的代理模式。 Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”，即对编程语言进行编程。 使用 Proxy 的核心优点是可以交由它来处理一些非核心逻辑（如：读取或设置对象的某些属性前记录日志；设置对象的某些属性值前，需要验证；某些属性的访问控制等）。 从而可以让对象只需关注于核心逻辑，达到关注点分离，降低对象复杂度等目的。 Vue组件通信有哪些方式1.父传子：props父组件通过 props 向下传递数据给子组件。注：组件中的数据共有三种形式：data、props、computed 2.父传子孙：provide 和 inject父组件定义provide方法return需要分享给子孙组件的属性，子孙组件使用 inject 选项来接收指定的我们想要添加在这个实例上的 属性； 3.子传父：通过事件形式子组件通过 $emit()给父组件发送消息，父组件通过v-on绑定事件接收数据。 4.父子、兄弟、跨级：eventBus.js这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心）,用它来（e m i t ） 触 发 事 件 和 （ emit）触发事件和（emit）触发事件和（on）监听事件，巧妙而轻量地实现了任何组件间的通信。 5.通信插件：PubSub.js 6.vuexvuex 是 vue 的状态管理器，存储的数据是响应式的。只需要把共享的值放到vuex中，其他需要的组件直接获取使用即可； router和route的区别router为VueRouter的实例，是路由实例对象，相当于一个全局的路由器对象，包括了路由的跳转方法，钩子函数等，里面含有很多属性和子对象，例如history对象。经常用的跳转链接就可以用this.$router.push和router-link跳转一样。 route是当前正在跳转的路由信息对象。包括path，params，hash，query，fullPath，matched，name 等路由信息参数，可以从里面获取name,path,params,query等。 $nextTick的理解用法：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。为什么？Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。所以为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数将在 DOM 更新完成后被调用。使用场景：在你更新完数据后，需要及时操作渲染好的 DOM时 Vue中常用的一些指令1.v-model指令：用于表单输入，实现表单控件和数据的双向绑定。2.v-on：简写为@，基础事件绑定3.v-bind：简写为：，动态绑定一些元素的属性，类型可以是：字符串、对象或数组。4.v-if指令：取值为true/false，控制元素是否需要被渲染5.v-else指令：和v-if指令搭配使用，没有对应的值。当v-if的值false，v-else才会被渲染出来。6.v-show指令：指令的取值为true/false，分别对应着显示/隐藏。7.v-for指令：遍历data中存放的数组数据，实现列表的渲染。8.v-once： 通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新 vue的自定义指令Vue除了核心功能默认内置的指令 ，Vue 也允许注册自定义指令。自定义指令是用来操作DOM的。尽管Vue推崇数据驱动视图的理念，但并非所有情况都适合数据驱动。自定义指令就是一种有效的补充和扩展，不仅可用于定义任何的DOM操作，并且是可复用的。 添加自定义指令的两种方式： 全局指令： 通过 Vue.directive() 函数注册一个全局的指令。局部指令：通过组件的 directives 属性，对该组件添加一个局部的指令。可以参考如何写一个Vue自定义指令或Vue.js官网关于自定义指令的详细讲解学习 你有写过自定义指令吗？自定义指令的应用场景有哪些？可以参考如何写一个Vue自定义指令 16.如何编写一个自定义指令指令是个函数或者对象，用来操作dom，指令内部的this指向window； a:全局指令 Vue.directive（指令名称不带v-,回调（el,bingding）） el:dom元素；binding是个对象，含有传入的参数，binding。value b:局部 定义在选项里面 123directives:&#123; 指令名不带v- : 函数(el,binding)&#123;&#125;&#125; v-show和v-if指令的共同点和不同点相同点：v-show和v-if都能控制元素的显示和隐藏。不同点：1.实现本质方法不同:v-show本质就是通过设置css中的display设置为none;控制隐藏v-if是动态的向DOM树内添加或者删除DOM元素;2.v-show都会编译，初始值为false，只是将display设为none，但它也编译了;v-if初始值为false，就不会编译了总结：v-show只编译一次，后面其实就是控制css，而v-if不停的销毁和创建，如果要频繁切换某节点时，故v-show性能更好一点。 为什么避免v-if和v-for一起使用vue2.x版本中，当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级；vue3.x版本中，当 v-if 与 v-for 一起使用时，v-if 具有比 v-for 更高的优先级。官网明确指出：避免 v-if 和 v-for 一起使用，永远不要在一个元素上同时使用 v-if 和 v-for。 可以先对数据在计算数据中进行过滤，然后再进行遍历渲染； 操作和实现起来都没有什么问题，页面也会正常展示。但是会带来不必要的性能消耗； 为什么避免 v-if 和 v-for 用在一起当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级，这意味着 v-if 将分别重复运行于每个 v-for 循环中。通过 v-if 移动到容器元素，不会再重复遍历列表中的每个值。取而代之的是，我们只检查它一次，且不会在 v-if 为否的时候运算 v-for。 请问 v-if 和 v-show 有什么区别v-if 指令是直接销毁和重建 DOM 达到让元素显示和隐藏的效果，适用于在运行时很少改变条件，不需要频繁切换条件的场景 v-show 指令是通过修改元素的 display 的 CSS 属性让其显示或者隐藏，适用于需要非常频繁切换条件的场景 vue中 key 值的作用需要使用 key 来给每个节点做一个唯一标识，Diff 算法就可以正确的识别此节点，找到正确的位置区插入新的节点所以一句话，key 的作用主要是为了高效的更新虚拟 DOM computed 和 watch 区别？computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。 watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。 keep-alive 组件有什么作用？如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。 路由之间跳转？声明式（标签跳转）1&lt;router-link :to=&quot;index&quot;&gt; 编程式（ js跳转）1router.push(&apos;index&apos;) vue 中的性能优化编码阶段 尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher v-if和v-for不能连用 如果需要使用v-for给每项元素绑定事件时使用事件代理 在更多的情况下，使用v-if替代v-show key保证唯一 SPA 页面采用keep-alive缓存组件 使用路由（组件）懒加载、异步组件 防抖、节流 第三方模块按需导入 长列表滚动到可视区域动态加载 图片懒加载（LazyLoad Images） 引入生产环境的 Vue 文件 使用单文件组件预编译模板 减少 http 请求，合理设置 HTTP 缓存 CSS Sprites 提取组件的 CSS 到单独到文件 CSS 放在页面最上部，javascript 放在页面最下面 尽量避免使用 eval 和 Function 利用 Object.freeze()提升性能 扁平化 Store 数据结构 合理使用持久化 Store 数据 SEO优化 服务端渲染SSR 预渲染 打包优化 压缩代码 服务端开启 gzip 压缩 Tree Shaking/Scope Hoisting 使用cdn加载第三方模块 多线程打包happypack splitChunks抽离公共文件 sourceMap优化 用户体验 骨架屏 PWA 使用缓存优化 客户端（浏览器）缓存 服务端缓存 什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化我们的开发效率。 比如说我们实验室在以前项目开发的时候，使用单页应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，当时一旦项目变得复杂，那么整个文件就会变得冗长，混乱，这样对我们的项目开发和后期的项目维护是非常不利的。 MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。 MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中我们使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此我们可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。 MVVM 模式中的 VM，指的是 ViewModel，它和 MVP 的思想其实是相同的，不过它通过双向的数据绑定，将 View 和 Model 的同步更新给自动化了。当 Model 发生变化的时候，ViewModel 就会自动更新；ViewModel 变化了，View 也会更新。这样就将 Presenter 中的工作给自动化了。我了解过一点双向数据绑定的原理，比如 vue 是通过使用数据劫持和发布订阅者模式来实现的这一功能。 详细资料可以参考：《浅析前端开发中的 MVC/MVP/MVVM 模式》《MVC，MVP 和 MVVM 的图示》《MVVM》《一篇文章了解架构模式：MVC/MVP/MVVM》 什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？我对 Virtual DOM 的理解是， 首先对我们将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后我们将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。 当页面的状态发生改变，我们需要对页面的 DOM 的结构进行调整的时候，我们首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。 最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。 我认为 Virtual DOM 这种方法对于我们需要有大量的 DOM 操作的时候，能够很好的提高我们的操作效率，通过在操作前确定需要做的最小修改，尽可能的减少 DOM 操作带来的重流和重绘的影响。其实 Virtual DOM 并不一定比我们真实的操作 DOM 要快，这种方法的目的是为了提高我们开发时的可维护性，在任意的情况下，都能保证一个尽量小的性能消耗去进行操作。 详细资料可以参考：《Virtual DOM》《理解 Virtual DOM》《深度剖析：如何实现一个 Virtual DOM 算法》《网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？》 如何比较两个 DOM 树的差异？两个树的完全 diff 算法的时间复杂度为 O(n^3) ，但是在前端中，我们很少会跨层级的移动元素，所以我们只需要比较同一层级的元素进行比较，这样就可以将算法的时间复杂度降低为 O(n)。 算法首先会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个序号。在深度遍历的时候，每遍历到一个节点，我们就将这个节点和新的树中的节点进行比较，如果有差异，则将这个差异记录到一个对象中。 在对列表元素进行对比的时候，由于 TagName 是重复的，所以我们不能使用这个来对比。我们需要给每一个子节点加上一个 key，列表对比的时候使用 key 来进行比较，这样我们才能够复用老的 DOM 树上的节点。 组件的设计原则 页面上每个独立的可视/可交互区域视为一个组件(比如页面的头部，尾部，可复用的区块) 每个组件对应一个工程目录，组件所需要的各种资源在这个目录下就近维护(组件的就近维护思想体现了前端的工程化思想，为前端开发提供了很好的分治策略，在vue.js中，通过.vue文件将组件依赖的模板，js，样式写在一个文件中)(每个开发者清楚开发维护的功能单元，它的代码必然存在在对应的组件目录中，在该目录下，可以找到功能单元所有的内部逻辑) 页面不过是组件的容器，组件可以嵌套自由组合成完整的页面 对于 Vue 是一套渐进式框架的理解每个框架都不可避免会有自己的一些特点，从而会对使用者有一定的要求，这些要求就是主张，主张有强有弱，它的强势程度会影响在业务开发中的使用方式。 1、使用 vue，你可以在原有大系统的上面，把一两个组件改用它实现，当 jQuery 用； 2、也可以整个用它全家桶开发，当 Angular 用； 3、还可以用它的视图，搭配你自己设计的整个下层用。你可以在底层数据逻辑的地方用 OO(Object–Oriented )面向对象和设计模式的那套理念。也可以函数式，都可以。 它只是个轻量视图而已，只做了自己该做的事，没有做不该做的事，仅此而已。 你不必一开始就用 Vue 所有的全家桶，根据场景，官方提供了方便的框架供你使用。 场景联想场景 1：维护一个老项目管理后台，日常就是提交各种表单了，这时候你可以把 vue 当成一个 js 库来使用，就用来收集 form 表单，和表单验证。 场景 2：得到 boss 认可， 后面整个页面的 dom 用 Vue 来管理，抽组件，列表用 v-for 来循环，用数据驱动 DOM 的变化 场景 3:越来越受大家信赖，领导又找你了，让你去做一个移动端 webapp，直接上了 vue 全家桶！ 场景 1-3 从最初的只因多看你一眼而用了前端 js 库，一直到最后的大型项目解决方案。 vue 常用的修饰符参考 v-on 可以监听多个方法吗？肯定可以的。 解析： 1234567&lt;input type=\"text\" :value=\"name\" @input=\"onInput\" @focus=\"onFocus\" @blur=\"onBlur\"/&gt; vue-cli 工程升级 vue 版本在项目目录里运行 npm upgrade vue vue-template-compiler，不出意外的话，可以正常运行和 build。如果有任何问题，删除 node_modules 文件夹然后重新运行 npm i 即可。（简单的说就是升级 vue 和 vue-template-compiler 两个插件） vue 事件中如何使用 event 对象？v-on 指令（可以简写为 @） 1、使用不带圆括号的形式，event 对象将被自动当做实参传入； 2、使用带圆括号的形式，我们需要使用 $event 变量显式传入 event 对象。 解析： 一、event 对象 （一）事件的 event 对象 你说你是搞前端的，那么你肯定就知道事件，知道事件，你就肯定知道 event 对象吧？各种的库、框架多少都有针对 event 对象的处理。比如 jquery，通过它内部进行一定的封装，我们开发的时候，就无需关注 event 对象的部分兼容性问题。最典型的，如果我们要阻止默认事件，在 chrome 等浏览器中，我们可能要写一个： 1event.preventDefault(); 而在 IE 中，我们则需要写： 1event.returnValue = false; 多亏了 jquery ，跨浏览器的实现，我们统一只需要写： 1event.preventDefault(); 兼容？jquery 内部帮我们搞定了。类似的还有比如阻止事件冒泡以以及事件绑定（addEventListener / attachEvent）等，简单到很多的后端都会使用 $(‘xxx’).bind(…)，这不是我们今天的重点，我们往下看。 （二）vue 中的 event 对象 我们知道，相比于 jquery，vue 的事件绑定可以显得更加直观和便捷，我们只需要在模板上添加一个 v-on 指令（还可以简写为 @），即可完成类似于 $(‘xxx’).bind 的效果，少了一个利用选择器查询元素的操作。我们知道，jquery 中，event 对象会被默认当做实参传入到处理函数中，如下 123$(\"body\").bind(\"click\", function(event) &#123; console.log(typeof event); // object&#125;); 这里直接就获取到了 event 对象，那么问题来了，vue 中呢？ 123456789101112&lt;div id=\"app\"&gt; &lt;button v-on:click=\"click\"&gt;click me&lt;/button&gt;&lt;/div&gt;...var app = new Vue(&#123; el: '#app', methods: &#123; click(event) &#123; console.log(typeof event); // object &#125; &#125;&#125;); 这里的实现方式看起来和 jquery 是一致的啊，但是实际上，vue 比 jquery 要要复杂得多，jquery 官方也明确的说，v-on 不简单是 addEventListener 的语法糖。在 jquery 中，我们传入到 bind 方法中的回调，只能是一个函数表类型的变量或者一个匿名函数，传递的时候，还不能执行它（在后面加上一堆圆括号），否则就变成了取这一个函数的返回值作为事件回调。而我们知道，vue 的 v-on 指令接受的值可以是函数执行的形式，比如 v-on:click=”click(233)” 。这里我们可以传递任何需要传递的参数，甚至可以不传递参数： 123456789101112&lt;div id=\"app\"&gt; &lt;button v-on:click=\"click()\"&gt;click me&lt;/button&gt;&lt;/div&gt;...var app = new Vue(&#123; el: '#app', methods: &#123; click(event) &#123; console.log(typeof event); // undefined &#125; &#125;&#125;); 咦？我的 event 对象呢？怎么不见了？打印看看 arguments.length 也是 0，说明这时候确实没有实参被传入进来。T_T，那我们如果既需要传递参数，又需要用到 event 对象，这个该怎么办呢？ （三）$event 翻看 vue 文档，不难发现，其实我们可以通过将一个特殊变量 $event 传入到回调中解决这个问题： 123456789101112&lt;div id=\"app\"&gt; &lt;button v-on:click=\"click($event, 233)\"&gt;click me&lt;/button&gt;&lt;/div&gt;...var app = new Vue(&#123; el: '#app', methods: &#123; click(event, val) &#123; console.log(typeof event); // object &#125; &#125;&#125;); 好吧，这样看起来就正常了。简单总结来说： 使用不带圆括号的形式，event 对象将被自动当做实参传入； 使用带圆括号的形式，我们需要使用 $event 变量显式传入 event 对象。 $nextTick 的使用1、什么是 Vue.nextTick()？定义：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 所以就衍生出了这个获取更新后的 DOM 的 Vue 方法。所以放在 Vue.nextTick()回调函数中的执行的应该是会对 DOM 进行操作的 js 代码； 理解：nextTick()，是将回调函数延迟在下一次 dom 更新数据后调用，简单的理解是：当数据更新了，在 dom 中渲染后，自动执行该函数， 12345678910111213141516171819202122232425&lt;template&gt; &lt;div class=\"hello\"&gt; &lt;div&gt; &lt;button id=\"firstBtn\" @click=\"testClick()\" ref=\"aa\"&gt;&#123;&#123;testMsg&#125;&#125;&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'HelloWorld', data () &#123; return &#123; testMsg:\"原始值\", &#125; &#125;, methods:&#123; testClick:function()&#123; let that=this; that.testMsg=\"修改后的值\"; console.log(that.$refs.aa.innerText); //that.$refs.aa获取指定DOM，输出：原始值 &#125; &#125;&#125;&lt;/script&gt; 使用 this.$nextTick() 123456789methods:&#123; testClick:function()&#123; let that=this; that.testMsg=\"修改后的值\"; that.$nextTick(function()&#123; console.log(that.$refs.aa.innerText); //输出：修改后的值 &#125;); &#125; &#125; 注意：Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM， 2、什么时候需要用的 Vue.nextTick()？1、Vue 生命周期的 created()钩子函数进行的 DOM 操作一定要放在 Vue.nextTick()的回调函数中，原因是在 created()钩子函数执行的时候 DOM 其实并未进行任何渲染，而此时进行 DOM 操作无异于徒劳，所以此处一定要将 DOM 操作的 js 代码放进 Vue.nextTick()的回调函数中。与之对应的就是 mounted 钩子函数，因为该钩子函数执行时所有的 DOM 挂载已完成。 123456created()&#123; let that=this; that.$nextTick(function()&#123; //不使用this.$nextTick()方法会报错 that.$refs.aa.innerHTML=\"created中更改了按钮内容\"; //写入到DOM元素 &#125;);&#125; 2、当项目中你想在改变 DOM 元素的数据后基于新的 dom 做点什么，对新 DOM 一系列的 js 操作都需要放进 Vue.nextTick()的回调函数中；通俗的理解是：更改数据后当你想立即使用 js 操作新的视图的时候需要使用它 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div class=\"hello\"&gt; &lt;h3 id=\"h\"&gt;&#123;&#123;testMsg&#125;&#125;&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'HelloWorld', data () &#123; return &#123; testMsg:\"原始值\", &#125; &#125;, methods:&#123; changeTxt:function()&#123; let that=this; that.testMsg=\"修改后的文本值\"; //vue数据改变，改变dom结构 let domTxt=document.getElementById('h').innerText; //后续js对dom的操作 console.log(domTxt); //输出可以看到vue数据修改后DOM并没有立即更新，后续的dom都不是最新的 if(domTxt===\"原始值\")&#123; console.log(\"文本data被修改后dom内容没立即更新\"); &#125;else &#123; console.log(\"文本data被修改后dom内容被马上更新了\"); &#125; &#125;, &#125;&#125;&lt;/script&gt; 正确的用法是：vue 改变 dom 元素结构后使用 vue.$nextTick()方法来实现 dom 数据更新后延迟执行后续代码 1234567891011121314changeTxt:function()&#123; let that=this; that.testMsg=\"修改后的文本值\"; //修改dom结构 that.$nextTick(function()&#123; //使用vue.$nextTick()方法可以dom数据更新后延迟执行 let domTxt=document.getElementById('h').innerText; console.log(domTxt); //输出可以看到vue数据修改后并没有DOM没有立即更新， if(domTxt===\"原始值\")&#123; console.log(\"文本data被修改后dom内容没立即更新\"); &#125;else &#123; console.log(\"文本data被修改后dom内容被马上更新了\"); &#125; &#125;);&#125; 3、在使用某个第三方插件时 ，希望在 vue 生成的某些 dom 动态发生变化时重新应用该插件，也会用到该方法，这时候就需要在 $nextTick 的回调函数中执行重新应用插件的方法。 Vue.nextTick(callback) 使用原理： 原因是，Vue 是异步执行 dom 更新的，一旦观察到数据变化，Vue 就会开启一个队列，然后把在同一个事件循环 (event loop) 当中观察到数据变化的 watcher 推送进这个队列。如果这个 watcher 被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和 DOm 操作。而在下一个事件循环时，Vue 会清空队列，并进行必要的 DOM 更新。当你设置 vm.someData = ‘new value’，DOM 并不会马上更新，而是在异步队列被清除，也就是下一个事件循环开始时执行更新时才会进行必要的 DOM 更新。如果此时你想要根据更新的 DOM 状态去做某些事情，就会出现问题。。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。 Vue 组件中 data 为什么必须是函数在 new Vue() 中，data 是可以作为一个对象进行操作的，然而在 component 中，data 只能以函数的形式存在，不能直接将对象赋值给它，这并非是 Vue 自身如此设计，而是跟 JavaScript 特性相关，我们来回顾下 JavaScript 的原型链 12345678var Component = function() &#123;&#125;; Component.prototype.data = &#123; message: \"Love\"&#125;;var component1 = new Component(),component2 = new Component();component1.data.message = \"Peace\";console.log(component2.data.message); // Peace 以上两个实例都引用同一个对象，当其中一个实例属性改变时，另一个实例属性也随之改变，只有当两个实例拥有自己的作用域时，才不会互相干扰 ！ 123456789101112var Component = function() &#123; this.data = this.data();&#125;;Component.prototype.data = function() &#123; return &#123; message: \"Love\" &#125;;&#125;;var component1 = new Component(), component2 = new Component();component1.data.message = \"Peace\";console.log(component2.data.message); // Love vue 中子组件调用父组件的方法 第一种方法是直接在子组件中通过 this.$parent.event 来调用父组件的方法 第二种方法是在子组件里用$emit 向父组件触发一个事件，父组件监听这个事件就行了 第三种是父组件把方法传入子组件中，在子组件里直接调用这个方法 解析： 第一种方法是直接在子组件中通过 this.$parent.event 来调用父组件的方法 父组件 123456789101112131415161718&lt;template&gt; &lt;div&gt; &lt;child&gt;&lt;/child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import child from '~/components/dam/child'; export default &#123; components: &#123; child &#125;, methods: &#123; fatherMethod() &#123; console.log('测试'); &#125; &#125; &#125;;&lt;/script&gt; 子组件 1234567891011121314&lt;template&gt; &lt;div&gt; &lt;button @click=\"childMethod()\"&gt;点击&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; childMethod() &#123; this.$parent.fatherMethod(); &#125; &#125; &#125;;&lt;/script&gt; 第二种方法是在子组件里用$emit 向父组件触发一个事件，父组件监听这个事件就行了 父组件 123456789101112131415161718&lt;template&gt; &lt;div&gt; &lt;child @fatherMethod=\"fatherMethod\"&gt;&lt;/child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import child from \"~/components/dam/child\"; export default &#123; components: &#123; child &#125;, methods: &#123; fatherMethod() &#123; console.log(\"测试\"); &#125; &#125; &#125;;&lt;/script&gt; 子组件 1234567891011121314&lt;template&gt; &lt;div&gt; &lt;button @click=\"childMethod()\"&gt;点击&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; childMethod() &#123; this.$emit(\"fatherMethod\"); &#125; &#125; &#125;;&lt;/script&gt; 第三种是父组件把方法传入子组件中，在子组件里直接调用这个方法 父组件 123456789101112131415161718&lt;template&gt; &lt;div&gt; &lt;child :fatherMethod=\"fatherMethod\"&gt;&lt;/child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import child from \"~/components/dam/child\"; export default &#123; components: &#123; child &#125;, methods: &#123; fatherMethod() &#123; console.log(\"测试\"); &#125; &#125; &#125;;&lt;/script&gt; 子组件 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;button @click=\"childMethod()\"&gt;点击&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; fatherMethod: &#123; type: Function, default: null &#125; &#125;, methods: &#123; childMethod() &#123; if (this.fatherMethod) &#123; this.fatherMethod(); &#125; &#125; &#125; &#125;;&lt;/script&gt; vue 中父组件调用子组件的方法答案：使用$refs 父组件 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;button @click=\"clickParent\"&gt;点击&lt;/button&gt; &lt;child ref=\"mychild\"&gt;&lt;/child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Child from \"./child\"; export default &#123; name: \"parent\", components: &#123; child: Child &#125;, methods: &#123; clickParent() &#123; this.$refs.mychild.parentHandleclick(\"嘿嘿嘿\"); // 划重点！！！！ &#125; &#125; &#125;;&lt;/script&gt; 子组件 1234567891011121314151617&lt;template&gt; &lt;div&gt; child &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: \"child\", props: \"someprops\", methods: &#123; parentHandleclick(e) &#123; console.log(e); &#125; &#125; &#125;;&lt;/script&gt; vue 中 keep-alive 组件的作用答案：keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。 解析： 用法也很简单： 12345&lt;keep-alive&gt; &lt;component&gt; &lt;!-- 该组件将被缓存！ --&gt; &lt;/component&gt;&lt;/keep-alive&gt; props_ include - 字符串或正则表达，只有匹配的组件会被缓存_ exclude - 字符串或正则表达式，任何匹配的组件都不会被缓存 1234567// 组件 aexport default &#123; name: \"a\", data() &#123; return &#123;&#125;; &#125;&#125;; 123456&lt;keep-alive include=\"a\"&gt; &lt;component&gt; &lt;!-- name 为 a 的组件将被缓存！ --&gt; &lt;/component&gt; &lt;/keep-alive&gt;可以保留它的状态或避免重新渲染 12345&lt;keep-alive exclude=\"a\"&gt; &lt;component&gt; &lt;!-- 除了 name 为 a 的组件都将被缓存！ --&gt; &lt;/component&gt; &lt;/keep-alive&gt;可以保留它的状态或避免重新渲染 但实际项目中,需要配合 vue-router 共同使用. router-view 也是一个组件，如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存： 12345&lt;keep-alive&gt; &lt;router-view&gt; &lt;!-- 所有路径匹配到的视图组件都会被缓存！ --&gt; &lt;/router-view&gt;&lt;/keep-alive&gt; 如果只想 router-view 里面某个组件被缓存，怎么办？ 增加 router.meta 属性 12345678910111213141516171819// routes 配置export default [ &#123; path: \"/\", name: \"home\", component: Home, meta: &#123; keepAlive: true // 需要被缓存 &#125; &#125;, &#123; path: \"/:id\", name: \"edit\", component: Edit, meta: &#123; keepAlive: false // 不需要被缓存 &#125; &#125;]; 123456789&lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt; &lt;!-- 这里是会被缓存的视图组件，比如 Home！ --&gt; &lt;/router-view&gt;&lt;/keep-alive&gt;&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt; &lt;!-- 这里是不被缓存的视图组件，比如 Edit！ --&gt;&lt;/router-view&gt; vue 中如何编写可复用的组件？总结组件的职能，什么需要外部控制（即 props 传啥），组件需要控制外部吗（$emit）,是否需要插槽（slot） 什么是 vue 生命周期和生命周期钩子函数？vue 的生命周期就是 vue 实例从创建到销毁的过程 解析： vue 生命周期钩子函数有哪些？ vue 如何监听键盘事件中的按键参考 什么是 vue 的计算属性？答案：先来看一下计算属性的定义：当其依赖的属性的值发生变化的时，计算属性会重新计算。反之则使用缓存中的属性值。计算属性和vue中的其它数据一样，都是响应式的，只不过它必须依赖某一个数据实现，并且只有它依赖的数据的值改变了，它才会更新。 什么是 Virtual DOM？可以看作是一个使用 javascript 模拟了 DOM 结构的树形结构 参考 Vue 中如何实现 proxy 代理？webpack 自带的 devServer 中集成了 http-proxy-middleware。配置 devServer 的 proxy 选项即可 123456789proxyTable: &#123; '/api': &#123; target: 'http://192.168.149.90:8080/', // 设置你调用的接口域名和端口号 changeOrigin: true, // 跨域 pathRewrite: &#123; '^/api': '/' &#125; &#125;&#125; vue 在什么情况下在数据发生改变的时候不会触发视图更新v-for 遍历的数组，当数组内容使用的是 arr[0].xx =xx 更改数据，vue 无法监测到vm.arr.length = newLength 也是无法检测的到的 vue 的优点是什么？低耦合。视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的”View”上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。 可重用性。你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 view 重用这段视图逻辑。 独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。 可测试。界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。 轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 kb ； 简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习； 双向数据绑定：保留了 angular 的特点，在数据操作方面更为简单； 组件化：保留了 react 的优点，实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势； 视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作； 虚拟DOM：dom 操作是非常耗费性能的， 不再使用原生的 dom 操作节点，极大解放 dom 操作，但具体操作的还是 dom 不过是换了另一种方式； 运行速度更快：相比较于 react 而言，同样是操作虚拟 dom ，就性能而言， vue 存在很大的优势。 观察者模式和发布订阅模式有什么不同？发布订阅模式其实属于广义上的观察者模式 在观察者模式中，观察者需要直接订阅目标事件。在目标发出内容改变的事件后，直接接收事件并作出响应。 而在发布订阅模式中，发布者和订阅者之间多了一个调度中心。调度中心一方面从发布者接收事件，另一方面向订阅者发布事件，订阅者需要在调度中心中订阅事件。通过调度中心实现了发布者和订阅者关系的解耦。使用发布订阅者模式更利于我们代码的可维护性。 详细资料可以参考：《观察者模式和发布订阅模式有什么不同？》 Vue 的生命周期是什么？1Vue 的生命周期指的是组件从创建到销毁的一系列的过程，被称为 Vue 的生命周期。通过提供的 Vue 在生命周期各个阶段的钩子函数，我们可以很好的在 Vue 的各个生命阶段实现一些操作。 Vue 的各个生命阶段是什么？12345678910111213141516171819Vue 一共有8个生命阶段，分别是创建前、创建后、加载前、加载后、更新前、更新后、销毁前和销毁后，每个阶段对应了一个生命周期的钩子函数。（1）beforeCreate 钩子函数，在实例初始化之后，在数据监听和事件配置之前触发。因此在这个事件中我们是获取不到 data 数据的。（2）created 钩子函数，在实例创建完成后触发，此时可以访问 data、methods 等属性。但这个时候组件还没有被挂载到页面中去，所以这个时候访问不到 $el 属性。一般我们可以在这个函数中进行一些页面初始化的工作，比如通过 ajax 请求数据来对页面进行初始化。（3）beforeMount 钩子函数，在组件被挂载到页面之前触发。在 beforeMount 之前，会找到对应的 template，并编译成 render 函数。（4）mounted 钩子函数，在组件挂载到页面之后触发。此时可以通过 DOM API 获取到页面中的 DOM 元素。（5）beforeUpdate 钩子函数，在响应式数据更新时触发，发生在虚拟 DOM 重新渲染和打补丁之前，这个时候我们可以对可能会被移除的元素做一些操作，比如移除事件监听器。（6）updated 钩子函数，虚拟 DOM 重新渲染和打补丁之后调用。（7）beforeDestroy 钩子函数，在实例销毁之前调用。一般在这一步我们可以销毁定时器、解绑全局事件等。（8）destroyed 钩子函数，在实例销毁之后调用，调用后，Vue 实例中的所有东西都会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。当我们使用 keep-alive 的时候，还有两个钩子函数，分别是 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。 详细资料可以参考：《vue 生命周期深入》《Vue 实例》 Vue 组件间的参数传递方式？1234567891011121314151617181920212223242526（1）父子组件间通信第一种方法是子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据。第二种是通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组件，这样也可以实现通信。第三种是使用 provider/inject，在父组件中通过 provider 提供变量，在子组件中通过 inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provider 中的数据。（2）兄弟组件间通信第一种是使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。第二种是通过 $parent.$refs 来获取到兄弟组件，也可以进行通信。（3）任意组件之间使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。 详细资料可以参考：《VUE 组件之间数据传递全集》 computed 和 watch 的差异？12345（1）computed 是计算一个新的属性，并将该属性挂载到 Vue 实例上，而 watch 是监听已经存在且已挂载到 Vue 实例上的数据，所以用 watch 同样可以监听 computed 计算属性的变化。（2）computed 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问 computed 属性，才会计算新的值。而 watch 则是当数据发生变化便会调用执行函数。（3）从使用场景上说，computed 适用一个数据被多个数据影响，而 watch 适用一个数据影响多个数据。 详细资料可以参考：《做面试的不倒翁：浅谈 Vue 中 computed 实现原理》《深入理解 Vue 的 watch 实现原理及其实现方式》 vue-router 中的导航钩子函数12345678（1）全局的钩子函数 beforeEach 和 afterEachbeforeEach 有三个参数，to 代表要进入的路由对象，from 代表离开的路由对象。next 是一个必须要执行的函数，如果不传参数，那就执行下一个钩子函数，如果传入 false，则终止跳转，如果传入一个路径，则导航到对应的路由，如果传入 error ，则导航终止，error 传入错误的监听函数。（2）单个路由独享的钩子函数 beforeEnter，它是在路由配置上直接进行定义的。（3）组件内的导航钩子主要有这三种：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave。它们是直接在路由组件内部直接进行定义的。 详细资料可以参考：《导航守卫》 $route 和 $router 的区别？1$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数。而 $router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。 vue 常用的修饰符？1.prevent: 提交事件不再重载页面；.stop: 阻止单击事件冒泡；.self: 当事件发生在该元素本身而不是子元素的时候会触发； vue 中 key 值的作用？12345vue 中 key 值的作用可以分为两种情况来考虑。第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当我们使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此我们可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。 详细资料可以参考：《Vue 面试中，经常会被问到的面试题 Vue 知识点整理》《Vue2.0 v-for 中 :key 到底有什么用？》《vue 中 key 的作用》 vue 中 mixin 和 mixins 区别？123mixin 用于全局混入，会影响到每个组件实例。mixins 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种逻辑等等。另外需要注意的是 mixins 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并 详细资料可以参考：《前端面试之道》《混入》 说说你对SPA单页面的理解，它的优缺点分别是什么？是什么 SPA（ single page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。 一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转 而页面的变化是利用路由机制实现 HTML 内容的变换，避免页面的重新加载。 优点 用户体验好，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染 减少了不必要的跳转和重复渲染，这样相对减轻了服务器的压力 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理 缺点 初次加载耗时多 不能使用浏览器的前进后退功能，由于单页应用在一个页面中显示所有的内容，所以，无法前进后退 不利于搜索引擎检索：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。 SPA首屏加载速度慢的怎么解决？首屏时间（First Contentful Paint），指的是浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容； 加载慢的原因 网络延时问题 资源文件体积是否过大 资源是否重复发送请求去加载了 加载脚本的时候，渲染内容堵塞了 常见的几种SPA首屏优化方式 减小入口文件积 静态资源本地缓存 UI框架按需加载 图片资源的压缩 组件重复打包 开启GZip压缩 使用SSR（想要具体了解可以点击SPA（单页应用）首屏加载速度慢的解决详解） Vue初始化过程中（new Vue(options)）都做了什么？ 处理组件配置项；初始化根组件时进行了选项合并操作，将全局配置合并到根组件的局部配置上；初始化每个子组件时做了一些性能优化，将组件配置对象上的一些深层次属性放到 vm.$options 选项中，以提高代码的执行效率；初始化组件实例的关系属性，比如 p a r e n t 、 parent、parent、children、r o o t 、 root、root、refs 等 处理自定义事件 调用 beforeCreate 钩子函数 初始化组件的 inject 配置项，得到 ret[key] = val 形式的配置对象，然后对该配置对象进行响应式处理，并代理每个 key 到 vm 实例上 数据响应式，处理 props、methods、data、computed、watch 等选项 解析组件配置项上的 provide 对象，将其挂载到 vm._provided 属性上 调用 created 钩子函数 如果发现配置项上有 el 选项，则自动调用 $mount 方法，也就是说有了 el 选项，就不需要再手动调用 $mount 方法，反之，没提供 el 选项则必须调用 $mount 接下来则进入挂载阶段 // core/instance/init.js export function initMixin (Vue: Class) { Vue.prototype._init = function (options?: Object) { const vm: Component = this vm._uid = uid++ // 如果是Vue的实例，则不需要被observe vm._isVue = true if (options &amp;&amp; options._isComponent) { // optimize internal component instantiation // since dynamic options merging is pretty slow, and none of the // internal component options needs special treatment. initInternalComponent(vm, options) } else { vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || {}, vm ) } if (process.env.NODE_ENV !== &apos;production&apos;) { initProxy(vm) } else { vm._renderProxy = vm } vm._self = vm initLifecycle(vm) initEvents(vm) callHook(vm, &apos;beforeCreate&apos;) initInjections(vm) // resolve injections before data/props initState(vm) initProvide(vm) // resolve provide after data/props callHook(vm, &apos;created&apos;) if (vm.$options.el) { vm.$mount(vm.$options.el) } } }对MVVM的理解？MVVM 由 Model、View、ViewModel 三部分构成，Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来；ViewModel 是一个同步View 和 Model的对象。 在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。 ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM， 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。 Vue数据双向绑定原理实现mvvm的数据双向绑定，是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来给各个属性添加setter，getter并劫持监听，在数据变动时发布消息给订阅者，触发相应的监听回调。就必须要实现以下几点：1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图 vue4 Vue的响应式原理什么是响应式，也即是说，数据发生改变的时候，视图会重新渲染，匹配更新为最新的值。Object.defineProperty 为对象中的每一个属性，设置 get 和 set 方法，每个声明的属性，都会有一个 专属的依赖收集器 subs，当页面使用到 某个属性时，触发 ObjectdefineProperty - get函数，页面的 watcher 就会被 放到 属性的依赖收集器 subs 中，在 数据变化时，通知更新；当数据改变的时候，会触发Object.defineProperty - set函数，数据会遍历自己的 依赖收集器 subs，逐个通知 watcher，视图开始更新； Vue3.x响应式数据原理Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。Proxy只会代理对象的第一层，Vue3是怎样处理这个问题的呢？判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。 Vue3.0 里为什么要用 Proxy API替代 defineProperty API？1.defineProperty API 的局限性最大原因是它只能针对单例属性做监听。Vue2.x中的响应式实现正是基于defineProperty中的descriptor，对 data 中的属性做了遍历 + 递归，为每个属性设置了 getter、setter。这也就是为什么 Vue 只能对 data 中预定义过的属性做出响应的原因。2.Proxy API的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作， 这就完全可以代理所有属性，将会带来很大的性能提升和更优的代码。Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。3.响应式是惰性的。在 Vue.js 2.x 中，对于一个深层属性嵌套的对象，要劫持它内部深层次的变化，就需要递归遍历这个对象，执行 Object.defineProperty 把每一层对象数据都变成响应式的，这无疑会有很大的性能消耗。在 Vue.js 3.0 中，使用 Proxy API 并不能监听到对象内部深层次的属性变化，因此它的处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部属性才会变成响应式，简单的可以说是按需实现响应式，减少性能消耗。 Proxy 与 Object.defineProperty 优劣对比1.Proxy 可以直接监听对象而非属性；2.Proxy 可以直接监听数组的变化；3.Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；4.Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；5.Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；6.Object.defineProperty 的优势如下:兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。 vue中组件的data为什么是一个函数？而new Vue 实例里，data 可以直接是一个对象我们知道，Vue组件其实就是一个Vue实例。 JS中的实例是通过构造函数来创建的，每个构造函数可以new出很多个实例，那么每个实例都会继承原型上的方法或属性。 Vue的data数据其实是Vue原型上的属性，数据存在于内存当中。Vue为了保证每个实例上的data数据的独立性，规定了必须使用函数，而不是对象。 因为使用对象的话，每个实例（组件）上使用的data数据是相互影响的，这当然就不是我们想要的了。对象是对于内存地址的引用，直接定义个对象的话组件之间都会使用这个对象，这样会造成组件之间数据相互影响。 使用函数后，使用的是data()函数，data()函数中的this指向的是当前实例本身，就不会相互影响了。 而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。 vue中data的属性可以和methods中方法同名吗，为什么？可以同名，methods的方法名会被data的属性覆盖；调试台也会出现报错信息，但是不影响执行；原因：源码定义的initState函数内部执行的顺序：props&gt;methods&gt;data&gt;computed&gt;watch 12345678910111213141516//initState部分源码export function initState (vm: Component) &#123; vm._watchers = [] const opts = vm.$options if (opts.props) initProps(vm, opts.props) if (opts.methods) initMethods(vm, opts.methods) if (opts.data) &#123; initData(vm) &#125; else &#123; observe(vm._data = &#123;&#125;, true /* asRootData */) &#125; if (opts.computed) initComputed(vm, opts.computed) if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch) &#125; &#125; vue中created与mounted区别在created阶段，实例已经被初始化，但是还没有挂载至el上，所以我们无法获取到对应的节点，但是此时我们是可以获取到vue中data与methods中的数据的；在mounted阶段，vue的template成功挂载在$el中，此时一个完整的页面已经能够显示在浏览器中，所以在这个阶段，可以调用节点了； 123456789101112131415161718192021//以下为测试vue部分生命函数，便于理解beforeCreate()&#123; //创建前 console.log(&apos;beforecreate:&apos;,document.getElementById(&apos;first&apos;))//null console.log(&apos;data:&apos;,this.text);//undefined this.sayHello();//error:not a function&#125;,created()&#123; //创建后 console.log(&apos;create:&apos;,document.getElementById(&apos;first&apos;))//null console.log(&apos;data:&apos;,this.text);//this.text this.sayHello();//this.sayHello()&#125;,beforeMount()&#123; //挂载前 console.log(&apos;beforeMount:&apos;,document.getElementById(&apos;first&apos;))//null console.log(&apos;data:&apos;,this.text);//this.text this.sayHello();//this.sayHello()&#125;,mounted()&#123; //挂载后 console.log(&apos;mounted:&apos;,document.getElementById(&apos;first&apos;))//&lt;p&gt;&lt;/p&gt; console.log(&apos;data:&apos;,this.text);//this.text this.sayHello();//this.sayHello()&#125; Vue中computed与method的区别相同点:如果作为模板的数据显示，二者能实现响应的功能，唯一不同的是methods定义的方法需要执行不同点：1.computed 会基于响应数据缓存，methods不会缓存；2.diff之前先看data里的数据是否发生变化，如果没有变化computed的方法不会执行，但methods里的方法会执行3.computed是属性调用，而methods是函数调用 虚拟DOM中key的作用简单的说：key是虚拟DOM对象的标识，在更新显示时key起着极其重要的作用。复杂的说：当状态中的数据发生了变化时，react会根据【新数据】生成【新的虚拟DOM】，随后React进行【新虚拟DOM】与【旧虚拟DOM】的diff比较，比较规则如下： 旧虚拟DOM中找到了与新虚拟DOM相同的key1.若虚拟DOM中的内容没有变，直接使用之前的真是DOM2.若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM旧虚拟DOM中未找到与新虚拟DOM相同的key1.根据数据创建新的真实DOM，随后渲染到页面 用index作为key可能会引发的问题若对数据进行：逆序添加/逆序删除等破坏顺序的操作，会产生没有必要的真实DOM更新，界面效果虽然没有问题，但是数据过多的话，会效率过低；如果结构中还包含输入类的DOM，会产生错误DOM更新，界面有问题；注意！如果不存在对数据的逆序操作，仅用于渲染表用于展示，使用index作为key是没有问题的。 Vue中watch用法详解在vue中，使用watch来监听数据的变化；1.监听的数据后面可以写成对象形式，包含handler方法，immediate和deep。2.immediate表示在watch中首次绑定的时候，是否执行handler，值为true则表示在watch中声明的时候，就立即执行handler方法，值为false，则和一般使用watch一样，在数据发生变化的时候才执行handler。3.当需要监听一个对象的改变时，普通的watch方法无法监听到对象内部属性的改变，只有data中的数据才能够监听到变化，此时就需要deep属性对对象进行深度监听。 123456789watch: &#123; name: &#123; handler(newName, oldName) &#123; &#125;, deep: true, immediate: true &#125; &#125; vue中对mixins的理解和使用mixins是一种分发 Vue 组件中可复用功能的非常灵活的方式。混合对象可以包含任意组件选项。当组件使用混合对象时，所有混合对象的选项将被混入该组件本身的选项。而mixins引入组件之后，则是将组件内部的内容如data等方法、method等属性与父组件相应内容进行合并。相当于在引入后，父组件的各种属性方法都被扩充了。可点击vue中对mixins的理解和使用的介绍作为参考 vue中的插槽点击Vue中组件神兵利器，插槽Slot！查看详解！ 为什么vue采用异步渲染vue是组件级更新，当前组件里的数据变了，它就会去更新这个组件。当数据更改一次组件就要重新渲染一次，性能不高，为了防止数据一更新就更新组件，所以做了个异步更新渲染。（核心的方法就是nextTick） 源码实现原理：当数据变化后会调用notify方法，将watcher遍历，调用update方法通知watcher进行更新，这时候watcher并不会立即去执行，在update中会调用queueWatcher方法将watcher放到了一个队列里，在queueWatcher会根据watcher的进行去重，多个属性依赖一个watcher，如果队列中没有该watcher就会将该watcher添加到队列中，然后通过nextTick异步执行flushSchedulerQueue方法刷新watcher队列。flushSchedulerQueue中开始会触发一个before的方法，其实就是beforeUpdate，然后watcher.run() 才开始真正执行watcher，执行完页面就渲染完成啦，更新完成后会调用updated钩子。 vue5 Vue 的异步更新机制是如何实现的？Vue 的异步更新机制的核心是利用了浏览器的异步任务队列来实现的，首选微任务队列，宏任务队列次之。 当响应式数据更新后，会调用 dep.notify 方法，通知 dep 中收集的 watcher 去执行 update 方法，watcher.update 将 watcher 自己放入一个 watcher 队列（全局的 queue 数组）。 然后通过 nextTick 方法将一个刷新 watcher 队列的方法（flushSchedulerQueue）放入一个全局的 callbacks 数组中。 如果此时浏览器的异步任务队列中没有一个叫 flushCallbacks 的函数，则执行 timerFunc 函数，将 flushCallbacks 函数放入异步任务队列。如果异步任务队列中已经存在 flushCallbacks 函数，等待其执行完成以后再放入下一个 flushCallbacks 函数。 flushCallbacks 函数负责执行 callbacks 数组中的所有 flushSchedulerQueue 函数。 flushSchedulerQueue 函数负责刷新 watcher 队列，即执行 queue 数组中每一个 watcher 的 run 方法，从而进入更新阶段，比如执行组件更新函数或者执行用户 watch 的回调函数。 vue为什么在 HTML 中监听事件？你可能注意到这种事件监听的方式违背了关注点分离 (separation of concern) 这个长期以来的优良传统。但不必担心，因为所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。实际上，使用 v-on 或 @ 有几个好处： 扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何清理它们。 Vue.set 改变数组和对象中的属性在一个组件实例中，只有在data里初始化的数据才是响应的，Vue不能检测到对象属性的添加或删除，没有在data里声明的属性不是响应的,所以数据改变了但是不会在页面渲染；解决办法：使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上 说说vue的生命周期的理解生命周期通俗说就是Vue实例从创建到销毁的过程，就是生命周期。beforecreate （初始化界面前）created （初始化界面后）beforemount （渲染界面前）mounted （渲染界面后）beforeUpdate （更新数据前）updated （更新数据后）beforedestory （卸载组件前）destroyed （卸载组件后）注意：面试官想听到的不只是你说出了以上八个钩子名称，而是每个阶段做了什么？可以收藏下图！ 第一次页面加载会触发哪几个钩子？第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子 vue-router有几种钩子函数？1.全局路由全局导航钩子主要有两种钩子：前置守卫(beforeEach)、后置钩子(afterEach) 2.路由独享的钩子单个路由独享的导航钩子，它是在路由配置上直接进行定义的 123456789routes: [ &#123; path: &apos;/file&apos;, component: File, beforeEnter: (to, from ,next) =&gt; &#123; //do something &#125; &#125; ] 3.组件内的导航钩子组件内的导航钩子主要有这三种：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave。他们是直接在路由组件内部直接进行定义的。ps:详细知识点可以点击路由导航守卫查看； vue路由跳转在Vue中，路由跳转通常使用vue-router插件来实现。以下是一些常见的路由跳转方法： 使用router-link组件创建链接进行导航： 1&lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt; 在Vue组件中使用this.$router.push方法进行编程式导航： 12345678910111213// 字符串this.$router.push(&apos;home&apos;)// 对象this.$router.push(&#123; path: &apos;home&apos; &#125;)// 带查询参数，变成 /register?plan=privatethis.$router.push(&#123; path: &apos;register&apos;, query: &#123; plan: &apos;private&apos; &#125;&#125;)created() &#123; // 当组件被创建时，访问查询参数 const empGroupName = this.$route.query.empGroupName; const empGroupId = this.$route.query.empGroupId;&#125;, 使用router-link的tag属性自定义标签类型： 1&lt;router-link to=&quot;/about&quot; tag=&quot;button&quot;&gt;About&lt;/router-link&gt; 使用router-link的replace属性避免在历史记录中留下记录： 1&lt;router-link to=&quot;/about&quot; replace&gt;About&lt;/router-link&gt; 在JavaScript中使用name属性进行导航（推荐）： 12// 使用路由name进行导航this.$router.push(&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;) 使用Vue Router的beforeEach钩子进行全局路由守卫： 12345router.beforeEach((to, from, next) =&gt; &#123; // 对路由进行某些操作，例如权限校验 // ... next(); // 必须调用该方法来resolve这个钩子&#125;) 以上是Vue路由跳转的一些常用方法，实际应用中可以根据需要选择合适的方式进行路由跳转。 vue-router路由跳转方式声明式（标签跳转） 12&lt;router-link :to=&quot;&#123;name:&apos;home&apos;&#125;&quot;&gt;&lt;/router-link&gt;&lt;router-link :to=&quot;&#123;path:&apos;/home&apos;&#125;&quot;&gt;&lt;/router-link&gt; 编程式（ js跳转） 123this.$router.push(&apos;/home&apos;)this.$router.push(&#123;name:&apos;home&apos;&#125;)this.$router.push(&#123;path:&apos;/home&apos;&#125;) vue-router路由传参router-link 进行页面按钮式路由跳转传参this.$router.push进行编程式路由跳转传参 Vuex是什么？怎么使用？Vuex是实现组件全局状态（数据）管理的一种机制，可以方便实现组件数据之间的共享；Vuex集中管理共享的数据，易于开发和后期维护；能够高效的实现组件之间的数据共享，提高开发效率；存储在Vuex的数据是响应式的，能够实时保持页面和数据的同步；Vuex重要核心属性包括：state,mutations,action,getters,modules. stateVuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。 mutationsmutations定义的方法动态修改Vuex 的 store 中的状态或数据。 actionactions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。 getters类似vue的计算属性，主要用来过滤一些数据。 modules项目特别复杂的时候，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理。ps:详细使用和对其各属性的理解可以参考以下文章！ 一文吃透Vuex3的状态管理 什么情况下使用 Vuex？如果应用够简单，最好不要使用 Vuex，一个简单的 store 模式即可；需要构建一个中大型单页应用时，使用Vuex能更好地在组件外部管理状态； Vuex和单纯的全局对象有什么区别？Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 为什么 Vuex 的 mutation 中不能做异步操作？每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。 axios 是什么，其特点和常用语法是什么？ Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。前端最流行的 ajax 请求库，react/vue 官方都推荐使用 axios 发 ajax 请求特点: 基于 promise 的异步 ajax 请求库，支持promise所有的API浏览器端/node 端都可以使用，浏览器中创建XMLHttpRequests支持请求／响应拦截器支持请求取消可以转换请求数据和响应数据，并对响应回来的内容自动转换成 JSON类型的数据批量发送多个请求安全性更高，客户端支持防御 XSRF，就是让你的每个请求都带一个从cookie中拿到的key, 根据浏览器同源策略，假冒的网站是拿不到你cookie中得key的，这样，后台就可以轻松辨别出这个请求是否是用户在假冒网站上的误导输入，从而采取正确的策略。常用语法：axios(config): 通用/最本质的发任意类型请求的方式axios(url[, config]): 可以只指定 url 发 get 请求axios.request(config): 等同于 axios(config)axios.get(url[, config]): 发 get 请求axios.delete(url[, config]): 发 delete 请求axios.post(url[, data, config]): 发 post 请求axios.put(url[, data, config]): 发 put 请求axios.defaults.xxx: 请求的默认全局配置axios.interceptors.request.use(): 添加请求拦截器axios.interceptors.response.use(): 添加响应拦截器axios.create([config]): 创建一个新的 axios(它没有下面的功能)axios.Cancel(): 用于创建取消请求的错误对象axios.CancelToken(): 用于创建取消请求的 token 对象axios.isCancel(): 是否是一个取消请求的错误axios.all(promises): 用于批量执行多个异步请求axios.spread(): 用来指定接收所有成功数据的回调函数的方法 对SSR有了解吗，它主要解决什么问题？Server-Side Rendering 我们称其为SSR，意为服务端渲染指由服务侧完成页面的 HTML 结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程； 解决了以下两个问题： seo：搜索引擎优先爬取页面HTML结构，使用ssr时，服务端已经生成了和业务想关联的HTML，有利于seo 首屏呈现渲染：用户无需等待页面所有js加载完成就可以看到页面视图（压力来到了服务器，所以需要权衡哪些用服务端渲染，哪些交给客户端） 缺点 复杂度：整个项目的复杂度 性能会受到影响 服务器负载变大，相对于前后端分离务器只需要提供静态资源来说，服务器负载更大，所以要慎重使用 Vue要做权限管理该怎么做？控制到按钮级别的权限怎么做？具体详解查看Vue要做权限管理该怎么做？控制到按钮级别的权限怎么做 Vue项目前端开发环境请求服务器接口跨域问题对于vue-cli 2.x版本在config文件夹配置服务器代理；对于vue-cli 3.x版本前端配置服务器代理在vue.config.js中设置服务器代理；如下图： target对应的属性值为你准备向后端服务器发送请求的主机+端口，含义为：相当于把前端发送请求的主机+端口自动替换成挂载的主机和端口，这样前后端的主机端口都一一就不会存在跨域问题；ws:表示WebSocket协议；changeOrigin:true;表示是否改变原域名；这个一定要选择为true;这样发送请求的时候就不会出现跨域问题了。 Vue3有了解过吗？能说说跟Vue2的区别吗？具体详解请点击Vue3有了解过吗？能说说跟Vue2的区别吗？ Vue 3.0 所采用的 Composition Api 与 Vue 2.x使用的Options Api 有什么区别？Options Api 包含一个描述组件选项（data、methods、props等）的对象 options；API开发复杂组件，同一个功能逻辑的代码被拆分到不同选项 ；使用mixin重用公用代码，也有问题：命名冲突，数据来源不清晰； Composition Api vue3 新增的一组 api，它是基于函数的 api，可以更灵活的组织组件的逻辑。解决options api在大型项目中，options api不好拆分和重用的问题。 vue 如何实现按需加载配合 webpack 设置123webpack 中提供了 require.ensure()来实现按需加载。以前引入路由是通过 import 这样的方式引入，改为 const 定义的方式进行引入。不进行页面按需加载引入方式：import home from &apos;../../common/home.vue&apos;进行页面按需加载的引入方式：const home = r =&gt; require.ensure( [], () =&gt; r (require(&apos;../../common/home.vue&apos;))) 在音乐 app 中使用的路由懒加载方式为： 1234567891011const Recommend = (resolve) =&gt; &#123; import(&apos;components/recommend/recommend&apos;).then((module) =&gt; &#123; resolve(module) &#125;)&#125;const Singer = (resolve) =&gt; &#123; import(&apos;components/singer/singer&apos;).then((module) =&gt; &#123; resolve(module) &#125;)&#125; 如何让 CSS 只在当前组件中起作用将当前组件的修改为 指令 v-el 的作用是什么?提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标.可以是 CSS 选择器，也可以是一个 HTMLElement 实例 vue-loader 是什么？使用它的用途有哪些？vue-loader 是解析 .vue 文件的一个加载器，将 template/js/style 转换成 js 模块。 用途：js 可以写 es6、style 样式可以 scss 或 less；template 可以加 jade 等。 vue怎么实现页面的权限控制利用 vue-router 的 beforeEach 事件，可以在跳转页面前判断用户的权限（利用 cookie 或 token），是否能够进入此页面，如果不能则提示错误或重定向到其他页面，在后台管理系统中这种场景经常能遇到。 watch的作用是什么watch 主要作用是监听某个数据值的变化。和计算属性相比除了没有缓存，作用是一样的。 借助 watch 还可以做一些特别的事情，例如监听页面路由，当页面跳转时，我们可以做相应的权限控制，拒绝没有权限的用户访问页面。 vue组件设计相关​ 1）用一些功能单一的小模块来组织应用，较小的模块更容易看懂、维护、复用和调试 （每个组件应该保持单一、独立、可复用、可测试）； ​ 2)组件命名应该遵从以下几点原则： ​ 有意义: 名字不要太详细，也不要太抽象。 ​ 短: 名字最好是2-3个单词。 ​ 可读的:容易让人能读出来以便我们可以更容易的讨论它。 ​ vue组件也应该遵循以下原则： ​ 遵从元素命名规范，包括连字符，不要使用保留字 ​ 为了在其他项目中复用，应该以某个模块名字作为命名空间。 ​ 3）把复杂的语法移动到methods或者计算属性中，避免使用行内表达式； ​ 4）保证组件的props简单，保证接口简单，便于开发理解维护，同时进行props限制，比如检查是否存在，设置默认值，设置类型校验等； ​ 参考链接：vue组件最佳实践 vue数据绑定原理 定义：vue的数据双向绑定是基于Object.defineProperty方法，通过定义data属性的get和set函数来监听数据对象的变化，一旦变化，vue利用发布订阅模式，通知订阅者执行回调函数，更新dom。 参考链接：vue数据绑定原理 vue父子组件和兄弟组件的通信问题；1）父子组件通信： 1、父组件使用 props 把数据传给子组件。 2、子组件使用 $emit 触发父组件的自定义事件。 2）兄弟组件通信： 创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。 1let Hub = new Vue(); //创建事件中心 组件1触发： 123methods: &#123; eve() &#123; Hub.$emit(&apos;change&apos;,&apos;hehe&apos;); &#125; //Hub触发事件&#125; 组件2接收: 12345created() &#123; Hub.$on(&apos;change&apos;, () =&gt; &#123; //Hub接收事件 this.msg = &apos;hehe&apos;; &#125;);&#125; vue的事件监听参考链接：事件监听 vue和react的对比参考链接：Vue.js与React的全面对比 vue和jquery的对比jQuery是使用选择器（$）选取DOM对象，对其进行赋值、取值、事件绑定等操作，其实和原生的HTML的区别只在于可以更方便的选取和操作DOM对象，而数据和界面是在一起的。比如需要获取label标签的内容：$(“lable”).val();,它还是依赖DOM元素的值。 Vue则是通过Vue对象将数据和View完全分离开来了。对数据进行操作不再需要引用相应的DOM对象，可以说数据和View是分离的，他们通过Vue对象这个vm实现相互的绑定。这就是传说中的MVVM。 vue适用的场景：复杂数据操作的后台页面，表单填写页面； jquery适用的场景：比如说一些html5的动画页面，一些需要js来操作页面样式的页面； 然而二者也是可以结合起来一起使用的，vue侧重数据绑定，jquery侧重样式操作，动画效果等，则会更加高效率的完成业务需求。 实现 Vue SSR其基本实现原理 app.js 作为客户端与服务端的公用入口，导出 Vue 根实例，供客户端 entry 与服务端 entry 使用。客户端 entry 主要作用挂载到 DOM 上，服务端 entry 除了创建和返回实例，还进行路由匹配与数据预获取。 webpack 为客服端打包一个 Client Bundle ，为服务端打包一个 Server Bundle 。 服务器接收请求时，会根据 url，加载相应组件，获取和解析异步数据，创建一个读取 Server Bundle 的 BundleRenderer，然后生成 html 发送给客户端。 客户端混合，客户端收到从服务端传来的 DOM 与自己的生成的 DOM 进行对比，把不相同的 DOM 激活，使其可以能够响应后续变化，这个过程称为客户端激活 。为确保混合成功，客户端与服务器端需要共享同一套数据。在服务端，可以在渲染之前获取数据，填充到 stroe 里，这样，在客户端挂载到 DOM 之前，可以直接从 store 里取数据。首屏的动态数据通过 window.__INITIAL_STATE__发送到客户端 Vue SSR 的实现，主要就是把 Vue 的组件输出成一个完整 HTML, vue-server-renderer 就是干这事的 Vue SSR需要做的事多点（输出完整 HTML），除了complier -&gt; vnode，还需如数据获取填充至 HTML、客户端混合（hydration）、缓存等等。相比于其他模板引擎（ejs, jade 等），最终要实现的目的是一样的，性能上可能要差点 Vue 组件 data 为什么必须是函数 每个组件都是 Vue 的实例。 组件共享 data 属性，当 data 的值是同一个引用类型的值时，改变其中一个会影响其他 Vue computed 实现 建立与其他属性（如：data、 Store）的联系； 属性改变后，通知计算属性重新计算 实现时，主要如下 初始化 data， 使用 Object.defineProperty 把这些属性全部转为 getter/setter。 初始化 computed, 遍历 computed 里的每个属性，每个 computed 属性都是一个 watch 实例。每个属性提供的函数作为属性的 getter，使用 Object.defineProperty 转化。 Object.defineProperty getter 依赖收集。用于依赖发生变化时，触发属性重新计算。 若出现当前 computed 计算属性嵌套其他 computed 计算属性时，先进行其他的依赖收集 Vue complier 实现 模板解析这种事，本质是将数据转化为一段 html ，最开始出现在后端，经过各种处理吐给前端。随着各种 mv* 的兴起，模板解析交由前端处理。 总的来说，Vue complier 是将 template 转化成一个 render 字符串。 可以简单理解成以下步骤： parse 过程，将 template 利用正则转化成 AST 抽象语法树。 optimize 过程，标记静态节点，后 diff 过程跳过静态节点，提升性能。 generate 过程，生成 render 字符串 怎么快速定位哪个组件出现性能问题用 timeline 工具。 大意是通过 timeline 来查看每个函数的调用时常，定位出哪个函数的问题，从而能判断哪个组件出了问题 1.那你能讲一讲 MVVM 吗？MVVM 是 Model-View-ViewModel 缩写，也就是把 MVC 中的 Controller 演变成 ViewModel。Model 层代表数据模型，View 代表 UI 组件， ViewModel 是 View 和 Model 层的桥梁，数据会绑定到 viewModel 层并自动将数据渲染到页面中，视图变化的时候会通知 viewModel 层更新数据。 2.简单说一下 Vue2.x 响应式数据原理Vue 在初始化数据时，会使用 Object.defineProperty 重新定义 data 中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的 watcher) 如果属性发生变化会通知相关依赖进行更新操作(发布订阅)。 3.那你知道 Vue3.x 响应式数据原理吗？(还好我有看，这个难不倒我) Vue3.x 改用 Proxy 替代 Object.defineProperty。因为 Proxy 可以直接监听对象和数组的变化，并且有多达 13 种拦截方法。 并且作为新标准将受到浏览器厂商重点持续的性能优化。 ❝ Proxy 只会代理对象的第一层，那么 Vue3 又是怎样处理这个问题的呢？❞ （很简单啊） 判断当前 Reflect.get 的返回值是否为 Object，如果是则再通过 reactive 方法做代理， 这样就实现了深度观测。 ❝ 监测数组的时候可能触发多次 get/set，那么如何防止触发多次呢？❞ 我们可以判断 key 是否为当前被代理对象 target 自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行 trigger。 面试官抬起了头。心里暗想 (这小子还行，比上两个强，应该是多多少少看过 Vue3 的源码了) 4.再说一下 vue2.x 中如何监测数组变化使用了函数劫持的方式，重写了数组的方法，Vue 将 data 中的数组进行了原型链重写，指向了自己定义的数组原型方法。 这样当调用数组 api 时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。 （能问到这的面试官都比较注重深度，这些常规操作要记牢） （原型链的细节可以参考我的另一篇专栏） 5.nextTick 知道吗，实现原理是什么？在下次 DOM 更新循环结束之后执行延迟回调。nextTick 主要使用了宏任务和微任务。根据执行环境分别尝试采用 Promise MutationObserver setImmediate 如果以上都不行则采用 setTimeout 定义了一个异步方法，多次调用 nextTick 会将方法存入队列中，通过这个异步方法清空当前队列。 （关于宏任务和微任务以及事件循环可以参考我的另两篇专栏） (看到这你就会发现，其实问框架最终还是考验你的原生 JavaScript 功底) 6.说一下 Vue 的生命周期beforeCreate 是 new Vue()之后触发的第一个钩子，在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问。 created 在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发 updated 函数。 可以做一些初始数据的获取，在当前阶段无法与 Dom 进行交互，如果非要想，可以通过 vm.$nextTick 来访问 Dom。 beforeMount 发生在挂载之前，在这之前 template 模板已导入渲染函数编译。而当前阶段虚拟 Dom 已经创建完成，即将开始渲染。 在此时也可以对数据进行更改，不会触发 updated。 mounted 在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom 节点，使用$refs 属性对 Dom 进行操作。 beforeUpdate 发生在更新之前，也就是响应式数据发生更新，虚拟 dom 重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。 updated 发生在更新完成之后，当前阶段组件 Dom 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。 beforeDestroy 发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。 destroyed 发生在实例销毁之后，这个时候只剩下了 dom 空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。 (关于 Vue 的生命周期详解感兴趣的也请移步我的另一篇专栏) 7.你的接口请求一般放在哪个生命周期中？接口请求一般放在 mounted 中，但需要注意的是服务端渲染时不支持 mounted，需要放到 created 中。 8.再说一下 Computed 和 WatchComputed 本质是一个具备缓存的 watcher，依赖的属性发生变化就会更新视图。适用于计算比较消耗性能的计算场景。 当表达式过于复杂时，在模板中放入过多逻辑会让模板难以维护，可以将复杂的逻辑放入计算属性中处理。 Watch 没有缓存性，更多的是观察的作用，可以监听某些数据执行回调。当我们需要深度监听对象中的属性时，可以打开 deep：true 选项， 这样便会对对象中的每一项进行监听。这样会带来性能问题，优化的话可以使用字符串形式监听，如果没有写到组件中，不要忘记使用 unWatch 手动注销哦。 9.说一下 v-if 和 v-show 的区别当条件不成立时，v-if 不会渲染 DOM 元素，v-show 操作的是样式(display)，切换当前 DOM 的显示和隐藏。 10.组件中的 data 为什么是一个函数？一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果 data 是对象的话，对象属于引用类型，会影响到所有的实例。 所以为了保证组件不同的实例之间 data 不冲突，data 必须是一个函数。 11.说一下 v-model 的原理v-model 本质就是一个语法糖，可以看成是 value + input 方法的语法糖。可以通过 model 属性的 prop 和 event 属性来进行自定义。 原生的 v-model，会根据标签的不同生成不同的事件和属性。 12.Vue 事件绑定原理说一下原生事件绑定是通过 addEventListener 绑定给真实元素的，组件事件绑定是通过 Vue 自定义的$on 实现的。 ❝ 面试官：(这小子基础还可以，接下来我得上上难度了） ❞ 13.Vue 模版编译原理知道吗，能简单说一下吗？简单说，Vue 的编译过程就是将 template 转化为 render 函数的过程。会经历以下阶段： 生成 AST 树 优化 codegen 首先解析模版，生成 AST 语法树(一种用 JavaScript 对象的形式来描述整个模板)。使用大量的正则表达式对模板进行解析， 遇到标签、文本的时候都会执行对应的钩子进行相关处理。 Vue 的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的 DOM 也不会变化。 那么优化过程就是深度遍历 AST 树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。 编译的最后一步是将优化后的 AST 树转换为可执行的代码。 ❝ 面试官：(精神小伙啊，有点东西，难度提升，不信难不倒你）❞ 14.Vue2.x 和 Vue3.x 渲染器的 diff 算法分别说一下简单来说，diff 算法有以下过程 同级比较，再比较子节点 先判断一方有子节点一方没有子节点的情况(如果新的 children 没有子节点，将旧的子节点移除) 比较都有子节点的情况(核心 diff) 递归比较子节点 正常 Diff 两个树的时间复杂度是 O(n^3)，但实际情况下我们很少会进行跨层级的移动 DOM，所以 Vue 将 Diff 进行了优化，从 O(n^3) -&gt; O(n)， 只有当新旧 children 都为多个子节点时才需要用核心的 Diff 算法进行同层级比较。 Vue2 的核心 Diff 算法采用了双端比较的算法，同时从新旧 children 的两端开始进行比较，借助 key 值找到可复用的节点，再进行相关操作。 相比 React 的 Diff 算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。 Vue3.x 借鉴了 ivi 算法和 inferno 算法 在创建 VNode 时就确定其类型，以及在 mount/patch 的过程中采用位运算来判断一个 VNode 的类型，在这个基础之上再配合核心的 Diff 算法， 使得性能上较 Vue2.x 有了提升。(实际的实现可以结合 Vue3.x 源码看。) 该算法中还运用了动态规划的思想求解最长递归子序列。 (看到这你还会发现，框架内无处不蕴藏着数据结构和算法的魅力) ❝ 面试官：(可以可以，看来是个苗子，不过自我介绍属实有些无聊，下一题) ❞ 15.再说一下虚拟 Dom 以及 key 属性的作用由于在浏览器中操作 DOM 是很昂贵的。频繁的操作 DOM，会产生一定的性能问题。这就是虚拟 Dom 的产生原因。 Vue2 的 Virtual DOM 借鉴了开源库 snabbdom 的实现。 Virtual DOM 本质就是用一个原生的 JS 对象去描述一个 DOM 节点。是对真实 DOM 的一层抽象。(也就是源码中的 VNode 类，它定义在 src/core/vdom/vnode.js 中。) VirtualDOM 映射到真实 DOM 要经历 VNode 的 create、diff、patch 等阶段。 「key 的作用是尽可能的复用 DOM 元素。」 新旧 children 中的节点只有顺序是不同的时候，最佳的操作应该是通过移动元素的位置来达到更新的目的。 需要在新旧 children 的节点中保存映射关系，以便能够在旧 children 的节点中找到可复用的节点。key 也就是 children 中节点的唯一标识。 16.keep-alive 了解吗？keep-alive 可以实现组件缓存，当组件切换时不会对当前组件进行卸载。 常用的两个属性 include/exclude，允许组件有条件的进行缓存。 两个生命周期 activated/deactivated，用来得知当前组件是否处于活跃状态。 keep-alive 的中还运用了 LRU(Least Recently Used)算法。 （又是数据结构与算法，原来算法在前端有这么多的应用） 17.Vue 中组件生命周期调用顺序说一下组件的调用顺序都是先父后子,渲染完成的顺序是先子后父。 组件的销毁操作是先父后子，销毁完成的顺序是先子后父。 加载渲染过程 父 beforeCreate-&gt;父 created-&gt;父 beforeMount-&gt;子 beforeCreate-&gt;子 created-&gt;子 beforeMount- &gt;子 mounted-&gt;父 mounted 子组件更新过程 父 beforeUpdate-&gt;子 beforeUpdate-&gt;子 updated-&gt;父 updated 父组件更新过程 父 beforeUpdate -&gt; 父 updated 销毁过程 父 beforeDestroy-&gt;子 beforeDestroy-&gt;子 destroyed-&gt;父 destroyed 18.Vue2.x 组件通信有哪些方式？父子组件通信 父-&gt;子 props，子-&gt;父 $on、$emit 获取父子组件实例 $parent、$children Ref 获取实例的方式调用组件的属性或者方法 Provide、inject 官方不推荐使用，但是写组件库时很常用 兄弟组件通信 Event Bus 实现跨组件通信 Vue.prototype.$bus = new Vue Vuex 跨级组件通信 Vuex $attrs、$listeners Provide、inject 19.SSR 了解吗？SSR 也就是服务端渲染，也就是将 Vue 在客户端把标签渲染成 HTML 的工作放在服务端完成，然后再把 html 直接返回给客户端。 SSR 有着更好的 SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制， 服务器端渲染只支持 beforeCreate 和 created 两个钩子，当我们需要一些外部扩展库时需要特殊处理， 服务端渲染应用程序也需要处于 Node.js 的运行环境。还有就是服务器会有更大的负载需求。 21.hash 路由和 history 路由实现原理说一下location.hash 的值实际就是 URL 中#后面的东西。 history 实际采用了 HTML5 中提供的 API 来实现，主要有 history.pushState()和 history.replaceState()。 面试官拿起旁边已经凉透的咖啡，喝了一口。(我难道问不倒这小子了么) 1.v-show 与 v-if 区别v-show 是css隐藏，v-if是直接销毁和创建，所以频繁切换的适合用v-show 2.计算属性和 watch 的区别计算属性是自动监听依赖值的变化，从而动态返回内容，监听是一个过程，在监听的值变化时，可以触发一个回调，并做一些事情。 所以区别来源于用法，只是需要动态值，那就用计算属性；需要知道值的改变后执行业务逻辑，才用 watch，用反或混用虽然可行，但都是不正确的用法。 说出一下区别会加分 computed 是一个对象时，它有哪些选项？ computed 和 methods 有什么区别？ computed 是否能依赖其它组件的数据？ watch 是一个对象时，它有哪些选项？ 有get和set两个选项 methods是一个方法，它可以接受参数，而computed不能，computed是可以缓存的，methods不会。 computed可以依赖其他computed，甚至是其他组件的data watch 配置 handler deep 是否深度 immeditate 是否立即执行 总结 当有一些数据需要随着另外一些数据变化时，建议使用computed。 当有一个通用的响应数据变化的时候，要执行一些业务逻辑或异步操作的时候建议使用watcher 3.事件修饰符绑定一个原生的click事件， 加native， 其他事件修饰符 stop（阻止事件冒泡） prevent（阻止默认事件） self（只有自己触发，子组件不会触发） 组合键 click.ctrl.exact 只有ctrl被按下的时候才触发 4.双向绑定的原理通过数据劫持和发布订阅模式方式实现的，核心的 API 是通过Object.defineProperty()来劫持各个属性的setter / getter，在数据变动时发布消息给订阅者，触发相应的监听回调，这也是为什么 Vue.js 2.x 不支持 IE8 的原因。要实现双向绑定，首先进行数据劫持，所以需要设置一个监听器Observer，用来监听所有属性。如果属性发生变化，就需要告诉订阅者Watcher看是否需要更新。因为订阅者很多，所以需要一个消息订阅器Dep来专门收集这些订阅者，然后在监听器和订阅者之间进行统一管理，最后需要一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令（v-model，v-on）对应初始化一个订阅者Watcheer ，并替换模板数据或绑定相应函数 官网解释：https://cn.vuejs.org/v2/guide/reactivity.html 5.怎么理解单项数据流这是关于组件通讯中父组件的prop传递给子组件，在子组件中不能更改prop，只能父组件更改prop，否则会报错。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。 一般来说，对于子组件想要更改父组件状态的场景，可以有两种方案： 在子组件的 data 中拷贝一份 prop，data 是可以修改的，但 prop 不能： exportdefault{props: {value:String}, data () {return{currentValue:this.value } }}复制代码 如果是对 prop 值的转换，可以使用计算属性： exportdefault{props: [‘size’],computed: {normalizedSize:function(){returnthis.size.trim().toLowerCase(); } }} 6.简述vue的状态管理并说明你在项目中哪些地方使用了component通过mapactions或者dispatch将方法类型和负载传给actions，actions接收到后进行业务处理通过commit将处理后的类型和负载传给mutations，mutations不做业务处理，只根据接收的类型和负载将state中的数据进行突变，component通过mapgetters拿到更新后的仓库数据。 在组件中用mapactions接管methods方法，用mapgetters接收computed计算属性，这样主要是为了action更简洁，便于后期迭代更新。以下通过官网例子进行加深理解： 7.简述下生命周期钩子vue实例从创建到销毁的过程，就是生命周期。从开始创建，初始化数据，编译模板，挂载DOM，渲染，更新再渲染，最后到销毁等一系列过程就是生命周期。 beforeCreate：数据观测和初始化事件还没开始 Created：完成数据观测，属性和方法的运算，初始化事件，$el属性还没显示出来 beforeMount：挂载前调用，相关的render第一次调用。实例已经完成编译模板，data里的数据和模板已经生成HTML，但没有讲HTML挂载到页面上 Mounted：el被新创建的Vm.$el替换，并挂载到实例上面调用。实例已经完成以下配置：用上面编译好的HTML内容替换el属性指向DOM元素。完成模板中HTML渲染到HTML页面中。此过程进行ajax交互。 beforeUpdate:发生在虚拟dom和打补丁之前，可以在该钩子中进一步修改状态，不会触发附加的冲渲染过程。 Updated：由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。 beforeDestroy（销毁前） 在实例销毁之前调用。实例仍然完全可用。 destroyed（销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 8.组件中如何通信九叔说要讲半小时左右：。。。。 父到子： 传&lt;子组件 :自定义属性=“父数据”&gt; 收：子组件选项props：【‘自定义属性’】 子到父： 父组件向子组件传递事件方法，子组件通过$emit触发事件，回调给父组件 非父子，兄弟组件通讯： 可以通过实例一个vue实例Bus作为媒介，要相互通信的兄弟组件之中，都引入Bus，然后通过分别调用Bus事件触发和监听来实现通信和参数传递。 组件通讯更详细解释 9.路由守卫是什么，有几种方式全局守卫，路由独享守卫，组件内部守卫； 全局守卫：router.beforeRouteEnter(to,from,next){前置守卫，进入} router.beforeRouterLeave(to,from,next){后置守卫，离开} to 目标路由 from 当前路由 next函数：next() == next(true) 运行跳转 next(false) 不让跳转 next(‘字符路径’)/next({对象路径}) 重定向 路由独享守卫：没有后置守卫1234567&#123; path: &apos;/foo&apos;, component: Foo, beforeEnter: (to, from, next) =&gt; &#123; // ... &#125;&#125; 组件内部守卫：123456789101112const Foo = &#123; template: `...`, beforeRouteEnter (to, from, next) &#123; 前置 // 在渲染该组件的对应路由被 confirm 前调用 // 不！能！获取组件实例 `this` // 因为当守卫执行前，组件实例还没被创建 &#125;, beforeRouteLeave (to, from, next) &#123; 后置 // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this` &#125;&#125; 10.vue的优化不支持低版本的浏览器，最低只支持到IE9； 不利于SEO的优化（如果要支持SEO，建议通过服务端来进行渲染组件）； 第一次加载首页耗时相对长一些； 不可以使用浏览器的导航按钮需要自行实现前进、后退 11.什么是插槽或内容分发 ，插槽有几种方式组件内部保留槽位: 具名槽位:&lt;slot name=槽名 匿名槽位: &lt;/..&gt; 调用组件插入内容: 内容 == dom | 组件 &lt;组件名&gt; &lt;template #槽名&gt; 内容 | &lt;组件名&gt; &lt;template v-slot:槽名&gt;内容 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译 12.简述下mvvm和MVCMVC： 1.View 传送指令到 Controller 2.Controller 完成业务逻辑后，要求 Model 改变状态 3.Model 将新的数据发送到 View，用户得到反馈 MVP： 各部分之间的通信，都是双向的。 View 与 Model 不发生联系，都通过 Presenter 传递。 View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。 MVVM： 和MVP很像，采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然 13.路由懒加载，异步路由，分片打包原理: 把组件封装到一个函数内部，路由激活时，调用该函数，函数内部 异步加载目标组件并返回 路由配置router.js: a) 123\\- import home from &quot;../components/home.vue&quot;\\+ const home =()=&gt;import(&quot;../components/home.vue&quot;);&#123;path:&apos;/home&apos;, component: home &#125; b) 1&#123;path:xxx, component: r =&gt; &#123; require([&apos;./login/Login&apos;], r) &#125;&#125; 17.如何自定义事件定义：vm.$on( ‘自定义事件名’|[‘自定义事件名1’,’自定义事件名2’], 回调(参数) ) 销毁：vm.$off( ‘自定义事件名’|[‘自定义事件名1’,’自定义事件名2’], 回调(参数) ) 触发: vm.$emit(自定义事件名1,参数) 自定义事件名： 使用 kebab-case 的事件名 场景： 在一个组件实例上手动侦听事件时 18.懒加载，按需加载，点击加载，滑动加载把组件加载封装在一个函数中，路由激活的时候调用这个函数，这个函数在运行的时候去加载这个组件。加载用import或者requireAPI 19.如何更改计算属性并响应式计算属性的set方法 img img 20.vue的diff算法突然发现弄懂这个就不是初级了。。。 https://juejin.im/post/5c97002b6fb9a070aa5cf60b 路由懒加载vue项目作为一个单页面应用，如果不对路由进行处理，在加载首页的时候，就会将所有组件全部加载，并向服务器请求数据，这必将拖慢加载速度；当打包构建应用时，Javascript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。 图片资源的压缩严格说来这一步不算在编码技术范围内，但是却对页面的加载速度影响很大，特别是对于移动端的项目来说。 对于非logo的图片文件，让UI设计师提供jpg格式的，不要用png 对于所有的图片文件，都可以在一个叫tinypng的网站上去压缩一下或采用webpack插件进行压缩 使用cdn 在Vue项目中，引入到工程中的所有js、css文件，编译时都会被打包进vendor.js，浏览器在加载该文件之后才能开始显示首屏。若是引入的库众多，那么vendor.js文件体积将会相当的大，影响首开的体验。 解决方法是，将引用的外部js、css文件剥离开来，不编译到vendor.js中，而是用资源的形式引用，这样浏览器可以使用多个线程异步将vendor.js、外部的js等加载下来，达到加速首开的目的。 外部的库文件，可以使用CDN资源，或者别的服务器资源等。 详述虚拟DOM第一种：1、state数据 2、JSX模板 3、 数据 + 模板 结合，生成真实的DOM -&gt; 视图 4、state发生了变化 5、数据 + 模板 结合，生成真实的DOM，替换原始的DOM 缺陷： 1、第一次生成了完整的DOM片段 2、第二次生成了完整的DOM片段 3、第二次的DOM替换第一次的DOM，非常耗费性能 第二种：1、state数据 2、JSX模板 3、数据 + 模板 结合， 生成真实的DOM -&gt; 视图 4、state发生变化 5、数据 + 模板 结合，生成真实的DOM，并不直接替换原始的DOM 6、新的DOM（DocumentFragment）和原始的DOM做比对，找差异 7、找出input框发生了变化 8、只用新的DOM中的input元素，替换掉老的DOM中input元素 缺陷： 虽然DOM只是局部替换，但是在比对时候的计算是比较耗费性能的，因此，性能的提升并不明显 第三种：1、state数据 2、JSX模板 3、数据 + 模板 生成虚拟DOM(虚拟DOM就是一个JS对象，用它来描述真实DOM)（损耗一点性能） 虚拟DOM：[‘div’, {id: ‘abc’}, [‘span’, ‘’, ‘hello world’]] 4、用虚拟DOM的结构生成真实的DOM -&gt; 视图显示 真实DOM： 5、state发生了变化 6、数据 + 模板 生成新的虚拟DOM：[‘div’, {id: ‘abc’}, [‘span’, ‘’, ‘hi world’]]（极大提升性能） 7、比较原始虚拟DOM和新的虚拟DOM的区别，找到的区别是span中的内容发生了变化（极大提升了性能） 8、直接操作DOM，改变span中的内容 总结： 减少了真实DOM的创建及对比，创建都是JS对象，对比的也都是JS的对象，在JS底层实现了极大的性能飞越 组件生成流程： JSX -&gt; JS对象(虚拟DOM) -&gt; 真实的DOM 用React.createElement改写JSX模板： JSX：return { item } JSX -&gt; JS对象(虚拟DOM) -&gt; 真实的DOM React.createElement(‘div’, {}, React.createElement(‘span’, {}, ‘item’)) JSX -&gt; createElement -&gt; JS对象(虚拟DOM) -&gt; 真实的DOM 虚拟DOM优点：1、性能提升了 2、它使得跨端应用得以实现，Ract Native React可以写原生应用了，得益于React中的虚拟DOM，如果没有虚拟DOM是不能写原生应用的。原生系统是不支持DOM不存在DOm这个概念的，但是支持虚拟DOM（虚拟DOM就是一个JS对象）；虚拟DOM可以在浏览器端被解析为真实的DOM，在原生端可以被解析原生所支持的组件等格式 详述虚拟DOM中的diff算法虚拟DOM对比时，会用到diff算法 虚拟DOM什么时候会被比对？ 当数据发生变化的时候就会被比对 那什么时候数据会发生改变呢？ 要么改变了state，要么改变了props（props的改变其实是他的父组件的state发生了改变） setState方法，其实是异步的，为什么是异步的？实际为了提升React底层的性能，假设：调用三次setState变更三组数据，大家想页面会怎么做或者说React会怎么做？我们想的是React可能会做三次比对更新三次视图。又假设三次更新间隔非常小，这样会耗费性能，React可以把三次合并为一次，只去做一次虚拟DOM的比对，然后更新一次视图，这样的话就可以省去两次比对性能上的耗费。 1、说说你对 SPA 单页面的理解，它的优缺点分别是什么？SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。 优点： 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染； 基于上面一点，SPA 相对对服务器压力小； 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理； 缺点： 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载； 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理； SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。 2、v-show 与 v-if 有什么区别？v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。 所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。 3、Class 与 Style 如何动态绑定？Class 可以通过对象语法和数组语法进行动态绑定： 对象语法： 1234567&lt;div v-bind:class=&quot;&#123; active: isActive, &apos;text-danger&apos;: hasError &#125;&quot;&gt;&lt;/div&gt;data: &#123; isActive: true, hasError: false&#125;复制代码 数组语法： 1234567&lt;div v-bind:class=&quot;[isActive ? activeClass : &apos;&apos;, errorClass]&quot;&gt;&lt;/div&gt;data: &#123; activeClass: &apos;active&apos;, errorClass: &apos;text-danger&apos;&#125;复制代码 Style 也可以通过对象语法和数组语法进行动态绑定： 对象语法： 1234567&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt;data: &#123; activeColor: &apos;red&apos;, fontSize: 30&#125;复制代码 数组语法： 1234567891011&lt;div v-bind:style=&quot;[styleColor, styleSize]&quot;&gt;&lt;/div&gt;data: &#123; styleColor: &#123; color: &apos;red&apos; &#125;, styleSize:&#123; fontSize:&apos;23px&apos; &#125;&#125;复制代码 4、怎样理解 Vue 的单向数据流？所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。 额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。 有两种常见的试图改变一个 prop 的情形 : 这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。 在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值： 1234567props: [&apos;initialCounter&apos;],data: function () &#123; return &#123; counter: this.initialCounter &#125;&#125;复制代码 这个 prop 以一种原始的值传入且需要进行转换。 在这种情况下，最好使用这个 prop 的值来定义一个计算属性 1234567props: [&apos;size&apos;],computed: &#123; normalizedSize: function () &#123; return this.size.trim().toLowerCase() &#125;&#125;复制代码 5、computed 和 watch 的区别和运用的场景？computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值； watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作； 运用场景： 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算； 当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。 7、谈谈你对 Vue 生命周期的理解？（1）生命周期是什么？ Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。 （2）各个生命周期的作用 生命周期 描述 beforeCreate 组件实例被创建之初，组件的属性生效之前 created 组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用 beforeMount 在挂载开始之前被调用：相关的 render 函数首次被调用 mounted el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子 beforeUpdate 组件数据更新之前调用，发生在虚拟 DOM 打补丁之前 update 组件数据更新之后 activited keep-alive 专属，组件被激活时调用 deactivated keep-alive 专属，组件被销毁时调用 beforeDestory 组件销毁前调用 destoryed 组件销毁后调用 （3）生命周期示意图 8、Vue 的父组件和子组件生命周期钩子函数执行顺序？Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分： 加载渲染过程 父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted 子组件更新过程 父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated 父组件更新过程 父 beforeUpdate -&gt; 父 updated 销毁过程 父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed 9、在哪个生命周期内调用异步请求？可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点： 能更快获取到服务端数据，减少页面 loading 时间； ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性； 10、在什么阶段才能访问操作DOM？在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 DOM。vue 具体的生命周期示意图可以参见如下，理解了整个生命周期各个阶段的操作，关于生命周期相关的面试题就难不倒你了。 11、父组件可以监听到子组件的生命周期吗？比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现： 12345678// Parent.vue&lt;Child @mounted=&quot;doSomething&quot;/&gt; // Child.vuemounted() &#123; this.$emit(&quot;mounted&quot;);&#125;复制代码 以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示： 12345678910111213141516// Parent.vue&lt;Child @hook:mounted=&quot;doSomething&quot; &gt;&lt;/Child&gt;doSomething() &#123; console.log(&apos;父组件监听到 mounted 钩子函数 ...&apos;);&#125;, // Child.vuemounted()&#123; console.log(&apos;子组件触发 mounted 钩子函数 ...&apos;);&#125;, // 以上输出顺序为：// 子组件触发 mounted 钩子函数 ...// 父组件监听到 mounted 钩子函数 ... 复制代码 当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。 12、谈谈你对 keep-alive 的了解？keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染DOM ，其有以下特性： 一般结合路由和动态组件一起使用，用于缓存组件； &lt; keep-alive &gt; 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。 提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高； 对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。 13、组件中 data 为什么是一个函数？ 为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？ 1234567891011121314151617// datadata() &#123; return &#123; message: &quot;子组件&quot;, childName:this.name &#125;&#125;// new Vuenew Vue(&#123; el: &apos;#app&apos;, router, template: &apos;&lt;App/&gt;&apos;, components: &#123;App&#125;&#125;)复制代码 因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。 14、v-model 的原理？我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件： text 和 textarea 元素使用 value 属性和 input 事件； checkbox 和 radio 使用 checked 属性和 change 事件； select 字段将 value 作为 prop 并将 change 作为事件。 以 input 表单元素为例： 123456&lt;input v-model=&apos;something&apos;&gt; 相当于&lt;input v-bind:value=&quot;something&quot; v-on:input=&quot;something = $event.target.value&quot;&gt;复制代码 如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示： 123456789101112131415父组件：&lt;ModelChild v-model=&quot;message&quot;&gt;&lt;/ModelChild&gt;子组件：&lt;div&gt;&#123;&#123;value&#125;&#125;&lt;/div&gt;props:&#123; value: String&#125;,methods: &#123; test1()&#123; this.$emit(&apos;input&apos;, &apos;小红&apos;) &#125;,&#125;,复制代码 15、Vue 组件间通信有哪几种方式？Vue 组件间通信是面试常考的知识点之一，这题有点类似于开放题，你回答出越多方法当然越加分，表明你对 Vue 掌握的越熟练。Vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。 （1）props / $emit 适用 父子组件通信 这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。 （2）ref 与 $parent / $children 适用 父子组件通信 ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例 $parent / $children：访问父 / 子实例 （3）EventBus （$emit / $on） 适用于 父子、隔代、兄弟组件通信 这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。 （4）$attrs/$listeners 适用于 隔代组件通信 $attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind=&quot;$attrs&quot; 传入内部组件。通常配合 inheritAttrs 选项一起使用。 $listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=&quot;$listeners&quot; 传入内部组件 （5）provide / inject 适用于 隔代组件通信 祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。 provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。 （6）Vuex 适用于 父子、隔代、兄弟组件通信 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。 Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。 16、你使用过 Vuex 吗？Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。 （1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 （2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。 主要包括以下几个模块： State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。 Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。 Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。 Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。 Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。 17、使用过 Vue SSR 吗？说说 SSR？ Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。 即：SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。 服务端渲染 SSR 的优缺点如下： （1）服务端渲染的优点： 更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面； 更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间； （2) 服务端渲染的缺点： 更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境； 更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。 如果没有 SSR 开发经验的同学，可以参考本文作者的另一篇 SSR 的实践文章《Vue SSR 踩坑之旅》，里面 SSR 项目搭建以及附有项目源码。 18、vue-router 路由模式有几种？vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示： 12345678910111213141516switch (mode) &#123; case &apos;history&apos;: this.history = new HTML5History(this, options.base) break case &apos;hash&apos;: this.history = new HashHistory(this, options.base, this.fallback) break case &apos;abstract&apos;: this.history = new AbstractHistory(this, options.base) break default: if (process.env.NODE_ENV !== &apos;production&apos;) &#123; assert(false, `invalid mode: $&#123;mode&#125;`) &#125;&#125;复制代码 其中，3 种路由模式的说明如下： hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器； history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式； abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式. 19、能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？（1）hash 模式的实现原理 早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 ‘#search’： 12https://www.word.com#search复制代码 hash 路由模式的实现主要是基于下面几个特性： URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送； hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换； 可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值； 我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。 （2）history 模式的实现原理 HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示： 123window.history.pushState(null, null, path);window.history.replaceState(null, null, path);复制代码 history 路由模式的实现主要基于存在下面几个特性： pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ； 我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）； history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。 20、什么是 MVVM？Model–View–ViewModel （MVVM） 是一个软件架构设计模式，由微软 WPF 和 Silverlight 的架构师 Ken Cooper 和 Ted Peters 开发，是一种简化用户界面的事件驱动编程方式。由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于2005年在他的博客上发表 MVVM 源自于经典的 Model–View–Controller（MVC）模式 ，MVVM 的出现促进了前端开发与后端业务逻辑的分离，极大地提高了前端开发效率，MVVM 的核心是 ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。如下图所示： （1）View 层 View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。 （2）Model 层 Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。 （3）ViewModel 层 ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的，比如页面的这一块展示什么，而页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互），视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。 MVVM 框架实现了双向绑定，这样 ViewModel 的内容会实时展现在 View 层，前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新。这样 View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。 我们以下通过一个 Vue 实例来说明 MVVM 的具体实现，有 Vue 开发经验的同学应该一目了然： （1）View 层 12345&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;button v-on:click=&quot;showMessage()&quot;&gt;Click me&lt;/button&gt;&lt;/div&gt;复制代码 （2）ViewModel 层 1234567891011121314151617181920212223var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; // 用于描述视图状态 message: &apos;Hello Vue!&apos;, &#125;, methods: &#123; // 用于描述视图行为 showMessage()&#123; let vm = this; alert(vm.message); &#125; &#125;, created()&#123; let vm = this; // Ajax 获取 Model 层的数据 ajax(&#123; url: &apos;/your/server/data/api&apos;, success(res)&#123; vm.message = res; &#125; &#125;); &#125;&#125;)复制代码 （3） Model 层 123456789&#123; &quot;url&quot;: &quot;/your/server/data/api&quot;, &quot;res&quot;: &#123; &quot;success&quot;: true, &quot;name&quot;: &quot;IoveC&quot;, &quot;domain&quot;: &quot;www.cnblogs.com&quot; &#125;&#125;复制代码 21、Vue 是如何实现数据双向绑定的？Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据，如下图所示： 即： 输入框内容变化时，Data 中的数据同步变化。即 View =&gt; Data 的变化。 Data 中的数据变化时，文本节点的内容同步变化。即 Data =&gt; View 的变化。 其中，View 变化更新 Data ，可以通过事件监听的方式来实现，所以 Vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View。 Vue 主要通过以下 4 个步骤来实现数据双向绑定的： 实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。 实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。 实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。 实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。 以上四个步骤的流程图表示如下，如果有同学理解不大清晰的，可以查看作者专门介绍数据双向绑定的文章《0 到 1 掌握：Vue 核心之数据双向绑定》，有进行详细的讲解、以及代码 demo 示例。 22、Vue 框架怎么实现对象和数组的监听？如果被问到 Vue 怎么实现数据双向绑定，大家肯定都会回答 通过 Object.defineProperty() 对数据进行劫持，但是 Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持，同理无法对数组进行劫持，但是我们在使用 Vue 框架中都知道，Vue 能检测到对象和数组（部分方法的操作）的变化，那它是怎么实现的呢？我们查看相关代码如下： 123456789101112131415 /** * Observe a list of Array items. */ observeArray (items: Array&lt;any&gt;) &#123; for (let i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) // observe 功能为监测数据的变化 &#125; &#125; /** * 对属性进行递归遍历 */ let childOb = !shallow &amp;&amp; observe(val) // observe 功能为监测数据的变化复制代码 通过以上 Vue 源码部分查看，我们就能知道 Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。 23、Proxy 与 Object.defineProperty 优劣对比Proxy 的优势如下: Proxy 可以直接监听对象而非属性； Proxy 可以直接监听数组的变化； Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的； Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改； Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利； Object.defineProperty 的优势如下: 兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。 25、虚拟 DOM 的优缺点？优点： 保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限； 无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率； 跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。 缺点: 无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。 26、虚拟 DOM 实现原理？虚拟 DOM 的实现原理主要包括以下 3 部分： 用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象； diff 算法 — 比较两棵虚拟 DOM 树的差异； pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。 如果对以上 3 个部分还不是很了解的同学，可以查看本文作者写的另一篇详解虚拟 DOM 的文章《深入剖析：Vue核心之虚拟DOM》 27、Vue 中的 key 有什么作用？key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。Vue 的 diff 过程可以概括为：oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex 和 newStartIndex、newEndIndex，它们会新节点和旧节点会进行两两对比，即一共有4种比较方式：newStartIndex 和oldStartIndex 、newEndIndex 和 oldEndIndex 、newStartIndex 和 oldEndIndex 、newEndIndex 和 oldStartIndex，如果以上 4 种比较都没匹配，如果设置了key，就会用 key 再进行比较，在比较的过程中，遍历会往中间靠，一旦 StartIdx &gt; EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。具体有无 key 的 diff 过程，可以查看作者写的另一篇详解虚拟 DOM 的文章《深入剖析：Vue核心之虚拟DOM》 所以 Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速 更准确：因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。 更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快，源码如下： 12345678910function createKeyToOldIdx (children, beginIdx, endIdx) &#123; let i, key const map = &#123;&#125; for (i = beginIdx; i &lt;= endIdx; ++i) &#123; key = children[i].key if (isDef(key)) map[key] = i &#125; return map&#125;复制代码 28、你有对 Vue 项目进行哪些优化？如果没有对 Vue 项目没有进行过优化总结的同学，可以参考本文作者的另一篇文章《 Vue 项目性能优化 — 实践指南 》，文章主要介绍从 3 个大方面，22 个小方面详细讲解如何进行 Vue 项目的优化。 （1）代码层面的优化 v-if 和 v-show 区分使用场景 computed 和 watch 区分使用场景 v-for 遍历必须为 item 添加 key，且避免同时使用 v-if 长列表性能优化 事件的销毁 图片资源懒加载 路由懒加载 第三方插件的按需引入 优化无限列表性能 服务端渲染 SSR or 预渲染 （2）Webpack 层面的优化 Webpack 对图片进行压缩 减少 ES6 转为 ES5 的冗余代码 提取公共代码 模板预编译 提取组件的 CSS 优化 SourceMap 构建结果输出分析 Vue 项目的编译优化 （3）基础的 Web 技术的优化 开启 gzip 压缩 浏览器缓存 CDN 的使用 使用 Chrome Performance 查找性能瓶颈 29、对于即将到来的 vue3.0 特性你有什么了解的吗？Vue 3.0 正走在发布的路上，Vue 3.0 的目标是让 Vue 核心变得更小、更快、更强大，因此 Vue 3.0 增加以下这些新特性： （1）监测机制的改变 3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。这消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制： 只能监测属性，不能监测对象 检测属性的添加和删除； 检测数组索引和长度的变更； 支持 Map、Set、WeakMap 和 WeakSet。 新的 observer 还提供了以下特性： 用于创建 observable 的公开 API。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。 默认采用惰性观察。在 2.x 中，不管反应式数据有多大，都会在启动时被观察到。如果你的数据集很大，这可能会在应用启动时带来明显的开销。在 3.x 中，只观察用于渲染应用程序最初可见部分的数据。 更精确的变更通知。在 2.x 中，通过 Vue.set 强制添加新属性将导致依赖于该对象的 watcher 收到变更通知。在 3.x 中，只有依赖于特定属性的 watcher 才会收到通知。 不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 prop 传递或 Vuex 状态树以外的变化。 更好的调试功能：我们可以使用新的 renderTracked 和 renderTriggered 钩子精确地跟踪组件在什么时候以及为什么重新渲染。 （2）模板 模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。 同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。 （3）对象式的组件声明方式 vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易。 此外，vue 的源码也改用了 TypeScript 来写。其实当代码的功能复杂之后，必须有一个静态类型系统来做一些辅助管理。现在 vue3.0 也全面改用 TypeScript 来重写了，更是使得对外暴露的 api 更容易结合 TypeScript。静态类型系统对于复杂代码的维护确实很有必要。 （4）其它方面的更改 vue3.0 的改变是全面的，上面只涉及到主要的 3 个方面，还有一些其他的更改： 支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。 支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。 基于 treeshaking 优化，提供了更多的内置功能。 30、说说你使用 Vue 框架踩过最大的坑是什么？怎么解决的？本题为开放题目，欢迎大家在评论区畅所欲言，分享自己的踩坑、填坑经历，提供前车之鉴，避免大伙再次踩坑 ~ 链接：https://juejin.cn/post/6844903918753808398","categories":[{"name":"前端面试题","slug":"前端面试题","permalink":"https://qw8.github.io/categories/前端面试题/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://qw8.github.io/tags/vue/"},{"name":"MVVM","slug":"MVVM","permalink":"https://qw8.github.io/tags/MVVM/"}]},{"title":"vue全家桶","slug":"knowledges/vue全家桶","date":"2024-03-08T12:34:52.000Z","updated":"2024-03-28T18:15:14.000Z","comments":true,"path":"/knowledges/vue-quan-jia-tong.html","link":"","permalink":"https://qw8.github.io/knowledges/vue-quan-jia-tong.html","excerpt":"","text":"vue-routervue-router 有哪几种导航钩子（ 导航守卫 ）？答案：三种 第一种是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。第二种：组件内的钩子；第三种：单独路由独享组件 怎么定义 vue-router 的动态路由？怎么获取传过来的动态参数？答案： 答：在 router 目录下的 index.js 文件中，对 path 属性加上/:id。 使用 router 对象的 params.id vue路由实现原理?或 vue-router原理?说简单点，vue-router的原理就是通过对URL地址变化的监听，继而对不同的组件进行渲染。每当URL地址改变时，就对相应的组件进行渲染。原理是很简单，实现方式可能有点复杂，主要有hash模式和history模式。如果想了解得详细点，建议百度或者阅读源码。 vue-router获取自定义参数传值： 123&gt; this.$router.push(name:&quot;test&quot;,params:&#123;data:&quot;test&quot;&#125;);&gt; this.$router.push(path:&quot;/test&quot;,query:&#123;data:&quot;test&quot;&#125;); 取值（与传值一一对应）： $route.params 类型: Object 一个 key/value 对象，包含了动态片段和全匹配片段，如果没有路由参数，就是一个空对象。 this.$route.params.data //“test” $route.query 类型: Object 一个 key/value 对象，表示 URL 查询参数。例如，对于路径 /foo?user=1，则有 $route.query.user == 1，如果没有查询参数，则是个空对象。 this.$route.query.data //“test” ​ vue-router 路由模式（url中#号的解析）​ 参考链接：vueRouter - mode API ​ 1）Hash模式：使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器。（URL中带有#号）： http://localhost:8080/#/ ​ 2）History模式：依赖HTML5 History API 和服务器配置。HTML5 History模式，(URL中不带有#号）: export default new Router ({ ​ mode: ‘history’, ​ routes: [ { ​ path: ‘/‘, ​ name: ‘/‘, ​ component: main ​ } ] }) ​ 3）Abstract模式：支持所有javascript运行模式，如 Node.js 服务器端。如果发现没有浏览器的API，路由会自动强制进入这个模式。 vue-router的go相关 router.go(n)：类似 window.history.go(n)，在 history 记录中向前或后退n步(n为int类型) router.push(location)：导航到不同的 URL，则使用 router.push 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。 router.replace(location)：跟 router.push 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。 vuexvuex 工作原理详解vuex 整体思想诞生于 flux,可其的实现方式完完全全的使用了 vue 自身的响应式设计，依赖监听、依赖收集都属于 vue 对对象 Property set get 方法的代理劫持。最后一句话结束 vuex 工作原理，vuex 中的 store 本质就是没有 template 的隐藏着的 vue 组件； 解析：vuex的原理其实非常简单，它为什么能实现所有的组件共享同一份数据？因为vuex生成了一个store实例，并且把这个实例挂在了所有的组件上，所有的组件引用的都是同一个store实例。store实例上有数据，有方法，方法改变的都是store实例上的数据。由于其他组件引用的是同样的实例，所以一个组件改变了store上的数据， 导致另一个组件上的数据也会改变，就像是一个对象的引用。 vuex 是什么？怎么使用？哪种功能场景使用它？vue 框架中状态管理。在 main.js 引入 store，注入。新建一个目录 store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车 main.js: 1234567import store from &apos;./store&apos;new Vue(&#123;el:&apos;#app&apos;,store&#125;) vuex 有哪几种属性？有五种，分别是 State、 Getter、Mutation 、Action、 Module 123456789101112vuex的State特性A、Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于一般Vue对象里面的dataB、state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新C、它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中· vuex的Getter特性A、getters 可以对State进行计算操作，它就是Store的计算属性B、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用C、 如果一个状态只在一个组件内使用，是可以不用getters· vuex的Mutation特性Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态；Action 可以包含任意异步操作。 不用 Vuex 会带来什么问题？可维护性会下降，想修改数据要维护三个地方； 可读性会下降，因为一个组件里的数据，根本就看不出来是从哪来的； 增加耦合，大量的上传派发，会让耦合性大大增加，本来 Vue 用 Component 就是为了减少耦合，现在这么用，和组件化的初衷相背。 vuex的原理​ 参考链接：到底vuex是什么 vuex的action和mutation的异步操作和同步操作问题​ 参考链接：vuex2.0 基本使用(2) — mutation 和 action vue-cli构建的 vue-cli 工程都到了哪些技术，它们的作用分别是什么？1、vue.js：vue-cli 工程的核心，主要特点是 双向数据绑定 和 组件系统。 2、vue-router：vue 官方推荐使用的路由框架。 3、vuex：专为 Vue.js 应用项目开发的状态管理器，主要用于维护 vue 组件间共用的一些 变量 和 方法。 4、axios（ 或者 fetch 、ajax ）：用于发起 GET 、或 POST 等 http 请求，基于 Promise 设计。 5、vux 等：一个专为 vue 设计的移动端 UI 组件库。 6、创建一个 emit.js 文件，用于 vue 事件机制的管理。 7、webpack：模块加载和 vue-cli 工程打包器。 vue-cli 工程常用的 npm 命令有哪些？ 答案：npm install、npm run dev、npm run build –report等 解析： 下载 node_modules 资源包的命令：npm install 启动 vue-cli 开发环境的 npm 命令：npm run dev vue-cli 生成 生产环境部署资源 的 npm 命令：npm run build 用于查看 vue-cli 生产环境部署资源文件大小的 npm 命令：npm run build –report，此命令必答 在浏览器上自动弹出一个 展示 vue-cli 工程打包后 app.js、manifest.js、vendor.js 文件里面所包含代码的页面。可以具此优化 vue-cli 生产环境部署的静态资源，提升 页面 的加载速度。 请说出 vue-cli 工程中每个文件夹和文件的用处vue-cli目录解析： build 文件夹：用于存放 webpack 相关配置和脚本。开发中仅 偶尔使用 到此文件夹下 webpack.base.conf.js 用于配置 less、sass等css预编译库，或者配置一下 UI 库。 config 文件夹：主要存放配置文件，用于区分开发环境、线上环境的不同。 常用到此文件夹下 config.js 配置开发环境的 端口号、是否开启热加载 或者 设置生产环境的静态资源相对路径、是否开启gzip压缩、npm run build 命令打包生成静态资源的名称和路径等。 dist 文件夹：默认 npm run build 命令打包生成的静态资源文件，用于生产部署。 node_modules：存放npm命令下载的开发环境和生产环境的依赖包。 src: 存放项目源码及需要引用的资源文件。 src下assets：存放项目中需要用到的资源文件，css、js、images等。 src下componets：存放vue开发中一些公共组件：header.vue、footer.vue等。 src下emit：自己配置的vue集中式事件管理机制。 src下router：vue-router vue路由的配置文件。 src下service：自己配置的vue请求后台接口方法。 src下page：存在vue页面组件的文件夹。 src下util：存放vue开发过程中一些公共的.js方法。 src下vuex：存放 vuex 为vue专门开发的状态管理器。 src下app.vue：使用标签渲染整个工程的.vue组件。 src下main.js：vue-cli工程的入口文件。 index.html：设置项目的一些meta头信息和提供用于挂载 vue 节 package.json：用于 node_modules资源部 和 启动、打包项目的 npm 命令管理。 config 文件夹 下 index.js 的对于工程 开发环境 和 生产环境 的配置123456789101112build 对象下 对于 生产环境 的配置：index：配置打包后入口.html文件的名称以及文件夹名称assetsRoot：配置打包后生成的文件名称和路径assetsPublicPath：配置 打包后 .html 引用静态资源的路径，一般要设置成 &quot;./&quot;productionGzip：是否开发 gzip 压缩，以提升加载速度dev 对象下 对于 开发环境 的配置：port：设置端口号autoOpenBrowser：启动工程时，自动打开浏览器proxyTable：vue设置的代理，用以解决 跨域 问题 vue-cli 中常用到的加载器1.安装 sass: 2.安装 axios: 3.安装 mock: 4.安装 lib-flexible: –实现移动端自适应 5.安装 sass-resourses-loader vue.cli 中怎样使用自定义的组件？有遇到过哪些问题吗？第一步：在 components 目录新建你的组件文件（如：indexPage.vue），script 一定要 export default {} 第二步：在需要用的页面（组件）中导入：import indexPage from ‘@/components/indexPage.vue’ 第三步：注入到 vue 的子组件的 components 属性上面,components:{indexPage} 第四步：在 template 视图 view 中使用 遇到的问题：例如有 indexPage 命名，使用的时候则 index-page babel相关​ 参考链接：Babel 从入门到插件开发 ​ Babel lodash相关​ 参考链接：官方文档 webGL​ 参考链接：webGL—MDN","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"vue-router","slug":"vue-router","permalink":"https://qw8.github.io/tags/vue-router/"},{"name":"vuex","slug":"vuex","permalink":"https://qw8.github.io/tags/vuex/"},{"name":"vue-cli","slug":"vue-cli","permalink":"https://qw8.github.io/tags/vue-cli/"}]},{"title":"vue知识点","slug":"knowledges/vue知识点","date":"2024-03-07T13:02:08.000Z","updated":"2024-06-06T01:59:24.038Z","comments":true,"path":"/knowledges/vue-zhi-shi-dian.html","link":"","permalink":"https://qw8.github.io/knowledges/vue-zhi-shi-dian.html","excerpt":"","text":"1.什么是vue的生命周期？Vue实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载DOM-&gt;渲染、更新-&gt;渲染、卸载等一系列过程，我们称这是Vue的生命周期。 2.vue生命周期的作用是什么？它的生命周期中有多个事件钩子，让我们在控制整个vue实例的过程时更容易形成好的逻辑。 3.Vue生命周期总共有几个阶段？它可以总共分为8个阶段：创建前/后，载入前/后，更新前/后，销毁前/销毁后 4.第一次页面加载会触发那几个钩子？第一次页面加载时会触发beforeCreate,created,beforeMount,mounted 5.DOM渲染在哪个周期中就已经完成？DOM渲染在mounted中就已经完成了 6.生命周期钩子的一些使用方法：1234561.beforecreate:可以在加个loading事件，在加载实例是触发2.created:初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用3.mounted:挂载元素，获取到dom节点4.updated:如果对数据统一处理，在这里写上相应函数5.beforeDestroy:可以一个确认停止事件的确认框6.nextTick:更新数据后立即操作dom 7.v-show与v-if的区别v-show是css切换，v-if是完整的销毁和重新创建使用频繁切换时用v-show,运行时较少改变时用v-ifV-if=’false’v-if是条件渲染，当false的时候不会渲染使用v-if的时候，如果值为false，那么页面将不会有这个html标签生成v-show则是不管值是为true还是false，html元素都会存在，只是css中的display显示或隐藏v-show 仅仅控制元素的显示方式，将 display 属性在 block 和 none 来回切换；而v-if会控制这个 DOM 节点的存在与否。 当我们需要经常切换某个元素的显示/隐藏时，使用v-show会更加节省性能上的开销； 当只需要一次显示或隐藏时，使用v-if更加合理。 8.开发中常用的指令有哪些?v-model:一般用在表达输入，很轻松的实现表单控件和数据的双向绑定v-html：更新元素的innerHTMLv-show与v-if：条件渲染，注意二者区别v-on:click:可以简写为@click,@绑定一个事件。如果事件触发了，就可以指定事件的处理函数v-for：基于源数据多次渲染元素或模板v-bind:当表达式的值改变时，将其产生的连带影响，响应式地作用于DOM语法v-bind:title=”msg”简写 :title=”msg” 9.绑定class的数组用法1231.对象方法v-bind:class=\"&#123;'orange':isRipe, 'green':isNotRipe&#125;”2.数组方法v-bind:class=\"[class1,class2]\"3.行内v-bind:style=\"&#123;color:color,fontSize:fontSize+'px'&#125;” 10.路由跳转方式1.router-link标签会渲染为标签，咋填template中的跳转都是这种；2.另一种是编辑是导航，也就是通过js跳转比如router.push(‘/home’) 11.MVVMM-model，model代表数据模型，也可以在model中定义数据修改和操作的业务逻辑 V-view,view代表UI组件，它负责将数据模型转化为UI展现出来 VM-viewmodel,viewmodel监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步view和model的对象，连接model和view 12.computed和watch有什么区别computed computed是计算属性，也就是计算值，它更多用于计算值的场景computed具有缓存性，computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时重新调用对应的getter来计算computed适用于计算比较消耗性能的计算场景 watch watch更多的是[观察]的作用，类似于某些数据的监听回调，用于观察props $emit或者本组件的值，当数据变化时来执行回调进行后续操作无缓存性，页面重新渲染时值不变化也会执行 小结 当我们要进行数值计算，而且依赖于其他数据，那么把这个数据设计为computed如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化。 13.vue组件的scoped属性的作用在style标签上添加scoped属性，以表示它的样式作用于当下的模块，很好的实现了样式私有化的目的；但是也得慎用：样式不易（可）修改，而很多时候，我们是需要对公共组件的样式做微调的； 解决办法： ①：使用混合型的css样式：（混合使用全局跟本地的样式） 12&lt;style&gt; /* 全局样式 */ &lt;/style&gt;&lt;style scoped&gt; /* 本地样式 */ &lt;/style&gt; ②：深度作用选择器（&gt;&gt;&gt;）如果你希望 scoped 样式中的一个选择器能够作用得“更深”，例如影响子组件，你可以使用 &gt;&gt;&gt; 操作符： 1&lt;style scoped&gt; .a &gt;&gt;&gt; .b &#123; /* ... */ &#125; &lt;/style&gt; 14.vue是渐进式的框架的理解：(主张最少,没有多做职责之外的事)Vue的核心的功能，是一个视图模板引擎，但这不是说Vue就不能成为一个框架。如下图所示，这里包含了Vue的所有部件，在声明式渲染（视图模板引擎）的基础上，我们可以通过添加组件系统、客户端路由、大规模状态管理来构建一个完整的框架。更重要的是，这些功能相互独立，你可以在核心功能的基础上任意选用其他的部件，不一定要全部整合在一起。可以看到，所说的“渐进式”，其实就是Vue的使用方式，同时也体现了Vue的设计的理念在我看来，渐进式代表的含义是：主张最少。视图模板引擎每个框架都不可避免会有自己的一些特点，从而会对使用者有一定的要求，这些要求就是主张，主张有强有弱，它的强势程度会影响在业务开发中的使用方式。比如说，Angular，它两个版本都是强主张的，如果你用它，必须接受以下东西：必须使用它的模块机制- 必须使用它的依赖注入- 必须使用它的特殊形式定义组件（这一点每个视图框架都有，难以避免）所以Angular是带有比较强的排它性的，如果你的应用不是从头开始，而是要不断考虑是否跟其他东西集成，这些主张会带来一些困扰。Vue可能有些方面是不如React，不如Angular，但它是渐进的，没有强主张，你可以在原有大系统的上面，把一两个组件改用它实现，当jQuery用；也可以整个用它全家桶开发，当Angular用；还可以用它的视图，搭配你自己设计的整个下层用。也可以函数式，都可以，它只是个轻量视图而已，只做了自己该做的事，没有做不该做的事，仅此而已。渐进式的含义，我的理解是：没有多做职责之外的事。 15.vue.js的两个核心是什么(数据驱动、组件系统。)数据驱动:Object.defineProperty和存储器属性: getter和setter（所以只兼容IE9及以上版本），可称为基于依赖收集的观测机制,核心是VM，即ViewModel，保证数据和视图的一致性。组件系统:点此查看 16.vue常用修饰符修饰符分为：一般修饰符，事件修饰符，按键、系统 ①一般修饰符：.lazy：v-model 在每次 input 事件触发后将输入框的值与数据进行同步 。你可以添加 lazy 修饰符，从而转变为使用 change 事件进行同步 1&lt;input v-model.lazy=\"msg\" &gt; .number 1&lt;input v-model.number=\"age\" type=\"number\"&gt; .trim 11.如果要自动过滤用户输入的首尾空白字符 &lt;input v-model.trim='trim'&gt; ② 事件修饰符12345678910111213&lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt;&lt;!-- 阻止单击事件继续传播 --&gt;&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt; &lt;!-- 提交事件不再重载页面 --&gt;&lt;a v-on:click.stop.prevent=\"doThat\"&gt;&lt;/a&gt; &lt;!-- 修饰符可以串联 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt; &lt;!-- 只有修饰符 --&gt;&lt;div v-on:click.capture=\"doThis\"&gt;...&lt;/div&gt; &lt;!-- 添加事件监听器时使用事件捕获模式 --&gt; &lt;!-- 即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理 --&gt;&lt;div v-on:click.self=\"doThat\"&gt;...&lt;/div&gt; &lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt; &lt;!-- 即事件不是从内部元素触发的 --&gt;&lt;a v-on:click.once=\"doThis\"&gt;&lt;/a&gt; &lt;!-- 点击事件将只会触发一次 --&gt; ③按键修饰符全部的按键别名: 12345678910111213.enter.tab.delete (捕获“删除”和“退格”键).esc.space.up.down.left.right.ctrl.alt.shift.meta 1&lt;input v-on:keyup.enter=\"submit\"&gt; 或者 &lt;input @keyup.enter=\"submit\"&gt; ④系统修饰键 （可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。）1234.ctrl.alt.shift.meta 1&lt;input @keyup.alt.67=\"clear\"&gt; 或者 &lt;div @click.ctrl=\"doSomething\"&gt;Do something&lt;/div&gt;&lt;!-- Ctrl + Click --&gt; 17.v-on可以监听多个方法吗？（可以的）一个元素绑定多个事件的两种写法，一个事件绑定多个函数的两种写法，修饰符的使用。 1&lt;a style=\"cursor:default\" v-on='&#123;click:DoSomething,mouseleave:MouseLeave&#125;'&gt;doSomething&lt;/a&gt; 在method方法里面分别写两个时事件； 1&lt;button @click=\"a(),b()\"&gt;点我ab&lt;/button&gt; 18.vue事件中如何使用event对象1&lt;button @click=\"Event($event)\"&gt;事件对象&lt;/button&gt; 19.比如你想让一个dom元素显示，然后下一步去获取这个元素的offsetWidth，最后你获取到的会是0。因为你改变数据把show变成true,元素并不会立即显示，理所当然也不会获取到动态宽度。正确的做法是先把元素show出来，在$nextTick去执行获取宽度的操作，不知道这样说会不会好理解一点。 12345openSubmenu() &#123; this.show = true //获取不到宽度 this.$nextTick(() =&gt; //这里才可以 let w = this.$refs.submenu.offsetWidth; &#125;)&#125; 20.Vue 组件中 data 为什么必须是函数vue组件中data值不能为对象，因为对象是引用类型，组件可能会被多个实例同时引用。如果data值为对象，将导致多个实例共享一个对象，其中一个组件改变data属性值，其它实例也会受到影响。 21.vue中子组件调用父组件的方法第一种方法是直接在子组件中通过this.$parent.event来调用父组件的方法第二种方法是在子组件里用$emit向父组件触发一个事件，父组件监听这个事件就行了。第三种都可以实现子组件调用父组件的方法， 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;button @click=\"childMethod()\"&gt;点击&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; fatherMethod: &#123; type: Function, default: null &#125; &#125;, methods: &#123; childMethod() &#123; if (this.fatherMethod) &#123; this.fatherMethod(); &#125; &#125; &#125; &#125;;&lt;/script&gt; 22.vue中 keep-alive 组件的作用keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。 123456789101112131415161718192021222324252627282930313233&lt;keep-alive&gt; &lt;component&gt; &lt;!-- 该组件将被缓存！ --&gt; &lt;/component&gt;&lt;/keep-alive&gt;如果只想 router-view 里面某个组件被缓存export default [ &#123; path: '/', name: 'home', component: Home, meta: &#123; keepAlive: true // 需要被缓存 &#125; &#125;, &#123; path: '/:id', name: 'edit', component: Edit, meta: &#123; keepAlive: false // 不需要被缓存 &#125; &#125;]&lt;keep-alive&gt; &lt;router-view v-if=\"$route.meta.keepAlive\"&gt; &lt;!-- 这里是会被缓存的视图组件，比如 Home！ --&gt; &lt;/router-view&gt;&lt;/keep-alive&gt; &lt;router-view v-if=\"!$route.meta.keepAlive\"&gt; &lt;!-- 这里是不被缓存的视图组件，比如 Edit！ --&gt;&lt;/router-view&gt; 23.vue中如何编写可复用的组件？https://blog.csdn.net/qq_38563845/article/details/77524934 ①创建组件页面eg Toast.vue；②用Vue.extend()扩展一个组件构造器,再通过实例化组件构造器,就可创造出可复用的组件③将toast组件挂载到新创建的div上；④把toast组件的dom添加到body里；⑤修改优化达到动态控制页面显示文字跟显示时间； 12345678910111213141516171819import Vue from 'vue'; import Toast from '@/components/Toast'; //引入组件let ToastConstructor = Vue.extend(Toast) // 返回一个“扩展实例构造器” let myToast = (text,duration)=&gt;&#123; let toastDom = new ToastConstructor(&#123; el:document.createElement('div') //将toast组件挂载到新创建的div上 &#125;) document.body.appendChild( toastDom.$el ) //把toast组件的dom添加到body里 toastDom.text = text; toastDom.duration = duration; // 在指定 duration 之后让 toast消失 setTimeout(()=&gt;&#123; toastDom.isShow = false; &#125;, toastDom.duration);&#125;export default myToast; 24.什么是vue生命周期和生命周期钩子函数？beforecreated：在实例初始化之后，el 和 data 并未初始化（这个时期，this变量还不能使用，在data下的数据，和methods下的方法，watcher中的事件都不能获得到；）created:完成了 data 数据的初始化，el没有（这个时候可以操作vue实例中的数据和各种方法，但是还不能对”dom”节点进行操作；）beforeMount：完成了 el 和 data 初始化 //这里的el是虚拟的dom；mounted ：完成挂载，在这发起后端请求，拿回数据，配合路由钩子做一些事情（挂载完毕，这时dom节点被渲染到文档内，一些需要dom的操作在此时才能正常进行）beforeUpdate：是指view层数据变化前，不是data中的数据改变前触发；update：是指view层的数据变化之后，beforeDestory： 你确认删除XX吗？destoryed ：当前组件已被删除，清空相关内容A、什么是vue生命周期？Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。B、vue生命周期的作用是什么？它的生命周期有多个事件钩子,让我们在控制整个Vue实例的过程时更容易形成好的逻辑。C、vue生命周期总共有几个阶段？它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后D、第一次页面加载会触发哪几个钩子？第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子E、DOM 渲染在 哪个周期中就已经完成？DOM 渲染在 mounted 中就已经完成了。F、简单描述每个周期具体适合哪些场景？生命周期钩子的一些使用方法： beforecreate : 可以在这加个loading事件，在加载实例时触发 created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用 mounted : 挂载元素，获取到DOM节点 updated : 如果对数据统一处理，在这里写上相应函数 beforeDestroy : 可以做一个确认停止事件的确认框 nextTick : 更新数据后立即操作dom; 26.webpack的作用①、依赖管理：方便引用第三方模块、让模块更容易复用，避免全局注入导致的冲突、避免重复加载或者加载不需要的模块。会一层一层的读取依赖的模块，添加不同的入口；同时，不会重复打包依赖的模块。②、合并代码：把各个分散的模块集中打包成大文件，减少HTTP的请求链接数，配合UglifyJS（压缩代码）可以减少、优化代码的体积。③、各路插件：统一处理引入的插件，babel编译ES6文件，TypeScript,eslint 可以检查编译期的错误。一句话总结：webpack 的作用就是处理依赖，模块化，打包压缩文件，管理插件。一切皆为模块，由于webpack只支持js文件，所以需要用loader 转换为webpack支持的模块，其中plugin 用于扩张webpack 的功能，在webpack构建生命周期的过程中，在合适的时机做了合适的事情。 webpack怎么工作的过程①解析配置参数，合并从shell(npm install 类似的命令)和webpack.config.js文件的配置信息，输出最终的配置信息；②注册配置中的插件,让插件监听webpack构建生命周期中的事件节点，做出对应的反应；③解析配置文件中的entry入口文件，并找出每个文件依赖的文件，递归下去；④在递归每个文件的过程中，根据文件类型和配置文件中的loader找出对应的loader对文件进行转换；⑤递归结束后得到每个文件最终的结果，根据entry 配置生成代码chunk(打包之后的名字)；⑥输出所以chunk 到文件系统。 27.vue等单页面应用及其优缺点缺点： 不支持低版本的浏览器，最低只支持到IE9；不利于SEO的优化（如果要支持SEO，建议通过服务端来进行渲染组件）；第一次加载首页耗时相对长一些；不可以使用浏览器的导航按钮需要自行实现前进、后退。 优点： 无刷新体验,提升了用户体验；前端开发不再以页面为单位，更多地采用组件化的思想，代码结构和组织方式更加规范化，便于修改和调整；API 共享，同一套后端程序代码不用修改就可以用于Web界面、手机、平板等多种客户端用户体验好、快，内容的改变不需要重新加载整个页面。 28.什么是vue的计算属性computed计算属性是需要复杂的逻辑，可以用方法method代替 12345computed:&#123; totalPrice()&#123; return (this.good.price*this.good.count)*this.discount+this.deliver; &#125; &#125; 29.vue-cli提供的几种脚手架模板 vue-cli 的脚手架项目模板有browserify 和 webpack； 30.组件中传递数据？12345678910props：export default &#123;props: &#123; message: String //定义传值的类型&lt;br&gt;&#125;,//或者props:[\"message\"]data: &#123;&#125;父组件调用子组件的方法：父组件 this.$refs.yeluosen.childMethod()子组件向父组件传值并调用方法 $emit组件之间：bus==$emit+$on 32.vue-router 的导航钩子,主要用来作用是拦截导航,让他完成跳转或取消。 全局的:前置守卫、后置钩子（beforeEach，afterEach）beforeResolve单个路由独享的:beforeEnter组件级的: beforeRouteEnter（不能获取组件实例 this）、beforeRouteUpdate、beforeRouteLeave这是因为在执行路由钩子函数beforRouteEnter时候，组件还没有被创建出来；先执行beforRouteEnter，再执行组件周期钩子函数beforeCreate，可以通过 next 获取组件的实例对象，如：next( (vm)=&gt;{} )，参数vm就是组件的实例化对象。 33.完整的 vue-router 导航解析流程 1.导航被触发；2.在失活的组件里调用beforeRouteLeave守卫；3.调用全局beforeEach守卫；4.在复用组件里调用beforeRouteUpdate守卫；5.调用路由配置里的beforeEnter守卫；6.解析异步路由组件；7.在被激活的组件里调用beforeRouteEnter守卫；8.调用全局beforeResolve守卫；9.导航被确认；10..调用全局的afterEach钩子；11.DOM更新；12.用创建好的实例调用beforeRouteEnter守卫中传给next的回调函数。 34.vue-router如何响应 路由参数 的变化？原来的组件实例会被复用。这也意味着组件的生命周期钩子不会再被调用。你可以简单地 watch (监测变化) $route 对象： 123456789101112131415161718const User = &#123; template: '...', watch: &#123; '$route' (to, from) &#123; // 对路由变化作出响应... &#125; &#125;&#125;const User = &#123; template: '...', watch: &#123; '$route' (to, from) &#123; // 对路由变化作出响应... &#125; &#125;&#125; 35.vue-router的几种实例方法以及参数传递 name传递to来传递采用url传参 36.is的用法（用于动态组件且基于 DOM 内模板的限制来工作。）is用来动态切换组件，DOM模板解析 1&lt;table&gt; &lt;tr is=\"my-row\"&gt;&lt;/tr&gt; &lt;/table&gt; 动态组件有的时候，在不同组件之间进行动态切换是非常有用的，比如在一个多标签的界面里： 上述内容可以通过 Vue 的 &lt;component&gt; 元素加一个特殊的 is attribute 来实现： 12&lt;!-- 组件会在 `currentTabComponent` 改变时改变 --&gt;&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt; 在上述示例中，currentTabComponent 可以包括 已注册组件的名字，或 一个组件的选项对象 请留意，这个 attribute 可以用于常规 HTML 元素，但这些元素将被视为组件，这意味着所有的 attribute 都会作为 DOM attribute 被绑定。对于像 value 这样的 property，若想让其如预期般工作，你需要使用 .prop 修饰器。 37.vuex是什么？怎么使用？哪种功能场景使用它？ 是什么：vue框架中状态管理:有五种，分别是 State、 Getter、Mutation 、Action、 Module使用：新建一个目录store，场景：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车 12345678910111213141516171819202122232425vuex的State特性A、Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于一般Vue对象里面的dataB、state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新C、它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中vuex的Getter特性A、getters 可以对State进行计算操作，它就是Store的计算属性B、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用C、 如果一个状态只在一个组件内使用，是可以不用gettersvuex的Mutation特性改变store中state状态的唯一方法就是提交mutation，就很类似事件。每个mutation都有一个字符串类型的事件类型和一个回调函数，我们需要改变state的值就要在回调函数中改变。我们要执行这个回调函数，那么我们需要执行一个相应的调用方法：store.commit。Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态；Action 可以包含任意异步操作，Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。Action 通过 store.dispatch 方法触发：eg。store.dispatch('increment')vuex的module特性Module其实只是解决了当state中很复杂臃肿的时候，module可以将store分割成模块，每个模块中拥有自己的state、mutation、action和getter 说说你对 SPA 单页面的理解，它的优缺点分别是什么？SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。 优点： 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染； 基于上面一点，SPA 相对对服务器压力小； 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理； 缺点： 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载； 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理； SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。 v-show 与 v-if 有什么区别？v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。 所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。 Class 与 Style 如何动态绑定？Class 可以通过对象语法和数组语法进行动态绑定： 对象语法： 1&lt;div v-bind:class=\"&#123; active: isActive, 'text-danger': hasError &#125;\"&gt;&lt;/div&gt; 数组语法： 1&lt;div v-bind:class=\"[isActive ? activeClass : '', errorClass]\"&gt;&lt;/div&gt; Style 也可以通过对象语法和数组语法进行动态绑定： 对象语法： 1&lt;div v-bind:style=\"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;\"&gt;&lt;/div&gt; 数组语法： 1&lt;div v-bind:style=\"[styleColor, styleSize]\"&gt;&lt;/div&gt; 怎样理解 Vue 的单向数据流？所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。 这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。 额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。 子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。 有两种常见的试图改变一个 prop 的情形 : 这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。 在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值： 1props: ['initialCounter'], 这个 prop 以一种原始的值传入且需要进行转换。 在这种情况下，最好使用这个 prop 的值来定义一个计算属性 1props: ['size'], computed 和 watch 的区别和运用的场景？computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值； watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作； 运用场景： 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算； 当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。 直接给一个数组项赋值，Vue 能检测到变化吗？由于 JavaScript 的限制，Vue 不能检测到以下数组的变动： 当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue 当你修改数组的长度时，例如：vm.items.length = newLength 为了解决第一个问题，Vue 提供了以下操作方法： 1// Vue.set 为了解决第二个问题，Vue 提供了以下操作方法： 1// Array.prototype.splice 谈谈你对 Vue 生命周期的理解？（1）生命周期是什么？Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。 （2）各个生命周期的作用 生命周期 描述 beforeCreate 组件实例被创建之初，组件的属性生效之前 created 组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用 beforeMount 在挂载开始之前被调用：相关的 render 函数首次被调用 mounted el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子 beforeUpdate 组件数据更新之前调用，发生在虚拟 DOM 打补丁之前 update 组件数据更新之后 activited keep-alive 专属，组件被激活时调用 deactivated keep-alive 专属，组件被销毁时调用 beforeDestory 组件销毁前调用 destoryed 组件销毁后调用 （3）生命周期示意图 img Vue 的父组件和子组件生命周期钩子函数执行顺序？Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分： 加载渲染过程 父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted 子组件更新过程 父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated 父组件更新过程 父 beforeUpdate -&gt; 父 updated 销毁过程 父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed 在哪个生命周期内调用异步请求？可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点： 能更快获取到服务端数据，减少页面 loading 时间； ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性； 在什么阶段才能访问操作DOM？在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 DOM。vue 具体的生命周期示意图可以参见如下，理解了整个生命周期各个阶段的操作，关于生命周期相关的面试题就难不倒你了。 img 父组件可以监听到子组件的生命周期吗？比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现： 1// Parent.vue 以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示： 1// Parent.vue 当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。 谈谈你对 keep-alive 的了解？keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性： 一般结合路由和动态组件一起使用，用于缓存组件； 提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高； 对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。 组件中 data 为什么是一个函数？为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？ 1// data 因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。 v-model 的原理？我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件： text 和 textarea 元素使用 value 属性和 input 事件； checkbox 和 radio 使用 checked 属性和 change 事件； select 字段将 value 作为 prop 并将 change 作为事件。 以 input 表单元素为例： 1&lt;input v-model='something'&gt; 如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示： 1父组件： Vue 组件间通信有哪几种方式？Vue 组件间通信是面试常考的知识点之一，这题有点类似于开放题，你回答出越多方法当然越加分，表明你对 Vue 掌握的越熟练。Vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。 （1）props / $emit 适用 父子组件通信 这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。 （2）ref 与 parent / children 适用 父子组件通信 ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例 parent / children：访问父 / 子实例 （3）EventBus （ emit / on） 适用于 父子、隔代、兄弟组件通信 这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。 （4） attrs/ listeners 适用于 隔代组件通信 listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=\" listeners\" 传入内部组件 （5）provide / inject 适用于 隔代组件通信 祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。 （6）Vuex 适用于 父子、隔代、兄弟组件通信 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。 Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。 父传子props1234567//childprops: &#123; msg: String;&#125;// parent&lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot; /&gt;; refs1234// parent&lt;HelloWorld ref=&quot;hw&quot; /&gt;this.$refs.hw.xx 子传父12345// childthis.$emit(&apos;add&apos;, good)// parent&lt;div @add=&quot;cartAdd($event)&quot;&gt;&lt;/div&gt; .sync 传参绑定.sync 其实也是事件传参的语法糖，父组件 以这样的形式@update:msg=”changeEmit” 子组件 this.$emit(‘update:msg’,this.msg)进行触发 而sync是可以进行简写的 12345678910111213141516171819202122232425262728293031323334353637383940414243// 父组件&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &#123;&#123;msg&#125;&#125; &lt;son @update:msg=&quot;changeEmit&quot;&gt;&lt;/son&gt; // 这下面是上面的语法糖，可以简写成这样 &lt;son :msg.sync=&quot;msg&quot;&gt;&lt;/son&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import son from &apos;./son.vue&apos; export default &#123; components:&#123; son &#125;, data()&#123; return&#123; msg:&quot;我是父亲&quot; &#125; &#125;, methods:&#123; changeEmit(value)&#123; this.msg = value &#125; &#125; &#125;&lt;/script&gt;// 子组件&lt;template&gt; &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data()&#123; return&#123; msg:&quot;我是儿子emit&quot; &#125; &#125;, mounted() &#123; this.$emit(&apos;update:msg&apos;,this.msg) &#125; &#125;&lt;/script&gt; 兄弟组件：通过共同祖辈组件通过共同的祖辈组件搭桥，$parent或$root。 1234// brother1this.$parent.$on(\"foo\", handle);// brother2this.$parent.$emit(\"foo\"); EventBusEventBus 又称为事件总线。在Vue中可以使用 EventBus 来作为沟通桥梁的概念， 就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件， 所以组件都可以上下平行地通知其他组件，但也就是太方便所以若使用不慎， 就会造成难以维护的灾难，因此才需要更完善的Vuex作为状态管理中心，将通知的概念上升到共享状态层次。 平常我们采用更多的是父传子，子传父，当遇到兄弟之间的组件通信的时候 就可以使用EventBus如下例 Vue.prototype.$EventBus = new Vue() 这句话的意思是 因为Vue的原型上有$on $emit 方法 继承自vue原型上的方法，实现一个发布订阅模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// main.js//这句话的意思是 因为Vue的原型上有$on $emit 方法 继承自vue原型上的方法，实现一个发布订阅模式Vue.prototype.$EventBus = new Vue()// 父组件-----------------&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &#123;&#123;msg&#125;&#125; &lt;son&gt;&lt;/son&gt; &lt;son1&gt;&lt;/son1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import son from &apos;./son.vue&apos; import son1 from &apos;./son1.vue&apos; export default &#123; components:&#123; son, son1 &#125;, data()&#123; return&#123; msg:&quot;我是父亲&quot; &#125; &#125;, &#125;&lt;/script&gt;// 子组件son------------------------&lt;template&gt; &lt;div&gt; &lt;span&gt;&#123;&#123;sonValue&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data()&#123; return&#123; sonValue:&quot;我是son1&quot; &#125; &#125;, mounted() &#123; this.$EventBus.$on(&apos;son1&apos;,(val)=&gt;&#123; this.sonValue = val &#125;) &#125; &#125;&lt;/script&gt;// 子组件son1----------------&lt;template&gt; &lt;div&gt; &lt;span&gt;&#123;&#123;sonValue&#125;&#125;&lt;/span&gt; &lt;button @click=&quot;btn&quot;&gt;在son1里面改变son的值&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data()&#123; return&#123; sonValue:&quot;我是son2&quot; &#125; &#125;, methods:&#123; btn()&#123; this.$EventBus.$emit(&apos;son1&apos;,&apos;在son1里面改变son的值&apos;) &#125; &#125; &#125;&lt;/script&gt;​``` --&gt;### 祖先和后代之间provide/inject：能够实现祖先给后代传值​```javascript// ancestorprovide() &#123; return &#123;foo: &apos;foo&apos;&#125;&#125;// descendantinject: [&apos;foo&apos;] dispatch：后代给祖先传值1234567891011121314151617//定义一个dispatch方法，指定要派发事件名称和数据function dispatch(eventName, data) &#123; let parent = this.$parent; // 只要还存在父元素就继续往上查找 while (parent) &#123; // 父元素用$emit触发 parent.$emit(eventName, data); // 递归查找父元素 parent = parent.$parent; &#125;&#125;// 使用，HelloWorld.vue&lt;h1 @click=\"dispatch('hello', 'hello,world')\"&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;// App.vuethis.$on('hello', this.sayHello) 任意两个组件之间：事件总线 或 vuex事件总线：创建一个 Bus 类负责事件派发、监听和回调管理 123456789101112131415161718192021222324252627// Bus：事件派发、监听和回调管理class Bus &#123; constructor() &#123; // &#123; // eventName1:[fn1,fn2], // eventName2:[fn3,fn4], // &#125; this.callbacks = &#123;&#125;; &#125; $on(name, fn) &#123; this.callbacks[name] = this.callbacks[name] || []; this.callbacks[name].push(fn); &#125; $emit(name, args) &#123; if (this.callbacks[name]) &#123; this.callbacks[name].forEach(cb =&gt; cb(args)); &#125; &#125;&#125;// main.jsVue.prototype.$bus = new Bus()// child1 this.$bus.$on('foo', handle) // child2 this.$bus.$emit('foo') vuex：创建唯一的全局数据管理者 store，通过它管理数据并通知组件状态变更 .sync修饰符1.作用可以实现子组件与父组件数据的双向绑定，简化代码 简单理解:子组件可以修改父组件传过来的props值 2.场景封装弹框类的基础组件， visible属性true显示false隐藏 特点:prop属性名，可以自定义，非固定为value 3.本质.sync修饰符就是:属性名和@update:属性名合写 .sync(有语义) :属性.sync=’数据’ 相当于 ：属性=“数据“ + @update：属性=”数据=$event” 1&lt;base-select :selectId=&quot;selectId&quot;@update:selectId=&quot;selectId = $event&quot; &gt; 相当于 1&lt;base-select :selectId.sync=&quot;selectId&quot;/&gt; v-model中的value不具有语义，要使其有语义写成 ：属性名=” 数据” @update:属性名=” 数据” 来替换原来的 ：属性名=”数据” @input=”数据” 4.案例一App.vue 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div&gt; &lt;h1&gt;大标题&lt;/h1&gt; &lt;!-- &lt;header-comp :projectId=&quot;selectId&quot; @changeId=&quot;selectId=$event&quot;&gt;&lt;/header-comp&gt; --&gt;&lt;header-comp :selectId=&quot;selectId&quot; @update:selectId=&quot;selectId=$event&quot;&gt;&lt;/header-comp&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;import HeaderComp from &apos;./components/HeaderComp.vue&apos; export default &#123; components: &#123; HeaderComp &#125;, data () &#123; return &#123; selectId: &apos;2&apos; &#125; &#125; &#125;&lt;/script&gt; &lt;style&gt; &lt;/style&gt; HeaderComp.vue 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div class=&quot;fa&quot;&gt; &lt;h2&gt;h2文章二级标题&lt;/h2&gt;&lt;select name=&quot;&quot; id=&quot;&quot; :value=&quot;selectId&quot; @change=&quot;handleChange&quot;&gt; &lt;option value=&quot;1&quot;&gt;html&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;css&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;js&lt;/option&gt;&lt;/select&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt; export default &#123; props: &#123; selectId: String &#125;, methods: &#123; handleChange (e) &#123; console.log(e.target.value) this.$emit(&apos;update:selectId&apos;, e.target.value) &#125; &#125; &#125;&lt;/script&gt; &lt;style&gt; &lt;/style&gt; 用.sync修饰符简化，只需将App.vue中的子组件标签写成 1&lt;header-comp :selectId.sync=&quot;selectId&quot;&gt;&lt;/header-comp&gt; 5.案例二father.vue 12345678910111213141516171819202122232425&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;wrd&quot;&gt; &lt;box :wrd.sync=&quot;wrd&quot;&gt;&lt;/box&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import box from &apos;./box&apos;export default &#123; name: &apos;HelloWorld&apos;, data() &#123; return &#123; wrd: &apos;&apos; &#125; &#125;, methods: &#123; boxIncremend(e) &#123; this.wrd = e &#125; &#125;, components: &#123; box &#125;&#125;&lt;/script&gt; child.vue 1234567891011121314151617181920&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;str&quot;&gt; &lt;h2&gt;&#123;&#123; word &#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;box&apos;, props: &#123; word: &apos;&apos; &#125;, watch: &#123; str: function(newword) &#123; //往父级发射incre事件 this.$emit(&apos;update:word&apos;, newword) &#125; &#125;,&#125;&lt;/script&gt; 父组件中的子组件，少写了一个自定义事件属性，子组件中$emit直接出发父组件中数据的更新，清新明了。使用中需要注意的是，update和后面对应的数据名不能写错。 你使用过 Vuex 吗？Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。 （1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 （2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。 主要包括以下几个模块： State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。 Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。 Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。 Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。 Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。 使用过 Vue SSR 吗？说说 SSR？ Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。 即：SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。 服务端渲染 SSR 的优缺点如下：（1）服务端渲染的优点： 更好的 SEO：因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面； 更快的内容到达时间（首屏加载更快）：SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间； （2) 服务端渲染的缺点： 更多的开发条件限制：例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境； 更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。 如果没有 SSR 开发经验的同学，可以参考本文作者的另一篇 SSR 的实践文章《Vue SSR 踩坑之旅》，里面 SSR 项目搭建以及附有项目源码。 vue-router 路由模式有几种？vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示： 1switch (mode) &#123; 其中，3 种路由模式的说明如下： hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器； history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式； abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式. 能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？（1）hash 模式的实现原理早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 ‘#search’： 1https://www.word.com#search hash 路由模式的实现主要是基于下面几个特性： URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送； hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换； 可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值； 我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。 （2）history 模式的实现原理HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示： 1window.history.pushState(null, null, path); history 路由模式的实现主要基于存在下面几个特性： pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ； 我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）； history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。 什么是 MVVM？Model–View–ViewModel （MVVM） 是一个软件架构设计模式，由微软 WPF 和 Silverlight 的架构师 Ken Cooper 和 Ted Peters 开发，是一种简化用户界面的事件驱动编程方式。由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于2005年在他的博客上发表 MVVM 源自于经典的 Model–View–Controller（MVC）模式 ，MVVM 的出现促进了前端开发与后端业务逻辑的分离，极大地提高了前端开发效率，MVVM 的核心是 ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。如下图所示： img （1）View 层View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。 （2）Model 层Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。 （3）ViewModel 层ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。 需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的，比如页面的这一块展示什么，而页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互），视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。 MVVM 框架实现了双向绑定，这样 ViewModel 的内容会实时展现在 View 层，前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新。 这样 View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。 我们以下通过一个 Vue 实例来说明 MVVM 的具体实现，有 Vue 开发经验的同学应该一目了然： （1）View 层 1&lt;div id=\"app\"&gt; （2）ViewModel 层 1var app = new Vue(&#123; （3） Model 层 1&#123; Vue 是如何实现数据双向绑定的？Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据，如下图所示： img 即： 输入框内容变化时，Data 中的数据同步变化。即 View =&gt; Data 的变化。 Data 中的数据变化时，文本节点的内容同步变化。即 Data =&gt; View 的变化。 其中，View 变化更新 Data ，可以通过事件监听的方式来实现，所以 Vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View。 Vue 主要通过以下 4 个步骤来实现数据双向绑定的： 实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。 实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。 实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。 实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。 以上四个步骤的流程图表示如下，如果有同学理解不大清晰的，可以查看作者专门介绍数据双向绑定的文章《0 到 1 掌握：Vue 核心之数据双向绑定》，有进行详细的讲解、以及代码 demo 示例。 img Vue 框架怎么实现对象和数组的监听？如果被问到 Vue 怎么实现数据双向绑定，大家肯定都会回答 通过 Object.defineProperty() 对数据进行劫持，但是 Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持，同理无法对数组进行劫持，但是我们在使用 Vue 框架中都知道，Vue 能检测到对象和数组（部分方法的操作）的变化，那它是怎么实现的呢？我们查看相关代码如下： 1/** 通过以上 Vue 源码部分查看，我们就能知道 Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。 Proxy 与 Object.defineProperty 优劣对比Proxy 的优势如下: Proxy 可以直接监听对象而非属性； Proxy 可以直接监听数组的变化； Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的； Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改； Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利； Object.defineProperty 的优势如下: 兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。 vue中this.$set的用法当你发现你给对象加了一个属性，在控制台能打印出来，但是却没有更新到视图上时，也许这个时候就需要用到this.$set（）这个方法了，简单来说this.$set的功能就是解决这个问题的啦。 官方解释：向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性 (比如 this.myObject.newProperty = ‘hi’) 调用方法：this.$set( target, key, value ) 🌹 target：要更改的数据源(可以是对象或者数组) 🌹 key：要更改的具体数据 🌹 value ：重新赋的值 12345// 不能动态修改值item2.price = 0this.arr[2] = 0this.$set(item, &apos;price&apos;, 0) // 对象给item设置新属性price，值为0，可以动态修改this.$set(this.arr, 2, 0) // 数组给第三个元素赋值为0 vue更新数组时触发视图更新的方法1.Vue.set 可以设置对象或数组的值，通过 key 或数组索引，可以触发视图更新 1234567数组修改Vue.set(array, indexOfItem, newValue)this.array.$set(indexOfItem, newValue)对象修改Vue.set(obj, keyOfItem, newValue)this.obj.$set(keyOfItem, newValue) 2.Vue.delete 删除对象或数组中元素，通过 key 或数组索引，可以触发视图更新 1234567数组修改Vue.delete(array, indexOfItem)this.array.$delete(indexOfItem)对象修改Vue.delete(obj, keyOfItem)this.obj.$delete(keyOfItem) 3.数组对象直接修改属性，可以触发视图更新 1234this.array[0].show = true;this.array.forEach(function(item)&#123; item.show = true;&#125;); 4.splice 方法修改数组，可以触发视图更新 1this.array.splice(indexOfItem, 1, newElement) 5.数组整体修改，可以触发视图更新 123var tempArray = this.array;tempArray[0].show = true;this.array = tempArray; 6.用 Object.assign 或 lodash.assign 可以为对象添加响应式属性，可以触发视图更新 12345678//Object.assign的单层的覆盖前面的属性，不会递归的合并属性this.obj = Object.assign(&#123;&#125;,this.obj,&#123;a:1, b:2&#125;)//assign与Object.assign一样this.obj = _.assign(&#123;&#125;,this.obj,&#123;a:1, b:2&#125;)//merge会递归的合并属性this.obj = _.merge(&#123;&#125;,this.obj,&#123;a:1, b:2&#125;) 7.Vue 提供了如下的数组的变异方法，可以触发视图更新 1234567push()pop()shift()unshift()splice()sort()reverse() 直接给一个数组项赋值，Vue 能检测到变化吗？由于 JavaScript 的限制，Vue 不能检测到以下数组的变动： 当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue 当你修改数组的长度时，例如：vm.items.length = newLength 为了解决第一个问题，Vue 提供了以下操作方法： 123456// Vue.setVue.set(vm.items, indexOfItem, newValue)// vm.$set，Vue.set的一个别名vm.$set(vm.items, indexOfItem, newValue)// Array.prototype.splicevm.items.splice(indexOfItem, 1, newValue) 为了解决第二个问题，Vue 提供了以下操作方法： 12// Array.prototype.splicevm.items.splice(newLength) vue更新数组时触发视图更新的方法1234567891011Vue.set ==========Vue.set(target,key,value)这个方法主要是用于避开vue不能检测属性被添加的限制Vue.set(array, indexOfItem, newValue)//indexOfItem指的索引this.array.$set(indexOfItem, newValue)Vue.set(obj, keyOfItem, newValue)this.obj.$set(keyOfItem, newValue)Vue.delete 这个方法主要用于避开vue不能检测到属性被删除；Vue.delete(array, indexOfItem)this.array.$delete(indexOfItem)Vue.delete(obj, keyOfItem)this.obj.$delete(keyOfItem) vue的数据是响应式的，请问什么时候是非响应式的并如何解决数组数据：问题1：通过改变长度，利用索引直接设置跟项 解决：Vue.set(数组对象, key, value) | vm|this.$set(数组对象, key, value) 问题2：对数组使用了非变异 (non-mutating method) 方法（返回的了新数组） 解决：对象合并 对象数据变化：问题：问题：data:{a:1}；a 数据是响应式的；vm.b=’qq’; b 属性不是响应式的 解决：Vue.set(对象, key, value) | vm|this.$set(对象, key, value) 总结：数据一开始就应该出现在data里，数组里面永远不要放置简单性数据 vm.$set(obj, key, val) 做了什么？由于 Vue 无法探测对象新增属性或者通过索引为数组新增一个元素，所以这才有了 vm.set ， 它 是 Vue.set 的 别 名 。 vm.set，它是 Vue.set 的别名。 vm.set，它是Vue.set的别名。vm.set 用于向响应式对象添加一个新的 property，并确保这个新的 property 同样是响应式的，并触发视图更新。 为对象添加一个新的响应式数据：调用 defineReactive 方法为对象增加响应式数据，然后执行 dep.notify 进行依赖通知，更新视图为数组添加一个新的响应式数据：通过 splice 方法实现 Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？受现代 JavaScript 的限制 ，Vue 无法检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。 但是 Vue 提供了Vue.set (object, propertyName, value) / vm.$set (object, propertyName, value) 来实现为对象添加响应式属性，那框架本身是如何实现的呢？ 我们查看对应的 Vue 源码：vue/src/core/instance/index.js 12345678910111213141516171819202122232425export function set (target: Array&lt;any&gt; | Object, key: any, val: any): any &#123; // target 为数组 if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123; // 修改数组的长度, 避免索引&gt;数组长度导致splcie()执行有误 target.length = Math.max(target.length, key) // 利用数组的splice变异方法触发响应式 target.splice(key, 1, val) return val &#125; // key 已经存在，直接修改属性值 if (key in target &amp;&amp; !(key in Object.prototype)) &#123; target[key] = val return val &#125; const ob = (target: any).__ob__ // target 本身就不是响应式数据, 直接赋值 if (!ob) &#123; target[key] = val return val &#125; // 对属性进行响应式处理 defineReactive(ob.value, key, val) ob.dep.notify() return val&#125; 我们阅读以上源码可知，vm.$set 的实现原理是： 如果目标是数组，直接使用数组的 splice 方法触发相应式； 如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法） 虚拟 DOM 的优缺点？优点： 保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限； 无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率； 跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。 缺点: 无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。 虚拟 DOM 实现原理？虚拟 DOM 的实现原理主要包括以下 3 部分： 用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象； diff 算法 — 比较两棵虚拟 DOM 树的差异； pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。 如果对以上 3 个部分还不是很了解的同学，可以查看本文作者写的另一篇详解虚拟 DOM 的文章《深入剖析：Vue核心之虚拟DOM》 你有对 Vue 项目进行哪些优化？如果没有对 Vue 项目没有进行过优化总结的同学，可以参考本文作者的另一篇文章《 Vue 项目性能优化 — 实践指南 》，文章主要介绍从 3 个大方面，22 个小方面详细讲解如何进行 Vue 项目的优化。 （1）代码层面的优化 v-if 和 v-show 区分使用场景 computed 和 watch 区分使用场景 v-for 遍历必须为 item 添加 key，且避免同时使用 v-if 长列表性能优化 事件的销毁 图片资源懒加载 路由懒加载 第三方插件的按需引入 优化无限列表性能 服务端渲染 SSR or 预渲染 （2）Webpack 层面的优化 Webpack 对图片进行压缩 减少 ES6 转为 ES5 的冗余代码 提取公共代码 模板预编译 提取组件的 CSS 优化 SourceMap 构建结果输出分析 Vue 项目的编译优化 （3）基础的 Web 技术的优化 开启 gzip 压缩 浏览器缓存 CDN 的使用 使用 Chrome Performance 查找性能瓶颈 vue路由组件动态引入在Vue中，可以使用动态组件和Vue Router结合来实现路由组件的动态引入。以下是一个简单的例子： 安装Vue Router： 1npm install vue-router 设置Vue Router，并使用动态导入来懒加载组件： 12345678910111213141516171819202122232425262728// router.jsimport Vue from &apos;vue&apos;;import Router from &apos;vue-router&apos;;Vue.use(Router);function loadView(view) &#123; return () =&gt; import(`@/views/$&#123;view&#125;.vue`);&#125;const router = new Router(&#123; mode: &apos;history&apos;, routes: [ &#123; path: &apos;/&apos;, name: &apos;home&apos;, component: loadView(&apos;Home&apos;) // 动态引入Home组件 &#125;, &#123; path: &apos;/about&apos;, name: &apos;about&apos;, component: loadView(&apos;About&apos;) // 动态引入About组件 &#125;, // 更多路由... ]&#125;);export default router; 在Vue实例中使用router： 123456789// main.jsimport Vue from &apos;vue&apos;;import App from &apos;./App.vue&apos;;import router from &apos;./router&apos;;new Vue(&#123; router, render: h =&gt; h(App)&#125;).$mount(&apos;#app&apos;); 在上述代码中，loadView函数负责根据视图名称动态创建组件加载函数。当Vue Router匹配到相应路由时，会调用这个加载函数来懒加载对应的组件文件。这样可以实现按需加载，提高应用的初始化速度和性能。 对于即将到来的 vue3.0 特性你有什么了解的吗？Vue 3.0 正走在发布的路上，Vue 3.0 的目标是让 Vue 核心变得更小、更快、更强大，因此 Vue 3.0 增加以下这些新特性： （1）监测机制的改变3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。这消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制： 只能监测属性，不能监测对象 检测属性的添加和删除； 检测数组索引和长度的变更； 支持 Map、Set、WeakMap 和 WeakSet。 新的 observer 还提供了以下特性： 用于创建 observable 的公开 API。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。 默认采用惰性观察。在 2.x 中，不管反应式数据有多大，都会在启动时被观察到。如果你的数据集很大，这可能会在应用启动时带来明显的开销。在 3.x 中，只观察用于渲染应用程序最初可见部分的数据。 更精确的变更通知。在 2.x 中，通过 Vue.set 强制添加新属性将导致依赖于该对象的 watcher 收到变更通知。在 3.x 中，只有依赖于特定属性的 watcher 才会收到通知。 不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 prop 传递或 Vuex 状态树以外的变化。 更好的调试功能：我们可以使用新的 renderTracked 和 renderTriggered 钩子精确地跟踪组件在什么时候以及为什么重新渲染。 （2）模板模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。 同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。 （3）对象式的组件声明方式vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。 3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易。 此外，vue 的源码也改用了 TypeScript 来写。其实当代码的功能复杂之后，必须有一个静态类型系统来做一些辅助管理。 现在 vue3.0 也全面改用 TypeScript 来重写了，更是使得对外暴露的 api 更容易结合 TypeScript。静态类型系统对于复杂代码的维护确实很有必要。 （4）其它方面的更改vue3.0 的改变是全面的，上面只涉及到主要的 3 个方面，还有一些其他的更改： 支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。 支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。 基于 treeshaking 优化，提供了更多的内置功能。 说说你使用 Vue 框架踩过最大的坑是什么？怎么解决的？本题为开放题目，Vue框架部分我们会涉及一些高频且有一定探讨价值的面试题,我们不会涉及一些非常初级的在官方文档就能查看的纯记忆性质的面试题,比如: vue常用的修饰符? vue-cli 工程常用的 npm 命令有哪些？ vue中 keep-alive 组件的作用? 首先,上述类型的面试题在文档中可查,没有比官方文档更权威的答案了,其次这种问题没有太大价值,除了考察候选人的记忆力,最后,这种面试题只要用过vue的都知道,没有必要占用我们的篇幅. 我们的问题并不多,但是难度可能会高一些,如果你真的搞懂了这些问题,在绝大多数情况下会有举一反三的效果,可以说基本能拿下Vue相关的所有重要知识点了. MVVM是什么?MVVM 模式，顾名思义即 Model-View-ViewModel 模式。它萌芽于2005年微软推出的基于 Windows 的用户界面框架 WPF ，前端最早的 MVVM 框架 knockout 在2010年发布。 Model 层: 对应数据层的域模型，它主要做域模型的同步。通过 Ajax/fetch 等 API 完成客户端和服务端业务 Model 的同步。在层间关系里，它主要用于抽象出 ViewModel 中视图的 Model。 View 层:作为视图模板存在，在 MVVM 里，整个 View 是一个动态模板。除了定义结构、布局外，它展示的是 ViewModel 层的数据和状态。View 层不负责处理状态，View 层做的是 数据绑定的声明、 指令的声明、 事件绑定的声明。 ViewModel 层:把 View 需要的层数据暴露，并对 View 层的 数据绑定声明、 指令声明、 事件绑定声明 负责，也就是处理 View 层的具体业务逻辑。ViewModel 底层会做好绑定属性的监听。当 ViewModel 中数据变化，View 层会得到更新；而当 View 中声明了数据的双向绑定（通常是表单元素），框架也会监听 View 层（表单）值的变化。一旦值变化，View 层绑定的 ViewModel 中的数据也会得到自动更新。 MVVM的优缺点?优点: 分离视图（View）和模型（Model）,降低代码耦合，提高视图或者逻辑的重用性: 比如视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定不同的”View”上，当View变化的时候Model不可以不变，当Model变化的时候View也可以不变。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑 提高可测试性: ViewModel的存在可以帮助开发者更好地编写测试代码 自动更新dom: 利用双向绑定,数据更新后视图自动更新,让开发者从繁琐的手动dom中解放 缺点: Bug很难被调试: 因为使用双向绑定的模式，当你看到界面异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。数据绑定使得一个位置的Bug被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了。另外，数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的 一个大的模块中model也会很大，虽然使用方便了也很容易保证了数据的一致性，当时长期持有，不释放内存就造成了花费更多的内存 对于大型的图形应用程序，视图状态较多，ViewModel的构建和维护的成本都会比较高 异步请求适合在哪个生命周期调用？官方实例的异步请求是在mounted生命周期中调用的，而实际上也可以在created生命周期中调用。 Vue组件如何通信？Vue组件通信的方法如下: props $emit+v-on: 通过props将数据自上而下传递，而通过$emit和v-on来向上传递信息。 EventBus: 通过EventBus进行信息的发布与订阅 vuex: 是全局数据管理库，可以通过vuex管理全局的数据流 $attrs $listeners: Vue2.4中加入的$attrs/$listeners可以进行跨级的组件通信 provide/inject：以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效，这成为了跨组件通信的基础 还有一些用solt插槽或者ref实例进行通信的，使用场景过于有限就不赘述了。 computed和watch有什么区别?computed: computed是计算属性,也就是计算值,它更多用于计算值的场景 computed具有缓存性,computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时才会重新调用对应的getter来计算 computed适用于计算比较消耗性能的计算场景 watch: 更多的是「观察」的作用,类似于某些数据的监听回调,用于观察props $emit或者本组件的值,当数据变化时来执行回调进行后续操作 无缓存性，页面重新渲染时值不变化也会执行 小结: 当我们要进行数值计算,而且依赖于其他数据，那么把这个数据设计为computed 如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化 Vue是如何实现双向绑定的?利用Object.defineProperty劫持对象的访问器,在属性值发生变化时我们可以获取变化,然后根据变化进行后续响应,在vue3.0中通过Proxy代理对象进行类似的操作。 12345678910111213141516171819202122232425262728293031323334// 这是将要被劫持的对象const data = &#123; name: '',&#125;;function say(name) &#123; if (name === '古天乐') &#123; console.log('给大家推荐一款超好玩的游戏'); &#125; else if (name === '渣渣辉') &#123; console.log('戏我演过很多,可游戏我只玩贪玩懒月'); &#125; else &#123; console.log('来做我的兄弟'); &#125;&#125;// 遍历对象,对其属性值进行劫持Object.keys(data).forEach(function(key) &#123; Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function() &#123; console.log('get'); &#125;, set: function(newVal) &#123; // 当属性值发生变化时我们可以进行额外操作 console.log(`大家好,我系$&#123;newVal&#125;`); say(newVal); &#125;, &#125;);&#125;);data.name = '渣渣辉';//大家好,我系渣渣辉//戏我演过很多,可游戏我只玩贪玩懒月 详细实现见Proxy比defineproperty优劣对比? Proxy与Object.defineProperty的优劣对比?Proxy的优势如下: Proxy可以直接监听对象而非属性 Proxy可以直接监听数组的变化 Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的 Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty只能遍历对象属性直接修改 Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利 Object.defineProperty的优势如下: 兼容性好,支持IE9 详细实现见Proxy比defineproperty优劣对比? 你是如何理解Vue的响应式系统的?响应式系统简述: 任何一个 Vue Component 都有一个与之对应的 Watcher 实例。 Vue 的 data 上的属性会被添加 getter 和 setter 属性。 当 Vue Component render 函数被执行的时候, data 上会被 触碰(touch), 即被读, getter 方法会被调用, 此时 Vue 会去记录此 Vue component 所依赖的所有 data。(这一过程被称为依赖收集) data 被改动时（主要是用户操作）, 即被写, setter 方法会被调用, 此时 Vue 会去通知所有依赖于此 data 的组件去调用他们的 render 函数进行更新。 虚拟DOM的优劣如何?优点: 保证性能下限: 虚拟DOM可以经过diff找出最小差异,然后批量进行patch,这种操作虽然比不上手动优化,但是比起粗暴的DOM操作性能要好很多,因此虚拟DOM可以保证性能下限 无需手动操作DOM: 虚拟DOM的diff和patch都是在一次更新中自动进行的,我们无需手动操作DOM,极大提高开发效率 跨平台: 虚拟DOM本质上是JavaScript对象,而DOM与平台强相关,相比之下虚拟DOM可以进行更方便地跨平台操作,例如服务器渲染、移动端开发等等 缺点: 无法进行极致优化: 在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化,比如VScode采用直接手动操作DOM的方式进行极端的性能优化 虚拟DOM实现原理? 虚拟DOM本质上是JavaScript对象,是对真实DOM的抽象 状态变更时，记录新树和旧树的差异 最后把差异更新到真正的dom中 详细实现见虚拟DOM原理? 既然Vue通过数据劫持可以精准探测数据变化,为什么还需要虚拟DOM进行diff检测差异?考点: Vue的变化侦测原理 前置知识: 依赖收集、虚拟DOM、响应式系统 现代前端框架有两种方式侦测变化,一种是pull一种是push pull: 其代表为React,我们可以回忆一下React是如何侦测到变化的,我们通常会用setStateAPI显式更新,然后React会进行一层层的Virtual Dom Diff操作找出差异,然后Patch到DOM上,React从一开始就不知道到底是哪发生了变化,只是知道「有变化了」,然后再进行比较暴力的Diff操作查找「哪发生变化了」，另外一个代表就是Angular的脏检查操作。 push: Vue的响应式系统则是push的代表,当Vue程序初始化的时候就会对数据data进行依赖的收集,一但数据发生变化,响应式系统就会立刻得知,因此Vue是一开始就知道是「在哪发生变化了」,但是这又会产生一个问题,如果你熟悉Vue的响应式系统就知道,通常一个绑定一个数据就需要一个Watcher,一但我们的绑定细粒度过高就会产生大量的Watcher,这会带来内存以及依赖追踪的开销,而细粒度过低会无法精准侦测变化,因此Vue的设计是选择中等细粒度的方案,在组件级别进行push侦测的方式,也就是那套响应式系统,通常我们会第一时间侦测到发生变化的组件,然后在组件内部进行Virtual Dom Diff获取更加具体的差异,而Virtual Dom Diff则是pull操作,Vue是push+pull结合的方式进行变化侦测的. Vue为什么没有类似于React中shouldComponentUpdate的生命周期？考点: Vue的变化侦测原理 前置知识: 依赖收集、虚拟DOM、响应式系统 根本原因是Vue与React的变化侦测方式有所不同 React是pull的方式侦测变化,当React知道发生变化后,会使用Virtual Dom Diff进行差异检测,但是很多组件实际上是肯定不会发生变化的,这个时候需要用shouldComponentUpdate进行手动操作来减少diff,从而提高程序整体的性能. Vue是pull+push的方式侦测变化的,在一开始就知道那个组件发生了变化,因此在push的阶段并不需要手动控制diff,而组件内部采用的diff方式实际上是可以引入类似于shouldComponentUpdate相关生命周期的,但是通常合理大小的组件不会有过量的diff,手动优化的价值有限,因此目前Vue并没有考虑引入shouldComponentUpdate这种手动优化的生命周期. Vue中的key到底有什么用？key是为Vue中的vnode标记的唯一id,通过这个key,我们的diff操作可以更准确、更快速 diff算法的过程中,先会进行新旧节点的首尾交叉对比,当无法匹配的时候会用新节点的key与旧节点进行比对,然后超出差异. diff程可以概括为：oldCh和newCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较,这四种比较方式就是首、尾、旧尾新头、旧头新尾. 准确: 如果不加key,那么vue会选择复用节点(Vue的就地更新策略),导致之前节点的状态被保留下来,会产生一系列的bug. 快速: key的唯一性可以被Map数据结构充分利用,相比于遍历查找的时间复杂度O(n),Map的时间复杂度仅仅为O(1). 在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 message 的翻转字符串。当你想要在模板中多次引用此处的翻转字符串时，就会更加难以处理。 所以，对于任何复杂逻辑，你都应当使用计算属性。 vue-cli提供了几种脚手架模板六种 https://github.com/vuejs/vue-cli/tree/v2#vue-cli-- computed、methods的区别两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的依赖进行缓存的。只在相关依赖发生改变时它们才会重新求值。这就意味着只要值还没有发生改变，多次访问 定义的计算属性会立即返回之前的计算结果，而不必再次执行函数。 相比之下，每当触发重新渲染时，调用方法(methods)将总会再次执行函数。 我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。 什么是自定义指令，有哪些钩子函数及自定义指令的使用场景有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。 一个指令定义对象可以提供如下几个钩子函数 (均为可选)： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用。 父组件获取异步动态数据传递给子组件在父组件中使用axios获取异步数据传给子组件，但是发现子组件在渲染的时候并没有数据，在created里面打印也是空的，结果发现一开始子组件绑定的数据是空的，在请求数据没有返回数据时，子组件就已经加载了，并且他绑定的值也是空的，问题找到了，怎么解决呢？ 开始的时候让子组件隐藏,然后等数据返回的时候，让子组件显示 通过v-if，也就是判断数据是否为空，为空就不渲染，也能解决了 为不能读取的属性添加一个默认值，就可以很好的解决了 vue-router实现原理这里指的路由并不是指我们平时所说的硬件路由器，这里的路由就是SPA（单页应用）的路径管理器。 换句话说，vue-router就是WebApp的链接路径管理系统。 vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。 那与传统的页面跳转有什么区别呢？1.vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。 2.传统的页面应用，是用一些超链接来实现页面切换和跳转的。 在vue-router单页面应用中，则是路径之间的切换，也就是组件的切换。路由模块的本质 就是建立起url和页面之间的映射关系。 至于为啥不能用a标签，这是因为用Vue做的都是单页应用，就相当于只有一个主的index.html页面，所以你写的标签是不起作用的，必须使用vue-router来进行管理。 SPA(single page application):单一页面应用程序，有且只有一个完整的页面；当它在加载页面的时候，不会加载整个页面的内容，而只更新某个指定的容器中内容。 单页面应用(SPA)的核心之一是: 更新视图而不重新请求页面; vue-router在实现单页面前端路由时，提供了三种方式：Hash模式、History模式、abstract模式，根据mode参数来决定采用哪一种方式。 路由模式vue-router 提供了三种运行模式： ● hash: 使用 URL hash 值来作路由。默认模式。 ● history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。 ● abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。 Hash模式vue-router 默认模式是 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，当 URL 改变时，页面不会去重新加载。 hash（#）是URL 的锚点，代表的是网页中的一个位置，单单改变#后的部分（/#/…），浏览器只会加载相应位置的内容，不会重新加载网页，也就是说 #是用来指导浏览器动作的，对服务器端完全无用，HTTP请求中不包括#；同时每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置；所以说Hash模式通过锚点值的改变，根据不同的值，渲染指定DOM位置的不同数据。 JavaScript实现SPA路由hash模式详解 History模式HTML5 History API提供了一种功能，能让开发人员在不刷新整个页面的情况下修改站点的URL，就是利用 history.pushState API 来完成 URL 跳转而无须重新加载页面； 由于hash模式会在url中自带#，如果不想要很丑的 hash，我们可以用路由的 history 模式，只需要在配置路由规则时，加入”mode: ‘history’”,这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。 //main.js文件中 1234const router = new VueRouter(&#123; mode: ‘history’, routes: […]&#125;) 当使用 history 模式时，URL 就像正常的 url，例如 yoursite.com/user/id，比较好… 不过这种模式有点问题，还需要后台配置支持。你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面，如果不这么做，直接访问页面空白 配置Apache第一步：新建：.htaccess文件放在服务器根目录下 （命令type null&gt;.htaccess） 12345678&lt;IfModule mod_rewrite.c&gt; RewriteEngine On RewriteBase / RewriteRule ^index.html$ - [L] RewriteCond %&#123;REQUEST_FILENAME&#125; !-f RewriteCond %&#123;REQUEST_FILENAME&#125; !-d RewriteRule . /index.html [L]&lt;/IfModule&gt; 除了 mod_rewrite，你也可以使用 FallbackResource。 第二步： src/router/index.js mode: ‘history’, base: ‘/dist/’, 第三步：访问：地址进行测试 abstract模式 abstract模式是使用一个不依赖于浏览器的浏览历史虚拟管理后端。 根据平台差异可以看出，在 Weex 环境中只支持使用 abstract 模式。 不过，vue-router 自身会对环境做校验，如果发现没有浏览器的 API，vue-router 会自动强制进入 abstract 模式，所以 在使用 vue-router 时只要不写 mode 配置即可，默认会在浏览器环境中使用 hash 模式，在移动端原生环境中使用 abstract 模式。 （当然，你也可以明确指定在所有情况下都使用 abstract 模式） Vuex用户在组件中发起动作，然后从API中拿数据，就会牵扯到异步操作，所以我们通过dispatch来提交一个action，在action里面发起ajax请求，拿到数据以后我们只需要通过commit提交mutations改变我的state状态就可以了，状态改变后视图就会改变因为Vuex是响应式的，这就是Vuex的运作流程机制 vuex中如何异步修改数据Action 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 荣耀黄金1. Vue的优点？Vue的缺点？优点：渐进式，组件化，轻量级，虚拟dom，响应式，单页面路由，数据与视图分开 缺点：单页面不利于seo，不支持IE8以下，首屏加载时间长 2. 为什么说Vue是一个渐进式框架？渐进式：通俗点讲就是，你想用啥你就用啥，咱也不强求你。你想用component就用，不用也行，你想用vuex就用，不用也可以 图片 image.png 3. Vue跟React的异同点？相同点： 1.都使用了虚拟dom 2.组件化开发 3.都是单向数据流(父子组件之间，不建议子修改父传下来的数据) 4.都支持服务端渲染 不同点： 1.React的JSX，Vue的template 2.数据变化，React手动(setState)，Vue自动(初始化已响应式处理，Object.defineProperty) 3.React单向绑定，Vue双向绑定 4.React的Redux，Vue的Vuex 4. MVVM是什么？和MVC有何区别呢？MVC Model(模型)：负责从数据库中取数据 View(视图)：负责展示数据的地方 Controller(控制器)：用户交互的地方，例如点击事件等等 思想：Controller将Model的数据展示在View上 图片 image.png MVVM VM：也就是View-Model，做了两件事达到了数据的双向绑定 一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。 思想：实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素，来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变（对应Vue数据驱动的思想） 图片 image.png 区别 整体看来，MVVM 比 MVC 精简很多，不仅简化了业务与界面的依赖，还解决了数据频繁更新的问题，不用再用选择器操作 DOM 元素。因为在 MVVM 中，View 不知道 Model 的存在，Model 和 ViewModel 也观察不到 View，这种低耦合模式提高代码的可重用性 Vue是不是MVVM框架？ Vue是MVVM框架，但是不是严格符合MVVM，因为MVVM规定Model和View不能直接通信，而Vue的ref可以做到这点 5. Vue和JQuery的区别在哪？为什么放弃JQuery用Vue？ 1.jQuery是直接操作DOM，Vue不直接操作DOM，Vue的数据与视图是分开的，Vue只需要操作数据即可 2.jQuery的操作DOM行为是频繁的，而Vue利用虚拟DOM的技术，大大提高了更新DOM时的性能 3.Vue中不倡导直接操作DOM，开发者只需要把大部分精力放在数据层面上 4.Vue集成的一些库，大大提高开发效率，比如Vuex，Router等 6. Vue的作者是谁？大声说出它的名字！！！他的名字就是：鱿鱼西 永恒钻石7. 为什么data是个函数并且返回一个对象呢？data之所以只一个函数，是因为一个组件可能会多处调用，而每一次调用就会执行data函数并返回新的数据对象，这样，可以避免多处调用之间的数据污染。 8. 使用过哪些Vue的修饰符呢？可以看我这篇文章「百毒不侵」面试官最喜欢问的13种Vue修饰符[1] 图片 截屏2021-07-11 下午9.56.53.png 9. 使用过哪些Vue的内部指令呢？ 图片 image.png 10. 组件之间的传值方式有哪些？ 父组件传值给子组件，子组件使用props进行接收 子组件传值给父组件，子组件使用$emit+事件对父组件进行传值 组件中可以使用$parent和$children获取到父组件实例和子组件实例，进而获取数据 使用$attrs和$listeners，在对一些组件进行二次封装时可以方便传值，例如A-&gt;B-&gt;C 使用$refs获取组件实例，进而获取数据 使用Vuex进行状态管理 使用eventBus进行跨组件触发事件，进而传递数据 使用provide和inject，官方建议我们不要用这个，我在看ElementUI源码时发现大量使用 使用浏览器本地缓存，例如localStorage 11. 路由有哪些模式呢？又有什么不同呢？ hash模式：通过#号后面的内容的更改，触发hashchange事件，实现路由切换 history模式：通过pushState和replaceState切换url，触发popstate事件，实现路由切换，需要后端配合 12. 如何设置动态class，动态style？ 动态class对象：&lt;div :class={ &#39;is-active&#39;: true, &#39;red&#39;: isRed }&gt;&lt;/div&gt; 动态class数组：&lt;div :class=[&#39;is-active&#39;, isRed ? &#39;red&#39; : &#39;&#39; ]&gt;&lt;/div&gt; 动态style对象：&lt;div :style={ color: textColor, fontSize: &#39;18px&#39; }&gt;&lt;/div&gt; 动态style数组：&lt;div :style=[{ color: textColor, fontSize: &#39;18px&#39; }, { fontWeight: &#39;300&#39; }]&gt;&lt;/div&gt; 13. v-if和v-show有何区别？ 1.v-if是通过控制dom元素的删除和生成来实现显隐，每一次显隐都会使组件重新跑一遍生命周期，因为显隐决定了组件的生成和销毁 2.v-show是通过控制dom元素的css样式来实现显隐，不会销毁 3.频繁或者大数量显隐使用v-show，否则使用v-if 14. computed和watch有何区别？ 1.computed是依赖已有的变量来计算一个目标变量，大多数情况都是多个变量凑在一起计算出一个变量，并且computed具有缓存机制，依赖值不变的情况下其会直接读取缓存进行复用，computed不能进行异步操作 2.watch是监听某一个变量的变化，并执行相应的回调函数，通常是一个变量的变化决定多个变量的变化，watch可以进行异步操作 3.简单记就是：一般情况下computed是多对一，watch是一对多 15. Vue的生命周期，讲一讲？ 图片 16. 为什么v-if和v-for不建议用在同一标签？在Vue2中，v-for优先级是高于v-if的，咱们来看例子 123&lt;div v-for=item in [1, 2, 3, 4, 5, 6, 7] v-if=item !== 3&gt; &#123;&#123;item&#125;&#125;&lt;/div&gt; 上面的写法是v-for和v-if同时存在，会先把7个元素都遍历出来，然后再一个个判断是否为3，并把3给隐藏掉，这样的坏处就是，渲染了无用的3节点，增加无用的dom操作，建议使用computed来解决这个问题： 123456789&lt;div v-for=item in list&gt; &#123;&#123;item&#125;&#125;&lt;/div&gt;computed() &#123; list() &#123; return [1, 2, 3, 4, 5, 6, 7].filter(item =&gt; item !== 3) &#125; &#125; 17. vuex的有哪些属性？用处是什么？ 图片 image.png State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。 Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。 Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。 Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。 Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。 至尊星耀18. 不需要响应式的数据应该怎么处理？在我们的Vue开发中，会有一些数据，从始至终都未曾改变过，这种死数据，既然不改变，那也就不需要对他做响应式处理了，不然只会做一些无用功消耗性能，比如一些写死的下拉框，写死的表格数据，这些数据量大的死数据，如果都进行响应式处理，那会消耗大量性能。 1234567891011121314151617181920// 方法一：将数据定义在data之外data () &#123; this.list1 = &#123; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &#125; this.list2 = &#123; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &#125; this.list3 = &#123; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &#125; this.list4 = &#123; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &#125; this.list5 = &#123; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &#125; return &#123;&#125; &#125; // 方法二：Object.freeze()data () &#123; return &#123; list1: Object.freeze(&#123;xxxxxxxxxxxxxxxxxxxxxxxx&#125;), list2: Object.freeze(&#123;xxxxxxxxxxxxxxxxxxxxxxxx&#125;), list3: Object.freeze(&#123;xxxxxxxxxxxxxxxxxxxxxxxx&#125;), list4: Object.freeze(&#123;xxxxxxxxxxxxxxxxxxxxxxxx&#125;), list5: Object.freeze(&#123;xxxxxxxxxxxxxxxxxxxxxxxx&#125;), &#125; &#125; 19. watch有哪些属性，分别有什么用？当我们监听一个基本数据类型时： 12345watch: &#123; value () &#123; // do something &#125;&#125; 当我们监听一个引用数据类型时： 123456789watch: &#123; obj: &#123; handler () &#123; // 执行回调 // do something &#125;, deep: true, // 是否进行深度监听 immediate: true // 是否初始执行handler函数 &#125;&#125; 20. 父子组件生命周期顺序父beforeCreate -&gt; 父created -&gt; 父beforeMount -&gt; 子beforeCreate -&gt; 子created -&gt; 子beforeMount -&gt; 子mounted -&gt; 父mounted 21. 对象新属性无法更新视图，删除属性无法更新视图，为什么？怎么办？ 原因：Object.defineProperty没有对对象的新属性进行属性劫持 对象新属性无法更新视图：使用Vue.$set(obj, key, value)，组件中this.$set(obj, key, value) 删除属性无法更新视图：使用Vue.$delete(obj, key)，组件中this.$delete(obj, key) 22. 直接arr[index] = xxx无法更新视图怎么办？为什么？怎么办？ 原因：Vue没有对数组进行Object.defineProperty的属性劫持，所以直接arr[index] = xxx是无法更新视图的 使用数组的splice方法，arr.splice(index, 1, item) 使用Vue.$set(arr, index, value) 24. 插槽的使用以及原理？建议看我这篇文章「Vue源码学习」你真的知道插槽Slot是怎么“插”的吗[3] 25. 为什么不建议用index做key，为什么不建议用随机数做key？举个例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;div v-for=(item, index) in list :key=index&gt;&#123;&#123;item.name&#125;&#125;&lt;/div&gt;list: [ &#123; name: &apos;小明&apos;, id: &apos;123&apos; &#125;, &#123; name: &apos;小红&apos;, id: &apos;124&apos; &#125;, &#123; name: &apos;小花&apos;, id: &apos;125&apos; &#125;]渲染为&lt;div key=0&gt;小明&lt;/div&gt;&lt;div key=1&gt;小红&lt;/div&gt;&lt;div key=2&gt;小花&lt;/div&gt;现在我执行 list.unshift(&#123; name: &apos;小林&apos;, id: &apos;122&apos; &#125;)渲染为&lt;div key=0&gt;小林&lt;/div&gt;&lt;div key=1&gt;小明&lt;/div&gt;&lt;div key=2&gt;小红&lt;/div&gt;&lt;div key=3&gt;小花&lt;/div&gt;新旧对比&lt;div key=0&gt;小明&lt;/div&gt; &lt;div key=0&gt;小林&lt;/div&gt;&lt;div key=1&gt;小红&lt;/div&gt; &lt;div key=1&gt;小明&lt;/div&gt;&lt;div key=2&gt;小花&lt;/div&gt; &lt;div key=2&gt;小红&lt;/div&gt; &lt;div key=3&gt;小花&lt;/div&gt;可以看出，如果用index做key的话，其实是更新了原有的三项，并新增了小花，虽然达到了渲染目的，但是损耗性能现在我们使用id来做key，渲染为&lt;div key=123&gt;小明&lt;/div&gt;&lt;div key=124&gt;小红&lt;/div&gt;&lt;div key=125&gt;小花&lt;/div&gt;现在我执行 list.unshift(&#123; name: &apos;小林&apos;, id: &apos;122&apos; &#125;)，渲染为&lt;div key=122&gt;小林&lt;/div&gt;&lt;div key=123&gt;小明&lt;/div&gt;&lt;div key=124&gt;小红&lt;/div&gt;&lt;div key=125&gt;小花&lt;/div&gt;新旧对比 &lt;div key=122&gt;小林&lt;/div&gt;&lt;div key=123&gt;小明&lt;/div&gt; &lt;div key=123&gt;小明&lt;/div&gt;&lt;div key=124&gt;小红&lt;/div&gt; &lt;div key=124&gt;小红&lt;/div&gt;&lt;div key=125&gt;小花&lt;/div&gt; &lt;div key=125&gt;小花&lt;/div&gt;可以看出，原有的三项都不变，只是新增了小林这个人，这才是最理想的结果 用index和用随机数都是同理，随机数每次都在变，做不到专一性，很渣男，也很消耗性能，所以，拒绝渣男，选择老实人 26. 说说nextTick的用处？我举个例子，在vue中： 123this.name = &apos;公众号：前端印象&apos;this.age = 18this.gender = &apos;男&apos; 我们修改了三个变量，那问题来了，是每修改一次，DOM就更新一次吗？不是的，Vue采用的是异步更新的策略，通俗点说就是，同一事件循环内多次修改，会统一进行一次视图更新，这样才能节省性能嘛 看懂了上面，那你应该也看得懂下面的例子了吧： 123456&lt;div ref=testDiv&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;name: &apos;小林&apos;this.name = &apos;公众号：前端印象&apos;console.log(this.$refs.testDiv.innerHTML) // 这里是啥呢 答案是“小林”，前面说了，Vue是异步更新，所以数据一更新，视图却还没更新，所以拿到的还是上一次的旧视图数据，那么想要拿到最新视图数据怎么办呢？ 1234this.name = &apos;公众号：前端印象&apos;this.$nextTick(() =&gt; &#123; console.log(this.$refs.testDiv.innerHTML) // 公众号：前端印象&#125;) 27. Vue的SSR是什么？有什么好处？ SSR就是服务端渲染 基于nodejs serve服务环境开发，所有html代码在服务端渲染 数据返回给前端，然后前端进行“激活”，即可成为浏览器识别的html代码 SSR首次加载更快，有更好的用户体验，有更好的seo优化，因为爬虫能看到整个页面的内容，如果是vue项目，由于数据还要经过解析，这就造成爬虫并不会等待你的数据加载完成，所以其实Vue项目的seo体验并不是很好 最强王者28. Vue响应式是怎么实现的？整体思路是数据劫持+观察者模式 对象内部通过defineReactive 方法，使用 Object.defineProperty 将属性进行劫持（只会劫持已经存在的属性），数组则是通过重写数组方法来实现。当页面使用对应属性时，每个属性都拥有自己的dep属性，存放他所依赖的watcher（依赖收集），当属性变化后会通知自己对应的watcher 去更新(派发更新)。 想详细了解过程，建议阅读我的Vue源码解析系列[4] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123const &#123; arrayMethods &#125; = require(&apos;./array&apos;)class Observer &#123; constructor(value) &#123; Object.defineProperty(value, &apos;__ob__&apos;, &#123; value: this, enumerable: false, writable: true, configurable: true &#125;) if(Array.isArray(value)) &#123; value.__proto__ = arrayMethods this.observeArray(value) &#125; else &#123; this.walk(value) &#125; &#125; walk(data) &#123; let keys = Object.keys(data) for(let i = 0; i &lt; keys.length; i++) &#123; const key = keys[i] const value = data[key] defineReactive(data, key, value) &#125; &#125; observeArray(items) &#123; for(let i = 0; i &lt; items.length; i++) &#123; observe(items[i]) &#125; &#125;&#125;function defineReactive(data, key, value) &#123; const childOb = observe(value) const dep = new Dep() Object.defineProperty(data, key, &#123; get() &#123; console.log(&apos;获取值&apos;) if (Dep.target) &#123; dep.depend() if (childOb) &#123; childOb.dep.depend() if (Array.isArray(value)) &#123; dependArray(value) &#125; &#125; &#125; return value &#125;, set(newVal) &#123; if (newVal === value) return observe(newVal) value = newVal dep.notify() &#125; &#125;)&#125;function observe(value) &#123; if (Object.prototype.toString.call(value) === &apos;[object Object]&apos; || Array.isArray(value)) &#123; return new Observer(value) &#125;&#125;function dependArray(value) &#123; for(let e, i = 0, l = value.length; i &lt; l; i++) &#123; e = value[i] e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend() if (Array.isArray(e)) &#123; dependArray(e) &#125; &#125;&#125;// array.jsconst arrayProto = Array.prototypeconst arrayMethods = Object.create(arrayProto)const methodsToPatch = [ &apos;push&apos;, &apos;pop&apos;, &apos;shift&apos;, &apos;unshift&apos;, &apos;splice&apos;, &apos;reverse&apos;, &apos;sort&apos;]methodsToPatch.forEach(method =&gt; &#123; arrayMethods[method] = function (...args) &#123; const result = arrayProto[method].apply(this, args) const ob = this.__ob__ var inserted switch (method) &#123; case &apos;push&apos;: case &apos;unshift&apos;: inserted = args break; case &apos;splice&apos;: inserted = args.slice(2) default: break; &#125; if (inserted) ob.observeArray(inserted) ob.dep.notify() return result &#125;&#125;) 29. 为什么只对对象劫持，而要对数组进行方法重写？因为对象最多也就几十个属性，拦截起来数量不多，但是数组可能会有几百几千项，拦截起来非常耗性能，所以直接重写数组原型上的方法，是比较节省性能的方案 30. Vue的模板编译原理？因为这个问题讲起来可能比较长，所以： 建议看我这篇「Vue源码学习(二)」你不知道的-模板编译原理[5] 31. Vue的computed和watch的原理？因为这个问题讲起来可能比较长，所以： 建议看我这篇「Vue源码学习(四)」立志写一篇人人都看的懂的computed，watch原理[6] 32. Vue.set方法的原理？12345678910111213141516171819202122function set(target, key, val) &#123; // 判断是否是数组 if (Array.isArray(target)) &#123; // 判断谁大谁小 target.length = Math.max(target.length, key) // 执行splice target.splice(key, 1, val) return val &#125; const ob = target.__ob__ // 如果此对象没有不是响应式对象，直接设置并返回 if (key in target &amp;&amp; !(key in target.prototype) || !ob) &#123; target[key] = val return val &#125; // 否则，新增属性，并响应式处理 defineReactive(target, key, val) return val&#125; 33. Vue.delete方法的原理？12345678910111213141516171819202122function del (target, key) &#123; // 判断是否为数组 if (Array.isArray(target)) &#123; // 执行splice target.splice(key, 1) return &#125; const ob = target.__ob__ // 对象本身就没有这个属性，直接返回 if (!(key in target)) return // 否则，删除这个属性 delete target[key] // 判断是否是响应式对象，不是的话，直接返回 if (!ob) return // 是的话，删除后要通知视图更新 ob.dep.notify()&#125; 34. nextTick的原理？1234567891011121314151617181920212223242526272829303132333435363738394041424344454647let callbacks = []; //回调函数let pending = false;function flushCallbacks() &#123; pending = false; //把标志还原为false // 依次执行回调 for (let i = 0; i &lt; callbacks.length; i++) &#123; callbacks[i]( i); &#125;&#125;let timerFunc; //先采用微任务并按照优先级优雅降级的方式实现异步刷新if (typeof Promise !== undefined) &#123; // 如果支持promise const p = Promise.resolve(); timerFunc = () =&gt; &#123; p.then(flushCallbacks); &#125;;&#125; else if (typeof MutationObserver !== undefined) &#123; // MutationObserver 主要是监听dom变化 也是一个异步方法 let counter = 1; const observer = new MutationObserver(flushCallbacks); const textNode = document.createTextNode(String(counter)); observer.observe(textNode, &#123; characterData: true, &#125;); timerFunc = () =&gt; &#123; counter = (counter + 1) % 2; textNode.data = String(counter); &#125;;&#125; else if (typeof setImmediate !== undefined) &#123; // 如果前面都不支持 判断setImmediate timerFunc = () =&gt; &#123; setImmediate(flushCallbacks); &#125;;&#125; else &#123; // 最后降级采用setTimeout timerFunc = () =&gt; &#123; setTimeout(flushCallbacks, 0); &#125;;&#125;export function nextTick(cb) &#123; callbacks.push(cb); if (!pending) &#123; pending = true; timerFunc(); &#125;&#125; 冷门的知识点36. 如果子组件改变props里的数据会发生什么props可以修改对象的属性值，不能直接改其他类型的值 改变的props数据是基本类型 如果修改的是基本类型，则会报错 123456props: &#123; num: Number, &#125;created() &#123; this.num = 999 &#125; 图片 0458e2ff1538ee85d42953cec9a94ca.png 改变的props数据是引用类型 123456789101112props: &#123; item: &#123; default: () =&gt; &#123;&#125;, &#125; &#125;created() &#123; // 不报错，并且父级数据会跟着变 this.item.name = &apos;sanxin&apos;; // 会报错，跟基础类型报错一样 this.item = &apos;sss&apos; &#125;, 37. props怎么自定义验证1234567891011props: &#123; num: &#123; default: 1, validator: function (value) &#123; // 返回值为true则验证不通过，报错 return [ 1, 2, 3, 4, 5 ].indexOf(value) !== -1 &#125; &#125; &#125; 38. watch的immediate属性有什么用？ 比如平时created时要请求一次数据，并且当搜索值改变，也要请求数据，我们会这么写： 12345678created()&#123; this.getList()&#125;,watch: &#123; searchInputValue()&#123; this.getList() &#125;&#125; 使用immediate完全可以这么写，当它为true时，会初始执行一次 123456watch: &#123; searchInputValue:&#123; handler: &apos;getList&apos;, immediate: true &#125;&#125; 39. watch监听一个对象时，如何排除某些属性的监听 下面代码是，params发生改变就重新请求数据，无论是a，b，c，d属性改变 123456789101112131415161718data() &#123; return &#123; params: &#123; a: 1, b: 2, c: 3, d: 4 &#125;, &#125;; &#125;,watch: &#123; params: &#123; deep: true, handler() &#123; this.getList; &#125;, &#125;, &#125; 但是如果我只想要a，b改变时重新请求，c，d改变时不重新请求呢？ 123456789101112131415161718192021222324252627mounted() &#123; Object.keys(this.params) .filter((_) =&gt; ![c, d].includes(_)) // 排除对c，d属性的监听 .forEach((_) =&gt; &#123; this.$watch((vm) =&gt; vm.params[_], handler, &#123; deep: true, &#125;); &#125;); &#125;,data() &#123; return &#123; params: &#123; a: 1, b: 2, c: 3, d: 4 &#125;, &#125;; &#125;,watch: &#123; params: &#123; deep: true, handler() &#123; this.getList; &#125;, &#125;, &#125; 欢迎关注公众号：前端印象，每日精选好文推送 40. 审查元素时发现data-v-xxxxx，这是啥？ 图片 image.png 这是在标记vue文件中css时使用scoped标记产生的，因为要保证各文件中的css不相互影响，给每个component都做了唯一的标记，所以每引入一个component就会出现一个新的’data-v-xxx’标记 41. computed如何实现传参？1234567891011// html&lt;div&gt;&#123;&#123; total(3) &#125;&#125;// jscomputed: &#123; total() &#123; return function(n) &#123; return n * this.num &#125; &#125;, &#125; 42. vue的hook的使用 同一组件中使用 这是我们常用的使用定时器的方式 123456789101112131415export default&#123; data()&#123; timer:null &#125;, mounted()&#123; this.timer = setInterval(()=&gt;&#123; //具体执行内容 console.log(&apos;1&apos;); &#125;,1000); &#125; beforeDestory()&#123; clearInterval(this.timer); this.timer = null; &#125;&#125; 上面做法不好的地方在于：得全局多定义一个timer变量，可以使用hook这么做： 1234567891011121314export default&#123; methods:&#123; fn()&#123; const timer = setInterval(()=&gt;&#123; //具体执行代码 console.log(&apos;1&apos;); &#125;,1000); this.$once(&apos;hook:beforeDestroy&apos;,()=&gt;&#123; clearInterval(timer); timer = null; &#125;) &#125; &#125;&#125; 7.2 父子组件使用 如果子组件需要在mounted时触发父组件的某一个函数，平时都会这么写： 12345678910111213//父组件&lt;rl-child @childMounted=childMountedHandle/&gt;method () &#123; childMountedHandle() &#123; // do something... &#125;&#125;,// 子组件mounted () &#123; this.$emit(&apos;childMounted&apos;)&#125;, 使用hook的话可以更方便： 12345678//父组件&lt;rl-child @hook:mounted=childMountedHandle/&gt;method () &#123; childMountedHandle() &#123; // do something... &#125;&#125;, 43. provide和inject是响应式的吗？123456789101112131415161718192021222324// 祖先组件provide()&#123; return &#123; // keyName: &#123; name: this.name &#125;, // value 是对象才能实现响应式，也就是引用类型 keyName: this.changeValue // 通过函数的方式也可以[注意，这里是把函数作为value，而不是this.changeValue()] // keyName: &apos;test&apos; value 如果是基本类型，就无法实现响应式 &#125; &#125;,data()&#123; return &#123; name:&apos;张三&apos;&#125; &#125;, methods: &#123; changeValue()&#123; this.name = &apos;改变后的名字-李四&apos; &#125; &#125; // 后代组件 inject:[&apos;keyName&apos;] create()&#123; console.log(this.keyName) // 改变后的名字-李四&#125; 44.Vue的el属性和 $mount优先级？ 比如下面这种情况，Vue会渲染到哪个节点上 123456new Vue(&#123; router, store, el: &apos;#app&apos;, render: h =&gt; h(App)&#125;).$mount(&apos;#ggg&apos;) 这是官方的一张图，可以看出el和$mount同时存在时，el优先级 &gt; $mount 图片 image.png 45. 动态指令和参数使用过吗？12345678910111213141516171819&lt;template&gt; ... &lt;aButton @[someEvent]=handleSomeEvent() :[someProps]=1000 /&gt;...&lt;/template&gt;&lt;script&gt; ... data()&#123; return&#123; ... someEvent: someCondition ? click : dbclick, someProps: someCondition ? num : price &#125; &#125;, methods: &#123; handleSomeEvent()&#123; // handle some event &#125; &#125; &lt;/script&gt; 46. 相同的路由组件如何重新渲染？ 开发人员经常遇到的情况是，多个路由解析为同一个Vue组件。问题是，Vue出于性能原因，默认情况下共享组件将不会重新渲染，如果你尝试在使用相同组件的路由之间进行切换，则不会发生任何变化。 12345678910const routes = [ &#123; path: /a, component: MyComponent &#125;, &#123; path: /b, component: MyComponent &#125;,]; 如果依然想重新渲染，怎么办呢？可以使用key 123&lt;template&gt; &lt;router-view :key=$route.path&gt;&lt;/router-view&gt;&lt;/template&gt; 47. 自定义v-model 默认情况下，v-model 是 @input 事件侦听器和 :value 属性上的语法糖。但是，你可以在你的Vue组件中指定一个模型属性来定义使用什么事件和value属性——非常棒！ 123456export default: &#123; model: &#123; event: &apos;change&apos;, prop: &apos;checked&apos; &#125;&#125; 48. 如何将获取data中某一个数据的初始状态？ 在开发中，有时候需要拿初始状态去计算。例如 1234567891011121314data() &#123; return &#123; num: 10 &#125;,mounted() &#123; this.num = 1000 &#125;,methods: &#123; howMuch() &#123; // 计算出num增加了多少，那就是1000 - 初始值 // 可以通过this.$options.data().xxx来获取初始值 console.log(1000 - this.$options.data().num) &#125; &#125; 49.为什么不建议v-for和v-if同时存在123&lt;div v-for=item in [1, 2, 3, 4, 5, 6, 7] v-if=item !== 3&gt; &#123;&#123;item&#125;&#125;&lt;/div&gt; 上面的写法是v-for和v-if同时存在，会先把7个元素都遍历出来，然后再一个个判断是否为3，并把3给隐藏掉，这样的坏处就是，渲染了无用的3节点，增加无用的dom操作，建议使用computed来解决这个问题： 123456789&lt;div v-for=item in list&gt; &#123;&#123;item&#125;&#125;&lt;/div&gt;computed() &#123; list() &#123; return [1, 2, 3, 4, 5, 6, 7].filter(item =&gt; item !== 3) &#125; &#125; 50.计算变量时，methods和computed哪个好？123456789101112131415161718192021&lt;div&gt; &lt;div&gt;&#123;&#123;howMuch1()&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123;howMuch2()&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123;index&#125;&#125;&lt;/div&gt;&lt;/div&gt;data: () &#123; return &#123; index: 0 &#125; &#125;methods: &#123; howMuch1() &#123; return this.num + this.price &#125; &#125;computed() &#123; howMuch2() &#123; return this.num + this.price &#125; &#125; computed会好一些，因为computed会有缓存。例如index由0变成1，那么会触发视图更新，这时候methods会重新执行一次，而computed不会，因为computed依赖的两个变量num和price都没变。","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://qw8.github.io/tags/vue/"},{"name":"MVVM","slug":"MVVM","permalink":"https://qw8.github.io/tags/MVVM/"}]},{"title":"JavaScript执行机制","slug":"knowledges/JavaScript执行机制","date":"2024-02-27T02:24:57.000Z","updated":"2024-04-03T16:14:34.000Z","comments":true,"path":"/knowledges/javascript-zhi-xing-ji-zhi.html","link":"","permalink":"https://qw8.github.io/knowledges/javascript-zhi-xing-ji-zhi.html","excerpt":"","text":"不论你是javascript新手还是老鸟，不论是面试求职，还是日常开发工作，我们经常会遇到这样的情况：给定的几行代码，我们需要知道其输出内容和顺序。因为javascript是一门单线程语言，所以我们可以得出结论： javascript是按照语句出现的顺序执行的 看到这里读者要打人了：我难道不知道js是一行一行执行的？还用你说？稍安勿躁，正因为js是一行一行执行的，所以我们以为js都是这样的： 12345let a = '1';console.log(a);let b = '2';console.log(b); img 然而实际上js是这样的： 1234567891011121314setTimeout(function()&#123; console.log('定时器开始啦')&#125;);new Promise(function(resolve)&#123; console.log('马上执行for循环啦'); for(var i = 0; i &lt; 10000; i++)&#123; i == 99 &amp;&amp; resolve(); &#125;&#125;).then(function()&#123; console.log('执行then函数啦')&#125;);console.log('代码执行结束'); img 依照js是按照语句出现的顺序执行这个理念，我自信的写下输出结果： 1234//\"定时器开始啦\"//\"马上执行for循环啦\"//\"执行then函数啦\"//\"代码执行结束\" 去chrome上验证下，结果完全不对，瞬间懵了，说好的一行一行执行的呢？ img 我们真的要彻底弄明白javascript的执行机制了。 1.关于javascriptjavascript是一门单线程语言，在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。所以一切javascript版的”多线程”都是用单线程模拟出来的，一切javascript多线程都是纸老虎！ 2.javascript事件循环既然js是单线程，那就像只有一个窗口的银行，客户需要排队一个一个办理业务，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此聪明的程序员将任务分为两类： 同步任务 异步任务 当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。关于这部分有严格的文字定义，但本文的目的是用最小的学习成本彻底弄懂执行机制，所以我们用导图来说明： img 导图要表达的内容用文字来表述的话： 同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。 当指定的事情完成时，Event Table会将这个函数移入Event Queue。 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。 上述过程会不断重复，也就是常说的Event Loop(事件循环)。 我们不禁要问了，那怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。 说了这么多文字，不如直接一段代码更直白： 123456789let data = [];$.ajax(&#123; url:www.javascript.com, data:data, success:() =&gt; &#123; console.log('发送成功!'); &#125;&#125;)console.log('代码执行结束'); 上面是一段简易的ajax请求代码： ajax进入Event Table，注册回调函数success。 执行console.log(&#39;代码执行结束&#39;)。 ajax事件完成，回调函数success进入Event Queue。 主线程从Event Queue读取回调函数success并执行。 相信通过上面的文字和代码，你已经对js的执行顺序有了初步了解。接下来我们来研究进阶话题：setTimeout。 3.又爱又恨的setTimeout大名鼎鼎的setTimeout无需再多言，大家对他的第一印象就是异步可以延时执行，我们经常这么实现延时3秒执行： 123setTimeout(() =&gt; &#123; console.log('延时3秒');&#125;,3000) 渐渐的setTimeout用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，这又咋回事啊？ 先看一个例子： 1234setTimeout(() =&gt; &#123; task();&#125;,3000)console.log('执行console'); 根据前面我们的结论，setTimeout是异步的，应该先执行console.log这个同步任务，所以我们的结论是： 12//执行console//task() 去验证一下，结果正确！ 然后我们修改一下前面的代码： 12345setTimeout(() =&gt; &#123; task()&#125;,3000)sleep(10000000) 乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行task()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？ 这时候我们需要重新理解setTimeout的定义。我们先说上述代码是怎么执行的： task()进入Event Table并注册,计时开始。 执行sleep函数，很慢，非常慢，计时仍在继续。 3秒到了，计时事件timeout完成，task()进入Event Queue，但是sleep也太慢了吧，还没执行完，只好等着。 sleep终于执行完了，task()终于从Event Queue进入了主线程执行。 上述的流程走完，我们知道setTimeout这个函数，是经过指定时间后，把要执行的任务(本例中为task())加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。 我们还经常遇到setTimeout(fn,0)这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？ 答案是不会的，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明： 12345678910//代码1console.log('先执行这里');setTimeout(() =&gt; &#123; console.log('执行啦')&#125;,0);//代码2console.log('先执行这里');setTimeout(() =&gt; &#123; console.log('执行啦')&#125;,3000); 代码1的输出结果是： 12//先执行这里//执行啦 代码2的输出结果是： 123//先执行这里// ... 3s later// 执行啦 关于setTimeout要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。有兴趣的同学可以自行了解。 4.又恨又爱的setInterval上面说完了setTimeout，当然不能错过它的孪生兄弟setInterval。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，setInterval会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。 唯一需要注意的一点是，对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。这句话请读者仔细品味。 5.Promise与process.nextTick(callback)传统的定时器我们已经研究过了，接着我们探究Promise与process.nextTick(callback)的表现。 Promise的定义和功能本文不再赘述，不了解的读者可以学习一下阮一峰老师的Promise。而process.nextTick(callback)类似node.js版的”setTimeout”，在事件循环的下一次循环中调用 callback 回调函数。 我们进入正题，除了广义的同步任务和异步任务，我们对任务有更精细的定义： macro-task(宏任务)：包括整体代码script，setTimeout，setInterval micro-task(微任务)：Promise，process.nextTick 不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同的Event Queue。 事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。听起来有点绕，我们用文章最开始的一段代码说明： 1234567891011setTimeout(function() &#123; console.log('setTimeout');&#125;)new Promise(function(resolve) &#123; console.log('promise');&#125;).then(function() &#123; console.log('then');&#125;)console.log('console'); 这段代码作为宏任务，进入主线程。 先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述) 接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。 遇到console.log()，立即执行。 好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了then在微任务Event Queue里面，执行。 ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。 结束。 事件循环，宏任务，微任务的关系如图所示： img 我们来分析一段较复杂的代码，看看你是否真的掌握了js的执行机制： 123456789101112131415161718192021222324252627282930313233343536console.log('1');setTimeout(function() &#123; console.log('2'); process.nextTick(function() &#123; console.log('3'); &#125;) new Promise(function(resolve) &#123; console.log('4'); resolve(); &#125;).then(function() &#123; console.log('5') &#125;)&#125;)process.nextTick(function() &#123; console.log('6');&#125;)new Promise(function(resolve) &#123; console.log('7'); resolve();&#125;).then(function() &#123; console.log('8')&#125;)setTimeout(function() &#123; console.log('9'); process.nextTick(function() &#123; console.log('10'); &#125;) new Promise(function(resolve) &#123; console.log('11'); resolve(); &#125;).then(function() &#123; console.log('12') &#125;)&#125;) 第一轮事件循环流程分析如下： 整体script作为第一个宏任务进入主线程，遇到console.log，输出1。 遇到setTimeout，其回调函数被分发到宏任务Event Queue中。我们暂且记为setTimeout1。 遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。我们记为process1。 遇到Promise，new Promise直接执行，输出7。then被分发到微任务Event Queue中。我们记为then1。 又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，我们记为setTimeout2。 宏任务Event Queue 微任务Event Queue setTimeout1 process1 setTimeout2 then1 上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。 我们发现了process1和then1两个微任务。 执行process1,输出6。 执行then1，输出8。 好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从setTimeout1宏任务开始： 首先输出2。接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2。new Promise立即执行输出4，then也分发到微任务Event Queue中，记为then2。 宏任务Event Queue 微任务Event Queue setTimeout2 process2 then2 第二轮事件循环宏任务结束，我们发现有process2和then2两个微任务可以执行。 输出3。 输出5。 第二轮事件循环结束，第二轮输出2，4，3，5。 第三轮事件循环开始，此时只剩setTimeout2了，执行。 直接输出9。 将process.nextTick()分发到微任务Event Queue中。记为process3。 直接执行new Promise，输出11。 将then分发到微任务Event Queue中，记为then3。 宏任务Event Queue 微任务Event Queue process3 then3 第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。 输出10。 输出12。 第三轮事件循环结束，第三轮输出9，11，10，12。 整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。 (请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差) 6.写在最后(1)js的异步我们从最开头就说javascript是一门单线程语言，不管是什么新框架新语法糖实现的所谓异步，其实都是用同步的方法去模拟的，牢牢把握住单线程这点非常重要。 (2)事件循环Event Loop事件循环是js实现异步的一种方法，也是js的执行机制。 (3)javascript的执行和运行执行和运行有很大的区别，javascript在不同的环境下，比如node，浏览器，Ringo等等，执行方式是不同的。而运行大多指javascript解析引擎，是统一的。 (4)setImmediate微任务和宏任务还有很多种类，比如setImmediate等等，执行都是有共同点的，有兴趣的同学可以自行了解。 (5)最后的最后 javascript是一门单线程语言 Event Loop是javascript的执行机制 牢牢把握两个基本点，以认真学习javascript为中心，早日实现成为前端高手的伟大梦想！ img 原文链接：https://juejin.cn/post/6844903512845860872 代码题: 看代码说结果, 事件循环 + async 函数1.基本的 async/await 和事件循环1234567891011console.log(&apos;1&apos;);async function asyncFunc() &#123; console.log(&apos;2&apos;); await Promise.resolve(); console.log(&apos;3&apos;);&#125;asyncFunc();console.log(&apos;4&apos;); 执行顺序：执行顺序： 打印 1 定义异步函数 asyncFunc，但并不执行它。 调用 1asyncFunc() 打印 2 遇到 await，所以 asyncFunc 的后续代码（打印 3）被移到事件队列中等待。 打印 4 所有同步代码执行完毕后，事件循环开始执行队列中的任务。 打印 3 预期输出：12341234 2.setTimeout 和 async/await 的结合123456789101112131415console.log(&apos;1&apos;);setTimeout(() =&gt; &#123; console.log(&apos;2&apos;);&#125;, 0);async function asyncFunc() &#123; console.log(&apos;3&apos;); await Promise.resolve(); console.log(&apos;4&apos;);&#125;asyncFunc();console.log(&apos;5&apos;); 执行顺序： 打印 1 将 setTimeout 回调（打印 2）设置为在0毫秒后执行。但实际上，它会被放入宏任务队列，等待所有微任务完成。 定义异步函数 asyncFunc，但并不执行。 调用 asyncFunc()。打印 3遇到 await，所以 asyncFunc 的后续代码（打印 4）被移到微任务队列中等待。 打印 5 执行微任务队列中的任务（因为微任务的优先级高于宏任务）。打印 4 执行宏任务队列中的任务。打印 2 预期输出：1234513542 3.嵌套的 async/await1234567891011121314151617console.log(&apos;1&apos;);async function firstAsync() &#123; console.log(&apos;2&apos;); await secondAsync(); console.log(&apos;3&apos;);&#125;async function secondAsync() &#123; console.log(&apos;4&apos;); await Promise.resolve(); console.log(&apos;5&apos;);&#125;firstAsync();console.log(&apos;6&apos;); 执行顺序： 打印 1 定义两个异步函数，但不执行。 调用 firstAsync()。打印 2调用 secondAsync()。打印 4 遇到 await，所以 secondAsync 的后续代码（打印 5）被移到微任务队列中等待。firstAsync 的后续代码（打印 3）也被移到微任务队列中等待。 打印 6 执行微任务队列中的任务。打印 5打印 3 预期输出：123456124653 4.多个异步函数123456789101112131415161718async function asyncOne() &#123; console.log(&apos;1&apos;); await Promise.resolve(); console.log(&apos;2&apos;);&#125;async function asyncTwo() &#123; console.log(&apos;3&apos;); await Promise.resolve(); console.log(&apos;4&apos;);&#125;console.log(&apos;5&apos;);asyncOne();asyncTwo();console.log(&apos;6&apos;); 执行顺序： 定义两个异步函数，但不执行。 打印 5 调用 asyncOne()。打印 1遇到 await，所以 asyncOne 的后续代码（打印 2）被移到微任务队列中等待。 调用 asyncTwo()。打印 3遇到 await，所以 asyncTwo 的后续代码（打印 4）被移到微任务队列中等待。 打印 6 执行微任务队列中的任务。打印 2打印 4 预期输出：123456513624 5.Promise 的基本行为1234567console.log(&apos;1&apos;);Promise.resolve().then(() =&gt; &#123; console.log(&apos;2&apos;);&#125;);console.log(&apos;3&apos;); 执行顺序： 打印 1 创建一个已解决的Promise，并在微任务队列中注册一个回调。 打印 3 当同步代码执行完成后，事件循环开始处理微任务队列，执行回调。 打印 2 预期输出：123132 6.setTimeout 与 Promise 的组合12345678910111213console.log(&apos;1&apos;);setTimeout(() =&gt; &#123; console.log(&apos;2&apos;);&#125;, 0);Promise.resolve().then(() =&gt; &#123; console.log(&apos;3&apos;);&#125;).then(() =&gt; &#123; console.log(&apos;4&apos;);&#125;);console.log(&apos;5&apos;); 执行顺序： 打印 1 将setTimeout的回调加入宏任务队列 创建一个已解决的Promise，并在微任务队列中注册第一个回调 在第一个then的回调中，注册第二个then的回调到微任务队列 打印 5 事件循环开始处理微任务，首先执行第一个then的回调 打印 3 紧接着，事件循环处理第二个then的回调 打印 4 最后，事件循环处理宏任务队列 打印 2 预期输出：1234515342 7.多个 async/await 的嵌套1234567891011121314151617console.log(&apos;1&apos;);async function outerAsync() &#123; console.log(&apos;2&apos;); await innerAsync(); console.log(&apos;3&apos;);&#125;async function innerAsync() &#123; console.log(&apos;4&apos;); await new Promise(resolve =&gt; setTimeout(resolve, 0)); console.log(&apos;5&apos;);&#125;outerAsync();console.log(&apos;6&apos;); 执行顺序： 打印 1 定义两个异步函数，但此时并未执行它们 调用 outerAsync() 打印 2 调用 innerAsync() 打印 4 遇到setTimeout，所以它的回调被加入宏任务队列 await将后续代码（打印 5 和 outerAsync 中的打印 3）移至微任务队列 打印 6 事件循环开始处理微任务，但在此之前，必须先完成setTimeout的回调，必须要等里面完成才能完成外面 打印 5 继续执行outerAsync中的代码 打印 3 预期输出：123456124653 8.多个微任务队列（这个不会）12345678910111213141516171819console.log(&apos;1&apos;);async function firstFunc() &#123; console.log(&apos;2&apos;); await Promise.resolve(); console.log(&apos;3&apos;);&#125;async function secondFunc() &#123; console.log(&apos;4&apos;); await Promise.resolve().then(() =&gt; &#123; console.log(&apos;5&apos;); &#125;); console.log(&apos;6&apos;);&#125;firstFunc();secondFunc();console.log(&apos;7&apos;); 执行顺序： 打印 1 调用 firstFunc() 打印 2 await使其后续代码（打印 3）移到微任务队列中 调用 secondFunc() 打印 4 await和then使其后续代码（首先打印 5，然后打印 6）移到微任务队列中 打印 7 事件循环开始处理微任务队列 打印 5 打印 3 打印 6 预期输出：12345671247536 9.复杂的async/await与setTimeout1234567891011console.log(&apos;1&apos;);setTimeout(() =&gt; &#123; console.log(&apos;2&apos;);&#125;, 0);async function asyncFunction() &#123; console.log(&apos;3&apos;); await Promise.resolve(); console.log(&apos;4&apos;); setTimeout(() =&gt; &#123; 原文链接：https://blog.csdn.net/weixin_43850639/article/details/132599505","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qw8.github.io/tags/JavaScript/"}]},{"title":"python","slug":"other/python","date":"2024-02-26T01:44:06.000Z","updated":"2024-02-26T03:37:54.000Z","comments":true,"path":"/other/python.html","link":"","permalink":"https://qw8.github.io/other/python.html","excerpt":"","text":"安装Python你可以从Python官方网站（https://www.python.org/downloads/）下载并安装Python。确保下载适合你操作系统的版本。如 Windows installer (64-bit) 特别要注意勾上 Add Python 3.5 to PATH，然后“lnstall Now”即可完成安装，默认会安装到 C：\\Python35 目录下。 安装完成后， 打开命令提示符窗口（方法是点击“开始”-“运行”-输入：“cmd”），敲入 Python 后，会出现“Python 3.11.0”等内容。 文件批量按日期命名文件批量按日期命名可以通过脚本或命令行工具来实现。下面是一个使用Python脚本的示例，该脚本将指定目录下的所有文件按照日期进行重命名。 使用你选择的代码编辑器或IDE创建一个新文件rename_files_by_date.py，将下面Python代码复制粘贴进去。 1234567891011121314151617181920212223242526import os import datetime # 设置要重命名文件的目录 directory = r\"D:\\test\\images万贯\" # 使用原始字符串以避免反斜杠转义问题 # 遍历目录下的所有文件 for filename in os.listdir(directory): # 拼接完整的文件路径 filepath = os.path.join(directory, filename) # 判断是否为文件（排除目录） if os.path.isfile(filepath): # 获取当前文件的修改时间 mtime = os.path.getmtime(filepath) date = datetime.datetime.fromtimestamp(mtime) # 将文件名格式化为日期字符串，并添加文件扩展名 new_filename = date.strftime(\"%Y%m%d_%H%M%S\") + os.path.splitext(filename)[1] # 拼接新的文件路径 new_filepath = os.path.join(directory, new_filename) # 重命名文件 os.rename(filepath, new_filepath) print(f\"Renamed '&#123;filename&#125;' to '&#123;new_filename&#125;'\") 请确保将/path/to/directory替换为你要重命名文件的实际目录路径。运行脚本后，它将遍历指定目录下的所有文件，并按照文件的修改时间（以YYYYMMDD_HHMMSS的格式）对文件进行重命名。 注意：在运行脚本之前，请务必备份重要文件，以防意外情况发生。此外，脚本只会重命名文件，不会重命名子目录中的文件。如果你需要重命名子目录中的文件，请相应地修改脚本。 在Python字符串中，反斜杠\\是一个特殊字符，也被用作转义字符，因此你需要使用双反斜杠\\\\来表示一个单独的反斜杠。或者，你可以在字符串前加上r来表示原始字符串，这样反斜杠就不会被当作转义字符。 以下是两种设置directory变量的方式： 12345# 使用双反斜杠作为路径分隔符 directory = \"D:\\\\test\\\\images万贯\" # 或者使用原始字符串（在字符串前加r） directory = r\"D:\\test\\images万贯\" 请确保在编写代码时使用其中一种方式正确设置directory变量，以便脚本能够正确地找到你的文件目录。 此外，需要注意的是，在Windows系统中，文件夹名称中的空格通常不会导致问题，但在路径字符串中确保正确地处理了所有特殊字符和空格是很重要的。 为了避免在重命名文件时出现名称冲突，我们可以在文件名后面添加序号来区分。我们可以修改脚本，使其检查新文件名是否已存在，如果存在，则在文件名后面添加括号和序号，直到找到一个唯一的文件名。 我们首先从文件名中提取出扩展名。然后，我们检查由基础文件名和扩展名组成的文件名是否已存在于existing_filenames字典中。如果存在，我们就在基础文件名后面添加括号和序号，序号从1开始递增，直到找到一个唯一的文件名。每次构造出新文件名后，我们都在字典中记录它，以确保下次不会重复使用。 这样，即使同一秒内只有一个文件被修改，我们的脚本也会确保文件名是唯一的，且序号出现在文件扩展名前面。 打开命令行或终端在Windows上，你可以按Win + R，然后输入cmd并按回车。在macOS或Linux上，你可以打开终端应用程序。 导航到脚本所在目录在命令行或终端中，使用cd命令导航到保存了Python脚本的目录。例如，如果你的脚本在C:\\Users\\YourName\\Documents目录下，你可以输入： 1cd C:\\Users\\YourName\\Documents 运行脚本在命令行或终端中，输入以下命令来运行脚本： 1python rename_files_by_date.py 确保你的Python安装路径已经添加到了系统的环境变量中，这样你才能直接在命令行中运行python命令。 等待脚本执行完成脚本将开始执行，并按照上述代码中定义的逻辑重命名指定目录下的文件。你将在命令行或终端中看到重命名的进度。 注意事项 确保你有足够的权限来重命名文件。 在运行脚本之前，最好先备份你的文件，以防万一。 脚本将按照文件的修改时间进行重命名，这意味着如果两个文件有相同的修改时间，它们将被重命名为相同的文件名，这可能会导致文件覆盖。请确保这种情况不会发生，或者在脚本中添加额外的逻辑来处理这种情况。 经过一步一步修改，现在没啥问题了，可以使用这个脚本来对自己备份的图片目录来重命名，文件名就是创建日期时间，一目了然。 Python牛逼(*≧∪≦)","categories":[{"name":"其他","slug":"其他","permalink":"https://qw8.github.io/categories/其他/"}],"tags":[{"name":"python","slug":"python","permalink":"https://qw8.github.io/tags/python/"}]},{"title":"JavaScript","slug":"interview/JavaScript","date":"2024-02-14T02:24:57.000Z","updated":"2024-03-31T12:01:24.000Z","comments":true,"path":"/interview/javascript.html","link":"","permalink":"https://qw8.github.io/interview/javascript.html","excerpt":"","text":"JS的基本数据类型和引用数据类型 基本数据类型 类型 值 string 单双引号引起来的数据 number 包括整型和浮点型 undefiend 未初始化的变量 null 相当于占位符 boolean true真 false 假 Symbol ES6新增，表示独一无二且不可变的值 BigInt ES10新增，BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。 引用数据类型：object、array、function 123var obj = &#123;&#125;; // 对象var arr = []; // 数组var fn = function()&#123;&#125;; // 函数 javascript 的 typeof 返回哪些数据类型7 种分别为 string、boolean、number、Object、Function、undefined、symbol(ES6)、 检测数据类型 typeof + 变量名 检测 结果 null object {} object [] object undefined undefined string string number number boolean boolean Symbol symbol function function 数据类型转换强制类型转换 Number() 任意类型数据转化为数字 parselnt() 任意类型数据转化为整数 parseFloat() 任意类型数据转化为浮点数 String) 任意类型数据转化为字符串 Boolean() 任意类型数据转化为布尔值 隐式类型转换 算术运算符 逻辑运算符：&amp;&amp;||！运算，会调用Boolean()~函数判断参与逻辑运算的数据的真假性 关系运算符：if、while、do while语句和三元表达式 里面的判断条件表达式会隐式的调用 Boolean()函数 复杂数据类型如何转变为字符串 首先，会调用 valueOf 方法，如果方法的返回值是一个基本数据类型，就返回这个值 如果调用 valueOf 方法之后的返回值仍旧是一个复杂数据类型，就会调用该对象的 toString 方法 如果 toString 方法调用之后的返回值是一个基本数据类型，就返回这个值， 如果 toString 方法调用之后的返回值是一个复杂数据类型，就报一个错误。 JavaScript 中如何检测一个变量是一个 String 类型？答案：三种方法（typeof、constructor、Object.prototype.toString.call()） 解析： 123456789①typeoftypeof('123') === \"string\" // truetypeof '123' === \"string\" // true②constructor'123'.constructor === String // true③Object.prototype.toString.call()Object.prototype.toString.call('123') === '[object String]' // true JavaScript 有几种类型的值？你能画一下他们的内存图吗？涉及知识点： 栈：原始数据类型（Undefined、Null、Boolean、Number、String） 堆：引用数据类型（对象、数组和函数） 两种类型的区别是：存储位置不同。原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。 引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。《JavaScript 有几种类型的值？能否画一下它们的内存图；》 什么是堆？什么是栈？它们之间有什么区别和联系？堆和栈的概念存在于数据结构中和操作系统内存中。 在数据结构中 栈中数据的存取方式为先进后出。而堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。完全二叉树是堆的一种实现方式。 在操作系统中 内存被分为栈区和堆区。 栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 堆区内存一般由程序员分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收。 详细资料可以参考：《什么是堆？什么是栈？他们之间有什么区别和联系？》 null，undefined 的区别？undefined 表示不存在这个值。undefined :是一个表示”无”的原始值或者说表示”缺少值”，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined 例如变量被声明了，但没有赋值时，就等于undefined null 表示一个对象被定义了，值为“空值”null : 是一个对象(空对象, 没有任何属性和方法) 例如作为函数的参数，表示该函数的参数不是对象； 在验证null时，一定要使用 === ，因为 == 无法分别 null 和 undefined == 和 === 的不同答案：==是抽象相等运算符，而===是严格相等运算符。 ==运算符是在进行必要的类型转换后，再比较。 ===运算符不会进行类型转换，所以如果两个值不是相同的类型，会直接返回false。使用==时，可能发生一些特别的事情，例如： 1234561 == \"1\"; // true1 == [1]; // true1 == true; // true0 == \"\"; // true0 == \"0\"; // true0 == false; // true 如果你对==和===的概念不是特别了解，建议大多数情况下使用=== 如何判断 NaNisNaN()方法 解析：isNaN(NaN) // true 说几条写JavaScript的基本规范？ 代码缩进，建议使用“四个空格”缩进 代码段使用花括号{}包裹 语句结束使用分号; 变量和函数在使用前进行声明，不要在同一行声明多个变量。 以大写字母开头命名构造函数，全大写命名常量 规范定义JSON对象，补全双引号 用{}和[]声明对象和数组 请使用 ===/!==来比较true/false或者数值 使用对象字面量替代new Array这种形式 不要使用全局函数 Switch语句必须带有default分支 函数不应该有时候有返回值，有时候没有返回值。 For循环必须使用大括号，If语句必须使用大括号。 for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。 如何编写高性能的JavaScript？ 将js脚本放在页面底部，加快渲染页面 尽量减少使用闭包 将js脚本将脚本成组打包，减少请求 使用非阻塞方式下载js脚本 尽量使用局部变量来保存全局变量 遵循严格模式：”use strict”; 使用 window 对象属性方法时，省略 window 尽量减少对象成员嵌套 缓存 DOM 节点的访问 通过避免使用 eval() 和 Function() 构造器 给 setTimeout() 和 setInterval() 传递函数而不是字符串作为参数 尽量使用直接量创建对象和数组 最小化重绘(repaint)和回流(reflow) 使用 DocumentFragment 优化多次 append 通过模板元素 clone ，替代 createElement 使用一次 innerHTML 赋值代替构建 dom 元素 使用 firstChild 和 nextSibling 代替 childNodes 遍历 dom 元素 使用 Array 做为 StringBuffer ，代替字符串拼接的操作 将循环控制量保存到局部变量 顺序无关的遍历时，用 while 替代 for 将条件分支，按可能性顺序从高到低排列 在同一条件子的多（ &gt;2 ）条件分支时，使用 switch 优于 if 使用三目运算符替代条件分支 需要不断执行的时候，优先考虑使用 setInterval document load 和 document ready 的区别页面加载完成有两种事件1.load是当页面所有资源全部加载完成后（包括DOM文档树，css文件，js文件，图片资源等），执行一个函数问题：如果图片资源较多，加载时间较长，onload后等待执行的函数需要等待较长时间，所以一些效果可能受到影响 2.$(document).ready()是当DOM文档树加载完成后执行一个函数 （不包含图片，css等）所以会比load较快执行在原生的jS中不包括ready()这个方法，只有load方法就是onload事件 字符串常用操作 charAt(index):返回指定索引处的字符串 charCodeAt(index):返回指定索引处的字符的 Unicode 的值 concat(str1,str2,…):连接多个字符串，返回连接后的字符串的副本 fromCharCode():将 Unicode 值转换成实际的字符串 indexOf(str):返回 str 在父串中第一次出现的位置，若没有则返回-1 lastIndexOf(str):返回 str 在父串中最后一次出现的位置，若没有则返回-1 match(regex):搜索字符串，并返回正则表达式的所有匹配 replace(str1,str2):str1 也可以为正则表达式，用 str2 替换 str1 search(regex):基于正则表达式搜索字符串，并返回第一个匹配的位置 slice(start,end)：返回字符索引在 start 和 end（不含）之间的子串 split(sep，limit)：将字符串分割为字符数组，limit 为从头开始执行分割的最大数量 substr(start，length)：从字符索引 start 的位置开始，返回长度为 length 的子串 substring(from,to)：返回字符索引在 from 和 to（不含）之间的子串 toLowerCase()：将字符串转换为小写 toUpperCase()：将字符串转换为大写 valueOf()：返回原始字符串值 内部属性 [[Class]] 是什么？1234567891011121314151617181920所有 typeof 返回值为 &quot;object&quot; 的对象（如数组）都包含一个内部属性 [[Class]]（我们可以把它看作一个内部的分类，而非传统的面向对象意义上的类）。这个属性无法直接访问，一般通过 Object.prototype.toString(..) 来查看。例如：Object.prototype.toString.call( [1,2,3] );// &quot;[object Array]&quot;Object.prototype.toString.call( /regex-literal/i );// &quot;[object RegExp]&quot;// 我们自己创建的类就不会有这份特殊待遇，因为 toString() 找不到 toStringTag 属性时只好返回默认的 Object 标签// 默认情况类的[[Class]]返回[object Object]class Class1 &#123;&#125;Object.prototype.toString.call(new Class1()); // &quot;[object Object]&quot;// 需要定制[[Class]]class Class2 &#123; get [Symbol.toStringTag]() &#123; return &quot;Class2&quot;; &#125;&#125;Object.prototype.toString.call(new Class2()); // &quot;[object Class2]&quot; 介绍 js 有哪些内置对象？涉及知识点： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556全局的对象（ global objects ）或称标准内置对象，不要和 &quot;全局对象（global object）&quot; 混淆。这里说的全局的对象是说在全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。标准内置对象的分类（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。例如 Infinity、NaN、undefined、null 字面量（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。例如 eval()、parseFloat()、parseInt() 等（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。例如 Object、Function、Boolean、Symbol、Error 等（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。例如 Number、Math、Date（5）字符串，用来表示和操作字符串的对象。例如 String、RegExp（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。例如 Map、Set、WeakMap、WeakSet（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。例如 SIMD 等（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。例如 JSON 等（10）控制抽象对象例如 Promise、Generator 等（11）反射例如 Reflect、Proxy（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。例如 Intl、Intl.Collator 等（13）WebAssembly（14）其他例如 arguments 回答： 123js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。一般我们经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。 详细资料可以参考：《标准内置对象的分类》《JS 所有内置对象属性和方法汇总》 undefined 与 undeclared 的区别？已在作用域中声明但还没有赋值的变量，是 undefined 的。相反，还没有在作用域中声明过的变量，是 undeclared 的。 对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用 typeof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 “undefined”。 null 和 undefined 的区别？首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。 undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。 undefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。 当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。 详细资料可以参考：《JavaScript 深入理解之 undefined 与 null》 如何获取安全的 undefined 值？因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。 表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。 按惯例我们用 void 0 来获得 undefined。 说几条写 JavaScript 的基本规范？在平常项目开发中，我们遵守一些这样的基本规范，比如说： （1）一个函数作用域中所有的变量声明应该尽量提到函数首部，用一个 var 声明，不允许出现两个连续的 var 声明，声明时 如果变量没有值，应该给该变量赋值对应类型的初始值，便于他人阅读代码时，能够一目了然的知道变量对应的类型值。 （2）代码中出现地址、时间等字符串时需要使用常量代替。 （3）在进行比较的时候吧，尽量使用’===’, ‘!==’代替’==’, ‘!=’。 （4）不要在内置对象的原型上添加方法，如 Array, Date。 （5）switch 语句必须带有 default 分支。 （6）for 循环必须使用大括号。 （7）if 语句必须使用大括号。 JavaScript 原型，原型链？ 有什么特点？在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说我们是不应该能够获取到这个值的，但是现在浏览器中都实现了 proto 属性来让我们访问这个属性，但是我们最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个Object.getPrototypeOf() 方法，我们可以通过这个方法来获取对象的原型。 当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是我们新建的对象为什么能够使用 toString() 等方法的原因。 特点： JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。 详细资料可以参考：《JavaScript 深入理解之原型与原型链》 js 获取原型的方法？ p.__proto__ p.constructor.prototype Object.getPrototypeOf(p) 在 js 中不同进制数字的表示方式 以 0X、0x 开头的表示为十六进制。 以 0、0O、0o 开头的表示为八进制。 以 0B、0b 开头的表示为二进制格式。 js 中整数的安全范围是多少？安全整数指的是，在这个范围内的整数转化为二进制存储的时候不会出现精度丢失，能够被“安全”呈现的最大整数是 2^53 - 1，即9007199254740991，在 ES6 中被定义为 Number.MAX_SAFE_INTEGER。最小整数是-9007199254740991，在 ES6 中被定义为 Number.MIN_SAFE_INTEGER。 如果某次计算的结果得到了一个超过 JavaScript 数值范围的值，那么这个值会被自动转换为特殊的 Infinity 值。如果某次计算返回了正或负的 Infinity 值，那么该值将无法参与下一次的计算。判断一个数是不是有穷的，可以使用 isFinite 函数来判断。 typeof NaN 的结果是什么？12345NaN 意指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。typeof NaN; // &quot;number&quot;NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN != NaN为 true。 isNaN 和 Number.isNaN 函数的区别？函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。 函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，这种方法对于 NaN 的判断更为准确。 Array 构造函数只有一个参数值时的表现？Array 构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度（length），而非只充当数组中的一个元素。这样创建出来的只是一个空数组，只不过它的 length 属性被设置成了指定的值。 构造函数 Array(..) 不要求必须带 new 关键字。不带时，它会被自动补上。 其他值到字符串的转换规则？规范的 9.8 节中定义了抽象操作 ToString ，它负责处理非字符串到字符串的强制类型转换。 （1）Null 和 Undefined 类型 ，null 转换为 “null”，undefined 转换为 “undefined”， （2）Boolean 类型，true 转换为 “true”，false 转换为 “false”。 （3）Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。 （4）Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。 （5）对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()） 来返回内部属性 [[Class]] 的值，如”[object Object]”。如果对象有自己的 toString() 方法，字符串化时就会 调用该方法并使用其返回值。 其他值到数字值的转换规则？有时我们需要将非数字值当作数字来使用，比如数学运算。为此 ES5 规范在 9.3 节定义了抽象操作 ToNumber。 （1）Undefined 类型的值转换为 NaN。 （2）Null 类型的值转换为 0。 （3）Boolean 类型的值，true 转换为 1，false 转换为 0。 （4）String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。 （5）Symbol 类型的值不能转换为数字，会报错。 （6）对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。 为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf() 方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。 如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。 其他值到布尔类型的值的转换规则？12345678910ES5 规范 9.2 节中定义了抽象操作 ToBoolean，列举了布尔强制类型转换所有可能出现的结果。以下这些是假值：• undefined• null• false• +0、-0 和 NaN• &quot;&quot;假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。 {} 和 [] 的 valueOf 和 toString 的结果是什么？123&#123;&#125; 的 valueOf 结果为 &#123;&#125; ，toString 的结果为 &quot;[object Object]&quot;[] 的 valueOf 结果为 [] ，toString 的结果为 &quot;&quot; 什么是假值对象？浏览器在某些特定情况下，在常规 JavaScript 语法基础上自己创建了一些外来值，这些就是“假值对象”。假值对象看起来和普通对象并无二致（都有属性，等等），但将它们强制类型转换为布尔值时结果为 false 最常见的例子是 document.all，它是一个类数组对象，包含了页面上的所有元素，由 DOM（而不是 JavaScript 引擎）提供给 JavaScript 程序使用。 ~ 操作符的作用？123~ 返回 2 的补码，并且 ~ 会将数字转换为 32 位整数，因此我们可以使用 ~ 来进行取整操作。~x 大致等同于 -(x+1)。 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？解析允许字符串（如 parseInt() ）中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换（如 Number ()）不允许出现非数字字符，否则会失败并返回 NaN。 + 操作符什么时候用于字符串的拼接？根据 ES5 规范 11.6.1 节，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。 简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。 那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。 什么情况下会发生布尔值的隐式强制类型转换？12345（1） if (..) 语句中的条件判断表达式。（2） for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。（3） while (..) 和 do..while(..) 循环中的条件判断表达式。（4） ? : 中的条件判断表达式。（5） 逻辑运算符 ||（逻辑或）和 &amp;&amp;（逻辑与）左边的操作数（作为条件判断表达式）。 || 和 &amp;&amp; 操作符的返回值？|| 和 &amp;&amp; 首先会对第一个操作数执行条件判断，如果其不是布尔值就先进行 ToBoolean 强制类型转换，然后再执行条件判断。 对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。 &amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。 || 和 &amp;&amp; 返回它们其中一个操作数的值，而非条件判断的结果 Symbol 值的强制类型转换？ES6 允许从符号到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误。 Symbol 值不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换为布尔值（显式和隐式结果都是 true ）。 == 操作符的强制类型转换规则？（1）字符串和数字之间的相等比较，将字符串转换为数字之后再进行比较。 （2）其他类型和布尔类型之间的相等比较，先将布尔值转换为数字后，再应用其他规则进行比较。 （3）null 和 undefined 之间的相等比较，结果为真。其他值和它们进行比较都返回假值。 （4）对象和非对象之间的相等比较，对象先调用 ToPrimitive 抽象操作后，再进行比较。 （5）如果一个操作值为 NaN ，则相等比较返回 false（ NaN 本身也不等于 NaN ）。 （6）如果两个操作值都是对象，则比较它们是不是指向同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true，否则，返回 false。 详细资料可以参考：《JavaScript 字符串间的比较》 如何将字符串转化为数字，例如 ‘12.3b’?（1）使用 Number() 方法，前提是所包含的字符串不包含不合法字符。 （2）使用 parseInt() 方法，parseInt() 函数可解析一个字符串，并返回一个整数。还可以设置要解析的数字的基数。当基数的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。 （3）使用 parseFloat() 方法，该函数解析一个字符串参数并返回一个浮点数。 （4）使用 + 操作符的隐式转换，前提是所包含的字符串不包含不合法字符。 详细资料可以参考：《详解 JS 中 Number()、parseInt() 和 parseFloat() 的区别》 如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?123456789101112// 方法一function format(number) &#123; return number &amp;&amp; number.replace(/(?!^)(?=(\\d&#123;3&#125;)+\\.)/g, \",\");&#125;// 方法二function format1(number) &#123; return Intl.NumberFormat().format(number)&#125;// 方法三function format2(number) &#123; return number.toLocaleString('en')&#125; 常用正则表达式1234567891011121314// （1）匹配 16 进制颜色值var regex = /#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g;// （2）匹配日期，如 yyyy-mm-dd 格式var regex = /^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;// （3）匹配 qq 号var regex = /^[1-9][0-9]&#123;4,10&#125;$/g;// （4）手机号码正则var regex = /^1[34578]\\d&#123;9&#125;$/g;// （5）用户名正则var regex = /^[a-zA-Z\\$][a-zA-Z0-9_\\$]&#123;4,16&#125;$/; 详细资料可以参考：《前端表单验证常用的 15 个 JS 正则表达式》《JS 常用正则汇总》 生成随机数的各种方法？《JS - 生成随机数的方法汇总（不同范围、类型的随机数）》 如何实现数组的随机排序？12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// （1）使用数组 sort 方法对数组元素随机排序，让 Math.random() 出来的数与 0.5 比较，如果大于就返回 1 交换位置，如果小于就返回 -1，不交换位置。function randomSort(a, b) &#123; return Math.random() &gt; 0.5 ? -1 : 1;&#125;// 缺点：每个元素被派到新数组的位置不是随机的，原因是 sort() 方法是依次比较的。// （2）随机从原数组抽取一个元素，加入到新数组function randomSort(arr) &#123; var result = []; while (arr.length &gt; 0) &#123; var randomIndex = Math.floor(Math.random() * arr.length); result.push(arr[randomIndex]); arr.splice(randomIndex, 1); &#125; return result;&#125;// （3）随机交换数组内的元素（洗牌算法类似）function randomSort(arr) &#123; var index, randomIndex, temp, len = arr.length; for (index = 0; index &lt; len; index++) &#123; randomIndex = Math.floor(Math.random() * (len - index)) + index; temp = arr[index]; arr[index] = arr[randomIndex]; arr[randomIndex] = temp; &#125; return arr;&#125;// es6function randomSort(array) &#123; let length = array.length; if (!Array.isArray(array) || length &lt;= 1) return; for (let index = 0; index &lt; length - 1; index++) &#123; let randomIndex = Math.floor(Math.random() * (length - index)) + index; [array[index], array[randomIndex]] = [array[randomIndex], array[index]]; &#125; return array;&#125; 详细资料可以参考：《Fisher and Yates 的原始版》《javascript 实现数组随机排序?》《JavaScript 学习笔记：数组随机排序》 javascript 创建对象的几种方式？我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是我们可以使用函数来进行模拟，从而产生出可复用的对象创建方式，我了解到的方式有这么几种： （1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。 （2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。 （3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。 （4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。 （5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。 （6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。 嗯我目前了解到的就是这么几种方式。 详细资料可以参考：《JavaScript 深入理解之对象创建》 JavaScript 继承的几种实现方式？我了解的 js 中实现继承的几种方式有： （1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。 （2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。 （3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。 （4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。 （5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。 （6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。 详细资料可以参考：《JavaScript 深入理解之继承》 寄生式组合继承的实现？12345678910111213141516171819function Person(name) &#123; this.name = name;&#125;Person.prototype.sayName = function() &#123; console.log(\"My name is \" + this.name + \".\");&#125;;function Student(name, grade) &#123; Person.call(this, name); this.grade = grade;&#125;Student.prototype = Object.create(Person.prototype);Student.prototype.constructor = Student;Student.prototype.sayMyGrade = function() &#123; console.log(\"My grade is \" + this.grade + \".\");&#125;; Javascript 的作用域链？作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。 作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。 当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。 作用域链的创建过程跟执行上下文的建立有关…. 详细资料可以参考：《JavaScript 深入理解之作用域链》 谈谈 This 对象的理解。1this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。 1.第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。 2.第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。 3.第三种是构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。 4.第四种是 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。 12这四种方式，使用构造器调用模式的优先级最高，然后是 apply 、 call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。 《JavaScript 深入理解之 this 详解》 eval 是做什么的？它的功能是把对应的字符串解析成 JS 代码并运行。 应该避免使用 eval，不安全，非常耗性能（2次，一次解析成 js 语句，一次执行）。 详细资料可以参考：《eval()》 什么是 DOM 和 BOM？DOM 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。 BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。 详细资料可以参考：《DOM, DOCUMENT, BOM, WINDOW 有什么区别?》《Window 对象》《DOM 与 BOM 分别是什么，有何关联？》《JavaScript 学习总结（三）BOM 和 DOM 详解》 写一个通用的事件侦听器函数。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const EventUtils = &#123; // 视能力分别使用dom0||dom2||IE方式 来绑定事件 // 添加事件 addEvent: function(element, type, handler) &#123; if (element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] = handler; &#125; &#125;, // 移除事件 removeEvent: function(element, type, handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.detachEvent) &#123; element.detachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] = null; &#125; &#125;, // 获取事件目标 getTarget: function(event) &#123; return event.target || event.srcElement; &#125;, // 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event getEvent: function(event) &#123; return event || window.event; &#125;, // 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获） stopPropagation: function(event) &#123; if (event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; &#125;, // 取消事件的默认行为 preventDefault: function(event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;&#125;; 详细资料可以参考：《JS 事件模型》 事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？1.事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。 2.事件处理机制：IE 支持事件冒泡、Firefox 同时支持两种事件模型，也就是：事件冒泡和事件捕获。 3.event.stopPropagation() 或者 ie 下的方法 event.cancelBubble = true; 详细资料可以参考：《Javascript 事件模型系列（一）事件及事件的三种模型》《Javascript 事件模型：事件捕获和事件冒泡》 三种事件模型是什么？事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。 第一种事件模型是最早的 DOM0 级模型，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。这种方式是所有浏览器都兼容的。 第二种事件模型是 IE 事件模型，在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。 第三种是 DOM2 级事件模型，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。 详细资料可以参考：《一个 DOM 元素绑定多个事件时，先执行冒泡还是捕获》 事件委托是什么？事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。 使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。 详细资料可以参考：《JavaScript 事件委托详解》 [“1”, “2”, “3”].map(parseInt) 答案是多少？parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)，其中 radix 表示要解析的数字的基数。（该值介于 2 ~ 36 之间，并且字符串中的数字不能大于 radix 才能正确返回数字结果值）。 此处 map 传了 3 个参数 (element, index, array)，默认第三个参数被忽略掉，因此三次传入的参数分别为 “1-0”, “2-1”, “3-2” 因为字符串的值不能大于基数，因此后面两次调用均失败，返回 NaN ，第一次基数为 0 ，按十进制解析返回 1。 详细资料可以参考：《为什么 [“1”, “2”, “3”].map(parseInt) 返回 [1,NaN,NaN]？》 什么是闭包，为什么要用它？闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。 闭包有两个常用的用途。 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。 函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。 其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。 详细资料可以参考：《JavaScript 深入理解之闭包》 javascript 代码中的 “use strict”; 是什么意思 ? 使用它区别是什么？use strict 是一种 ECMAscript5 添加的（严格）运行模式，这种模式使得 Javascript 在更严格的条件下运行。 设立”严格模式”的目的，主要有以下几个： 消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的 Javascript 做好铺垫。 区别： 1.禁止使用 with 语句。 2.禁止 this 关键字指向全局对象。 3.对象不能有重名的属性。 回答： use strict 指的是严格运行模式，在这种模式对 js 的使用添加了一些限制。比如说禁止 this 指向全局对象，还有禁止使用 with 语句等。设立严格模式的目的，主要是为了消除代码使用中的一些不安全的使用方式，也是为了消除 js 语法本身的一些不合理的地方，以此来减少一些运行时的怪异的行为。同时使用严格运行模式也能够提高编译的效率，从而提高代码的运行速度。我认为严格模式代表了 js 一种更合理、更安全、更严谨的发展方向。 详细资料可以参考：《Javascript 严格模式详解》 如何判断一个对象是否属于某个类？第一种方式是使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。 第二种方式可以通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。 第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断。 详细资料可以参考：《js 判断一个对象是否属于某一类》 instanceof 的作用？1234567891011121314// instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。// 实现：function myInstanceof(left, right) &#123; let proto = Object.getPrototypeOf(left), // 获取对象的原型 prototype = right.prototype; // 获取构造函数的 prototype 对象 // 判断构造函数的 prototype 对象是否在对象的原型链上 while (true) &#123; if (!proto) return false; if (proto === prototype) return true; proto = Object.getPrototypeOf(proto); &#125;&#125; 详细资料可以参考：《instanceof》 new 操作符具体干了什么呢？如何实现？（1）首先创建了一个新的空对象（2）设置原型，将对象的原型设置为函数的 prototype 对象。（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。 12345678910111213141516171819202122232425262728// 实现:function objectFactory() &#123; let newObject = null, constructor = Array.prototype.shift.call(arguments), result = null; // 参数判断 if (typeof constructor !== \"function\") &#123; console.error(\"type error\"); return; &#125; // 新建一个空对象，对象的原型为构造函数的 prototype 对象 newObject = Object.create(constructor.prototype); // 将 this 指向新建对象，并执行函数 result = constructor.apply(newObject, arguments); // 判断返回对象 let flag = result &amp;&amp; (typeof result === \"object\" || typeof result === \"function\"); // 判断返回结果 return flag ? result : newObject;&#125;// 使用方法// objectFactory(构造函数, 初始化参数); 详细资料可以参考：《new 操作符具体干了什么？》《JavaScript 深入之 new 的模拟实现》 Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？123hasOwnProperty所有继承了 Object 的对象都会继承到 hasOwnProperty 方法。这个方法可以用来检测一个对象是否含有特定的自身属性，和in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。 详细资料可以参考：《Object.prototype.hasOwnProperty()》 对于 JSON 的了解？相关知识点： JSON 是一种数据交换格式，基于文本，优于轻量，用于交换数据。 JSON 可以表示数字、布尔值、字符串、null、数组（值的有序序列），以及由这些值（或数组、对象）所组成的对象（字符串与值的映射）。 JSON 使用 JavaScript 语法，但是 JSON 格式仅仅是一个文本。文本可以被任何编程语言读取及作为数据格式传递。 回答： JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。 在项目开发中，我们使用 JSON 作为前后端数据交换的方式。在前端我们通过将一个符合 JSON 格式的数据结构序列化为 JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。 因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是我们应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。 在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，一个是 JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，我们可以调用这个函数将数据对象转化为 JSON 格式的字符串。 另一个函数 JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当我们从后端接收到 JSON 格式的字符串时，我们可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。 详细资料可以参考：《深入了解 JavaScript 中的 JSON 》 1[].forEach.call($$(&quot;*&quot;),function(a)&#123;a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16)&#125;)` 能解释一下这段代码的意思吗？（1）选取页面所有 DOM 元素。在浏览器的控制台中可以使用$$()方法来获取页面中相应的元素，这是现代浏览器提供的一个命令行 API 相当于 document.querySelectorAll 方法。 （2）循环遍历 DOM 元素 （3）给元素添加 outline 。由于渲染的 outline 是不在 CSS 盒模型中的，所以为元素添加 outline 并不会影响元素的大小和页面的布局。 （4）生成随机颜色函数。Math.random()*(1&lt;&lt;24) 可以得到 0~2^24 - 1 之间的随机数，因为得到的是一个浮点数，但我们只需要整数部分，使用取反操作符 ~ 连续两次取反获得整数部分，然后再用 toString(16) 的方式，转换为一个十六进制的字符串。 详细资料可以参考：《通过一行代码学 JavaScript》 js 延迟加载的方式有哪些？js 延迟加载，也就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度。 一般有以下几种方式： defer 属性 async 属性 动态创建 DOM 方式 使用 setTimeout 延迟方法 让 JS 最后加载 回答： js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。 我了解到的几种方式是： 第一种方式是我们一般采用的是将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。 第二种方式是给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。 第三种方式是给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。 第四种方式是动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。 详细资料可以参考：《JS 延迟加载的几种方式》《HTML 5 &lt;script&gt; async 属性》 Ajax 是什么? 如何创建一个 Ajax？相关知识点： 2005 年 2 月，AJAX 这个词第一次正式提出，它是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。 具体来说，AJAX 包括以下几个步骤。 1.创建 XMLHttpRequest 对象，也就是创建一个异步调用对象 2.创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息 3.设置响应 HTTP 请求状态变化的函数 4.发送 HTTP 请求 5.获取异步调用返回的数据 6.使用 JavaScript 和 DOM 实现局部刷新 一般实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667const SERVER_URL = \"/server\";let xhr = new XMLHttpRequest();// 创建 Http 请求xhr.open(\"GET\", SERVER_URL, true);// 设置状态监听函数xhr.onreadystatechange = function() &#123; if (this.readyState !== 4) return; // 当请求成功时 if (this.status === 200) &#123; handle(this.response); &#125; else &#123; console.error(this.statusText); &#125;&#125;;// 设置请求失败时的监听函数xhr.onerror = function() &#123; console.error(this.statusText);&#125;;// 设置请求头信息xhr.responseType = \"json\";xhr.setRequestHeader(\"Accept\", \"application/json\");// 发送 Http 请求xhr.send(null);// promise 封装实现：function getJSON(url) &#123; // 创建一个 promise 对象 let promise = new Promise(function(resolve, reject) &#123; let xhr = new XMLHttpRequest(); // 新建一个 http 请求 xhr.open(\"GET\", url, true); // 设置状态的监听函数 xhr.onreadystatechange = function() &#123; if (this.readyState !== 4) return; // 当请求成功或失败时，改变 promise 的状态 if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; // 设置错误监听函数 xhr.onerror = function() &#123; reject(new Error(this.statusText)); &#125;; // 设置响应的数据类型 xhr.responseType = \"json\"; // 设置请求头信息 xhr.setRequestHeader(\"Accept\", \"application/json\"); // 发送 http 请求 xhr.send(null); &#125;); return promise;&#125; 回答： 我对 ajax 的理解是，它是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。 创建一个 ajax 有这样几个步骤 首先是创建一个 XMLHttpRequest 对象。 然后在这个对象上使用 open 方法创建一个 http 请求，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。 在发起请求前，我们可以为这个对象添加一些信息和监听函数。比如说我们可以通过 setRequestHeader 方法来为请求添加头信息。我们还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，我们可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候我们可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候我们就可以通过 response 中的数据来对页面进行更新了。 当对象的属性和监听函数设置完成后，最后我们调用 sent 方法来向服务器发起请求，可以传入参数作为发送的数据体。 详细资料可以参考：《XMLHttpRequest 对象》《从 ajax 到 fetch、axios》《Fetch 入门》《传统 Ajax 已死，Fetch 永生》 谈一谈浏览器的缓存机制？浏览器的缓存机制指的是通过在一段时间内保留已接收到的 web 资源的一个副本，如果在资源的有效时间内，发起了对这个资源的再一次请求，那么浏览器会直接使用缓存的副本，而不是向服务器发起请求。使用 web 缓存可以有效地提高页面的打开速度，减少不必要的网络带宽的消耗。 web 资源的缓存策略一般由服务器来指定，可以分为两种，分别是强缓存策略和协商缓存策略。 使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。 服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。 Expires 是 http1.0 中的方式，因为它的一些缺点，在 http 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，常用的比如我们可以通过设置 max-age 来指定资源能够被缓存的时间的大小，这是一个相对的时间，它会根据这个时间的大小和资源第一次请求时的时间来计算出资源过期的时间，因此相对于 Expires来说，这种方式更加有效一些。常用的还有比如 private ，用来规定资源只能被客户端缓存，不能够代理服务器所缓存。还有如 no-store ，用来指定资源不能够被缓存，no-cache 代表该资源能够被缓存，但是立即失效，每次都需要向服务器发起请求。 一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires 。 使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。协商缓存也可以通过两种方式来设置，分别是 http 头信息中的 Etag 和 Last-Modified 属性。 服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。 因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。 当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。 强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。 详细资料可以参考：《浅谈浏览器缓存》《前端优化：浏览器缓存技术介绍》《请求头中的 Cache-Control》《Cache-Control 字段值详解》 Ajax 解决浏览器缓存问题？1.在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(“If-Modified-Since”,”0”)。 2.在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(“Cache-Control”,”no-cache”)。 3.在 URL 后面加上一个随机数： “fresh=” + Math.random();。 4.在 URL 后面加上时间戳：”nowtime=” + new Date().getTime();。 5.如果是使用 jQuery，直接这样就可以了$.ajaxSetup({cache:false})。这样页面的所有 ajax 都会执行这条语句就是不需要保存缓存记录。 详细资料可以参考：《Ajax 中浏览器的缓存问题解决方法》《浅谈浏览器缓存》 同步和异步的区别？同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是处于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。 异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。 回答： 同步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。 异步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理。 详细资料可以参考：《同步和异步的区别》 什么是浏览器的同源政策？我对浏览器的同源政策的理解是，一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容。这里的同源的指的是两个域的协议、域名、端口号必须相同，否则则不属于同一个域。 同源政策主要限制了三个方面 第一个是当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。 第二个是当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。 第三个是当前域下 ajax 无法发送跨域请求。 同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。 如何解决跨域问题？相关知识点： 通过 jsonp 跨域 document.domain + iframe 跨域 location.hash + iframe window.name + iframe 跨域 postMessage 跨域 跨域资源共享（CORS) nginx 代理跨域 nodejs 中间件代理跨域 WebSocket 协议跨域 回答： 解决跨域的方法我们可以根据我们想要实现的目的来划分。 首先我们如果只是想要实现主域名下的不同子域名的跨域操作，我们可以使用设置 document.domain 来解决。 （1）将 document.domain 设置为主域名，来实现相同子域名的跨域操作，这个时候主域名下的 cookie 就能够被子域名所访问。同时如果文档中含有主域名相同，子域名不同的 iframe 的话，我们也可以对这个 iframe 进行操作。 如果是想要解决不同跨域窗口间的通信问题，比如说一个页面想要和页面的中的不同源的 iframe 进行通信的问题，我们可以使用 location.hash 或者 window.name 或者 postMessage 来解决。 （2）使用 location.hash 的方法，我们可以在主页面动态的修改 iframe 窗口的 hash 值，然后在 iframe 窗口里实现监听函数来实现这样一个单向的通信。因为在 iframe 是没有办法访问到不同源的父级窗口的，所以我们不能直接修改父级窗口的 hash 值来实现通信，我们可以在 iframe 中再加入一个 iframe ，这个 iframe 的内容是和父级页面同源的，所以我们可以 window.parent.parent 来修改最顶级页面的 src，以此来实现双向通信。 （3）使用 window.name 的方法，主要是基于同一个窗口中设置了 window.name 后不同源的页面也可以访问，所以不同源的子页面可以首先在 window.name 中写入数据，然后跳转到一个和父级同源的页面。这个时候级页面就可以访问同源的子页面中 window.name 中的数据了，这种方式的好处是可以传输的数据量大。 （4）使用 postMessage 来解决的方法，这是一个 h5 中新增的一个 api。通过它我们可以实现多窗口间的信息传递，通过获取到指定窗口的引用，然后调用 postMessage 来发送信息，在窗口中我们通过对 message 信息的监听来接收信息，以此来实现不同源间的信息交换。 如果是像解决 ajax 无法提交跨域请求的问题，我们可以使用 jsonp、cors、websocket 协议、服务器代理来解决问题。 （5）使用 jsonp 来实现跨域请求，它的主要原理是通过动态构建 script 标签来实现跨域请求，因为浏览器对 script 标签的引入没有跨域的访问限制 。通过在请求的 url 后指定一个回调函数，然后服务器在返回数据的时候，构建一个 json 数据的包装，这个包装就是回调函数，然后返回给前端，前端接收到数据后，因为请求的是脚本文件，所以会直接执行，这样我们先前定义好的回调函数就可以被调用，从而实现了跨域请求的处理。这种方式只能用于 get 请求。 （6）使用 CORS 的方式，CORS 是一个 W3C 标准，全称是”跨域资源共享”。CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，因此我们只需要在服务器端配置就行。浏览器将 CORS 请求分成两类：简单请求和非简单请求。对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是会在头信息之中，增加一个 Origin 字段。Origin 字段用来说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。对于如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，ajax 不会收到响应信息。如果成功的话会包含一些以 Access-Control- 开头的字段。 非简单请求，浏览器会先发出一次预检请求，来判断该域名是否在服务器的白名单中，如果收到肯定回复后才会发起请求。 （7）使用 websocket 协议，这个协议没有同源限制。 （8）使用服务器来代理跨域的访问请求，就是有跨域的请求操作时发送请求给后端，让后端代为请求，然后最后将获取的结果发返回。 详细资料可以参考：《前端常见跨域解决方案（全）》《浏览器同源政策及其规避方法》《跨域，你需要知道的全在这里》《为什么 form 表单提交没有跨域问题，但 ajax 提交有跨域问题？》 服务器代理转发时，该如何处理 cookie？详细资料可以参考：《深入浅出 Nginx》 模块化开发怎么做？我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，js 只实现一些简单的功能，所以并没有模块的概念，但随着程序越来越复杂，代码的模块化开发变得越来越重要。 由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污染，并且模块间没有联系。 后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所有的所有的模块成员，外部代码可以修改内部属性的值。 现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。 详细资料可以参考：《浅谈模块化开发》《Javascript 模块化编程（一）：模块的写法》《前端模块化：CommonJS，AMD，CMD，ES6》《Module 的语法》 js 的几种模块规范？js 中现在比较成熟的有四种模块加载方案。 第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。 第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。 第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和 require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。参考60 第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。这种方案和上面三种方案都不同。参考 61。 AMD 和 CMD 规范的区别？它们之间的主要区别有两个方面。 （1）第一个方面是在模块定义时对依赖的处理不同。AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。 （2）第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。 123456789101112131415161718// CMDdefine(function(require, exports, module) &#123; var a = require(\"./a\"); a.doSomething(); // 此处略去 100 行 var b = require(\"./b\"); // 依赖可以就近书写 b.doSomething(); // ...&#125;);// AMD 默认推荐define([\"./a\", \"./b\"], function(a, b) &#123; // 依赖必须一开始就写好 a.doSomething(); // 此处略去 100 行 b.doSomething(); // ...&#125;); 详细资料可以参考：《前端模块化，AMD 与 CMD 的区别》 ES6 模块与 CommonJS 模块、AMD、CMD 的差异。1.CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。 2.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。 requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）require.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。 详细资料可以参考：《requireJS 的用法和原理分析》《requireJS 的核心原理是什么？》《从 RequireJs 源码剖析脚本加载原理》《requireJS 原理分析》 JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？详细资料可以参考：《JS 模块加载器加载原理是怎么样的？》 ECMAScript6 怎么写 class，为什么会出现 class 这种东西?在我看来 ES6 新添加的 class 只是为了补充 js 中缺少的一些面向对象语言的特性，但本质上来说它只是一种语法糖，不是一个新的东西，其背后还是原型继承的思想。通过加入 class 可以有利于我们更好的组织代码。 在 class 中添加的方法，其实是添加在类的原型上的。 详细资料可以参考：《ECMAScript 6 实现了 class，对 JavaScript 前端开发有什么意义？》《Class 的基本语法》 documen.write 和 innerHTML 的区别？document.write 的内容会代替整个文档内容，会重写整个页面。 innerHTML 的内容只是替代指定元素的内容，只会重写页面中的部分内容。 详细资料可以参考：《简述 document.write 和 innerHTML 的区别。》 DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？（1）创建新节点 123createDocumentFragment(node);createElement(node);createTextNode(text); （2）添加、移除、替换、插入 1234appendChild(node)removeChild(node)replaceChild(new,old)insertBefore(new,old) （3）查找 123456getElementById();getElementsByName();getElementsByTagName();getElementsByClassName();querySelector();querySelectorAll(); （4）属性操作 1234getAttribute(key);setAttribute(key, value);hasAttribute(key);removeAttribute(key); 详细资料可以参考：《DOM 概述》《原生 JavaScript 的 DOM 操作汇总》《原生 JS 中 DOM 节点相关 API 合集》 innerHTML 与 outerHTML 的区别？123456对于这样一个 HTML 元素：&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;。innerHTML：内部 HTML，content&lt;br/&gt;；outerHTML：外部 HTML，&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;；innerText：内部文本，content ；outerText：内部文本，content ； .call() 和 .apply() 的区别？它们的作用一模一样，区别仅在于传入参数的形式的不同。 apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。 call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。 详细资料可以参考：《apply、call 的区别和用途》 JavaScript 类数组对象的定义？一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。 常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length属性值，代表可接收的参数个数。 常见的类数组转换为数组的方法有这样几种： （1）通过 call 调用数组的 slice 方法来实现转换 1Array.prototype.slice.call(arrayLike); （2）通过 call 调用数组的 splice 方法来实现转换 1Array.prototype.splice.call(arrayLike, 0); （3）通过 apply 调用数组的 concat 方法来实现转换 1Array.prototype.concat.apply([], arrayLike); （4）通过 Array.from 方法来实现转换 1Array.from(arrayLike); 详细的资料可以参考：《JavaScript 深入之类数组对象与 arguments》《javascript 类数组》《深入理解 JavaScript 类数组》 数组和对象有哪些原生方法，列举一下？数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。 数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。 数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。 数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。 数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。 数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法 数组归并方法 reduce() 和 reduceRight() 方法 详细资料可以参考：《JavaScript 深入理解之 Array 类型详解》 数组的 fill 方法？fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。fill 方法接受三个参数 value，start 以及 end，start 和 end 参数是可选的，其默认值分别为 0 和 this 对象的 length 属性值。 详细资料可以参考：《Array.prototype.fill()》 [,,,] 的长度？尾后逗号 （有时叫做“终止逗号”）在向 JavaScript 代码添加元素、参数、属性时十分有用。如果你想要添加新的属性，并且上一行已经使用了尾后逗号，你可以仅仅添加新的一行，而不需要修改上一行。这使得版本控制更加清晰，以及代码维护麻烦更少。 JavaScript 一开始就支持数组字面值中的尾后逗号，随后向对象字面值（ECMAScript 5）中添加了尾后逗号。最近（ECMAScript 2017），又将其添加到函数参数中。但是 JSON 不支持尾后逗号。 如果使用了多于一个尾后逗号，会产生间隙。 带有间隙的数组叫做稀疏数组（密致数组没有间隙）。稀疏数组的长度为逗号的数量。 详细资料可以参考：《尾后逗号》 JavaScript 中的作用域与变量声明提升？变量提升的表现是，无论我们在函数中何处位置声明的变量，好像都被提升到了函数的首部，我们可以在变量声明前访问到而不会报错。 造成变量声明提升的本质原因是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当我们访问一个变量时，我们会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。这就是会出现变量声明提升的根本原因。 详细资料可以参考：《JavaScript 深入理解之变量对象》 如何编写高性能的 Javascript ？1.使用位运算代替一些简单的四则运算。 2.避免使用过深的嵌套循环。 3.不要使用未定义的变量。 4.当需要多次访问数组长度时，可以用变量保存起来，避免每次都会去进行属性查找。 详细资料可以参考：《如何编写高性能的 Javascript？》 简单介绍一下 V8 引擎的垃圾回收机制v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。 新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。 新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步： （1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。 （2）如果对象不存活，则释放对象的空间。 （3）最后将 From 空间和 To 空间角色进行交换。 新生代对象晋升到老生代有两个条件： （1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。 （2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。 老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。 由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。 详细资料可以参考：《深入理解 V8 的垃圾回收原理》《JavaScript 中的垃圾回收》 哪些操作会造成内存泄漏？相关知识点： 1.意外的全局变量 2.被遗忘的计时器或回调函数 3.脱离 DOM 的引用 4.闭包 回答： 第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。 第二种情况是我们设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。 第三种情况是我们获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。 详细资料可以参考：《JavaScript 内存泄漏教程》《4 类 JavaScript 内存泄漏及如何避免》《杜绝 js 中四种内存泄漏类型的发生》《javascript 典型内存泄漏及 chrome 的排查方法》 如何做到修改url参数页面不刷新HTML5引入了 history.pushState() 和 history.replaceState() 方法，它们分别可以添加和修改历史记录条目。 12345let stateObj = &#123; foo: \"bar\",&#125;;history.pushState(stateObj, \"page 2\", \"bar.html\"); 假设当前页面为 foo.html，执行上述代码后会变为 bar.html，点击浏览器后退，会变为 foo.html，但浏览器并不会刷新。pushState() 需要三个参数: 一个状态对象, 一个标题 (目前被忽略), 和 (可选的) 一个 URL. 让我们来解释下这三个参数详细内容： 状态对象 — 状态对象 state 是一个 JavaScript 对象，通过 pushState () 创建新的历史记录条目。无论什么时候用户导航到新的状态，popstate 事件就会被触发，且该事件的 state 属性包含该历史记录条目状态对象的副本。状态对象可以是能被序列化的任何东西。原因在于 Firefox 将状态对象保存在用户的磁盘上，以便在用户重启浏览器时使用，我们规定了状态对象在序列化表示后有640k的大小限制。如果你给 pushState() 方法传了一个序列化后大于 640k 的状态对象，该方法会抛出异常。如果你需要更大的空间，建议使用 sessionStorage 以及 localStorage. 标题 — Firefox 目前忽略这个参数，但未来可能会用到。传递一个空字符串在这里是安全的，而在将来这是不安全的。二选一的话，你可以为跳转的 state 传递一个短标题。 URL — 该参数定义了新的历史URL记录。注意，调用 pushState() 后浏览器并不会立即加载这个 URL，但可能会在稍后某些情况下加载这个 URL，比如在用户重新打开浏览器时。新URL不必须为绝对路径。如果新URL是相对路径，那么它将被作为相对于当前 URL 处理。新 URL 必须与当前URL同源，否则 pushState() 会抛出一个异常。该参数是可选的，缺省为当前 URL。 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？通过使用 pushState + ajax 实现浏览器无刷新前进后退，当一次 ajax 调用成功后我们将一条 state 记录加入到 history对象中。一条 state 记录包含了 url、title 和 content 属性，在 popstate 事件中可以获取到这个 state 对象，我们可以使用 content 来传递数据。最后我们通过对 window.onpopstate 事件监听来响应浏览器的前进后退操作。 使用 pushState 来实现有两个问题，一个是打开首页时没有记录，我们可以使用 replaceState 来将首页的记录替换，另一个问题是当一个页面刷新的时候，仍然会向服务器端请求数据，因此如果请求的 url 需要后端的配合将其重定向到一个页面。 详细资料可以参考：《pushState + ajax 实现浏览器无刷新前进后退》《Manipulating the browser history》 如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）123typeof window === &apos;undefined&apos; ? &apos;node&apos; : &apos;browser&apos;;通过判断当前环境的 window 对象类型是否为 undefined，如果是undefined，则说明当前脚本运行在node环境，否则说明运行在window环境。 把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？详细资料可以参考：《为什么把 script 标签放在 body 结束标签之后 html 结束标签之前？》《从 Chrome 源码看浏览器如何加载资源》 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？移动端点击有 300ms 的延迟是因为移动端会有双击缩放的这个操作，因此浏览器在 click 之后要等待 300ms，看用户有没有下一次点击，来判断这次操作是不是双击。 有三种办法来解决这个问题： 1.通过 meta 标签禁用网页的缩放。 2.通过 meta 标签将网页的 viewport 设置为 ideal viewport。 3.调用一些 js 库，比如 FastClick click 延时问题还可能引起点击穿透的问题，就是如果我们在一个元素上注册了 touchStart 的监听事件，这个事件会将这个元素隐藏掉，我们发现当这个元素隐藏后，触发了这个元素下的一个元素的点击事件，这就是点击穿透。 详细资料可以参考：《移动端 300ms 点击延迟和点击穿透》 什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？（1）什么是前端路由？ 前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前是通过服务端根据 url 的不同返回不同的页面实现的。 （2）什么时候使用前端路由？ 在单页面应用，大部分页面结构不变，只改变部分内容的使用 （3）前端路由有什么优点和缺点？ 优点：用户体验好，不需要每次都从服务器全部获取，快速展现给用户 缺点：单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置 前端路由一共有两种实现方式，一种是通过 hash 的方式，一种是通过使用 pushState 的方式。 详细资料可以参考：《什么是“前端路由”》《浅谈前端路由》 《前端路由是什么东西？》 如何测试前端代码么？ 知道 BDD, TDD, Unit Test 么？ 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)？详细资料可以参考：《浅谈前端单元测试》 检测浏览器版本版本有哪些方式？检测浏览器版本一共有两种方式： 一种是检测 window.navigator.userAgent 的值，但这种方式很不可靠，因为 userAgent 可以被改写，并且早期的浏览器如 ie，会通过伪装自己的 userAgent 的值为 Mozilla 来躲过服务器的检测。 第二种方式是功能检测，根据每个浏览器独有的特性来进行判断，如 ie 下独有的 ActiveXObject。 详细资料可以参考：《JavaScript 判断浏览器类型》 什么是 Polyfill ？Polyfill 指的是用于实现浏览器并不支持的原生 API 的代码。 比如说 querySelectorAll 是很多现代浏览器都支持的原生 Web API，但是有些古老的浏览器并不支持，那么假设有人写了一段代码来实现这个功能使这些浏览器也支持了这个功能，那么这就可以成为一个 Polyfill。 一个 shim 是一个库，有自己的 API，而不是单纯实现原生不支持的 API。 详细资料可以参考：《Web 开发中的“黑话”》《Polyfill 为何物》 使用 JS 实现获取文件扩展名？12345678// String.lastIndexOf() 方法返回指定值（本例中的'.'）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。// 对于 'filename' 和 '.hiddenfile' ，lastIndexOf 的返回值分别为 0 和 -1 无符号右移操作符(&gt;&gt;&gt;) 将 -1 转换为 4294967295 ，将 -2 转换为 4294967294 ，这个方法可以保证边缘情况时文件名不变。// String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为\"\"。function getFileExtension(filename) &#123; return filename.slice(((filename.lastIndexOf(\".\") - 1) &gt;&gt;&gt; 0) + 2);&#125; 详细资料可以参考：《如何更有效的获取文件扩展名》 介绍一下 js 的节流与防抖？函数防抖： 在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。 函数节流： 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。 12345678910111213141516171819202122232425262728293031323334353637// 函数防抖的实现function debounce(fn, wait) &#123; var timer = null; return function() &#123; var context = this, args = arguments; // 如果此时存在定时器的话，则取消之前的定时器重新记时 if (timer) &#123; clearTimeout(timer); timer = null; &#125; // 设置定时器，使事件间隔指定事件后执行 timer = setTimeout(() =&gt; &#123; fn.apply(context, args); &#125;, wait); &#125;;&#125;// 函数节流的实现;function throttle(fn, delay) &#123; var preTime = Date.now(); return function() &#123; var context = this, args = arguments, nowTime = Date.now(); // 如果两次时间间隔超过了指定时间，则执行函数。 if (nowTime - preTime &gt;= delay) &#123; preTime = Date.now(); return fn.apply(context, args); &#125; &#125;;&#125; 回答： 函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。 函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。 详细资料可以参考：《轻松理解 JS 函数节流和函数防抖》《JavaScript 事件节流和事件防抖》《JS 的防抖与节流》 Object.is() 与原来的比较操作符 “===”、“==” 的区别？相关知识点： 两等号判等，会在比较时进行类型转换。三等号判等（判断严格），比较时不进行隐式类型转换，（类型不同则会返回false）。 Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 Object.is(NaN, NaN) 会返回 true. Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。 回答： 使用双等号进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。 使用三等号进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。 使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 认定为是相等的。 escape,encodeURI,encodeURIComponent 有什么区别？相关知识点： escape 和 encodeURI 都属于 Percent-encoding，基本功能都是把 URI 非法字符转化成合法字符，转化后形式类似「%*」。它们的根本区别在于，escape 在处理 0xff 之外字符的时候，是直接使用字符的 unicode 在前面加上一个「%u」，而 encode URI 则是先进行 UTF-8，再在 UTF-8 的每个字节码前加上一个「%」；在处理 0xff 以内字符时，编码方式是一样的（都是「%XX」，XX 为字符的 16 进制 unicode，同时也是字符的 UTF-8），只是范围（即哪些字符编码哪些字符不编码）不一样。 回答： encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。 encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。 escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。 详细资料可以参考：《escape,encodeURI,encodeURIComponent 有什么区别?》 Unicode 和 UTF-8 之间的关系？Unicode 是一种字符集合，现在可容纳 100 多万个字符。每个字符对应一个不同的 Unicode 编码，它只规定了符号的二进制代码，却没有规定这个二进制代码在计算机中如何编码传输。 UTF-8 是一种对 Unicode 的编码方式，它是一种变长的编码方式，可以用 1~4 个字节来表示一个字符。 详细资料可以参考：《字符编码详解》《字符编码笔记：ASCII，Unicode 和 UTF-8》 js 中的深浅拷贝实现？相关资料： 12345678910111213141516171819202122232425262728293031323334// 浅拷贝的实现;function shallowCopy(object) &#123; // 只拷贝对象 if (!object || typeof object !== \"object\") return; // 根据 object 的类型判断是新建一个数组还是对象 let newObject = Array.isArray(object) ? [] : &#123;&#125;; // 遍历 object，并且判断是 object 的属性才拷贝 for (let key in object) &#123; if (object.hasOwnProperty(key)) &#123; newObject[key] = object[key]; &#125; &#125; return newObject;&#125;// 深拷贝的实现;function deepCopy(object) &#123; if (!object || typeof object !== \"object\") return object; let newObject = Array.isArray(object) ? [] : &#123;&#125;; for (let key in object) &#123; if (object.hasOwnProperty(key)) &#123; newObject[key] = deepCopy(object[key]); &#125; &#125; return newObject;&#125; 回答： 浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用 Object.assign 和展开运算符来实现。 深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败。 详细资料可以参考：《JavaScript 专题之深浅拷贝》《前端面试之道》 手写 call、apply 及 bind 函数相关资料： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// call函数实现Function.prototype.myCall = function(context) &#123; // 判断调用对象 if (typeof this !== \"function\") &#123; console.error(\"type error\"); &#125; // 获取参数 let args = [...arguments].slice(1), result = null; // 判断 context 是否传入，如果未传入则设置为 window context = context || window; // 将调用函数设为对象的方法 context.fn = this; // 调用函数 result = context.fn(...args); // 将属性删除 delete context.fn; return result;&#125;;// apply 函数实现Function.prototype.myApply = function(context) &#123; // 判断调用对象是否为函数 if (typeof this !== \"function\") &#123; throw new TypeError(\"Error\"); &#125; let result = null; // 判断 context 是否存在，如果未传入则为 window context = context || window; // 将函数设为对象的方法 context.fn = this; // 调用方法 if (arguments[1]) &#123; result = context.fn(...arguments[1]); &#125; else &#123; result = context.fn(); &#125; // 将属性删除 delete context.fn; return result;&#125;;// bind 函数实现Function.prototype.myBind = function(context) &#123; // 判断调用对象是否为函数 if (typeof this !== \"function\") &#123; throw new TypeError(\"Error\"); &#125; // 获取参数 var args = [...arguments].slice(1), fn = this; return function Fn() &#123; // 根据调用方式，传入不同绑定值 return fn.apply( this instanceof Fn ? this : context, args.concat(...arguments) ); &#125;;&#125;; 回答： call 函数的实现步骤：1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。 2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。 3.处理传入的参数，截取第一个参数后的所有参数。 4.将函数作为上下文对象的一个属性。 5.使用上下文对象来调用这个方法，并保存返回结果。 6.删除刚才新增的属性。 7.返回结果。 apply 函数的实现步骤：1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。 2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。 3.将函数作为上下文对象的一个属性。 4.判断参数值是否传入 4.使用上下文对象来调用这个方法，并保存返回结果。 5.删除刚才新增的属性 6.返回结果 bind 函数的实现步骤：1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。 2.保存当前函数的引用，获取其余传入参数值。 3.创建一个函数返回 4.函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。 详细资料可以参考：《手写 call、apply 及 bind 函数》《JavaScript 深入之 call 和 apply 的模拟实现》 函数柯里化的实现12345678910111213141516171819202122232425262728293031// 函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。function curry(fn, args) &#123; // 获取函数需要的参数长度 let length = fn.length; args = args || []; return function() &#123; let subArgs = args.slice(0); // 拼接得到现有的所有参数 for (let i = 0; i &lt; arguments.length; i++) &#123; subArgs.push(arguments[i]); &#125; // 判断参数的长度是否已经满足函数所需参数的长度 if (subArgs.length &gt;= length) &#123; // 如果满足，执行函数 return fn.apply(this, subArgs); &#125; else &#123; // 如果不满足，递归返回科里化的函数，等待参数的传入 return curry.call(this, fn, subArgs); &#125; &#125;;&#125;// es6 实现function curry(fn, ...args) &#123; return fn.length &lt;= args.length ? fn(...args) : curry.bind(null, fn, ...args);&#125; 详细资料可以参考：《JavaScript 专题之函数柯里化》 为什么 0.1 + 0.2 != 0.3？如何解决这个问题？当计算机计算 0.1+0.2 的时候，实际上计算的是这两个数字在计算机里所存储的二进制，0.1 和 0.2 在转换为二进制表示的时候会出现位数无限循环的情况。js 中是以 64 位双精度格式来存储数字的，只有 53 位的有效数字，超过这个长度的位数会被截取掉这样就造成了精度丢失的问题。这是第一个会造成精度丢失的地方。在对两个以 64 位双精度格式的数据进行计算的时候，首先会进行对阶的处理，对阶指的是将阶码对齐，也就是将小数点的位置对齐后，再进行计算，一般是小阶向大阶对齐，因此小阶的数在对齐的过程中，有效数字会向右移动，移动后超过有效位数的位会被截取掉，这是第二个可能会出现精度丢失的地方。当两个数据阶码对齐后，进行相加运算后，得到的结果可能会超过 53 位有效数字，因此超过的位数也会被截取掉，这是可能发生精度丢失的第三个地方。 对于这样的情况，我们可以将其转换为整数后再进行运算，运算后再转换为对应的小数，以这种方式来解决这个问题。 我们还可以将两个数相加的结果和右边相减，如果相减的结果小于一个极小数，那么我们就可以认定结果是相等的，这个极小数可以使用 es6 的 Number.EPSILON 详细资料可以参考：《十进制的 0.1 为什么不能用二进制很好的表示？》《十进制浮点数转成二进制》《浮点数的二进制表示》《js 浮点数存储精度丢失原理》《浮点数精度之谜》《JavaScript 浮点数陷阱及解法》《0.1+0.2 !== 0.3？》《JavaScript 中奇特的~运算符》 原码、反码和补码的介绍1234567891011原码是计算机中对数字的二进制的定点表示方法，最高位表示符号位，其余位表示数值位。优点是易于分辨，缺点是不能够直接参与运算。正数的反码和其原码一样；负数的反码，符号位为1，数值部分按原码取反。如 [+7]原 = 00000111，[+7]反 = 00000111； [-7]原 = 10000111，[-7]反 = 11111000。正数的补码和其原码一样；负数的补码为其反码加1。例如 [+7]原 = 00000111，[+7]反 = 00000111，[+7]补 = 00000111；[-7]原 = 10000111，[-7]反 = 11111000，[-7]补 = 11111001之所以在计算机中使用补码来表示负数的原因是，这样可以将加法运算扩展到所有的数值计算上，因此在数字电路中我们只需要考虑加法器的设计就行了，而不用再为减法设置新的数字电路。 详细资料可以参考：《关于 2 的补码》 toPrecision 和 toFixed 和 Math.round 的区别？toPrecision 用于处理精度，精度是从左至右第一个不为 0 的数开始数起。toFixed 是对小数点后指定位数取整，从小数点开始数起。Math.round 是将一个数字四舍五入到一个整数。 什么是 requestAnimationFrame ？详细资料可以参考：《你需要知道的 requestAnimationFrame》《CSS3 动画那么强，requestAnimationFrame 还有毛线用？》 offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别？clientWidth/clientHeight 返回的是元素的内部宽度，它的值只包含 content + padding，如果有滚动条，不包含滚动条。clientTop 返回的是上边框的宽度。clientLeft 返回的左边框的宽度。 offsetWidth/offsetHeight 返回的是元素的布局宽度，它的值包含 content + padding + border 包含了滚动条。offsetTop 返回的是当前元素相对于其 offsetParent 元素的顶部的距离。offsetLeft 返回的是当前元素相对于其 offsetParent 元素的左部的距离。 scrollWidth/scrollHeight 返回值包含 content + padding + 溢出内容的尺寸。scrollTop 属性返回的是一个元素的内容垂直滚动的像素数。scrollLeft 属性返回的是元素滚动条到元素左边的距离。 详细资料可以参考：《最全的获取元素宽高及位置的方法》《用 Javascript 获取页面元素的位置》 谈一谈你理解的函数式编程？简单说，”函数式编程”是一种”编程范式”（programming paradigm），也就是如何编写程序的方法论。 它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是”第一等公民”、只用”表达式”。 详细资料可以参考：《函数式编程初探》 异步编程的实现方式？相关资料： 回调函数优点：简单、容易理解缺点：不利于维护，代码耦合高 事件监听（采用时间驱动模式，取决于某个事件是否发生）：优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数缺点：事件驱动型，流程不够清晰 发布/订阅（观察者模式）类似于事件监听，但是可以通过‘消息中心’，了解现在有多少发布者，多少订阅者 Promise 对象优点：可以利用 then 方法，进行链式写法；可以书写错误时的回调函数；缺点：编写和理解，相对比较难 Generator 函数优点：函数体内外的数据交换、错误处理机制缺点：流程管理不方便 async 函数优点：内置执行器、更好的语义、更广的适用性、返回的是 Promise、结构清晰。缺点：错误处理机制 回答： js 中的异步机制可以分为以下几种： 第一种最常见的是使用回调函数的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。 第二种是 Promise 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。 第三种是使用 generator 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部我们还可以将执行权转移回来。当我们遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕的时候我们再将执行权给转移回来。因此我们在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式我们需要考虑的问题是何时将函数的控制权转移回来，因此我们需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。 第四种是使用 async 函数的形式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此我们可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。 Js 动画与 CSS 动画区别及相应实现CSS3 的动画的优点 在性能上会稍微好一些，浏览器会对 CSS3 的动画做一些优化代码相对简单 缺点 在动画控制上不够灵活兼容性不好 JavaScript 的动画正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容 IE6，并且功能强大。对于一些复杂控制的动画，使用 javascript 会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑 CSS 吧 get 请求传参长度的误区误区：我们经常说 get 请求参数的大小存在限制，而 post 请求的参数大小是无限制的。 实际上 HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对 get 请求参数的限制是来源与浏览器或web 服务器，浏览器或 web 服务器限制了 url 的长度。为了明确这个概念，我们必须再次强调下面几点: 1.HTTP 协议未规定 GET 和 POST 的长度限制 2.GET 的最大长度显示是因为浏览器和 web 服务器限制了 URI 的长度 3.不同的浏览器和 WEB 服务器，限制的最大长度不一样 4.要支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度 8182byte URL 和 URI 的区别？URI: Uniform Resource Identifier 指的是统一资源标识符URL: Uniform Resource Location 指的是统一资源定位符URN: Universal Resource Name 指的是统一资源名称 URI 指的是统一资源标识符，用唯一的标识来确定一个资源，它是一种抽象的定义，也就是说，不管使用什么方法来定义，只要能唯一的标识一个资源，就可以称为 URI。 URL 指的是统一资源定位符，URN 指的是统一资源名称。URL 和 URN 是 URI 的子集，URL 可以理解为使用地址来标识资源，URN 可以理解为使用名称来标识资源。 详细资料可以参考：《HTTP 协议中 URI 和 URL 有什么区别？》《你知道 URL、URI 和 URN 三者之间的区别吗？》《URI、URL 和 URN 的区别》 get 和 post 请求在缓存方面的区别相关知识点： get 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。 post 不同，post 做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此 get 请求适合于请求缓存。 回答： 缓存一般只适用于那些不会更新服务端数据的请求。一般 get 请求都是查找请求，不会对服务器资源数据造成修改，而 post 请求一般都会对服务器数据造成修改，所以，一般会对 get 请求进行缓存，很少会对 post 请求进行缓存。 详细资料可以参考：《HTML 关于 post 和 get 的区别以及缓存问题的理解》 图片的懒加载和预加载相关知识点： 预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。 懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。 两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。 懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。 回答： 懒加载也叫延迟加载，指的是在长网页中延迟加载图片的时机，当用户需要访问时，再去加载，这样可以提高网站的首屏加载速度，提升用户的体验，并且可以减少服务器的压力。它适用于图片很多，页面很长的电商网站的场景。懒加载的实现原理是，将页面上的图片的 src 属性设置为空字符串，将图片的真实路径保存在一个自定义属性中，当页面滚动的时候，进行判断，如果图片进入页面可视区域内，则从自定义属性中取出真实路径赋值给图片的 src 属性，以此来实现图片的延迟加载。 预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。通过预加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 scr 属性，来实现图片的预加载。 这两种方式都是提高网页性能的方式，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。 详细资料可以参考：《懒加载和预加载》《网页图片加载优化方案》《基于用户行为的图片等资源预加载》 mouseover 和 mouseenter 的区别？当鼠标移动到元素上时就会触发 mouseenter 事件，类似 mouseover，它们两者之间的差别是 mouseenter 不会冒泡。 由于 mouseenter 不支持事件冒泡，导致在一个元素的子元素上进入或离开的时候会触发其 mouseover 和 mouseout 事件，但是却不会触发 mouseenter 和 mouseleave 事件。 详细资料可以参考：《mouseenter 与 mouseover 为何这般纠缠不清？》 js 拖拽功能的实现相关知识点： 首先是三个事件，分别是 mousedown，mousemove，mouseup当鼠标点击按下的时候，需要一个 tag 标识此时已经按下，可以执行 mousemove 里面的具体方法。clientX，clientY 标识的是鼠标的坐标，分别标识横坐标和纵坐标，并且我们用 offsetX 和 offsetY 来表示元素的元素的初始坐标，移动的举例应该是：鼠标移动时候的坐标-鼠标按下去时候的坐标。也就是说定位信息为：鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的 offetLeft. 回答： 一个元素的拖拽过程，我们可以分为三个步骤，第一步是鼠标按下目标元素，第二步是鼠标保持按下的状态移动鼠标，第三步是鼠标抬起，拖拽过程结束。 这三步分别对应了三个事件，mousedown 事件，mousemove 事件和 mouseup 事件。只有在鼠标按下的状态移动鼠标我们才会执行拖拽事件，因此我们需要在 mousedown 事件中设置一个状态来标识鼠标已经按下，然后在 mouseup 事件中再取消这个状态。 在 mousedown 事件中我们首先应该判断，目标元素是否为拖拽元素，如果是拖拽元素，我们就设置状态并且保存这个时候鼠标的位置。 然后在 mousemove 事件中，我们通过判断鼠标现在的位置和以前位置的相对移动，来确定拖拽元素在移动中的坐标。需要通过 event.clientX 和 clientY 获取拖拽位置，并实时更新位置最后 mouseup 事件触发后，清除状态，结束拖拽事件。（需要注意浏览器边界的情况） 详细资料可以参考：《原生 js 实现拖拽功能基本思路》 为什么使用 setTimeout 实现 setInterval？怎么模拟？相关知识点： 123456789101112131415161718192021// 思路是使用递归函数，不断地去执行 setTimeout 从而达到 setInterval 的效果function mySetInterval(fn, timeout) &#123; // 控制器，控制定时器是否继续执行 var timer = &#123; flag: true &#125;; // 设置递归函数，模拟定时器执行。 function interval() &#123; if (timer.flag) &#123; fn(); setTimeout(interval, timeout); &#125; &#125; // 启动定时器 setTimeout(interval, timeout); // 返回控制器 return timer;&#125; 回答： setInterval 的作用是每隔一段指定时间执行一个函数，但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。 针对 setInterval 的这个缺点，我们可以使用 setTimeout 递归调用来模拟 setInterval，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 setInterval 的问题。 详细资料可以参考：《用 setTimeout 实现 setInterval》《setInterval 有什么缺点？》 let 和 const 的注意点？1.声明的变量只在声明时的代码块内有效 2.不存在声明提升 3.存在暂时性死区，如果在变量声明前使用，会报错 4.不允许重复声明，重复声明会报错 什么是 rest 参数？rest 参数（形式为…变量名），用于获取函数的多余参数。 什么是尾调用，使用尾调用有什么好处？尾调用指的是函数的最后一步调用另一个函数。我们代码执行是基于执行栈的，所以当我们在一个函数里调用另一个函数时，我们会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这个时候我们可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。 Symbol 类型的注意点？1.Symbol 函数前不能使用 new 命令，否则会报错。 2.Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。 3.Symbol 作为属性名，该属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。 4.Object.getOwnPropertySymbols 方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。 5.Symbol.for 接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。 6.Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key。 Set 和 WeakSet 结构？1.ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 2.WeakSet 结构与 Set 类似，也是不重复的值的集合。但是 WeakSet 的成员只能是对象，而不能是其他类型的值。WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用， Map 和 WeakMap 结构？1.Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。 2.WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。 Reflect 对象创建目的？1.将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty，放到 Reflect 对象上。 2.修改某些 Object 方法的返回结果，让其变得更合理。 3.让 Object 操作都变成函数行为。 4.Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为。 require 模块引入的查找方式？12345678910111213141516171819202122232425当 Node 遇到 require(X) 时，按下面的顺序处理。（1）如果 X 是内置模块（比如 require(&apos;http&apos;)） a. 返回该模块。 b. 不再继续执行。（2）如果 X 以 &quot;./&quot; 或者 &quot;/&quot; 或者 &quot;../&quot; 开头 a. 根据 X 所在的父模块，确定 X 的绝对路径。 b. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。 X X.js X.json X.node c. 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。 X/package.json（main字段） X/index.js X/index.json X/index.node（3）如果 X 不带路径 a. 根据 X 所在的父模块，确定 X 可能的安装目录。 b. 依次在每个目录中，将 X 当成文件名或目录名加载。（4）抛出 &quot;not found&quot; 详细资料可以参考：《require() 源码解读》 什么是 Promise 对象，什么是 Promises/A+ 规范？Promise 对象是异步编程的一种解决方案，最早由社区提出。Promises/A+ 规范是 JavaScript Promise 的标准，规定了一个 Promise 所必须具有的特性。 Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是 pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者 rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。状态的改变是通过 resolve() 和 reject() 函数来实现的，我们可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。 详细资料可以参考：《Promises/A+ 规范》《Promise》 手写一个 Promise123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106const PENDING = \"pending\";const RESOLVED = \"resolved\";const REJECTED = \"rejected\";function MyPromise(fn) &#123; // 保存初始化状态 var self = this; // 初始化状态 this.state = PENDING; // 用于保存 resolve 或者 rejected 传入的值 this.value = null; // 用于保存 resolve 的回调函数 this.resolvedCallbacks = []; // 用于保存 reject 的回调函数 this.rejectedCallbacks = []; // 状态转变为 resolved 方法 function resolve(value) &#123; // 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变 if (value instanceof MyPromise) &#123; return value.then(resolve, reject); &#125; // 保证代码的执行顺序为本轮事件循环的末尾 setTimeout(() =&gt; &#123; // 只有状态为 pending 时才能转变， if (self.state === PENDING) &#123; // 修改状态 self.state = RESOLVED; // 设置传入的值 self.value = value; // 执行回调函数 self.resolvedCallbacks.forEach(callback =&gt; &#123; callback(value); &#125;); &#125; &#125;, 0); &#125; // 状态转变为 rejected 方法 function reject(value) &#123; // 保证代码的执行顺序为本轮事件循环的末尾 setTimeout(() =&gt; &#123; // 只有状态为 pending 时才能转变 if (self.state === PENDING) &#123; // 修改状态 self.state = REJECTED; // 设置传入的值 self.value = value; // 执行回调函数 self.rejectedCallbacks.forEach(callback =&gt; &#123; callback(value); &#125;); &#125; &#125;, 0); &#125; // 将两个方法传入函数执行 try &#123; fn(resolve, reject); &#125; catch (e) &#123; // 遇到错误时，捕获错误，执行 reject 函数 reject(e); &#125;&#125;MyPromise.prototype.then = function(onResolved, onRejected) &#123; // 首先判断两个参数是否为函数类型，因为这两个参数是可选参数 onResolved = typeof onResolved === \"function\" ? onResolved : function(value) &#123; return value; &#125;; onRejected = typeof onRejected === \"function\" ? onRejected : function(error) &#123; throw error; &#125;; // 如果是等待状态，则将函数加入对应列表中 if (this.state === PENDING) &#123; this.resolvedCallbacks.push(onResolved); this.rejectedCallbacks.push(onRejected); &#125; // 如果状态已经凝固，则直接执行对应状态的函数 if (this.state === RESOLVED) &#123; onResolved(this.value); &#125; if (this.state === REJECTED) &#123; onRejected(this.value); &#125;&#125;; 如何检测浏览器所支持的最小字体大小？用 JS 设置 DOM 的字体为某一个值，然后再取出来，如果值设置成功，就说明支持。 怎么做 JS 代码 Error 统计？error 统计使用浏览器的 window.error 事件。 单例模式模式是什么？单例模式保证了全局只有一个实例来被访问。比如说常用的如弹框组件的实现和全局状态的实现。 策略模式是什么？策略模式主要是用来将方法的实现和方法的调用分离开，外部通过不同的参数可以调用不同的策略。我主要在 MVP 模式解耦的时候用来将视图层的方法定义和方法调用分离。 代理模式是什么？ 代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。比如说常见的事件代理。 中介者模式是什么？中介者模式指的是，多个对象通过一个中介者进行交流，而不是直接进行交流，这样能够将通信的各个对象解耦。 适配器模式是什么？适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。假如我们需要一种新的接口返回方式，但是老的接口由于在太多地方已经使用了，不能随意更改，这个时候就可以使用适配器模式。比如我们需要一种自定义的时间返回格式，但是我们又不能对 js 时间格式化的接口进行修改，这个时候就可以使用适配器模式。 更多关于设计模式的资料可以参考：《前端面试之道》《JavaScript 设计模式》《JavaScript 中常见设计模式整理》 开发中常用的几种Content-Type ？12345678910111213141516（1）application/x-www-form-urlencoded浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。（2）multipart/form-data该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。（3）application/json告诉服务器消息主体是序列化后的 JSON 字符串。（4）text/xml该种方式主要用来提交 XML 格式的数据。 详细资料可以参考：《常用的几种 Content-Type》 如何确定页面的可用性时间，什么是 Performance API？123456789Performance API 用于精确度量、控制、增强浏览器的性能表现。这个 API 为测量网站性能，提供以前没有办法做到的精度。使用 getTime 来计算脚本耗时的缺点，首先，getTime方法（以及 Date 对象的其他方法）都只能精确到毫秒级别（一秒的千分之一），想要得到更小的时间差别就无能为力了。其次，这种写法只能获取代码运行过程中的时间进度，无法知道一些后台事件的时间进度，比如浏览器用了多少时间从服务器加载网页。为了解决这两个不足之处，ECMAScript 5引入“高精度时间戳”这个 API，部署在 performance 对象上。它的精度可以达到1毫秒的千分之一（1秒的百万分之一）。navigationStart：当前浏览器窗口的前一个网页关闭，发生 unload 事件时的 Unix 毫秒时间戳。如果没有前一个网页，则等于 fetchStart 属性。loadEventEnd：返回当前网页 load 事件的回调函数运行结束时的 Unix 毫秒时间戳。如果该事件还没有发生，返回 0。 根据上面这些属性，可以计算出网页加载各个阶段的耗时。比如，网页加载整个过程的耗时的计算方法如下： 12var t = performance.timing;var pageLoadTime = t.loadEventEnd - t.navigationStart; 详细资料可以参考：《Performance API》 js 中的命名规则（1）第一个字符必须是字母、下划线（_）或美元符号（$）（2）余下的字符可以是下划线、美元符号或任何字母或数字字符 一般我们推荐使用驼峰法来对变量名进行命名，因为这样可以与 ECMAScript 内置的函数和对象命名格式保持一致。 详细资料可以参考：《ECMAScript 变量》 js 语句末尾分号是否可以省略？在 ECMAScript 规范中，语句结尾的分号并不是必需的。但是我们一般最好不要省略分号，因为加上分号一方面有利于我们代码的可维护性，另一方面也可以避免我们在对代码进行压缩时出现错误。 Object.assign()1Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 Math.ceil 和 Math.floor123Math.ceil() === 向上取整，函数返回一个大于或等于给定数字的最小整数。Math.floor() === 向下取整，函数返回一个小于或等于给定数字的最大整数。 js for 循环注意点123456for (var i = 0, j = 0; i &lt; 5, j &lt; 9; i++, j++) &#123; console.log(i, j);&#125;// 当判断语句含有多个语句时，以最后一个判断语句的值为准，因此上面的代码会执行 10 次。// 当判断语句为空时，循环会一直进行。 一个列表，假设有 100000 个数据，这个该怎么办？我们需要思考的问题：该处理是否必须同步完成？数据是否必须按顺序完成？ 解决办法： （1）将数据分页，利用分页的原理，每次服务器端只返回一定数目的数据，浏览器每次只对一部分进行加载。 （2）使用懒加载的方法，每次加载一部分数据，其余数据当需要使用时再去加载。 （3）使用数组分块技术，基本思路是为要处理的项目创建一个队列，然后设置定时器每过一段时间取出一部分数据，然后再使用定时器取出下一个要处理的项目进行处理，接着再设置另一个定时器。 js 中倒计时的纠偏实现？在前端实现中我们一般通过 setTimeout 和 setInterval 方法来实现一个倒计时效果。但是使用这些方法会存在时间偏差的问题，这是由于 js 的程序执行机制造成的，setTimeout 和 setInterval 的作用是隔一段时间将回调事件加入到事件队列中，因此事件并不是立即执行的，它会等到当前执行栈为空的时候再取出事件执行，因此事件等待执行的时间就是造成误差的原因。 一般解决倒计时中的误差的有这样两种办法： （1）第一种是通过前端定时向服务器发送请求获取最新的时间差，以此来校准倒计时时间。 （2）第二种方法是前端根据偏差时间来自动调整间隔时间的方式来实现的。这一种方式首先是以 setTimeout 递归的方式来实现倒计时，然后通过一个变量来记录已经倒计时的秒数。每一次函数调用的时候，首先将变量加一，然后根据这个变量和每次的间隔时间，我们就可以计算出此时无偏差时应该显示的时间。然后将当前的真实时间与这个时间相减，这样我们就可以得到时间的偏差大小，因此我们在设置下一个定时器的间隔大小的时候，我们就从间隔时间中减去这个偏差大小，以此来实现由于程序执行所造成的时间误差的纠正。 详细资料可以参考：《JavaScript 前端倒计时纠偏实现》 进程间通信的方式？ 1.管道通信 2.消息队列通信 3.信号量通信 4.信号通信 5.共享内存通信 6.套接字通信 详细资料可以参考：《进程间 8 种通信方式详解》《进程与线程的一个简单解释》 ele.getElementsByClassName和ele.querySelectorAll的区别？123456789101112131415161718192021222324element.getElementsByClassName 返回一个即时更新（动态的）HTMLCollectionelement.querySelectorAll 返回一个非即时更新（静态的） NodeList// 先说什么叫即时更新，（前者是动态的，改变 DOM 结构会同步，后者只会记录调用 api 时的结果，不懂可以看下面的例子）&lt;div id=&quot;parent&quot;&gt; &lt;p class=&quot;p&quot;&gt;1&lt;/p&gt; &lt;p class=&quot;p&quot;&gt;2&lt;/p&gt; &lt;p class=&quot;p&quot;&gt;3&lt;/p&gt;&lt;/div&gt;&lt;script&gt;let list1 = parent.getElementsByClassName(&apos;p&apos;);let list2 = parent.querySelectorAll(&apos;.p&apos;);console.log(list1.length1); // 3console.log(list2.length1); // 3let newP = docuemnt.createElement(&quot;p&quot;)newP.classList.add(&apos;p&apos;);parent.appendChild(newP);console.log(list1.length1); // 4 (即时更新)console.log(list2.length1); // 3（非即时更新）&lt;/script&gt;// 在说下返回值// HTMLCollection 和 NodeList 都是类数组形式如下一个 div 可以看成是 HTMLDivElement 的实例，其中 Node 的集合为 NodeList；Element 的集合为 HTMLCollectionEventTarget - Node - Element - HTMLElement - HTMLDivElement&lt;br&gt;EventTarget - Node - Element - SVGElement - SVGPathElement&lt;br&gt; MDN 上元素 div 继承关系 请用 js 去除字符串空格？答案：replace 正则匹配方法、str.trim()方法、JQ 方法：$.trim(str)方法 解析： 方法一：replace 正则匹配方法 去除字符串内所有的空格：str = str.replace(/\\s*/g,””); 去除字符串内两头的空格：str = str.replace(/^\\s|\\s$/g,””); 去除字符串内左侧的空格：str = str.replace(/^\\s*/,””); 去除字符串内右侧的空格：str = str.replace(/(\\s*$)/g,””); 示例： 123456789101112131415var str = \" 6 6 \";var str_1 = str.replace(/\\s*/g, \"\");console.log(str_1); //66var str = \" 6 6 \";var str_1 = str.replace(/^\\s*|\\s*$/g, \"\");console.log(str_1); //6 6//输出左右侧均无空格var str = \" 6 6 \";var str_1 = str.replace(/^\\s*/, \"\");console.log(str_1); //6 6 //输出右侧有空格左侧无空格var str = \" 6 6 \";var str_1 = str.replace(/(\\s*$)/g, \"\");console.log(str_1); // 6 6//输出左侧有空格右侧无空格 方法二：str.trim()方法 trim()方法是用来删除字符串两端的空白字符并返回，trim 方法并不影响原来的字符串本身，它返回的是一个新的字符串。 缺陷：只能去除字符串两端的空格，不能去除中间的空格 示例： 123var str = \" 6 6 \";var str_1 = str.trim();console.log(str_1); //6 6//输出左右侧均无空格 方法三：JQ 方法：$.trim(str)方法 $.trim() 函数用于去除字符串两端的空白字符。 注意：$.trim()函数会移除字符串开始和末尾处的所有换行符，空格(包括连续的空格)和制表符。如果这些空白字符在字符串中间时，它们将被保留，不会被移除。 示例： 123var str = \" 6 6 \";var str_1 = $.trim(str);console.log(str_1); //6 6//输出左右侧均无空格 同步和异步的区别?同步的概念应该是来自于OS中关于同步的概念:不同进程为协同完成某项工作而在先后次序上调整(通过阻塞,唤醒等方式).同步强调的是顺序性.谁先谁后.异步则不存在这种顺序性. 同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作 异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容 异步加载JS的方式有哪些？ (1) defer，只支持IE (2) async： (3) 创建script，插入到DOM中，加载完毕后callBack 异步处理方法（参考链接）1)回调函数： 123456789101112131415161718function fn1 () &#123; console.log(&apos;Function 1&apos;)&#125;function fn2 (f) &#123; setTimeout(() =&gt; &#123; console.log(&apos;Function 2&apos;) f()&#125;, 500)&#125;function fn3 () &#123; console.log(&apos;Function 3&apos;)&#125;fn1();fn2(fn3) ; //可依次执行fn1，fn2，fn3 2)发布/订阅模式； 12345678910111213141516171819202122232425262728293031class AsyncFunArr &#123; constructor (...arr) &#123; this.funcArr = [...arr]&#125;next () &#123; const fn = this.funcArr.shift() if (typeof fn === &apos;function&apos;) fn()&#125;run () &#123; this.next()&#125;&#125;function fn1 () &#123; console.log(&apos;Function 1&apos;) asyncFunArr.next()&#125;function fn2 () &#123; setTimeout(() =&gt; &#123; console.log(&apos;Function 2&apos;) asyncFunArr.next() &#125;, 500)&#125;function fn3 () &#123; console.log(&apos;Function 3&apos;) asyncFunArr.next()&#125; 3）Promise： 1234567891011121314151617181920212223242526272829function fn1 () &#123;console.log(&apos;Function 1&apos;)&#125;function fn2 () &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&apos;Function 2&apos;) resolve() &#125;, 500) &#125;)&#125;function fn3 () &#123;console.log(&apos;Function 3&apos;)&#125;fn1()；fn2().then(() =&gt; &#123; fn3() &#125;)； 4)generator:（参考链接） documen.write和 innerHTML的区别 document.write只能重绘整个页面 innerHTML可以重绘页面的一部分 怎样添加、移除、移动、复制、创建和查找节点？1）创建新节点 createDocumentFragment() //创建一个 DOM 片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点 2）添加、移除、替换、插入 appendChild() //添加 removeChild() //移除 replaceChild() //替换 insertBefore() //插入 3）查找 getElementsByTagName() //通过标签名称 getElementsByName() //通过元素的 Name 属性的值 getElementById() //通过元素 Id，唯一性 如何判断 JS 变量的一个类型（至少三种方式）typeof、instanceof、 constructor、 prototype null/undefined 的区别null： Null 类型，代表“空值”，代表一个空对象指针，使用 typeof 运算得到 “object”，所以你可以认为它是一个特殊的对象值。 undefined： Undefined 类型，当一个声明了一个变量未初始化时，得到的就是 undefined。 去除字符串里面的重复字符最简单的方式 12[...new Set(\"ababbc\")].join(\"\");// \"abc\" 数组和对象的深浅拷贝（参考链接）String + Array的一些基本操作（参考链接）冒泡和捕获（参考链接）事件代理（参考链接）jsonp和跨域，为什么浏览器会禁止跨域（参考链接：jsonp）变量提升（参考链接）高阶函数（参考链接）动画（参考链接）模块化开发参考链接、 UMD引起内存泄漏的原因（参考链接）1）全局变量引起的内存泄漏 function leaks(){ leak = ‘xxxxxx’;//leak 成为一个全局变量，不会被回收} 2）闭包引起的内存泄漏 123456var leaks = (function()&#123; var leak = &apos;xxxxxx&apos;;// 被闭包所引用，不会被回收 return function()&#123; console.log(leak); &#125;&#125;)() 3）dom清空或删除时，事件未清除导致的内存泄漏 123456789$(&apos;#container&apos;).bind(&apos;click&apos;, function()&#123; console.log(&apos;click&apos;);&#125;).remove();// zepto 和原生 js下，#container dom 元素，还在内存里jquery 的 empty和 remove会帮助开发者避免这个问题$(&apos;#container&apos;).bind(&apos;click&apos;, function()&#123; console.log(&apos;click&apos;);&#125;).off(&apos;click&apos;).remove();//把事件清除了，即可从内存中移除 4） 被遗忘的计时器或回调函数 12345678910111213var someResource = getData();setInterval(function() &#123; var node = document.getElementById(&apos;Node&apos;); if(node) &#123; // 处理 node 和 someResource node.innerHTML = JSON.stringify(someResource));&#125;&#125;, 1000);修改：var element = document.getElementById(&apos;button&apos;);function onClick(event) &#123; element.innerHTML = &apos;text&apos;;&#125;element.addEventListener(&apos;click&apos;, onClick); map、filter、reduce相关参考链接： https://atendesigngroup.com/blog/array-map-filter-and-reduce-js http://zerosoul.github.io/2016/12/06/array-filter-map-reduce-in-js Map和Set（参考链接）Map是一组键值对的结构，具有极快的查找速度。 例：var m =new Map([[‘Michael’,95], [‘Bob’,75], [‘Tracy’,85]]); m.get(‘Michael’);// 95 Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。 要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set： var s1 = new Set(); // 空Set var s2 = new Set([1, 2, 3]); // 含1, 2, 3 js 是一门怎样的语言，它有什么特点1.脚本语言。JavaScript 是一种解释型的脚本语言,C、C++等语言先编译后执行,而 JavaScript 是在程序的运行过程中逐行进行解释。 2.基于对象。JavaScript 是一种基于对象的脚本语言,它不仅可以创建对象,也能使用现有的对象。 3.简单。JavaScript 语言中采用的是弱类型的变量类型,对使用的数据类型未做出严格的要求,是基于 Java 基本语句和控制的脚本语言,其设计简单紧凑。 4.动态性。JavaScript 是一种采用事件驱动的脚本语言,它不需要经过 Web 服务器就可以对用户的输入做出响应。 5.跨平台性。JavaScript 脚本语言不依赖于操作系统,仅需要浏览器的支持。 JavaScript 的循环语句有哪些？while for do while forEach script 的位置是否会影响首屏显示时间？ 在解析 HTML 生成 DOM 过程中，js 文件的下载是并行的，不需要 DOM 处理到 script 节点。因此，script的位置不影响首屏显示的开始时间。 浏览器解析 HTML 是自上而下的线性过程，script作为 HTML 的一部分同样遵循这个原则 因此，script 会延迟 DomContentLoad，只显示其上部分首屏内容，从而影响首屏显示的完成时间 JavaScript有几种类型的值？你能画一下他们的内存图吗？栈：原始数据类型（Undefined，Null，Boolean，Number、String） 堆：引用数据类型（对象、数组和函数） 两种类型的区别是：存储位置不同； 原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储； 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体 eval是做什么的？eval的功能是把对应的字符串解析成JS代码并运行 应该避免使用eval，不安全，非常耗性能（先解析成js语句，再执行） 由JSON字符串转换为JSON对象的时候可以用 eval(‘(‘+ str +’)’); javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？ use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行, 使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。 默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值; 全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用； 消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同; 提高编译器效率，增加运行速度；为未来新版本的Javascript标准化做铺垫。 js延迟加载的方式有哪些？ defer和async、动态创建DOM方式（用得最多）、按需异步载入js 介绍 DOM 的发展 DOM：文档对象模型（Document Object Model），定义了访问HTML和XML文档的标准，与编程语言及平台无关 DOM0：提供了查询和操作Web文档的内容API。未形成标准，实现混乱。如：document.forms[‘login’] DOM1：W3C提出标准化的DOM，简化了对文档中任意部分的访问和操作。如：JavaScript中的Document对象 DOM2：原来DOM基础上扩充了鼠标事件等细分模块，增加了对CSS的支持。如：getComputedStyle(elem, pseudo) DOM3：增加了XPath模块和加载与保存（Load and Save）模块。如：XPathEvaluator 区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”？ 客户区坐标：鼠标指针在可视区中的水平坐标(clientX)和垂直坐标(clientY) 页面坐标：鼠标指针在页面布局中的水平坐标(pageX)和垂直坐标(pageY) 屏幕坐标：设备物理屏幕的水平坐标(screenX)和垂直坐标(screenY) 如何获得一个DOM元素的绝对位置？ elem.offsetLeft：返回元素相对于其定位父级左侧的距离 elem.offsetTop：返回元素相对于其定位父级顶部的距离 elem.getBoundingClientRect()：返回一个DOMRect对象，包含一组描述边框的只读属性，单位像素 用原生JavaScript的实现过什么功能吗？封装选择器、调用第三方API、设置和获取样式 JavaScript实现异步编程的方法？ 回调函数 事件监听 发布/订阅 Promises对象 Async函数[ES7] web开发中会话跟踪的方法有哪些 cookie session url重写 隐藏input ip地址 JavaScript有几种类型的值？，你能画一下他们的内存图吗？ 栈：原始数据类型（Undefined，Null，Boolean，Number、String） 堆：引用数据类型（对象、数组和函数） 两种类型的区别是：存储位置不同； 原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储； 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其 在栈中的地址，取得地址后从堆中获得实体 eval是做什么的？ 它的功能是把对应的字符串解析成JS代码并运行 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行） 由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(‘(‘+ str +’)’) javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？ use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为 js延迟加载的方式有哪些？defer和async、动态创建DOM方式（用得最多）、按需异步载入js 异步加载JS的方式有哪些？ defer，只支持IE async： 创建script，插入到DOM中，加载完毕后callBack defer和asyncdefer并行加载js文件，会按照页面上script标签的顺序执行async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行 documen.write和 innerHTML的区别 document.write只能重绘整个页面 innerHTML可以重绘页面的一部分 那些操作会造成内存泄漏？ 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） Javascript垃圾回收方法标记清除（mark and sweep） 这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境” 垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了 引用计数(reference counting) 在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间 用过哪些设计模式？工厂模式： 主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字。将所有实例化的代码集中在一个位置防止代码重复 工厂模式解决了重复实例化的问题 ，但还有一个问题,那就是识别问题，因为根本无法 搞清楚他们到底是哪个对象的实例 12345678910function createObject(name,age,profession)&#123;//集中实例化的函数var obj = new Object(); obj.name = name; obj.age = age; obj.profession = profession; obj.move = function () &#123; return this.name + &apos; at &apos; + this.age + &apos; engaged in &apos; + this.profession; &#125;; return obj;&#125;var test1 = createObject(&apos;trigkit4&apos;,22,&apos;programmer&apos;);//第一个实例var test2 = createObject(&apos;mike&apos;,25,&apos;engineer&apos;);//第二个实例 构造函数模式 使用构造函数的方法 ，即解决了重复实例化的问题 ，又解决了对象识别的问题，该模式与工厂模式的不同之处在于 构造函数方法没有显示的创建对象 (new Object()); 直接将属性和方法赋值给 this 对象; 没有 renturn 语句 实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制1234567Object.prototype.clone = function()&#123; var o = this.constructor === Array ? [] : &#123;&#125;; for(var e in this)&#123; o[e] = typeof this[e] === &quot;object&quot; ? this[e].clone() : this[e]; &#125; return o;&#125; 说说严格模式的限制 严格模式主要有以下限制： 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀0表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性delete global[prop] eval不会在它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee 不能使用arguments.caller 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface） 如何删除一个cookie 将时间设为当前时间往前一点 12var date = new Date();date.setDate(date.getDate() - 1);//真正的删除 setDate()方法用于设置一个月的某一天 expires的设置 1document.cookie = &apos;user=&apos;+ encodeURIComponent(&apos;name&apos;) + &apos;;expires = &apos; + new Date(0) attribute和property的区别是什么？ attribute是dom元素在文档中作为html标签拥有的属性； property就是dom元素在js中作为对象拥有的属性。 对于html的标准属性来说，attribute和property是同步的，是会自动更新的 但是对于自定义的属性来说，他们是不同步的 页面编码和被请求的资源编码如果不一致如何处理？ 后端响应头设置 charset 前端页面&lt;meta&gt;设置 charset 把&lt;script&gt;放在&lt;/body&gt;之前和之后有什么区别？浏览器会如何解析它们？ 按照HTML标准，在&lt;/body&gt;结束后出现&lt;script&gt;或任何元素的开始标签，都是解析错误 虽然不符合HTML标准，但浏览器会自动容错，使实际效果与写在&lt;/body&gt;之前没有区别 浏览器的容错机制会忽略之前的&lt;/body&gt;，视作&lt;script&gt;仍在 body 体内。省略&lt;/body&gt;和&lt;/html&gt;闭合标签符合HTML标准，服务器可以利用这一标准尽可能少输出内容 延迟加载（异步加载）JS的方式有哪些？ 设置&lt;script&gt;属性 defer=\"defer\" （脚本将在页面完成解析时执行） 设置&lt;script&gt;属性 async=\"async\" （一旦脚本可用，则会异步执行） 动态创建 script DOM：document.createElement('script'); XmlHttpRequest 脚本注入 延迟加载工具 LazyLoad 异步加载库 LABjs 模块加载器 Sea.js JavaScript 对象生命周期的理解？ 当创建一个对象时，JavaScript 会自动为该对象分配适当的内存 垃圾回收器定期扫描对象，并计算引用了该对象的其他对象的数量 如果被引用数量为 0，或惟一引用是循环的，那么该对象的内存即可回收 哪些操作会造成内存泄漏？ JavaScript 内存泄露指对象在不需要使用它时仍然存在，导致占用的内存不能使用或回收 未使用 var 声明的全局变量 闭包函数(Closures) 循环引用(两个对象相互引用) 控制台日志(console.log) 移除存在绑定事件的DOM元素(IE) require 与 import 的区别两者的加载方式不同、规范不同 第一、两者的加载方式不同，require 是在运行时加载，而 import 是在编译时加载 require('./a')(); // a 模块是一个函数，立即执行 a 模块函数 var data = require('./a').data; // a 模块导出的是一个对象 var a = require('./a')[0]; // a 模块导出的是一个数组 ======> 哪都行 import $ from 'jquery'; import * as _ from '_'; import {a,b,c} from './a'; import {default as alias, a as a_a, b, c} from './a'; ======>用在开头 第二、规范不同，require 是 CommonJS/AMD 规范，import 是 ESMAScript6+规范 第三、require 特点：社区方案，提供了服务器/浏览器的模块加载方案。非语言层面的标准。只能在运行时确定模块的依赖关系及输入/输出的变量，无法进行静态优化。 import 特点：语言规格层面支持模块功能。支持编译时静态分析，便于 JS 引入宏和类型检验。动态绑定。 https://zhidao.baidu.com/question/1180348878138910499.html) 复杂数据类型如何转变为字符串 首先，会调用 valueOf 方法，如果方法的返回值是一个基本数据类型，就返回这个值， 如果调用 valueOf 方法之后的返回值仍旧是一个复杂数据类型，就会调用该对象的 toString 方法， 如果 toString 方法调用之后的返回值是一个基本数据类型，就返回这个值， 如果 toString 方法调用之后的返回值是一个复杂数据类型，就报一个错误。 解析： 123456789101112131415161718192021222324252627282930313233341;var obj = &#123; valueOf: function() &#123; return 1; &#125;&#125;;console.log(obj + \"\"); //'1'2;var obj = &#123; valueOf: function() &#123; return [1, 2]; &#125;&#125;;console.log(obj + \"\"); //'[object Object]';3;var obj = &#123; valueOf: function() &#123; return [1, 2]; &#125;, toString: function() &#123; return 1; &#125;&#125;;console.log(obj + \"\"); //'1';4;var obj = &#123; valueOf: function() &#123; return [1, 2]; &#125;, toString: function() &#123; return [1, 2, 3]; &#125;&#125;;console.log(obj + \"\"); // 报错 Uncaught TypeError: Cannot convert object to primitive value 拓展： 12345678910var arr = [new Object(), new Date(), new RegExp(), new String(), new Number(), new Boolean(), new Function(), new Array(), Math] console.log(arr.length) // 9for (var i = 0; i &lt; arr.length; i++) &#123; arr[i].valueOf = function() &#123; return [1, 2, 3] &#125; arr[i].toString = function() &#123; return 'toString' &#125; console.log(arr[i] + '')&#125; 1、若 return [1,2,3]处为 return \"valueof\"，得到的返回值是 valueof toString 7valueof说明：其他八种复杂数据类型是先调用 valueOf 方法，时间对象是先调用 toString 方法 2、改成 return [1,2,3]，得到的返回值是 9toString说明：执行 valueof 后都来执行 toString JS 哪些操作会造成内存泄露1）意外的全局变量引起的内存泄露 123function leak() &#123; leak = \"xxx\"; //leak成为一个全局变量，不会被回收&#125; 2）闭包引起的内存泄露 123456function bindEvent() &#123; var obj = document.createElement(\"XXX\"); obj.οnclick = function() &#123; //Even if it's a empty function &#125;;&#125; 闭包可以维持函数内局部变量，使其得不到释放。 上例定义事件回调时，由于是函数内定义函数，并且内部函数--事件回调的引用外暴了，形成了闭包。解决之道，将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对 dom 的引用。 1234567891011121314151617//将事件处理函数定义在外部function onclickHandler() &#123; //do something&#125;function bindEvent() &#123; var obj = document.createElement(\"XXX\"); obj.οnclick = onclickHandler;&#125;//在定义事件处理函数的外部函数中，删除对dom的引用function bindEvent() &#123; var obj = document.createElement(\"XXX\"); obj.οnclick = function() &#123; //Even if it's a empty function &#125;; obj = null;&#125; 3）没有清理的 DOM 元素引用 12345678910111213var elements=&#123; button: document.getElementById(\"button\"), image: document.getElementById(\"image\"), text: document.getElementById(\"text\")&#125;;function doStuff()&#123; image.src=\"http://some.url/image\"; button.click(): console.log(text.innerHTML)&#125;function removeButton()&#123; document.body.removeChild(document.getElementById('button'))&#125; 4）被遗忘的定时器或者回调 1234567var someResouce = getData();setInterval(function() &#123; var node = document.getElementById(\"Node\"); if (node) &#123; node.innerHTML = JSON.stringify(someResouce); &#125;&#125;, 1000); 这样的代码很常见, 如果 id 为 Node 的元素从 DOM 中移除, 该定时器仍会存在, 同时, 因为回调函数中包含对 someResource 的引用, 定时器外面的 someResource 也不会被释放。 5）子元素存在引起的内存泄露 黄色是指直接被 js 变量所引用，在内存里，红色是指间接被 js 变量所引用，如上图，refB 被 refA 间接引用，导致即使 refB 变量被清空，也是不会被回收的子元素 refB 由于 parentNode 的间接引用，只要它不被删除，它所有的父元素（图中红色部分）都不会被删除。 6）IE7/8 引用计数使用循环引用产生的问题 1234567function fn() &#123; var a = &#123;&#125;; var b = &#123;&#125;; a.pro = b; b.pro = a;&#125;fn(); fn()执行完毕后，两个对象都已经离开环境，在标记清除方式下是没有问题的，但是在引用计数策略下，因为 a 和 b 的引用次数不为 0，所以不会被垃圾回收器回收内存，如果 fn 函数被大量调用，就会造成内存泄漏。在 IE7 与 IE8 上，内存直线上升。IE 中有一部分对象并不是原生 js 对象。例如，其内存泄漏 DOM 和 BOM 中的对象就是使用 C++以 COM 对象的形式实现的，而 COM 对象的垃圾回收机制采用的就是引用计数策略。因此，即使 IE 的 js 引擎采用标记清除策略来实现，但 js 访问的 COM 对象依然是基于引用计数策略的。换句话说，只要在 IE 中涉及 COM 对象，就会存在循环引用的问题。 1234var element = document.getElementById(\"some_element\");var myObject = new Object();myObject.e = element;element.o = myObject; 上面的例子在一个 DOM 元素（element)与一个原生 js 对象（myObject)之间创建了循环引用。其中，变量 myObject 有一个名为 e 的属性指向 element 对象；而变量 element 也有一个属性名为 o 回指 myObject。由于存在这个循环引用，即使例子中的 DOM 从页面中移除，它也永远不会被回收。 看上面的例子，有人会觉得太弱了，谁会做这样无聊的事情，但是其实我们经常会这样做 1234window.οnlοad=function outerFunction()&#123; var obj=document.getElementById(\"element\"): obj.οnclick=function innerFunction()&#123;&#125;;&#125;; 这段代码看起来没什么问题，但是 obj 引用了 document.getElementById(“element”)，而 document.getElementById(“element”)的 onclick 方法会引用外部环境中的变量，自然也包括 obj，是不是很隐蔽啊。 最简单的解决方式就是自己手工解除循环引用，比如刚才的函数可以这样 1234567myObject.element=null;element.o=null;window.οnlοad=function outerFunction()&#123; var obj=document.getElementById(\"element\"): obj.οnclick=function innerFunction()&#123;&#125;; obj=null;&#125;; 将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾回收器下次运行时，就会删除这些值并回收它们占用的内存。 要注意的是，IE9+并不存在循环引用导致 Dom 内存泄漏问题，可能是微软做了优化，或者 Dom 的回收方式已经改变 JS 的回收机制JavaScript 垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收系统（GC）会按照固定的时间间隔,周期性的执行。 到底哪个变量是没有用的？所以垃圾收集器必须跟踪到底哪个变量没用，对于不再有用的变量打上标记，以备将来收回其内存。用于标记的无用变量的策略可能因实现而有所区别，通常情况下有两种实现方式：标记清除和引用计数。引用计数不太常用，标记清除较为常用。 标记清除（mark and sweep）js 中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。 12345function test() &#123; var a = 10; //被标记，进入环境 var b = 20; //被标记，进入环境&#125;test(); //执行完毕之后a、b又被标记离开环境，被回收 引用计数(reference counting)引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值（function object array）赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为 0 的值所占用的内存。 123456function test() &#123; var a = &#123;&#125;; //a的引用次数为0 var b = a; //a的引用次数加1，为1 var c = a; //a的引用次数加1，为2 var b = &#123;&#125;; //a的引用次数减1，为1&#125; 如何分析内存的使用情况Google Chrome 浏览器提供了非常强大的 JS 调试工具，Memory 视图 profiles 视图让你可以对 JavaScript 代码运行时的内存进行快照，并且可以比较这些内存快照。它还让你可以记录一段时间内的内存分配情况。在每一个结果视图中都可以展示不同类型的列表，但是对我们最有用的是 summary 列表和 comparison 列表。 summary 视图提供了不同类型的分配对象以及它们的合计大小：shallow size （一个特定类型的所有对象的总和）和 retained size （shallow size 加上保留此对象的其它对象的大小）。distance 显示了对象到达 GC 根（校者注：最初引用的那块内存，具体内容可自行搜索该术语）的最短距离。 comparison 视图提供了同样的信息但是允许对比不同的快照。这对于找到泄漏很有帮助。 5、怎样避免内存泄露 1）减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收； 2）注意程序逻辑，避免“死循环”之类的 ； 3）避免创建过多的对象 原则：不用了的东西要及时归还。 参考 发布订阅设计模式答案：发布/订阅模式(Publish Subscribe Pattern)属于设计模式中的行为(Behavioral Patterns) 解析：参考 Zepto 的点透问题如何解决？方案一：来得很直接 github 上有个 fastclick 可以完美解决https://github.com/ftlabs/fastclick 引入 fastclick.js，因为 fastclick 源码不依赖其他库所以你可以在原生的 js 前直接加上 1234567window.addEventListener( \"load\", function() &#123; FastClick.attach(document.body); &#125;, false); 或者有 zepto 或者 jqm 的 js 里面加上 123$(function() &#123; FastClick.attach(document.body);&#125;); 当然 require 的话就这样： 12var FastClick = require(\"fastclick\");FastClick.attach(document.body, options); 方案二：用 touchend 代替 tap 事件并阻止掉 touchend 的默认行为 preventDefault() 1234$(\"#cbFinish\").on(\"touchend\", function(event) &#123; //很多处理比如隐藏什么的 event.preventDefault();&#125;); 方案三：延迟一定的时间(300ms+)来处理事件 12345$(\"#cbFinish\").on(\"tap\", function(event) &#123; setTimeout(function() &#123; //很多处理比如隐藏什么的 &#125;, 320);&#125;); 这种方法其实很好，可以和 fadeInIn/fadeOut 等动画结合使用，可以做出过渡效果 理论上上面的方法可以完美的解决 tap 的点透问题，如果真的不行，用 click 解析： “点透”是什么？你可能碰到过在列表页面上创建一个弹出层，弹出层有个关闭的按钮，你点了这个按钮关闭弹出层后后，这个按钮正下方的内容也会执行点击事件（或打开链接）。这个被定义为这是一个“点透”现象。 2、为什么会出现点透呢？ 参考 移动端最小触控区域是多大？苹果推荐是 44pt x 44pt 解析：参考 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？ 300 毫秒 因为浏览器捕获第一次单击后，会先等待一段时间，如果在这段时间区间里用户未进行下一次点击，则浏览器会做单击事件的处理。如果这段时间里用户进行了第二次单击操作，则浏览器会做双击事件处理。 推荐 fastclick.js 如何获取浏览器版本信息1window.navigator.userAgent 调试工具的使用调试模式中的按钮作用F8 跳出断点调试模式F10、F11 代码的逐行调试 进入断点调试模式的 方法 在浏览器当中打断点 直接在代码中加 debugger foo = foo||bar ，这行代码是什么意思？为什么要这样写？这种写法称为短路表达式 解析： 相当于 123456var foo;if (foo) &#123; foo = foo;&#125; else &#123; foo = bar;&#125; 答案：常用于函数参数的空判断 列举浏览器对象模型 BOM 里常用的至少 4 个对象，并列举 window 对象的常用方法至少 5 个？对象：Window，document，location，screen，history，navigator。方法：Alert（），confirm（），prompt（），open（），close（）。 class.forname 的作用?为什么要用?1231、获取Class对象的方式：类名.class、对象.getClass()、Class.forName(“类名”);2、通过Class对象自审3、动态调用方法 外部 JS 文件出现中文字符，会出现什么问题，怎么解决？会出现乱码，加 charset=”GB2312”; 在 JS 中有哪些会被隐式转换为 falseUndefined、null、关键字 false、NaN、零、空字符串 eval 是做什么的？ 它的功能是把对应的字符串解析成 JS 代码并运行 应该避免使用 eval，不安全，非常耗性能（2 次，一次解析成 js 语句，一次执行） documen.write 和 innerHTML 的区别?document.write 是重写整个 document, 写入内容是字符串的 htmlinnerHTML 是 HTMLElement 的属性，是一个元素的内部 html 内容 javascript 代码中的\"use strict\";是什么意思 ? 使用它区别是什么？意思是使用严格模式，使用严格模式，一些不规范的语法将不再支持 前端 templating(Mustache, underscore, handlebars)是干嘛的, 怎么用? Web 模板引擎是为了使用户界面与业务数据（内容）分离而产生的， Mustache 是一个 logic-less （轻逻辑）模板解析引擎，它的优势在于可以应用在 Javascript、PHP、Python、Perl 等多种编程语言中。 Underscore 封装了常用的 JavaScript 对象操作方法，用于提高开发效率。 Handlebars 是 JavaScript 一个语义模板库，通过对 view 和 data 的分离来快速构建 Web 模板。 说说写JavaScript的基本规范？1) 不要在同一行声明多个变量2) 使用 ===或!==来比较true/false或者数值3) switch必须带有default分支4) 函数应该有返回值5) for if else 必须使用大括号6) 语句结束加分号7) 命名要有意义，使用驼峰命名法 jQuery使用建议1) 尽量减少对dom元素的访问和操作2) 尽量避免给dom元素绑定多个相同类型的事件处理函数，可以将多个相同类型事件处理函数合并到一个处理函数，通过数据状态来处理分支3) 尽量避免使用toggle事件 Ajax使用全称 ： Asynchronous Javascript And XML所谓异步，就是向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。创建Ajax的过程：1) 创建XMLHttpRequest对象（异步调用对象） 1var xhr = new XMLHttpRequest(); 2) 创建新的Http请求（方法、URL、是否异步） 1xhr.open(‘get’,’example.php’,false); 3) 设置响应HTTP请求状态变化的函数。onreadystatechange事件中readyState属性等于4。响应的HTTP状态为200(OK)或者304(Not Modified)。4) 发送http请求 1xhr.send(data); 5) 获取异步调用返回的数据注意：1) 页面初次加载时，尽量在web服务器一次性输出所有相关的数据，只在页面加载完成之后，用户进行操作时采用ajax进行交互。2) 同步ajax在IE上会产生页面假死的问题。所以建议采用异步ajax。3) 尽量减少ajax请求次数4) ajax安全问题，对于敏感数据在服务器端处理，避免在客户端处理过滤。对于关键业务逻辑代码也必须放在服务器端处理。 JavaScript有几种类型的值？你能画一下他们的内存图吗？基本数据类型存储在栈中，引用数据类型（对象）存储在堆中，指针放在栈中。两种类型的区别是：存储位置不同；原始数据类型直接存储在栈中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；引用数据类型存储在堆中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 栈和堆的区别？栈（stack）：由编译器自动分配释放，存放函数的参数值，局部变量等；堆（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统释放。 Javascript实现继承的几种方式可以参考我的另一篇文章JavaScript实现类与继承的方法（全面整理） Javascript创建对象的几种方式？可以参考我的另一篇文章JavaScript实现类与继承的方法（全面整理） Javascript作用链域作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。注意：JS没有块级作用域，若要形成块级作用域，可通过（function（）｛｝）（）；立即执行的形式实现。 谈谈this的理解1) this总是指向函数的直接调用者（而非间接调用者）2) 如果有new关键字，this指向new出来的那个对象3) 在事件中，this指向目标元素，特殊的是IE的attachEvent中的this总是指向全局对象window。 eval是做什么的？它的功能是把对应的字符串解析成JS代码并运行；应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。 什么是window对象? 什么是document对象?window对象代表浏览器中打开的一个窗口。document对象代表整个html文档。实际上，document对象是window对象的一个属性。 null，undefined的区别？null表示一个对象被定义了，但存放了空指针，转换为数值时为0。undefined表示声明的变量未初始化，转换为数值时为NAN。typeof(null) -- object;typeof(undefined) -- undefined [\"1\", \"2\", \"3\"].map(parseInt) 答案是多少？[1,NaN,NaN] 解析：Array.prototype.map()array.map(callback[, thisArg])callback函数的执行规则参数：自动传入三个参数currentValue（当前被传递的元素）；index（当前被传递的元素的索引）；array（调用map方法的数组） parseInt方法接收两个参数第三个参数[\"1\", \"2\", \"3\"]将被忽略。parseInt方法将会通过以下方式被调用parseInt(\"1\", 0)parseInt(\"2\", 1)parseInt(\"3\", 2) parseInt的第二个参数radix为0时，ECMAScript5将string作为十进制数字的字符串解析；parseInt的第二个参数radix为1时，解析结果为NaN；parseInt的第二个参数radix在2—36之间时，如果string参数的第一个字符（除空白以外），不属于radix指定进制下的字符，解析结果为NaN。parseInt(\"3\", 2)执行时，由于\"3\"不属于二进制字符，解析结果为NaN。 关于事件，IE与火狐的事件机制有什么区别？ 如何阻止冒泡？IE为事件冒泡，Firefox同时支持事件捕获和事件冒泡。但并非所有浏览器都支持事件捕获。jQuery中使用event.stopPropagation()方法可阻止冒泡;（旧IE的方法 ev.cancelBubble = true;） 什么是闭包（closure），为什么要用它？闭包指的是一个函数可以访问另一个函数作用域中变量。常见的构造方法，是在一个函数内部定义另外一个函数。内部函数可以引用外层的变量；外层变量不会被垃圾回收机制回收。注意，闭包的原理是作用域链，所以闭包访问的上级作用域中的变量是个对象，其值为其运算结束后的最后一个值。优点：避免全局变量污染。缺点：容易造成内存泄漏。例子： 123456789function makeFunc() &#123; var name = &quot;Mozilla&quot;; function displayName() &#123; console.log(name); &#125; return displayName;&#125;var myFunc = makeFunc();myFunc(); //输出Mozilla myFunc 变成一个 闭包。闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。在我们的例子中，myFunc 是一个闭包，由 displayName 函数和闭包创建时存在的 \"Mozilla\" 字符串形成。 javascript 代码中的\"use strict\";是什么意思 ? 使用它区别是什么？除了正常模式运行外，ECMAscript添加了第二种运行模式：“严格模式”。作用：1) 消除js不合理，不严谨地方，减少怪异行为2) 消除代码运行的不安全之处，3) 提高编译器的效率，增加运行速度4) 为未来的js新版本做铺垫。 如何判断一个对象是否属于某个类？使用instanceof 即if(a instanceof Person){alert('yes');} Javascript中，执行时对象查找时，永远不会去查找原型的函数？Object.hasOwnProperty(proName)：是用来判断一个对象是否有你给出名称的属性。不过需要注意的是，此方法无法检查该对象的原型链中是否具有该属性，该属性必须是对象本身的一个成员。 对JSON的了解？全称：JavaScript Object NotationJSON中对象通过“{}”来标识，一个“{}”代表一个对象，如{“AreaId”:”123”}，对象的值是键值对的形式（key：value）。JSON是JS的一个严格的子集，一种轻量级的数据交换格式，类似于xml。数据格式简单，易于读写，占用带宽小。两个函数：JSON.parse(str)解析JSON字符串 把JSON字符串变成JavaScript值或对象JSON.stringify(obj)将一个JavaScript值(对象或者数组)转换为一个 JSON字符串eval('('＋json＋')')用eval方法注意加括号 而且这种方式更容易被攻击 JS延迟加载的方式有哪些？JS的延迟加载有助与提高页面的加载速度。defer和async、动态创建DOM方式（用得最多）、按需异步载入JSdefer：延迟脚本。立即下载，但延迟执行（延迟到整个页面都解析完毕后再运行），按照脚本出现的先后顺序执行。async：异步脚本。下载完立即执行，但不保证按照脚本出现的先后顺序执行。 同步和异步的区别?同步的概念在操作系统中：不同进程协同完成某项工作而先后次序调整（通过阻塞、唤醒等方式），同步强调的是顺序性，谁先谁后。异步不存在顺序性。同步：浏览器访问服务器，用户看到页面刷新，重新发请求，等请求完，页面刷新，新内容出现，用户看到新内容之后进行下一步操作。异步：浏览器访问服务器请求，用户正常操作，浏览器在后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。 什么是跨域问题 ，如何解决跨域问题?可以参考我的另一篇文章什么是跨域以及几种简单解决方案 页面编码和被请求的资源编码如果不一致如何处理？若请求的资源编码，如外引js文件编码与页面编码不同。可根据外引资源编码方式定义为 charset=\"utf-8\"或\"gbk\"。比如：http://www.yyy.com/a.html 中嵌入了一个http://www.xxx.com/test.jsa.html 的编码是gbk或gb2312的。 而引入的js编码为utf-8的 ，那就需要在引入的时候 1&lt;script src=&quot;http://www.xxx.com/test.js&amp;quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; 模块化开发怎么做？模块化开发指的是在解决某一个复杂问题或者一系列问题时，依照一种分类的思维把问题进行系统性的分解。模块化是一种将复杂系统分解为代码结构更合理，可维护性更高的可管理的模块方式。对于软件行业：系统被分解为一组高内聚，低耦合的模块。（1）定义封装的模块（2）定义新模块对其他模块的依赖（3）可对其他模块的引入支持。在JavaScript中出现了一些非传统模块开发方式的规范。 CommonJS的模块规范，AMD（Asynchronous Module Definition），CMD（Common Module Definition）等。AMD是异步模块定义，所有的模块将被异步加载，模块加载不影响后边语句运行。 AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。区别：1) 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。2) CMD 推崇依赖就近，AMD 推崇依赖前置。3) AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。 1234567891011121314// CMDdefine(function(require, exports, module) &#123; var a = require(&apos;./a&apos;) a.doSomething() // 此处略去 100 行 var b = require(&apos;./b&apos;) // 依赖可以就近书写 b.doSomething()&#125;)// AMD 默认推荐define([&apos;./a&apos;, &apos;./b&apos;], function(a, b) &#123; // 依赖必须一开始就写好 a.doSomething(); // 此处略去 100 行 b.doSomething();&#125;) requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）核心是js的加载模块，通过正则匹配模块以及模块的依赖关系，保证文件加载的先后顺序，根据文件的路径对加载过的文件做了缓存。 call和applycall（）方法和apply（）方法的作用相同，动态改变某个类的某个方法的运行环境。他们的区别在于接收参数的方式不同。 在使用call（）方法时，传递给函数的参数必须逐个列举出来。 使用apply（）时，传递给函数的是参数数组。 documen.write和 innerHTML的区别document.write()只能重绘整个页面 123setTimeout(function()&#123; document.write(&apos;&lt;p&gt;5 secs later&lt;/p&gt;&apos;);&#125;, 5000); 或 1window.onload = function() &#123; document.write(&quot;HI&quot;); innerHTML可以重绘页面的一部分 回流与重绘当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树。完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘 DOM操作（1）创建新节点createDocumentFragment() //创建一个DOM片段createElement() //创建一个具体的元素createTextNode() //创建一个文本节点（2）添加、移除、替换、插入appendChild()removeChild()replaceChild()insertBefore() //在已有的子节点前插入一个新的子节点（3）查找getElementsByTagName() //通过标签名称getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)getElementById() //通过元素Id，唯一性 数组对象有哪些原生方法，列举一下pop、push、shift、unshift、splice、reverse、sort、concat、join、slice、toString、indexOf、lastIndexOf、reduce、reduceRightforEach、map、filter、every、some 那些操作会造成内存泄漏全局变量、闭包、DOM清空或删除时，事件未清除、子元素存在引用 响应事件onclick鼠标点击某个对象；onfocus获取焦点；onblur失去焦点；onmousedown鼠标被按下 flash和js通过什么类如何交互?Flash提供了ExternalInterface接口与JavaScript通信，ExternalInterface有两个方法，call和addCallback，call的作用是让Flash调用js里的方法，addCallback是用来注册flash函数让js调用。 Flash与Ajax各自的优缺点？Flash：适合处理多媒体、矢量图形、访问机器。但对css、处理文本不足，不容易被搜索。Ajax：对css、文本支持很好，但对多媒体、矢量图形、访问机器不足。 有效的javascript变量定义规则第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；其他字符可以是字母、下划线、美元符号或数字。 XML与JSON的区别？1) 数据体积方面。JSON相对于XML来讲，数据的体积小，传递的速度更快些。2) 数据交互方面。JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。3) 数据描述方面。JSON对数据的描述性比XML较差。4) 传输速度方面。JSON的速度要远远快于XML。 HTML与XML的区别？（1）XML用来传输和存储数据，HTML用来显示数据；（2）XML使用的标签不用预先定义（3）XML标签必须成对出现（4）XML对大小写敏感（5）XML中空格不会被删减（6）XML中所有特殊符号必须用编码表示（7）XML中的图片必须有文字说明 渐进增强与优雅降级渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进，达到更好的用户体验。优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 Web Worker和Web Socket？web socket：在一个单独的持久连接上提供全双工、双向的通信。使用自定义的协议（ws://、wss://），同源策略对web socket不适用。web worker：运行在后台的JavaScript，不影响页面的性能。创建worker：var worker = new Worker(url);向worker发送数据：worker.postMessage(data);接收worker返回的数据：worker.onmessage终止一个worker的执行：worker.terminate(); JS垃圾回收机制？1) 标记清除：这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。定期的，垃圾回收器将从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象。从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。 2) 引用计数：这是最简单的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。该算法有个限制：无法处理循环引用。两个对象被创建，并互相引用，形成了一个循环。它们被调用之后不会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。 web应用从服务器主动推送data到客户端的方式？JavaScript数据推送：commet（基于http长连接的服务器推送技术）。基于web socket的推送：SSE（server-send Event） 如何删除一个cookie？1） 将cookie的失效时间设置为过去的时间（expires） 12document.cookie = ‘user=’+ encodeURIComponent(‘name’) + &apos;;expires=’+ new Date(0); 2） 将系统时间设置为当前时间往前一点时间 12var data = new Date();date.setDate(date.getDate()-1); attribute与property的区别？attribute是dom元素在文档中作为html标签拥有的属性property是dom元素在js中作为对象拥有的属性。所以，对于html的标准属性来说，attribute和property是同步的，是会自动更新的。但对于自定义属性，他们不同步。 Ajax请求的页面历史记录状态问题？（1）通过location.hash记录状态，让浏览器记录Ajax请求时页面状态的变化。（2）通过HTML5的history.pushstate，来实现浏览器地址栏的无刷新改变。","categories":[{"name":"前端面试题","slug":"前端面试题","permalink":"https://qw8.github.io/categories/前端面试题/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qw8.github.io/tags/JavaScript/"},{"name":"BOM","slug":"BOM","permalink":"https://qw8.github.io/tags/BOM/"},{"name":"字符串","slug":"字符串","permalink":"https://qw8.github.io/tags/字符串/"},{"name":"DOM","slug":"DOM","permalink":"https://qw8.github.io/tags/DOM/"},{"name":"同步异步","slug":"同步异步","permalink":"https://qw8.github.io/tags/同步异步/"}]},{"title":"基于Vue的前端架构","slug":"articles/基于Vue的前端架构","date":"2023-12-16T16:00:00.000Z","updated":"2024-05-09T03:19:43.270Z","comments":true,"path":"/articles/ji-yu-vue-de-qian-duan-jia-gou.html","link":"","permalink":"https://qw8.github.io/articles/ji-yu-vue-de-qian-duan-jia-gou.html","excerpt":"","text":"1.分解需求技术栈 考虑到后续招人和现有人员的技术栈，选择 Vue 作为框架。 公司主要业务是 GIS 和 BIM，通常开发一些中大型的系统，所以 vue-router 和 vuex 都是必不可少的。 放弃了 Element UI 选择了 Ant Design Vue（最近 Element 好像复活了，麻蛋）。 工具库选择 lodash。 建立脚手架 搭建 NPM 私服。 使用 Node 环境开发 CLI 工具，参考我自己写过的一篇 -【 搭建自己的脚手架—“优雅”生成前端工程】。 基于 @vue/cli 搭建基础的模板（大家都比较了解，节省开发时间，远胜于从零开始搭建）。 根据业务需求定义各种开发中可能用到的功能（组件库、状态管理、过滤器、指令、CSS内置变量、CSS Mixins、表单验证、工具函数等）。 性能优化，例如对 Ant Design Vue 组件库的优化。 开发规范 对代码风格、命名规则、目录结构进行统一规范。 静态资源的使用规范。 单元测试、提交线上测试规范。 Git 提交记录和多人协作规范。 2.样式CSS 预处理器的选择 Sass/Scss ✅ Less ✅ Stylus ⭕ 为什么选择了两个？因为公司团队跟倾向于使用 scss 开发，less 是为了覆盖 ant design vue 的样式，stylus 只有我自己喜欢这种风格。 局部样式与全局样式局部样式一般都是使用 scoped 方案： 123&lt;style lang=&quot;scss&quot; scoped&gt; ...&lt;/style&gt; 全局样式全局样式 目录：@/styles variable.scss: 全局变量管理 mixins.scss: 全局 Mixins 管理 global.scss: 全局样式 其中 variable.scss 和 mixins.scss 会优先于 global.css 加载，并且可以不通过 import 的方式在项目中任何位置使用这些变量和 mixins。 12345678910111213// vue.config.jsmodule.exports = &#123; css: &#123; loaderOptions: &#123; sass: &#123; prependData: ` @import '@/styles/variable.scss'; @import '@/styles/mixins.scss'; `, &#125;, &#125;, &#125;,&#125; 体验优化页面载入进度条使用 nprogress 对路由跳转时做一个伪进度条，这样做在网络不好的情况下可以让用户知道页面已经在加载了： 123456789import NProgress from 'nprogress';router.beforeEach(() =&gt; &#123; NProgress.start();&#125;);router.afterEach(() =&gt; &#123; NProgress.done();&#125;); 美化滚动条一直用 Mac 做前端，突然发现同事的 Windows 上出现了十分丑陋的滚动条，为了保持一致： 12345678910111213141516171819202122232425::-webkit-scrollbar &#123; width: 6px; height: 6px;&#125;::-webkit-scrollbar-track &#123; width: 6px; background: rgba(#101F1C, 0.1); -webkit-border-radius: 2em; -moz-border-radius: 2em; border-radius: 2em;&#125;::-webkit-scrollbar-thumb &#123; background-color: rgba(#101F1C, 0.5); background-clip: padding-box; min-height: 28px; -webkit-border-radius: 2em; -moz-border-radius: 2em; border-radius: 2em;&#125;::-webkit-scrollbar-thumb:hover &#123; background-color: rgba(#101F1C, 1);&#125; 静态资源加载页面首次加载页面时，会产生大量的白屏时间，这时做一个 loading 效果看起来会很友好，其实很简单，直接在 public/index.html 里写一些静态的样式即可。 移动端 100vh 问题在移动端使用 100vh 时，发现在 Chrome、Safari 浏览器中，因为浏览器栏和一些导航栏、链接栏导致不一样的呈现： 你以为的 100vh === 视口高度 实际上 100vh === 视口高度 + 浏览器工具栏（地址栏等等）的高度 解决方案安装 vh-check npm install vh-check --save 12import vhCheck from 'vh-check';vhCheck('browser-address-bar'); 定义一个 CSS Mixin 1234s@mixin vh($height: 100vh) &#123; height: $height; height: calc(#&#123;$height&#125; - var(--browser-address-bar, 0px));&#125; 之后就是哪里不会点哪里。 3.组件库因为 Element UI 长期没更新，并且之前使用过 React 的 Ant Design（重点），所以组件库选择了Ant Design Vue。 覆盖 Ant Design Vue 样式设计师眼中的 Ant Design === ‘丑’（心酸）。 1.使用 .less 文件Ant Design Vue 的样式使用了 Less 作为开发语言，并定义了一系列全局/组件的样式变量，所以需要安装了 less、less-loader，在 @/styles/antd-theme.less 可以覆盖默认样式。 优点是： 方便快捷，可以修改 class，覆盖默认变量。 缺点是： 必须引入 @import &#39;~ant-design-vue/dist/antd.less&#39;; ，引入后会将所有的组件样式全部引入，导致打包后的 css 体积达到 500kb 左右。 2.使用 JavaScript 对象通过 JavaScript 对象的方式可以修改内置变量，需要对 Less 进行配置： 123456789101112131415// vue.config.jsconst modifyVars = require('./src/styles/antdTheme.js');module.exports = &#123; css: &#123; loaderOptions: &#123; less: &#123; lessOptions: &#123; javascriptEnabled: true, modifyVars, &#125;, &#125;, &#125;, &#125;,&#125; 这一步还可以继续优化，通过 babel-plugin-import 使 Ant Design Vue 的组件样式可以按需加载： 123456789101112// babel.config.jsmodule.exports = &#123; presets: [ '@vue/cli-plugin-babel/preset', ], plugins: [ [ 'import', &#123; libraryName: 'ant-design-vue', libraryDirectory: 'es', style: true &#125;, ], ],&#125;; 优点是： 可以按需引入，打包后的 CSS 体积取决于你引用了多少个组件。 缺点是： 不能使用 class 进行样式覆盖。 干掉无用的图标Ant Design Vue 把所有的 Icon 一次性引入（不管你因用了多少个组件），这使得体积打包后图标所占的体积竟然有几百 kb 之多。这些图标大多数不会被设计师所采纳，所以部分图标都应该被干掉： 创建一个 icons.js 来管理 Ant Design Vue 图标，这里以一个 Loading 图标为例： 12// @/src/assets/icons.jsexport &#123; default as LoadingOutline &#125; from '@ant-design/icons/lib/outline/LoadingOutline'; 如何知道你要加载的图标在什么路径下？ 在 @ant-design/icons/lib 目录下有三种风格的图标，分别是 fill、outline、twotone，这里面内部的文件并不是 svg 格式，而是 js 和 ts 格式，这就是为什么我们可以这么引入图标的关键所在了。 下一步是通过配置 vue.config.js 将这个文件引入进来： 12345678910// vue.config.jsmodule.exports = &#123; configureWebpack: &#123; resolve: &#123; alias: &#123; '@ant-design/icons/lib/dist$': path.resolve(__dirname, './src/assets/icons.js'), &#125;, &#125;, &#125;,&#125; 解决 Moment 多国语解决到这之后，Ant Design Vue 居然还很大，这是因为 moment 是 Ant Design Vue 中有强依赖该插件，所以使用 webpack 插件减小打包体积，这里我们只保留 zh-cn 语言包： 12345678// vue.config.jsmodule.exports = &#123; chainWebpack: (config) =&gt; &#123; config .plugin('ContextReplacementPlugin') .use(webpack.ContextReplacementPlugin, [/moment[/\\\\]locale$/, /zh-cn/]); &#125;,&#125; 部分组件需要在页面内引用Ant Design Vue 中部分体积较大的组件，例如 DatePicker，根据业务需求，应考虑在页面中进行加载，尽量保证首屏加载的速度： 12345678&lt;script&gt;import &#123; DatePicker &#125; from &apos;ant-design-vue&apos;;export default &#123; components: &#123; ADatePicker: DatePicker, &#125;,&#125;&lt;/script&gt; 4.静态资源与图标静态资源所有的静态资源文件都会上传到 阿里云 OSS 上，所以在环境变量上加以区分。 .env.development 与 .env.production 的 VUE_APP_STATIC_URL 属性分别配置了本地的静态资源服务器地址和线上 OSS 的地址。 本地的静态资源服务器是通过 pm2 + http-server 创建的，设计师切完直接扔进来就好了。 自动注册 Svg 图标在日常的开发中，总是会有着大量的图标需要使用，这里我们直接选择使用 SVG 图标。但是如果每次使用图标还需要通过路径找到这张图标岂不是很麻烦？ 下面这种才是我想要的方案（直接 name 等于 文件名即可）： 123&lt;template&gt; &lt;svg name=&quot;logo&quot; /&gt;&lt;/template&gt; 而且最后打包后需要合并成一张雪碧图。 首先需要对 @/assets/icons 文件夹下的 svg 图标进行自动注册，需要对 webpack 和 svg-sprite-loader 进行了相关设置，文件全部打包成 svg-sprite。 12345678910111213141516module.exports = &#123; chainWebpack: (config) =&gt; &#123; config.module .rule('svg') .exclude.add(resolve('src/assets/icons')) .end(); config.module .rule('icons') .test(/\\.svg$/) .include.add(resolve('src/assets/icons')) .end() .use('svg-sprite-loader') .loader('svg-sprite-loader'); &#125;,&#125; 写一个全局用的 Vue 组件 ``: // @/components/m-svg/index.js 123const requireAll = (requireContext) =&gt; requireContext.keys().map(requireContext);const req = require.context('@/assets/icons', false, /\\.svg$/);requireAll(req); @/components/m-svg/index.vue 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;svg class=&quot;mw-svg&quot; aria-hidden=&quot;true&quot;&gt; &lt;use :xlink:href=&quot;iconName&quot;&gt;&lt;/use&gt; &lt;/svg&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;m-svg&apos;, props: &#123; name: &#123; type: String, default: &apos;&apos; &#125;, &#125;, computed: &#123; iconName() &#123; return `#$&#123;this.name&#125;`; &#125;, &#125;,&#125;;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.mw-svg &#123; width: 1.4em; height: 1.4em; fill: currentColor; overflow: hidden; line-height: 1em; display: inline-block;&#125;&lt;/style&gt; 参数 name 类型：String 默认值：null 说明：放置在 @/assets/icons 文件夹下的文件名 样式 图标的大小可以通过 width + height 属性改变。 通过改变 font-size 属性改变，宽高 = font-zise * 1.4 5.异步请求封装 Axios在 @/libs/request.js 路径下对 Axios 进行封装，封装了请求参数，请求头，以及错误提示信息、 request 拦截器、response 拦截器、统一的错误处理、baseURL 设置等。 废话不说直接贴代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import axios from 'axios';import get from 'lodash/get';import storage from 'store';// 创建 axios 实例const request = axios.create(&#123; // API 请求的默认前缀 baseURL: process.env.VUE_APP_BASE_URL, timeout: 10000, // 请求超时时间&#125;);// 异常拦截处理器const errorHandler = (error) =&gt; &#123; const status = get(error, 'response.status'); switch (status) &#123; /* eslint-disable no-param-reassign */ case 400: error.message = '请求错误'; break; case 401: error.message = '未授权，请登录'; break; case 403: error.message = '拒绝访问'; break; case 404: error.message = `请求地址出错: $&#123;error.response.config.url&#125;`; break; case 408: error.message = '请求超时'; break; case 500: error.message = '服务器内部错误'; break; case 501: error.message = '服务未实现'; break; case 502: error.message = '网关错误'; break; case 503: error.message = '服务不可用'; break; case 504: error.message = '网关超时'; break; case 505: error.message = 'HTTP版本不受支持'; break; default: break; /* eslint-disabled */ &#125; return Promise.reject(error);&#125;;// request interceptorrequest.interceptors.request.use((config) =&gt; &#123; // 如果 token 存在 // 让每个请求携带自定义 token 请根据实际情况自行修改 // eslint-disable-next-line no-param-reassign config.headers.Authorization = `bearer $&#123;storage.get('ACCESS_TOKEN')&#125;`; return config;&#125;, errorHandler);// response interceptorrequest.interceptors.response.use((response) =&gt; &#123; const dataAxios = response.data; // 这个状态码是和后端约定的 const &#123; code &#125; = dataAxios; // 根据 code 进行判断 if (code === undefined) &#123; // 如果没有 code 代表这不是项目后端开发的接口 return dataAxios; // eslint-disable-next-line no-else-return &#125; else &#123; // 有 code 代表这是一个后端接口 可以进行进一步的判断 switch (code) &#123; case 200: // [ 示例 ] code === 200 代表没有错误 return dataAxios.data; case 'xxx': // [ 示例 ] 其它和后台约定的 code return 'xxx'; default: // 不是正确的 code return '不是正确的code'; &#125; &#125;&#125;, errorHandler);export default request; 通过 VUE_APP_BASE_URL 区分线上与开发环境的 API 地址。 code 起到一个比较关键的作用，例如 token 过期时的验证。 使用了一个叫 sotre 的包作为本地储存的工具用来存储 token。 跨域问题跨域问题一般情况直接找后端解决了，你要是不好意思打扰他们的话，可以用 devServer 提供的 proxy 代理： 12345678910111213// vue.config.jsdevServer: &#123; proxy: &#123; '/api': &#123; target: 'http://47.100.186.132/your-path/api', ws: true, changeOrigin: true, pathRewrite: &#123; '^/api': '' &#125; &#125; &#125;&#125; Mock 数据一个很常见的情况，后端接口没出来，前端在这干瞪眼。 Mock 数据功能是基于 mock.js (opens new window)开发，通过 webpack 进行自动加载 mock 配置文件。 规则 所有的 mock 配置文件均应放置在 @/mock/services 路径内。 在 @/mock/services 内部可以建立业务相关的文件夹分类存放配置文件。 所有的配置文件应按照 ***.mock.js 的命名规范创建。 配置文件使用 ES6 Module 导出 export default 或 export 一个数组。 入口文件12345678910111213import Mock from 'mockjs';Mock.setup(&#123; timeout: '500-800',&#125;);const context = require.context('./services', true, /\\.mock.js$/);context.keys().forEach((key) =&gt; &#123; Object.keys(context(key)).forEach((paramKey) =&gt; &#123; Mock.mock(...context(key)[paramKey]); &#125;);&#125;); 示例模板1234567891011121314151617181920212223242526272829import Mock from 'mockjs';const &#123; Random &#125; = Mock;export default [ RegExp('/example.*'), 'get', &#123; 'range|50-100': 50, 'data|10': [ &#123; // 唯一 ID id: '@guid()', // 生成一个中文名字 cname: '@cname()', // 生成一个 url url: '@url()', // 生成一个地址 county: Mock.mock('@county(true)'), // 从数组中随机选择一个值 'array|1': ['A', 'B', 'C', 'D', 'E'], // 随机生成一个时间 time: '@datetime()', // 生成一张图片 image: Random.dataImage('200x100', 'Mock Image'), &#125;, ], &#125;,]; 6.路由Layout布局暂时分为三大类： frameIn：基于 BasicLayout，通常需要登录或权限认证的路由。 frameOut：不需要动态判断权限的路由，如登录页或通用页面。 errorPage：例如404。 权限验证通过获取当前用户的权限去比对路由表，生成当前用户具的权限可访问的路由表，通过 router.addRoutes 动态挂载到 router 上。 判断页面是否需要登陆状态，需要则跳转到 /user/login 本地存储中不存在 token 则跳转到 /user/login 如果存在 token，用户信息不存在，自动调用 vuex ‘/system/user/getInfo’ 在路由中，集成了权限验证的功能，需要为页面增加权限时，在 meta 下添加相应的 key： auth 类型：Boolean 说明：当 auth 为 true 时，此页面需要进行登陆权限验证，只针对 frameIn 路由有效。 permissions 类型：Object 说明：permissions 每一个 key 对应权限功能的验证，当 key 的值为 true 时，代表具有权限，若 key 为 false，配合 v-permission 指令，可以隐藏相应的 DOM。 在这里贴一下路由跳转时权限验证的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import router from '@/router';import store from '@/store';import storage from 'store';import util from '@/libs/utils';// 进度条import NProgress from 'nprogress';import 'nprogress/nprogress.css';const loginRoutePath = '/user/login';const defaultRoutePath = '/home';/** * 路由拦截 * 权限验证 */router.beforeEach(async (to, from, next) =&gt; &#123; // 进度条 NProgress.start(); // 验证当前路由所有的匹配中是否需要有登录验证的 if (to.matched.some((r) =&gt; r.meta.auth)) &#123; // 是否存有token作为验证是否登录的条件 const token = storage.get('ACCESS_TOKEN'); if (token &amp;&amp; token !== 'undefined') &#123; // 是否处于登录页面 if (to.path === loginRoutePath) &#123; next(&#123; path: defaultRoutePath &#125;); // 查询是否储存用户信息 &#125; else if (Object.keys(store.state.system.user.info).length === 0) &#123; store.dispatch('system/user/getInfo').then(() =&gt; &#123; next(); &#125;); &#125; else &#123; next(); &#125; &#125; else &#123; // 没有登录的时候跳转到登录界面 // 携带上登陆成功之后需要跳转的页面完整路径 next(&#123; name: 'Login', query: &#123; redirect: to.fullPath, &#125;, &#125;); NProgress.done(); &#125; &#125; else &#123; // 不需要身份校验 直接通过 next(); &#125;&#125;);router.afterEach((to) =&gt; &#123; // 进度条 NProgress.done(); util.title(to.meta.title);&#125;); 页面开发 根据业务需要划分，按照路由层级在 views 中创建相对应的页面组件，以文件夹的形式创建，并在文件夹内创建 index.vue 文件作为页面的入口文件。 页面内的组件：在页面文件夹下创建 components 文件夹，在其内部对应创建相应的组件文件，如果是复杂组件，应以文件夹的形式创建组件。 工具模块：能够高度抽象的工具模块，应创建在 @/src/libs 内创建 js 文件。 7、构建优化包分析工具构建代码之后，到底是什么占用了这么多空间？靠直觉猜测或者使用 webpack-bundle-analyzer。 1234567891011const WebpackBundleAnalyzer = require('webpack-bundle-analyzer');module.exports = &#123; chainWebpack: (config) =&gt; &#123; if (process.env.use_analyzer) &#123; config .plugin('webpack-bundle-analyzer') .use(WebpackBundleAnalyzer.BundleAnalyzerPlugin); &#125; &#125;,&#125;; 开启 Gzip对，这这么一句话，后端就得支持你的 .gz 文件了，而你只需要坐着等老板夸： 12345chainWebpack: (config) =&gt; &#123; config .plugin('CompressionPlugin') .use(CompressionPlugin, []);&#125;, 路由懒加载这块 @vue/cli 已经帮忙处理好了，但也需要了解一下他的原理和如何配置。 1234567&#123; path: 'home', name: 'Home', component: () =&gt; import( /* webpackChunkName: \"home\" */ '@/views/home/index.vue' ),&#125;, webpackChunkName 这条注释还是很有必要加的，至少你打包后知道又是哪个页面变得又臭又大。 Preload &amp; Prefetch不清楚这两个功能的去 @vue/cli 补课，这两个功能非常有助于你处理加载的性能。 8.测试框架直接使用了官方提供的 Vue Test Utils，这东西可以对组件进行测试，很不错。 写单元测试在团队里其实很难推进，不知道大家怎么看。 9.组件库对于很多第三方的工具，我坚持认为二次封装成 vue 插件并没有多少开发成本，反而让你在后续的开发中变得很灵活。 我对以下库进行了 vue 插件的封装，并提交到 npm 私服： 数字动画 代码高亮 大文件上传（切片、断点续传、秒传）需要与后端配合 图片预览 Excel 导入导出 富文本编辑器 Markdown 编辑器 代码编辑器 大文件上传有兴趣的可以留言，我后续单独拎出来详细的写一下这块。 10.Vuex内置一些功能，主要是对以下这些功能做了一些封装： 用户信息管理（储存信息、对 token 进行操作等） 登陆（调接口） 菜单管理（储存路由信息，生成菜单，模糊查询等功能） UA信息 全屏操作 Loading 日志管理（消息提醒、日志留存、日志上报） 11.过滤器过滤器是 Vue 提供的一个很好用的功能，听说 vue3 没了？ 1&#123;&#123; message | capitalize &#125;&#125; 我写了几个常用的过滤器： 日期时间 剩余时间 区分环境的链接（主要针对本地静态资源服务器和 OSS ） 文件大小 数字金额 浮点型精度 12.指令自定义指令可以提供很好的帮助： 组件权限验证 文本复制 快捷键绑定 滚动至指定位置 图片懒加载 焦点 13.开发规范ESLint不管是多人合作还是个人项目，代码规范都是很重要的。这样做不仅可以很大程度地避免基本语法错误，也保证了代码的可读性。 这里我们采用了 Airbnb JavaScript Style Guide。 这套规范给我的感觉就是 很严谨！ CSS 规范降低选择器复杂性浏览器读取选择器，遵循的原则是从选择器的右边到左边读取。 123#block .text p &#123; color: red;&#125; 查找所有 P 元素。 查找结果 1 中的元素是否有类名为 text 的父元素 查找结果 2 中的元素是否有 id 为 block 的父元素 选择器优先级 内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器 选择器越短越好。 尽量使用高优先级的选择器，例如 ID 和类选择器。 避免使用通配符 *。 使用 flexbox在早期的 CSS 布局方式中我们能对元素实行绝对定位、相对定位或浮动定位。而现在，我们有了新的布局方式 flexbox，它比起早期的布局方式来说有个优势，那就是性能比较好。不过 flexbox 兼容性还是有点问题，不是所有浏览器都支持它，所以要谨慎使用。 各浏览器兼容性： Chrome 29+ Firefox 28+ Internet Explorer 11 Opera 17+ Safari 6.1+ (prefixed with -webkit-) Android 4.4+ iOS 7.1+ (prefixed with -webkit-) 动画性能优化在 CSS 中，transforms 和 opacity 这两个属性更改不会触发重排与重绘，它们是可以由合成器（composite）单独处理的属性。 属性值 当数值为 0 - 1 之间的小数时，建议省略整数部分的 0。 当长度为 0 时建议省略单位。 建议不使用命名色值。 建议当元素需要撑起高度以包含内部的浮动元素时，通过对伪类设置 clear 或触发 BFC 的方式进行 clearfix。尽量不使用增加空标签的方式。 除公共样式之外，在业务代码中尽量不能使用 !important。 建议将 z-index 进行分层，对文档流外绝对定位元素的视觉层级关系进行管理。 字体排版 字号应不小于 12px（PC端）。 font-weight 属性建议使用数值方式描述。 line-height 在定义文本段落时，应使用数值。 Vue 代码规范常规 当在组件中使用 data 属性的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数 data() { return {...} }。 prop 的定义应该尽量详细，至少需要指定其类型。 布尔类型的 attribute， 为 true 时直接写属性值。 不要在computed中对vue变量进行操作。 应该优先通过 prop 和事件进行父子组件之间的通信，而不是 this.$parent 或改变 prop。 在组件上总是必须用 key 配合 v-for，以便维护内部组件及其子树的状态。 v-if 和 v-for 不能同时使用 公共方法尽量不要挂到原型上, 可以写在 utils 文件，也可以使用 mixin 文件。不要将业务公共组件注册到全局。 不要将任何第三方插件挂载到 vue 原型上。 具有高度通用性的方法，要封装到 libs、全局组件或指令集里。 为组件样式设置作用域。 尽量使用指令缩写。 vuexState (opens new window)为单一状态树，在 state 中需要定义我们所需要管理的数组、对象、字符串等等，只有在这里定义了，在 vue 的组件中才能获取你定义的这个对象的状态。 修改 state 中数据必须通过 mutations。 每一个可能发生改变的 state 必须同步创建一条或多条用来改变它的 mutations。 服务端获取的数据存放在 state 中，作为原始数据保留，不可变动。 Getters (opens new window)有点类似 vue.js 的计算属性，当我们需要从 store 的 state 中派生出一些状态，那么我们就需要使用 getters，getters 会接收 state 作为第一个参数，而且 getters 的返回值会根据它的依赖被缓存起来，只有 getters 中的依赖值（state 中的某个需要派生状态的值）发生改变的时候才会被重新计算。 通过 getters 处理你需要得到的数据格式，而不是通过修改 state 原始数据。 组件内不强制使用 mapGetters，因为你可能需要使用 getter 和 setter。 改变 state 的唯一方法就是提交 mutations (opens new window)。 组件内使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用。 命名采用 大写字母 + 下划线 的规则。 定义 CLEAR，以确保路由切换时可以初始化数据。 Actions 页面重的数据接口尽量在 actions (opens new window)中调用。 服务端返回的数据尽量不作处理，保留原始数据。 获取到的数据必须通过调用 mutations 改变 state。 Modules 通常情况下按照页面划分 modules (opens new window)。 默认内置了 system 保证了脚手架的基础功能。 每个页面模块或页面的子模块添加属性 namespaced: true。 14.完成详细的使用文档不论是功能还是组件库等等的工具，都需要完善的文档提供查阅，即使是轮子的构建者，也抵不住时间长了会忘记许多细节。 这里我使用 vuepress 构建文档，方便快捷。 参考【拯救懒癌文档君 - VuePress + Travis CI + Github Pages 自动线上生成文档】 15.Git 多人协作流程公司使用内部搭建的 GitLab 托管代码 Root 仓库项目启动时，由项目管理者搭建起最原始的仓库，称为 Root 仓库（源仓库）。 源仓库的有个作用 : 汇总参与该项目的各个开发者的代码。 存放趋于稳定和可发布的代码。 向 Master 分支提交 Merge Requests 可以触发测试环境构建（CI/CD）。 源仓库是受保护的，开发者不可直接对其进行开发工作。 开发者仓库任何开发者都没有权限对 Root 仓库进行直接的操作，源仓库建立以后，每个开发者需要做的事情就是把源仓库的 Fork 一份，作为自己日常开发的仓库。 每个开发者所Fork的仓库是完全独立的，互不干扰。 每个开发者提交到代码到自己的仓库中，开发工作完成以后，开发者可以向源仓库发送 Pull Request ，本地仓库先合并源仓库，解决冲突。 发起 Merge Request 请求管理员把自己的代码合并到源仓库中的 master 或 其他分支。 Git 流程 img 前端项目会在 Root 仓库下创建 dev 分支，用于代码的拉取和合并，如果有多个不同的测试环境，按照测试环境创建分支。 在本地的仓库中创建你的 dev 分支和其他功能性的分支。 开发过程中不允许直接在 master 分支上开发，创建一个新的分支进行开发，git checkout –b {branch_name}。 规范且详细的书写 commit ，推荐使用 git-cz 工具进行提交。 完成开发后将相应的分支合并到自己仓库的 master 分支。 将 master 分支 push 到自己的远程仓库（Fork仓库）。 向 Root 仓库 dev 分支提交 Merge Requests。 提醒前端负责人审查代码、解决冲突或测试环境上线。 解决冲突后 git pull upstream dev 拉取解决后的最新代码。 原文链接：https://juejin.cn/post/6901466994478940168","categories":[{"name":"前端文章","slug":"前端文章","permalink":"https://qw8.github.io/categories/前端文章/"}],"tags":[{"name":"前端架构","slug":"前端架构","permalink":"https://qw8.github.io/tags/前端架构/"}]},{"title":"前端权限开发","slug":"articles/前端权限开发","date":"2023-12-15T16:00:00.000Z","updated":"2024-05-10T09:29:21.379Z","comments":true,"path":"/articles/qian-duan-quan-xian-kai-fa.html","link":"","permalink":"https://qw8.github.io/articles/qian-duan-quan-xian-kai-fa.html","excerpt":"","text":"前端权限开发——设计到实践（保姆级）1.权限控制的方案选择。做后台项目区别于做其它的项目，权限验证与安全性是非常重要的，可以说是一个后台项目一开始就必须考虑和搭建的基础核心功能。在后台管理系统中，实现权限控制可以采用多种方案： 权限方案类型 描述 基于角色的访问控制（Role-Based Access Control，RBAC） 是一种广泛采用的权限控制方案。系统中定义了不同的角色，每个角色具有一组权限，而用户被分配到一个或多个角色。通过控制用户角色的分配，可以实现对用户访问系统中不同功能和资源的权限控制。 基于权限的访问控制（Permission-Based Access Control） 这种方案将权限直接分配给用户，而不是通过角色来管理。每个用户都有自己的权限列表，控制用户对系统中各项功能和资源的访问。 基于资源的访问控制（Resource-Based Access Control，RBAC） 这种方案将权限控制与资源本身关联起来。系统中的每个资源都有自己的访问权限，用户通过被授予资源的访问权限来控制其对资源的操作。 层次结构权限控制（Hierarchical Access Control） 这种方案基于资源和操作的层次结构来进行权限控制。系统中的资源和操作被组织成层次结构，用户被授予访问某个层次及其子层次的权限。 基于规则的访问控制（Rule-Based Access Control） 这种方案使用预定义的规则来确定用户对系统中功能和资源的访问权限。规则可以基于用户属性、环境条件或其他因素进行定义。 这里我选择了基于角色的访问控制（Role-Based Access Control，RBAC） 这是因为RBAC提供了一种灵活且易于管理的方式来控制用户对系统功能和资源的访问，也是目前最主流的前端权限方案选择。 在RBAC中，系统中的功能和资源被组织成角色，而用户则被分配到不同的角色。每个角色都有一组权限，定义了该角色可以执行的操作和访问的资源。通过给用户分配适当的角色，可以实现对用户的权限控制。 RBAC的好处之一是它简化了权限管理的复杂性。管理员只需管理角色和分配角色给用户，而不需要为每个用户单独定义权限。当需要对用户的权限进行修改时，只需调整其角色的权限即可。 此外，RBAC还支持灵活的权限组合，允许创建具有不同权限组合的角色，以适应不同用户的需求。它也便于扩展，可以随着系统的发展和需求的变化而调整和添加角色。 2.RBAC下的权限字段设计与管理模型1.用户权限授权是对用户身份认证的细化。可简单理解为访问控制，在用户身份认证通过后，系统对用户访问菜单或按钮进行控制。也就是说，该用户有身份进入系统了，但他不一定能访问系统里的所有菜单或按钮，而他只能访问管理员给他分配的权限菜单或按钮。 主要包括： Permission（权限标识、权限字符串）：针对系统访问资源的权限标识，如：用户添加、用户修改、用户删除。 Role （角色）：可以理解为权限组，也就是说角色下可以访问和点击哪些菜单、访问哪些权限标识。 权限标识或权限字符串校验规则： 权限字符串：指定权限串必须和菜单中的权限标识匹配才可访问 权限字符串命名规范为：模块:功能:操作，例如：sys:user:edit 使用冒号分隔，对授权资源进行分类，如 sys:user:edit 代表 系统模块:用户功能:编辑操作 设定的功能指定的权限字符串与当前用户的权限字符串进行匹配，若匹配成功说明当前用户有该功能权限 还可以使用简单的通配符，如 sys:user:*，建议省略为 sys:user（分离前端不能使用星号写法） 举例1 sys:user 将于 sys:user 或 sys:user: 开头的所有权限字符串匹配成功 举例2 sys 将于 sys 或 sys: 开头的所有权限字符串匹配成功 这种命名格式的好处有： 可读性和可理解性：使用模块、功能和操作的格式可以直观地表达权限的含义。每个部分都有明确的作用，模块表示特定的模块或子系统，功能表示模块内的某个功能或页面，操作表示对功能进行的具体操作。通过这种格式，权限名称可以更容易地被开发人员、管理员和其他人员理解和解释。 可扩展性和灵活性： 通过使用模块、功能和操作的格式，可以轻松地扩展和管理权限。每个模块、功能和操作都可以被单独定义和控制。当系统需要增加新的功能或操作时，可以根据需要添加新的权限字符串，而不需要修改现有的权限规则和代码。 细粒度的权限控制： 这种格式支持细粒度的权限控制，可以针对特定的功能和操作进行权限管理。通过将权限名称拆分为模块、功能和操作，可以精确地定义哪些用户或角色具有访问或操作特定功能的权限。 避免权限冲突： 使用模块、功能和操作的格式可以避免权限之间的冲突。不同模块、功能和操作的权限名称是唯一的，这样可以避免同名权限之间的混淆和冲突。 2.权限管理模型关键数据模型如下： 用户：登录账号、密码、角色 角色：角色名称、角色权限字符、对应菜单、对应菜单下的权限 菜单：菜单名称、菜单URL、菜单类型 用户角色关系：用户编码、角色编码 角色菜单关系：角色编码、菜单编码 关系图如下： 1【用户】 &lt;---多对多---&gt; 【角色】 &lt;---多对多---&gt; 【菜单/权限】 3.实现思路与步骤前端权限一般分为路由级权限和按钮级权限，这里我们先实现页面路由级的权限功能，按钮级的会在后面讲到。大致的思路如下图： 飞书20230324-135033.png 上图是用户从`登录-->路由守卫-->权限验证-->构建路由表-->跳转目标页面`的一个简单的正向流程，可以看到，`权限验证`和`构建路由表`这两步是发生在`路由守卫`这一步里，而实际上在开发设计阶段，我们还要做的准备有： 与后端确认权限字段及类型 确定路由表信息是由前端还是后端生成 为了方便理解，我们就按照这个正向流程来逐步实现，期间需要用到或者提前考虑设计到的内容，包括以上需要准备的两点，我会补充在步骤当中。 1.登录登录成功后，获取到token,将token存到本地的sessionStorage里。 12345678910// action.jsasync login(&#123; commit &#125;, userInfo) &#123; const &#123; data &#125; = await login(userInfo) const accessToken = &apos;Bearer &apos; + data.access_token if (accessToken) &#123; sessionStorage.getItem(tokenTableName) &#125; else &#123; message.error(`登录接口异常，未正确返回$&#123;tokenName&#125;...`) &#125; &#125; 接着，进行路由跳转到首页 1234// login.vueimport &#123; useRouter &#125; from &apos;vue-router&apos;;const router = useRouter(); router.push(&apos;/&apos;); 如果考虑到页面token失效后，重新登陆后返回原先的路由地址，则需要在路由守卫中添加redirect字段用来存储当前的路由地址 12// permissions.jsnext(&#123; path: &apos;/login&apos;, query: &#123; redirect: to.fullPath &#125;, replace: true &#125;) 然后在登录页中，监听路由对象中的这个值，如果有值，那么在刚刚路由跳转时，就跳转到该路由地址，而非/首页，另外，还需要考虑到403，404页面。所以，添加了这些逻辑后，部分代码如下： 1234567891011121314151617181920212223242526272829303132// login.vue&lt;script setup&gt;import &#123; ref, watch, useRouter &#125; from 'vue';import &#123; useRouter &#125; from 'vue-router';const redirect = ref('/');const router = useRouter();watch( () =&gt; router.currentRoute.value.query.redirect, (redirectValue) =&gt; &#123; redirect.value = redirectValue || '/'; &#125;, &#123; immediate: true &#125;);function handleRoute() &#123; return redirect.value === '/404' || redirect.value === '/403' ? '/' : redirect.value &#125;, async handleSubmit() &#123; loading.value = true try &#123; await login(form.value) loading.value = false router.push(handleRoute()); &#125; catch &#123; loading.value = false &#125; &#125;, &lt;/script&gt; 2.路由守卫与权限校验当进行路由跳转时，会进入到路由守卫中，在路由守卫中： 路由守卫会首先判断有没有token，如果没有，先判断要去的路由地址是否包含在路由白名单内，如果要去的路由地址也不在路由白名单内，就会让用户跳转到登录页重新登陆。 如果有token，会先判断跳转的目标地址是否是登录页，如果是，则重新跳转到默认首页 此时，我们就需要对用户权限进行校验，首先，判断当前用户是否拥有角色信息,如果没有，就要获取用户的角色信息。 3.获取角色信息与权限信息调取用户信息接口获取用户角色信息和权限信息,代码如下： 123456789101112131415161718192021222324252627//store/user // 获取用户信息 GetInfo(&#123; commit, dispatch &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; getUserInfo() .then(async (response) =&gt; &#123; const result = response.data if (result.roles &amp;&amp; result.roles.length &gt; 0) &#123; // 验证返回的roles是否是一个非空数组 commit('SET_ROLES', result.roles) //permissions就是对应的用户权限信息 commit('SET_PERMISSION', result.permissions) &#125; else &#123; // 如果当前用户没有角色，则赋值一个默认角色 commit('SET_ROLES', ['ROLE_DEFAULT']) &#125; resolve(result) // GetInfo一旦失败就说明这个token不是过期就是丢失了,直接走catch并让调用方跳转路由 if (!response.success) &#123; reject(response.errorMsg) &#125; &#125;) .catch((error) =&gt; &#123; reject(error) &#125;) &#125;) &#125;, 根据之前上文提到的权限管理模型，从之间的关系是多对多，因此，role(角色）和permssions(权限）的类型应为数组，其中的权限permssion这个字段的格式规范也在上文提及。在与后端约定好后，后端返回的信息如图： image.png image.png 4.谁来生成动态路由表？在成功获取到用户信息，拿到用户角色和对应权限后，此时，就需要根据权限生成对应的路由表了，到这里，我们需要思考一个问题： 路由表是由后端提供还是由前端提供？ A:前端根据权限生成路由表 B:后端生成路由表给前端 没错！答案是C：路由表可以由后端提供或由前端提供。 9b7ce6e5503212cdd80bfe8bc78040b9.jpg 两者的优劣分别是： 后端提供路由表： 优点： 安全性高：后端负责验证和控制权限，可以确保只有授权的用户能够访问特定的路由和功能。 隐藏敏感信息：后端可以根据用户的角色和权限隐藏不应该被访问的敏感路由和数据。 适用于复杂的权限规则：后端可以使用更复杂的逻辑和规则来处理权限控制，例如基于用户角色、用户组、权限等的复杂控制逻辑。 缺点： 前后端耦合度高：由于路由表由后端提供，前端开发人员可能需要与后端开发人员密切协作，增加了协调和沟通的成本。 前端依赖后端：前端应用程序可能需要等待后端提供路由表后才能进行开发和测试，增加了开发的时间和依赖性。 前端提供路由表： 优点： 前后端解耦：前端可以独立开发和维护路由表，减少了与后端的依赖性和协调成本。 更好的用户体验：前端可以根据用户的角色和权限动态展示路由和功能，提供更灵活和个性化的用户体验。 缺点： 安全性较低：前端提供的路由表容易受到篡改和绕过，安全性相对较低。 隐藏敏感信息的难度增加：前端无法直接隐藏敏感路由和数据，需要依赖后端接口的授权验证来保护敏感信息。 最终，考虑到后台管理系统的安全性优先级最高，我选择了由后端存储，并生成返回路由表信息。 确定好了之后，你就会遇到一个坑：后端提供的路由表无法直接在前端路由中添加使用 这是因为，后端存储的路由表的结构只一个JSON对象。怎么解决，我们放到后面讲。 5.公共路由和动态路由我们现在把整个路由分为两个部分，分别是公共路由和动态路由（私有路由）。 公共路由公共路由顾名思义就是无论当前用户是什么角色，都会出现的路由部分。一般这样的路由分别有：首页驾驶舱、登录注册页、403页、404页。 这部分路由是在前端项目中提前写死的。 以我的项目为例，我在src/config下创建一个publicRouter.js文件，然后里面放入基础路由信息： 12345678910111213141516171819202122232425262728//基础公共路由export const constantRouterMap = [&#123; path: '/', name: '', component: () =&gt; import('@/layout'), redirect: '/homePage', children: [ &#123; path: '/homePage', name: 'homePage', component: () =&gt; import('@/views/homePage/index.vue'), &#125;, ],&#125;,&#123; path: '/login', component: () =&gt; import('@/views/login'),&#125;,&#123; path: '/403', name: '403', component: () =&gt; import('@/views/403'),&#125;,&#123; path: '/:pathMatch(.*)*', component: () =&gt; import('@/views/404'),&#125;] 这里面都是路由懒加载的写法，这个没啥好说的。需要注意的是在vue3中，vue-router的版本是4.x以上，在跳转404页面时，如果你的写法是 12345&#123; path: \"/404\", name: \"notFound\", component: () =&gt; import('@/views/404')&#125; 这样写会提示报错，这是因为vue-router4.x的版本官方推荐引入了这种新写法，配置一个通配符路由，匹配所有未被其他具体路由匹配的路径。其中 :pathMatch 是参数名，而 (.*)* 是参数的匹配模式，它使用正则表达式来匹配任意路径。 动态路由(私有路由）上文提到的后端返回给前端当前用户的路由表信息，其实就是私有路由，这部分的路由是动态的。那么我们只需要把公共路由+动态路由=当前角色用户完整路由表。然鹅，后端返回给前端的动态路由是无法直接添加到当前页面路由中的，这是因为在浏览器的前后端请求当中，信息的返回体都是以JSON字符串的数据交换格式进行传输，而JSON字符串是不支持函数的。为什么要提到函数形式呢？ 因为当我们在路由表使用懒加载的写法时，component的值是一个异步函数。也只有异步函数才能实现对路由的异步懒加载。import（）会返回一个promise，这个 promise 最终会加载对应的组件模块。在格式上表现为一个func函数，因此，我们无法将compnent的值传给后端存储 但是办法总比困难多，我们可以将对应的路径字符串传给后端存储，然后再通过后端返回的路径字符串转换成这种箭头函数的写法。 除了这个需要转换以外，我们还要考虑一些问题： 比如，转换后的路由结构要符合router中的路由格式，否则会在调用router.addRoutes时报错，添加失败。 添加一些其他自定义属性（例如添加导航栏菜单图标、某个路由的显隐、路由缓存、跳转外链接、…），以满足特定需求。 以我项目中的的路由示例，直接上代码看： 1234567891011121314151617181920212223242526272829&#123; \"path\": \"/\", //path,路由的路径，即访问该路由时的 URL 路径。 \"name\": \"homePage\",//name,路由的名称，用于在代码中标识路由。通常用于编程式导航。 \"hidden\": false,//hidden,是否隐藏路由，在Vue Router 4.0 中被废弃。 \"component\": \"Layout\"//路由对应的组件，可以是通过懒加载方式导入的异步组件，或直接引入的同步组件。 \"meta\": &#123;//meta,路由元信息，可以用于存储一些额外的信息，比如页面标题、权限等 \"title\": \"首页\", //路由标题 \"icon\": \"icon-Home\", //路由图标 \"target\": \"\", //是否跳转新页签 \"permission\": \"homePage\",//权限 \"keepAlive\": false//是否缓存 &#125;, \"redirect\": \"/homePage\",//重定向 \"fullPath\": \"/\",//完整的url路径，会带上？后面的参数 \"children\": [//子路由 &#123; \"path\": \"/homePage\", \"name\": \"homePage\", \"meta\": &#123; \"title\": \"首页\", \"icon\": \"\", \"target\": \"\", \"permission\": \"homePage\", \"keepAlive\": false &#125;, \"fullPath\": \"/homePage\" &#125; ]&#125; 考虑完这些之后，我们就开始拿着后端返回的路由表信息动手转换吧！ 先看看后端返回给前端的路由表格式内容 image.png image.png image.png 这里你只需要注意component这个字段的值就行了。 可能有人会问：“那我给后端传的路由表是什么格式的，也是这样吗？” 答案是：当然不是！RBAC权限方案中，用户可以自己配置权限，也就是会有对应的用户管理，角色管理，菜单（权限）管理这三个基本的模块，给后端传的是对应模块的修改配置内容。前端是不需要关心传给后端什么格式。 有点啰嗦了，总之，就是你指着上文这三张图片，让后端给你生成出来就完事了。后端要是说办不到，那就是后端的问题。 297708da4a493456bfcab94617c1ac55.jpg 6.RBAC的权限配置项上文提到了三个基本的配置模块，分别是用户管理，角色管理，菜单（权限）管理,按照先后顺序，我们首先要新建一个权限，在页面级的权限中，权限是跟每个页面路由一一对应的，所以当我们需要新建一个权限的时候，也就是在新建一个页面路由。而为了方便知道所有页面权限之间的层级关系，最终的展现形式就是一个树形表格结构： image.png 可以看到，在页面路由（权限）配置项里，单个路由的各个都可以进行修改配置，这就让整个项目的路由表的可维护性和灵活度都极大的提高。需要注意的是路由地址和组件路径这两个配置项，路由地址可以随意命名，但是同层级下，必须唯一。 而组件路径里面的值就是相对src目录的相对路径。比如我新建一个部门管理页面权限，一般在前端路由中的懒加载写法是这样： 1component: () =&gt; import('@/views/login'), 但在这个配置项中，只需要填入login这个字段就行了。原因是因为前面的这些字段会在后面对路由的格式化中进行处理。虽然后续步骤会讲到这一步，但这里我还是先贴出来，方便你理解： 123456component: constantRouterComponents[item.component || item.key] || (() =&gt; import(`@/views/$&#123;item.component&#125;`).catch(() =&gt; import('@/views/404') )), 那有人就会问，如果我乱填一个不存在的组件路径地址怎么办？正常情况下这样会导致整个动态路由在构建过程中报错，从而导致白屏。所以，上述代码里的.catch会捕获这个错误，然后跳转到404页面，再从404页面跳转到首页。就像这样： image.png 当我们配置好权限后，会将新增的路由配置信息发送给后端，**后端根据这些配置信息，会在对应的路由表中添加这个路由，并生成新的路由表返回给前端**。 那当我们有一个权限之后，该怎么配置给对应的用户呢？还记得我上文提及的RBAC的权限管理模型嘛： image.png 就是按照关系图中，我们将权限分配给角色，所以，就要有角色管理这个模块来进行分配： image.png 用户管理也是依葫芦画瓢，跟角色管理如出一辙，碍于篇幅，就不再过多赘述。每一个配置项都可以根据你的业务场景和需要，进行增减。 7.获取动态路由（私有路由）并转换言归正传，接下来，这一步是整个前端权限中最重要的一步。在src/router下，我们新建一个generatorRouters.js文件。里面的内容是： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117//getCurrentUserNav获取动态路由的接口import &#123; getCurrentUserNav &#125; from '@/api/user'//validURL是一个正则判断方法，用来校验当前字符串是否符合url外链格式import &#123; validURL &#125; from '@/utils/validate'// 前端路由表const constantRouterComponents = &#123; // 基础页面 layout 必须引入 Layout: () =&gt; import('@/layout'), 403: () =&gt; import('@/views/403'), 404: () =&gt; import('@/views/404'),&#125;/** * 动态生成菜单 * @param token * @returns &#123;Promise&lt;Router&gt;&#125; */export const generatorDynamicRouter = (token) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; getCurrentUserNav() .then((res) =&gt; &#123; //接收后端返回的路由表，结构是个数组 let menuNav = res.data //将路由表存到本地临时缓存中 //这一步是为了刷新的时候不需要再调接口，增加用户体验的，没这方面需求可以不用写 sessionStorage.setItem('generateRoutes', JSON.stringify(menuNav)) //转化路由格式 const routers = generator(menuNav) resolve(routers) &#125;) .catch((err) =&gt; &#123; reject(err) &#125;) &#125;)&#125;/** * 格式化树形结构数据 生成 vue-router 层级路由表 * * @param routerMap //当前路由表route * @param parent//当前路由表route的父级component * @returns &#123;*&#125; */export const generator = (routerMap, parent) =&gt; &#123; return routerMap.map((item) =&gt; &#123; const &#123; title, show, hideChildren, hiddenHeaderContent, icon, hidden &#125; = item.meta || &#123;&#125; if (item.component) &#123; // Layout ParentView 组件特殊处理 //这里是对父组件/布局组件的处理，因为有可能出现嵌套布局和多种布局的情况，这个时候需要进行处理。 if (item.component === 'Layout') &#123; item.component = 'Layout' &#125; else if (item.component === 'ParentView') &#123; item.component = 'BasicLayout' item.path = '/' + item.path &#125; &#125; if (item.isFrame === 0) &#123; item.target = '_blank' &#125; const currentRouter = &#123; // 如果路由设置了 path，则作为默认 path，否则 路由地址 动态拼接生成如 /dashboard/workplace path: item.path || `$&#123;(parent &amp;&amp; parent.path) || ''&#125;/$&#123;item.key&#125;`, // 路由名称，建议唯一 // name: item.name || item.key || '', name: item.name || item.key || '', // 该路由对应页面的 组件 :方案1 // 该路由对应页面的 组件 :方案2 (动态加载) //这里就是将component的字符串值转换成懒加载的异步函数 //同时，如果当前路径并没有对应的组件，catch捕获报错，然后跳转到404页，这一步很重要，否则 component: constantRouterComponents[item.component || item.key] || (() =&gt; import(`@/views/$&#123;item.component&#125;`).catch(() =&gt; import('@/views/404') )), hidden: item.hidden, // redirect: '/' + item.path || `$&#123;parent &amp;&amp; parent.path || ''&#125;/$&#123;item.key&#125;`, // meta: 页面标题, 菜单图标, 页面权限(供指令权限用，可去掉) meta: &#123; title: title, icon: icon, hiddenHeaderContent: hiddenHeaderContent, target: validURL(item.path) ? '_blank' : '', permission: item.name, keepAlive: false, hidden: hidden, &#125;, //适配本框架的跳转路径 &#125; // 是否设置了隐藏菜单 if (show === false) &#123; currentRouter.hidden = true &#125; // 修正路径，而antdv-pro的pro-layout要求每个路径需为全路径 //这一步的修正路径也是因人而异，正常情况下按照我这样拼接就没问题了 if (!constantRouterComponents[item.component || item.key]) &#123; if (parent &amp;&amp; parent.path &amp;&amp; parent.path !== '/') &#123; currentRouter.path = `$&#123;parent.path&#125;/$&#123;item.path&#125;` &#125; &#125; // 是否设置了隐藏子菜单 if (hideChildren) &#123; currentRouter.hideChildrenInMenu = true &#125; // 重定向 item.redirect &amp;&amp; (currentRouter.redirect = item.redirect) //添加fullPath currentRouter.fullPath = currentRouter.path // 是否有子菜单，并递归处理 if (item.children &amp;&amp; item.children.length &gt; 0) &#123; currentRouter.children = generator(item.children, currentRouter) &#125; return currentRouter &#125;)&#125; generatorDynamicRouter方法（promise嵌套）上面的代码有点多，不要觉得麻烦，其实就两个方法，第一个方法generatorDynamicRouter会调取后端接口，获取后端返回的私有路由表信息，返回的是个promise对象，因为需要调接口请求后端数据，并且其他方法依赖这个方法的接口返回值，所以是个异步函数。之所以这么写的另外一个原因，是因为在它之前还有个promise异步方法包着它。 我们都知道：在嵌套的 Promise 中，内部的 Promise 会先执行，然后再执行外部的 Promise。这是由于 JavaScript 的异步执行机制所决定的。 所以这种套娃式的目的只有一个——就是确保外层的异步方法在调用内部异步方法时，能够保证拿到内部异步方法请求成功之后的返回值（也就是将异步方法变成同步方法，这也是Promise主要的作用之一，面试常问的）。 而最外层的异步方法，是放在路由守卫当中直接调用的，由于我们是动态异步加载路由，那么执行的方法肯定也是异步。具体的原因是因为： 如果动态加载路由的方法不是异步的，那么在路由守卫中使用它将导致它立即执行并返回一个 Promise，而不是在路由导航过程中延迟加载。这样会使得在路由守卫中的逻辑无法按预期执行，因为在组件加载完成之前，它依赖的组件可能还没有被加载，导致出现错误或不一致的状态。 从后端获取路由配置往往涉及到网络请求和异步操作，不能保证立即返回所有路由信息。当你从后端获取到路由配置后，需要将其添加到 Vue Router 中，以便在前端应用程序中进行动态路由。在这个过程中，你需要使用异步操作来确保在获取到路由配置后再添加到路由中。 generator方法（递归转化）言归正传，generatorDynamicRouter方法调取后端接口，拿到后端返回路由表信息后，会紧接着调用第二个generator方法，并将路由表信息当做参数传入。而generator是一个递归方法。这个也很好理解，因为路由信息里都会包含children子路由，需要层层递归，generator内部会对每一个路由进行逐层转化，每一步都在代码中标有注释，我就不再过多赘述了。我们只需要知道：generator的最终目的就是将后端返回的路由表结构转化成符合前端路由格式的路由（听起来有点绕）。 附上格式化好之后的路由信息： image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3d0b3b606354dbeb064da7b21d406fd~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?) 再对比下格式化之前的样子： ![image.png 可以看到component从字符串变成了函数，path路径也得到了拼接补充。 8.存储格式化好的动态路由及导航栏菜单信息上文提到在generatorDynamicRouter异步方法之外还有一层异步方法，其实我是放在了vuex的store下某个模块中的actions里（默认大家都会用vuex）。具体代码如下 12345678910111213141516const actions = &#123; GenerateRoutes(&#123; commit &#125;) &#123; let sidebarList = [] return new Promise((resolve) =&gt; &#123; generatorDynamicRouter().then((routers) =&gt; &#123; //sidebarList是侧边栏渲染数据 sidebarList = routers //routers就是我们要存储到vuex中的动态路由 commit('set_routers', routers) //侧边栏数据存到vuex中 commit('set_sidebarList', sidebarList) resolve() &#125;) &#125;) &#125;,&#125; 9.添加动态路由好了，到这一步，我们就拿到了准备好的公共路由和私有路由。这个时候，我们再回到路由守卫，回顾一下之前的流程： 路由守卫先判断token 没有token去登录拿token（或者是直接去了白名单里） 拿到token后判断有没有角色信息，没有角色信息就去请求角色信息（调接口） 拿到角色信息后，再去获取对应角色信息的路由表（调接口） 将后端返回的路由表信息转换成前端能添加的路由表信息格式 添加路由 跳转对应路由页面 现在，我们来到了第6步，添加路由，在添加路由之前，先看下路由守卫： 路由守卫的代码如下，在src/config目录下新建文件permissions.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import router from '@/router'import store from '@/store'import getPageTitle from '@/utils/pageTitle'import getInfoRouter from '@/router/getInfoRouter'import &#123; loginInterception, recordRoute, routesWhiteList &#125; from '@/config'router.beforeEach(async (to, from, next) =&gt; &#123; let hasToken = store.getters['user/accessToken'] if (hasToken) &#123; if (to.path === '/login') &#123; next(&#123; path: '/' &#125;) &#125; else &#123; //权限校验 if (store.getters['user/roles'].length === 0) &#123; try &#123; //获取用户信息，包括角色信息和权限信息 await store.dispatch('user/GetInfo') //获取动态路由表信息，并对路由表进行格式转化，然后存到vuex中 await store.dispatch('async-router/GenerateRoutes') //从vuex中拿到动态路由表数据 let accessRoutes = store.getters['async-router/addRouters'] //循环添加路由 accessRoutes.forEach((route) =&gt; &#123; //isHttp方法用来判断是否是外链，如果是外链，就不添加到当前路由表中 if (!isHttp(route.path)) &#123; router.addRoute(route) // 动态添加可访问路由表 &#125; &#125;) //刷新跳转 next(&#123; ...to, replace: true &#125;) &#125; catch (e) &#123; //登出 await store.dispatch('user/Logout') //记录登出前的路由地址 next(&#123; path: '/login', query: &#123; redirect: to.fullPath &#125; &#125;) &#125; &#125; else &#123; next() &#125; &#125; &#125; else &#123; //判断是否在白名单中 if (routesWhiteList.indexOf(to.path) !== -1) &#123; next() &#125; else &#123; //记录跳转到登录页之前的路由地址 next(&#123; path: '/login', query: &#123; redirect: to.fullPath &#125;, replace: true &#125;) &#125; &#125;&#125;)router.afterEach((to) =&gt; &#123; //浏览器页签标题 document.title = getPageTitle(to.meta.title)&#125;) 在vue-router4.x版本中，往当前的路由router对象中动态添加路由时，需要使用官方提供的addRoute方法，不能直接对router对象进行修改，这是因为vue-router必须是要vue在实例化之前就挂载上去的。addRoute方法传入的参数是单个路由对象,所以写法上我们需要对动态路由数组进行for循环，在内部调用addRoute方法，从而达到成功添加多个动态路由的目的。这里附上官方API地址链接：router.vuejs.org/zh/api/inte… 添加完路由之后，调用next({ ...to, replace: true }),就会成功跳转到目标路由地址了。 10.登出当用户要退出时，也就是登出，我们只需要调用登出接口，并在接口成功返回后，重置vuex中的用户信息（token,角色roles,权限permission），同时清空本地缓存的数据就行了。附上代码： 123456789101112131415161718192021222324252627282930 /** * @description 退出登录 * @param &#123;*&#125; &#123; dispatch &#125; */ Logout(&#123; commit, dispatch, state &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; logout() .then(async () =&gt; &#123; await dispatch('resetAll') //清空导航tab页签 this.dispatch('tagsBar/delAllVisitedRoutes', &#123; root: true &#125;) resolve() &#125;) .catch((error) =&gt; &#123; reject(error) &#125;) .finally(() =&gt; &#123;&#125;) &#125;) &#125;,/** * @description 重置accessToken、roles、permission等 * @param &#123;*&#125; &#123; commit, dispatch &#125; */ async resetAll(&#123; dispatch, commit &#125;) &#123; await dispatch('setAccessToken', '') commit('SET_ROLES', []) commit('SET_PERMISSION', []) sessionStorage.clear() &#125;, 到这一步，整个前端权限的流程就算是走完了。 4.按钮级权限前端按钮级权限，是指在前端界面中，根据用户的权限不同，对不同的按钮进行权限控制。这样做的目的是为了确保系统的安全性和数据的保密性，使得不同用户只能执行其有权执行的操作，从而避免潜在的安全风险。 上面这段定义是我copy过来的，其中这句对不同的按钮进行权限控制并不完全对，除了按钮，比如页面中的某个字段，某个div，某个组件要求根据当前用户的权限进行控制时，都可以称为按钮级权限。 像这种按钮级权限的设计方案很多，在vue中，本人目前知道的主流方式有两种： 条件渲染（Conditional Rendering）： 这是一种简单有效的方法，通过在前端代码中根据用户的权限信息来决定是否渲染特定的按钮或组件。比如，你可以使用条件语句（如v-if、ngIf等）来判断用户是否有权限，从而决定是否渲染按钮。 指令/组件封装： 使用一些前端框架（如Vue、React、Angular）提供的自定义指令或组件，可以封装权限控制逻辑。你可以创建一个自定义指令或组件，接受用户权限作为输入，然后根据权限来决定是否显示按钮。 一开始我用的是指令封装的方式，但是随着业务需要，条件渲染这种方式我也用了。 在开始看具体的实现方法之前，不知道你有没有留意到上文的路由守卫中，只是根据用户的角色字段role来校验当前用户的权限，还有一个字段permssions(权限)其实一直没有派上用场，但是无论是在权限的配置项中，还是在后端的返回字段里，都有它的存在： image.png image.png 1.指令/组件封装形式的按钮级权限现在它的作用来了，先看指令的具体实现方式，我们在src/directive目录下新建一个hasPermi.js文件，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * v-hasPermi 操作权限处理 */import store from '@/store'export default &#123; //`el`（element）：这是指令所绑定的元素，是一个普通的DOM元素。在自定义指令的钩子函数中,//你可以通过操作`el`来实现对元素的各种修改，比如添加、删除、修改样式等。/** `binding`：这是一个包含指令信息的对象。它包括了以下属性： `name`：指令的名称，不包括`v-`前缀。 `value`：指令的绑定值，即传递给指令的参数。在你的示例中，`value`存储了操作权限的标识符数组。 `oldValue`：先前的绑定值，仅在组件更新时可用。 `expression`：指令的表达式，如`v-my-directive=\"someValue\"`中的`someValue`。 `arg`：指令的参数，如`v-my-directive:arg=\"value\"`中的`arg`。 `modifiers`：一个包含修饰符的对象，如`v-my-directive.modifier`。 `vnode`：渲染该组件的虚拟节点。 */ mounted(el, binding, vnode) &#123; const &#123; value &#125; = binding //all_permission代表所有权限，一般超级管理员需要用这个 const all_permission = '*:*:*' //获取后端返回的权限字段列表 const permissions = store.getters &amp;&amp; store.getters['user/permissions'] //校验当前用户的权限列表是否存在 if (value &amp;&amp; value instanceof Array &amp;&amp; value.length &gt; 0) &#123; //传入的参数，需要校验的权限字段值 const permissionFlag = value //判断当前权限列表中，有无该传入的权限字段值 const hasPermissions = permissions.some((permission) =&gt; &#123; return ( all_permission === permission || permissionFlag.includes(permission) ) &#125;) if (!hasPermissions) &#123; // 如果用户没有权限，移除当前元素的父节点（即移除当前元素） el.parentNode &amp;&amp; el.parentNode.removeChild(el) &#125; &#125; else &#123; throw new Error(`请设置操作权限标签值`) &#125; &#125;,&#125; 这段代码主要是在页面元素的挂载阶段（mounted钩子）检查用户权限，如果用户没有操作权限，那么就移除对应的页面元素。具体的代码说明我都放在里注释里。 写好了这个方法后，需要将该指令挂载到全局当中，这个时候需要进入main.js文件，在vue3中，给vue对象挂载自定义指令的方式如下： 1234567import &#123; createApp &#125; from 'vue'import App from './App'import directive from '@/directive' // directiveconst app = createApp(App)app.mount('#app')// 添加到全局directive(app) 然后，在你需要进行按钮级权限校验的地方添加上这段指令，比如： 1234567&lt;a-button type=\"primary\" @click=\"openModal('add')\" v-hasPermi=\"['system:user:add']\" &gt; 新增 &lt;/a-button&gt; 上面这段代码里的system:user:add意思是系统目录下用户管理模块的新增按钮权限（如果看不懂就翻到文章最开始介绍RBAC的权限字段设计那里），当后端返回的当前用户数据中的permissions字段里，没有system:user:add这个权限字段时，这个按钮就不会显示出来。 2.条件渲染形式的按钮级权限自定义指令实现的按钮级权限并不能满足我的业务需要，由于vue的限制，我们的自定义指令只能用在组件的template模块内，也就是只能放在dom标签上。但是有的时候，我可能需要对某个字段的逻辑，或者根据角色的不同，显示不同的表格列，这是数据上的处理，这个时候自定义指令就毫无用武之地。所以就需要用到条件渲染的形式。 条件渲染的形式，说白了，就是封装一个全局方法，方法返回值是true或者是false，然后再加一个v-if，但是我其实用不到这个v-if,我只需要这个判断权限的返回结果就足够了，核心逻辑跟自定义指令如出一辙。就不再过多赘述，直接上代码你就懂了： 123456789101112131415/** * checkPermi 操作权限处理 */import store from '@/store'export default function checkPermi(value) &#123; const all_permission = '*:*:*' const permissions = store.getters &amp;&amp; store.getters['user/permissions'] const permissionFlag = value const hasPermissions = permissions.some((permission) =&gt; &#123; return all_permission === permission || permissionFlag.includes(permission) &#125;) return hasPermissions&#125; 跟上面的自定义指令不能说完全一样，只能说是一模一样。然后，我们就需要把这个方法挂载到全局，这里的挂载方式是vue3的： 12345import &#123; createApp &#125; from 'vue'import App from './App'const app = createApp(App)app.config.globalProperties.$checkPermi = checkPermiapp.mount('#app') 然后在你需要用的地方引入： 123456789101112131415161718&lt;script setup&gt; import &#123; ref, reactive, onMounted, watch, toRefs, nextTick, getCurrentInstance, &#125; from 'vue' const &#123; $checkPermi &#125; = getCurrentInstance().appContext.config.globalProperties if ($checkPermi(['ProductionManagement:CustomOrderManagement:pro'])) &#123; //有这个按钮级权限时的处理 &#125;else&#123; //没有这个按钮级权限时的处理 &#125;&lt;/script&gt; 怎么样，是不是很简单？ 后台系统按钮级别权限控制两种方案，自定义指令和条件控制的优缺点在后台系统中，对于按钮级别权限控制，自定义指令和条件控制是两种常用的方法。以下是它们各自的优缺点： 自定义指令方案优点： 高度封装：自定义指令可以将权限控制的逻辑封装起来，使得在多个地方使用相同的权限控制变得简单。 易于扩展：如果需要添加新的权限控制逻辑，只需修改或扩展自定义指令即可，无需修改大量已有代码。 提高可读性：在模板中使用自定义指令可以使得代码更加简洁，提高可读性。 缺点： 依赖后端：通常，自定义指令需要依赖于后端提供的用户权限数据来进行权限判断。 学习成本：对于不熟悉Vue等前端框架的开发者来说，学习自定义指令的编写和使用需要一定的时间。 性能考虑：如果自定义指令的实现不够高效，可能会对页面性能产生一定的影响。 条件控制方案优点： 简单直接：条件控制直接基于前端逻辑进行判断，代码简单直接，易于理解。 减少依赖：与自定义指令相比，条件控制通常不需要依赖于后端提供的权限数据，只需根据前端状态进行判断。 无需额外学习：对于大多数开发者来说，条件控制是基本的前端技能，无需额外学习。 缺点： 代码冗余：如果在多个地方使用相同的权限控制逻辑，可能会导致代码冗余。 维护困难：当需要修改权限控制逻辑时，可能需要修改多个地方的代码，维护起来较为困难。 安全性：如果条件控制的逻辑过于简单，可能会存在安全风险，比如被绕过或猜测出正确的逻辑。 总结在实际应用中，可以根据项目的具体需求和团队的实际情况来选择使用哪种方案。如果项目对权限控制的要求比较高，且团队对Vue等前端框架比较熟悉，可以考虑使用自定义指令方案；如果项目对权限控制的要求相对简单，或者团队对前端框架的熟悉程度不够，可以考虑使用条件控制方案。同时，也可以考虑将两种方案结合起来使用，以达到更好的效果。 如何结合使用自定义指令和条件控制结合使用自定义指令和条件控制可以为后台系统的按钮级别权限控制提供更灵活和可维护的解决方案。以下是如何结合使用这两种方法的建议： 1. 定义自定义指令首先，你可以定义一个或多个自定义指令来处理权限控制的逻辑。这些指令可以检查用户是否具有某个特定的权限，并根据权限决定是否显示或禁用某个按钮。 例如，在Vue中，你可以定义一个名为v-permission的自定义指令： 12345678910111213Vue.directive('permission', &#123; // 当被绑定的元素挂载到 DOM 中时…… inserted: function (el, binding, vnode) &#123; // 假设 binding.value 是一个权限字符串，如 'admin' const hasPermission = checkPermission(binding.value); // 这是一个假设的函数，需要根据你的后端API实现 if (!hasPermission) &#123; // 如果没有权限，隐藏或禁用元素 el.style.display = 'none'; // 或者你可以添加 disabled 属性到按钮上 &#125; &#125;, // ...（其他钩子函数，如 update，componentUpdated） &#125;); 2. 使用条件渲染除了自定义指令，你还可以使用Vue的条件渲染指令（如v-if和v-show）来根据条件显示或隐藏按钮。这种方法特别适用于基于更复杂逻辑（不仅仅是权限）的渲染。 1&lt;button v-if=\"isAdmin &amp;&amp; showButton\" @click=\"handleClick\"&gt;点击我&lt;/button&gt; 在上面的例子中，isAdmin可能是一个计算属性或方法来检查用户是否具有管理员权限，而showButton可能是一个简单的布尔值，用于根据其他条件（如页面状态）控制按钮的显示。 3. 结合使用你可以将自定义指令和条件渲染结合使用，以便在更复杂的场景中实现权限控制。例如，你可以使用v-permission指令来检查用户是否具有某个权限，并使用v-if来根据其他条件（如页面状态或数据可用性）进一步控制按钮的显示。 1&lt;button v-permission=\"'admin'\" v-if=\"dataLoaded\" @click=\"handleClick\"&gt;管理操作&lt;/button&gt; 在上面的例子中，只有当用户具有管理员权限（由v-permission指令检查）且数据已加载（由v-if指令检查）时，按钮才会显示。 4. 注意事项 性能：虽然自定义指令和条件渲染都是Vue的性能优化点，但在大规模应用中，过多的条件渲染可能会导致性能问题。确保在适当的时候使用v-show代替v-if，以避免不必要的重新渲染。 代码组织：为了保持代码的清晰和可维护性，将权限控制逻辑与业务逻辑分开。你可以将权限检查逻辑封装在可复用的函数或组件中。 测试：确保对自定义指令和条件渲染进行充分的测试，以确保它们在各种条件下都能正常工作。 5.遇到的坑这里面有几个坑需要注意下： 第一个坑就是在vue3支持的vue-router4.0版本之前，也就是vue2中，动态添加路由的方式支持的是addRoutes，它的参数是格式是一个数组。而到了4.0后，addRoutes这个方法被废弃，取而代之的是addRoute，它的参数则是一个路由对象。这两个方法无论是在传参类型还是添加相同path时的覆盖逻辑都不相同。 第二个坑就是无论是用控制台还是打断点的方式，或者是用Vue.js devtools的谷歌插件，都无法在路由守卫中获取到添加完成后的最新router对象，也就是说你会在调试addRoute加载后的动态路由表时，发现与之前为添加路由时的路由表是一样的，从而无法判断是否动态路由添加成功（就很蛋疼） 第三个坑是 next({ …to, replace: true })这个方法，当添加好动态路由后，如果不这么写next，会白屏。在addRoute()之后第一次访问被添加的路由会白屏，这是因为刚刚addRoute()就立刻访问被添加的路由，然而此时addRoute()没有执行结束，因而找不到刚刚被添加的路由导致白屏。因此需要从新访问一次路由才行。 具体原因见文章链接：blog.csdn.net/qq_41912398… 退出后，新的用户会访问到原本不属于该用户的路由，必须刷新页面才会正常。后来通过排查，导致这个问题的原因是因为当用户登出时，当前路由router对象还保留着上一个用户的动态路由，因次，还需要在登出的时候，对路由router对象进行初始化。我们在src/router目录下的index.js文件里写一个初始化方法： 1234567891011//初始化路由export function resetRouter() &#123;//获取当前路有对象 let routers = router.getRoutes()//剔除动态路由 routers.map((it) =&gt; &#123; if (!['login', '403', ':pathMatch(.*)*'].includes(it.name)) &#123; router.removeRoute(it.name) &#125; &#125;)&#125; 然后在登出的地方引用这个方法并执行 123456import &#123; resetRouter &#125; from '@/router/index.js' async logout() &#123; resetRouter() await store.dispatch('user/Logout') this.$router.push('/login') &#125;, 还有一个关于vuex的问题，从之前的代码里不难看出，我们将用户信息，角色、权限、动态路由等都存在了vuex中。由于vuex的特性，用户会在刷新页面后，vuex里的数据会被清空，这个时候就会导致页面直接跳转到登录页。这肯定是不能接受的，因此，我们需要对vuex里的数据在刷新的时候做持久化处理。逻辑也很简单，监听页面刷新事件，beforeunload这个方法恰好就能做到，在页面刷新的时候，将vuex中的数据缓存到浏览器本地临时缓存中，然后再在页面初始化的时候，从本地临时缓存中取出存入vuex对象中。 附上代码：（项目根目录下的的App.vue文件中,这里是vue2的写法) 1234567891011121314created() &#123; //在页面加载时读取sessionStorage里的状态信息 sessionStorage.getItem('userMsg') &amp;&amp; this.$store.replaceState( Object.assign( this.$store.state, JSON.parse(sessionStorage.getItem('userMsg')) ) ) //在页面刷新时将vuex里的信息保存到sessionStorage里 window.addEventListener('beforeunload', () =&gt; &#123; sessionStorage.setItem('userMsg', JSON.stringify(this.$store.state)) &#125;) &#125;, 这里再附上src/router目录下的index.js代码，方便大家理解路由这块： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import &#123; createWebHistory, createRouter, useRouter &#125; from 'vue-router'import &#123; constantRouterMap &#125; from '@/config/router.config.js'import &#123; generator &#125; from '@/router/generatorRouters'const router = createRouter(&#123; history: createWebHistory(), routes: constantRouterMap, scrollBehavior(to, from, savedPosition) &#123; if (savedPosition) &#123; return savedPosition &#125; else &#123; return &#123; top: 0 &#125; &#125; &#125;,&#125;)//这里是我为了刷新的时候不调取获取路由信息的接口，做的本地缓存，因为刷新一次就要获取一遍用户信息和//动态路由表信息太影响用户体验了，尤其是在网速差的情况下。没这方面需求的可以不用管let asyncRouterMap = []function handleLocalRouter() &#123; if (sessionStorage.getItem('generateRoutes')) &#123; asyncRouterMap = asyncRouterMap.concat( JSON.parse(sessionStorage.getItem('generateRoutes')) ) const generatedRoutes = generator(asyncRouterMap) generatedRoutes.push(&#123; path: '/:pathMatch(.*)*', redirect: '/404', hidden: true, &#125;) generatedRoutes.forEach((route) =&gt; &#123; router.addRoute(route) &#125;) &#125;&#125;//初始化路由export function resetRouter() &#123; let routers = router.getRoutes() routers.map((it) =&gt; &#123; if (!['login', '403', ':pathMatch(.*)*'].includes(it.name)) &#123; router.removeRoute(it.name) &#125; &#125;)&#125;handleLocalRouter()export default router 6.结束与优化好，至此，整个RBAC的前端权限方案设计到实现就已经宣告完成，其实还有很多需要优化的地方，比如把用户路由表信息缓存到本地临时缓存中，这样用户每次刷新页面的时候就不会因为vuex的特性需要再去请求一边接口。（但是老实说，我觉得这个优化方案还是不够好，因为将路由表存在本地缓存中就已经背离了安全性这一块，但是在网络较差的情况下，刷新就要调取角色信息接口，调取获取私有路由的接口，再到构建新的完整路由这个过程期间，页面会处于白屏状态，非常影响用户体验。因此，只能取此下策。到底要不要缓存，看个人的想法吧。） 还比如 123456789await store.dispatch('user/GetInfo') await store.dispatch('async-router/GenerateRoutes') let accessRoutes = store.getters['async-router/addRouters'] accessRoutes.forEach((route) =&gt; &#123; //用来判断是否是外链 if (!isHttp(route.path)) &#123; router.addRoute(route) // 动态添加可访问路由表 &#125; &#125;) 这段获取用户信息-&gt;构建路由-&gt;添加动态路由的代码可以抽离出来，单独封装。 还可以根据当前环境是否是development来判断是否是开发环境，从而准备另外一套前端开发场景下使用的完整路由表，这样，就可以在不依赖后端的情况下，进行前端开发。 另外还有侧边导航栏的处理，这个我没讲，一方面是相对简单，我们获取到格式化之后的动态路由数据的同时，其实也就是获取到了导航栏的菜单信息。 另一方面，每个人的项目页面布局方式不一样，导航栏的设计也会不一样。在此基础上，针对性的对数据进行修饰和改造即可。 不啰嗦了，今天周五下班时间了，我写的比较匆忙，也有些地方我可能没有考虑到，看到这里的小伙伴，或者对着文章实践的小伙伴们，欢迎你们提出自己的意见和看法，我会加以订正，不足之处，还请海涵~~ 5223e1f26a8ae0f57e4ff89518d9c82f.jpg 原文链接：https://juejin.cn/post/7259210874446692411","categories":[{"name":"前端文章","slug":"前端文章","permalink":"https://qw8.github.io/categories/前端文章/"}],"tags":[{"name":"权限","slug":"权限","permalink":"https://qw8.github.io/tags/权限/"}]},{"title":"后台管理系统","slug":"articles/后台管理系统","date":"2023-12-14T16:00:00.000Z","updated":"2024-05-08T06:50:25.053Z","comments":true,"path":"/articles/hou-tai-guan-li-xi-tong.html","link":"","permalink":"https://qw8.github.io/articles/hou-tai-guan-li-xi-tong.html","excerpt":"","text":"总是做后台管理系统，到底要怎么提升自己呢？很多人都来问我：我平时写的东西都是后台管理系统，根本就没啥亮点的东西，我也没啥进步，我该咋办呢？ 后台管理不丢人其实据我了解，大部分前端在公司其实就是做后台管理系统，偶尔做做移动端，那么大家都是做后台管理，你要怎么比别人强呢？其实就是一个点：你如何把后台管理系统做得更好 其实我也做过一段时间的后台管理系统，我总结了几点我的心得，分享给大家~ 多封装组件封装是一个很普遍的操作，但是却很少人去做好这件事，我现在做后台管理系统的话我会做到极致的封装，只要是一个东西有两处地方复用到了，我肯定会抽取封装起来，在这个过程中，我也学到了很多 Vue3 的 API，也发现很多封装组件的技巧，比如 shallowRef 节省性能 computed 的 getter 和 setter 组件 props 类型的拓展 组件封装的更加方便使用 模板的极致复用 命令式使用弹窗 多封装 Hooks对于一些业务性的逻辑代码，或者共用的逻辑代码，都要有抽取成 Hooks 的意识，这有利于于后续代码的可维护性，并且抽取共用的 Hooks，有利于代码可复用性，提高代码开发效率，锻炼你的逻辑封装能力，我最近封装了很多 Hooks，比如 useClickoutside：点击目标区域以外触发事件 useCommandComponent：命令式使用组件 createModal：命令式使用弹窗 useTemplate：本组件复用弹窗 useGlobalState：局部状态管理 useVirtualList：虚拟滚动 等等。。。 多考虑边界条件我发现很多人在做后台管理也好，做其他的东西也好，其实总是会考虑得没那么周全，其中一点就是，总是不考虑边界条件，不去考虑兜底，比如： 组件的参数兜底检验补全 hooks的参数兜底补全 接口请求数据出错、接口报错的兜底 某些代码记得加 try catch 进行兜底 代码执行先后顺序问题，怎么去控制按照顺序去执行 多想想产品优化其实优化不止是代码优化，也有产品优化，有时候其实产品经理想出来的点子，也是不合理的，这个时候你可以去提出自己的见解，让整个产品更好，当然代码的优化也是必须做的，比如： 防抖节流 长列表的虚拟滚动 大文件的分片上传 多请求时的控制并发 使用合适的 API ，节省性能 多使用设计模式，提高代码健壮性 多想想怎么提高效率你要知道，后台管理系统其实业务难度是有限的，但是其实你可以不要局限于项目，而是要经常去想想： 你能怎么在项目中去让自己进步 你要怎么样去提升自己的开发效率 你要怎么样去提升整个团队的开发效率 就比如我，我在开发后台管理系统的时候，我会做这些事： 发现某些别人不合理的开发习惯，可以记下来，反馈给团队 为了团队开发规范，开发一些小工具，来助力团队的规范 为了团队成员开发的效率，开发一些小工具，帮他们提升开发效率 多为团队的组件库工具库贡献，这样也能提升整个团队的开发效率 主动去封装一些比较难的组件，提升团队开发效率，使自己进步 多搞配置化我记得我一年前去面试一个高级前端工程师的岗位时，面试官就问我一个问题：假如你开发一个后台管理系统，你怎么让你的团队成员更轻松去开发呢？ 我当时回答说：制定规范！ 然后面试官我没体会到他真正的意思 现在我算是领会到了，面试官的意思是：你要怎么开发一个后台管理系统，让你的组员无脑地开发 那其实我觉得，把一些事情做成配置化，这样才能让别人开发的时候，更加方便、更加无脑~ 其实后台管理无非就几个东西： 表单 表格 图表 那么可以做相对应的配置器，让其他人只需要传入配置，就可以生成想要的页面效果，比如： 表单配置器 表格配置器 图表配置器 多看看别人怎么做的github 上有很多很出名的后台管理系统，大家可以去看看人家是怎么写的，为啥你写的像入门级，人家写的像大佬级别，可以多看看多学学，我推荐给你们vben-admin，我从这个后台管理项目中真的学到好多东西！","categories":[{"name":"前端文章","slug":"前端文章","permalink":"https://qw8.github.io/categories/前端文章/"}],"tags":[{"name":"管理系统","slug":"管理系统","permalink":"https://qw8.github.io/tags/管理系统/"}]},{"title":"Webpack优化实践","slug":"articles/Webpack优化实践","date":"2023-11-20T16:00:00.000Z","updated":"2024-02-18T02:48:44.000Z","comments":true,"path":"/articles/webpack-you-hua-shi-jian.html","link":"","permalink":"https://qw8.github.io/articles/webpack-you-hua-shi-jian.html","excerpt":"","text":"Vue项目Webpack优化实践，构建效率提高50%前言 公司的前端项目使用Vue框架，Vue框架使用Webpack进行构建，随着项目不断迭代，项目逐渐变得庞大，然而项目的构建速度随之变得缓慢，于是对Webpack构建进行优化变得刻不容缓。经过不断的摸索和实践，通过以下方法优化后，项目的构建速度提高了50%。现将相关优化方法进行总结分享。 1、缩小文件的搜索范围1.1、优化Loader配置​ 由于Loader对文件的转换操作很耗时，所以需要让尽可能少的文件被Loader处理。我们可以通过以下3方面优化Loader配置：（1）优化正则匹配（2）通过cacheDirectory选项开启缓存（3）通过include、exclude来减少被处理的文件。实践如下： 项目原配置： 12345&#123; test: /\\.js$/, loader: &apos;babel-loader&apos;, include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;)]&#125; 优化后配置： 12345678&#123; // 1、如果项目源码中只有js文件，就不要写成/\\.jsx?$/，以提升正则表达式的性能 test: /\\.js$/, // 2、babel-loader支持缓存转换出的结果，通过cacheDirectory选项开启 loader: &apos;babel-loader?cacheDirectory&apos;, // 3、只对项目根目录下的src 目录中的文件采用 babel-loader include: [resolve(&apos;src&apos;)]&#125; 1.2、优化resolve.modules配置​ resolve.modules 用于配置Webpack去哪些目录下寻找第三方模块。resolve.modules的默认值是［node modules］，含义是先去当前目录的/node modules目录下去找我们想找的模块，如果没找到，就去上一级目录../node modules中找，再没有就去../ .. /node modules中找，以此类推，这和Node.js的模块寻找机制很相似。当安装的第三方模块都放在项目根目录的./node modules目录下时，就没有必要按照默认的方式去一层层地寻找，可以指明存放第三方模块的绝对路径，以减少寻找。 优化后配置： 1234resolve: &#123;// 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤modules: [path.resolve(__dirname,&apos;node_modules&apos;)]&#125; 1.3、优化resolve.alias配置​ resolve.alias配置项通过别名来将原导入路径映射成一个新的导入路径。 如项目中的配置使用： 12345alias: &#123; &apos;@&apos;: resolve(&apos;src&apos;),&#125;,// 通过以上的配置，引用src底下的common.js文件，就可以直接这么写import common from &apos;@/common.js&apos;; 1.4、优化resolve.extensions配置​ 在导入语句没带文件后缀时，Webpack 会在自动带上后缀后去尝试询问文件是否存在。默认是：extensions :[‘. js ‘,’. json ’] 。也就是说，当遇到require ( &#39;. /data ’）这样的导入语句时，Webpack会先去寻找./data .js 文件，如果该文件不存在，就去寻找./data.json 文件，如果还是找不到就报错。如果这个列表越长，或者正确的后缀越往后，就会造成尝试的次数越多，所以 resolve .extensions 的配置也会影响到构建的性能。 优化措施： • 后缀尝试列表要尽可能小，不要将项目中不可能存在的情况写到后缀尝试列表中。 • 频率出现最高的文件后缀要优先放在最前面，以做到尽快退出寻找过程。 • 在源码中写导入语句时，要尽可能带上后缀，从而可以避免寻找过程。例如在确定的情况下将 require(’. /data ’)写成require(’. /data.json ’)，可以结合enforceExtension 和 enforceModuleExtension开启使用来强制开发者遵守这条优化 1.5、优化resolve.noParse配置​ noParse配置项可以让Webpack忽略对部分没采用模块化的文件的递归解析和处理，这 样做的好处是能提高构建性能。原因是一些库如jQuery、ChartJS 庞大又没有采用模块化标准，让Webpack去解析这些文件既耗时又没有意义。 noParse是可选的配置项，类型需要是RegExp 、[RegExp]、function中的一种。例如，若想要忽略jQuery 、ChartJS ，则优化配置如下： 1234567// 使用正则表达式 noParse: /jquerylchartjs/ // 使用函数，从 Webpack3.0.0开始支持 noParse: (content)=&gt; &#123; // 返回true或false return /jquery|chartjs/.test(content); &#125; 2、减少冗余代码​ babel-plugin-transform-runtime 是Babel官方提供的一个插件，作用是减少冗余的代码 。 Babel在将ES6代码转换成ES5代码时，通常需要一些由ES5编写的辅助函数来完成新语法的实现，例如在转换 class extent 语法时会在转换后的 ES5 代码里注入 extent 辅助函数用于实现继承。babel-plugin-transform-runtime会将相关辅助函数进行替换成导入语句，从而减小babel编译出来的代码的文件大小。 3、使用HappyPack多进程解析和处理文件​ 由于有大量文件需要解析和处理，所以构建是文件读写和计算密集型的操作，特别是当文件数量变多后，Webpack构建慢的问题会显得更为严重。运行在 Node之上的Webpack是单线程模型的，也就是说Webpack需要一个一个地处理任务，不能同时处理多个任务。Happy Pack ( https://github.com/amireh/happypack ）就能让Webpack做到这一点，它将任务分解给多个子进程去并发执行，子进程处理完后再将结果发送给主进程。 项目中HappyPack使用配置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344（1）HappyPack插件安装： $ npm i -D happypack（2）webpack.base.conf.js 文件对module.rules进行配置 module: &#123; rules: [ &#123; test: /\\.js$/, // 将对.js 文件的处理转交给 id 为 babel 的HappyPack实例 use:[&apos;happypack/loader?id=babel&apos;], include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;), resolve(&apos;node_modules/webpack-dev-server/client&apos;)], // 排除第三方插件 exclude:path.resolve(__dirname,&apos;node_modules&apos;), &#125;, &#123; test: /\\.vue$/, use: [&apos;happypack/loader?id=vue&apos;], &#125;, ] &#125;,（3）webpack.prod.conf.js 文件进行配置 const HappyPack = require(&apos;happypack&apos;); // 构造出共享进程池，在进程池中包含5个子进程 const HappyPackThreadPool = HappyPack.ThreadPool(&#123;size:5&#125;); plugins: [ new HappyPack(&#123; // 用唯一的标识符id，来代表当前的HappyPack是用来处理一类特定的文件 id:&apos;vue&apos;, loaders:[ &#123; loader:&apos;vue-loader&apos;, options: vueLoaderConfig &#125; ], threadPool: HappyPackThreadPool, &#125;), new HappyPack(&#123; // 用唯一的标识符id，来代表当前的HappyPack是用来处理一类特定的文件 id:&apos;babel&apos;, // 如何处理.js文件，用法和Loader配置中一样 loaders:[&apos;babel-loader?cacheDirectory&apos;], threadPool: HappyPackThreadPool, &#125;), ] 4、使用ParallelUglifyPlugin多进程压缩代码文件​ 由于压缩JavaScript 代码时，需要先将代码解析成用 Object 抽象表示的 AST 语法树，再去应用各种规则分析和处理AST ，所以导致这个过程的计算量巨大，耗时非常多。当Webpack有多个JavaScript 文件需要输出和压缩时，原本会使用UglifyJS去一个一个压缩再输出，但是ParallelUglifyPlugin会开启多个子进程，将对多个文件的压缩工作分配给多个子进程去完成，每个子进程其实还是通过UglifyJS去压缩代码，但是变成了并行执行。所以 ParallelUglify Plugin能更快地完成对多个文件的压缩工作。 项目中ParallelUglifyPlugin使用配置： 12345678910111213141516（1）ParallelUglifyPlugin插件安装： $ npm i -D webpack-parallel-uglify-plugin（2）webpack.prod.conf.js 文件进行配置 const ParallelUglifyPlugin =require(&apos;webpack-parallel-uglify-plugin&apos;); plugins: [ new ParallelUglifyPlugin(&#123; cacheDir: &apos;.cache/&apos;, uglifyJs:&#123; compress: &#123; warnings: false &#125;, sourceMap: true &#125; &#125;), ]复制代码 5、使用自动刷新​ 借助自动化的手段，在监听到本地源码文件发生变化时，自动重新构建出可运行的代码后再控制浏览器刷新。Webpack将这些功能都内置了，并且提供了多种方案供我们选择。 项目中自动刷新的配置： 1234567891011devServer: &#123; watchOptions: &#123; // 不监听的文件或文件夹，支持正则匹配 ignored: /node_modules/, // 监听到变化后等300ms再去执行动作 aggregateTimeout: 300, // 默认每秒询问1000次 poll: 1000 &#125;&#125;,复制代码 相关优化措施： （1）配置忽略一些不监听的一些文件，如：node_modules。 （2）watchOptions.aggregateTirneout 的值越大性能越好，因为这能降低重新构建的频率。 （3） watchOptions.poll 的值越小越好，因为这能降低检查的频率。 6、开启模块热替换​ DevServer 还支持一种叫做模块热替换（ Hot Module Replacement ）的技术可在不刷新整个网页的情况下做到超灵敏实时预览。原理是在一个源码发生变化时，只需重新编译发生变化的模块，再用新输出的模块替换掉浏览器中对应的老模块 。模块热替换技术在很大程度上提升了开发效率和体验 。 项目中模块热替换的配置： 123456789devServer: &#123; hot: true,&#125;,plugins: [ new webpack.HotModuleReplacementPlugin(),// 显示被替换模块的名称 new webpack.NamedModulesPlugin(), // HMR shows correct file names]复制代码 7、提取公共代码​ 如果每个页面的代码都将这些公共的部分包含进去，则会造成以下问题 ： • 相同的资源被重复加载，浪费用户的流量和服务器的成本。 • 每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。 ​ 如果将多个页面的公共代码抽离成单独的文件，就能优化以上问题 。Webpack内置了专门用于提取多个Chunk中的公共部分的插件CommonsChunkPlugin。 项目中CommonsChunkPlugin的配置： 12345678910111213141516171819// 所有在 package.json 里面依赖的包，都会被打包进 vendor.js 这个文件中。new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;vendor&apos;, minChunks: function(module, count) &#123; return ( module.resource &amp;&amp; /\\.js$/.test(module.resource) &amp;&amp; module.resource.indexOf( path.join(__dirname, &apos;../node_modules&apos;) ) === 0 ); &#125;&#125;),// 抽取出代码模块的映射关系new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;manifest&apos;, chunks: [&apos;vendor&apos;]&#125;),复制代码 8、按需加载代码​ 通过vue写的单页应用时，可能会有很多的路由引入。当打包构建的时候，javascript包会变得非常大，影响加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来。 项目中路由按需加载（懒加载）的配置： 123456const Foo = () =&gt; import(&apos;./Foo.vue&apos;)const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/foo&apos;, component: Foo &#125; ]&#125;) 9、优化SourceMap​ 我们在项目进行打包后，会将开发中的多个文件代码打包到一个文件中，并且经过压缩，去掉多余的空格，且babel编译化后，最终会用于线上环境，那么这样处理后的代码和源代码会有很大的差别，当有bug的时候，我们只能定位到压缩处理后的代码位置，无法定位到开发环境中的代码，对于开发不好调式，因此sourceMap出现了，它就是为了解决不好调式代码问题的。 SourceMap的可选值如下： img 开发环境推荐： cheap-module-eval-source-map 生产环境推荐： `cheap-module-source-map` 原因如下： 源代码中的列信息是没有任何作用，因此我们打包后的文件不希望包含列相关信息，只有行信息能建立打包前后的依赖关系。因此不管是开发环境或生产环境，我们都希望添加cheap的基本类型来忽略打包前后的列信息。 不管是开发环境还是正式环境，我们都希望能定位到bug的源代码具体的位置，比如说某个vue文件报错了，我们希望能定位到具体的vue文件，因此我们也需要module配置。 我们需要生成map文件的形式，因此我们需要增加source-map属性。 我们介绍了eval打包代码的时候，知道eval打包后的速度非常快，因为它不生成map文件，但是可以对eval组合使用 eval-source-map使用会将map文件以DataURL的形式存在打包后的js文件中。在正式环境中不要使用 eval-source-map, 因为它会增加文件的大小，但是在开发环境中，可以试用下，因为他们打包的速度很快。 10、构建结果输出分析​ Webpack输出的代码可读性非常差而且文件非常大，让我们非常头疼。为了更简单、直观地分析输出结果，社区中出现了许多可视化分析工具。这些工具以图形的方式将结果更直观地展示出来，让我们快速了解问题所在。接下来讲解vue项目中用到的分析工具：webpack-bundle-analyzer 。 项目中在webpack.prod.conf.js进行配置： 12345if (config.build.bundleAnalyzerReport) &#123; var BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin; webpackConfig.plugins.push(new BundleAnalyzerPlugin());&#125;执行 $ npm run build --report 后生成分析报告如下：","categories":[{"name":"前端文章","slug":"前端文章","permalink":"https://qw8.github.io/categories/前端文章/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"https://qw8.github.io/tags/Webpack/"}]},{"title":"Vue核心之虚拟DOM","slug":"articles/Vue核心之虚拟DOM","date":"2023-11-19T16:00:00.000Z","updated":"2024-02-18T02:52:52.000Z","comments":true,"path":"/articles/vue-he-xin-zhi-xu-ni-dom.html","link":"","permalink":"https://qw8.github.io/articles/vue-he-xin-zhi-xu-ni-dom.html","excerpt":"","text":"深入剖析：Vue核心之虚拟DOM前言使用 Vue 做项目也有两年时间了，对 Vue 的 api也用的比较得心应手了，虽然对 Vue 的一些实现原理也耳有所闻，例如 虚拟DOM、flow、数据驱动、路由原理等等，但是自己并没有特意去探究这些原理的基础以及 Vue 源码是如何利用这些原理进行框架实现的，所以利用空闲时间，进行 Vue 框架相关技术原理和 Vue 框架的具体实现的整理。如果你对 Vue 的实现原理很感兴趣，那么就可以开始这系列文章的阅读，将会为你打开 Vue 的底层世界大门，对它的实现细节一探究竟。 本文为 Virtual DOM的技术原理和 Vue 框架的具体实现。 辛苦编写良久，还望手动点赞鼓励~ github地址为：github.com/fengshi123/…，上面汇总了作者所有的博客文章，如果喜欢或者有所启发，请帮忙给个 star ~，对作者也是一种鼓励。 一、真实DOM和其解析流程本节我们主要介绍真实 DOM 的解析过程，通过介绍其解析过程以及存在的问题，从而引出为什么需要虚拟DOM。一图胜千言，如下图为 webkit 渲染引擎工作流程图 1.png 所有的浏览器渲染引擎工作流程大致分为5步：创建 DOM 树 —&gt; 创建 Style Rules -&gt; 构建 Render 树 —&gt; 布局 Layout -—&gt; 绘制 Painting。 第一步，构建 DOM 树：用 HTML 分析器，分析 HTML 元素，构建一棵 DOM 树； 第二步，生成样式表：用 CSS 分析器，分析 CSS 文件和元素上的 inline 样式，生成页面的样式表； 第三步，构建 Render 树：将 DOM 树和样式表关联起来，构建一棵 Render 树（Attachment）。每个 DOM 节点都有 attach 方法，接受样式信息，返回一个 render 对象（又名 renderer），这些 render 对象最终会被构建成一棵 Render 树； 第四步，确定节点坐标：根据 Render 树结构，为每个 Render 树上的节点确定一个在显示屏上出现的精确坐标； 第五步，绘制页面：根据 Render 树和节点显示坐标，然后调用每个节点的 paint 方法，将它们绘制出来。 注意点： *1、DOM 树的构建是文档加载完成开始的？ *构建 DOM 树是一个渐进过程，为达到更好的用户体验，渲染引擎会尽快将内容显示在屏幕上，它不必等到整个 HTML 文档解析完成之后才开始构建 render 树和布局。 *2、Render 树是 DOM 树和 CSS 样式表构建完毕后才开始构建的？ *这三个过程在实际进行的时候并不是完全独立的，而是会有交叉，会一边加载，一边解析，以及一边渲染。 3、CSS 的解析注意点？ CSS 的解析是从右往左逆向解析的，嵌套标签越多，解析越慢。 4、JS 操作真实 DOM 的代价？ 用我们传统的开发模式，原生 JS 或 JQ 操作 DOM 时，浏览器会从构建 DOM 树开始从头到尾执行一遍流程。在一次操作中，我需要更新 10 个 DOM 节点，浏览器收到第一个 DOM 请求后并不知道还有 9 次更新操作，因此会马上执行流程，最终执行10 次。例如，第一次计算完，紧接着下一个 DOM 更新请求，这个节点的坐标值就变了，前一次计算为无用功。计算 DOM 节点坐标值等都是白白浪费的性能。即使计算机硬件一直在迭代更新，操作 DOM 的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户体验 二、Virtual-DOM 基础2.1、虚拟 DOM 的好处​ 虚拟 DOM 就是为了解决浏览器性能问题而被设计出来的。如前，若一次操作中有 10 次更新 DOM 的动作，虚拟 DOM 不会立即操作 DOM，而是将这 10 次更新的 diff 内容保存到本地一个 JS 对象中，最终将这个 JS 对象一次性 attch 到 DOM 树上，再进行后续操作，避免大量无谓的计算量。所以，用 JS 对象模拟 DOM 节点的好处是，页面的更新可以先全部反映在 JS 对象(虚拟 DOM )上，操作内存中的 JS 对象的速度显然要更快，等更新完成后，再将最终的 JS 对象映射成真实的 DOM，交由浏览器去绘制。 2.2、算法实现2.2.1、用 JS 对象模拟 DOM 树（1）如何用 JS 对象模拟 DOM 树 例如一个真实的 DOM 节点如下： 123456789&lt;div id=\"virtual-dom\"&gt;&lt;p&gt;Virtual DOM&lt;/p&gt;&lt;ul id=\"list\"&gt; &lt;li class=\"item\"&gt;Item 1&lt;/li&gt; &lt;li class=\"item\"&gt;Item 2&lt;/li&gt; &lt;li class=\"item\"&gt;Item 3&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;Hello World&lt;/div&gt;&lt;/div&gt; 我们用 JavaScript 对象来表示 DOM 节点，使用对象的属性记录节点的类型、属性、子节点等。 element.js 中表示节点对象代码如下： 1234567891011121314151617181920212223242526272829303132/** * Element virdual-dom 对象定义 * @param &#123;String&#125; tagName - dom 元素名称 * @param &#123;Object&#125; props - dom 属性 * @param &#123;Array&lt;Element|String&gt;&#125; - 子节点 */function Element(tagName, props, children) &#123; this.tagName = tagName this.props = props this.children = children // dom 元素的 key 值，用作唯一标识符 if(props.key)&#123; this.key = props.key &#125; var count = 0 children.forEach(function (child, i) &#123; if (child instanceof Element) &#123; count += child.count &#125; else &#123; children[i] = '' + child &#125; count++ &#125;) // 子元素个数 this.count = count&#125;function createElement(tagName, props, children)&#123; return new Element(tagName, props, children);&#125;module.exports = createElement; 根据 element 对象的设定，则上面的 DOM 结构就可以简单表示为： 12345678910var el = require(\"./element.js\");var ul = el('div',&#123;id:'virtual-dom'&#125;,[ el('p',&#123;&#125;,['Virtual DOM']), el('ul', &#123; id: 'list' &#125;, [ el('li', &#123; class: 'item' &#125;, ['Item 1']), el('li', &#123; class: 'item' &#125;, ['Item 2']), el('li', &#123; class: 'item' &#125;, ['Item 3']) ]), el('div',&#123;&#125;,['Hello World'])]) 现在 ul 就是我们用 JavaScript 对象表示的 DOM 结构，我们输出查看 ul 对应的数据结构如下： 12.png （2）渲染用 JS 表示的 DOM 对象 但是页面上并没有这个结构，下一步我们介绍如何将 ul 渲染成页面上真实的 DOM 结构，相关渲染函数如下： 123456789101112131415161718192021/** * render 将virdual-dom 对象渲染为实际 DOM 元素 */Element.prototype.render = function () &#123; var el = document.createElement(this.tagName) var props = this.props // 设置节点的DOM属性 for (var propName in props) &#123; var propValue = props[propName] el.setAttribute(propName, propValue) &#125; var children = this.children || [] children.forEach(function (child) &#123; var childEl = (child instanceof Element) ? child.render() // 如果子节点也是虚拟DOM，递归构建DOM节点 : document.createTextNode(child) // 如果字符串，只构建文本节点 el.appendChild(childEl) &#125;) return el&#125; 我们通过查看以上 render 方法，会根据 tagName 构建一个真正的 DOM 节点，然后设置这个节点的属性，最后递归地把自己的子节点也构建起来。 我们将构建好的 DOM 结构添加到页面 body 上面，如下： 12ulRoot = ul.render();document.body.appendChild(ulRoot); 这样，页面 body 里面就有真正的 DOM 结构，效果如下图所示： 2.png 2.2.2、比较两棵虚拟 DOM 树的差异 — diff 算法diff 算法用来比较两棵 Virtual DOM 树的差异，如果需要两棵树的完全比较，那么 diff 算法的时间复杂度为O(n^3)。但是在前端当中，你很少会跨越层级地移动 DOM 元素，所以 Virtual DOM 只会对同一个层级的元素进行对比，如下图所示， div 只会和同一层级的 div 对比，第二层级的只会跟第二层级对比，这样算法复杂度就可以达到 O(n)。 3.png （1）深度优先遍历，记录差异 在实际的代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记： 在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。 1234567891011121314151617181920212223242526272829303132333435363738394041// diff 函数，对比两棵树function diff(oldTree, newTree) &#123; var index = 0 // 当前节点的标志 var patches = &#123;&#125; // 用来记录每个节点差异的对象 dfsWalk(oldTree, newTree, index, patches) return patches&#125;// 对两棵树进行深度优先遍历function dfsWalk(oldNode, newNode, index, patches) &#123; var currentPatch = [] if (typeof (oldNode) === \"string\" &amp;&amp; typeof (newNode) === \"string\") &#123; // 文本内容改变 if (newNode !== oldNode) &#123; currentPatch.push(&#123; type: patch.TEXT, content: newNode &#125;) &#125; &#125; else if (newNode!=null &amp;&amp; oldNode.tagName === newNode.tagName &amp;&amp; oldNode.key === newNode.key) &#123; // 节点相同，比较属性 var propsPatches = diffProps(oldNode, newNode) if (propsPatches) &#123; currentPatch.push(&#123; type: patch.PROPS, props: propsPatches &#125;) &#125; // 比较子节点，如果子节点有'ignore'属性，则不需要比较 if (!isIgnoreChildren(newNode)) &#123; diffChildren( oldNode.children, newNode.children, index, patches, currentPatch ) &#125; &#125; else if(newNode !== null)&#123; // 新节点和旧节点不同，用 replace 替换 currentPatch.push(&#123; type: patch.REPLACE, node: newNode &#125;) &#125; if (currentPatch.length) &#123; patches[index] = currentPatch &#125;&#125; 从以上可以得出，patches[1] 表示 p ，patches[3] 表示 ul ，以此类推。 （2）差异类型 DOM 操作导致的差异类型包括以下几种： 节点替换：节点改变了，例如将上面的 div 换成 h1; 顺序互换：移动、删除、新增子节点，例如上面 div 的子节点，把 p 和 ul 顺序互换； 属性更改：修改了节点的属性，例如把上面 li 的 class 样式类删除； 文本改变：改变文本节点的文本内容，例如将上面 p 节点的文本内容更改为 “Real Dom”； 以上描述的几种差异类型在代码中定义如下所示： 1234var REPLACE = 0 // 替换原先的节点var REORDER = 1 // 重新排序var PROPS = 2 // 修改了节点的属性var TEXT = 3 // 文本内容改变 （3）列表对比算法 ​ 子节点的对比算法，例如 p, ul, div 的顺序换成了 div, p, ul。这个该怎么对比？如果按照同层级进行顺序对比的话，它们都会被替换掉。如 p 和 div 的 tagName 不同，p 会被 div 所替代。最终，三个节点都会被替换，这样 DOM 开销就非常大。而实际上是不需要替换节点，而只需要经过节点移动就可以达到，我们只需知道怎么进行移动。 ​ 将这个问题抽象出来其实就是字符串的最小编辑距离问题（Edition Distance），最常见的解决方法是 Levenshtein Distance , Levenshtein Distance 是一个度量两个字符序列之间差异的字符串度量标准，两个单词之间的 Levenshtein Distance 是将一个单词转换为另一个单词所需的单字符编辑（插入、删除或替换）的最小数量。Levenshtein Distance 是1965年由苏联数学家 Vladimir Levenshtein 发明的。Levenshtein Distance 也被称为编辑距离（Edit Distance），通过动态规划求解，时间复杂度为 O(M*N)。 定义：对于两个字符串 a、b，则他们的 Levenshtein Distance 为： 5.png 示例：字符串 a 和 b，a=“abcde” ，b=“cabef”，根据上面给出的计算公式，则他们的 Levenshtein Distance 的计算过程如下： 6.png 本文的 demo 使用插件 list-diff2 算法进行比较，该算法的时间复杂度伟 O(n*m)，虽然该算法并非最优的算法，但是用于对于 dom 元素的常规操作是足够的。该算法具体的实现过程这里不再详细介绍，该算法的具体介绍可以参照：https://github.com/livoras/list-diff （4）实例输出 两个虚拟 DOM 对象如下图所示，其中 ul1 表示原有的虚拟 DOM 树，ul2 表示改变后的虚拟 DOM 树 12345678910111213141516171819var ul1 = el('div',&#123;id:'virtual-dom'&#125;,[ el('p',&#123;&#125;,['Virtual DOM']), el('ul', &#123; id: 'list' &#125;, [ el('li', &#123; class: 'item' &#125;, ['Item 1']), el('li', &#123; class: 'item' &#125;, ['Item 2']), el('li', &#123; class: 'item' &#125;, ['Item 3']) ]), el('div',&#123;&#125;,['Hello World'])]) var ul2 = el('div',&#123;id:'virtual-dom'&#125;,[ el('p',&#123;&#125;,['Virtual DOM']), el('ul', &#123; id: 'list' &#125;, [ el('li', &#123; class: 'item' &#125;, ['Item 21']), el('li', &#123; class: 'item' &#125;, ['Item 23']) ]), el('p',&#123;&#125;,['Hello World'])]) var patches = diff(ul1,ul2);console.log('patches:',patches); 我们查看输出的两个虚拟 DOM 对象之间的差异对象如下图所示，我们能通过差异对象得到，两个虚拟 DOM 对象之间进行了哪些变化，从而根据这个差异对象（patches）更改原先的真实 DOM 结构，从而将页面的 DOM 结构进行更改。 7 2.2.3、将两个虚拟 DOM 对象的差异应用到真正的 DOM 树（1）深度优先遍历 DOM 树 ​ 因为步骤一所构建的 JavaScript 对象树和 render 出来真正的 DOM 树的信息、结构是一样的。所以我们可以对那棵 DOM 树也进行深度优先的遍历，遍历的时候从步骤二生成的 patches 对象中找出当前遍历的节点差异，如下相关代码所示： 1234567891011121314151617181920212223function patch (node, patches) &#123; var walker = &#123;index: 0&#125; dfsWalk(node, walker, patches)&#125;function dfsWalk (node, walker, patches) &#123; // 从patches拿出当前节点的差异 var currentPatches = patches[walker.index] var len = node.childNodes ? node.childNodes.length : 0 // 深度遍历子节点 for (var i = 0; i &lt; len; i++) &#123; var child = node.childNodes[i] walker.index++ dfsWalk(child, walker, patches) &#125; // 对当前节点进行DOM操作 if (currentPatches) &#123; applyPatches(node, currentPatches) &#125;&#125; （2）对原有 DOM 树进行 DOM 操作 我们根据不同类型的差异对当前节点进行不同的 DOM 操作 ，例如如果进行了节点替换，就进行节点替换 DOM 操作；如果节点文本发生了改变，则进行文本替换的 DOM 操作；以及子节点重排、属性改变等 DOM 操作，相关代码如 applyPatches 所示 ： 1234567891011121314151617181920212223function applyPatches (node, currentPatches) &#123; currentPatches.forEach(currentPatch =&gt; &#123; switch (currentPatch.type) &#123; case REPLACE: var newNode = (typeof currentPatch.node === 'string') ? document.createTextNode(currentPatch.node) : currentPatch.node.render() node.parentNode.replaceChild(newNode, node) break case REORDER: reorderChildren(node, currentPatch.moves) break case PROPS: setProps(node, currentPatch.props) break case TEXT: node.textContent = currentPatch.content break default: throw new Error('Unknown patch type ' + currentPatch.type) &#125; &#125;)&#125; （3）DOM结构改变 通过将第 2.2.2 得到的两个 DOM 对象之间的差异，应用到第一个（原先）DOM 结构中，我们可以看到 DOM 结构进行了预期的变化，如下图所示： 8.png 2.3、结语Virtual DOM 算法主要实现上面三个步骤来实现： 用 JS 对象模拟 DOM 树 — element.js 123456789&lt;div id=\"virtual-dom\"&gt;&lt;p&gt;Virtual DOM&lt;/p&gt;&lt;ul id=\"list\"&gt; &lt;li class=\"item\"&gt;Item 1&lt;/li&gt; &lt;li class=\"item\"&gt;Item 2&lt;/li&gt; &lt;li class=\"item\"&gt;Item 3&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;Hello World&lt;/div&gt;&lt;/div&gt; 比较两棵虚拟 DOM 树的差异 — diff.js 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树 — patch.js 1234567891011121314151617181920212223function applyPatches (node, currentPatches) &#123; currentPatches.forEach(currentPatch =&gt; &#123; switch (currentPatch.type) &#123; case REPLACE: var newNode = (typeof currentPatch.node === 'string') ? document.createTextNode(currentPatch.node) : currentPatch.node.render() node.parentNode.replaceChild(newNode, node) break case REORDER: reorderChildren(node, currentPatch.moves) break case PROPS: setProps(node, currentPatch.props) break case TEXT: node.textContent = currentPatch.content break default: throw new Error('Unknown patch type ' + currentPatch.type) &#125; &#125;)&#125; 三、Vue 源码 Virtual-DOM 简析我们从第二章节（Virtual-DOM 基础）中已经掌握 Virtual DOM 渲染成真实的 DOM 实际上要经历 VNode 的定义、diff、patch 等过程，所以本章节 Vue 源码的解析也按这几个过程来简析。 3.1、VNode 模拟 DOM 树3.1.1、VNode 类简析在 Vue.js 中，Virtual DOM 是用 VNode 这个 Class 去描述，它定义在 src/core/vdom/vnode.js 中 ，从以下代码块中可以看到 Vue.js 中的 Virtual DOM 的定义较为复杂一些，因为它这里包含了很多 Vue.js 的特性。实际上 Vue.js 中 Virtual DOM 是借鉴了一个开源库 snabbdom 的实现，然后加入了一些 Vue.js 的一些特性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364export default class VNode &#123; tag: string | void; data: VNodeData | void; children: ?Array&lt;VNode&gt;; text: string | void; elm: Node | void; ns: string | void; context: Component | void; // rendered in this component's scope key: string | number | void; componentOptions: VNodeComponentOptions | void; componentInstance: Component | void; // component instance parent: VNode | void; // component placeholder node // strictly internal raw: boolean; // contains raw HTML? (server only) isStatic: boolean; // hoisted static node isRootInsert: boolean; // necessary for enter transition check isComment: boolean; // empty comment placeholder? isCloned: boolean; // is a cloned node? isOnce: boolean; // is a v-once node? asyncFactory: Function | void; // async component factory function asyncMeta: Object | void; isAsyncPlaceholder: boolean; ssrContext: Object | void; fnContext: Component | void; // real context vm for functional nodes fnOptions: ?ComponentOptions; // for SSR caching devtoolsMeta: ?Object; // used to store functional render context for devtools fnScopeId: ?string; // functional scope id support constructor ( tag?: string, data?: VNodeData, children?: ?Array&lt;VNode&gt;, text?: string, elm?: Node, context?: Component, componentOptions?: VNodeComponentOptions, asyncFactory?: Function ) &#123; this.tag = tag this.data = data this.children = children this.text = text this.elm = elm this.ns = undefined this.context = context this.fnContext = undefined this.fnOptions = undefined this.fnScopeId = undefined this.key = data &amp;&amp; data.key this.componentOptions = componentOptions this.componentInstance = undefined this.parent = undefined this.raw = false this.isStatic = false this.isRootInsert = true this.isComment = false this.isCloned = false this.isOnce = false this.asyncFactory = asyncFactory this.asyncMeta = undefined this.isAsyncPlaceholder = false &#125;&#125; 这里千万不要因为 VNode 的这么属性而被吓到，或者咬紧牙去摸清楚每个属性的意义，其实，我们主要了解其几个核心的关键属性就差不多了，例如： tag 属性即这个vnode的标签属性 data 属性包含了最后渲染成真实dom节点后，节点上的class，attribute，style以及绑定的事件 children 属性是vnode的子节点 text 属性是文本属性 elm 属性为这个vnode对应的真实dom节点 key 属性是vnode的标记，在diff过程中可以提高diff的效率 3.1.2、源码创建 VNode 过程*（1）初始化 vue * 我们在实例化一个 vue 实例，也即 new Vue( ) 时，实际上是执行 src/core/instance/index.js 中定义的 Function 函数。 12345678function Vue (options) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) &#123; warn('Vue is a constructor and should be called with the `new` keyword') &#125; this._init(options)&#125; 通过查看 Vue 的 function，我们知道 Vue 只能通过 new 关键字初始化，然后调用 this._init 方法，该方法在 src/core/instance/init.js 中定义。 12345678910Vue.prototype._init = function (options?: Object) &#123; const vm: Component = this // 省略一系列其它初始化的代码 if (vm.$options.el) &#123; console.log('vm.$options.el:',vm.$options.el); vm.$mount(vm.$options.el) &#125;&#125; （2）Vue 实例挂载 Vue 中是通过 $mount 实例方法去挂载 dom 的，下面我们通过分析 compiler 版本的 mount 实现，相关源码在目录 src/platforms/web/entry-runtime-with-compiler.js 文件中定义：。 1234567891011const mount = Vue.prototype.$mountVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; query(el) // 省略一系列初始化以及逻辑判断代码 return mount.call(this, el, hydrating)&#125; 我们发现最终还是调用用原先原型上的 $mount 方法挂载 ，原先原型上的 $mount 方法在 src/platforms/web/runtime/index.js 中定义 。 1234567Vue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined return mountComponent(this, el, hydrating)&#125; 我们发现$mount 方法实际上会去调用 mountComponent 方法，这个方法定义在 src/core/instance/lifecycle.js 文件中 1234567891011121314151617181920212223242526272829303132333435export function mountComponent ( vm: Component, el: ?Element, hydrating?: boolean): Component &#123; vm.$el = el // 省略一系列其它代码 let updateComponent /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; updateComponent = () =&gt; &#123; // 生成虚拟 vnode const vnode = vm._render() // 更新 DOM vm._update(vnode, hydrating) &#125; &#125; else &#123; updateComponent = () =&gt; &#123; vm._update(vm._render(), hydrating) &#125; &#125; // 实例化一个渲染Watcher，在它的回调函数中会调用 updateComponent 方法 new Watcher(vm, updateComponent, noop, &#123; before () &#123; if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, 'beforeUpdate') &#125; &#125; &#125;, true /* isRenderWatcher */) hydrating = false return vm&#125; 从上面的代码可以看到，mountComponent 核心就是先实例化一个渲染Watcher，在它的回调函数中会调用 updateComponent 方法，在此方法中调用 vm._render 方法先生成虚拟 Node，最终调用 vm._update 更新 DOM。 （3）创建虚拟 Node Vue 的 _render 方法是实例的一个私有方法，它用来把实例渲染成一个虚拟 Node。它的定义在 src/core/instance/render.js 文件中： 1234567891011121314151617Vue.prototype._render = function (): VNode &#123; const vm: Component = this const &#123; render, _parentVnode &#125; = vm.$options let vnode try &#123; // 省略一系列代码 currentRenderingInstance = vm // 调用 createElement 方法来返回 vnode vnode = render.call(vm._renderProxy, vm.$createElement) &#125; catch (e) &#123; handleError(e, vm, `render`)&#123;&#125; &#125; // set parent vnode.parent = _parentVnode console.log(\"vnode...:\",vnode); return vnode &#125; Vue.js 利用 _createElement 方法创建 VNode，它定义在 src/core/vdom/create-elemenet.js 中： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849export function _createElement ( context: Component, tag?: string | Class&lt;Component&gt; | Function | Object, data?: VNodeData, children?: any, normalizationType?: number): VNode | Array&lt;VNode&gt; &#123; // 省略一系列非主线代码 if (normalizationType === ALWAYS_NORMALIZE) &#123; // 场景是 render 函数不是编译生成的 children = normalizeChildren(children) &#125; else if (normalizationType === SIMPLE_NORMALIZE) &#123; // 场景是 render 函数是编译生成的 children = simpleNormalizeChildren(children) &#125; let vnode, ns if (typeof tag === 'string') &#123; let Ctor ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag) if (config.isReservedTag(tag)) &#123; // 创建虚拟 vnode vnode = new VNode( config.parsePlatformTagName(tag), data, children, undefined, undefined, context ) &#125; else if ((!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, 'components', tag))) &#123; // component vnode = createComponent(Ctor, data, context, children, tag) &#125; else &#123; vnode = new VNode( tag, data, children, undefined, undefined, context ) &#125; &#125; else &#123; vnode = createComponent(tag, data, context, children) &#125; if (Array.isArray(vnode)) &#123; return vnode &#125; else if (isDef(vnode)) &#123; if (isDef(ns)) applyNS(vnode, ns) if (isDef(data)) registerDeepBindings(data) return vnode &#125; else &#123; return createEmptyVNode() &#125;&#125; _createElement 方法有 5 个参数，context 表示 VNode 的上下文环境，它是 Component 类型；tag表示标签，它可以是一个字符串，也可以是一个 Component；data 表示 VNode 的数据，它是一个 VNodeData 类型，可以在 flow/vnode.js 中找到它的定义；children 表示当前 VNode 的子节点，它是任意类型的，需要被规范为标准的 VNode 数组； 3.1.3、实例查看为了更直观查看我们平时写的 Vue 代码如何用 VNode 类来表示，我们通过一个实例的转换进行更深刻了解。 例如，实例化一个 Vue 实例： 1234567891011121314var app = new Vue(&#123; el: '#app', render: function (createElement) &#123; return createElement('div', &#123; attrs: &#123; id: 'app', class: \"class_box\" &#125;, &#125;, this.message) &#125;, data: &#123; message: 'Hello Vue!' &#125;&#125;) 我们打印出其对应的 VNode 表示： 10.png 3.2、diff 过程3.2.1、Vue.js 源码的 diff 调用逻辑Vue.js 源码实例化了一个 watcher，这个 ~ 被添加到了在模板当中所绑定变量的依赖当中，一旦 model 中的响应式的数据发生了变化，这些响应式的数据所维护的 dep 数组便会调用 dep.notify() 方法完成所有依赖遍历执行的工作，这包括视图的更新，即 updateComponent 方法的调用。watcher 和 updateComponent方法定义在 src/core/instance/lifecycle.js 文件中 。 1234567891011121314151617181920212223242526272829303132333435export function mountComponent ( vm: Component, el: ?Element, hydrating?: boolean): Component &#123; vm.$el = el // 省略一系列其它代码 let updateComponent /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; updateComponent = () =&gt; &#123; // 生成虚拟 vnode const vnode = vm._render() // 更新 DOM vm._update(vnode, hydrating) &#125; &#125; else &#123; updateComponent = () =&gt; &#123; vm._update(vm._render(), hydrating) &#125; &#125; // 实例化一个渲染Watcher，在它的回调函数中会调用 updateComponent 方法 new Watcher(vm, updateComponent, noop, &#123; before () &#123; if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, 'beforeUpdate') &#125; &#125; &#125;, true /* isRenderWatcher */) hydrating = false return vm&#125; 完成视图的更新工作事实上就是调用了vm._update方法，这个方法接收的第一个参数是刚生成的Vnode，调用的vm._update方法定义在 src/core/instance/lifecycle.js中。 1234567891011121314151617181920212223242526Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123; const vm: Component = this const prevEl = vm.$el const prevVnode = vm._vnode const restoreActiveInstance = setActiveInstance(vm) vm._vnode = vnode if (!prevVnode) &#123; // 第一个参数为真实的node节点，则为初始化 vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) &#125; else &#123; // 如果需要diff的prevVnode存在，那么对prevVnode和vnode进行diff vm.$el = vm.__patch__(prevVnode, vnode) &#125; restoreActiveInstance() // update __vue__ reference if (prevEl) &#123; prevEl.__vue__ = null &#125; if (vm.$el) &#123; vm.$el.__vue__ = vm &#125; // if parent is an HOC, update its $el as well if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123; vm.$parent.$el = vm.$el &#125;&#125; 在这个方法当中最为关键的就是 vm.__patch__ 方法，这也是整个 virtual-dom 当中最为核心的方法，主要完成了prevVnode 和 vnode 的 diff 过程并根据需要操作的 vdom 节点打 patch，最后生成新的真实 dom 节点并完成视图的更新工作。 接下来，让我们看下 vm.__patch__的逻辑过程， vm.__patch__ 方法定义在 src/core/vdom/patch.js 中。 12345678910111213141516function patch (oldVnode, vnode, hydrating, removeOnly) &#123; ...... if (isUndef(oldVnode)) &#123; // 当oldVnode不存在时，创建新的节点 isInitialPatch = true createElm(vnode, insertedVnodeQueue) &#125; else &#123; // 对oldVnode和vnode进行diff，并对oldVnode打patch const isRealElement = isDef(oldVnode.nodeType) if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123; // patch existing root node patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly) &#125; ...... &#125;&#125; 在 patch 方法中，我们看到会分为两种情况，一种是当 oldVnode 不存在时，会创建新的节点；另一种则是已经存在 oldVnode ，那么会对 oldVnode 和 vnode 进行 diff 及 patch 的过程。其中 patch 过程中会调用 sameVnode 方法来对对传入的2个 vnode 进行基本属性的比较，只有当基本属性相同的情况下才认为这个2个vnode 只是局部发生了更新，然后才会对这2个 vnode 进行 diff，如果2个 vnode 的基本属性存在不一致的情况，那么就会直接跳过 diff 的过程，进而依据 vnode 新建一个真实的 dom，同时删除老的 dom节点。 123456789function sameVnode (a, b) &#123; return ( a.key === b.key &amp;&amp; a.tag === b.tag &amp;&amp; a.isComment === b.isComment &amp;&amp; isDef(a.data) === isDef(b.data) &amp;&amp; sameInputType(a, b) )&#125; diff 过程中主要是通过调用 patchVnode 方法进行的: 12345678910111213141516171819202122232425262728293031function patchVnode (oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) &#123; ...... const elm = vnode.elm = oldVnode.elm const oldCh = oldVnode.children const ch = vnode.children // 如果vnode没有文本节点 if (isUndef(vnode.text)) &#123; // 如果oldVnode的children属性存在且vnode的children属性也存在 if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123; // updateChildren，对子节点进行diff if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly) &#125; else if (isDef(ch)) &#123; if (process.env.NODE_ENV !== 'production') &#123; checkDuplicateKeys(ch) &#125; // 如果oldVnode的text存在，那么首先清空text的内容,然后将vnode的children添加进去 if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '') addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue) &#125; else if (isDef(oldCh)) &#123; // 删除elm下的oldchildren removeVnodes(elm, oldCh, 0, oldCh.length - 1) &#125; else if (isDef(oldVnode.text)) &#123; // oldVnode有子节点，而vnode没有，那么就清空这个节点 nodeOps.setTextContent(elm, '') &#125; &#125; else if (oldVnode.text !== vnode.text) &#123; // 如果oldVnode和vnode文本属性不同，那么直接更新真是dom节点的文本元素 nodeOps.setTextContent(elm, vnode.text) &#125; ......&#125; 从以上代码得知， diff 过程中又分了好几种情况，oldCh 为 oldVnode的子节点，ch 为 Vnode的子节点： 首先进行文本节点的判断，若 oldVnode.text !== vnode.text，那么就会直接进行文本节点的替换； 在vnode 没有文本节点的情况下，进入子节点的 diff； 当 oldCh 和 ch 都存在且不相同的情况下，调用 updateChildren 对子节点进行 diff； 若 oldCh不存在，ch 存在，首先清空 oldVnode 的文本节点，同时调用 addVnodes 方法将 ch 添加到elm真实 dom 节点当中； 若 oldCh存在，ch不存在，则删除 elm 真实节点下的 oldCh 子节点； 若 oldVnode 有文本节点，而 vnode 没有，那么就清空这个文本节点。 3.2.2、子节点 diff 流程分析（1）Vue.js 源码 ​ 这里着重分析下updateChildren方法，它也是整个 diff 过程中最重要的环节，以下为 Vue.js 的源码过程，为了更形象理解 diff 过程，我们给出相关的示意图来讲解。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123; // 为oldCh和newCh分别建立索引，为之后遍历的依据 let oldStartIdx = 0 let newStartIdx = 0 let oldEndIdx = oldCh.length - 1 let oldStartVnode = oldCh[0] let oldEndVnode = oldCh[oldEndIdx] let newEndIdx = newCh.length - 1 let newStartVnode = newCh[0] let newEndVnode = newCh[newEndIdx] let oldKeyToIdx, idxInOld, vnodeToMove, refElm // 直到oldCh或者newCh被遍历完后跳出循环 while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if (isUndef(oldStartVnode)) &#123; oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left &#125; else if (isUndef(oldEndVnode)) &#123; oldEndVnode = oldCh[--oldEndIdx] &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx] &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123; patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx] &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx) canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm)) oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx] &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm) oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx] &#125; else &#123; if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx) if (isUndef(idxInOld)) &#123; // New element createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx) &#125; else &#123; vnodeToMove = oldCh[idxInOld] if (sameVnode(vnodeToMove, newStartVnode)) &#123; patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) oldCh[idxInOld] = undefined canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm) &#125; else &#123; // same key but different element. treat as new element createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx) &#125; &#125; newStartVnode = newCh[++newStartIdx] &#125; &#125; if (oldStartIdx &gt; oldEndIdx) &#123; refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue) &#125; else if (newStartIdx &gt; newEndIdx) &#123; removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx) &#125;&#125; 在开始遍历 diff 前，首先给 oldCh和 newCh 分别分配一个 startIndex 和 endIndex 来作为遍历的索引，当oldCh 或者 newCh 遍历完后(遍历完的条件就是 oldCh 或者 newCh 的 startIndex &gt;= endIndex )，就停止oldCh 和 newCh 的 diff 过程。接下来通过实例来看下整个 diff 的过程(节点属性中不带 key 的情况)。 （2）无 key 的 diff 过程 我们通过以下示意图对以上代码过程进行讲解： （2.1）首先从第一个节点开始比较，不管是 oldCh 还是 newCh 的起始或者终止节点都不存在 sameVnode ，同时节点属性中是不带 key标记的，因此第一轮的 diff 完后，newCh的 startVnode 被添加到 oldStartVnode的前面，同时 newStartIndex前移一位； （2.2）第二轮的 diff中，满足 sameVnode(oldStartVnode, newStartVnode)，因此对这2个 vnode 进行diff，最后将 patch 打到 oldStartVnode 上，同时 oldStartVnode和 newStartIndex 都向前移动一位 ； 12.jpg （2.3）第三轮的 diff 中，满足 sameVnode(oldEndVnode, newStartVnode)，那么首先对 oldEndVnode和newStartVnode 进行 diff，并对 oldEndVnode进行 patch，并完成 oldEndVnode 移位的操作，最后newStartIndex前移一位，oldStartVnode 后移一位； （2.4）第四轮的 diff中，过程同步骤3； （2.5）第五轮的 diff 中，同过程1； （2.6）遍历的过程结束后，newStartIdx &gt; newEndIdx，说明此时 oldCh 存在多余的节点，那么最后就需要将这些多余的节点删除。 （3）有 key 的 diff 流程 在 vnode 不带 key 的情况下，每一轮的 diff 过程当中都是起始和结束节点进行比较，直到 oldCh 或者newCh 被遍历完。而当为 vnode 引入 key 属性后，在每一轮的 diff 过程中，当起始和结束节点都没有找到sameVnode 时，然后再判断在 newStartVnode 的属性中是否有 key，且是否在 oldKeyToIndx 中找到对应的节点 ： 如果不存在这个 key，那么就将这个 newStartVnode作为新的节点创建且插入到原有的 root 的子节点中； 如果存在这个 key，那么就取出 oldCh 中的存在这个 key 的 vnode，然后再进行 diff 的过； 通过以上分析，给vdom上添加 key属性后，遍历 diff 的过程中，当起始点，结束点的搜寻及 diff 出现还是无法匹配的情况下时，就会用 key 来作为唯一标识，来进行 diff，这样就可以提高 diff 效率。 带有 Key属性的 vnode的 diff 过程可见下图： （3.1）首先从第一个节点开始比较，不管是 oldCh 还是 newCh 的起始或者终止节点都不存在 sameVnode，但节点属性中是带 key 标记的， 然后在 oldKeyToIndx 中找到对应的节点，这样第一轮 diff 过后 oldCh 上的B节点被删除了，但是 newCh 上的B节点上 elm 属性保持对 oldCh 上 B节点 的elm引用。 （3.2）第二轮的 diff 中，满足 sameVnode(oldStartVnode, newStartVnode)，因此对这2个 vnode 进行diff，最后将 patch 打到 oldStartVnode上，同时 oldStartVnode 和 newStartIndex 都向前移动一位 ； 18.jpg （3.3）第三轮的 diff中，满足 sameVnode(oldEndVnode, newStartVnode)，那么首先对 oldEndVnode 和newStartVnode 进行 diff，并对 oldEndVnode 进行 patch，并完成 oldEndVnode 移位的操作，最后newStartIndex 前移一位，oldStartVnode后移一位； （3.4）第四轮的diff中，过程同步骤2； （3.5）第五轮的diff中，因为此时 oldStartIndex 已经大于 oldEndIndex，所以将剩余的 Vnode 队列插入队列最后。 21.jpg 3.3、patch 过程通过3.2章节介绍的 diff 过程中，我们会看到 nodeOps 相关的方法对真实 DOM 结构进行操作，nodeOps 定义在 src/platforms/web/runtime/node-ops.js 中，其为基本 DOM 操作，这里就不在详细介绍。 12345678910111213141516171819export function createElementNS (namespace: string, tagName: string): Element &#123; return document.createElementNS(namespaceMap[namespace], tagName)&#125;export function createTextNode (text: string): Text &#123; return document.createTextNode(text)&#125;export function createComment (text: string): Comment &#123; return document.createComment(text)&#125;export function insertBefore (parentNode: Node, newNode: Node, referenceNode: Node) &#123; parentNode.insertBefore(newNode, referenceNode)&#125;export function removeChild (node: Node, child: Node) &#123; node.removeChild(child)&#125; 3.4、总结通过前三小节简析，我们从主线上把模板和数据如何渲染成最终的 DOM 的过程分析完毕了，我们可以通过下图更直观地看到从初始化 Vue 到最终渲染的整个过程。 四、总结本文从通过介绍真实 DOM 结构其解析过程以及存在的问题，从而引出为什么需要虚拟 DOM；然后分析虚拟DOM 的好处，以及其一些理论基础和基础算法的实现；最后根据我们已经掌握的基础知识，再一步步去查看Vue.js 的源码如何实现的。从存在问题 —&gt; 理论基础 —&gt; 具体实践，一步步深入，帮助大家更好的了解什么是Virtual DOM、为什么需要 Virtual DOM、以及 Virtual DOM的具体实现，希望本文对您有帮助。 辛苦编写良久，如果对你有帮助，还望手动点赞鼓励~ github地址为：github.com/fengshi123/…，上面汇总了作者所有的博客文章，如果喜欢或者有所启发，请帮忙给个 star ~，对作者也是一种鼓励。 参考文献1、Vue 技术揭秘：https://ustbhuangyi.github.io/vue-analysis/ 2、深度剖析：如何实现一个 Virtual DOM 算法：https://segmentfault.com/a/1190000004029168 3、vue核心之虚拟DOM(vdom)：https://www.jianshu.com/p/af0b398602bc 4、virtual-dom(Vue实现)简析：https://segmentfault.com/a/1190000010090659","categories":[{"name":"前端文章","slug":"前端文章","permalink":"https://qw8.github.io/categories/前端文章/"}],"tags":[{"name":"虚拟DOM","slug":"虚拟DOM","permalink":"https://qw8.github.io/tags/虚拟DOM/"}]},{"title":"Nodejs","slug":"articles/Nodejs","date":"2023-11-18T16:00:00.000Z","updated":"2024-02-18T02:46:06.000Z","comments":true,"path":"/articles/nodejs.html","link":"","permalink":"https://qw8.github.io/articles/nodejs.html","excerpt":"","text":"从零开始nodejs系列文章，将介绍如何利Javascript做为服务端脚本，通过Nodejs框架web开发。Nodejs框架是基于V8的引擎，是目前速度最快的Javascript引擎。chrome浏览器就基于V8，同时打开20-30个网页都很流畅。Nodejs标准的web开发框架Express，可以帮助我们迅速建立web站点，比起PHP的开发效率更高，而且学习曲线更低。非常适合小型网站，个性化网站，我们自己的Geek网站！！ 首先来说，nodeJs是前端全栈的基石，它的应用场景已经从前端工具的脚手架、辅助工具类，发展到api中间层、代理层，以及专业的后端开发。 这其中最有价值的就是api中间层。现在的大趋势是越来越多的业务被推到前端，后端专注于只提供服务。很典型且常见的工作场景就是，前后端协作的时候，因为进度不同有时前端需要等后端的接口。 这种时候，nodeJs的中间层应用就可以很好的解决这个问题。前端通过nodeJs可以自己约定数据的格式，根据前端的需求定制自己的接口，自己封装对数据库的crud操作，创建自己的代理和网关服务器等。这些事情在以往只能是等着后端做，但现在通过nodeJs前端都可以自己搞定，这就使得工作的过程更加可控。 当然了这也对前端开发人员提出了更高的要求，至少数据库、架构设计、系统结构 、网络应用这些短板都需要慢慢补齐。 据说啊我也不确定，nodeJs最开始是给后端搞的，只不过为了简单、异步、大并发而选择了Java语言，阴差阳错之下被前端发现并发扬光大。 所以前端搞nodeJs必然是向后端侵蚀，而后端的开发结构、技术栈已经很完整了，所以后端一般不愿意变动，所以很多时候对于nodeJs的阻力，其实是来源于后端的保守。当然这也是有一定道理的，因为后端主要是服务、数据、底层应用，这些东西都求稳、求安全、还有些历史遗留问题，所以它们不喜欢新东西。 所以在现阶段吧，很多nodeJs的应用都是处于前端和后端之间的桥梁。一般来讲，没有什么历史包袱的新公司啊，创业公司啊，孵化项目之类的更愿意使用nodeJs，快速、高效嘛。 现在基本上所有的前端应用都有nodeJs的影子，什么React、vue、angular等，它的应用场景和就业市场也都很大，所以nodeJs的学习不是让你可以做什么，而是让你多了一个施展的空间。 NodeJs的优势和适合开发的程序做页游或webqq这样的应用nodejs有优势，但如果做微博、豆瓣、facebook这样的社交网络，nodejs还有优势吗？另外不知道大家是什么原因选择的nodejs？是因为应用需求还是对javascript这门语言的喜欢？ 很多同学可能都听说过nodejs，并且知道他是可以运行在服务器上的javascript，但是他的使用场景可能大家并不是很清楚，最近也在看学习nodejs，就做了一下小总结； NodeJs的优势： 现在的很多的服务器端的语言（PHP,JAVA,ASP.net）,有什么问题呢，现在的服务器端的语言在用户访问服务器时，为每个用户链接创建了一个线程，但每个线程大约要耗费2M的内存，如果一个8G内存的服务器，也就能链接4000个左右的用户，如果用户的链接数较大，就必须增加服务器的数量，而且现在用户的链接方式有很多（如app，网页同时访问），这就又涉及到服务器共享的问题，所以服务器怎么支持最大的同时链接用户量就成了一个问题； NodeJS修改了客户端到服务器端的链接方法，解决了这个问题，他不在为每个客户端创建一个新的线程，而是为每个客户端链接出发一个NodeJs内部进行处理的事件，所以NodeJS具备同时处理多达几万个用户的客户端链接的能力； NodeJS适合开发的应用程序： 当应用程序需要处理大量并发的输入/输出，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，我们应该考虑使用NodeJs来进行应用程序的开发，例如： 1、聊天服务器：如果聊天的人很多，用户的与服务器之间的并发链接量很大，但是服务器端的数据处理并不复杂； 2、综合类服务网站和电子商务网站的服务器：在这类网站中的服务器端，往往可能每秒存内可以接受多达上千条的数据并且需要将这些数据写入数据库中，NodeJs可以通过其队列机制将这些数据迅速写入缓存区中，然后再通过每一个单独的处理从缓存区中取出这些数据并将其写入数据库中，如果是其他的服务器（如Apache服务器或Tomcat服务器）的话，由于这些服务器采用的是阻塞型I/O机制，因此每条数据写入到数据库中都要等待一段时间（等上一条写完，才能写下一条），但是NodeJs使用的是非阻塞的I/O机制，因此可以实现这些数据到数据库中的写入，而不必再为每条数据的写入而等待一段时间； 总结： 一个规模稍微大点的系统都不是一种开发语言可以搞定的，往往是几种混杂一起，比如c、c++做服务器端开发，java做业务逻辑，php等做前端展示，此外还需要消息中间件等等。 nodejs可以很快地在服务器端做原型（原来只有c系和java等能做的事情，性能还很高），而且代码量相对会少很多；另一点是它的语法优势，js闭包等。但它不太适合做cpu密集型处理的工作，只能绕着弯去解决，据说这次QCon会有人分享这方面的研究成果，可以关注下。 每种语言都有它适合的领域，没必要强求一门语言可以解决所有事情，拥有其它语言的特性，只有不断的tradeoff把系统做出来才是目标。","categories":[{"name":"前端文章","slug":"前端文章","permalink":"https://qw8.github.io/categories/前端文章/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://qw8.github.io/tags/Nodejs/"}]},{"title":"JavaScript的33个概念","slug":"articles/JavaScript的33个概念","date":"2023-11-17T16:00:00.000Z","updated":"2024-02-18T02:45:32.000Z","comments":true,"path":"/articles/javascript-de-33-ge-gai-nian.html","link":"","permalink":"https://qw8.github.io/articles/javascript-de-33-ge-gai-nian.html","excerpt":"","text":"","categories":[{"name":"前端文章","slug":"前端文章","permalink":"https://qw8.github.io/categories/前端文章/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qw8.github.io/tags/JavaScript/"}]},{"title":"网站性能优化实战","slug":"articles/网站性能优化实战","date":"2023-11-16T16:00:00.000Z","updated":"2024-02-18T02:45:18.000Z","comments":true,"path":"/articles/wang-zhan-xing-neng-you-hua-shi-zhan.html","link":"","permalink":"https://qw8.github.io/articles/wang-zhan-xing-neng-you-hua-shi-zhan.html","excerpt":"","text":"作为互联网项目，最重要的便是用户体验。在举国“互联网+”的热潮中，用户至上也已经被大多数企业所接收，特别是在如今移动端快速发展的时代，我们的网页不仅只是呈现在用户的PC浏览器里，更多的时候，用户是通过移动产品浏览我们的网页。加之有越来越多的开发者投入到Web APP和Hybrid APP的开发队伍中，性能这一问题又再一次被提上了程序员们重点关注的要素。我曾经看到过这样一句话：一个网站的体验，决定了用户是否愿意去了解网站的功能；而网站的功能，决定了用户是否会一票否决网站的体验。这是改版自网络上的一句流行语，但却把网站性能这件事说的十分透彻，特别是在网站这样的项目中，如果一个用户需要超过5s才能看见页面，他会毫不犹豫地关闭它。性能优化，作为工程师界的“上乘武功”，是我们在开发中老生常谈的话题，也是一名开发者从入门向资深进阶的必经阶段，虽然我们看到过很多的标准、军规，但在真正实践中，却常常力不从心，不知道落下了什么，不知道性能是否还有进一步优化的空间。 对于网站的性能，在行业内有很多既定的指标，但就以前端er而言，我们应该更加关注以下指标：白屏时间、首屏时间、整页时间、DNS时间、CPU占用率。而我之前自己搭建的一个网站（网址：jerryonlyzrj.com/resume/ ，近日因域名备案无法打开，几日后即恢复正常），完全没做性能优化时，首屏时间是12.67s，最后经过多方面优化，终于将其降低至1.06s，并且还未配置CDN加速。其中过程我踩了很多坑，也翻了许多专业书籍，最后决定将这几日的努力整理成文，帮助前端爱好者们少走弯路。文章更新可能之后不会实时同步在论坛上，欢迎大家关注我的Github，我会把最新的文章更新在对应的项目里，让我们一起在代码的海洋里策马奔腾：github.com/jerryOnlyZR… 。 今天，我们将从性能优化的三大方面工作逐步展开介绍，其中包括网络传输性能、页面渲染性能以及JS阻塞性能，系统性地带着读者们体验性能优化的实践流程。 1.网络传输性能优化在开始介绍网络传输性能优化这项工作之前，我们需要了解浏览器处理用户请求的过程，那么就必须奉上这幅神图了： img 这是navigation timing监测指标图，从图中我们可以看出，浏览器在得到用户请求之后，经历了下面这些阶段：重定向→拉取缓存→DNS查询→建立TCP链接→发起请求→接收响应→处理HTML元素→元素加载完成。不着急，我们对其中的细节一步步展开讨论： 1.1.浏览器缓存我们都知道，浏览器在向服务器发起请求前，会先查询本地是否有相同的文件，如果有，就会直接拉取本地缓存，这和我们在后台部属的Redis和Memcache类似，都是起到了中间缓冲的作用，我们先看看浏览器处理缓存的策略： img 因为网上的图片太笼统了，而且我翻过很多讲缓存的文章，很少有将状态码还有什么时候将缓存存放在内存（memory）中什么时候缓存在硬盘中（disk）系统地整理出来，所以我自己绘制了一张浏览器缓存机制流程图，结合这张图再更深入地说明浏览器的缓存机制。 这里我们可以使用chrome devtools里的network面板查看网络传输的相关信息： （这里需要特别注意，在我们进行缓存调试时，需要去除network面板顶部的Disable cache勾选项，否则浏览器将始终不会从缓存中拉取数据） img 浏览器默认的缓存是放在内存内的，但我们知道，内存里的缓存会因为进程的结束或者说浏览器的关闭而被清除，而存在硬盘里的缓存才能够被长期保留下去。很多时候，我们在network面板中各请求的size项里，会看到两种不同的状态：from memory cache 和 from disk cache，前者指缓存来自内存，后者指缓存来自硬盘。而控制缓存存放位置的，不是别人，就是我们在服务器上设置的Etag字段。在浏览器接收到服务器响应后，会检测响应头部（Header），如果有Etag字段，那么浏览器就会将本次缓存写入硬盘中。 之所以拉取缓存会出现200、304两种不同的状态码，取决于浏览器是否有向服务器发起验证请求。只有向服务器发起验证请求并确认缓存未被更新，才会返回304状态码。 这里我以nginx为例，谈谈如何配置缓存: 首先，我们先进入nginx的配置文档 1$ vim nginxPath/conf/nginx.conf 在配置文档内插入如下两项： 1etag on; //开启etag验证 expires 7d; //设置缓存过期时间为7天 打开我们的网站，在chrome devtools的network面板中观察我们的请求资源，如果在响应头部看见Etag和Expires字段，就说明我们的缓存配置成功了。 img 【！！！特别注意！！！】 在我们配置缓存时一定要切记，浏览器在处理用户请求时，如果命中强缓存，浏览器会直接拉取本地缓存，不会与服务器发生任何通信，也就是说，如果我们在服务器端更新了文件，并不会被浏览器得知，就无法替换失效的缓存。所以我们在构建阶段，需要为我们的静态资源添加md5 hash后缀，避免资源更新而引起的前后端文件无法同步的问题。 1.2.资源打包压缩我们之前所作的浏览器缓存工作，只有在用户第二次访问我们的页面才能起到效果，如果要在用户首次打开页面就实现优良的性能，必须对资源进行优化。我们常将网络性能优化措施归结为三大方面：减少请求数、减小请求资源体积、提升网络传输速率。现在，让我们逐个击破： 结合前端工程化思想，我们在对上线文件进行自动化打包编译时，通常都需要打包工具的协助，这里我推荐webpack，我通常都使用Gulp和Grunt来编译node，Parcel太新，而且webpack也一直在自身的特性上向Parcel靠拢。 在对webpack进行上线配置时，我们要特别注意以下几点： ①JS压缩：（这点应该算是耳熟能详了，就不多介绍了） 12345678910optimization: &#123; minimizer: [ new UglifyJsPlugin(&#123; cache: true, parallel: true, sourceMap: true// set to true if you want JS source maps &#125;), ...Plugins ]&#125; ②HTML压缩： 12345678910111213141516new HtmlWebpackPlugin(&#123; template: __dirname + &apos;/views/index.html&apos;, // new 一个这个插件的实例，并传入相关的参数 filename: &apos;../index.html&apos;, minify: &#123; removeComments: true, collapseWhitespace: true, removeRedundantAttributes: true, useShortDoctype: true, removeEmptyAttributes: true, removeStyleLinkTypeAttributes: true, keepClosingSlash: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;, chunksSortMode: &apos;dependency&apos; &#125;) 我们在使用html-webpack-plugin 自动化注入JS、CSS打包HTML文件时，很少会为其添加配置项，这里我给出样例，大家直接复制就行。据悉，在Webpack5中，html-webpack-plugin 的功能会像 common-chunk-plugin 那样，被集成到webpack内部，这样我们就不需要再install额外的插件了。PS：这里有一个技巧，在我们书写HTML元素的src 或 href 属性时，可以省略协议部分，这样也能简单起到节省资源的目的。（虽然其目的本身是为了统一站内的所有协议） ③提取公共资源： 1234567891011121314splitChunks: &#123;cacheGroups: &#123;vendor: &#123; // 抽离第三方插件test: /node_modules/, // 指定是node_modules下的第三方包chunks: &apos;initial&apos;,name: &apos;common/vendor&apos;, // 打包后的文件名，任意命名priority: 10// 设置优先级，防止和自定义的公共代码提取时被覆盖，不进行打包&#125;,utils: &#123; // 抽离自定义公共代码test: /\\.js$/,chunks: &apos;initial&apos;,name: &apos;common/utils&apos;,minSize: 0// 只要超出0字节就生成一个新包&#125;&#125;&#125; ④提取css并压缩： 在使用webpack的过程中，我们通常会以模块的形式引入css文件（webpack的思想不就是万物皆模块嘛），但是在上线的时候，我们还需要将这些css提取出来，并且压缩，这些看似复杂的过程只需要简单的几行配置就行： （PS:我们需要用到mini-css-extract-plugin ，所以还得大家自行npm install） 1234567891011121314const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;)module: &#123;rules: [..., &#123;test: /\\.css$/,exclude: /node_modules/,use: [_mode === &apos;development&apos; ? &apos;style-loader&apos; : MiniCssExtractPlugin.loader, &#123; loader: &apos;css-loader&apos;,options: &#123;importLoaders: 1&#125;&#125;, &#123;loader: &apos;postcss-loader&apos;,options: &#123;ident: &apos;postcss&apos;&#125;&#125;]&#125;]&#125; 我这里配置预处理器postcss，但是我把相关配置提取到了单独的文件postcss.config.js里了，其中cssnano是一款很不错的CSS优化插件。 ⑤将webpack开发环境修改为生产环境：在使用webpack打包项目时，它常常会引入一些调试代码，以作相关调试，我们在上线时不需要这部分内容，通过配置剔除： devtool: ‘false’ 如果你能按照上述六点将webpack上线配置完整配置出来，基本能将文件资源体积压缩到极致了，如有疏漏，还希望大家能加以补充。 最后，我们还应该在服务器上开启Gzip传输压缩，它能将我们的文本类文件体积压缩至原先的四分之一，效果立竿见影，还是切换到我们的nginx配置文档，添加如下两项配置项目： 1gzip on; gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php application/vnd.ms-fontobject font/ttf font/opentype font/x-woff image/svg+xml; 【！！！特别注意！！！】 不要对图片文件进行Gzip压缩！不要对图片文件进行Gzip压缩！不要对图片文件进行Gzip压缩！我只会告诉你效果适得其反，至于具体原因，还得考虑服务器压缩过程中的CPU占用还有压缩率等指标，对图片进行压缩不但会占用后台大量资源，压缩效果其实并不可观，可以说是“弊大于利”，所以请在gzip_types 把图片的相关项去掉。针对图片的相关处理，我们接下来会更加具体地介绍。 1.3.图片资源优化刚刚我们介绍了资源打包压缩，只是停留在了代码层面，而在我们实际开发中，真正占用了大量网络传输资源的，并不是这些文件，而是图片，如果你对图片进行了优化工作，你能立刻看见明显的效果。 1.3.1.不要在HTML里缩放图像很多开发者可能会有这样的错觉（其实我曾经也是这样），我们会为了方便在一个200✖200的图片容器内直接使用一张400✖400的图片，我们甚至认为这样能让用户觉得图片更加清晰，其实不然，在普通的显示器上，用户并不会感到缩放后的大图更加清晰，但这一切却导致网页加速速度下降，同时照成带宽浪费，你可能不知道，一张200KB的图片和2M的图片的传输时间会是200m和12s的差距（亲身经历，深受其害(┬＿┬)）。所以，当你需要用多大的图片时，就在服务器上准备好多大的图片，尽量固定图片尺寸。 1.3.2.使用雪碧图（CSS Sprite）雪碧图的概念大家一定在生活中经常听见，其实雪碧图是减小请求数的显著运用。而且很奇妙的是，多张图片聘在一块后，总体积会比之前所有图片的体积之和小（你可以亲自试试）。这里给大家推荐一个自动化生成雪碧图的工具：www.toptal.com/developers/… （图片来自官网首页） img 只要你添加相关资源文件，他就会自动帮你生成雪碧图以及对应的CSS样式。 其实我们在工程中还有更为自动的方法，便是一款雪碧图生成插件webpack-spritesmith。首先，先简单介绍一下使用插件生成雪碧图的思路： 首先，我们会把我们所需要的小图标放置在一个文件夹内以便于管理： （这里的@2x图片是为了适配视网膜二倍屏的图片资源，webpack-spritesmith内有专门为适配多倍屏提供的配置项，稍候将会讲到） 然后，我们需要插件去读取这个文件夹内的所有图片资源文件，以文件夹名称为图片名称生成一张雪碧图到指定位置，并且输出能够正确使用这些雪碧图的CSS文件。 img img 如今，webpack-spritesmith这款插件能实现我们想要的一切，先奉上配置内容：（具体可参照webpack-spritesmith官方文档：www.npmjs.com/package/web） img 执行webpack之后，就会在开发目录里生成上面两张图的结果，我们可以看看common.css里面的内容： img 我们可以看到，所有我们之前放在common文件夹里的图片资源都自动地生成了相应的样式，这些都不需要我们手动处理，``webpack-spritesmith`这款插件就已经帮我们完成了！ 1.3.3.使用字体图标（iconfont）不论是压缩后的图片，还是雪碧图，终归还是图片，只要是图片，就还是会占用大量网络传输资源。但是字体图标的出现，却让前端开发者看到了另外一个神奇的世界。 我最喜欢用的是阿里矢量图标库（网址：www.iconfont.cn/），里面有大量的矢量图… img 图片能做的很多事情，矢量图都能作，而且它只是往HTML里插入字符和CSS样式而已，和图片请求比起来资源占用完全不在一个数量级，如果你的项目里有小图标，就是用矢量图吧。 但如果我们做的是公司或者团队的项目，需要使用到许多自定义的字体图标，可爱的设计小姐姐们只是丢给你了几份.svg图片，你又该如何去做呢？ 其实也很简单，阿里矢量图标库就提供了上传本地SVG资源的功能，这里另外推荐一个网站——icomoon。icomoon这个网站也为我们提供了将SVG图片自动转化成CSS样式的功能。（图片来自icomoon首页） img 我们可以点击Import Icons按钮导入我们本地的SVG资源，然后选中他们，接下来生成CSS的事情，就交给icomoon吧，具体的操作，就和阿里矢量图标库类同了。 1.3.4.使用WebPWebP格式，是谷歌公司开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。Facebook、Ebay等知名网站已经开始测试并使用WebP格式。 我们可以使用官网提供的Linux命令行工具对项目中的图片进行WebP编码，也可以使用我们的线上服务，这里我推荐叉拍云（网址：www.upyun.com/webp）。但是在实际… img 1.4.网络传输性能检测工具——Page Speed除了network版块，其实chrome还为我们准备好了一款监测网络传输性能的插件——Page Speed，咱们的文章封面，就是用的Page Speed的官方宣传图（因为我觉得这张图再合适不过了）。我们只需要通过下面步骤安装，就可以在chrome devtools里找到它了：chrome菜单→更多工具→拓展程序→chrome网上应用商店→搜索pagespeed后安转即可。 （PS：使用chrome应用商店需要翻墙，怎么翻墙我就不便多说了） 这就是Page Speed的功能界面： img 我们只需要打开待测试的网页，然后点击Page Speed里的 Start analyzing按钮，它就会自动帮我们测试网络传输性能了，这是我的网站测试结果： img Page Speed最人性化的地方，便是它会对测试网站的性能瓶颈提出完整的建议，我们可以根据它的提示进行优化工作。这里我的网站已经优化到最好指标了(•́⌄•́๑)૭✧，Page Speed Score表示你的性能测试得分，100/100表示已经没有需要优化的地方。 优化完毕后再使用chorme devtools的network版块测量一下我们网页的白屏时间还有首屏时间，是不是得到了很大的提升？ 1.5.使用CDNLast but not least， 再好的性能优化实例，也必须在CDN的支撑下才能到达极致。 如果我们在Linux下使用命令$ traceroute targetIp 或者在Windows下使用批处理 &gt; tracert targetIp，都可以定位用户与目标计算机之间经过的所有路由器，不言而喻，用户和服务器之间距离越远，经过的路由器越多，延迟也就越高。使用CDN的目的之一便是解决这一问题，当然不仅仅如此，CDN还可以分担IDC压力。 当然，凭着我们单个人的资金实力（除非你是王思聪）是必定搭建不起来CDN的，不过我们可以使用各大企业提供的服务，诸如腾讯云等，配置也十分简单，这里就请大家自行去推敲啦。 2.页面渲染性能优化2.1.浏览器渲染过程（Webkit） img 其实大家应该对浏览器将的HTML渲染机制比较熟悉了，基本流程同上图所述，大家在入门的时候，你的导师或者前辈可能会告诉你，在渲染方面我们要减少重排和重绘，因为他们会影响浏览器性能。不过你一定不知道其中原理是什么，对吧。今天我们就结合《Webkit技术内幕》（这本书我还是很推荐大家买来看看，好歹作为一名前端工程师，你得知道我们天天接触的浏览器内核是怎样工作的）的相关知识，给大家普及普及那些深层次的概念。 PS：这里提到了Webkit内核，我顺带提一下浏览器内部的渲染引擎、解释器等组件的关系，因为经常有师弟或者一些前端爱好者向我问这方面的知识，分不清他们的关系，我就拿一张图来说明：（如果你对着不感兴趣，可以直接跳过） 浏览器的解释器，是包括在渲染引擎内的，我们常说的Chrome（现在使用的是Blink引擎）和Safari使用的Webkit引擎，Firefox使用的Gecko引擎，指的就是渲染引擎。而在渲染引擎内，还包括着我们的HTML解释器（渲染时用于构造DOM树）、CSS解释器（渲染时用于合成CSS规则）还有我们的JS解释器。不过后来，由于JS的使用越来越重要，工作越来越繁杂，所以JS解释器也渐渐独立出来，成为了单独的JS引擎，就像众所周知的V8引擎，我们经常接触的Node.js也是用的它。 2.2.DOM渲染层与GPU硬件加速如果我告诉你，一个页面是有许多许多层级组成的，他们就像千层面那样，你能想象出这个页面实际的样子吗？这里为了便于大家想象，我附上一张之前Firefox的3D View插件的页面Layers层级图： img 对，你没看错，页面的真实样子就是这样，是由多个DOM元素渲染层（Layers）组成的，实际上一个页面在构建完render tree之后，是经历了这样的流程才最终呈现在我们面前的： ①浏览器会先获取DOM树并依据样式将其分割成多个独立的渲染层 ②CPU将每个层绘制进绘图中 ③将位图作为纹理上传至GPU（显卡）绘制 ④GPU将所有的渲染层缓存（如果下次上传的渲染层没有发生变化，GPU就不需要对其进行重绘）并复合多个渲染层最终形成我们的图像 从上面的步骤我们可以知道，布局是由CPU处理的，而绘制则是由GPU完成的。 其实在chrome中，也为我们提供了相关插件供我们查看页面渲染层的分布情况，以及GPU的占用率：（所以说，平时我们得多去尝试尝试chrome的那些莫名其妙的插件，真的会发现好多东西都是神器） chrome开发者工具菜单→more tools→Layers（开启渲染层功能模块） chrome开发者工具菜单→more tools→rendering（开启渲染性能监测工具） 执行上面的操作后，你会在浏览器里看到这样的效果： img 太多东西了，分模块讲吧： （一）最先是页面右上方的小黑窗：其实提示已经说的很清楚了，它显示的就是我们的GPU占用率，能够让我们清楚地知道页面是否发生了大量的重绘。 （二）Layers版块：这就是用于显示我们刚提到的DOM渲染层的工具了，左侧的列表里将会列出页面里存在哪些渲染层，还有这些渲染层的详细信息。 （三）Rendering版块：这个版块和我们的控制台在同一个地方，大家可别找不到它。前三个勾选项是我们最常使用的，让我来给大家解释一下他们的功能（充当一次免费翻译） ①Paint flashing：勾选之后会对页面中发生重绘的元素高亮显示 ②Layer borders：和我们的Layer版块功能类似，它会用高亮边界突出我们页面中的各个渲染层 ③FPS meter：就是开启我们在（一）中提到的小黑窗，用于观察我们的GPU占用率 可能大家会问我，和我提到DOM渲染层这么深的概念有什么用啊，好像跟性能优化没一点关系啊？大家应该还记得我刚说到GPU会对我们的渲染层作缓存对吧，那么大家试想一下，如果我们把那些一直发生大量重排重绘的元素提取出来，单独触发一个渲染层，那样这个元素不就不会“连累”其他元素一块重绘了对吧。 那么问题来了，什么情况下会触发渲染层呢？大家只要记住： video元素、WebGL、Canvas、CSS3 3D、CSS滤镜、z-index大于某个相邻节点的元素都会触发新的Layer，其实我们最常用的方法，就是给某个元素加上下面的样式： 1transform: translateZ(0); backface-visibility: hidden; 这样就可以触发渲染层啦(__) 。 我们把容易触发重排重绘的元素单独触发渲染层，让它与那些“静态”元素隔离，让GPU分担更多的渲染工作，我们通常把这样的措施成为硬件加速，或者是GPU加速。大家之前肯定听过这个说法，现在完全清楚它的原理了吧。 2.3.重排与重绘现在到我们的重头戏了，重排和重绘。先抛出概念： ①重排（reflow）：渲染层内的元素布局发生修改，都会导致页面重新排列，比如窗口的尺寸发生变化、删除或添加DOM元素，修改了影响元素盒子大小的CSS属性（诸如：width、height、padding）。 ②重绘（repaint）：绘制，即渲染上色，所有对元素的视觉表现属性的修改，都会引发重绘。 我们习惯使用chrome devtools中的performance版块来测量页面重排重绘所占据的时间： img ①蓝色部分：HTML解析和网络通信占用的时间 ②黄色部分：JavaScript语句执行所占用时间 ③紫色部分：重排占用时间 ④绿色部分：重绘占用时间 不论是重排还是重绘，都会阻塞浏览器。要提高网页性能，就要降低重排和重绘的频率和成本，尽可能少地触发重新渲染。正如我们在2.3中提到的，重排是由CPU处理的，而重绘是由GPU处理的，CPU的处理效率远不及GPU，并且重排一定会引发重绘，而重绘不一定会引发重排。所以在性能优化工作中，我们更应当着重减少重排的发生。 这里给大家推荐一个网站，里面详细列出了哪些CSS属性在不同的渲染引擎中是否会触发重排或重绘： csstriggers.com/ （图片来自官网） 2.4.优化策略谈了那么多理论，最实际不过的，就是解决方案，大家一定都等着急了吧，做好准备，一大波干货来袭： （一）CSS属性读写分离：浏览器每次对元素样式进行读操作时，都必须进行一次重新渲染（重排 + 重绘），所以我们在使用JS对元素样式进行读写操作时，最好将两者分离开，先读后写，避免出现两者交叉使用的情况。最最最客观的解决方案，就是不用JS去操作元素样式，这也是我最推荐的。 （二）通过切换class或者style.csstext属性去批量操作元素样式 （三）DOM元素离线更新：当对DOM进行相关操作时，例如innerHTML、appendChild等都可以使用Document Fragment对象进行离线操作，待元素“组装”完成后再一次插入页面，或者使用display:none 对元素隐藏，在元素“消失”后进行相关操作。 （四）将没用的元素设为不可见：visibility: hidden，这样可以减小重绘的压力，必要的时候再将元素显示。 （五）压缩DOM的深度，一个渲染层内不要有过深的子元素，少用DOM完成页面样式，多使用伪元素或者box-shadow取代。 （六）图片在渲染前指定大小：因为img元素是内联元素，所以在加载图片后会改变宽高，严重的情况会导致整个页面重排，所以最好在渲染前就指定其大小，或者让其脱离文档流。 （七）对页面中可能发生大量重排重绘的元素单独触发渲染层，使用GPU分担CPU压力。（这项策略需要慎用，得着重考量以牺牲GPU占用率能否换来可期的性能优化，毕竟页面中存在太多的渲染层对于GPU而言也是一种不必要的压力，通常情况下，我们会对动画元素采取硬件加速。） 3.JS阻塞性能JavaScript在网站开发中几乎已经确定了垄断地位，哪怕是一个再简单不过的静态页面，你都可能看到JS的存在，可以说，没有JS，就基本没有用户交互。然而，脚本带来的问题就是他会阻塞页面的平行下载，还会提高进程的CPU占用率。更有甚者，现在node.js已经在前端开发中普及，稍有不慎，我们引发了内存泄漏，或者在代码中误写了死循环，会直接造成我们的服务器奔溃。在如今这个JS已经遍布前后端的时代，性能的瓶颈不单单只是停留在影响用户体验上，还会有更多更为严重的问题，对JS的性能优化工作不可小觑。 在编程的过程中，如果我们使用了闭包后未将相关资源加以释放，或者引用了外链后未将其置空（比如给某DOM元素绑定了事件回调，后来却remove了该元素），都会造成内存泄漏的情况发生，进而大量占用用户的CPU，造成卡顿或死机。我们可以使用chrome提供的JavaScript Profile版块，开启方式同Layers等版块，这里我就不再多说了，直接上效果图： img 我们可以清除看见JS执行时各函数的执行时间以及CPU占用情况，如果我在代码里增加一行while(true){}, 那么它的占用率一定会飙升到一个异常的指标（亲测93.26%）。 其实浏览器强大的内存回收机制在大多数时候避免了这一情况的发生，即便用户发生了死机，他只要结束相关进程（或关闭浏览器）就可以解决这一问题，但我们要知道，同样的情况还会发生在我们的服务器端，也就是我们的node中，严重的情况，会直接造成我们的服务器宕机，网站奔溃。所以更多时候，我们都使用JavaScript Profile版块来进行我们的node服务的压力测试，搭配node-inspector 插件，我们能更有效地检测JS执行时各函数的CPU占用率，针对性地进行优化。 （PS：没修炼到一定水平，千万别在服务端使用闭包，一个是真没啥用，我们会有更多优良的解决办法，二是真的很容易内存泄漏，造成的后果是你无法预期的） 4.【拓展】负载均衡之所以将负载均衡作为拓展内容，是因为如果是你自己搭建的个人网站，或者中小型网站，其实并不需要考虑多大的并发量，但是如果你搭建的是大型网站，负载均衡便是开发过程不可或缺的步骤。 4.1.Node.js处理IO密集型请求现在的开发流程都注重前后端分离，也就是软件工程中常提到的“高内聚低耦合”的思想，你也可以用模块化的思想去理解，前后解耦就相当于把一个项目分成了前端和后端两个大模块，中间通过接口联系起来，分别进行开发。这样做有什么好处？我就举最有实际效果的一点：“异步编程”。这是我自己想的名字，因为我觉得前后解耦的形式很像我们JS中的异步队列，传统的开发模式是“同步”的，前端需要等后端封装好接口，知道了能拿什么数据，再去开发，时间短，工程大。而解耦之后，我们只需要提前约定好接口，前后两端就可以同时开发，不仅高效而且省时。 我们都知道node的核心是事件驱动，通过loop去异步处理用户请求，相比于传统的后端服务，它们都是将用户的每个请求分配到异步队列进行处理，推荐大家去看这样一篇博文：mp.weixin.qq.com/s?__biz=MzA… 。特别生动地讲解了事件驱动的运行机制，通俗易懂。事件驱动的最大优势是什么？就是在高并发IO时，不会造成堵塞，对于直播类网站，这点是至关重要的，我们有成功的先例——快手，快手强大的IO高并发究其本质一定能追溯到node。 其实现在的企业级网站，都会搭建一层node作为中间层。大概的网站框架如图所示： img 4.2.pm2实现Node.js“多线程”我们都知道node的优劣，这里分享一份链接，找了挺久写的还算详细：www.zhihu.com/question/19… 。其实都是老套路，那些说node不行的都是指着node是单线程这一个软肋开撕，告诉你，我们有解决方案了——pm2。这是它的官网：pm2.keymetrics.io/ 。它是一款node.js进程管理器，具体的功能，就是能在你的计算机里的每一个内核都启动一个node.js服务，也就是说如果你的电脑或者服务器是多核处理器（现在也少见单核了吧），它就能启动多个node.js服务，并且它能够自动控制负载均衡，会自动将用户的请求分发至压力小的服务进程上处理。听起来这东西简直就是神器啊！而且它的功能远远不止这些，这里我就不作过多介绍了，大家知道我们在上线的时候需要用到它就行了，安装的方法也很简单，直接用npm下到全局就可以了$ npm i pm2 -g具体的使用方法还有相关特性可以参照官网。这里我在build文件夹内添加了pm2.json文件，这是pm2的启动配置文件，我们可以自行配置相关参数，具体可参考github源码，运行时我们只要在上线目录下输入命令$ pm2 start pm2.json即可。 下面是pm2启动后的效果图： img 4.3.nginx搭建反向代理在开始搭建工作之前，首先得知道什么是反向代理。可能大家对这个名词比较陌生，先上一张图： img 所谓代理就是我们通常所说的中介，网站的反向代理就是指那台介于用户和我们真实服务器之间的服务器（说的我都拗口了），它的作用便是能够将用户的请求分配到压力较小的服务器上，其机制是轮询。听完这句话是不是感觉很耳熟，没错，在我介绍pm2的时候也说过同样的话，反向代理起到的作用同pm2一样也是实现负载均衡，你现在应该也明白了两者之间的差异，反向代理是对服务器实现负载均衡，而pm2是对进程实现负载均衡。大家如果想深入了解反向代理的相关知识，我推荐知乎的一个贴子：www.zhihu.com/question/24… 。但是大家会想到，配服务器是运维的事情啊，和我们前端有什么关系呢？的确，在这部分，我们的工作只有一些，只需要向运维提供一份配置文档即可。 1http &#123; upstream video &#123; ip_hash; server localhost:3000; &#125; server &#123; listen: 8080; location / &#123; proxy_pass: http://video &#125; &#125; &#125; 也就是说，在和运维对接的时候，我们只需要将上面这几行代码改为我们配置好的文档发送给他就行了，其他的事情，运维小哥会明白的，不用多说，都在酒里。 但是，这几行代码该怎么去改呢？首先我们得知道，在nginx中，模块被分为三大类：handler、filter和upstream。而其中的upstream模块，负责完成完成网络数据的接收、处理和转发，也是我们需要在反向代理中用到的模块。接下来我们将介绍配置代码里的内容所表示的含义 4.3.1.upstream配置信息：upstream关键字后紧跟的标识符是我们自定义的项目名称，通过一对花括号在其中增添我们的配置信息。 ip_hash 关键字：控制用户再次访问时是否连接到前一次连接的服务器 server关键字：我们真实服务器的地址，这里的内容肯定是需要我们去填写的，不然运维怎么知道你把项目放在那个服务器上了，也不知道你封装了一层node而得去监听3000端口。 4.3.2.server配置信息server是nginx的基本配置，我们需要通过server将我们定义的upstream应用到服务器上。 listen关键字：服务器监听的端口 location关键字：和我们之前在node层说到的路由是起同样的功能，这里是把用户的请求分配到对应的upstream上 5.拓展阅读网站的性能与监测是一项复杂的工作，还有很多很多后续的工作，我之前所提到的这些，也只能算是冰山一角，在熟悉开发规范的同时，也需要实践经验的积累。 在翻阅了许多与网站性能相关的书籍后，我还是更钟情于唐文前辈编著的《大型网站性能监测、分析与优化》，里面的知识较新，切合实际，至少我读完一遍后很有收获、醍醐灌顶，我也希望对性能感兴趣的读者在看完我的文章后能去翻翻这本著作。 这里笔者还建议大家平时有事没事可以多去看几遍雅虎军规，虽是老生常谈，但却字字珠玑。如果大家能熟记于心更是再好不过了，传送门： www.cnblogs.com/xianyulaodi","categories":[{"name":"前端文章","slug":"前端文章","permalink":"https://qw8.github.io/categories/前端文章/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://qw8.github.io/tags/性能优化/"}]},{"title":"前端技能","slug":"articles/前端技能","date":"2023-11-15T16:00:00.000Z","updated":"2024-02-18T02:40:20.000Z","comments":true,"path":"/articles/qian-duan-ji-neng.html","link":"","permalink":"https://qw8.github.io/articles/qian-duan-ji-neng.html","excerpt":"","text":"第一阶段：HTML+CSS: HTML进阶、CSS进阶、div+css布局、HTML+css整站开发、 JavaScript基础： Js基础教程、js内置对象常用方法、常见DOM树操作大全、ECMAscript、DOM、BOM、定时器和焦点图。 JS基本特效： 常见特效、例如：tab、导航、整页滚动、轮播图、JS制作幻灯片、弹出层、手风琴菜单、瀑布流布局、滚动事件、滚差视图。 JS高级特征： 正则表达式、排序算法、递归算法、闭包、函数节流、作用域链、基于距离运动框架、面向对象基础、 JQuery：基础使用 悬着器、DOM操作、特效和动画、方法链、拖拽、变形、JQueryUI组件基本使用。 第二阶段：WEB开发（和HTML5）HTML5： HTML5新语义标签、HTML5表单、音频和视频、离线和本地存储、SVG、Web Socket、Canvas. CSS3: CSS3新选择器、伪元素、脸色表示法、边框、阴影、background系列属性改变、Transition、动画、景深和深透、3D效果制作、Velocity.js框架、元素进场、出场策略、炫酷CSS3网页制作。 Bootstrap: 响应式概念、媒体查询、响应式网站制作、删格系统、删格系统原理、Bootstrap常用模板、LESS和SASS。 移动Web开发： 跨终端WEB和主流设备简介、视口、流式布局、弹性盒子、rem、移动终端JavaScript事件、手机中常见JS效果制作、Zepto.js、手机聚划算页面、手机滚屏。 第三阶段：http服务（实现必须过程）WEB服务器基础： 服务器基础知识、Apache服务器和其他WEB服务器介绍、Apache服务器搭建、HTTP介绍。 PHP基础： PHP基础语法、使用PHP处理简单的GET或者POST请求、 AJAX上篇： Ajax简介和异步的概念、Ajax框架的封装、XMLHttpRequest对象详细介绍方法、兼容性处理方法、Ajax框架的封装、Ajax中缓存问题、XML介绍和使用。 AJAX下篇： JSON和JSON解析、数据绑定和模板技术、JSONP、跨域技术、图片预读取和lazy-load技术、JQuery框架中的AjaxAPI、使用Ajax实现爆布流案例额。 第四阶段：面向对象（继承、多态、抽象，貌似是现在主流的三大特征了）面向对象终极篇： 从内存角度到理解JS面向对象、基本类型、复杂类型、原型链、ES6中的面向对象、属性读写权限、设置器、访问器。 面向对象三大特征： 继承性、多态性、封装性、接口。 设计模式： 面向对象编程思维、单例模式、工厂模式、策略模式、观察者模式、模板方法模式、代理模式、装饰者模式、适配器模式、面向切面编程。 第五阶段：（个性化，框架的建立）框架封装基础： 事件流、冒泡、捕获、事件对象、事件框架、选择框架。 框架封装中级： 运动原理、单物体运动框架、多物体运动框架、运动框架面向对象封装。 框架封装高级和补充： JQuery框架雏形、可扩展性、模块化、封装属于传智自己的框架。 第六阶段：（模块组件和主流框架结合）面向组件编程： 面向组件编程的方式、面向组件编程的实现原理、面向组件编程实战、基于组件化思想开发网站应用程序。 面向模块编程： AMD设计规范、CMD设计规范、RequireJS，LoadJS、淘宝的SeaJS。 Web开发工作流： GIT/SVN、Yeoman脚手架、NPM/Bower依赖管理工具、Grunt/Gulp/Webpack。 MVC/MVVM/MVW框架： Angular.js、Backbone.js、Knockout/Ember。 常用库： React.js、Vue.js、Zepto.js……. 第七阶段：（移动应用开发，appium脚本开发们需要知道的）Cordova： WebApp/NativeApp/HybirdApp简介、Cordova简介、与PhoneGap之间的关系、开发环境搭建、Cordova实战（创建项目，配置，编译，调试，部署发布）。 Ionic： Ionic简介和同类对比、模板项目解析、常见组件及使用、结合Angular构建APP、常见效果（下拉刷新，上拉加载，侧滑导航，选项卡）。 React Native： React Native简介、React Native环境配置、创建项目，配置，编译，调试，部署发布、原生模块和UI组件、原生常用API。 HTML5+： HTML5+中国产业联盟、HTML5 Plus Runtime环境、HBuilder开发工具、MUI框架、H5+开发和部署。 第八阶段：全栈Node.js发展、生态圈、Io.js、Linux/Windows/OS X环境配置、REPL环境和控制台程序、异步编程，非阻塞I/O、模块概念，模块管理工具、开发流程，调试，测试 核心模块和对象： 全局对象global，process，console，util、事件驱动，事件发射器、加密解密，路径操作，序列化和反序列化、文件流操作、HTTP服务端与客户端、Socket.IO Web开发基础： HTTP协议，请求响应处理过程、关系型数据库操作和数据访问、非关系型数据库操作和数据访问、原生的Node.js开发Web应用程序、Web开发工作流、Node.js开发Blog案例。 快速开发框架： Express简介+MVC简介、Express常用API、Express路由模块、Jade/Ejs模板引擎、使用Express重构Blog案例、Koa等其他常见MVC框架； 例：Node.js开发电子商务实战相关的：需求与设计、账户模块注册登录、会员中心模块、前台展示模块、购物车，订单结算、在线客服即时通讯模块。 基础 HTML / CSS JavaScript DOM 中级篇 数据格式（如JSON、XML） RESTful API交互（如jQuery Ajax，Fetch API，ReactiveX） 正则表达式 HTML语义化 命令行 Node.js DIV / CSS SCSS / SASS 矢量图形 / 矢量图形动画（如SVG） 单页面应用 高级篇 ES6 / TypeScript CSS3 面向对象编程 函数式编程 MVC / MVVM / MV* 安全性（如跨域） 授权（如HTTP Basic、JWT等等） 工程化 代码质量（如JSLint / ESLint / TSLint / CSLint） 代码分析（如Code Climate） 测试覆盖率 构建系统（gulp、grunt、webpack等等） 自动构建（脚本） 兼容性 跨浏览器测试 （Chrome，IE，Firefox，Safari等等） 跨平台测试（Windows、GNU/Linux，Mac OS等等） 跨设备测试（Desktop，Android，iOS，Windows Phone） 跨版本测试（同一个浏览器的不同版本） 前端特定 CSS / CSS3 动画 JavaScript 动画 Web字体嵌入 Icon 字体 图形和图表 CSS Sprite（如glue） DOM操作（如jQuery、React等等） 模板引擎（如JSX、Handlebars、JSP、Mustache等等） 软件工程 版本管理（如git、svn） 包管理（如npm、bower） 依赖管理 模块化（如CommonJS、WebPack） 调试 浏览器调试 Debug工具 Wireshark / Charles抓包 远程设备调试（如Chrome Inspect Devices） 测试 单元测试 服务测试 UI测试 集成测试 性能与优化 PageSpeed / Yslow 优化 加载优化（如gzip压缩、缓存等等） 性能测试（特别是移动Web） 可用性 压缩（如Minify、Uglify、CleanCSS等等） 设计 切页面 线框图（Wireframe） 响应式设计 网格布局（Grid Layout） Flexbox布局 SEO Sitemap（站点地图） 内部链接建设 MicroData / MicroFormat 页面静态内容生成 H1、H2、H3和strong使用 Title、Description优化 页面静态内容生成","categories":[{"name":"前端文章","slug":"前端文章","permalink":"https://qw8.github.io/categories/前端文章/"}],"tags":[{"name":"前端技能","slug":"前端技能","permalink":"https://qw8.github.io/tags/前端技能/"}]},{"title":"前端代码评审","slug":"articles/前端代码评审","date":"2023-11-14T16:00:00.000Z","updated":"2024-02-18T02:52:52.000Z","comments":true,"path":"/articles/qian-duan-dai-ma-ping-shen.html","link":"","permalink":"https://qw8.github.io/articles/qian-duan-dai-ma-ping-shen.html","excerpt":"","text":"前端代码评审checklist清单前言​ 前端团队有评审代码的要求，但由于每个开发人员的水平不同，技术关注点不同，所以对代码评审的关注点不同，为了保证代码质量，团队代码风格统一，特此拟定一份《前端团队代码评审 CheckList 清单》，这样代码评审人员在评审代码时，可以参照这份清单，对代码进行评审。从而辅助整个团队提高代码质量、统一代码规范。如果你的团队还没有这么一份代码评审 CheckList 清单，也许这正是你需要的；如果你的团队已经有了代码评审参照标准，这份清单也许能起到锦上添花的效果。 一、代码静态检查工具1.1、使用 eslint 工具对 javascript 代码进行检查​ eslint 检查的规范继承自 eslint-config-standard 检验规则，具体的规则介绍参照链接：https://cn.eslint.org/docs/rules/ ，这里及以下部分不再重复介绍这些检验规则。 1.2、使用 stylelint 工具对 css 样式代码进行检查​ stylelint 检查的规范继承自 stylelint-config-standard 检验规则，具体的规则介绍参照链接：https://www.npmjs.com/package/stylelint-config-standard ，这里及以下部分不再重复介绍这些检验规则。 二、命名2.1、JS 采用 Camel Case 小驼峰式命名推荐： 1 studentInfot 2.2、避免名称冗余推荐： 12345const Car = &#123; make: &quot;Honda&quot;, model: &quot;Accord&quot;, color: &quot;Blue&quot;&#125;; 不推荐： 12345const Car = &#123; carMake: &quot;Honda&quot;, carModel: &quot;Accord&quot;, carColor: &quot;Blue&quot;&#125;; 2.3、CSS 类名采用 BEM 命名规范推荐： 12.block__element&#123;&#125; .block--modifier&#123;&#125; 2.4、命名符合语义化命名需要符合语义化，如果函数命名，可以采用加上动词前缀： 动词 含义 can 判断是否可执行某个动作 has 判断是否含有某个值 is 判断是否为某个值 get 获取某个值 set 设置某个值 推荐： 12345678//是否可阅读 function canRead()&#123; return true; &#125; //获取姓名 function getName&#123; return this.name &#125; 三、JS 推荐写法3.1、每个常量都需命名每个常量应该命名，不然看代码的人不知道这个常量表示什么意思。 推荐： 12const COL_NUM = 10;let row = Math.ceil(num/COL_NUM); 不推荐： 1let row = Math.ceil(num/10); 3.2、推荐使用字面量创建对象和数组推荐使用字面量，因为这不仅是性能最优也有助于节省代码量。 推荐： 12345let obj = &#123; name:&apos;tom&apos;, age:15, sex:&apos;男&apos; &#125; 不推荐： 1234let obj = &#123;&#125;;obj.name = &apos;tom&apos;;obj.age = 15;obj.sex = &apos;男&apos;; 3.3、对象设置默认属性的推荐写法推荐： 1234567891011121314151617181920212223const menuConfig = &#123; title: &quot;Order&quot;, // User did not include &apos;body&apos; key buttonText: &quot;Send&quot;, cancellable: true&#125;;function createMenu(config) &#123; config = Object.assign( &#123; title: &quot;Foo&quot;, body: &quot;Bar&quot;, buttonText: &quot;Baz&quot;, cancellable: true &#125;, config ); // config now equals: &#123;title: &quot;Order&quot;, body: &quot;Bar&quot;, buttonText: &quot;Send&quot;, cancellable: true&#125; // ...&#125;createMenu(menuConfig); 不推荐： 12345678910111213141516const menuConfig = &#123; title: null, body: &quot;Bar&quot;, buttonText: null, cancellable: true&#125;;function createMenu(config) &#123; config.title = config.title || &quot;Foo&quot;; config.body = config.body || &quot;Bar&quot;; config.buttonText = config.buttonText || &quot;Baz&quot;; config.cancellable = config.cancellable !== undefined ? config.cancellable : true;&#125;createMenu(menuConfig); 3.4、将对象的属性值保存为局部变量对象成员嵌套越深，读取速度也就越慢。所以好的经验法则是：如果在函数中需要多次读取一个对象属性，最佳做法是将该属性值保存在局部变量中，避免多次查找带来的性能开销。 推荐： 1234567891011let person = &#123; info:&#123; sex:&apos;男&apos; &#125;&#125;function getMaleSex()&#123; let sex = person.info.sex; if(sex === &apos;男&apos;)&#123; console.log(sex) &#125;&#125; 不推荐： 12345678910let person = &#123; info:&#123; sex:&apos;男&apos; &#125;&#125;function getMaleSex()&#123; if(person.info.sex === &apos;男&apos;)&#123; console.log(person.info.sex) &#125;&#125; 3.5、字符串转为整型当需要将浮点数转换成整型时，应该使用Math.floor()或者Math.round()，而不是使用parseInt()将字符串转换成数字。Math是内部对象，所以Math.floor()`其实并没有多少查询方法和调用时间，速度是最快的。 推荐： 1let num = Math.floor(&apos;1.6&apos;); 不推荐： 1let num = parseInt(&apos;1.6&apos;); 3.6、函数参数函数参数越少越好，如果参数超过两个，要使用 ES6的解构语法，不用考虑参数的顺序。 推荐： 12345678910function createMenu(&#123; title, body, buttonText, cancellable &#125;) &#123; // ...&#125;createMenu(&#123; title: &apos;Foo&apos;, body: &apos;Bar&apos;, buttonText: &apos;Baz&apos;, cancellable: true&#125;); 不推荐： 123function createMenu(title, body, buttonText, cancellable) &#123; // ...&#125; 3.7、使用参数默认值使用参数默认值 替代 使用条件语句进行赋值。 推荐： 123function createMicrobrewery(name = &quot;Hipster Brew Co.&quot;) &#123; // ...&#125; 不推荐： 1234function createMicrobrewery(name) &#123; const breweryName = name || &quot;Hipster Brew Co.&quot;; // ...&#125; 3.8、最小函数准则这是一条在软件工程领域流传久远的规则。严格遵守这条规则会让你的代码可读性更好，也更容易重构。如果违反这个规则，那么代码会很难被测试或者重用 。 3.9、不要写全局方法在 JavaScript 中，永远不要污染全局，会在生产环境中产生难以预料的 bug。举个例子，比如你在 Array.prototype 上新增一个 diff 方法来判断两个数组的不同。而你同事也打算做类似的事情，不过他的 diff 方法是用来判断两个数组首位元素的不同。很明显你们方法会产生冲突，遇到这类问题我们可以用 ES2015/ES6 的语法来对 Array 进行扩展。 推荐: 123456class SuperArray extends Array &#123; diff(comparisonArray) &#123; const hash = new Set(comparisonArray); return this.filter(elem =&gt; !hash.has(elem)); &#125;&#125; 不推荐： 1234Array.prototype.diff = function diff(comparisonArray) &#123; const hash = new Set(comparisonArray); return this.filter(elem =&gt; !hash.has(elem));&#125;; 3.10、推荐函数式编程函数式变编程可以让代码的逻辑更清晰更优雅，方便测试。 推荐： 123456789101112131415161718const programmerOutput = [ &#123; name: &apos;Uncle Bobby&apos;, linesOfCode: 500 &#125;, &#123; name: &apos;Suzie Q&apos;, linesOfCode: 1500 &#125;, &#123; name: &apos;Jimmy Gosling&apos;, linesOfCode: 150 &#125;, &#123; name: &apos;Gracie Hopper&apos;, linesOfCode: 1000 &#125;];let totalOutput = programmerOutput .map(output =&gt; output.linesOfCode) .reduce((totalLines, lines) =&gt; totalLines + lines, 0) 不推荐： 123456789101112131415161718192021 const programmerOutput = [ &#123; name: &apos;Uncle Bobby&apos;, linesOfCode: 500 &#125;, &#123; name: &apos;Suzie Q&apos;, linesOfCode: 1500 &#125;, &#123; name: &apos;Jimmy Gosling&apos;, linesOfCode: 150 &#125;, &#123; name: &apos;Gracie Hopper&apos;, linesOfCode: 1000 &#125;];let totalOutput = 0;for (let i = 0; i &lt; programmerOutput.length; i++) &#123; totalOutput += programmerOutput[i].linesOfCode;&#125; 3.11、使用多态替换条件语句为了让代码更简洁易读，如果你的函数中出现了条件判断，那么说明你的函数不止干了一件事情，违反了函数单一原则 ；并且绝大数场景可以使用多态替代 推荐： 123456789101112131415161718192021222324class Airplane &#123; // ...&#125;// 波音777class Boeing777 extends Airplane &#123; // ... getCruisingAltitude() &#123; return this.getMaxAltitude() - this.getPassengerCount(); &#125;&#125;// 空军一号class AirForceOne extends Airplane &#123; // ... getCruisingAltitude() &#123; return this.getMaxAltitude(); &#125;&#125;// 赛纳斯飞机class Cessna extends Airplane &#123; // ... getCruisingAltitude() &#123; return this.getMaxAltitude() - this.getFuelExpenditure(); &#125;&#125; 不推荐： 123456789101112131415class Airplane &#123; // ... // 获取巡航高度 getCruisingAltitude() &#123; switch (this.type) &#123; case &apos;777&apos;: return this.getMaxAltitude() - this.getPassengerCount(); case &apos;Air Force One&apos;: return this.getMaxAltitude(); case &apos;Cessna&apos;: return this.getMaxAltitude() - this.getFuelExpenditure(); &#125; &#125;&#125; 3.12、定时器是否清除代码中使用了定时器 setTimeout 和 setInterval，需要在不使用时进行清除。 四、SCSS 推荐写法4.1、变量 $ 使用利用scss中的变量配置，可以进行项目的颜色、字体大小统一更改（换肤），有利于后期项目的维护。 推荐： 1234$--color-success: #67C23A;$--color-warning: #E6A23C;$--color-danger: #F56C6C;$--color-info: #909399; 4.2、@import 导入样式文件scss中的@import规则在生成css文件时就把相关文件导入进来。这意味着所有相关的样式被归纳到了同一个css文件中，而无需发起额外的下载请求，在构建我们自己的组件库时推荐使用。 123456@import &quot;./base.scss&quot;;@import &quot;./pagination.scss&quot;;@import &quot;./dialog.scss&quot;;@import &quot;./autocomplete.scss&quot;;@import &quot;./dropdown.scss&quot;;@import &quot;./dropdown-menu.scss&quot;; 4.3、局部文件命名的使用scss局部文件的文件名以下划线开头。这样，scss就不会在编译时单独编译这个文件输出css，而只把这个文件用作导入。 推荐： checklist.png 4.4、父选择器标识符 &amp; 实现BEM 命令规范scss的嵌套和父选择器标识符&amp;能解决BEM命名的冗长，且使样式可读性更高。 推荐： 123456.el-input &#123; display: block; &amp;__inner &#123; text-align: center; &#125; &#125; 4.5、@mixin 混合器的使用mixin混合器用来实现大段样式的重用，减少代码的冗余，且支持传参。 12345678910111213141516@mixin button-size($padding-vertical, $padding-horizontal, $font-size, $border-radius) &#123; padding: $padding-vertical $padding-horizontal; font-size: $font-size; border-radius: $border-radius; &amp;.is-round &#123; padding: $padding-vertical $padding-horizontal; &#125;&#125; @include m(medium) &#123; @include button-size($--button-medium-padding-vertical, $--button-medium-padding-horizontal, $--button-medium-font-size, $--button-medium-border-radius); &#125; @include m(small) &#123; @include button-size($--button-small-padding-vertical, $--button-small-padding-horizontal, $--button-small-font-size, $--button-small-border-radius); &#125; 4.6、@extend 指令的使用（1）使用@extend产生 DRY CSS风格的代码（Don’t repeat yourself） （2）@mixin主要的优势就是它能够接受参数。如果想传递参数，你会很自然地选择@mixin而不是@extend 推荐： 123456789101112131415.common-mod &#123; height: 250px; width: 50%; background-color: #fff; text-align: center;&#125; .show-mod--right &#123; @extend .common-mod; float: right; &#125;.show-mod--left &#123; @extend .common-mod;&#125; 4.7、#{} 插值的使用插值能动态定义类名的名称，当有两个页面的样式类似时，我们会将类似的样式抽取成页面混合器，但两个不同的页面样式的命名名称根据BEM命名规范不能一样，这时我们可使用插值进行动态命名。 推荐： 12345678910111213141516@mixin home-content($class) &#123; .#&#123;$class&#125; &#123; position: relative; background-color: #fff; overflow-x: hidden; overflow-y: hidden; &amp;--left &#123; margin-left: 160px; &#125; &amp;--noleft &#123; margin-left: 0; &#125; &#125;&#125; 4.8、each遍历、map数据类型、@mixin/@include混合器、#{}插值 结合使用可通过each遍历、map数据类型、@mixin/@include混合器、#{}插值 结合使用，从而减少冗余代码，使代码更精简。 推荐： 12345678910111213141516171819$img-list: ( (xlsimg, $papers-excel), (xlsximg, $papers-excel), (gifimg, $papers-gif), (jpgimg, $papers-jpg), (mp3img, $papers-mp3), (mp4img, $papers-mp3), (docimg, $papers-word), (docximg, $papers-word), (rarimg, $papers-zip), (zipimg, $papers-zip), (unknownimg, $papers-unknown));@each $label, $value in $img-list &#123; .com-hwicon__#&#123;$label&#125; &#123; @include commonImg($value); &#125;&#125; 4.9、scss 自带函数的应用scss自带函数的应用，从而进行相关的计算，例如 mix函数的使用如下。 1234567891011121314 @include m(text) &#123; &amp;:hover, &amp;:focus &#123; color: mix($--color-white, $--color-primary, $--button-hover-tint-percent); border-color: transparent; background-color: transparent; &#125; &amp;:active &#123; color: mix($--color-black, $--color-primary, $--button-active-shade-percent); border-color: transparent; background-color: transparent; &#125;&#125; 4.10、gulp-sass的使用gulp-sass插件能实时监测scss代码检查其语法错误并将其编译成css代码，帮助开发人员检查scss语法的准确性，且其是否符合我们的预期，相关配置如下： 123456789gulp.task(&apos;gulpsass&apos;, function() &#123; return gulp.src(&apos;src/style/components/hwIcon.scss&apos;) .pipe(gulpsass().on(&apos;error&apos;, gulpsass.logError)) .pipe(gulp.dest(&apos;src/style/dest&apos;));&#125;);gulp.task(&apos;watch&apos;, function() &#123; gulp.watch(&apos;src/style/components/hwIcon.scss&apos;, [&apos;gulpsass&apos;]);&#125;); 五、Vue 推荐写法5.1、组件名为多个单词我们开发过程中自定义的组件的名称需要为多个单词，这样做可以避免跟现有的以及未来的HTML元素相冲突，因为所有的 HTML 元素名称都是单个单词的。 推荐： 12345678Vue.component(&apos;todo-item&apos;, &#123; // ...&#125;)export default &#123; name: &apos;TodoItem&apos;, // ...&#125; 不推荐： 12345678Vue.component(&apos;todo&apos;, &#123; // ...&#125;)export default &#123; name: &apos;Todo&apos;, // ...&#125; 5.2、组件的 data 必须是一个函数当在组件中使用 data 属性的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数。 因为如果直接是一个对象的话，子组件之间的属性值会互相影响。 推荐： 1234567export default &#123; data () &#123; return &#123; foo: &apos;bar&apos; &#125; &#125;&#125; 不推荐： 12345export default &#123; data: &#123; foo: &apos;bar&apos; &#125;&#125; 5.3、Prop定义应该尽量详细prop 的定义应该尽量详细，至少需要指定其类型。 推荐： 12345678910111213141516171819props: &#123; status: String&#125;// 更好的做法！props: &#123; status: &#123; type: String, required: true, validator: function (value) &#123; return [ &apos;syncing&apos;, &apos;synced&apos;, &apos;version-conflict&apos;, &apos;error&apos; ].indexOf(value) !== -1 &#125; &#125;&#125; 不推荐： 1props: [&apos;status&apos;] 5.4、为 v-for 设置键值v-for 中总是有设置 key 值。在组件上总是必须用 key 配合 v-for，以便维护内部组件及其子树的状态。 推荐： 1234567&lt;ul&gt; &lt;li v-for=&quot;todo in todos&quot; :key=&quot;todo.id&quot;&gt; &#123;&#123; todo.text &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 不推荐： 12345&lt;ul&gt; &lt;li v-for=&quot;todo in todos&quot;&gt; &#123;&#123; todo.text &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 5.5、完整单词的组件名组件名应该倾向于完整单词而不是缩写，编辑器中的自动补全已经让书写长命名的代价非常之低了，而其带来的明确性却是非常宝贵的。不常用的缩写尤其应该避免。 推荐： 123components/ |- StudentDashboardSettings.vue |- UserProfileOptions.vue 不推荐： 123components/ |- SdSettings.vue |- UProfOpts.vue 5.6、多个特性元素的每个特性分行在 JavaScript 中，用多行分隔对象的多个属性是很常见的最佳实践，因为这样更易读。 推荐： 12345&lt;MyComponent foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot;/&gt; 不推荐： 1&lt;MyComponent foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot;/&gt; 5.7、模板中简单的表达式组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的是什么，而非如何计算那个值。而且计算属性和方法使得代码可以重用。 推荐： 1234567891011&lt;!-- 在模板中 --&gt;&#123;&#123; normalizedFullName &#125;&#125;// 复杂表达式已经移入一个计算属性computed: &#123; normalizedFullName: function () &#123; return this.fullName.split(&apos; &apos;).map(function (word) &#123; return word[0].toUpperCase() + word.slice(1) &#125;).join(&apos; &apos;) &#125;&#125; 不推荐： 12345&#123;&#123; fullName.split(&apos; &apos;).map(function (word) &#123; return word[0].toUpperCase() + word.slice(1) &#125;).join(&apos; &apos;)&#125;&#125; 5.8、简单的计算属性应该把复杂计算属性分割为尽可能多的更简单的属性。 推荐： 1234567891011computed: &#123; basePrice: function () &#123; return this.manufactureCost / (1 - this.profitMargin) &#125;, discount: function () &#123; return this.basePrice * (this.discountPercent || 0) &#125;, finalPrice: function () &#123; return this.basePrice - this.discount &#125;&#125; 不推荐： 123456789computed: &#123; price: function () &#123; var basePrice = this.manufactureCost / (1 - this.profitMargin) return ( basePrice - basePrice * (this.discountPercent || 0) ) &#125;&#125; 5.9、指令缩写指令推荐都使用缩写形式，(用 : 表示 v-bind: 、用 @ 表示 v-on: 和用 # 表示 v-slot:)。 推荐： 1234&lt;input @input=&quot;onInput&quot; @focus=&quot;onFocus&quot;&gt; 不推荐： 1234&lt;input v-on:input=&quot;onInput&quot; @focus=&quot;onFocus&quot;&gt; 5.10、标签顺序保持一致单文件组件应该总是让标签顺序保持为 、、 。 推荐： 12345&lt;!-- ComponentA.vue --&gt;&lt;template&gt;...&lt;/template&gt;&lt;script&gt;/* ... */&lt;/script&gt;&lt;style&gt;/* ... */&lt;/style&gt; 不推荐： 12345&lt;!-- ComponentA.vue --&gt;&lt;template&gt;...&lt;/template&gt;&lt;style&gt;/* ... */&lt;/style&gt;&lt;script&gt;/* ... */&lt;/script&gt; 5.11、组件之间通信父子组件的通信推荐使用 prop和 emit ，而不是this.$parent或改变 prop； 兄弟组件之间的通信推荐使用 EventBus（$emit / $on），而不是滥用 vuex； 祖孙组件之间的通信推荐使用 $attrs / $listeners 或 provide / inject（依赖注入） ，而不是滥用 vuex； 5.12、页面跳转数据传递页面跳转，例如 A 页面跳转到 B 页面，需要将 A 页面的数据传递到 B 页面，推荐使用 路由参数进行传参，而不是将需要传递的数据保存 vuex，然后在 B 页面取出 vuex的数据，因为如果在 B 页面刷新会导致 vuex 数据丢失，导致 B 页面无法正常显示数据。 推荐： 12let id = &apos; 123&apos;;this.$router.push(&#123;name: &apos;homeworkinfo&apos;, query: &#123;id:id&#125;&#125;); 5.13、script 标签内部声明顺序script 标签内部的声明顺序如下： data > prop > components > filter > computed > watch > 钩子函数（钩子函数按其执行顺序） > methods 5.14、计算属性 VS 方法 VS 侦听器 （1）推荐使用计算属性：计算属性基于响应式依赖进行缓存，只在相关响应式依赖发生改变时它们才会重新求值；相比之下，每次调用方法都会再次执行方法； （2）推荐使用计算属性：而不是根据 Watch 侦听属性，进行回调； 但是有计算属性做不到的：当需要在数据变化时执行异步或开销较大的操作时，侦听器是最有用的。 5.15、v-if VS v-show v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的属性 display 进行切换。 推荐： 如果运行时，需要非常频繁地切换，推荐使用 v-show 比较好；如果在运行时，条件很少改变，则推荐使用 v-if 比较好。 六、团队其它规范6.1、尽量不手动操作 DOM因为团队现在使用 vue 框架，所以在项目开发中尽量使用 vue 的特性去满足我们的需求，尽量（不到万不得已）不要手动操作DOM，包括：增删改dom元素、以及更改样式、添加事件等。 6.2、删除弃用代码很多时候有些代码已经没有用了，但是没有及时去删除，这样导致代码里面包括很多注释的代码块，好的习惯是提交代码前记得删除已经确认弃用的代码，例如：一些调试的console语句、无用的弃用代码。 6.3、保持必要的注释代码注释不是越多越好，保持必要的业务逻辑注释，至于函数的用途、代码逻辑等，要通过语义化的命令、简单明了的代码逻辑，来让阅读代码的人快速看懂。","categories":[{"name":"前端文章","slug":"前端文章","permalink":"https://qw8.github.io/categories/前端文章/"}],"tags":[{"name":"代码评审","slug":"代码评审","permalink":"https://qw8.github.io/tags/代码评审/"}]},{"title":"编写高性能的JavaScript","slug":"articles/编写高性能的JavaScript","date":"2023-11-13T16:00:00.000Z","updated":"2024-02-18T02:33:34.000Z","comments":true,"path":"/articles/bian-xie-gao-xing-neng-de-javascript.html","link":"","permalink":"https://qw8.github.io/articles/bian-xie-gao-xing-neng-de-javascript.html","excerpt":"","text":"前言随着计算机硬件的不断升级，开发者越发觉得Javascript性能优化的好不好对网页的执行效率影响不明显，所以一些性能方面的知识被很多开发者忽视。但在某些情况下，不优化的Javascript代码必然会影响用户的体验。因此，即使在当前硬件性能已经大大提升的时代，在编写Javascript代码时，若能遵循Javascript规范和注意一些性能方面的知识，对于提升代码的可维护性和优化性能将大有好处。那么，接下来我们讨论几种能够提高JavaScript性能的方法。 1、js文件加载和执行（1）将&lt;script&gt;标签放到&lt;body&gt;标签的底部 （2）可以合并多个js文件，减少页面中&lt;script&gt;标签改善性能 （3）使用 defer 属性，加载后续文档元素的过程将和script.js的加载并行进行，但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded事件触发之前完成。 （4）使用 async 属性，加载和渲染后续文档元素的过程将和script.js的加载与执行并行进行 （5）动态加载脚本元素，无论在何时启动瞎子，文件的下载和执行过程都不会阻塞页面其它进程 1234var script = document.createElement(&apos;script&apos;);script.type = &apos;text/javascript&apos;;script.src = &apos;file.js&apos;;document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script); 2、标识符所在的作用域链的位置越深标识符所在的作用域链的位置越深，那么它的标识符解析的性能就越慢。所以一个好的性能提升的经验法则是：如果某个跨作用域的值在函数中被引用一次以上，那么就把它存储到局部变量里。 12345678910function fun1() &#123; // 将全局变量的引用先存储在一个局部变量中，然后使用这个局部变量代替全局变量，从而提高 // 性能；不然每次(3次)都要遍历整个作用域链找到document var doc = document; var bd = doc.body; var links = doc.getElementsByTagName(&apos;a&apos;); doc.getElementById(&apos;btn&apos;).onclick = function()&#123; console.log(&apos;btn&apos;); &#125;&#125; 3、避免过长原型链继承方法或属性在原型链中存在的位置越深，搜索它的性能也就越慢，所以要避免N多层原型链的写法。 4、对象成员嵌套过深对象的嵌套成员，对象成员嵌套越深，读取速度也就越慢。所以好的经验法则是：如果在函数中需要多次读取一个对象属性，最佳做法是将该属性值保存在局部变量中，避免多次查找带来的性能开销。 12345678910function f() &#123; // 因为在以下函数中需要3次用到DOM对象属性，所以先将它存储在一个局部变量 // 中，然后使用这个局部变量代替它进行后续操作，从而提高性能 var dom = YaHOO.util.Dom; if(Dom.hasClass(element,&apos;selected&apos;))&#123; Dom.removeClass(elemet,&apos;selected&apos;); &#125;else&#123; Dom.addClass(elemet,&apos;selected&apos;); &#125;&#125; 5、DOM操作用js访问和操作DOM都会带来性能损失，可通过以下几点来减少性能损失： （1）尽可能减少DOM访问次数； （2）如果需要多次访问某个DOM节点，请使用局部变量存储它的引用； （3）小心处理HTML集合，因为它实时连系着底层文档；我们可以把集合的长度缓存到一个变量中，并在迭代中使用它； （4）下述情况会发生重排： 添加或删除可见的DOM元素； 元素位置改变； 元素尺寸改变（包括：外边距、内边距、边框厚度、宽度、高度等属性）； 内容改变（例如：文本改变或图片被另一个不同尺寸的图片改变）； 页面渲染器初始化； 浏览器窗口尺寸改变 可通过以下方式减少重排： 留意上面会导致重排的操作，尽量避免； 获取布局信息的操作会导致强制渲染队列重排，应该尽量避免使用以下获取布局信息的操作方法或属性或者缓存布局信息，例如：offsetTop,offsetLeft,offsetWidthoffsetHeight,``scrollTop,scrollLeft,scrollWidth,scrollHeight,clientTop,clientLeft,clientWidth,clientHeight,getComputedStyle()等; 批量修改样式，例如使用： 12345678910function f() &#123; // 推荐使用以下操作 var el1 = document.getElementById(&apos;mydiv&apos;); el1.style.cssText = &apos;border:1px;padding:2px;margin:3px&apos;; // 不推荐使用以下操作 var el2 = document.getElementById(&apos;mydiv&apos;); el2.style.border = &apos;1px&apos;; el2.style.padding = &apos;2px&apos;; el2.style.margin = &apos;3px&apos;;&#125; 当需要批量修改DOM时，可以通过以下步骤减少重绘和重排的次数： 使元素脱离文档流（隐藏元素、拷贝元素） 对其应用多重改变； 把元素带回文档中 使用事件委托（事件逐层冒泡并能被父级元素捕获，使用事件代理，只需给外层元素绑定一个处理器，就可以处理其子元素上触发的所用事件），因为给DOM元素绑定事件以及浏览器需要跟踪每个事件处理器都需要消耗性能。 6、字符串连接12str += &apos;one&apos;+&apos;two&apos;;str= str+&apos;one&apos;+&apos;two&apos;; 后者方式会比前者少在内存中创建一个临时字符串，所以性能有相应的提升，所以，所以推荐后者的写法。 7、直接使用字面量创建对象和数组推荐使用字面量，因为这不仅是性能最优也有助于节省代码量。 12345var obj = &#123; name:&apos;tom&apos;, age:15, sex:&apos;男&apos;&#125; ​ 8、数组长度缓存如果需要遍历数组，应该先缓存数组长度，将数组长度放入局部变量中，避免多次查询数组长度。 9、循环比较JS提供了三种循环：for(;;)、while()、for(in)。在这三种循环中 for(in)的效率最差，因为它需要查询Hash键，因此应尽量少用for(in)循环，for(;;)、while()循环的性能基本持平。 10、少用eval尽量少使用eval，每次使用eval需要消耗大量时间，这时候使用JS所支持的闭包可以实现函数模板。 11、字符串转换当需要将数字转换成字符时，采用如下方式：&quot;&quot; + 1。从性能上来看，将数字转换成字符时，有如下公式：(&quot;&quot; +) &gt; String() &gt; .toString() &gt; new String()。String()属于内部函数，所以速度很快。而.toString()要查询原型中的函数，所以速度逊色一些，new String()需要重新创建一个字符串对象，速度最慢。 12、浮点数转换整形当需要将浮点数转换成整型时，应该使用Math.floor()或者Math.round()。而不是使用parseInt(),该方法用于将字符串转换成数字。而且Math是内部对象，所以Math.floor()其实并没有多少查询方法和调用时间，速度是最快的。","categories":[{"name":"前端文章","slug":"前端文章","permalink":"https://qw8.github.io/categories/前端文章/"}],"tags":[{"name":"前端优化","slug":"前端优化","permalink":"https://qw8.github.io/tags/前端优化/"}]},{"title":"正则表达式","slug":"knowledges/正则表达式","date":"2023-11-13T12:01:23.000Z","updated":"2024-04-26T09:21:07.221Z","comments":true,"path":"/knowledges/zheng-ze-biao-da-shi.html","link":"","permalink":"https://qw8.github.io/knowledges/zheng-ze-biao-da-shi.html","excerpt":"","text":"正则表达式正则表达式为标书字符串规则的表达式。下面为两个例子为在 JavaScript 中的使用， /pattern/attrs new RegExp(pattern, attrs) 锚点锚点用于匹配一个位置，下列为常用的锚点 ^ 起始的位置 /^http/ $ 结尾的位置 /\\.jpg$/ \\b 单词边界 字符类字符类用于匹配一类字符中的一个，下面为几个常用的例子， [abc] 可用于匹配 a b 还有 c [0-9] 可用于匹配一个数字 [^0-9] 可用于匹配一个非数字 [a-z] 可用于匹配一个字母 . 任意字符但换行符除外 元字符元字符为具有特殊意义的字符。常见的有， ^, $, \\b \\d 用于匹配数字 [0-9] \\D 用于匹配 [^\\d] \\s 用于匹配空白符 \\S 用于匹配非空白符 [^\\s] \\w 用于匹配任意单词字符（例如程序中的变量字符） [A-Za-z0-9_] \\W 用于匹配非单词字符 [^\\W] 量词量词用于表现字符出现的次数。可用的连词如下， {m,n} 用于表示出现 m 到 n 次之间。 * 用于表示出现 0 到无穷之间也就等同于 {0,} ? 用于表示出现 0 次到 1 次也等同于 {0,1} + 用于表现出现 1 次以及一次以上也等同于 {1,} 转移符转义符需要在匹配的字符是元字符的时候使用。使用 \\ 来进行转移即可。 多选分支多选分支用于表示或的概念。/thi(c|n)k/ 其又等同于 /thi[cn]k/。其还可以用于匹配文件扩展名 /\\.(png|jpg|jpeg|gif)$/ 。 常用方法测试：regxObj.test(str)其用于测试正则表达式与指定字符串是否匹配。 123/123/.test(123); // true/123/.test(111); // false/123/.test(&apos;x123&apos;); // true 捕获其用于保存所匹配到的字符串为后续开发所用。() 可用于捕获，正则表达式再运行时会将其保存下来，(?:) 则不予保存。 12345678910// str.match(regexp)var url = &apos;http://www.google.com/query?test=li-xinyang#cool&apos;;var reg = /(https?:)\\/\\/([^\\/]+)(\\/[^\\?]*)?(\\?[^#]*)?(#.*)?/;var arr = url.match(reg);var protocol = arr[1];var host = arr[2];var pathname = arr[3];var search = arr[4];var hash = arr[5]; 搜索与替换regexpObj.exec(str) 可以提供更强大的检索，它可以提供更详尽的结果 index 也可以提供过程状态 lastIndex。 str.replace(regex/substr, replacement) 可以使用正则表达式来对字符串进行替换。 常见的表单验证1234567891011121314151617// 用户名正则，4到16位（字母，数字，下划线，减号）var userNameReg = /^[a-zA-Z0-9_-]&#123;4,16&#125;$/;// 密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符var passwordReg = /^.*(?=.&#123;6,&#125;)(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&amp;*? ]).*$/;// 匹配邮箱地址var mailReg = /\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*/;// 中国六位数的邮政编码var postalCode = /^\\d&#123;6&#125;$/;// 匹配15~18位身份证var IDCard = /(^[1-9]\\d&#123;5&#125;(18|19|([23]\\d))\\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d&#123;3&#125;[0-9Xx]$)|(^[1-9]\\d&#123;5&#125;\\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d&#123;2&#125;$)/;// 匹配18位的新版身份证var IDCard_18 = /^[1-9]\\d&#123;5&#125;(18|19|([23]\\d))\\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d&#123;3&#125;[0-9Xx]$/; 网络相关123456789101112131415161718192021//ipv4地址正则var IPReg = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;// Reg Hex颜色正则var pattern = /^#?([a-fA-F0-9]&#123;6&#125;|[a-fA-F0-9]&#123;3&#125;)$/;// URL正则var urlReg= /^((https?|ftp|file):\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]&#123;2,6&#125;)([\\/\\w \\.-]*)*\\/?$/;// 匹配JSON格式var reg = /^\\w+\\((&#123;[^()]+&#125;)\\)$/匹配json字符串var ret = response.data;if (typeof ret === 'string') &#123; var reg = /^\\w+\\((&#123;[^()]+&#125;)\\)$/ var matches = ret.match(reg); if (matches) ret = JSON.parse(matches[1]);&#125;res.json(ret); 联系方式1234567891011// 5-11位的腾讯qq号var qqReg = /^[1-9][0-9]&#123;4,11&#125;$/;// 微信号正则，6至20位，以字母开头，字母，数字，减号，下划线var qqReg = /^[a-zA-Z]([-_a-zA-Z0-9]&#123;5,19&#125;)+$/;// 国内常见var phone = /^1[3|5|8|9]\\d&#123;9&#125;$/;// 固定电话var telephone = /^(0[0-9]&#123;2&#125;)\\d&#123;8&#125;$|^(0[0-9]&#123;3&#125;(\\d&#123;7,8&#125;))$/; 匹配特定数字1234567891011121314151617181920212223242526272829// 匹配正整数var reg = /^[1-9]\\d*$/;// 匹配负整数var reg = /^-[1-9]\\d*$/;// 匹配整数var reg = /^-?[1-9]\\d*$/;// 匹配非负整数（正整数 + 0）var reg = /^[1-9]\\d*|0$/;// 匹配非正整数（负整数 + 0）var reg = /^-[1-9]\\d*|0$/;// 匹配正浮点数var reg = /^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$/;// 匹配负浮点数var reg = /^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$/;// 匹配浮点数var reg = /^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$/;// 匹配非负浮点数（正浮点数 + 0）var reg = /^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$/;// 匹配非正浮点数（负浮点数 + 0）var reg = /^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$/; 字符串相关123456789101112131415161718192021222324// 匹配由26个英文字母组成的字符串var reg = /^[A-Za-z]+$/;// 匹配由26个英文字母的大写组成的字符串var reg = /^[A-Z]+$/;// 匹配由26个英文字母的小写组成的字符串var reg = /^[a-z]+$/;// 匹配由数字和26个英文字母组成的字符串var reg = /^[A-Za-z0-9]+$/;// 匹配由数字、26个英文字母或者下;划线组成的字符串var reg = /^\\w+$/;// 匹配空白行的正则表达式var reg = /\\n\\s*\\r/;// 匹配首尾空白字符的正则表达式var reg = /^\\s*|\\s*$/;var rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;// 匹配双字节字符(包括汉字在内, 一个双字节字符长度计2，ASCII字符计1)var reg = /[^\\x00-\\xff]/g; 以上部分摘自这里 https://github.com/anran758/Front-End-Lab/tree/master/REGEXP 匹配网址的正则1/(http|ftp|https):\\/\\/[\\w\\-_]+(\\.[\\w\\-_]+)+([\\w\\-\\.,@?^=%&amp;:/~\\+#]*[\\w\\-\\@?^=%&amp;/~\\+#])?/gi 去除html标签1/&lt;\\/?.+?&gt;/g 正则是啥？下面是我对正则的理解： 正则就是用有限的符号，表达无限的序列，殆已！ 正则表达式的语法一般如下(js)，两条斜线中间是正则主体，这部分可以有很多字符组成；i部分是修饰符，i的意思表示忽略大小写 1/^abc/i 正则定义了很多特殊意义的字符，有名词，量词，谓词等，下面逐一介绍 简单字符没有特殊意义的字符都是简单字符，简单字符就代表自身，绝大部分字符都是简单字符，举个例子 1234/abc/ // 匹配 abc/123/ // 匹配 123/-_-/ // 匹配 -_-/海镜/ // 匹配 海镜 转义字符\\是转义字符，其后面的字符会代表不同的意思，转义字符主要有三个作用： 第一种，是为了匹配不方便显示的特殊字符，比如换行，tab符号等 第二种，正则中预先定义了一些代表特殊意义的字符，比如\\w等 第三种，在正则中某些字符有特殊含义(比如下面说到的)，转义字符可以让其显示自身的含义 下面是常用转义字符列表： \\n 匹配换行符 \\r 匹配回车符 \\t 匹配制表符，也就是tab键 \\v 匹配垂直制表符 \\x20 20是2位16进制数字，代表对应的字符 \\u002B 002B是4位16进制数字，代表对应的字符 \\u002B 002B是4位16进制数字，代表对应的字符 \\w 匹配任何一个字母或者数字或者下划线 \\W 匹配任何一个字母或者数字或者下划线以外的字符 \\s 匹配空白字符，如空格，tab等 \\S 匹配非空白字符 \\d 匹配数字字符，0~9 \\D 匹配非数字字符 \\b 匹配单词的边界 \\B 匹配非单词边界 \\ 匹配\\本身 字符集和有时我们需要匹配一类字符，字符集可以实现这个功能，字符集的语法用[``]分隔，下面的代码能够匹配a或b或c 1[abc] 如果要表示字符很多，可以使用-表示一个范围内的字符，下面两个功能相同 12[0123456789][0-9] 在前面添加^，可表示非的意思，下面的代码能够匹配a``b``c之外的任意字符 1[^abc] 其实正则还内置了一些字符集，在上面的转义字符有提到，下面给出内置字符集对应的自定义字符集 . 匹配除了换行符（\\n）以外的任意一个字符 = [^\\n] \\w = [0-9a-zA-Z_] \\W = [^0-9a-zA-Z_] \\s = [ \\t\\n\\v] \\S = [^ \\t\\n\\v] \\d = [0-9] \\D = [^0-9] 量词如果我们有三个苹果，我们可以说自己有个3个苹果，也可以说有一个苹果，一个苹果，一个苹果，每种语言都有量词的概念 如果需要匹配多次某个字符，正则也提供了量词的功能，正则中的量词有多个，如?、+、*、{n}、{m,n}、{m,} 123456`&#123;n&#125;`匹配n次，比如`a&#123;2&#125;`，匹配`aa`&#123;m, n&#125;`匹配m-n次，优先匹配n次，比如`a&#123;1,3&#125;`，可以匹配`aaa`、`aa`、`a``&#123;m,&#125;`匹配m-∞次，优先匹配∞次，比如`a&#123;1,&#125;`，可以匹配`aaaa...``?`匹配0次或1次，优先匹配1次，相当于`&#123;0,1&#125;``+`匹配1-n次，优先匹配n次，相当于`&#123;1,&#125;``*`匹配0-n次，优先匹配n次，相当于`&#123;0,&#125;` 正则默认和人心一样是贪婪的，也就是常说的贪婪模式，凡是表示范围的量词，都优先匹配上限而不是下限 1a&#123;1, 3&#125; // 匹配字符串&apos;aaa&apos;的话，会匹配aaa而不是a 有时候这不是我们想要的结果，可以在量词后面加上?，就可以开启非贪婪模式 1a&#123;1, 3&#125;? // 匹配字符串&apos;aaa&apos;的话，会匹配a而不是aaa 字符边界有时我们会有边界的匹配要求，比如以xxx开头，以xxx结尾 ^在[]外表示匹配开头的意思 1^abc // 可以匹配abc，但是不能匹配aabc $表示匹配结尾的意思 1abc$ // 可以匹配abc，但是不能匹配abcc 上面提到的\\b表示单词的边界 1abc\\b // 可以匹配 abc ，但是不能匹配 abcc 选择表达式有时我们想匹配x或者y，如果x和y是单个字符，可以使用字符集，[abc]可以匹配a或b或c，如果x和y是多个字符，字符集就无能为力了，此时就要用到分组 正则中用|来表示分组，a|b表示匹配a或者b的意思 1123|456|789 // 匹配 123 或 456 或 789 分组与引用分组是正则中非常强大的一个功能，可以让上面提到的量词作用于一组字符，而非单个字符，分组的语法是圆括号包裹(xxx) 1(abc)&#123;2&#125; // 匹配abcabc 分组不能放在[]中，分组中还可以使用选择表达式 1(123|456)&#123;2&#125; // 匹配 123123、456456、123456、456123 和分组相关的概念还有一个捕获分组和非捕获分组，分组默认都是捕获的，在分组的(后面添加?:可以让分组变为非捕获分组，非捕获分组可以提高性能和简化逻辑 12&apos;123&apos;.match(/(?:123)/) // 返回 [&apos;123&apos;]&apos;123&apos;.match(/(123)/) // 返回 [&apos;123&apos;, &apos;123&apos;] 和分组相关的另一个概念是引用，比如在匹配html标签时，通常希望``后面的xxx能够和前面保持一致 引用的语法是\\数字，数字代表引用前面第几个捕获分组，注意非捕获分组不能被引用 1&lt;([a-z]+)&gt;&lt;\\/\\1&gt; // 可以匹配 `&lt;span&gt;&lt;/span&gt;` 或 `&lt;div&gt;&lt;/div&gt;`等 预搜索如果你想匹配xxx前不能是yyy，或者xxx后不能是yyy，那就要用到预搜索 js只支持正向预搜索，也就是xxx后面必须是yyy，或者xxx后面不能是yyy 121(?=2) // 可以匹配12，不能匹配221(?!2) // 可有匹配22，不能匹配12 修饰符默认正则是区分大小写，这可能并不是我们想要的，正则提供了修饰符的功能，修复的语法如下 1/xxx/gi // 最后面的g和i就是两个修饰符 g正则遇到第一个匹配的字符就会结束，加上全局修复符，可以让其匹配到结束 i正则默认是区分大小写的，i可以忽略大小写 m正则默认情况下，^和只能匹配字符串的开始和结尾，修饰符可以让和匹配行首和行尾，不理解就看例子 12345/jing$/ // 能够匹配 &apos;yanhaijing，不能匹配 &apos;yanhaijing\\n&apos;/jing$/m // 能够匹配 &apos;yanhaijing， 能够匹配 &apos;yanhaijing\\n&apos;/^jing/ // 能够匹配 &apos;jing&apos;，不能匹配 &apos;\\njing&apos;/^jing/m // 能够匹配 &apos;jing&apos;，能够匹配 &apos;\\njing&apos; 图形化工具有时我们会遇到特别复杂的正则，有时候可能不太直观，下面推荐一个图形化展示的工具，我们把涉及到的语法罗列一下 1/^[a-z]*[^\\d]&#123;1,10&#125;?(aaa|bbb)(?:ccc)$/ 可以看到工具能够更快的帮我们理清头绪 图片 JavaScript中的正则在js中创建正则有两种办法，字面量和new，和创建其他类型变量一样 12var reg = /abc/g // 字面量var reg = new RegExp(&apos;abc&apos;, &apos;g&apos;) // new方式，意思和上面一样 js中用到正则的地方有两个入口，正则的api和字符串的api，RegExp#test等于RegExp.prototype.test RegExp#test RegExp#exec String#search String#match String#split String#replace RegExp#test每个正则实例都有test方法，test的参数是字符串，返回值是布尔值，表示当前正则是否能匹配指定的字符串 12/abc/.test(&apos;abc&apos;) // true/abc/.test(&apos;abd&apos;) // false RegExp#execexec使用方法和test一样，只是返回值并不是布尔值，而是返回匹配的结果 匹配成功返回一个数组，数组第一项是匹配结果，后面一次是捕获的分组 1/abc(d)/.exec(&apos;abcd&apos;) // [&quot;abcd&quot;, &quot;d&quot;, index: 0, input: &quot;abcd&quot;] 此数组还有另外两个参数，input是输入的字符串，index表示匹配成功的序列在输入字符串中的索引位置 如果有全局参数(g)，第二次匹配时将从上次匹配结束时继续 12345678var r1 = /ab/r1.exec(&apos;ababab&apos;) // [&apos;ab&apos;, index: 0]r1.exec(&apos;ababab&apos;) // [&apos;ab&apos;, index: 0]var r2 = /ab/gr2.exec(&apos;ababab&apos;) // [&apos;ab&apos;, index: 0]r2.exec(&apos;ababab&apos;) // [&apos;ab&apos;, index: 2]r2.exec(&apos;ababab&apos;) // [&apos;ab&apos;, index: 4] 这一特性可以被用于循环匹配，比如统计字符串中abc的次数 12345678var reg = /abc/gvar str = &apos;abcabcabcabcabc&apos;var num = 0;var match = null;while((match = reg.exec(str)) !== null) &#123; num++&#125;console.log(num) // 5 如果匹配失败则返回null 1/abc(d)/.exec(&apos;abc&apos;) // null String#searchsearch方法返回匹配成功位置的索引，参数是字符串或正则，结果是索引 12&apos;abc&apos;.search(/abc/) // 0&apos;abc&apos;.search(/c/) // 2 如果匹配失败则返回-1 123&apos;abc&apos;.search(/d/) // -1&apos;abc&apos;.search(/d/) !== -1 // false 转换为布尔值 String#matchmatch方法也会返回匹配的结果，匹配结果和exec类似 12&apos;abc&apos;.match(/abc/) // [&apos;abc&apos;, index: 0, input: abc]&apos;abc&apos;.match(/abd/) // null 如果有全局参数(g)，match会返回所有的结果，并且没有index和input属性 1&apos;abcabcabc&apos;.match(/abc/g) // [&apos;abc&apos;, &apos;abc&apos;, &apos;abc&apos;] String#split字符串的split方法，可以用指定符号分隔字符串，并返回数据 1&apos;a,b,c&apos;.split(&apos;,&apos;) // [a, b, c] 其参数也可以使一个正则，如果分隔符有多个时，就必须使用正则 1&apos;a,b.c&apos;.split(/,|\\./) // [a, b, c] String#replace字符串的replace方法，可以将字符串的匹配字符，替换成另外的指定字符 1&apos;abc&apos;.replace(&apos;a&apos;, &apos;b&apos;) // &apos;bbc&apos; 其第一个参数可以是正则表达式，如果想全局替换需添加全局参数 12&apos;abc&apos;.replace(/[abc]/, &apos;y&apos;) // ybc&apos;abc&apos;.replace(/[abc]/g, &apos;y&apos;) // yyy 全局替换 在第二个参数中，也可以引用前面匹配的结果 1234&apos;abc&apos;.replace(/a/, &apos;$&amp;b&apos;) // abbc $&amp; 引用前面的匹配字符&apos;abc&apos;.replace(/(a)b/, &apos;$1a&apos;) // aac &amp;n 引用前面匹配字符的分组&apos;abc&apos;.replace(/b/, &apos;$\\&apos;&apos;) // aac $` 引用匹配字符前面的字符&apos;abc&apos;.replace(/b/, &quot;$&apos;&quot;) // acc $&apos; 引用匹配字符后面的字符 replace的第二个参数也可以是函数，其第一个参数是匹配内容，后面的参数是匹配的分组 1234&apos;abc&apos;.replace(/\\w/g, function (match, $1, $2) &#123; return match + &apos;-&apos;&#125;)// a-b-c- RegExpRegExp是一个全局函数，可以用来创建动态正则，其自身也有一些属性 $_ $n input length lastMatch 来个例子 1234567/a(b)/.exec(&apos;abc&apos;) // [&quot;ab&quot;, &quot;b&quot;, index: 0, input: &quot;abc&quot;]RegExp.$_ // abc 上一次匹配的字符串RegExp.$1 // b 上一次匹配的捕获分组RegExp.input // abc 上一次匹配的字符串RegExp.lastMatch // ab 上一次匹配成功的字符RegExp.length // 2 上一次匹配的数组长度 实例属性正则表达式的实例上也有一些属性 flags ignoreCase global multiline source lastIndex 还是看例子 1234567var r = /abc/igm;r.flags // igmr.ignoreCase // truer.global // truer.multiline // truer.source // abc lastIndex比较有意思，表示上次匹配成功的是的索引 123456var r = /abc/igm;r.exec(&apos;abcabcabc&apos;)r.lastIndex // 3r.exec(&apos;abcabcabc&apos;)r.lastIndex // 6 可以更改lastIndex让其重新开始 123456var r = /abc/igm;r.exec(&apos;abcabcabc&apos;) // [&quot;abc&quot;, index: 0]r.exec(&apos;abcabcabc&apos;) // [&quot;abc&quot;, index: 3]r.lastIndex = 0r.exec(&apos;abcabcabc&apos;) // [&quot;abc&quot;, index: 0] 实战实例来几个常用的例子 12345/(?:0\\d&#123;2,3&#125;-)?\\d&#123;7&#125;/ // 电话号 010-xxx xxx/^1[378]\\d&#123;9&#125;$/ // 手机号 13xxx 17xxx 18xxx/^[0-9a-zA-Z_]+@[0-9a-zA-Z]+\\.[z-z]+$/ // 邮箱 去除字符串前后空白 1str = str.replace(/^\\s*|\\s*$/g, &apos;&apos;)","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"正则","slug":"正则","permalink":"https://qw8.github.io/tags/正则/"},{"name":"表单校验","slug":"表单校验","permalink":"https://qw8.github.io/tags/表单校验/"}]},{"title":"uniapp组件","slug":"knowledges/uniapp组件","date":"2023-04-30T00:03:10.000Z","updated":"2024-03-28T17:46:30.000Z","comments":true,"path":"/knowledges/uniapp-zu-jian.html","link":"","permalink":"https://qw8.github.io/knowledges/uniapp-zu-jian.html","excerpt":"","text":"弹窗确认提示框组件Alert.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;template&gt; &lt;view class=&quot;alert-bg&quot; v-if=&quot;isShow&quot; catchtouchmove=&apos;true&apos;&gt; &lt;view class=&quot;alert&quot;&gt; &lt;text class=&quot;title&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;text class=&quot;content&quot; v-if=&quot;content&quot;&gt;&#123;&#123;content&#125;&#125;&lt;/text&gt; &lt;slot&gt;&lt;/slot&gt; &lt;view class=&quot;button-bg&quot;&gt; &lt;view class=&quot;left button&quot; v-if=&quot;showCancel&quot; @click=&quot;cancel&quot;&gt;&#123;&#123;cancelText&#125;&#125;&lt;/view&gt; &lt;view :class=&quot;showCancel ? &apos;right button&apos;:&apos;full button&apos;&quot; :style=&quot;&#123;color:confirmColor&#125;&quot; @click=&quot;confirm&quot;&gt;&#123;&#123;confirmText&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123;&#125;, data() &#123; return &#123; isShow: false, // 是否显示 title: &apos;&apos;, // 标题 content: &apos;&apos;, // 内容 cancelText: &apos;取消&apos;, // 取消按钮文字 confirmText: &apos;确定&apos;, // 确定按钮文字 confirmColor: &apos;#247bff&apos;, // 确定按钮的文字颜色 url: &apos;&apos;, // 确定后需跳转页面路径 showCancel: true ,// 是否显示取消按钮 isNavigate: true // 是否navigateTo &#125; &#125;, computed: &#123;&#125;, created() &#123;&#125;, methods: &#123; // 显示弹框 show(obj) &#123; console.log(obj) this.isShow = true this.title = obj.title || &apos;&apos; this.content = obj.content || &apos;&apos; this.cancelText = obj.cancelText || &apos;取消&apos; this.confirmText = obj.confirmText || &apos;确定&apos; this.confirmColor = obj.confirmColor || &apos;#247bff&apos; this.url = obj.url || &apos;&apos; this.showCancel = obj.showCancel === false ? false : true this.isNavigate = obj.isNavigate === false ? false : true &#125;, // 取消：关闭弹框 cancel() &#123; this.isShow = false &#125;, // 确认：跳转对应页面 confirm() &#123; // 有url就跳转 if (this.url) &#123; if(this.isNavigate)&#123; uni.navigateTo(&#123; url: this.url &#125;) &#125; else &#123; uni.switchTab(&#123; url: this.url &#125;) &#125; &#125; else if (this.showCancel) &#123; // 如果有取消按钮，触发父组件回调事件 this.$emit(&apos;confirm&apos;) &#125; this.isShow = false &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.alert-bg &#123; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: flex; justify-content: center; align-items: center; z-index: 999; .alert &#123; width: calc(100% - 128rpx); display: flex; flex-direction: column; align-items: center; border-radius: 16rpx; z-index: 1000; background-color: #ffffff; .title &#123; font-size: 32rpx; font-weight: 500; color: #33373d; line-height: 40rpx; margin: 48rpx 0 40rpx 0; &#125; .content &#123; font-size: 28rpx; color: #5e6166; line-height: 36rpx; margin: 0 48rpx; text-align: center; &#125; .button-bg &#123; width: 100%; margin-top: 48rpx; font-size: 32rpx; border-top: 1px solid #f0f2f5; display: flex; .button &#123; text-align: center; padding: 24rpx 0; &#125; .left &#123; width: 50%; color: #33373d; border-right: 1px solid #f0f2f5; &#125; .full &#123; width: 100%; &#125; .right &#123; width: 50%; &#125; &#125; &#125;&#125;&lt;/style&gt; 使用方式： 1234567891011&lt;!-- 自定义弹窗 --&gt;&lt;Alert ref=&quot;alertRef&quot;&gt;&lt;/Alert&gt;this.$refs.alertRef.show(&#123; title: &apos;请添加收款账户&apos;, content: &apos;您还未添加收款账户信息，为了方便企业进行费用结算，请尽快前往添加收款账户信息&apos;, cancelText: &apos;稍后&apos;, confirmText: &apos;去添加&apos;, url: &apos;/sub_my/account/AddAccount&apos;&#125;) 打卡弹窗组件ClockPopup.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544&lt;template&gt; &lt;view class=&quot;popup&quot; v-if=&quot;isShow&quot;&gt; &lt;view class=&quot;content&quot;&gt; &lt;image class=&quot;bg-top&quot; :src=&quot;imgUrl+&apos;clock_top@2x.png&apos;&quot; /&gt; &lt;image class=&quot;bg-bottom&quot; :src=&quot;imgUrl+&apos;clock_bottom@2x.png&apos;&quot; /&gt; &lt;view class=&quot;inner&quot;&gt; &lt;view class=&quot;rotate&quot; v-if=&quot;state===0&quot;&gt; &lt;image class=&quot;ring&quot; :src=&quot;imgUrl+&apos;clock2@2x.png&apos;&quot; /&gt; &lt;image class=&quot;circle&quot; :src=&quot;imgUrl+&apos;clock1@2x.png&apos;&quot; /&gt; &lt;text&gt;打卡中...&lt;/text&gt; &lt;/view&gt; &lt;image class=&quot;success&quot; :src=&quot;imgUrl+&apos;clock5@2x.png&apos;&quot; v-if=&quot;state===1&quot; /&gt; &lt;view class=&quot;success-text&quot; v-if=&quot;state===1&quot;&gt;打卡成功&lt;/view&gt; &lt;view class=&quot;address&quot; v-if=&quot;state===0||state===1&quot;&gt; &lt;image :src=&quot;imgUrl+&apos;clock3@2x.png&apos;&quot; /&gt; &lt;view class=&quot;text&quot;&gt;&#123;&#123;state===0?&apos;当前&apos;:&apos;打卡&apos;&#125;&#125;位置：&#123;&#123;address&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;image class=&quot;fail&quot; src=&quot;/static/images/clock6.png&quot; mode=&quot;widthFix&quot; v-if=&quot;state===2&quot; /&gt; &lt;view class=&quot;fail-text&quot; v-if=&quot;state===2&quot;&gt;打卡失败&lt;/view&gt; &lt;view class=&quot;address&quot; v-if=&quot;state===2&quot;&gt; &lt;image src=&quot;/static/images/clock7.png&quot; /&gt; &lt;view class=&quot;text&quot;&gt;失败原因：&#123;&#123;tip&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;again&quot; v-if=&quot;state===2&quot; @click=&quot;setRecord&quot;&gt; &lt;image src=&quot;/static/images/clock8.png&quot; /&gt; &lt;text&gt;重新打卡&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;image class=&quot;close&quot; src=&quot;/static/images/clock4.png&quot; @click=&quot;close&quot; /&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;import Config from &apos;@/config&apos;import $http from &apos;@/api/http&apos;import Utils from &apos;@/utils/index&apos;import QQMapWX from &apos;@/utils/qqmap-wx-jssdk.min.js&apos;import &#123; mapState &#125; from &apos;vuex&apos;export default &#123; props: &#123; tripId: &#123; type: Number, value: 0 &#125;, markers: &#123; type: Array, value: [] &#125;, clock_radius: &#123; type: Number, value: 1000 &#125; &#125;, data() &#123; return &#123; imgUrl: Config.imgUrl, // 图片地址 isShow: false, // 是否显示弹窗 tMap: null, // 腾讯地图实例 location: &#123;&#125;, // 位置信息 title: &apos;&apos;, // 当前位置标题 address: &apos;&apos;, // 当前位置详情 state: 0, // 0打卡中，1打卡成功，2打卡失败 tip: &apos;网络异常&apos; // 失败原因 &#125; &#125;, computed: &#123; ...mapState(&#123; envType: (state) =&gt; state.login.envType, map: (state) =&gt; state.login.map &#125;) &#125;, created() &#123; // 微信/企微 if (this.envType === 1 || this.envType === 2) &#123; // 同步获取位置改变 this.getWxLocation() &#125; // 钉钉 if (this.envType === 3) &#123; // 普通获取当前位置坐标 this.getLocation() &#125; // 实例化腾讯地图API核心类 this.tMap = new QQMapWX(&#123; key: this.map.key // 开发者密钥 &#125;) &#125;, methods: &#123; // 打开弹框 open() &#123; // 微信/企微 if (this.envType === 1 || this.envType === 2) &#123; // 同步获取位置改变 this.getWxLocation() &#125; // 钉钉 if (this.envType === 3) &#123; // 普通获取当前位置坐标 this.getLocation() &#125; this.isShow = true console.time(&apos;耗时&apos;) this.setRecord() console.timeEnd(&apos;耗时&apos;) &#125;, // 关闭弹框 close() &#123; this.isShow = false &#125;, // 同步获取位置改变 getWxLocation() &#123; return new Promise((resolve, reject) =&gt; &#123; const _locationChangeFn = (res) =&gt; &#123; console.log(&apos;同步获取位置改变&apos;, res) this.location = res resolve(res) // 坐标转文字（放在resolve后面不影响同步获取速度） this.getLocationText() uni.offLocationChange(_locationChangeFn) &#125; uni.startLocationUpdate(&#123; success: (res) =&gt; &#123; uni.onLocationChange(_locationChangeFn) &#125;, fail: (err) =&gt; &#123; console.log(&apos;获取当前位置失败&apos;, err) reject() &#125; &#125;) &#125;) &#125;, // 普通获取当前位置坐标 getLocation() &#123; let _this = this uni.getLocation(&#123; // type: &apos;gcj02&apos;, isHighAccuracy: true, success(res) &#123; console.log(&apos;getLocation&apos;, res) _this.location = res // 坐标转文字 _this.getLocationText() &#125;, fail(err) &#123; console.log(err) &#125; &#125;) &#125;, // 普通获取当前位置坐标（同步获取） getLocationSync() &#123; return new Promise((resolve, reject) =&gt; &#123; uni.getLocation(&#123; type: &apos;gcj02&apos;, isHighAccuracy: true, success: resolve, fail: reject &#125;) &#125;) &#125;, // 根据当前经纬度获取所在位置的文字描述 async getLocationText() &#123; const &#123; result &#125; = await this.getCurrentLocation(this.location) console.log(&apos;当前位置文字&apos;, result) this.address = result.address &#125;, getCurrentLocation(location) &#123; return new Promise((resolve, reject) =&gt; &#123; this.tMap.reverseGeocoder(&#123; location, //位置坐标，对象格式,不填默认当前位置(不填真机会报错) success: resolve, fail: reject &#125;) &#125;) &#125;, // 打卡 setRecord() &#123; // 显示打卡中 this.state = 0 setTimeout(() =&gt; &#123; this.getNetworkType() &#125;, 1500) &#125;, // 获取网络类型 getNetworkType() &#123; if (this.envType === 4) &#123; // h5判断有无网络 console.log(navigator.onLine) if (navigator.onLine) &#123; this.judge() &#125; else &#123; this.tip = &apos;网络异常&apos; this.state = 2 &#125; &#125; else &#123; let _this = this uni.getNetworkType(&#123; success(res) &#123; console.log(&apos;网络&apos;, res) if (res.networkType === &apos;none&apos;) &#123; _this.tip = &apos;网络异常&apos; _this.state = 2 &#125; else &#123; _this.getSetting() &#125; &#125; &#125;) &#125; &#125;, // 获取用户的当前设置 getSetting() &#123; let isAuthed = false // 是否授权了位置信息 if (this.envType === 1) &#123; // 微信 uni.getSetting(&#123; success: (res) =&gt; &#123; console.log(&apos;权限&apos;, res) if (res.authSetting[&apos;scope.userLocation&apos;]) &#123; isAuthed = true &#125; &#125; &#125;) &#125; if (isAuthed || this.location.latitude) &#123; // 微信授权了 或者 企微/钉钉/web有坐标 this.judge() &#125; else &#123; this.tip = &apos;获取定位失败&apos; this.state = 2 console.log(this.tip) &#125; &#125;, // 打卡判断 async judge() &#123; // 如果还没有获取到位置就重新获取 if (!this.location.latitude) &#123; if (this.envType === 1 || this.envType === 2) &#123; this.location = await this.getWxLocation() &#125; else if (this.envType === 3) &#123; this.location = await this.getLocationSync() &#125; console.log(&apos;还没有获取到位置，同步获取&apos;, this.location) &#125; let markers = this.markers let num = 0 let maxTime = &apos;&apos;, time = new Date(), minute console.log(markers, this.location) for (let i = 0; i &lt; markers.length; i++) &#123; if (markers[i].time === null) &#123; // 防止time提交时为null字符串，不能写到下面的循环，会导致提交时后面的还是null markers[i].time = &apos;&apos; &#125; else &#123; // 如果打过卡 if (maxTime) &#123; // 第二个及以后 if (markers[i].time &gt; maxTime) &#123; // 如果比最大的大，就赋值为最大值 maxTime = markers[i].time &#125; &#125; else &#123; // 第一个 maxTime = markers[i].time &#125; &#125; &#125; console.log(&apos;最大时间&apos;, maxTime) if (maxTime) &#123; // 如果以前打过卡 maxTime = Utils.getDateFromTimeString(maxTime) minute = (time - maxTime) / (1000 * 60) &#125; else &#123; // 没打过卡，让满足打卡条件 minute = 4 &#125; console.log(&apos;距离最大时间的分钟数&apos;, minute, maxTime, time) // 循环获取两点距离进行判断 for (let i = 0; i &lt; markers.length; i++) &#123; const &#123; result &#125; = await this.calculateDistance( this.location, markers[i] ) const distance = result.elements[0].distance console.log( &apos;第&apos; + i + &apos;个距离&apos;, distance, &apos;半径&apos;, this.clock_radius ) if (distance &lt; this.clock_radius) &#123; // 如果有在打卡半径（默认1000）范围内的 if (markers[i].clock_state === &apos;2&apos;) &#123; // 如果已经打卡，弹窗直接显示成功，不调用接口，防止第一次打卡时间被覆盖 this.state = 1 console.log(&apos;已经打卡，弹窗直接显示成功&apos;) &#125; else if (minute &gt; 3) &#123; // 如果超过三分钟 markers[i].time = Utils.formatDate(new Date()) // 当前时间 markers[i].clock_state = &apos;2&apos; // 打卡成功状态，为了和以前小程序数据类型相同 this.clockTrip(markers) // 有一个成功就改变条件，后续的点不满足条件就不打卡了 minute = 0 &#125; &#125; else &#123; num++ &#125; // 每次点击打卡时依次记录各个点的情况 await $http.recordClockApi(&#123; id: this.tripId, is_ok: distance &lt; this.clock_radius, radius: distance, latitude: this.location.latitude, longitude: this.location.longitude, markers &#125;) &#125; if (num === markers.length) &#123; this.tip = &apos;您未在所有地点的半径1000米范围内&apos; this.state = 2 &#125; &#125;, // 计算一段路的距离 calculateDistance(from, to) &#123; // console.log(from, to, 111) return new Promise((resolve, reject) =&gt; &#123; this.tMap.calculateDistance(&#123; mode: &apos;straight&apos;, // 可选值：&apos;driving&apos;（驾车）、&apos;walking&apos;（步行）、&apos;straight&apos;（直线），不填默认：&apos;walking&apos; // 经纬度并设置from和to参数 from: from, // 若起点有数据则采用起点坐标，若为空默认当前地址 to: [to], // 终点坐标格式为数组或字符串 success: resolve, fail: reject &#125;) &#125;) &#125;, // 打卡接口 async clockTrip(markers) &#123; console.log(markers) await $http.clockTripApi(&#123; id: this.tripId, markers &#125;) this.state = 1 // 刷新父页面数据 this.$emit(&apos;refresh&apos;) &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.popup &#123; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; position: fixed; top: 0; left: 0; z-index: 999; background: rgba(0, 0, 0, 0.5);&#125;.content &#123; width: 622rpx; height: 812rpx; margin-bottom: 164rpx; border-radius: 24rpx; display: flex; flex-direction: column; justify-content: center; align-items: center; position: relative; background: #fff;&#125;.bg-top &#123; width: 100%; height: 580rpx; position: absolute; top: 0;&#125;.bg-bottom &#123; width: 100%; height: 196rpx; position: absolute; bottom: 0;&#125;.inner &#123; width: 100%; height: 100%; position: absolute; top: 0; left: 0; display: flex; flex-direction: column; align-items: center; justify-content: center;&#125;.rotate &#123; width: 440rpx; height: 440rpx; margin-bottom: 56rpx; position: relative;&#125;.ring &#123; width: 440rpx; height: 440rpx; /*旋转*/ animation: circleRoate 5s infinite; animation-timing-function: linear;&#125;.circle &#123; width: 392rpx; height: 392rpx; position: absolute; top: 38rpx; left: 24rpx;&#125;@keyframes circleRoate &#123; from &#123; transform: rotate(0deg); &#125; to &#123; transform: rotate(360deg); &#125;&#125;.rotate text &#123; line-height: 64rpx; position: absolute; top: 200rpx; left: 124rpx; font-size: 48rpx; font-weight: 500; color: #fff;&#125;.success &#123; width: 516rpx; height: 360rpx;&#125;.success-text &#123; line-height: 100rpx; margin: 32rpx 0; font-size: 72rpx; font-weight: 600; color: #247bff;&#125;.address &#123; padding: 0 40rpx; display: flex;&#125;.address image &#123; width: 32rpx; height: 32rpx; margin-top: 4rpx;&#125;.address .text &#123; line-height: 40rpx; margin-left: 8rpx; font-size: 28rpx; flex: 1; text-align: center; color: #868a8f;&#125;.fail &#123; width: 380rpx;&#125;.fail-text &#123; line-height: 100rpx; margin: 32rpx 0; font-size: 72rpx; font-weight: 600; color: #e34950;&#125;.again &#123; margin-top: 32rpx; position: relative;&#125;.again image &#123; width: 264rpx; height: 264rpx;&#125;.again text &#123; line-height: 40rpx; font-size: 32rpx; word-wrap: nowrap; position: absolute; top: 96rpx; left: 68rpx; color: #fff;&#125;.close &#123; width: 96rpx; height: 96rpx; position: absolute; bottom: -144rpx; left: 264rpx;&#125;&lt;/style&gt; 使用方式： 1234567891011&lt;!-- 打卡弹窗 --&gt;&lt;clock-popup ref=&quot;clockRef&quot; :tripId=&quot;detail.id&quot; :markers=&quot;detail.markers&quot; :clock_radius=&quot;clock.clock_radius&quot; @refresh=&quot;getDetail&quot;&gt;&lt;/clock-popup&gt; // 打卡onClick() &#123; this.$refs.clockRef.open()&#125;, 时间选择组件DateTime.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285&lt;template&gt; &lt;picker mode=&quot;multiSelector&quot; :range=&quot;rangeList&quot; :value=&quot;rangeValue&quot; @change=&quot;selectChangeFn&quot; @columnchange=&quot;selectColumnChangeFn&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/picker&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; mode: &#123; // 选择器类型 type: String, required: true, &#125;, value: &#123; // 回显的时间 type: String, default: &quot;&quot;, &#125;, &#125;, data() &#123; return &#123; rangeList: [], rangeValue: [], dateDetails: [&quot;年&quot;, &quot;月&quot;, &quot;时&quot;, &quot;分&quot;, &quot;秒&quot;], &#125;; &#125;, computed: &#123;&#125;, created() &#123; // 初始化时间选择器，延时是因为编辑需要获取后端数据 setTimeout(() =&gt; &#123; this._initDateTimePickerFn(); &#125;, 500); &#125;, methods: &#123; //初始化时间选择器 _initDateTimePickerFn() &#123; try &#123; if (this.mode != &quot;dateminute&quot; &amp;&amp; this.mode != &quot;datetime&quot;) &#123; uni.showToast(&#123; title: &quot;请输入合法的时间选择器类型！&quot;, icon: &quot;none&quot;, duration: 2000, &#125;); &#125; //获取到当前时间 let showTimeValue = this._validateShowTime( this.value, this.mode ); // 获取年份范围 const currentYear = showTimeValue.substring( 0, showTimeValue.indexOf(&quot;-&quot;) ); const currentMouth = showTimeValue.split(&quot; &quot;)[0].split(&quot;-&quot;)[1]; const yearList = this._gotDateTimeList(&#123; _start: Number(currentYear) - 1, _end: Number(currentYear) + 1, _type: 0, &#125;); // 获取月份 const monthList = this._gotDateTimeList(&#123; _start: 1, _end: 12, _type: 1, &#125;); //获取天数 const dayList = this._gotDayList(currentYear, currentMouth); // 获取小时 const hourList = this._gotDateTimeList(&#123; _start: 0, _end: 23, _type: 2, &#125;); // 获取分钟 const munithList = this._gotDateTimeList(&#123; _start: 0, _end: 59, _type: 3, &#125;); // 获取秒 const secondList = this._gotDateTimeList(&#123; _start: 0, _end: 59, _type: 4, &#125;); let rangeList = new Array(); rangeList.push(yearList); rangeList.push(monthList); rangeList.push(dayList); rangeList.push(hourList); rangeList.push(munithList); this.mode === &quot;datetime&quot; &amp;&amp; rangeList.push(secondList); this.rangeList = rangeList; this._echoDateTime(showTimeValue); // 初始化时间显示 &#125; catch (err) &#123; console.log(err); &#125; &#125;, //验证显示的时间是否合法 //@param &#123;Number&#125; _value 要验证的时间 //@param &#123;Number&#125; _mode 选择器类型 _validateShowTime(_value, _mode) &#123; let currentTime = this.formatTime(new Date()).replace(/\\//g, &quot;-&quot;); let showTimeValue = _value.trim() || currentTime; const secondReg = /^\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;\\s\\d&#123;2&#125;:\\d&#123;2&#125;:\\d&#123;2&#125;$/; const munithReg = /^\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;\\s\\d&#123;2&#125;:\\d&#123;2&#125;$/; if (_mode === &quot;dateminute&quot;) &#123; // yyyy-MM-dd HH:mm // 验证是否合法 secondReg.test(showTimeValue) &amp;&amp; (showTimeValue = showTimeValue.substring( 0, showTimeValue.lastIndexOf(&quot;:&quot;) )); munithReg.test(showTimeValue) || (showTimeValue = currentTime.substring( 0, currentTime.lastIndexOf(&quot;:&quot;) )); &#125; else &#123; // yyyy-MM-dd HH:mm:ss munithReg.test(showTimeValue) &amp;&amp; (showTimeValue += &quot;:00&quot;); secondReg.test(showTimeValue) || (showTimeValue = currentTime); &#125; return showTimeValue; &#125;, //获取年份、月份、小时、分钟、秒 //@param &#123;Number&#125; _start 开始值 //@param &#123;Number&#125; _end 结束值 //@param &#123;Number&#125; _type 类型 _gotDateTimeList(&#123; _start, _end, _type &#125;) &#123; let resultDataList = new Array(); for (let i = _start; i &lt;= _end; i++) &#123; resultDataList.push(this._addZore(i) + this.dateDetails[_type]); &#125; return resultDataList; &#125;, //获取天数 //@param &#123;Number&#125; _year 年份 //@param &#123;Number&#125; _mouth 月份 _gotDayList(_year, _mouth) &#123; let now = new Date(_year, _mouth, 0); const dayLength = now.getDate(); let dayList = new Array(); for (let i = 1; i &lt;= dayLength; i++) &#123; dayList.push(this._addZore(i) + &quot;日&quot;); &#125; return dayList; &#125;, //补零 //@param &#123;Number&#125; _num 数值 _addZore(_num) &#123; return _num &lt; 10 ? &quot;0&quot; + _num : _num.toString(); &#125;, //回显时间 //@param &#123;Number&#125; _showTimeValue 初始化时要显示的时间 _echoDateTime(_showTimeValue) &#123; const rangeList = this.rangeList; let rangeValue = new Array(); const list = _showTimeValue.split(/[\\-|\\:|\\s]/); list.map((el, index) =&gt; &#123; rangeList[index].map((item, itemIndex) =&gt; &#123; item.indexOf(el) !== -1 &amp;&amp; rangeValue.push(itemIndex); &#125;); &#125;); this.rangeValue = rangeValue; &#125;, //点击确定时触发的回调函数 //@param &#123;Number&#125; ev selectChangeFn(ev) &#123; const selectValues = ev.detail.value; const rangeList = this.rangeList; let dateTime = &quot;&quot;; selectValues.map((el, index) =&gt; &#123; dateTime += rangeList[index][el].substring( 0, rangeList[index][el].length - 1 ); if (index == 0 || index == 1) &#123; dateTime += &quot;-&quot;; &#125; else if ( index == 3 || (index == 4 &amp;&amp; index != selectValues.length - 1) ) &#123; dateTime += &quot;:&quot;; &#125; else if (index == 2 &amp;&amp; index != selectValues.length - 1) &#123; dateTime += &quot; &quot;; &#125; &#125;); // 触发父组件把值传递给父组件 this.$emit(&quot;change&quot;, dateTime); // this.triggerEvent(&quot;change&quot;, &#123; value: dateTime &#125;); &#125;, // 当具体的一项的值发生改变时触发 // @param &#123;Number&#125; ev selectColumnChangeFn(ev) &#123; const &#123; column, value &#125; = ev.detail; let rangeList = this.rangeList; let rangeValue = this.rangeValue; let selectValue = Number( rangeList[column][value].substring( 0, rangeList[column][value].length - 1 ) ); if (column === 1) &#123; // 改变月份 const currentYear = Number( rangeList[0][rangeValue[0]].substring( 0, rangeList[0][rangeValue[0]].length - 1 ) ); const dayList = this._gotDayList(currentYear, selectValue); rangeList[column + 1] = dayList; &#125; this.rangeList = rangeList; &#125;, // 格式化日期 formatTime(date) &#123; const year = date.getFullYear(); const month = date.getMonth() + 1; const day = date.getDate(); const hour = date.getHours(); const minute = date.getMinutes(); const second = date.getSeconds(); return ( [year, month, day].map(this.formatNumber).join(&quot;/&quot;) + &quot; &quot; + [hour, minute, second].map(this.formatNumber).join(&quot;:&quot;) ); &#125;, formatNumber(n) &#123; n = n.toString(); return n[1] ? n : &quot;0&quot; + n; &#125;, &#125;,&#125;;&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.toast_content_box &#123; display: flex; width: 100%; height: 100%; justify-content: center; align-items: center; position: fixed; z-index: 999; top: 0;&#125;.toast_content &#123; background: rgba(0, 0, 0, 0.8); border-radius: 16rpx; display: flex; flex-direction: column; justify-content: center; align-items: center; max-width: 284rpx; min-width: 256rpx; min-height: 236rpx;&#125;.toast_content_image &#123; margin: 48rpx 32rpx 0 32rpx; width: 80rpx; height: 80rpx;&#125;.text &#123; /* margin: 20rpx 32rpx 48rpx 32rpx; */ text-align: center; font-size: 32rpx; font-family: PingFangSC-Regular, PingFang SC; font-weight: 400; color: #ffffff; line-height: 40rpx;&#125;.img_magin &#123; margin: 20rpx 32rpx 48rpx 32rpx;&#125;.no_img &#123; margin: 20rpx 32rpx 20rpx 32rpx;&#125;&lt;/style&gt; 使用方式： 123456789101112&lt;date-time mode=&quot;dateminute&quot; :value=&quot;formModel.use_start&quot; @change=&quot;startChange&quot;&gt; &lt;view class=&quot;msg&quot;&gt; &lt;text&gt;&#123;&#123; use_start &#125;&#125;&lt;/text&gt; &lt;image src=&quot;/static/images/index_icon5.png&quot;&gt;&lt;/image&gt; &lt;/view&gt;&lt;/date-time&gt;// 用车开始时间，时分的事件方法，如果需要时分秒参考https://blog.csdn.net/Shids_/article/details/122084621startChange(dateTime) &#123; this.formModel.use_start = dateTime + &apos;:00&apos; this.use_start = this.formModel.use_start.replace(/-/g, &apos;/&apos;)&#125;, 输入框下拉组件DropDown.vue1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;template&gt; &lt;view class=&quot;drop-down&quot; v-if=&quot;isShow&amp;&amp;list.length&quot;&gt; &lt;view class=&quot;drop-list&quot; @touchstart=&apos;touch(1)&apos; @touchmove=&apos;touch(2)&apos; @touchend=&apos;touch(3)&apos;&gt; &lt;view class=&quot;drop-item&quot; v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot; @click=&quot;change(item,index)&quot; v-html=&quot;highLight(item[label])&quot;&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;import Utils from &apos;@/utils/index&apos;export default &#123; props: &#123; // 列表数据 list: &#123; type: Array, default: [] &#125;, // 搜索词 keyword: &#123; type: String, default: &apos;&apos; &#125;, // 显示字段 label: &#123; type: String, default: &apos;label&apos; &#125; &#125;, data() &#123; return &#123; isShow: false // 是否显示 &#125; &#125;, computed: &#123; highLight() &#123; return (data) =&gt; &#123; return Utils.highLight(this.keyword, data, &apos;#247bff&apos;) &#125; &#125; &#125;, created() &#123;&#125;, methods: &#123; // 打开 show() &#123; this.isShow = true &#125;, // 关闭 close() &#123; this.isShow = false &#125;, // 触摸事件 touch(type) &#123; console.log(type) this.$emit(&apos;touch&apos;, type) &#125;, // 选择 change(item) &#123; console.log(item) this.$emit(&apos;change&apos;, item) // this.close() &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.drop-down &#123; width: 686rpx; border-radius: 8rpx; position: absolute; top: 110rpx; left: 0; z-index: 10; background: #ffffff; color: #1d2126; box-shadow: 0rpx 4rpx 16rpx 0rpx rgba(0, 0, 0, 0.12); .drop-list &#123; // 避免ios闪烁 max-height: 368rpx; overflow-y: auto; .drop-item &#123; line-height: 44rpx; padding: 24rpx; font-size: 28rpx; &#125; &#125;&#125;&lt;/style&gt; 使用方式： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;view class=&quot;page&quot; @touchmove=&apos;touchmove&apos;&gt; &lt;input v-model=&quot;car_num&quot; :adjust-position=&quot;false&quot; maxlength=&quot;10&quot; placeholder=&quot;搜索车牌号&quot; @focus=&quot;focus&quot; @input=&quot;input&quot; @blur=&quot;blur&quot; /&gt; &lt;drop-down ref=&quot;dropRef&quot; :list=&quot;carList&quot; :keyword=&quot;car_num&quot; @touch=&quot;touch&quot; @change=&quot;change&quot;&gt;&lt;/drop-down&gt; &lt;/view&gt; touchType: 3, // 下拉框触摸事件类型，3为结束 isFocus: false, // 是否聚焦 // 输入框聚焦 focus() &#123; this.$refs.dropRef.show() &#125;, // 输入框失焦 blur() &#123; if (this.touchType === 3) &#123; setTimeout(() =&gt; &#123; this.$refs.dropRef.close() this.isFocus = false &#125;, 200) &#125; &#125;, // 选择车辆 change(item) &#123; this.car_num = item.label this.$refs.dropRef.close() this.isFocus = false this.close() if (this.car_num) &#123; // 如果有车牌号，根据车牌号过滤 this.markers = this.allMarkers.filter( (item) =&gt; item.car_num === this.car_num ) this.includePoints() &#125; &#125;, // 输入 input() &#123; if (this.car_num) &#123; // 如果有车牌号，根据车牌号过滤 this.carList = this.allCarList.filter( (item) =&gt; item.label.indexOf(this.car_num) !== -1 ) &#125; else &#123; // 清空输入框刷新 this.markers = this.allMarkers this.carList = this.allCarList this.includePoints() &#125; &#125;, // 下拉框触摸事件 touch(type) &#123; this.touchType = type &#125;, // 页面触摸移动事件 touchmove() &#123; if (this.isFocus) &#123; this.blur() &#125; &#125;, 菜单栏组件ListBar.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;template&gt; &lt;view class=&quot;list-bar&quot; v-if=&quot;isShow&quot; @click=&quot;click&quot;&gt; &lt;view class=&quot;left&quot;&gt; &lt;image :src=&quot;icon&quot; /&gt; &lt;text&gt;&#123;&#123; title &#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;view class=&quot;right&quot;&gt; &lt;view class=&quot;circle&quot; v-if=&quot;num&quot;&gt; &lt;text&gt;&#123;&#123; num &#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;image class=&quot;arrow&quot; src=&quot;/static/images/right_arrow.png&quot; /&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; // 是否显示（默认不显示，防止用户看到后又消失） isShow: &#123; type: Boolean, default: false &#125;, // 标题 title: &#123; type: String, default: &apos;&apos; &#125;, // 左侧的图标 icon: &#123; type: String, default: &apos;&apos; &#125;, // 跳转路由 url: &#123; type: String, default: &apos;&apos; &#125;, // 消息数 num: &#123; type: Number, default: 0 &#125; &#125;, data() &#123; return &#123;&#125; &#125;, computed: &#123;&#125;, created() &#123;&#125;, methods: &#123; // 点击事件 click() &#123; if (this.url) &#123; // 有跳转路由 uni.navigateTo(&#123; url: this.url &#125;) &#125; else &#123; this.$emit(&apos;click&apos;) &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.list-bar &#123; position: relative; height: 108rpx; display: flex; justify-content: space-between; align-items: center; .left &#123; font-size: 32rpx; display: flex; align-items: center; color: #33373d; image &#123; width: 36rpx; height: 36rpx; margin-right: 20rpx; &#125; &#125; .right &#123; display: flex; align-items: center; .circle &#123; width: 32rpx; height: 32rpx; border-radius: 50%; font-size: 20rpx; display: flex; align-items: center; justify-content: center; color: #fff; background: red; &#125; &#125; .arrow &#123; width: 40rpx; height: 40rpx; &#125;&#125;&lt;/style&gt; 使用方式： 12345678910111213&lt;list-bar isShow title=&quot;车辆管理&quot; icon=&quot;/static/images/icon_car.png&quot; @click=&quot;carList&quot;&gt;&lt;/list-bar&gt; &lt;list-bar :isShow=&quot;userInfo.role_type===2&quot; title=&quot;车辆定位&quot; icon=&quot;/static/images/my_position.png&quot; url=&quot;/sub_my/car/CarPosition&quot;&gt;&lt;/list-bar&gt; &lt;list-bar isShow title=&quot;消息通知&quot; icon=&quot;/static/images/message.png&quot; url=&quot;/sub_my/notice/Notices&quot; :num=&quot;userInfo.notice_num&quot;&gt;&lt;/list-bar&gt; 弹窗组件Popup.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;template&gt; &lt;view class=&quot;overlay&quot; v-if=&quot;isShow&quot; @click=&quot;close&quot;&gt; &lt;!-- @click.stop=&quot;&quot;防止点击弹窗标题触发关闭 --&gt; &lt;view :style=&quot;&#123;&apos;padding-bottom&apos;:bottom+&apos;px&apos;&#125;&quot; class=&quot;popup&quot; @click.stop=&quot;&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapState &#125; from &apos;vuex&apos;export default &#123; props: &#123; // 是否需要兼容ios安全区 isSafe: &#123; type: Boolean, default: true &#125; &#125;, data() &#123; return &#123; isShow: false, // 是否显示 bottom: 34 // padding-bottom高度 &#125; &#125;, computed: &#123; ...mapState(&#123; systemInfo: (state) =&gt; state.login.systemInfo &#125;) &#125;, created() &#123; if (this.isSafe) &#123; this.bottom = this.systemInfo.safeAreaInsets.bottom &#125; else &#123; this.bottom = 0 &#125; &#125;, methods: &#123; /** * 展示弹框 */ show() &#123; this.isShow = true &#125;, /** * 隐藏弹框 */ close() &#123; this.isShow = false &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.overlay &#123; width: 100%; height: 100%; position: fixed; left: 0; top: 0; z-index: 99; transition-duration: 300ms; background: rgba(0, 0, 0, 0.5);&#125;.popup &#123; width: 100%; position: fixed; bottom: 0; border-radius: 32rpx 32rpx 0 0; background: #ffffff;&#125;&lt;/style&gt; 使用方式： 123456789101112131415&lt;!-- 选择用车类型弹窗 --&gt; &lt;popup ref=&quot;carRef&quot;&gt; &lt;view class=&quot;popup-list&quot;&gt; &lt;/view&gt; &lt;/popup&gt; // 显示选择车辆弹窗 showCar() &#123; this.$refs.carRef.show() &#125;, // 关闭选择车辆弹窗 closeCar() &#123; this.$refs.carRef.close() &#125;, 弹窗选择器组件Select.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158&lt;template&gt; &lt;popup ref=&quot;popupRef&quot;&gt; &lt;view class=&quot;popup&quot;&gt; &lt;view class=&quot;popup-title&quot;&gt; &lt;image @click=&quot;close&quot; src=&quot;/static/images/icon1.png&quot; /&gt; &lt;view class=&quot;ellipsis-one&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;popup-list&quot;&gt; &lt;view :class=&quot;item.disabled ? &apos;popup-item placeholder&apos; : &apos;popup-item&apos;&quot; v-for=&quot;(item, index) in list&quot; :key=&quot;index&quot; @click=&quot;change(item)&quot;&gt; &lt;view class=&quot;ellipsis-tow&quot; v-if=&quot;labelSlot&quot;&gt; &lt;text&gt;&#123;&#123; item[label] &#125;&#125; | &#123;&#123; item[labelSlot] &#125;&#125;&lt;/text&gt; &lt;view class=&quot;state state-orange&quot; v-if=&quot;item.travel_state&quot;&gt;出行中&lt;/view&gt; &lt;!-- &lt;slot name=&quot;label&quot; :item=&quot;item&quot;&gt;&lt;/slot&gt; --&gt; &lt;/view&gt; &lt;view class=&quot;ellipsis-tow&quot; v-else&gt; &#123;&#123; item[label] &#125;&#125; &lt;/view&gt; &lt;image v-if=&quot;item[value] === selected&quot; src=&quot;/static/images/icon2.png&quot; /&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/popup&gt;&lt;/template&gt;&lt;script&gt;import Popup from &apos;@/components/Popup&apos;export default &#123; components: &#123; Popup &#125;, props: &#123; // 标题 title: &#123; type: String, default: &apos;&apos; &#125;, // 列表数据 list: &#123; type: Array, default: [] &#125;, // 显示字段 label: &#123; type: String, default: &apos;label&apos; &#125;, // 自定义其余显示字段 labelSlot: &#123; type: String, default: &apos;&apos; &#125;, // 绑定字段（key是关键词，如果用了会和vue的key冲突） value: &#123; type: String, default: &apos;key&apos; &#125;, // 选中项（不需要定义类型和默认值） selected: &#123;&#125; &#125;, data() &#123; return &#123;&#125; &#125;, computed: &#123;&#125;, created() &#123;&#125;, methods: &#123; // 显示弹窗 show() &#123; this.$refs.popupRef.show() &#125;, // 关闭弹窗 close() &#123; this.$refs.popupRef.close() &#125;, // 选择 change(item) &#123; console.log(item) if (item.travel_state) &#123; // 不能选择出行中的 return &#125; this.$emit(&apos;change&apos;, item) if (!item.disabled) &#123; // 不是禁用，才能关闭 this.close() &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.popup &#123; width: 100%; border-radius: 32rpx 32rpx 0 0; color: #1d2126; background: #ffffff; image &#123; width: 40rpx; height: 40rpx; &#125; .popup-title &#123; padding: 34rpx 40rpx; font-size: 36rpx; font-weight: 500; display: flex; align-items: center; border-bottom: 1px solid #f5f7fa; .ellipsis-one &#123; width: 590rpx; line-height: 52rpx; text-align: center; &#125; &#125; .popup-list &#123; min-height: 224rpx; max-height: 70vh; overflow: auto; .popup-item &#123; padding: 32rpx 40rpx; font-size: 32rpx; display: flex; align-items: center; justify-content: space-between; &amp;:hover &#123; // 置灰时如果点击不生效会有背景色，所以先注释掉 // background: #f0f2f5; &#125; .ellipsis-tow &#123; max-width: 614rpx; line-height: 48rpx; display: flex; align-items: center; .state &#123; line-height: 36rpx; padding: 2rpx 16rpx; margin-left: 16rpx; border-radius: 8rpx; font-size: 24rpx; &#125; .state-orange &#123; color: #ff9900; background: #fff4e0; &#125; &#125; &#125; &#125;&#125;&lt;/style&gt; 使用方式： 123456789101112&lt;Select ref=&quot;carRef&quot; title=&quot;使用车辆&quot; :list=&quot;carList&quot; label=&quot;car_num&quot; labelSlot=&quot;name&quot; value=&quot;car_num&quot; :selected=&quot;formModel.car_num&quot; @change=&quot;carSelected&quot;&gt; &lt;!-- &lt;template v-slot:label=&quot;&#123;item&#125;&quot;&gt; &#123;&#123; item.car_num &#125;&#125; | &#123;&#123; item.name &#125;&#125; &lt;/template&gt; --&gt; &lt;/Select&gt; 步骤条组件Step.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&lt;template&gt; &lt;view class=&quot;step&quot;&gt; &lt;view class=&quot;item&quot; v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot;&gt; &lt;view :class=&quot;[&apos;tag&apos;,&#123;&apos;tag-black&apos;:index&lt;active,&apos;tag-blue&apos;:index===active,&apos;tag-grey&apos;:index&gt;active&#125;]&quot;&gt; &lt;view class=&quot;circle&quot;&gt;&#123;&#123;index+1&#125;&#125;&lt;/view&gt; &lt;text&gt;&#123;&#123;item&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;view :class=&quot;&#123;&apos;line1&apos;:list.length===2,&apos;line2&apos;:list.length===3,&apos;line3&apos;:list.length===4,&apos;line-blue&apos;:index&lt;active,&apos;line-grey&apos;:index&gt;=active,&#125;&quot; v-if=&quot;index&lt;list.length-1&quot;&gt;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; list: &#123; type: Array, default: [] &#125;, active: &#123; type: Number, default: 0 &#125; &#125;, data() &#123; return &#123;&#125; &#125;, computed: &#123;&#125;, created() &#123;&#125;, methods: &#123;&#125;&#125;&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.step &#123; width: 100%; display: flex; align-items: center; justify-content: space-between; color: #33373d; background: #fff; .item &#123; display: flex; .tag &#123; display: flex; flex-direction: column; align-items: center; font-size: 24rpx; .circle &#123; width: 40rpx; height: 40rpx; line-height: 40rpx; border-radius: 50%; margin-bottom: 12rpx; text-align: center; &#125; text &#123; line-height: 34rpx; white-space: nowrap; &#125; &#125; .tag-black &#123; .circle &#123; color: #247bff; border: 2rpx solid #247bff; &#125; &#125; .tag-blue &#123; .circle &#123; color: #fff; background: #247dff; &#125; text &#123; font-weight: 500; color: #247bff; &#125; &#125; .tag-grey &#123; .circle &#123; color: rgba(0, 0, 0, 0.26); border: 2rpx solid #c5c5c5; &#125; text &#123; color: #b0b3b8; &#125; &#125; .line1 &#123; width: 479rpx; height: 1rpx; margin-top: 20rpx; &#125; .line2 &#123; width: 190rpx; height: 1rpx; margin-top: 20rpx; &#125; .line3 &#123; width: 132rpx; height: 1rpx; margin-top: 20rpx; &#125; .line-blue &#123; background: #247bff; &#125; .line-grey &#123; background: #dcdcdc; &#125; &#125;&#125;&lt;/style&gt; 使用方式： 12345&lt;!-- 自定义步骤条 --&gt;&lt;Step :list=&quot;list&quot; :active=&quot;active&quot;&gt;&lt;/Step&gt;list: [&apos;上传&apos;, &apos;添加&apos;, &apos;签署&apos;],active: 2 提示栏组件TipBar.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;template&gt; &lt;view :class=&quot;isRed?&apos;tip-bar red&apos;:&apos;tip-bar orange&apos;&quot; v-if=&quot;isShow&quot; @click=&quot;go&quot;&gt; &lt;view class=&quot;flex-view&quot;&gt; &lt;image class=&quot;icon&quot; :src=&quot;isRed?&apos;/static/images/warn2.png&apos;:&apos;/static/images/icon.png&apos;&quot; /&gt; &lt;text&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;view class=&quot;flex-view&quot;&gt; &lt;text&gt;&#123;&#123;operate&#125;&#125;&lt;/text&gt; &lt;image class=&quot;next&quot; :src=&quot;isRed?&apos;/static/images/next_red.png&apos;:&apos;/static/images/next_yellow.png&apos;&quot; /&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; // 是否显示 isShow: &#123; type: Boolean, default: false &#125;, // 是否为红色 isRed: &#123; type: Boolean, default: false &#125;, // 标题 title: &#123; type: String, default: &apos;&apos; &#125;, // 操作文案 operate: &#123; type: String, default: &apos;&apos; &#125; &#125;, data() &#123; return &#123;&#125; &#125;, computed: &#123;&#125;, created() &#123;&#125;, methods: &#123; // 点击事件 go() &#123; this.$emit(&apos;go&apos;) &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.tip-bar &#123; height: 64rpx; line-height: 64rpx; padding: 0 20rpx 0 16rpx; margin-bottom: 32rpx; border-radius: 8rpx; display: flex; justify-content: space-between; align-items: center; font-size: 24rpx; .flex-view &#123; display: flex; align-items: center; .icon &#123; width: 32rpx; height: 32rpx; margin-right: 8rpx; &#125; .next &#123; width: 24rpx; height: 24rpx; &#125; &#125;&#125;.red &#123; color: #ed4013; background: #ffefe6;&#125;.orange &#123; color: #ff9900; background: #fff4db;&#125;&lt;/style&gt; 使用方式： 1234&lt;tip-bar :isShow=&quot;accountState&quot; title=&quot;您还未添加收款账户信息，请立即前往&quot; operate=&quot;去添加&quot; @go=&quot;goAddAccount&quot;&gt;&lt;/tip-bar&gt; 自定义toast组件Toast.vue12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;template&gt; &lt;view class=&quot;toast_content_box&quot; v-if=&quot;isShow&quot;&gt; &lt;view class=&quot;toast_content&quot;&gt; &lt;image v-if=&quot;url&quot; class=&quot;toast_content_image&quot; :src=&quot;url&quot;&gt;&lt;/image&gt; &lt;view :class=&quot;url ? &apos;text img_magin&apos; : &apos;text no_img&apos;&quot;&gt;&#123;&#123; text &#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123;&#125;, data() &#123; return &#123; isShow: false, // 是否显示 url: &quot;&quot;, // 提示图片路径 text: &quot;&quot;, // 提示内容 &#125;; &#125;, computed: &#123;&#125;, created() &#123; &#125;, methods: &#123; /** * 展示提示 * @param &#123;String&#125; type 提示类型 * @param &#123;String&#125; text 提示内容 */ show(type, text) &#123; if (type === &quot;success&quot;) &#123; this.url = &quot;/static/images/toast_success.png&quot;; &#125; else if (type === &quot;alert&quot;) &#123; this.url = &quot;/static/images/toast_alert.png&quot;; &#125; this.text = text; this.isShow = true; let _this = this; // 定时关闭 setTimeout(function () &#123; _this.isShow = false; &#125;, 1500); &#125;, &#125;,&#125;;&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.toast_content_box &#123; display: flex; width: 100%; height: 100%; justify-content: center; align-items: center; position: fixed; z-index: 999; top: 0; left: 0;&#125;.toast_content &#123; background: rgba(0, 0, 0, 0.8); border-radius: 16rpx; display: flex; flex-direction: column; justify-content: center; align-items: center; max-width: 284rpx; min-width: 256rpx; min-height: 236rpx;&#125;.toast_content_image &#123; margin: 48rpx 32rpx 0 32rpx; width: 80rpx; height: 80rpx;&#125;.text &#123; /* margin: 20rpx 32rpx 48rpx 32rpx; */ text-align: center; font-size: 32rpx; font-family: PingFangSC-Regular, PingFang SC; font-weight: 400; color: #ffffff; line-height: 40rpx;&#125;.img_magin &#123; margin: 20rpx 32rpx 48rpx 32rpx;&#125;.no_img &#123; margin: 20rpx 32rpx 20rpx 32rpx;&#125;&lt;/style&gt; 使用方式： 1234&lt;!-- 自定义提示 --&gt; &lt;Toast ref=&quot;toastRef&quot;&gt;&lt;/Toast&gt; this.$refs.toastRef.show(&apos;success&apos;, &apos;添加成功&apos;) 图片上传列表组件Upload.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202&lt;template&gt; &lt;view&gt; &lt;!-- 单文件 --&gt; &lt;view class=&quot;list&quot; v-if=&quot;isSingle&quot;&gt; &lt;view class=&quot;item&quot; v-if=&quot;url&quot;&gt; &lt;image class=&quot;upload img-border&quot; mode=&quot;aspectFill&quot; :src=&quot;url&quot; @click=&quot;preview(url)&quot; /&gt; &lt;image class=&quot;close&quot; v-if=&quot;url&amp;&amp;isAdd&quot; @click=&quot;del&quot; src=&quot;/static/images/index_icon11.png&quot; /&gt; &lt;/view&gt; &lt;view class=&quot;item&quot; v-else&gt; &lt;view :class=&quot;isCheck&amp;&amp;!url?&apos;upload upload-err&apos;:&apos;upload&apos;&quot; @click=&quot;upload&quot;&gt; &lt;image v-if=&quot;isCheck&amp;&amp;!url&quot; src=&quot;/static/images/upload_err.png&quot; /&gt; &lt;image v-else src=&quot;/static/images/index_icon10.png&quot; /&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 多文件 --&gt; &lt;view :class=&quot;[&apos;list&apos;,&#123;&apos;show3&apos;:columns===3,&apos;show4&apos;:columns===4&#125;]&quot; v-else&gt; &lt;view class=&quot;item mb&quot; v-for=&quot;(item,index) in files&quot; :key=&quot;index&quot;&gt; &lt;image class=&quot;upload img-border&quot; mode=&quot;aspectFill&quot; :src=&quot;item.url&quot; @click=&quot;preview(item)&quot; /&gt; &lt;image class=&quot;close&quot; v-if=&quot;item.url&amp;&amp;isAdd&quot; @click=&quot;del(index)&quot; src=&quot;/static/images/index_icon11.png&quot; /&gt; &lt;/view&gt; &lt;view class=&quot;item&quot; v-if=&quot;isAdd&quot;&gt; &lt;view :class=&quot;isCheck&amp;&amp;!files.length?&apos;upload upload-err&apos;:&apos;upload&apos;&quot; @click=&quot;upload&quot;&gt; &lt;image v-if=&quot;isCheck&amp;&amp;!files.length&quot; src=&quot;/static/images/upload_err.png&quot; /&gt; &lt;image v-else src=&quot;/static/images/index_icon10.png&quot; /&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 一行有两个元素的时候再加一个元素 --&gt; &lt;view class=&quot;item&quot; v-if=&quot;columns===4&amp;&amp;files.length%4===1&quot;&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; // 是否为单个 isSingle: &#123; type: Boolean, default: true &#125;, // 单个地址 url: &#123; type: String, default: &apos;&apos; &#125;, // 多个地址 files: &#123; type: Array, default: [] &#125;, // 是否为添加/编辑 isAdd: &#123; type: Boolean, default: true &#125;, // 是否核验 isCheck: &#123; type: Boolean, default: false &#125;, // 列数 columns: &#123; type: Number, default: 4 &#125; &#125;, data() &#123; return &#123;&#125; &#125;, computed: &#123;&#125;, created() &#123;&#125;, methods: &#123; // 预览图片 preview(item) &#123; let urls, current = 0 if (this.isSingle) &#123; urls = [item] &#125; else &#123; // 需要预览的图片链接列表 urls = this.files.map((it) =&gt; it.url) // 当前显示图片的链接/索引值 current = urls.indexOf(item.url) &#125; uni.previewImage(&#123; urls, current &#125;) &#125;, // 删除 del(index) &#123; this.$emit(&apos;del&apos;, index) &#125;, // 上传 upload() &#123; this.$emit(&apos;upload&apos;) &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.list &#123; display: flex; flex-wrap: wrap; justify-content: space-between; .mb &#123; margin-bottom: 20rpx; &#125; .item &#123; width: 144rpx; position: relative; .upload &#123; width: 140rpx; height: 140rpx; border-radius: 10rpx; display: flex; align-items: center; justify-content: center; background: #f5f7fa; border: dashed 2rpx #e6e8eb; image &#123; width: 56rpx; height: 56rpx; &#125; &#125; .img-border &#123; border: solid 2rpx #e6e8eb; &#125; .upload-err &#123; background: #ffe7e6; border: dashed 2rpx #e34950; &#125; .close &#123; width: 28rpx; height: 28rpx; position: absolute; top: 8rpx; right: 8rpx; z-index: 1; &#125; &#125;&#125;// 3列.show3 &#123; // 防止最后一排两个的时候分散在两边 &amp;::after &#123; content: &apos;&apos;; width: 144rpx; &#125; .item &#123; width: 144rpx; .upload &#123; width: 140rpx; height: 140rpx; &#125; &#125;&#125;// 4列.show4 &#123; // 防止最后一排两个的时候分散在两边 &amp;::after &#123; content: &apos;&apos;; width: 144rpx; &#125; .item &#123; width: 144rpx; .upload &#123; width: 140rpx; height: 140rpx; &#125; &#125;&#125;&lt;/style&gt; 使用方式： 1234567891011&lt;!-- 单文件 --&gt;&lt;Upload :url=&quot;formModel.startPic.url&quot; :isCheck=&quot;isCheck&quot; @upload=&quot;uploadDashboard&quot; @del=&quot;delDashboard&quot;&gt;&lt;/Upload&gt;&lt;!-- 多文件 --&gt;&lt;Upload :isSingle=&quot;false&quot; :files=&quot;item.file&quot; :isCheck=&quot;isCheck&quot; @upload=&quot;uploadImg(index)&quot; @del=&quot;(e)=&gt;delVoucher(e,index)&quot;&gt;&lt;/Upload&gt;","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"uni-app","slug":"uni-app","permalink":"https://qw8.github.io/tags/uni-app/"},{"name":"小程序","slug":"小程序","permalink":"https://qw8.github.io/tags/小程序/"}]},{"title":"uniapp网页H5","slug":"knowledges/uniapp网页H5","date":"2023-04-29T02:03:10.000Z","updated":"2024-03-29T16:11:50.000Z","comments":true,"path":"/knowledges/uniapp-wang-ye-h5.html","link":"","permalink":"https://qw8.github.io/knowledges/uniapp-wang-ye-h5.html","excerpt":"","text":"uniapp动态引入script12345678910111213141516171819onLoad(options) &#123; if (this.envType === 4) &#123; this.loadScript() &#125; &#125;// 动态引入script loadScript() &#123; const URL = &apos;https://cdn.dingxiang-inc.com/ctu-group/captcha-ui/index.js&apos; // 插入script脚本 let scriptNode = document.createElement(&apos;script&apos;) scriptNode.setAttribute(&apos;type&apos;, &apos;text/javascript&apos;) scriptNode.setAttribute(&apos;src&apos;, URL) document.body.appendChild(scriptNode) setTimeout(() =&gt; &#123; this.initDx() &#125;, 1000) &#125;, uniapp的H5项目腾讯地图跨域问题用uni-app开发，h5和小程序使用的都是腾讯地图-微信小程序sdk，但它是为小程序设计的，所以在vue的h5中使用会有跨域问题，所以结合vue-jsonp对这个sdk做了一下修改，可以直接放入h5中使用。此方法不止在uniapp中可以使用，在所有H5项目中都可以。 简单描述一句：就是把sdk内使用的wx对象重写，替换了里面的request方法，使用vue-jsonp完成跨域；H5和小程序不能兼容问题，可以用uniapp的条件编译来解决。 1.在腾讯地图创建应用时，要把webserviceAPI勾选上，并配置H5的域名白名单2.安装vue-jsonp1npm i --save vue-jsonp 3.main.js中添加12import &#123; VueJsonp &#125; from &quot;vue-jsonp&quot;Vue.use(VueJsonp) 如果在这个时候出现 install undefined的报错，需要先初始化npmnpm init -y然后在执行第一步进行安装，就正常了 4.qqmap-wx-jssdk.js中最上方添加以下代码12345678910111213141516171819202122// #ifdef H5// 条件编译：仅出现在 H5 平台下的代码（解决h5地图跨域问题）import Vue from &apos;vue&apos;var vm = new Vue()// wx对象里的request方法重写var wx = &#123; request(obj) &#123; obj.data.output = &apos;jsonp&apos; vm.$jsonp(obj.url, obj.data) .then(json =&gt; &#123; if (json.status == 0) &#123; obj.success(&#123; data: json &#125;) &#125; else &#123; obj.fail(json) &#125; &#125;) .catch(err =&gt; &#123; obj.fail(err) &#125;) &#125;&#125;// #endif 参考链接: https://blog.csdn.net/weixin_42390525/article/details/117596280 https://blog.csdn.net/qq_60485359/article/details/126482245 https://www.jianshu.com/p/4847480995c9 uniapp中h5获取网络类型123456789101112131415161718192021222324252627// 获取网络类型 getNetworkType() &#123; if (this.envType === 4) &#123; // h5判断有无网络 console.log(navigator.onLine); if (navigator.onLine) &#123; this.judge(); &#125; else &#123; this.tip = &quot;网络异常&quot;; this.state = 2; &#125; &#125; else &#123; let _this = this; uni.getNetworkType(&#123; success(res) &#123; console.log(&quot;网络&quot;, res); if (res.networkType === &quot;none&quot;) &#123; _this.tip = &quot;网络异常&quot;; _this.state = 2; &#125; else &#123; _this.getSetting(); &#125; &#125;, &#125;); &#125; console.log(this.tip); &#125; 在网页端，实现监听窗口尺寸变化（同一页套娃效果）App.vue 1234567891011121314151617181920212223242526272829303132onLaunch() &#123; console.log(&apos;App Launch&apos;) this.getSystemInfo() // 如果在网页端，实现监听窗口尺寸变化 if (window) &#123; // PC隐藏tabbar if (this.systemInfo.windowWidth &gt; 750) &#123; uni.hideTabBar() &#125; // 如果PC首次从其他路径进入，就跳到首页，不然没有PC样式 if ( this.systemInfo.windowWidth &gt; 750 &amp;&amp; window.location.pathname !== &apos;/&apos; ) &#123; window.location.href = &apos;/&apos; &#125; // 高频率会让浏览器崩溃，解决这个问题可以用定时器对该函数进行节流 let timer = null, num = 0 // 用来计数，如果只监听到一次，是由于uni.hideTabBar引起的，不需要跳转（没有这个会陷入跳转死循环） window.onresize = function () &#123; console.log(&apos;实时屏幕宽度&apos;, document.body.clientWidth, num) num++ clearTimeout(timer) timer = setTimeout(function () &#123; // 首页有PC相关代码 if (num &gt; 1) &#123; window.location.href = &apos;/&apos; &#125; &#125;, 1000) &#125; &#125;&#125; 请求封装 123456if (res.data.code === 401 &amp;&amp; windowWidth &lt;= 750) &#123; console.log(&quot;小程序登录失效&quot;) uni.reLaunch(&#123; url: &quot;/pages/login/Login&quot; &#125;)&#125; 首页 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;view&gt; &lt;!-- PC --&gt; &lt;view class=&quot;ifram-box&quot; v-if=&quot;systemInfo.windowWidth&gt;750&quot;&gt; &lt;view class=&quot;ifram-wrapper&quot;&gt; &lt;img class=&quot;barcode-image&quot; src=&quot;/static/images/code-bg.png&quot; alt=&quot;&quot;&gt; &lt;view class=&quot;list&quot;&gt; &lt;p class=&quot;list-cell&quot;&gt;请使用手机浏览器，扫描上方二维码预览。&lt;/p&gt; &lt;p class=&quot;list-cell&quot;&gt;PC浏览器，请打开控制台并切换至手机模式后再次刷新浏览。&lt;/p&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;h5-viwer-box&quot;&gt; &lt;iframe frameborder=&quot;0&quot; scrolling=&quot;auto&quot; class=&quot;h5-viwer&quot; width=&quot;375&quot; height=&quot;812&quot; src=&quot;/pages/home/Home&quot;&gt; &lt;/iframe&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 手机 --&gt; &lt;view class=&quot;home-content&quot; v-else&gt; &lt;/view&gt;&lt;/view&gt; async init() &#123; // PC版只展示页面，不需要触发方法 if (this.systemInfo.windowWidth &gt; 750) &#123; return &#125; // 首次登录还没有token，主动跳转，避免登录失效提示 if (this.systemInfo.windowWidth &lt;= 750 &amp;&amp; !this.token) &#123; uni.reLaunch(&#123; url: &apos;/pages/login/Login&apos; &#125;) return &#125; // 获取数据方法 ... &#125; uni-app使用uni.request获取的文件流图片转base64数据网站开发中对于后端请求数据是必不可少的一个操作，而后端反馈的数据格式大致分为字符串、json、文件流等。 对于后端反馈的文件流格式图片，在前端开发中有时并不能被直接使用。这个时候就需要将文件流图片先转换base64格式的图片数据，再来进行展示效果。 1234567891011uni.request(&#123; url: &apos;https://xxx.xxx.com/api/wechat-qrcode&apos;, method: &apos;POST&apos;, responseType: &apos;arraybuffer&apos;, success: (res) =&gt; &#123; this.qrcodeUrl = &apos;data:image/png;base64,&apos; + uni.arrayBufferToBase64(res.data) console.log(this.qrcodeUrl) &#125; &#125;) 参数解析： 1.responseType：设置响应的数据类型为arraybuffer。 2.uni.arrayBufferToBase64将ArrayBuffer对象转成 Base64 字符串 注：uni.arrayBufferToBase64支持平台分别为App、H5、微信小程序、快手小程序、京东小程序 代码逻辑基础说明： 使用uni.request获取服务端反馈的文件流数据（注这里的responseType必须设置为arraybuffer），使用uni.arrayBufferToBase64将获取的文件流转换成base64数据。 转换后的base64数据需要拼接文件头：data:image/png;base64, uniapp修改checkbox样式第一个是H5，第二个是微信小程序 1234567891011121314151617181920212223/deep/ checkbox, uni-checkbox &#123; // checkbox样式 .wx-checkbox-input, .uni-checkbox-input &#123; width: 24rpx; height: 24rpx; padding: 2rpx; border-radius: 0; border: 2rpx solid #c8c9cc; &#125; // checkbox选中后样式 .wx-checkbox-input.wx-checkbox-input-checked, .uni-checkbox-input.uni-checkbox-input-checked &#123; color: #fff !important; background: rgb(31, 108, 221); border: 2rpx solid rgb(31, 108, 221); &#125; // checkbox选中后图标样式 .wx-checkbox-input.wx-checkbox-input-checked::before &#123; color: #fff; &#125; &#125; 参考链接：https://blog.csdn.net/weixin_43655896/article/details/122955576 uniapp打包发布h5项目的缓存问题uniapp 打包 H5 生成的js文件，默认情况下是不包含版本号以及时间戳后缀。这样会导致H5新版打包上线后，用户依旧使用的是浏览器中缓存的老版js文件，文件更新滞后等现象。 第一种(推荐)在根目录新建vue.config.js文件,粘贴以下代码 12345678910111213141516let filePath = &apos;&apos;let Timestamp = &apos;&apos;//编译环境判断,判断是否H5环境if (process.env.UNI_PLATFORM === &apos;h5&apos;) &#123; filePath = &apos;static/js/&apos;; //打包文件存放文件夹路径 Timestamp = &apos;.&apos; + new Date().getTime();//时间戳&#125;module.exports = &#123; configureWebpack: &#123; // webpack 配置 解决js缓存的问题 output: &#123; // 输出重构 打包编译后的 文件目录 文件名称 【模块名称.时间戳】 filename: `$&#123;filePath&#125;[name]$&#123;Timestamp&#125;.js`, chunkFilename: `$&#123;filePath&#125;[name]$&#123;Timestamp&#125;.js` &#125; &#125;&#125; 第二个方法在应用程序的入口文件（如 main.js 或 App.vue）uniapp项目 :h5template.html中添加时间戳。例如，您可以在 index.html 文件中添加以下代码： 123var script = document.createElement(&apos;script&apos;);script.src = &apos;/js/app.js?&apos; + new Date().getTime();document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script); 注意:这个方法可以生效,但是在电脑端调试的时候会看到一个报错,但是不影响使用,有知道完美解决的可以留言一下哦,感谢. 第三个方法1.设置缓存 (未实践) 1&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache&quot; /&gt; 手机页面通常在第一次加载后会进行缓存，然后每次刷新会使用缓存而不是去重新向服务器发送请求。如果不希望使用缓存可以设置no-cache。 2.设置nginx禁止缓存 点击网站-&gt;站点设置-&gt;配置文件，放在这下面即可，把之前的允许js和css缓存删除掉，然后重启nginx或者重新载入nginx配置即可。 img 123location ~ \\.(js|css|html)$ &#123; add_header Cache-Control no-store;&#125; uniapp网页在微信调试时，控制台出现报错Invalid Host/Origin header，[WDS] Disconnected! manifest.json源码视图找到h5，在devServer: 添加 “disableHostCheck”: true 重新启动项目，报错就消失了 注意：只能在Hbuilder创建的项目使用，在cil创建的项目加这个会报错，options has an unknown property ‘disableHostCheck’ 1234567891011121314151617181920&quot;h5&quot;: &#123; &quot;devServer&quot;: &#123; &quot;disableHostCheck&quot;: true // &quot;proxy&quot;: &#123; // &quot;/apis&quot;: &#123; // &quot;target&quot;: &quot;&quot;, // &quot;changeOrigin&quot;: true, // &quot;secure&quot;: false, // &quot;pathRewrite&quot;: &#123; // &quot;^/apis&quot;: &quot;/&quot; // &#125; // &#125; // &#125; &#125;, &quot;router&quot;: &#123; &quot;mode&quot;: &quot;hash&quot; &#125;, &quot;template&quot;: &quot;&quot;, &quot;title&quot;: &quot;&quot; &#125; 通过路径拼接传参时，参数中含有特殊符号（#），被截断造成传参错误1https://user-stage.xiuchuan.com/pages/login/H5Login?mch_id=JiCI1qzUKGP6&amp;redirect_url=http://172.16.8.84:8080/#/myPages/my/inspect 将#变成%23，在onLoad即可正常接受参数 云之家引入js123456789101112131415161718if (window.location.origin === &quot;miniapp://&quot; || options.query.ticket) &#123; // 金蝶小程序或者金蝶轻应用 context.commit(&apos;setWebType&apos;, 4); context.dispatch(&apos;setScript&apos;, &apos;https://static.yunzhijia.com/public/js/qing/latest/qing.js&apos;); // 发布时需要自己切换地址 // context.dispatch(&apos;setApi&apos;, 2); context.dispatch(&apos;setApi&apos;, 3);&#125;// 插入script脚本setScript(context, src) &#123; let scriptNode = document.createElement(&apos;script&apos;) scriptNode.setAttribute(&apos;type&apos;, &apos;text/javascript&apos;) scriptNode.setAttribute(&apos;src&apos;, src) document.body.appendChild(scriptNode) console.log(&apos;已插入脚本&apos;, src)&#125;, 云之家个人信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 personInfo: &#123;&#125;, // 云之家个人信息// 云之家获取个人信息 getPersonInfo() &#123; qing.call(&apos;getPersonInfo&apos;, &#123; success: (res) =&gt; &#123; console.log(&apos;云之家获取个人信息&apos;, res) this.personInfo = res // this.$refs.alertRef.show(&#123; // title: &apos;云之家获取个人信息成功&apos;, // content: JSON.stringify(res) // &#125;) &#125;, error: (res) =&gt; &#123; console.log(&apos;云之家获取个人信息失败&apos;, res) this.personInfo = res &#125; &#125;) &#125;, if (!this.formData.ticket) &#123; // 没有ticket再验证（成功过一次就不用重复验证了） const res = await this.yunValidate() // &#123;success:false, error:&apos;用户取消验证&apos;, errorCode:13400&#125; // &#123;success:false, error:&apos;密码验证错误&apos;, errorCode:13400&#125; // &#123;success:true, errorCode:1, data:&#123;ticket:&apos;APPURLWITHTICKETf3bb6035b335502d1387d6f7cad9249e&apos;&#125;&#125; // this.$refs.alertRef.show(&#123; // title: &apos;金蝶身份确认结果&apos; + typeof res.success, // content: JSON.stringify(res) // &#125;) if (res.success) &#123; // 输入正确的密码才能获取到ticket this.formData.ticket = res.data.ticket &#125; else &#123; uni.showToast(&#123; title: &apos;请输入正确的密码&apos;, icon: &apos;none&apos;, duration: 2000 &#125;) return &#125; &#125; // 金蝶身份确认 yunValidate() &#123; return new Promise((resolve, reject) =&gt; &#123; qing.call(&apos;validate&apos;, &#123; type: &apos;password&apos;, // 验证方式 lightAppId: Config.lightAppId, // 轻应用id prompt: &apos;为正常使用&apos;, // 自定义提示语 ignoreYzjPwd: false, // 是否不做降级处理（false表示降级，使用登录密码验证） success: (res) =&gt; &#123; console.log(res) resolve(res) &#125;, error: (res) =&gt; &#123; console.log(&apos;金蝶身份确认失败&apos;, res) // res.success = true // resolve(res) reject(res) &#125; &#125;) &#125;) &#125;, H5返回uniapp的webview下载js文件放入public/static/uni.webview.1.5.4.js public/index.html 12&lt;!-- 为了返回第三方uniapp的webview --&gt;&lt;script src=&quot;/static/uni.webview.1.5.4.js&quot;&gt;&lt;/script&gt; 在点击事件中 12345678let pages = getCurrentPages()console.log(pages);// 返回上一页uni.webView.navigateBack()// 返回多少层级前的页面uni.webView.redirectTo(&#123; url:`/pages/my/index?level=$&#123;getCurrentPages().length-1&#125;`&#125;)","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"uni-app","slug":"uni-app","permalink":"https://qw8.github.io/tags/uni-app/"}]},{"title":"uniapp钉钉","slug":"knowledges/uniapp钉钉","date":"2023-04-28T11:03:10.000Z","updated":"2024-03-28T17:45:24.000Z","comments":true,"path":"/knowledges/uniapp-ding-ding.html","link":"","permalink":"https://qw8.github.io/knowledges/uniapp-ding-ding.html","excerpt":"","text":"小问题 钉钉小程序后台添加完Webview安全域名需要重新发布应用（或者重新真机调试），并不是实时生效 uni.getLocation放在onLoad偶尔获取不到位置，放在onReady可以避免这个问题 统一授权套件目前只能在H5与小程序使用，PC端暂不支持 https://www.dingtalk.com/qidian/help-detail-1060979859.html 钉钉小程序如何判断其当前环境1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 获取系统信息 getSystemInfo(context) &#123; uni.getSystemInfo(&#123; success(res) &#123; console.log(&quot;设备信息&quot;, res) context.commit(&apos;setSystemInfo&apos;, res); if (res.uniPlatform === &quot;mp-weixin&quot;) &#123; console.log(&quot;微信/企微环境&quot;, __wxConfig); if (res.environment === &quot;wxwork&quot;) &#123; context.commit(&apos;setEnvType&apos;, 2); &#125; else &#123; context.commit(&apos;setEnvType&apos;, 1); &#125; // 不同环境使用不同接口域名 if (__wxConfig.envVersion === &quot;release&quot;) &#123; // 正式版 context.commit(&apos;setApiUrl&apos;, Config.releaseUrl); context.commit(&apos;setProUrl&apos;, Config.releaseProUrl); &#125; else if (__wxConfig.envVersion === &quot;trial&quot;) &#123; // 体验版 context.commit(&apos;setApiUrl&apos;, Config.testUrl); context.commit(&apos;setProUrl&apos;, Config.testProUrl); &#125; else &#123; // 开发版 context.commit(&apos;setApiUrl&apos;, Config.testUrl); context.commit(&apos;setProUrl&apos;, Config.testProUrl); &#125; &#125; else if (res.uniPlatform === &quot;mp-alipay&quot;) &#123; console.log(&quot;钉钉/支付宝环境&quot;, __appxStartupParams, dd.isIDE); dd.getRunScene(&#123; success(res) &#123; console.log(&quot;运行版本&quot;, res.envVersion) &#125;, &#125;) context.commit(&apos;setEnvType&apos;, 3); if (dd.isIDE || __appxStartupParams.isRemoteDebug || __appxStartupParams.source) &#123; // IDE中开发（没有source），或者是远程调试，或者体验版有source console.log(&quot;测试接口&quot;) context.commit(&apos;setApiUrl&apos;, Config.testUrl); context.commit(&apos;setProUrl&apos;, Config.testProUrl); &#125; else &#123; // 正式环境没有source console.log(&quot;正式接口&quot;) context.commit(&apos;setApiUrl&apos;, Config.releaseUrl); context.commit(&apos;setProUrl&apos;, Config.releaseProUrl); &#125; &#125; &#125; &#125;) &#125;, 参考链接：https://blog.csdn.net/keloneko/article/details/106044305 报错及解决报错：corpId is required开发者工具左上角：没有登录或没有选择类型/应用/体验组织报错：{error: 1002, errorMessage: ‘企业无此微应用’}工作台-部署与发布-版本管理与发布-设置体验组织并开通-设置体验人员-开发者工具左上角选择体验组织即可 报错：onLoad调用组件方法，报错未定义 在onReady中调用即可 123456789101112131415onLoad(options) &#123; console.log(options); this.toastType = options.toastType &#125;, onReady() &#123; // 首次登录成功提示（如果放在onLoad中钉钉小程序因为组件还没有渲染完成会报错） if (this.toastType) &#123; this.$refs.toastRef.show( &quot;success&quot;, &quot;登录成功&quot; ); &#125; // 创建 map 上下文 MapContext 对象 this.mapCtx = uni.createMapContext(&quot;myMap&quot;); &#125;, 问题：钉钉输入框没有auto-focus uniapp引入 ‘dingtalk-jsapi’;在main.js中 12import * as dd from &apos;dingtalk-jsapi&apos;;Vue.prototype.dd = dd; 在页面中 123456789import &#123; onAuthAppBack &#125; from &quot;dingtalk-design-libs/biz/openAuthMiniApp&quot;;onAuthAppBack(options, (data) =&gt; &#123; console.log(data, 123); // 这里可以对返回数据做二次处理，之后需要把数据返回到page.onShow dd.alert(&#123; title: &quot;app is onAppShow have data ：&quot; + JSON.stringify(data), &#125;); return data; &#125;); 时间选择器12345678910111213&lt;view class=&quot;message-item&quot;&gt; &lt;text&gt;用车开始时间&lt;/text&gt; &lt;view class=&quot;message-item-content&quot; v-if=&quot;envType === 3&quot; @click=&quot;ddStart&quot;&gt; &lt;text&gt;&#123;&#123; formModel.use_start &#125;&#125;&lt;/text&gt; &lt;image src=&quot;/static/images/index_icon5@2x.png&quot;&gt;&lt;/image&gt; &lt;/view&gt; &lt;date-time mode=&quot;dateminute&quot; :value=&quot;formModel.use_start&quot; @change=&quot;startChange&quot; v-else&gt; &lt;view class=&quot;message-item-content&quot;&gt; &lt;text&gt;&#123;&#123; formModel.use_start &#125;&#125;&lt;/text&gt; &lt;image src=&quot;/static/images/index_icon5@2x.png&quot;&gt;&lt;/image&gt; &lt;/view&gt; &lt;/date-time&gt; &lt;/view&gt; 123456789101112131415// 用车开始时间，时分的事件方法，如果需要时分秒参考https://blog.csdn.net/Shids_/article/details/122084621 startChange(dateTime) &#123; this.formModel.use_start = dateTime + &quot;:00&quot;; &#125;, // 钉钉小程序选择用车开始时间 ddStart() &#123; dd.datePicker(&#123; format: &quot;yyyy-MM-dd HH:mm&quot;, currentDate: this.formModel.use_start, success: (res) =&gt; &#123; console.log(res); this.formModel.use_start = res.date + &quot;:00&quot;; &#125;, &#125;); &#125;, 时间选择组件DateTime.vue见文档：uniapp组件 文件查看1.关于文件查看，在钉钉里需要使用钉盘进行查看。 转存文件到钉盘：dd.saveFileToDingTalk 钉盘文件预览：dd.previewFileInDingTalk 封装成mixins，便于每个文件引用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108import &#123; mapState &#125; from &quot;vuex&quot;;export default &#123; data() &#123; return &#123; &#125;; &#125;, computed: &#123; ...mapState(&#123; envType: (state) =&gt; state.login.envType, proUrl: (state) =&gt; state.login.proUrl, protocol: (state) =&gt; state.login.protocol, &#125;), &#125;, methods: &#123; // 预览协议 previewFile(type) &#123; let url, fileName, obj if (type === 1) &#123; url = this.proUrl + &quot;/mp_source/register.pdf&quot;; fileName = &quot;用户协议&quot; obj = this.protocol.register &#125; else if (type === 2) &#123; url = this.proUrl + &quot;/mp_source/private.pdf&quot;; fileName = &quot;隐私条款&quot; obj = this.protocol.private &#125; if (this.envType === 3) &#123; this.ddPreviewFile(type, url, fileName, obj) &#125; else if (this.envType === 4) &#123; // H5打开协议 window.open(url, &apos;_self&apos;); &#125; else &#123; this.openDocument(url); &#125; &#125;, // 钉钉预览协议 ddPreviewFile(type, url, fileName, obj) &#123; // 如果缓存中有记录就直接预览 if (obj) &#123; dd.previewFileInDingTalk(obj) &#125; else &#123; // 钉钉采用钉盘处理文件 let _this = this dd.saveFileToDingTalk(&#123; url, // 文件在第三方服务器地址 name: fileName, success(res) &#123; if (type === 1) &#123; _this.protocol.register = res.data[0] &#125; else if (type === 2) &#123; _this.protocol.private = res.data[0] &#125; _this.$store.commit(&quot;setProtocol&quot;, _this.protocol); if (res.data.length) &#123; dd.confirm(&#123; title: &apos;提示&apos;, content: &apos;文件已保存到钉盘中，是否需要现在查看？&apos;, confirmButtonText: &apos;确定&apos;, cancelButtonText: &apos;取消&apos;, success: (result) =&gt; &#123; if (result.confirm) &#123; dd.previewFileInDingTalk(&#123; spaceId: res.data[0].spaceId, fileId: res.data[0].fileId, fileName: fileName, fileType: &quot;pdf&quot;, &#125;) &#125; &#125;, &#125;); &#125; &#125;, fail(err) &#123; console.log(err) dd.alert(&#123; content: JSON.stringify(err) &#125;) &#125; &#125;) &#125; &#125;, // 微信/企微预览协议 openDocument(url) &#123; uni.downloadFile(&#123; url, // 要预览的PDF的地址 success(res) &#123; // console.log(res); if (res.statusCode === 200) &#123; // 成功 uni.openDocument(&#123; filePath: res.tempFilePath, // 要打开的文件路径 showMenu: true, // 是否显示右上角菜单 success(res) &#123; // console.log(&quot;打开成功&quot;); &#125;, fail(res) &#123; // console.log(&quot;打开失败&quot;); &#125; &#125;) &#125; &#125;, fail(res) &#123; console.log(res); //失败 &#125; &#125;) &#125; &#125;&#125; 2.下载地址也可以直接使用web-view打开，安卓会跳转到浏览器下载，ios直接可以预览，需在后台配置安全域名。 12345url=&apos;https://resource-test.xiuchuan.com/mp_source/car/register.pdf&apos;// 直接打开下载地址uni.navigateTo(&#123; url: `/sub_my/WebView$&#123;url&#125;`&#125;) 1&lt;web-view :src=&quot;url&quot;&gt;&lt;/web-view&gt; 3.拼接第三方在线预览链接，使用web-view打开，如： 1https://previewpdf.mumudev.top/?file=https://resource-test.xiuchuan.com/mp_source/car/register.pdf 选择图片的坑chooseImage去掉参数去掉sizeType，避免钉钉报错 utils中封装 123456789101112131415161718192021222324252627282930313233343536373839import store from &quot;@/store/index&quot;// 选择图片const chooseImage = () =&gt; &#123; /* 返回一个promise实例化对象 */ return new Promise((resolve, reject) =&gt; &#123; uni.chooseImage(&#123; count: 1, sourceType: [&quot;album&quot;, &quot;camera&quot;], success: (res) =&gt; &#123; console.log(res, store.state.login.envType) let filePath, dealName // 钉钉且不是开发者工具中（预览、真机调试、体验版、正式版） if (store.state.login.envType === 3 &amp;&amp; !dd.isIDE) &#123; // 可以作为img标签的src属性显示图片 filePath = res.files[0].path.slice(0, -5) + res.files[0].fileType dealName = filePath.replace(&quot;https://resource/&quot;, &quot;&quot;).toLowerCase(); &#125; else if (store.state.login.envType === 4) &#123; // 网页版 filePath = res.tempFilePaths[0] dealName = res.tempFiles[0].name; &#125; else &#123; // 微信/企微/钉钉开发者工具 filePath = res.tempFilePaths[0] dealName = filePath.replace(&quot;http://tmp/&quot;, &quot;&quot;).toLowerCase(); &#125; console.log(filePath, dealName) resolve([filePath, dealName]) &#125;, fail: (err) =&gt; &#123; reject(err) &#125; &#125;) &#125;)&#125;module.exports = &#123; chooseImage&#125; 页面中调用 1234567891011121314151617181920212223242526272829303132333435363738394041424344import Utils from &quot;@/utils/index&quot;;// 上传oss async uploadOSS(index) &#123; const [filePath, dealName] = await Utils.chooseImage(); console.log(filePath, dealName) uni.showLoading(&#123; title: &quot;图片上传中&quot;, &#125;); const res = await $http.getUploadOSS(&#123; name: dealName, type: 2, &#125;); const _this = this uni.uploadFile(&#123; url: res.host, filePath, name: &quot;file&quot;, // 钉钉多传两个参数 fileType: &quot;image&quot;, fileName: &quot;file&quot;, formData: &#123; &quot;x:source_name&quot;: res.source_name, key: res.path + res.name, OSSAccessKeyId: res.accessid, signature: res.signature, policy: res.policy, callback: res.callback, &#125;, success(res) &#123; let data = JSON.parse(res.data); _this.formModel.other_amount[index].file_id = data.data.id; _this.formModel.other_amount[index].url = filePath; &#125;, fail(err) &#123; console.log(err); &#125;, complete(res) &#123; console.log(res); uni.hideLoading(); &#125;, &#125;); &#125;, js中使用Promise同步resolve返回多个参数的解决办法123456resolve([filePath, dealName])async uploadOSS(index) &#123; const [filePath, dealName] = await Utils.chooseImage(); console.log(filePath, dealName)&#125; 更新钉钉小程序小程序更新机制 开发者在开发者后台发布新版本之后，并不是用户就会立即使用到最新版的小程序。针对小程序版本的更新，钉钉小程序提供了不同的更新机制。 小程序每次冷启动时，都会检查是否有更新版本，如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。如果距离上一次更新版本超过 48 小时，则会等待新版本的代码包被下载后，直接使用新版本启动。 1.手动更新钉钉小程序发布后，手机端在24小时内还会默认使用旧的版本，如果需要立即使用新版本，请使用以下方法手动更新： 1.通过钉钉工作台打开小程序，使用小程序关闭按钮关闭，重新进入小程序 2.可以退出钉钉登录账户,并杀掉钉钉进程,这样再进去后就是直接访问的最新版本了 3.我的-设置-通用-一键清理，重新进入小程序即可（管用） 2.onLaunch中代码自动触发12345678910111213141516171819202122232425262728293031323334353637// 钉钉更新版本update() &#123; const updateManager = dd.getUpdateManager() updateManager.onCheckForUpdate(function (res) &#123; // 请求完新版本信息的回调 console.log(res) if (res.hasUpdate) &#123; // 如果有新版 dd.showLoading(&#123; content: &apos;正在获取新版本中...&apos;, &#125;); updateManager.onUpdateReady(function (ret) &#123; console.log(ret.version) // 更新版本号 dd.hideLoading() dd.confirm(&#123; title: &apos;更新提示&apos;, content: &apos;新版本已经准备好，是否重启应用？&apos;, success: function (res) &#123; if (res.confirm) &#123; // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启 updateManager.applyUpdate() &#125; &#125; &#125;) &#125;) &#125; &#125;) updateManager.onUpdateFailed(function () &#123; // 新版本下载失败 dd.hideLoading() dd.alert(&#123; title: &apos;新版本下载失败，请重启钉钉后重试！&apos;, buttonText: &apos;我知道了&apos;, success: () =&gt; &#123; &#125;, &#125;) &#125;)&#125;, 这代码写的没问题，问题是即使你有新版上线了，若非冷启动，onCheckForUpdate也检查不到新版本。若冷启动，钉钉又可以自动更新小程序，那还要这一大串代码干啥嘞 表情包 （有的手机有效） 钉钉小程序禁止下拉1234567891011121314151617// 部分页面可用下拉&#123; &quot;path&quot;: &quot;pages/index/index&quot;, &quot;style&quot;: &#123; &quot;navigationBarTitleText&quot;: &quot;首页&quot;, &quot;enablePullDownRefresh&quot;: true, &quot;mp-alipay&quot;: &#123; &quot;allowsBounceVertical&quot;: &quot;YES&quot; &#125; &#125; &#125;,// 全局禁用下拉&quot;globalStyle&quot;: &#123; &quot;mp-alipay&quot;: &#123; &quot;allowsBounceVertical&quot;: &quot;NO&quot; &#125;&#125; 钉钉小程序checkbox大小不好调12345// 兼容钉钉checkbox &#123; border-radius: 50%; transform: scale(0.8);&#125; 钉钉输入框默认会高一点，因为默认有padding123456789input &#123; width: 100%; height: 100%; // 兼容钉钉 padding: 0; margin-left: 8rpx; font-size: 28rpx; background: #f5f7fa;&#125; 钉钉为了让地图视野移动到指定地点123456789101112131415&lt;map id=&quot;myMap&quot; :latitude=&quot;location.latitude&quot; :longitude=&quot;location.longitude&quot; :include-points=&quot;points&quot; scale=&quot;17&quot; show-location @regionchange=&quot;regionchange&quot;&gt;&lt;/map&gt;// 其他平台自动移动视野this.location = locationif (this.envType === 3) &#123; // 钉钉为了让地图视野移动到该地点 this.points = [location]&#125;","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"uni-app","slug":"uni-app","permalink":"https://qw8.github.io/tags/uni-app/"},{"name":"小程序","slug":"小程序","permalink":"https://qw8.github.io/tags/小程序/"}]},{"title":"uniapp安卓IOS","slug":"knowledges/uniapp安卓IOS","date":"2023-04-27T09:03:10.000Z","updated":"2024-03-28T17:45:44.000Z","comments":true,"path":"/knowledges/uniapp-an-zhuo-ios.html","link":"","permalink":"https://qw8.github.io/knowledges/uniapp-an-zhuo-ios.html","excerpt":"","text":"uniapp—app开发(nvue) 如果view包括文字，需要再文字外层包括text 不能使用百分比控制宽高，vh，vw也不支持 仅支持css写法 nvue 页面只能使用flex布局，nvue 页面的布局排列方向默认为竖排（column） 文字内容，必须、只能在&lt;text&gt;组件下。不能在&lt;div&gt;、&lt;view&gt;的text区域里直接写文字。否则即使渲染了，也无法绑定js里的变量 只有text标签可以设置字体大小，字体颜色。 布局不能使用百分比、没有媒体查询。 padding不生效 小程序和app-vue中，&lt;map&gt; 组件是由引擎创建的原生组件，它的层级是最高的，不能通过 z-index 控制层级。在&lt;map&gt;上绘制内容，可使用组件自带的marker、controls等属性，也可以使用&lt;cover-view&gt;组件。App端还可以使用plus.nativeObj.view 或 subNVue 绘制原生内容，参考。另外App端nvue文件不存在层级问题。从微信基础库2.8.3开始，支持map组件的同层渲染，不再有层级问题。 App端nvue文件的map和小程序拉齐度更高。vue里的map则与plus.map功能一致，和小程序的地图略有差异。App端使用map推荐使用nvue。 App 端使用地图组件需要向高德或百度等三方服务商申请SDK资质，获取AppKey，打包时需要在manifest文件中勾选相应模块，在SDK配置中填写Appkey。注意申请包名和打包时的包名需匹配一致，证书信息匹配。在manifest可视化界面有详细申请指南。 ios nvue Color 不支持 ARGB 十六进制，使用 rgba(r,g,b,a) 代替 小程序和App的vue页面，主体是webview渲染的。为了提升性能，小程序和App的vue页面下部分ui元素，比如导航栏、tabbar、video、map使用了原生控件。这种方式被称为混合渲染。 部分CSS样式无法应用于原生组件，例如： 无法对原生组件设置 CSS 动画； 无法定义原生组件为 position: fixed； 不能在父级节点使用 overflow: hidden 来裁剪原生组件的显示区域。 在小程序端真机上，原生组件会遮挡 vConsole 弹出的调试面板。 nvue页面，map地图的include-points属性，怎么设置缩放的左右间距 nvue页面如果使用组件，组件也需要改成nvue的写法 cover-view(开发注意) 只支持基本的定位、布局、文本样式。不支持设置单边的border、background-image、shadow、overflow: visible等。 自定义组件嵌套 cover-view 时，自定义组件的 slot 及其父节点暂不支持通过 wx:if 控制显隐，否则会导致 cover-view 不显示。 css不支持标签选择器 flex布局默认为column，期望是行排列的话，需要手动改成row cover-view里面放文本不能直接放需要在文本外嵌套webview 只支持基本的定位、布局、文本样式。不支持设置单边的border、background-image、shadow、overflow: visible等。单边border不支持 map组件polyline实时更新this.polyline.push或者$set()在安卓上面没效果，需要把整个polyline对象通过解构赋值 1this.polyline = [...this.route.polyline]","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"uni-app","slug":"uni-app","permalink":"https://qw8.github.io/tags/uni-app/"}]},{"title":"uniapp基础知识","slug":"knowledges/uniapp基础知识","date":"2023-04-26T11:03:10.000Z","updated":"2024-03-28T17:42:30.000Z","comments":true,"path":"/knowledges/uniapp-ji-chu-zhi-shi.html","link":"","permalink":"https://qw8.github.io/knowledges/uniapp-ji-chu-zhi-shi.html","excerpt":"","text":"uni-app的基本使用 环境搭建 页面外观配置 数据绑定 uni-app的生命周期 组件的使用 uni-app中样式学习 在uni-app中使用字体图标和开启scss 条件注释跨端兼容 uni中的事件 导航跳转 组件创建和通讯，及组件的生命周期 uni-app中使用uni-ui库 uni-app介绍uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台。 即使不跨端，uni-app同时也是更好的小程序开发框架。 具有vue和微信小程序的开发经验，可快速上手uni-app 为什么要去学习uni-app？ 相对开发者来说，减少了学习成本，因为只学会uni-app之后，即可开发出iOS、Android、H5、以及各种小程序的应用，不需要再去学习开发其他应用的框架，相对公司而言，也大大减少了开发成本。 官方网页 环境搭建安装编辑器HbuilderX 下载地址 HBuilderX是通用的前端开发工具，但为uni-app做了特别强化。 下载App开发版，可开箱即用 安装微信开发者工具 下载地址 利用HbuilderX初始化项目 点击HbuilderX菜单栏文件&gt;项目&gt;新建 选择uni-app,填写项目名称，项目创建的目录 运行项目在菜单栏中点击运行，运行到浏览器，选择浏览器即可运行 在微信开发者工具里运行：进入hello-uniapp项目，点击工具栏的运行 -&gt; 运行到小程序模拟器 -&gt; 微信开发者工具，即可在微信开发者工具里面体验uni-app 在微信开发者工具里运行：进入hello-uniapp项目，点击工具栏的运行 -&gt; 运行到手机或模拟器 -&gt; 选择调式的手机 注意： 如果是第一次使用，需要先配置小程序ide的相关路径（比如微信开发者工具安装路径），才能运行成功 微信开发者工具在设置中安全设置，服务端口开启 介绍项目目录和文件作用pages.json 文件用来对 uni-app 进行全局配置，决定页面文件的路径、窗口样式、原生的导航栏、底部的原生tabbar 等 manifest.json 文件是应用的配置文件，用于指定应用的名称、图标、权限等。 App.vue是我们的根组件，所有页面都是在App.vue下进行切换的，是页面入口文件，可以调用应用的生命周期函数。 main.js是我们的项目入口文件，主要作用是初始化vue实例并使用需要的插件。 uni.scss文件的用途是为了方便整体控制应用的风格。比如按钮颜色、边框风格，uni.scss文件里预置了一批scss变量预置。 就是打包目录，在这里有各个平台的打包文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051```pages``` 所有的页面存放目录```static``` 静态资源目录，例如图片等```components``` 组件存放目录为了实现多端兼容，综合考虑编译速度、运行性能等因素，`uni-app` 约定了如下开发规范：- 页面文件遵循 [Vue 单文件组件 (SFC) 规范](https://vue-loader.vuejs.org/zh/spec.html)- 组件标签靠近小程序规范，详见[uni-app 组件规范](https://uniapp.dcloud.io/component/README)- 接口能力（JS API）靠近微信小程序规范，但需将前缀 `wx` 替换为 `uni`，详见[uni-app接口规范](https://uniapp.dcloud.io/api/README)- 数据绑定及事件处理同 `Vue.js` 规范，同时补充了App及页面的生命周期- 为兼容多端运行，建议使用flex布局进行开发### 全局配置和页面配置通过globalStyle进行全局配置用于设置应用的状态栏、导航条、标题、窗口背景色等。[详细文档](https://uniapp.dcloud.io/collocation/pages?id=globalstyle)| 属性 | 类型 | 默认值 | 描述 || ---------------------------- | -------- | ------- | ---------------------------------------- || navigationBarBackgroundColor | HexColor | #F7F7F7 | 导航栏背景颜色（同状态栏背景色） || navigationBarTextStyle | String | white | 导航栏标题颜色及状态栏前景颜色，仅支持 black/white || navigationBarTitleText | String | | 导航栏标题文字内容 || backgroundColor | HexColor | #ffffff | 窗口的背景色 || backgroundTextStyle | String | dark | 下拉 loading 的样式，仅支持 dark / light || enablePullDownRefresh | Boolean | false | 是否开启下拉刷新，详见[页面生命周期](https://uniapp.dcloud.io/use?id=%e9%a1%b5%e9%9d%a2%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f)。 || onReachBottomDistance | Number | 50 | 页面上拉触底事件触发时距页面底部距离，单位只支持px，详见[页面生命周期](https://uniapp.dcloud.io/use?id=%e9%a1%b5%e9%9d%a2%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f) |### 创建新的message页面右键pages新建message目录，在message目录下右键新建.vue文件,并选择基本模板```html&lt;template&gt; &lt;view&gt; 这是信息页面 &lt;/view&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 通过pages来配置页面 属性 类型 默认值 描述 path String 配置页面路径 style Object 配置页面窗口表现，配置项参考 pageStyle pages数组数组中第一项表示应用启动页 1234567891011\"pages\": [ &#123; \"path\":\"pages/message/message\" &#125;, &#123; \"path\": \"pages/index/index\", \"style\": &#123; \"navigationBarTitleText\": \"uni-app\" &#125; &#125; ] 通过style修改页面的标题和导航栏背景色，并且设置h5下拉刷新的特有样式 12345678910111213141516\"pages\": [ //pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages &#123; \"path\":\"pages/message/message\", \"style\": &#123; \"navigationBarBackgroundColor\": \"#007AFF\", \"navigationBarTextStyle\": \"white\", \"enablePullDownRefresh\": true, \"disableScroll\": true, \"h5\": &#123; \"pullToRefresh\": &#123; \"color\": \"#007AFF\" &#125; &#125; &#125; &#125; ] 配置tabbar如果应用是一个多 tab 应用，可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页。 Tips 当设置 position 为 top 时，将不会显示 icon tabBar 中的 list 是一个数组，只能配置最少2个、最多5个 tab，tab 按数组的顺序排序。 属性说明： 属性 类型 必填 默认值 描述 平台差异说明 color HexColor 是 tab 上的文字默认颜色 selectedColor HexColor 是 tab 上的文字选中时的颜色 backgroundColor HexColor 是 tab 的背景色 borderStyle String 否 black tabbar 上边框的颜色，仅支持 black/white App 2.3.4+ 支持其他颜色值 list Array 是 tab 的列表，详见 list 属性说明，最少2个、最多5个 tab position String 否 bottom 可选值 bottom、top top 值仅微信小程序支持 其中 list 接收一个数组，数组中的每个项都是一个对象，其属性值如下： 属性 类型 必填 说明 pagePath String 是 页面路径，必须在 pages 中先定义 text String 是 tab 上按钮文字，在 5+APP 和 H5 平台为非必填。例如中间可放一个没有文字的+号图标 iconPath String 否 图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px，当 postion 为 top 时，此参数无效，不支持网络图片，不支持字体图标 selectedIconPath String 否 选中时的图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px ，当 postion 为 top 时，此参数无效 案例代码： 12345678910111213141516171819202122\"tabBar\": &#123; \"list\": [ &#123; \"text\": \"首页\", \"pagePath\":\"pages/index/index\", \"iconPath\":\"static/tabs/home.png\", \"selectedIconPath\":\"static/tabs/home-active.png\" &#125;, &#123; \"text\": \"信息\", \"pagePath\":\"pages/message/message\", \"iconPath\":\"static/tabs/message.png\", \"selectedIconPath\":\"static/tabs/message-active.png\" &#125;, &#123; \"text\": \"我们\", \"pagePath\":\"pages/contact/contact\", \"iconPath\":\"static/tabs/contact.png\", \"selectedIconPath\":\"static/tabs/contact-active.png\" &#125; ] &#125; condition启动模式配置启动模式配置，仅开发期间生效，用于模拟直达页面的场景，如：小程序转发后，用户点击所打开的页面。 属性说明： 属性 类型 是否必填 描述 current Number 是 当前激活的模式，list节点的索引值 list Array 是 启动模式列表 list说明： 属性 类型 是否必填 描述 name String 是 启动模式名称 path String 是 启动页面路径 query String 否 启动参数，可在页面的 onLoad 函数里获得 组件的基本使用uni-app提供了丰富的基础组件给开发者，开发者可以像搭积木一样，组合各种组件拼接称自己的应用 uni-app中的组件，就像 HTML 中的 div 、p、span 等标签的作用一样，用于搭建页面的基础结构 text文本组件的用法text 组件的属性 属性 类型 默认值 必填 说明 selectable boolean false 否 文本是否可选 space string . 否 显示连续空格，可选参数：ensp、emsp、nbsp decode boolean false 否 是否解码 text 组件相当于行内标签、在同一行显示 除了文本节点以外的其他节点都无法长按选中 代码案例1234567891011121314151617181920212223242526&lt;view&gt; &lt;!-- 长按文本是否可选 --&gt; &lt;text selectable='true'&gt;来了老弟&lt;/text&gt;&lt;/view&gt;&lt;view&gt; &lt;!-- 显示连续空格的方式 --&gt; &lt;view&gt; &lt;text space='ensp'&gt;来了 老弟&lt;/text&gt; &lt;/view&gt; &lt;view&gt; &lt;text space='emsp'&gt;来了 老弟&lt;/text&gt; &lt;/view&gt; &lt;view&gt; &lt;text space='nbsp'&gt;来了 老弟&lt;/text&gt; &lt;/view&gt;&lt;/view&gt;&lt;view&gt; &lt;text&gt;skyblue&lt;/text&gt;&lt;/view&gt;&lt;view&gt; &lt;!-- 是否解码 --&gt; &lt;text decode='true'&gt;&amp;nbsp; &amp;lt; &amp;gt; &amp;amp; &amp;apos; &amp;ensp; &amp;emsp;&lt;/text&gt;&lt;/view&gt; view视图容器组件的用法 View 视图容器， 类似于 HTML 中的 div 组件的属性 代码案例1234&lt;view class=\"box2\" hover-class=\"box2_active\"&gt; &lt;view class='box1' hover-class='active' hover-stop-propagation :hover-start-time=\"2000\" :hover-stay-time='2000'&gt; &lt;/view&gt;&lt;/view&gt; button按钮组件的用法组件的属性 属性名 类型 默认值 说明 size String default 按钮的大小 type String default 按钮的样式类型 plain Boolean false 按钮是否镂空，背景色透明 disabled Boolean false 是否按钮 loading Boolean false 名称是否带 loading t图标 button 组件默认独占一行，设置 size 为 mini 时可以在一行显示多个 案例代码12345&lt;button size='mini' type='primary'&gt;前端&lt;/button&gt;&lt;button size='mini' type='default' disabled='true'&gt;前端&lt;/button&gt;&lt;button size='mini' type='warn' loading='true'&gt;前端&lt;/button&gt; image组件的使用文档 属性名 类型 默认值 说明 平台差异说明 src String 图片资源地址 mode String ‘scaleToFill’ 图片裁剪、缩放的模式 Tips &lt;image&gt; 组件默认宽度 300px、高度 225px； src 仅支持相对路径、绝对路径，支持 base64 码； 页面结构复杂，css样式太多的情况，使用 image 可能导致样式生效较慢，出现 “闪一下” 的情况，此时设置 image{will-change: transform} ,可优化此问题。 uni-app中的样式 rpx 即响应式px，一种根据屏幕宽度自适应的动态单位。以750宽的屏幕为基准，750rpx恰好为屏幕宽度。屏幕变宽，rpx 实际显示效果会等比放大。 使用@import语句可以导入外联样式表，@import后跟需要导入的外联样式表的相对路径，用;表示语句结束 支持基本常用的选择器class、id、element等 在 uni-app 中不能使用 * 选择器。 page 相当于 body 节点 定义在 App.vue 中的样式为全局样式，作用于每一个页面。在 pages 目录下 的 vue 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 App.vue 中相同的选择器。 uni-app 支持使用字体图标，使用方式与普通 web 项目相同，需要注意以下几点： 字体文件小于 40kb，uni-app 会自动将其转化为 base64 格式； 字体文件大于等于 40kb， 需开发者自己转换，否则使用将不生效； 字体文件的引用路径推荐使用以 ~@ 开头的绝对路径。 1234@font-face &#123; font-family: test1-icon; src: url(&apos;~@/static/iconfont.ttf&apos;);&#125; 如何使用scss或者less uni-app中的数据绑定在页面中需要定义数据，和我们之前的vue一摸一样，直接在data中定义数据即可 1234567export default &#123; data () &#123; return &#123; msg: 'hello-uni' &#125; &#125;&#125; 插值表达式的使用利用插值表达式渲染基本数据 1&lt;view&gt;&#123;&#123;msg&#125;&#125;&lt;/view&gt; 在插值表达式中使用三元运算 1&lt;view&gt;&#123;&#123; flag ? '我是真的':'我是假的' &#125;&#125;&lt;/view&gt; 基本运算 1&lt;view&gt;&#123;&#123;1+1&#125;&#125;&lt;/view&gt; v-bind动态绑定属性在data中定义了一张图片，我们希望把这张图片渲染到页面上 1234567export default &#123; data () &#123; return &#123; img: 'http://destiny001.gitee.io/image/monkey_02.jpg' &#125; &#125;&#125; 利用v-bind进行渲染 1&lt;image v-bind:src=\"img\"&gt;&lt;/image&gt; 还可以缩写成: 1&lt;image :src=\"img\"&gt;&lt;/image&gt; v-for的使用data中定以一个数组，最终将数组渲染到页面上 12345678910data () &#123; return &#123; arr: [ &#123; name: '刘能', age: 29 &#125;, &#123; name: '赵四', age: 39 &#125;, &#123; name: '宋小宝', age: 49 &#125;, &#123; name: '小沈阳', age: 59 &#125; ] &#125;&#125; 利用v-for进行循环 1&lt;view v-for=\"(item,i) in arr\" :key=\"i\"&gt;名字：&#123;&#123;item.name&#125;&#125;---年龄：&#123;&#123;item.age&#125;&#125;&lt;/view&gt; uni中的事件事件绑定在uni中事件绑定和vue中是一样的，通过v-on进行事件的绑定，也可以简写为@ 1&lt;button @click=\"tapHandle\"&gt;点我啊&lt;/button&gt; 事件函数定义在methods中 12345methods: &#123; tapHandle () &#123; console.log('真的点我了') &#125;&#125; 事件传参默认如果没有传递参数，事件函数第一个形参为事件对象 12345678// template&lt;button @click=&quot;tapHandle&quot;&gt;点我啊&lt;/button&gt;// scriptmethods: &#123; tapHandle (e) &#123; console.log(e) &#125;&#125; 如果给事件函数传递参数了，则对应的事件函数形参接收的则是传递过来的数据 12345678// template&lt;button @click=&quot;tapHandle(1)&quot;&gt;点我啊&lt;/button&gt;// scriptmethods: &#123; tapHandle (num) &#123; console.log(num) &#125;&#125; 如果获取事件对象也想传递参数 12345678// template&lt;button @click=&quot;tapHandle(1,$event)&quot;&gt;点我啊&lt;/button&gt;// scriptmethods: &#123; tapHandle (num,e) &#123; console.log(num,e) &#125;&#125; uni的生命周期应用的生命周期生命周期的概念：一个对象从创建、运行、销毁的整个过程被成为生命周期。 生命周期函数：在生命周期中每个阶段会伴随着每一个函数的触发，这些函数被称为生命周期函数 uni-app 支持如下应用生命周期函数： 函数名 说明 onLaunch 当uni-app 初始化完成时触发（全局只触发一次） onShow 当 uni-app 启动，或从后台进入前台显示 onHide 当 uni-app 从前台进入后台 onError 当 uni-app 报错时触发 页面的生命周期uni-app 支持如下页面生命周期函数： 函数名 说明 平台差异说明 最低版本 onLoad 监听页面加载，其参数为上个页面传递的数据，参数类型为Object（用于页面传参），参考示例 onShow 监听页面显示。页面每次出现在屏幕上都触发，包括从下级页面点返回露出当前页面 onReady 监听页面初次渲染完成。 onHide 监听页面隐藏 onUnload 监听页面卸载 下拉刷新开启下拉刷新在uni-app中有两种方式开启下拉刷新 需要在 pages.json 里，找到的当前页面的pages节点，并在 style 选项中开启 enablePullDownRefresh 通过调用uni.startPullDownRefresh方法来开启下拉刷新 通过配置文件开启创建list页面进行演示 123456789101112131415161718192021&lt;template&gt; &lt;view&gt; 杭州学科 &lt;view v-for=\"(item,index) in arr\" :key=\"index\"&gt; &#123;&#123;item&#125;&#125; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; arr: ['前端','java','ui','大数据'] &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 通过pages.json文件中找到当前页面的pages节点，并在 style 选项中开启 enablePullDownRefresh 123456&#123; \"path\":\"pages/list/list\", \"style\":&#123; \"enablePullDownRefresh\": true &#125;&#125; 通过API开启api文档 1uni.startPullDownRefresh() 监听下拉刷新通过onPullDownRefresh可以监听到下拉刷新的动作 123456789101112131415export default &#123; data () &#123; return &#123; arr: ['前端','java','ui','大数据'] &#125; &#125;, methods: &#123; startPull () &#123; uni.startPullDownRefresh() &#125; &#125;, onPullDownRefresh () &#123; console.log('触发下拉刷新了') &#125;&#125; 关闭下拉刷新uni.stopPullDownRefresh() 停止当前页面下拉刷新。 案例演示 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;view&gt; &lt;button type=\"primary\" @click=\"startPull\"&gt;开启下拉刷新&lt;/button&gt; 杭州学科 &lt;view v-for=\"(item,index) in arr\" :key=\"index\"&gt; &#123;&#123;item&#125;&#125; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; arr: ['前端','java','ui','大数据'] &#125; &#125;, methods: &#123; startPull () &#123; uni.startPullDownRefresh() &#125; &#125;, onPullDownRefresh () &#123; this.arr = [] setTimeout(()=&gt; &#123; this.arr = ['前端','java','ui','大数据'] uni.stopPullDownRefresh() &#125;, 1000); &#125; &#125;&lt;/script&gt; 上拉加载通过在pages.json文件中找到当前页面的pages节点下style中配置onReachBottomDistance可以设置距离底部开启加载的距离，默认为50px 通过onReachBottom监听到触底的行为 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;view&gt; &lt;button type=\"primary\" @click=\"startPull\"&gt;开启下拉刷新&lt;/button&gt; 杭州学科 &lt;view v-for=\"(item,index) in arr\" :key=\"index\"&gt; &#123;&#123;item&#125;&#125; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; arr: ['前端','java','ui','大数据','前端','java','ui','大数据'] &#125; &#125;, onReachBottom () &#123; console.log('触底了') &#125; &#125;&lt;/script&gt;&lt;style&gt; view&#123; height: 100px; line-height: 100px; &#125;&lt;/style&gt; 网络请求在uni中可以调用uni.request方法进行请求网络请求 需要注意的是：在小程序中网络相关的 API 在使用前需要配置域名白名单。 发送get请求12345678910111213141516171819&lt;template&gt; &lt;view&gt; &lt;button @click=\"sendGet\"&gt;发送请求&lt;/button&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; sendGet () &#123; uni.request(&#123; url: 'http://localhost:8082/api/getlunbo', success(res) &#123; console.log(res) &#125; &#125;) &#125; &#125; &#125;&lt;/script&gt; 数据缓存uni.setStorage官方文档 将数据存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个异步接口。 代码演示 123456789101112131415161718192021222324&lt;template&gt; &lt;view&gt; &lt;button type=\"primary\" @click=\"setStor\"&gt;存储数据&lt;/button&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; setStor () &#123; uni.setStorage(&#123; key: 'id', data: 100, success () &#123; console.log('存储成功') &#125; &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; uni.setStorageSync将 data 存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个同步接口。 代码演示 123456789101112131415161718&lt;template&gt; &lt;view&gt; &lt;button type=\"primary\" @click=\"setStor\"&gt;存储数据&lt;/button&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; setStor () &#123; uni.setStorageSync('id',100) &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; uni.getStorage从本地缓存中异步获取指定 key 对应的内容。 代码演示 123456789101112131415161718192021222324&lt;template&gt; &lt;view&gt; &lt;button type=\"primary\" @click=\"getStorage\"&gt;获取数据&lt;/button&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; id: '' &#125; &#125;, methods: &#123; getStorage () &#123; uni.getStorage(&#123; key: 'id', success: res=&gt;&#123; this.id = res.data &#125; &#125;) &#125; &#125; &#125;&lt;/script&gt; uni.getStorageSync从本地缓存中同步获取指定 key 对应的内容。 代码演示 123456789101112131415&lt;template&gt; &lt;view&gt; &lt;button type=\"primary\" @click=\"getStorage\"&gt;获取数据&lt;/button&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; getStorage () &#123; const id = uni.getStorageSync('id') console.log(id) &#125; &#125; &#125;&lt;/script&gt; uni.removeStorage从本地缓存中异步移除指定 key。 代码演示 12345678910111213141516171819&lt;template&gt; &lt;view&gt; &lt;button type=\"primary\" @click=\"removeStorage\"&gt;删除数据&lt;/button&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; removeStorage () &#123; uni.removeStorage(&#123; key: 'id', success: function () &#123; console.log('删除成功') &#125; &#125;) &#125; &#125; &#125;&lt;/script&gt; uni.removeStorageSync从本地缓存中同步移除指定 key。 代码演示 1234567891011121314&lt;template&gt; &lt;view&gt; &lt;button type=\"primary\" @click=\"removeStorage\"&gt;删除数据&lt;/button&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; removeStorage () &#123; uni.removeStorageSync('id') &#125; &#125; &#125;&lt;/script&gt; 上传图片、预览图片上传图片uni.chooseImage方法从本地相册选择图片或使用相机拍照。 案例代码 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;view&gt; &lt;button @click=\"chooseImg\" type=\"primary\"&gt;上传图片&lt;/button&gt; &lt;view&gt; &lt;image v-for=\"item in imgArr\" :src=\"item\" :key=\"index\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; imgArr: [] &#125; &#125;, methods: &#123; chooseImg () &#123; uni.chooseImage(&#123; count: 9, success: res=&gt;&#123; this.imgArr = res.tempFilePaths &#125; &#125;) &#125; &#125; &#125;&lt;/script&gt; 预览图片结构 123&lt;view&gt; &lt;image v-for=\"item in imgArr\" :src=\"item\" @click=\"previewImg(item)\" :key=\"item\"&gt;&lt;/image&gt;&lt;/view&gt; 预览图片的方法 123456previewImg (current) &#123; uni.previewImage(&#123; urls: this.imgArr, current &#125;)&#125; 条件注释实现跨段兼容条件编译是用特殊的注释作为标记，在编译时根据这些特殊的注释，将注释里面的代码编译到不同平台。 写法：以 #ifdef 加平台标识 开头，以 #endif 结尾。 平台标识 值 平台 参考文档 APP-PLUS 5+App HTML5+ 规范 H5 H5 MP-WEIXIN 微信小程序 微信小程序 MP-ALIPAY 支付宝小程序 支付宝小程序 MP-BAIDU 百度小程序 百度小程序 MP-TOUTIAO 头条小程序 头条小程序 MP-QQ QQ小程序 （目前仅cli版支持） MP 微信小程序/支付宝小程序/百度小程序/头条小程序/QQ小程序 组件的条件注释代码演示 123456789101112131415&lt;!-- #ifdef H5 --&gt;&lt;view&gt; h5页面会显示&lt;/view&gt;&lt;!-- #endif --&gt;&lt;!-- #ifdef MP-WEIXIN --&gt;&lt;view&gt; 微信小程序会显示&lt;/view&gt;&lt;!-- #endif --&gt;&lt;!-- #ifdef APP-PLUS --&gt;&lt;view&gt; app会显示&lt;/view&gt;&lt;!-- #endif --&gt; api的条件注释代码演示 12345678onLoad () &#123; //#ifdef MP-WEIXIN console.log('微信小程序') //#endif //#ifdef H5 console.log('h5页面') //#endif&#125; 样式的条件注释 代码演示 1234567891011121314/* #ifdef H5 */view&#123; height: 100px; line-height: 100px; background: red;&#125;/* #endif *//* #ifdef MP-WEIXIN */view&#123; height: 100px; line-height: 100px; background: green;&#125;/* #endif */ uni中的导航跳转利用navigator进行跳转navigator详细文档：文档地址 跳转到普通页面 123&lt;navigator url=\"/pages/about/about\" hover-class=\"navigator-hover\"&gt; &lt;button type=\"default\"&gt;跳转到关于页面&lt;/button&gt;&lt;/navigator&gt; 跳转到tabbar页面 123&lt;navigator url=\"/pages/message/message\" open-type=\"switchTab\"&gt; &lt;button type=\"default\"&gt;跳转到message页面&lt;/button&gt;&lt;/navigator&gt; 利用编程式导航进行跳转导航跳转文档 利用navigateTo进行导航跳转保留当前页面，跳转到应用内的某个页面，使用uni.navigateBack可以返回到原页面。 1&lt;button type=\"primary\" @click=\"goAbout\"&gt;跳转到关于页面&lt;/button&gt; 通过navigateTo方法进行跳转到普通页面 12345goAbout () &#123; uni.navigateTo(&#123; url: '/pages/about/about', &#125;)&#125; 通过switchTab跳转到tabbar页面跳转到tabbar页面 1&lt;button type=\"primary\" @click=\"goMessage\"&gt;跳转到message页面&lt;/button&gt; 通过switchTab方法进行跳转 12345goMessage () &#123; uni.switchTab(&#123; url: '/pages/message/message' &#125;)&#125; redirectTo进行跳转关闭当前页面，跳转到应用内的某个页面。 12345678&lt;!-- template --&gt;&lt;button type=\"primary\" @click=\"goMessage\"&gt;跳转到message页面&lt;/button&gt;&lt;!-- js --&gt;goMessage () &#123; uni.switchTab(&#123; url: '/pages/message/message' &#125;)&#125; 通过onUnload测试当前组件确实卸载 123onUnload () &#123; console.log('组件卸载了')&#125; 导航跳转传递参数在导航进行跳转到下一个页面的同时，可以给下一个页面传递相应的参数，接收参数的页面可以通过onLoad生命周期进行接收 传递参数的页面 12345goAbout () &#123; uni.navigateTo(&#123; url: '/pages/about/about?id=80', &#125;);&#125; 接收参数的页面 1234567&lt;script&gt; export default &#123; onLoad (options) &#123; console.log(options) &#125; &#125;&lt;/script&gt; uni-app中组件的创建在uni-app中，可以通过创建一个后缀名为vue的文件，即创建一个组件成功，其他组件可以将该组件通过impot的方式导入，在通过components进行注册即可 创建login组件，在component中创建login目录，然后新建login.vue文件 1234567891011&lt;template&gt; &lt;view&gt; 这是一个自定义组件 &lt;/view&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 在其他组件中导入该组件并注册 1import login from &quot;@/components/test/test.vue&quot; 注册组件 1components: &#123;test&#125; 使用组件 1&lt;test&gt;&lt;/test&gt; 组件的生命周期函数 beforeCreate 在实例初始化之后被调用。详见 created 在实例创建完成后被立即调用。详见 beforeMount 在挂载开始之前被调用。详见 mounted 挂载到实例上去之后调用。详见 注意：此处并不能确定子组件被全部挂载，如果需要子组件完全挂载之后在执行操作可以使用$nextTickVue官方文档 beforeUpdate 数据更新时调用，发生在虚拟 DOM 打补丁之前。详见 仅H5平台支持 updated 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。详见 仅H5平台支持 beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。详见 destroyed Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。详见 组件的通讯父组件给子组件传值通过props来接受外界传递到组件内部的值 1234567891011121314&lt;template&gt; &lt;view&gt; 这是一个自定义组件 &#123;&#123;msg&#125;&#125; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: [&apos;msg&apos;] &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 其他组件在使用login组件的时候传递值 123456789101112131415161718&lt;template&gt; &lt;view&gt; &lt;test :msg=&quot;msg&quot;&gt;&lt;/test&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; import test from &quot;@/components/test/test.vue&quot; export default &#123; data () &#123; return &#123; msg: &apos;hello&apos; &#125; &#125;, components: &#123;test&#125; &#125;&lt;/script&gt; 子组件给父组件传值通过$emit触发事件进行传递参数 123456789101112131415161718192021222324252627&lt;template&gt; &lt;view&gt; 这是一个自定义组件 &#123;&#123;msg&#125;&#125; &lt;button type=\"primary\" @click=\"sendMsg\"&gt;给父组件传值&lt;/button&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; status: '打篮球' &#125; &#125;, props: &#123; msg: &#123; type: String, value: '' &#125; &#125;, methods: &#123; sendMsg () &#123; this.$emit('myEvent',this.status) &#125; &#125; &#125;&lt;/script&gt; 父组件定义自定义事件并接收参数 12345678910111213141516171819202122&lt;template&gt; &lt;view&gt; &lt;test :msg=\"msg\" @myEvent=\"getMsg\"&gt;&lt;/test&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; import test from \"@/components/test/test.vue\" export default &#123; data () &#123; return &#123; msg: 'hello' &#125; &#125;, methods: &#123; getMsg (res) &#123; console.log(res) &#125; &#125;, components: &#123;test&#125; &#125;&lt;/script&gt; uni-app 全局变量的几种实现方式公用模块定义一个专用的模块，用来组织和管理这些全局的变量，在需要的页面引入。 注意这种方式只支持多个vue页面或多个nvue页面之间公用，vue和nvue之间不公用。 示例如下：在 uni-app 项目根目录下创建 common 目录，然后在 common 目录下新建 helper.js 用于定义公用的方法。 12345678910111213const websiteUrl = 'http://uniapp.dcloud.io'; const now = Date.now || function () &#123; return new Date().getTime(); &#125;; const isArray = Array.isArray || function (obj) &#123; return obj instanceof Array; &#125;; export default &#123; websiteUrl, now, isArray &#125; 接下来在 pages/index/index.vue 中引用该模块 1234567891011121314&lt;script&gt; import helper from '../../common/helper.js'; export default &#123; data() &#123; return &#123;&#125;; &#125;, onLoad()&#123; console.log('now:' + helper.now()); &#125;, methods: &#123; &#125; &#125; &lt;/script&gt; 这种方式维护起来比较方便，但是缺点就是每次都需要引入。 挂载 Vue.prototype将一些使用频率较高的常量或者方法，直接扩展到 Vue.prototype 上，每个 Vue 对象都会“继承”下来。 注意这种方式只支持vue页面 示例如下：在 main.js 中挂载属性/方法 1234567Vue.prototype.websiteUrl = 'http://uniapp.dcloud.io'; Vue.prototype.now = Date.now || function () &#123; return new Date().getTime(); &#125;; Vue.prototype.isArray = Array.isArray || function (obj) &#123; return obj instanceof Array; &#125;; 然后在 pages/index/index.vue 中调用 123456789101112&lt;script&gt; export default &#123; data() &#123; return &#123;&#125;; &#125;, onLoad()&#123; console.log('now:' + this.now()); &#125;, methods: &#123; &#125; &#125; &lt;/script&gt; 这种方式，只需要在 main.js 中定义好即可在每个页面中直接调用。 Tips 每个页面中不要在出现重复的属性或方法名。 建议在 Vue.prototype 上挂载的属性或方法，可以加一个统一的前缀。比如 $url、global_url 这样，在阅读代码时也容易与当前页面的内容区分开。 globalData小程序中有个globalData概念，可以在 App 上声明全局变量。 Vue 之前是没有这类概念的，但 uni-app 引入了globalData概念，并且在包括H5、App等平台都实现了。在 App.vue 可以定义 globalData ，也可以使用 API 读写这个值。 globalData支持vue和nvue共享数据。 globalData是一种比较简单的全局变量使用方式。 定义：App.vue 1234567891011121314151617181920&lt;script&gt; export default &#123; globalData: &#123; text: 'text' &#125;, onLaunch: function() &#123; console.log('App Launch') &#125;, onShow: function() &#123; console.log('App Show') &#125;, onHide: function() &#123; console.log('App Hide') &#125; &#125; &lt;/script&gt; &lt;style&gt; /*每个页面公共css */ &lt;/style&gt; js中操作globalData的方式如下： 赋值：getApp().globalData.text = &#39;test&#39; 取值：console.log(getApp().globalData.text) // &#39;test&#39; 如果需要把globalData的数据绑定到页面上，可在页面的onshow声明周期里进行变量重赋值。HBuilderX 2.0.3起，nvue页面在uni-app编译模式下，也支持onshow。 VuexVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 HBuilderX 2.2.5+起，支持vue和nvue之间共享。参考 这里以登录后同步更新用户信息为例，简单说明下 Vuex 的用法，更多更详细的 Vuex 的内容，建议前往其官网 Vuex 学习下。 举例说明： 在 uni-app 项目根目录下新建 store 目录，在 store 目录下创建 index.js 定义状态值 123456789101112131415161718192021222324const store = new Vuex.Store(&#123; state: &#123; login: false, token: '', avatarUrl: '', userName: '' &#125;, mutations: &#123; login(state, provider) &#123; console.log(state) console.log(provider) state.login = true; state.token = provider.token; state.userName = provider.userName; state.avatarUrl = provider.avatarUrl; &#125;, logout(state) &#123; state.login = false; state.token = ''; state.userName = ''; state.avatarUrl = ''; &#125; &#125; &#125;) 然后，需要在 main.js 挂载 Vuex 12import store from './store' Vue.prototype.$store = store 最后，在 pages/index/index.vue 使用 123456789101112131415&lt;script&gt; import &#123; mapState, mapMutations &#125; from 'vuex'; export default &#123; computed: &#123; ...mapState(['avatarUrl', 'login', 'userName']) &#125;, methods: &#123; ...mapMutations(['logout']) &#125; &#125; &lt;/script&gt; 详细示例，请下载附件，在 HBuilderX 中运行。 示例操作步骤：未登录时，提示去登录。跳转至登录页后，点击“登录”获取用户信息，同步更新状态后，返回到个人中心即可看到信息同步的结果。 注意：对比前面的方式，该方式更加适合处理全局的并且值会发生变化的情况。 注意事项.vue 和 .nvue 并不是一个规范，因此一些在 .vue 中适用的方案并不适用于 .nvue。 Vue 上挂载属性，不能在 .nvue 中使用。 更多关于登录状态的维护，还可以参考 uni-app 的登录模板示例。可以在 github 获取源码，也可以在新建 uni-app 时“从模板创建”选择登录模板。 链接","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"uni-app","slug":"uni-app","permalink":"https://qw8.github.io/tags/uni-app/"},{"name":"小程序","slug":"小程序","permalink":"https://qw8.github.io/tags/小程序/"}]},{"title":"uniapp","slug":"knowledges/uniapp","date":"2023-04-25T10:03:10.000Z","updated":"2024-03-31T16:10:54.000Z","comments":true,"path":"/knowledges/uniapp.html","link":"","permalink":"https://qw8.github.io/knowledges/uniapp.html","excerpt":"","text":"小技巧右击“新建页面“可以直接创建xx文件夹和xx.vue并配置好pages.json，可以自定义模板如下： 123456789101112131415161718192021&lt;template&gt; &lt;view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123;&#125;; &#125;, components: &#123;&#125;, onLoad(options) &#123;&#125;, onShow() &#123;&#125;, methods: &#123;&#125;,&#125;;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt; 小问题 uniapp登录并不会执行App.vue中的onlunch，因为onlunch是进入小程序执行一次，onlunch后才能看到登录页 switch、delete等是关键词，不能用作方法名，不然打死也找不到为什么报错o(╥﹏╥)o 在小程序中尽量避免使用cursor: pointer;会导致点击时会出现淡蓝色背景，打死找不到原因o(╥﹏╥)o 刚配置完pages.json里的页面后跳转该页不显示？在Hbuilder中重新运行一下项目就好了 固定尺寸图标不能只设置宽度用mode=”widthFix”，这样真机首次进入会闪烁（高度拉伸），只能同时设置宽高 微信小程序底部tabBar一般通过switchTab进行跳转，但该api无法传参； 可以使用reLaunch进行跳转，它也可以跳转到tabBar，且可以传参，当然注意它会关闭其他页面 iPhoneX等机型安全区高度都是34 1:style=&quot;&#123; &apos;padding-bottom&apos;: systemInfo.safeAreaInsets.bottom + &apos;px&apos;&#125;&quot; 缺少平台 h5 插件（一定要cnpm安装） 1cnpm install @dcloudio/uni-h5 --save :style 不支持模板字符串如 top:${headerHeight}px 的语法 12345单字符如top可写为:style=&quot;&#123; top: headerHeight + &apos;px&apos; &#125;双字符padding-bottom不加引号会报错，可写为:style=&quot;&#123; &apos;padding-bottom&apos;: safeAreaHeight + &apos;px&apos;, height: calc(100% - navHeight+&apos;px&apos;) &#125;&quot;:style=&quot;&#123;&apos;padding-top&apos;:160+systemInfo.statusBarHeight+&apos;px&apos;,&apos;padding-bottom&apos;:envType===4?&apos;60px&apos;:&apos;0&apos;&#125;&quot; uniapp创建步骤1.新建-项目-选择模板-创建 2.manifest.json中 基础配置-填写名称、描述 web配置-基础路径填“./”，部署H5到相对路径（本地可以打开） 微信小程序配置-填写appid、勾选样式补全和自动压缩 uniapp运行步骤 项目拖动到HBuilderX打开 HBuilderX插件市场安装sass、less 打开微信开发者工具扫码登录（微信开发者平台需要加入项目组），在左上角选择设置 &gt; 安全设置， 开启服务端口即可 HBuilderX打开首页代码，点击“运行”–“运行到小程序模拟器”–“微信开发者工具” 等待微信开发者工具启动，点击项目，等待加载完成即可看到页面 h5：点击“运行”–“运行到浏览器”–“chome” h5打包：点击“发行”–“网站-PC” uniapp公共图片路径封装及使用config.js 1imgUrl: &apos;https://xxx.xxx.com/xxx/images/&apos;, // 服务器图片路径 方法1.使用Vue.prototype，每个页改动代码较少，推荐使用main.js 1234// 返回公共图片路径Vue.prototype.getSrc = function (img) &#123; return Config.imgUrl + img;&#125; 页面中 1&lt;image :src=&quot;getSrc(&apos;account_checked@2x.png&apos;)&quot; /&gt; 方法2.只使用config，缺点：每个页改动代码较多123456789&lt;image :src=&quot;imgUrl+&apos;login-bg@2x.png&apos;&quot;&gt;&lt;/image&gt;import Config from &apos;@/config&apos;data() &#123; return &#123; imgUrl: Config.imgUrl, // 图片地址 &#125; &#125;, success内部不写_this简化代码官网示例 123456uni.removeStorage(&#123; key: &apos;storage_key&apos;, success: function (res) &#123; console.log(&apos;success&apos;); &#125;&#125;); 实际使用因为success函数内部无法获取this.historicalLocation报错，只能let _this = this 1234567let _this = this uni.removeStorage(&#123; key: &apos;historicalLocation&apos;, success(res) &#123; _this.historicalLocation = [] &#125; &#125;) 优化：将success函数改为箭头函数，就不需要再let _this = this了 123456uni.removeStorage(&#123; key: &apos;historicalLocation&apos;, success: (res) =&gt; &#123; this.historicalLocation = [] &#125; &#125;) 很简单，但很实用！官网所有success的函数都可以这样使用。 await可以获取函数返回值123456789async function echo(arg) &#123; return arg;&#125;async function getValue() &#123; const res = await echo(5); console.log(res);&#125;getValue(); uniapp中使用calc计算的坑错误写法： 1height: calc(100vh-100rpx) 正确写法: 1height: calc(100vh - 100rpx) 睁大眼睛找不同，有没有发现在calc中“100vh”和“100rpx”与中间“-”加了个空格，对，就是这么坑，我之前以为uniapp不支持calc计算不同单位呢，后来才发现这个坑。 uni-app 部署 H5 到相对路径（含file协议打开）自 HBuilderX 2.6.6 版本开始，uni-app 支持部署 H5 到相对路径，部署到服务端或在本地（使用file协议）打开均可。 使用方式配置 manifest.json 配置 h5-&gt;router-&gt;base 值为 “./“ 部署到相对路径 注意事项按相对路径发行时路由模式强制为hash模式，不支持history模式（两者相悖）。 uniapp阻止遮罩滚动穿透1234567&lt;view class=&quot;mask&quot; @touchmove.stop.prevent=&quot;moveHandle&quot;&gt;methods:&#123; moveHandle()&#123; return &#125;,&#125; 填入字符不能包含&lt;&gt;/（防止xss攻击）123456789101112131415161718192021222324252627282930//main.js中Vue.prototype.inputFilter = function(text) &#123; // 规则对象(reg) let reg = new RegExp(&quot;[&lt;&gt;/]&quot;) if (reg.test(text)) &#123; uni.showToast(&#123; icon: &apos;none&apos;, duration: 3000, title: &apos;填入字符不能包含&lt;&gt;/&apos; &#125;) return true; &#125; return false;&#125;// 页面中函数内使用// 填入字符不能包含&lt;&gt;/if (this.inputFilter(this.value)) &#123; return false&#125;//如果要验证数组对象中多个值let flag = falsebodyList.forEach(item =&gt; &#123; if (this.inputFilter(item.memo)) &#123; flag = true &#125;&#125;)if (flag) &#123; return&#125; 全屏播放视频123456789101112131415&lt;video id=&quot;myVideo&quot; class=&quot;home_video&quot; loop autoplay show-center-play-btn :src=&quot;articleData.content&quot; :controls=&quot;false&quot; :object-fit=&quot;fit&quot; @loadedmetadata=&quot;getSize&quot;&gt;&lt;/video&gt;data中fit: &apos;fill&apos;, // 默认竖屏播放（填充）// 获取视频宽高时长getSize(e) &#123; const &#123; width, height, duration &#125; = e.detail // 如果宽大于高，横屏播放（包含） if (width &gt; height) &#123; this.fit = &apos;contain&apos; &#125; // console.log(width, height, duration, this.fit)&#125;, 每日登录领红包父组件中 12&lt;!-- 签到弹窗组件 --&gt;&lt;popup v-if=&quot;signIn&quot; :isShowDialog=&quot;isShowDialog&quot; :operation=&quot;operation&quot; @sonClose=&quot;close&quot; @sonReceive=&quot;receive&quot;&gt;&lt;/popup&gt; 弹窗组件中 12345678910111213141516171819202122232425262728methods: &#123; // 关闭弹窗后今日不再提醒 dialogClose() &#123; this.$emit(&quot;sonClose&quot;, false); //其中function为父组件定义函数，param为需要传递参数 try &#123; uni.setStorageSync(&apos;signInDate&apos;, new Date().toLocaleDateString()); &#125; catch (e) &#123; console.log(e) &#125; &#125;, // 登录领取福利 async receive() &#123; const &#123; data &#125; = await signInRedPacket() try &#123; uni.setStorageSync(&apos;signInDate&apos;, new Date().toLocaleDateString()); &#125; catch (e) &#123; console.log(e) &#125; console.log(data) if (data) &#123; this.credit = data.credit; setTimeout(() =&gt; &#123; this.operation = 2; this.$emit(&quot;sonReceive&quot;, this.operation); //其中function为父组件定义函数，param为需要传递参数 &#125;, 100); &#125; &#125;, &#125;, 在App.vue中onLaunch生命周期函数中 123456789101112131415// 每日签到判断everydaySignIn() &#123; try &#123; const signInDate = uni.getStorageSync(&apos;signInDate&apos;); if (signInDate) &#123; const today = new Date().toLocaleDateString() if (today &lt;= signInDate) &#123; console.log(signInDate, today, &quot;不可以签到&quot;); this.$store.commit(&apos;everydaySignIn&apos;, false) &#125; &#125; &#125; catch (e) &#123; console.log(e) &#125;&#125; 防止多次提交或点击123456789101112131415161718if (this.noClick) &#123; // 第一次点击 this.noClick = false; console.log(this.noClick) const res = await saveReceiver(this.form) if (res.code === 0) &#123; uni.navigateBack() &#125; else &#123; uni.showToast(&#123; icon: &apos;none&apos;, title: &apos;添加失败&apos; &#125;) &#125; setTimeout(() =&gt; &#123; this.noClick = true; console.log(this.noClick) &#125;, 2000)&#125; 返回顶部按钮123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template&gt; &lt;view class=&quot;toTop&quot; @tap=&quot;toTop&quot; :style=&quot;&#123;&apos;display&apos;:(flag? &apos;block&apos;:&apos;none&apos;)&#125;&quot;&gt; &lt;image src=&quot;../../static/icon/toTop.png&quot; mode=&quot;widthFix&quot;&gt;&lt;/image&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; flag: false // 是否显示回顶按钮 &#125; &#125;, methods: &#123; // 返回顶部 toTop() &#123; uni.pageScrollTo(&#123; scrollTop: 0 &#125;); &#125;, // 当距离大于800时显示回到顶部按钮 onPageScroll(e) &#123; if (e.scrollTop &gt; 800) &#123; this.flag = true &#125; else &#123; this.flag = false &#125; &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; .toTop &#123; position: fixed; z-index: 999; right: 20rpx; bottom: 200rpx; transition: transform 0.8s ease-in; image &#123; width: 80rpx; &#125; &#125;&lt;/style&gt; 跳转页面传对象12345678910// 传递goSystemNotice(content) &#123; uni.navigateTo(&#123; url: `/pages/message/systemNotice?content=$&#123;JSON.stringify(content)&#125;` &#125;)&#125;// 接收onLoad(option) &#123; this.content = JSON.parse(option.content)&#125; uniapp保存网络图片1234567891011121314151617181920212223242526272829303132333435// 预览长按保存到相册 preview(pic) &#123; uni.previewImage(&#123; urls: [pic], // 长按图片显示操作菜单 longPressActions: &#123; itemList: [&apos;保存图片&apos;], success: (data) =&gt; &#123; //先下载到本地获取临时路径 uni.downloadFile(&#123; url: pic, success: (res) =&gt; &#123; console.log(&apos;下载成功&apos;, res.tempFilePath) //将临时路径保存到相册，即可在相册中查看图片 uni.saveImageToPhotosAlbum(&#123; filePath: res.tempFilePath, //不支持网络地址 success: function() &#123; uni.showToast(&#123; title: &apos;保存图片到相册成功&apos;, position: &apos;bottom&apos; &#125;); &#125; &#125;); &#125;, fail: (err) =&gt; &#123; console.log(&apos;下载失败&apos;, err) &#125; &#125;) &#125;, fail: function(err) &#123; console.log(err.errMsg); &#125; &#125; &#125;) &#125; .gitignore文件忽略提交unpackage包到github仓库（uni-app）pull代码下来，然而unpackage文件一直说有东西重复了，让我删除掉先，应该是同事提交了unpackage包上去了，所以我们就来解决这个问题。 1、要怎么样把远程分支上的unpackage包给删除掉？ 1git rm -r --cached unpackage （本地的目录还在，直接关闭软件删除unpackage目录） 2、要怎么要每次提交都忽略unpackage等文件？ 根目录新建.gitignore文件 然后记事本打开，复制粘贴以下内容进去就完事了 1234node_modules/.projectunpackage/.DS_Store 3、git提交，push一下即可。 uni-app把canvas的px像素使用rpx表示小程序，移动端在设置canvas的位置的时候，因为cnavas默认是px像素，对于位置的设置很不方便，所以要把px转换为用rpx表示 1、获取设备宽度 1const system = uni.getSystemInfoSync() 2、单位换算，算出1rpx = 多少px 1const w = system.windowWidth / 750 3、使用 比如我要设置30rpx，则可以表为 30*w canvas绘制多行文本自动换行123456789101112131415161718192021222324252627/** * 绘制多行文本自动换行 * ctx canvas对象 * text 文本内容 * leftWidth 距离左侧的距离 * initHeight 距离顶部的距离 * textWidth 文本的宽度 */ drawText (text, leftWidth, initHeight, ctx, textWidth) &#123; let lineWidth = 0; let lastSubStrIndex = 0; //每次开始截取的字符串的索引 const rpx = this.windowWidth / 750; for (let i = 0; i &lt; text.length; i++) &#123; lineWidth += ctx.measureText(text[i]).width; //16是一个中文宽度，为了解决偶尔夹有数字或英文时，文字长度超出设置宽度的bug if (lineWidth &gt; textWidth - 16) &#123; ctx.fillText(text.substring(lastSubStrIndex, i + 1), leftWidth, initHeight); //绘制截取部分 initHeight += 48 * rpx; lineWidth = 0; lastSubStrIndex = i + 1; &#125; if (i === text.length - 1) &#123; ctx.fillText(text.substring(lastSubStrIndex, i + 1), leftWidth, initHeight); //绘制剩余部分 &#125; &#125; ctx.fillText(\"谢谢。\", 40 * rpx, initHeight + 48 * rpx); &#125;, canvas设置字间距（真机不生效）、文字加粗1234567891011&lt;canvas class=&quot;my-canvas&quot; canvas-id=&quot;myCanvas&quot; @click=&quot;saveSharePic(&apos;canvas&apos;)&quot;&gt;&lt;/canvas&gt;context.font = &quot;bold 16px PingFangSC-Medium, PingFang SC&quot;;.my-canvas &#123; letter-spacing: 2rpx;&#125; 文字地址使用微信内置地图查看位置1234567891011121314151617181920212223242526272829303132333435363738import Config from &quot;@/config.js&quot;;import QQMapWX from &quot;@/utils/qqmap-wx-jssdk.min.js&quot;//点击查看地址 viewAddress(address) &#123; // 实例化腾讯地图API核心类 const tMap = new QQMapWX(&#123; key: Config.mapKey // 开发者密钥 &#125;); // 调用地址解析接口 tMap.geocoder(&#123; address, //地址参数，例：address: &apos;北京市海淀区彩和坊路海淀西大街74号&apos; success: function(res) &#123; // console.log(res); uni.openLocation(&#123; latitude: res.result.location.lat, // 纬度，范围为-90~90，负数表示南纬 longitude: res.result.location.lng, // 经度，范围为-180~180，负数表示西经 name: res.result.title, // 位置名 address, // 地址的详细说明 scale: 17, // 缩放比例，范围5~18，默认为18 success: function(res)&#123; // success &#125;, fail: function() &#123; // fail &#125;, &#125;) &#125;, fail: function(res) &#123; // console.log(res); uni.showToast(&#123; title: &quot;该地址无法定位&quot;, icon: &quot;none&quot;, duration: 2000 &#125;); &#125; &#125;); &#125;, 在manifest.json中添加以下代码，并在小程序后台申请getLocation权限（审核1-2天） 12345678&quot;mp-weixin&quot; : &#123; &quot;permission&quot; : &#123; &quot;scope.userLocation&quot; : &#123; &quot;desc&quot; : &quot;将获取您的位置信息，用于查看地址功能&quot; &#125; &#125;, &quot;requiredPrivateInfos&quot; : [ &quot;getLocation&quot; ] &#125;, 开启小程序在前后台时均可接收位置消息开发工具需要清除全部缓存，重新编译，才能获取权限 真机需要到小程序设置中位置信息选择“使用小程序时和离开后” 123456789&quot;requiredBackgroundModes&quot;: [ &quot;location&quot; ], &quot;requiredPrivateInfos&quot;: [ &quot;getLocation&quot;, &quot;onLocationChange&quot;, &quot;startLocationUpdate&quot;, &quot;startLocationUpdateBackground&quot; ] js计算两个经纬度点之间距离12345678910111213141516171819202122232425262728293031// 计算两点之间直线距离 algorithm(point1, point2) &#123; let &#123; latitude: x1, longitude: y1 &#125; = point1 let &#123; latitude: x2, longitude: y2 &#125; = point2 console.log(x1, y1, x2, y2) // 纬度 let Lat1 = this.rad(x1) let Lat2 = this.rad(x2) let a = Lat1 - Lat2 // 两点纬度之差 let b = this.rad(y1) - this.rad(y2) // 经度之差 let s = 2 * Math.asin( Math.sqrt( Math.pow(Math.sin(a / 2), 2) + Math.cos(Lat1) * Math.cos(Lat2) * Math.pow(Math.sin(b / 2), 2) ) ) // 计算两点距离的公式 // 弧长等于弧度乘地球半径（半径为米） s = s * 6378137.0 // 精确距离的数值 s = Math.round(s * 10000) / 10000 return s &#125;, // 角度转换成弧度 rad(d) &#123; return (d * Math.PI) / 180.0 &#125;, 自己与腾讯地图分别计算两点距离，8km，自己计算比腾讯多了10m js计算多个经纬度点之间距离12345678910111213141516// 计算实时路径总距离 calculateDistance() &#123; let sum = 0, points = this.points // let points = [ // &#123; latitude: 40.040452, longitude: 116.273486 &#125;, // &#123; latitude: 40.00654, longitude: 116.303695 &#125;, // &#123; latitude: 39.8664564344618, longitude: 116.3070187717014 &#125; // ] if (points.length &gt;= 2) &#123; for (let i = 0; i &lt; points.length - 1; i++) &#123; sum += this.algorithm(points[i], points[i + 1]) &#125; &#125; this.sum = sum &#125;, 小程序地图画路线测试结果北京到深圳2000km，最多10w个点的话，可以设置20m一个点距离：都可以计算，7w多km真机本地存储：最多15185个，石家庄站到喀什站-2次画图，10w个耗时10秒左右，不过存在有性能问题-8次14w个可以画图-12次17w个可以画图-14次（n次表示漠河站到喀什站路径规划，返回值push的循环次数） 比例尺是根据图上距离*比例尺计算实际距离，图上距离和比例尺都无法获取，无法计算实际距离比例尺1:1000000，图上的距离是12.5厘米实际距离12.5cm x 1000000 = 12500000cm = 125000m = 125km 开发工具57980个，setData数据传输长度为 8322KB，8.12MB，存在有性能问题！-5次漠河站到喀什站5898002/3=1966000个数组，腾讯23611个，距离误差15km北京到吕梁672178/3=224059个数组，腾讯3860个 小程序其他样式需覆盖地图根据实际情况，使用position的三个属性。（使用z-index不生效） 123position: relative;position: absolute;position: fixed; 地图选点1234567891011121314151617181920212223&lt;map id=&quot;myMap&quot; :latitude=&quot;location.latitude&quot; :longitude=&quot;location.longitude&quot; scale=&quot;17&quot; show-location @regionchange=&quot;regionchange&quot;&gt;&lt;/map&gt; // 视野发生变化regionchange(e) &#123; console.log(&apos;视野发生变化&apos;, e) if (e.type === &apos;end&apos;) &#123; this.mapCtx.getCenterLocation(&#123; success: (res) =&gt; &#123; console.log(&apos;地图中心的经纬度&apos;, res) this.getAddress(res.latitude, res.longitude) &#125;, fail: (err) =&gt; &#123; console.log(err) &#125; &#125;) &#125;&#125;, 地图高度动态调整123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239 &lt;!-- 地图 --&gt; &lt;map id=&quot;myMap&quot; :latitude=&quot;latitude&quot; :longitude=&quot;longitude&quot; :markers=&quot;markers&quot; :polyline=&quot;polyline&quot; scale=&quot;17&quot; show-location style=&quot;width: 100%;&quot; :style=&quot;&#123; height: mapHeight + &apos;px&apos; &#125;&quot;&gt; &lt;/map&gt; &lt;view :class=&quot;envType === 4?&apos;operation operation-web&apos;:&apos;operation operation-mp&apos;&quot; v-else id=&quot;operation&quot;&gt; &lt;view class=&quot;back&quot; @click=&quot;goBack&quot;&gt; &lt;image class=&quot;back-img&quot; src=&quot;/static/images/index_icon12.png&quot; /&gt; &lt;/view&gt; &lt;view class=&quot;input-area&quot;&gt; &lt;view class=&quot;button&quot; @click=&quot;reverse&quot;&gt; &lt;image src=&quot;/static/images/index_icon1.png&quot; /&gt; &lt;/view&gt; &lt;view class=&quot;input-content&quot;&gt; &lt;view class=&quot;input-item&quot; v-for=&quot;(item, index) in tripList&quot; :key=&quot;index&quot;&gt; &lt;view class=&quot;prefix&quot; v-if=&quot;index === 0&quot;&gt; &lt;view class=&quot;kong&quot;&gt;&lt;/view&gt; &lt;view class=&quot;cricle start&quot;&gt;&lt;/view&gt; &lt;view class=&quot;line&quot;&gt;&lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;prefix&quot; v-else-if=&quot;index === tripList.length - 1&quot;&gt; &lt;view class=&quot;line&quot;&gt;&lt;/view&gt; &lt;view class=&quot;cricle end&quot;&gt;&lt;/view&gt; &lt;view class=&quot;kong&quot;&gt;&lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;prefix&quot; v-else&gt; &lt;view class=&quot;line&quot;&gt;&lt;/view&gt; &lt;view class=&quot;index&quot;&gt;&#123;&#123; index &#125;&#125;&lt;/view&gt; &lt;view class=&quot;line&quot;&gt;&lt;/view&gt; &lt;/view&gt; &lt;view :class=&quot;item ? &apos;input&apos; : &apos;input placeholder&apos;&quot; @click=&quot;onClick&quot; v-if=&quot;index === 0&quot;&gt; &#123;&#123; item?item: &quot;请输入起点&quot; &#125;&#125;&lt;/view&gt; &lt;view :class=&quot;item ? &apos;input&apos; : &apos;input placeholder&apos;&quot; @click=&quot;onClick&quot; v-else-if=&quot;index === tripList.length - 1&quot;&gt;&#123;&#123; item?item: &quot;请输入终点&quot; &#125;&#125;&lt;/view&gt; &lt;view :class=&quot;item ? &apos;input&apos; : &apos;input placeholder&apos;&quot; @click=&quot;onClick&quot; v-else&gt;&#123;&#123; item?item: &quot;请输入途径点&quot; &#125;&#125; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;button&quot; @click=&quot;onClick(1)&quot;&gt; &lt;image src=&quot;/static/images/index_icon2.png&quot; /&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;add-trip&quot; @click=&quot;onClick&quot;&gt;添加行程&lt;/view&gt; &lt;/view&gt; mapHeight: 400, // 地图高度响应式 // 设置地图高度 this.setMapHeight() // 设置地图高度 setMapHeight() &#123; if (this.token &amp;&amp; this.userInfo.travel_type !== 0) &#123; // 设备模式/仪表盘模式/手机GPS模式 this.mapHeight = this.systemInfo.windowHeight &#125; else &#123; const query = uni.createSelectorQuery() query.select(&apos;#operation&apos;).boundingClientRect() query.selectViewport().scrollOffset() query.exec((res) =&gt; &#123; console.log(&apos;操作区dom&apos;, res) if (res[0]) &#123; // 防止切换到设备模式没有操作区dom报错 if (this.envType === 3) &#123; // 钉钉无法隐藏地图水印 this.mapHeight = this.systemInfo.windowHeight - res[0].height &#125; else &#123; // 地图高度=可使用窗口高度-输入框区域高度+地图水印高度 this.mapHeight = this.systemInfo.windowHeight - res[0].height + 22 &#125; console.log( this.systemInfo.windowHeight, res[0].height, this.mapHeight ) &#125; &#125;) &#125; &#125;, // 数组反转 reverse() &#123; this.tripList = this.tripList.reverse() this.$store.commit(&apos;setAddTripList&apos;, this.tripList) console.log(this.tripList) &#125;, // 点击添加行程 onClick: Utils.throttle(function (isAdd) &#123; console.log(&apos;点击事件随机值&apos; + Math.random()) this.addTrip(isAdd) &#125;, 2000), // 添加行程 async addTrip(isAdd) &#123; // 如果点击+号，添加一个途经点 const url = isAdd === 1 ? `/sub_trip/trip/SetTrip?isAdd=$&#123;isAdd&#125;` : &apos;/sub_trip/trip/SetTrip&apos; uni.navigateTo(&#123; url &#125;) &#125;,// pc样式.pc &#123; .operation &#123; .add-trip &#123; width: calc(100% - 16px); &#125; .input-area &#123; .input-content &#123; width: 100%; .input-item .input &#123; width: 100%; &#125; &#125; &#125; &#125;&#125;.operation-web &#123; bottom: 50px;&#125;.operation-mp &#123; bottom: 0;&#125;.operation &#123; width: 100%; min-height: 222rpx; padding: 32rpx; box-sizing: border-box; position: absolute; background: #f5f7fa; box-shadow: 0 0 80rpx 0 rgba(0, 0, 0, 0.08); border-radius: 24rpx 24rpx 0 0; .input-area &#123; border-radius: 16rpx; display: flex; align-items: center; background: #fff; // 扩大点击热区 .button &#123; width: 88rpx; min-height: 88rpx; padding: 0 16rpx; box-sizing: border-box; display: flex; align-items: center; image &#123; width: 40rpx; height: 40rpx; &#125; &#125; .input-content &#123; width: 558rpx; padding: 0 8rpx; box-sizing: border-box; display: flex; flex-direction: column; .input-item &#123; height: 90rpx; display: flex; align-items: center; .input &#123; width: 486rpx; height: 88rpx; line-height: 88rpx; border-bottom: solid 2rpx #f0f2f5; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; &#125; &#125; .kong &#123; width: 2rpx; height: 37rpx; &#125; .line &#123; height: 37rpx; border-left: dashed 2rpx #e6e8eb; box-shadow: 0 0 80rpx 0 rgba(0, 0, 0, 0.08); &#125; .index &#123; width: 24rpx; height: 24rpx; line-height: 24rpx; font-size: 18rpx; border-radius: 50%; text-align: center; color: #fff; background: #c9ccd1; box-shadow: 0 0 80rpx 0 rgba(0, 0, 0, 0.08); &#125; &#125; &#125; .back &#123; /* 去掉水印高度 */ top: -104rpx; &#125; .add-trip &#123; width: 686rpx; margin-top: 32rpx; &#125;&#125; 小程序拖拽排序页面 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;view class=&quot;trip-list&quot;&gt; &lt;!-- 克隆当前拖拽的项 --&gt; &lt;view class=&quot;trip-item kelong&quot; v-if=&quot;showkelong&quot; :style=&quot;&#123; top: top + &apos;px&apos; &#125;&quot;&gt; &lt;view class=&quot;trip-input-area&quot;&gt; &lt;view class=&quot;cricle channel&quot;&gt;&lt;/view&gt; &lt;input v-model=&quot;kelong&quot; placeholder=&quot;请输入地点&quot; /&gt; &lt;image class=&quot;small img&quot; src=&quot;/static/images/index_icon3.png&quot;&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 原来各项 --&gt; &lt;view class=&quot;trip-item&quot; v-for=&quot;(item, index) in tripList&quot; :key=&quot;index&quot;&gt; &lt;view class=&quot;trip-input-area&quot;&gt; &lt;view v-if=&quot;index === 0&quot; class=&quot;cricle start&quot;&gt;&lt;/view&gt; &lt;view v-else-if=&quot;index === tripList.length - 1&quot; class=&quot;cricle end&quot;&gt;&lt;/view&gt; &lt;view v-else class=&quot;cricle channel&quot;&gt;&lt;/view&gt; &lt;input v-if=&quot;index === 0&quot; :value=&quot;item&quot; @input=&quot;getsuggest&quot; @focus=&quot;focus(index)&quot; placeholder=&quot;请输入起点&quot; maxlength=&quot;32&quot; :auto-focus=&quot;autoFocus[0]&quot; /&gt; &lt;input v-else-if=&quot;index === tripList.length - 1&quot; :value=&quot;item&quot; @input=&quot;getsuggest&quot; @focus=&quot;focus(index)&quot; placeholder=&quot;请输入终点&quot; maxlength=&quot;32&quot; :auto-focus=&quot;autoFocus[1]&quot; /&gt; &lt;input v-else :value=&quot;item&quot; @input=&quot;getsuggest&quot; @focus=&quot;focus(index)&quot; placeholder=&quot;请输入途径点&quot; maxlength=&quot;32&quot; /&gt; &lt;!-- 拖拽节点 --&gt; &lt;view class=&quot;drag&quot; :id=&quot;index&quot; @touchstart=&apos;dragStart&apos; @touchmove=&apos;dragMove&apos; @touchend=&apos;dragEnd&apos;&gt; &lt;image class=&quot;small img&quot; src=&quot;/static/images/index_icon3.png&quot;&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;del&quot; v-if=&quot;tripList.length &gt; 2&quot; @click=&quot;delSpot(index)&quot;&gt; &lt;image class=&quot;small &quot; src=&quot;/static/images/index_icon4.png&quot;&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122 kelong: &apos;&apos;, // 当前拖拽项的克隆 mkelong: &#123;&#125;, // 当前拖拽项的克隆(标记点) startTop: 0, //拖拽开始时克隆项距离class=tripList节点顶部边界的值 top: 0, // 当前拖拽项的top selectedIndex: -1, //被选择拖拽的项的index showkelong: false, //是否显示克隆项 // 拖拽开始 dragStart(e) &#123; // 当前拖拽项的索引index let index = e.currentTarget.id // 把当前拖拽项的内容复制给kelong this.kelong = this.tripList[index] this.mkelong = this.markers[index] this.selectedIndex = index this.showkelong = true console.log(&apos;拖拽开始index=&apos;, index, &apos;kelong=&apos;, this.kelong, e) let query = uni.createSelectorQuery() // 创建节点查询器 quer //选择class=tripList的节点，获取节点位置信息的查询请求 query .select(&apos;.trip-list&apos;) .boundingClientRect((rect) =&gt; &#123; console.log(rect) this.top = e.changedTouches[0].clientY - rect.top - 22 this.startTop = this.top &#125;) .exec() &#125;, // 拖拽移动 dragMove(e) &#123; // console.log(&quot;拖拽移动&quot;, e); let query = uni.createSelectorQuery() let top = this.top query .select(&apos;.trip-list&apos;) .boundingClientRect((rect) =&gt; &#123; top = e.changedTouches[0].clientY - rect.top - 22 if (top &lt; 0) &#123; // 顶部边界控制：控制克隆项不会拖拽出class=tripList节点的顶部边界 top = 0 &#125; this.top = top &#125;) .exec() &#125;, // 拖拽结束 dragEnd(e) &#123; console.log(&apos;拖拽结束&apos;, e) let i = e.currentTarget.id let query = uni.createSelectorQuery() let kelong = this.kelong let mkelong = this.mkelong let tripList = this.tripList let markers = this.markers query .select(&apos;.trip-list&apos;) .boundingClientRect((rect) =&gt; &#123; let top = e.changedTouches[0].clientY - rect.top - 22 if (top &gt; rect.height) &#123; // 底部边界控制：控制克隆项拖拽结束时不会出class=tripList节点的底部边界 top = rect.height - 44 &#125; else if (top &lt; 0) &#123; // 顶部边界控制：控制克隆项拖拽结束时不会出class=tripList节点的顶部边界 top = 0 &#125; this.top = top let target = parseInt(top / 44) let list = [] //用于备份数据 let mlist = [] //用于备份数据 if (this.startTop &gt; top) &#123; // 往上方位置拖拽 for (let k = 0; k &lt;= i - target; k++) &#123; // 备份插入位置target开始的下方数据，除了拖拽数据项 if (tripList[target + k] != kelong) &#123; list.push(tripList[target + k]) &#125; if (markers[target + k] != mkelong) &#123; mlist.push(markers[target + k]) &#125; &#125; console.log(&apos;往上拖拽 list=======&apos;, list) if (list.lenghth != 0) &#123; tripList[target] = kelong markers[target] = mkelong for ( let m = target + 1, n = 0; n &lt; list.length; m++, n++ ) &#123; tripList[m] = list[n] markers[m] = mlist[n] &#125; &#125; &#125; else &#123; // 往下边位置拖拽 for (let k = 1; k &lt;= target - i; k++) &#123; // 备份插入位置target开始的上方数据，除了拖拽数据项 if (tripList[i + k] != kelong) &#123; list.push(tripList[i + k]) &#125; if (markers[i + k] != mkelong) &#123; mlist.push(markers[i + k]) &#125; &#125; console.log(&apos;往下拖拽 list=======&apos;, list) if (list.length != 0) &#123; tripList[target] = kelong markers[target] = mkelong for (let m = i, n = 0; n &lt; list.length; m++, n++) &#123; tripList[m] = list[n] markers[m] = mlist[n] &#125; &#125; &#125; console.log(tripList, markers) this.tripList = tripList this.markers = markers this.selectedIndex = -1 this.showkelong = false &#125;) .exec() &#125; css 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283.trip-list &#123; position: relative; .trip-item &#123; margin: 0rpx auto; width: 100%; /* height: 60px; */ height: 44px; background-color: #fff; position: relative; display: flex; align-items: center; .trip-input-area &#123; width: 526rpx; height: 80rpx; padding-left: 16rpx; margin: 4rpx 0; box-sizing: border-box; border-radius: 8rpx; display: flex; align-items: center; position: relative; background: #f5f7fa; border: solid 1rpx #f0f2f5; .cricle &#123; width: 16rpx; height: 16rpx; margin-right: 16rpx; border-radius: 50%; box-shadow: 0 0 80rpx 0 rgba(0, 0, 0, 0.08); &#125; .start &#123; background: #00cc88; border: solid 2rpx #00cc88; &#125; .channel &#123; background: #c9ccd1; border: solid 2rpx #c9ccd1; &#125; .end &#123; background: #f25041; border: solid 2rpx #f25041; &#125; input &#123; width: 420rpx; background: #f5f7fa; &#125; .drag &#123; width: 40rpx; height: 56rpx; /* 为了扩大可拖拽区域 */ padding: 16rpx 16rpx 16rpx 0; &#125; .small &#123; width: 24rpx; height: 24rpx; &#125; .img &#123; position: absolute; right: 16rpx; top: 28rpx; z-index: 2; &#125; &#125; // 扩大点击热区 .del &#123; height: 44px; padding-left: 24rpx; display: flex; align-items: center; &#125; &#125; .kelong &#123; width: 526rpx; height: 80rpx; background: #f5f7fa; z-index: 99; position: absolute; box-shadow: 1px 1px 5px #ccc; .trip-input-area &#123; border: 0; &#125; &#125;&#125; uniapp小程序用deep重写组件样式不生效deep只在h5中生效，但是在小程序中不生效 解决办法：在method同级下添加： methods: { }, options: { styleIsolation: &apos;shared&apos; }然后再使用deep就可以了，如： /deep/ .u-modal__title { color: red }去掉按钮默认边框1234button::after &#123; border: none; outline: none;&#125; input组件样式问题 input组件placeholder-class样式未生效， 123456/deep/.placeholder &#123; color: #b0b3b8 !important;&#125;/deep/.err &#123; color: #f25041 !important;&#125; input字体大小及样式修改（直接在input里写font-size不生效） 1234567891011121314151617&lt;view class=&quot;alert&quot;&gt; &lt;input v-model=&quot;formData.imei&quot; placeholder-class=&quot;placeholder&quot; placeholder=&quot;请输入设备号&quot; /&gt;&lt;/view&gt;.alert &#123; font-size: 28rpx; input &#123; padding: 16rpx; border-radius: 8rpx; background: #f5f7fa; &#125; /deep/ .placeholder &#123; font-size: 28rpx !important; &#125;&#125; v-for循环将index带入class属性中使用绑定数组写法 123&lt;view :class=&quot;[&apos;item&apos;, `img$&#123;index + 1&#125;`]&quot; v-for=&quot;(item,index) in list&quot; :key=&quot;item&quot; @click=&quot;previewImage(index)&quot;&gt; &lt;image :src=&quot;item&quot; mode=&quot;widthFix&quot;&gt;&lt;/image&gt;&lt;/view&gt; 自定义导航优点：样式和功能可以自定义，文字可居中（官方居左） 123456789101112131415161718// 页面级别使用&#123; &quot;path&quot;: &quot;file_detail/file_detail&quot;, &quot;style&quot;: &#123; &quot;navigationBarTitleText&quot;: &quot;文件详情&quot;, &quot;navigationBarTextStyle&quot;: &quot;black&quot;, &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;, &quot;navigationStyle&quot;: &quot;custom&quot; &#125;&#125;// 全局使用&quot;globalStyle&quot;: &#123; &quot;navigationBarTextStyle&quot;: &quot;white&quot;, &quot;navigationBarTitleText&quot;: &quot;首页&quot;, &quot;navigationBarBackgroundColor&quot;: &quot;#287eff&quot;, &quot;backgroundColor&quot;: &quot;#F8F8F8&quot;, &quot;navigationStyle&quot;: &quot;custom&quot; //导航栏样式，仅支持 default/custom。&#125;, 官方原生的效果肯定比较好好，全局使用自定义导航不太好 比如：页面多了的话，每个页面都需要写导航组件，代码重复；滚动条通顶；塌陷的高度还需要额外处理等缺点。 getSavedFileList返回fileList为空wx.getSavedFileList() 是获取【缓存文件】，而 saveFile 存文件操作的是【用户文件】，这是两个不同的文件区划。 https://developers.weixin.qq.com/miniprogram/dev/framework/ability/file-system.html img 所以应该访问【用户文件】 12let fs = wx.getFileSystemManager()fs.readdir(wx.env.USER_DATA_PATH) 小程序使用downloadFile和saveFile()保存文件在本机找不到文件？downloadFile和saveFile调用成功后返回的地址都是以wxfile://开头的，这是微信自己的内部存储空间。但是android是可以在本地查询到的： 1内部存储/Android/data/com.tencent.mm/MicroMsg/wxanewfiles/***/文件名， 中间那个***·是个长字符串，不知道是什么规则生成的；ios是无法查询到具体的文件的。 文件下载123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143&lt;view class=&quot;item&quot; @click=&quot;download&quot; v-if=&quot;!isDownload&quot;&gt; &lt;image src=&quot;/static/img/icon_download@3x.png&quot; mode=&quot;widthFix&quot;&gt;&lt;/image&gt; &lt;text&gt;下载&lt;/text&gt;&lt;/view&gt;&lt;view class=&quot;item&quot; @click=&quot;viewFile&quot; v-if=&quot;isDownload&quot;&gt; &lt;image src=&quot;/static/img/icon_downloaded@3x.png&quot; mode=&quot;widthFix&quot;&gt;&lt;/image&gt; &lt;text&gt;已下载&lt;/text&gt;&lt;/view&gt; data() &#123; return &#123; fs: null, // 文件管理器 filePath: `$&#123;wx.env.USER_DATA_PATH&#125;/my/2021_PDF.pdf`, // 文件存放路径 isDownload: false, // 该文件是否已下载 &#125;; &#125;, onLoad(options) &#123; console.log(options); // 获取FileSystemManger的全局唯一文件管理器 this.fs = uni.getFileSystemManager(); this.judgeDownload(); &#125;, // 判断文件是否已下载 judgeDownload() &#123; const _this = this; // 检查本地文件夹是否存在 this.fs.access(&#123; path: `$&#123;wx.env.USER_DATA_PATH&#125;/my`, success(res) &#123; console.log(&quot;有my文件夹&quot;, res); // 检查本地该文件是否存在 _this.fs.access(&#123; path: _this.filePath, success(res) &#123; console.log(&quot;有该文件&quot;, res); _this.isDownload = true; &#125;, fail(err) &#123; console.log(&quot;没有该文件&quot;, err); &#125;, &#125;); // 文件列表中可以用这个判断 // _this.fs.readdir(&#123; // dirPath: `$&#123;wx.env.USER_DATA_PATH&#125;/my`, // success(res) &#123; // console.log(res, &quot;用户本地my目录文件列表&quot;); // &#125;, // fail(res) &#123; // console.error(res); // &#125;, // &#125;); &#125;, fail(err) &#123; console.log(&quot;没my有文件夹&quot;, err); // 不存在执行创建文件夹，便于后续下载 _this.mkdir(); &#125;, &#125;); console.log(wx.env.USER_DATA_PATH); &#125;, // 创建文件夹，便于区分本小程序下载的文件 mkdir() &#123; this.fs.mkdir(&#123; dirPath: `$&#123;wx.env.USER_DATA_PATH&#125;/my`, success(res) &#123; console.log(&quot;创建文件夹成功&quot;, res); &#125;, fail(err) &#123; console.log(&quot;创建文件夹失败&quot;, err); &#125;, &#125;); &#125;, // 下载文件 download() &#123; const downloadTask = uni.downloadFile(&#123; url: &quot;http://www.gov.cn/zhengce/pdfFile/2021_PDF.pdf&quot;, success: (res) =&gt; &#123; console.log(res); if (res.statusCode === 200) &#123; uni.showToast(&#123; title: &quot;下载成功&quot;, icon: &quot;none&quot;, &#125;); console.log(res.tempFilePath); // res.filePath和res.tempFilePath路径一致，这样做是为了防止IOS中报错：No tempFilePath const tempFilePath = res.tempFilePath || res.filePath; this.fs.saveFile(&#123; tempFilePath, // 临时文件保存到用户本地并且重命名，不加文件名的话会导致下载的文件没有后缀打不开 filePath: this.filePath, success: (res) =&gt; &#123; console.log(res, &quot;本地路径&quot;); this.isDownload = true; // 下载后跳转查看 this.viewFile(); &#125;, fail: (res) =&gt; &#123; console.log(res); &#125;, &#125;); &#125; &#125;, fail: (res) =&gt; &#123; uni.showToast(&#123; title: &quot;下载失败，请重试&quot;, icon: &quot;none&quot;, duration: 2000, &#125;); console.log(res); &#125;, // 接口调用结束 complete: () =&gt; &#123; // 关闭进度提示 uni.hideLoading(); // 取消监听加载进度 downloadTask.offProgressUpdate(); &#125;, &#125;); downloadTask.onProgressUpdate((res) =&gt; &#123; console.log(&quot;下载进度&quot; + res.progress); uni.showLoading(&#123; mask: true, // 显示透明蒙层，防止触摸穿透 title: &quot;下载中...&quot; + res.progress + &quot;%&quot;, &#125;); // console.log(&quot;已经下载的数据长度&quot; + res.totalBytesWritten); // console.log( // &quot;预期需要下载的数据总长度&quot; + res.totalBytesExpectedToWrite // ); &#125;); &#125;, // 查看原文件 viewFile() &#123; uni.openDocument(&#123; filePath: this.filePath, showMenu: true, success: (res) =&gt; &#123; console.log(&quot;打开文档成功&quot;, res); &#125;, &#125;); &#125;, 小bug： 文件下载名称不能过长，官方会提示太长导致下载失败；不超过80字可以正常下载，90字就下载失败了 关闭console调试下载失败问题：需要在小程序后台配置downloadFile合法域名（测试、正式两个地址） 微信小程序预览文件123456789101112131415161718192021222324252627// 微信小程序预览文件 openDocument(url) &#123; uni.downloadFile(&#123; url, // 要预览的PDF的地址 // 保存到用户本地并且重命名，不加文件名的话会导致下载的文件没有后缀打不开 filePath: `$&#123;wx.env.USER_DATA_PATH&#125;/$&#123;this.protoName&#125;.pdf`, // 文件存放路径 success(res) &#123; console.log(res) if (res.statusCode === 200) &#123; // 成功 uni.openDocument(&#123; filePath: res.filePath, // 要打开的文件路径 showMenu: true, // 是否显示右上角菜单 success(res) &#123; // console.log(&quot;打开成功&quot;); &#125;, fail(res) &#123; // console.log(&quot;打开失败&quot;); &#125; &#125;) &#125; &#125;, fail(res) &#123; console.log(res) //失败 &#125; &#125;) &#125;, uniapp 子组件监听页面onShowuniapp 开发的时候，需要子组件监听onShow事件，但是子组件没有办法直接监听onShow，我们可以通过页面监听，当页面监听到以后发送通知，子组件监听通知，收到通知后触发事件就可以了。 页面代码 12345678onShow() &#123; // 触发全局的自定义事件，用于子组件监听onShow uni.$emit(&apos;onShow&apos;, 1);&#125;,//触底监听onReachBottom() &#123; uni.$emit(&apos;onReachBottom&apos;, 1);&#125;, 子组件监听 1234567891011121314mounted() &#123; // 监听主页面onShow事件 uni.$on(&apos;onShow&apos;, function(data) &#123; console.log(data); &#125;); uni.$on(&apos;onReachBottom&apos;, function(data) &#123; console.log(data); &#125;);&#125;// 为了避免重复监听，在组件销毁前，关闭监听beforeDestroy()&#123; uni.$off(&apos;onReachBottom&apos;) uni.$off(&apos;onShow&apos;)&#125;, 组件中从本地目录文件判断列表文件是否已下载123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657mounted() &#123; // 获取FileSystemManger的全局唯一文件管理器 this.fs = uni.getFileSystemManager(); // 首次监听不到onShow，所以需调用一次 this.readdir() const _that = this; // 监听主页面onShow事件 uni.$on(&apos;onShow&apos;, function(data) &#123; console.log(data); // 如果用户切换到文件管理去删除文件或目录，也能实时判断 _that.readdir() &#125;);&#125;beforeDestroy()&#123; // 为了避免重复监听，在组件销毁前，关闭监听 uni.$off(&apos;onShow&apos;)&#125;,// 读取本地目录内文件列表 readdir()&#123; const _this = this this.fs.readdir(&#123; dirPath: `$&#123;wx.env.USER_DATA_PATH&#125;/my`, success(res) &#123; console.log(res, &quot;用户本地my目录文件列表&quot;); _this.downloadFiles = res.files _this.judgeDownload() &#125;, fail(res) &#123; console.error(res); &#125;, &#125;); &#125;, // 判断文件是否已下载(首次data为空不影响，第一次获取到数据，查看更多时只判断新加载的数据，onShow触发时重新实时判断) judgeDownload(data = this.profileList) &#123; data.forEach(item =&gt; &#123; let res = this.downloadFiles.find( it =&gt; it === item.title) console.log(res) if(res)&#123; item.isDown = true &#125; else &#123; // 避免本地删除后不更新状态 item.isDown = false &#125; &#125;); // 下面这种看似正常，但在else时存在问题，记录一下（有bug禁用） this.downloadFiles.forEach(item =&gt; &#123; data.forEach(it =&gt; &#123; if(item === it.title)&#123; it.isDown = true &#125; else &#123; // 避免本地删除后不更新状态 it.isDown = false &#125; &#125;); &#125;); &#125;, JS中find方法 find() 方法返回通过测试（函数内判断）的数组的第一个元素的值。 如果没有符合条件的元素返回 undefined find() 对于空数组，函数是不会执行的。 find() 并没有改变数组的原始值。 array.find(function(currentValue, index, arr),thisValue)，其中currentValue为当前项，index为当前索引，arr为当前数组 123456let test = [1, 2, 3, 4, 5];let a = test.find(item =&gt; item &gt; 3);console.log(a); //4 let b = test.find(item =&gt; item == 0);console.log(b); //undefined 小程序onShareTimeline()分享朋友圈只写onShareTimeline不生效，有点坑，有两种方法： 1.onLoad或者onReady中使用wx.showShareMenu，必须两个菜单都写上朋友圈才生效 2.写个onShareAppMessage空函数里面啥也不写也行 12345678910111213141516171819202122232425 data:&#123; &#125;, // 生命周期函数--监听页面加载 onLoad: function(options) &#123; // 要先在这里设置menus的两个参数,才可以分享朋友圈 wx.showShareMenu(&#123; withShareTicket: true, menus: [&apos;shareAppMessage&apos;, &apos;shareTimeline&apos;] &#125;) &#125;, // 用户点击右上角分享给好友 onShareAppMessage: function() &#123; &#125;, // 用户点击右上角分享朋友圈 onShareTimeline: function () &#123; return &#123; title: &apos;&apos;, query: &#123; key: value &#125;, imageUrl: &apos;&apos; &#125; &#125;,&#125;) 无法通过自己的按钮触发“分享到朋友圈”和“收藏”转发到朋友圈、收藏到微信收藏 只能通过点击右上角三个点操作，无法通过自己写的按钮触发，可以用类似于分享到企微的引导弹窗实现 不过可以监听右上角菜单“分享到朋友圈”、“收藏”按钮的点击行为，并可以自定义标题和图片https://developers.weixin.qq.com/community/develop/doc/0002c42d65c4401925cef764c58c00 标签切换常规写法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;view class=&quot;tags-list&quot;&gt; &lt;view :class=&quot;item.checked?&apos;active tags-item&apos;:&apos;tags-item&apos;&quot; v-for=&quot;(item,index) in tagsList&quot; :key=&quot;item.name&quot; @click=&quot;switchTags(index)&quot;&gt;&#123;&#123; item.name &#125;&#125; &lt;/view&gt; &lt;/view&gt; tagsList: [ &#123; name: &quot;全部&quot;, checked: true, &#125;, &#123; name: &quot;分类1&quot;, checked: false, &#125;, &#123; name: &quot;分类2&quot;, checked: false, &#125;, &#123; name: &quot;分类3&quot;, checked: false, &#125;, ], // 切换分类 switchTags(ind) &#123; // 重新判断是否选中 this.tagsList.forEach((item, index) =&gt; &#123; item.checked = false; if (ind === index) &#123; item.checked = true; &#125; &#125;); if (ind === 0) &#123; console.log(ind); &#125; &#125;, .active &#123; font-weight: bold; position: relative; transition: all 0.2s; &#125; .active::after &#123; content: &quot;&quot;; width: 62.5%; height: 6rpx; border-radius: 3rpx; position: absolute; left: 18.75%; // 50-62.5/2 bottom: 0; background: #247bff; &#125; 通过selectedIndex来控制选中项更加简单： 1234567891011121314151617181920212223242526272829&lt;view class=&quot;tags-list&quot;&gt; &lt;view :class=&quot;checked===index?&apos;active tags-item&apos;:&apos;tags-item&apos;&quot; v-for=&quot;(item,index) in tagsList&quot; :key=&quot;item.name&quot; @click=&quot;switchTags(index)&quot;&gt;&#123;&#123; item.name &#125;&#125; &lt;/view&gt; &lt;/view&gt; // 分类列表 tagsList: [ &#123; name: &quot;全部&quot;, &#125;, &#123; name: &quot;分类1&quot;, &#125;, &#123; name: &quot;分类2&quot;, &#125;, &#123; name: &quot;分类3&quot;, &#125;, ], checked: 0, // 选中项 // 切换分类 switchTags(index) &#123; this.checked = index; // 选中当前项 if (index === 0) &#123; console.log(index); &#125; &#125;, 搜索历史保存123456789101112131415// 点击完成按钮时触发 confirm() &#123; console.log(this.value, this.historicalFiles); // 如果缓存中有此记录，就先删除再加入 this.historicalFiles.forEach((item, index) =&gt; &#123; if (item === this.value) &#123; this.historicalFiles.splice(index, 1); &#125; &#125;); this.historicalFiles.unshift(this.value); if (this.historicalFiles.length &gt;= 15) &#123; this.historicalFiles.length = 15; // 限制数组长度 &#125; this.$store.commit(&quot;setHistoricalFiles&quot;, this.historicalFiles); &#125;, 图片懒加载我们在用 uni-app 开发微信小程序时，一般都离不开图片组件 image，如果图片多的时候，为了提升用户体验，都会做懒加载处理。那么，我们应该如何实现图片懒加载呢？ 通过查看 uni-app 相关文档 和 微信小程序相关文档，有如下属性： 属性名 类型 默认值 说明 lazy-load Boolean false 图片懒加载，在即将进入一定范围（上下三屏）时才开始加载 因此，我们只需在 image 属性中增加该属性就可以了，具体如下： 1&lt;image lazy-load :src=&quot;item.pic&quot; /&gt; 小伙伴们可能会感觉加入 lazy-load 属性后，好像懒加载没有生效。其实这只是个错觉，因为按文档所述，小程序会提前加载上下三屏的图片，导致无法感知懒加载的存在。其实 image 组件还有个如下隐藏的属性，官方文档里面没有标出来（可以在开发文档搜索“image 组件支持设置预加载屏数”查看） 默认情况下， image 组件 lazy-load 的阈值是 2 屏，也就是当图片距当前屏幕边界为 2 屏之外，图片会马上加载。不同场景可能对该阈值有不同要求，因此计划新增一个属性可以设置该阈值。文档没更新，但是可以使用了。 lazy-load-margin 值指代阈值，如lazy-load-margin=”0.5”，是距离视口0.5屏时再开始加载资源 属性名 类型 默认值 说明 lazy-load-margin Number — 图片懒加载屏数阈值，在即将进入设置的屏数才开始加载 为了能更清楚的确认懒加载是否生效，我们通过将 lazy-load-margin 设置为 0，再看效果，代码如下： 123456&lt;image :src=&quot;item&quot; mode=&quot;widthFix&quot; lazy-load=&quot;true&quot; lazy-load-margin=&quot;0&quot; @load=&quot;load&quot;&gt;&lt;/image&gt;// 只需查看本事件触发即可知道image的加载情况load(e) &#123; console.log(e);&#125;, 通过设置 lazy-load-margin，并结合 微信开发者工具 调试器中的 Network，我们可以很清楚的观察到懒加载的效果了。 另外，可以通过 lazy-load-margin 灵活设置懒加载屏数阈值。 注意：图片懒加载只针对 page 与 scroll-view 下的 image 有效。 所有的注册页面讲道理都在page 之下，注意这个是注册页面，而不是组件等。不过通常情况下组件也会在页面上被使用，里面的image自然也会在page之下 关键词精准匹配高亮123456789101112131415161718192021222324252627/** * 关键词精准匹配高亮 * @param &#123;String&#125; keyword 关键词 * @param &#123;String&#125; target 原数据 * */utils.highLight = (keyword, target) =&gt; &#123; const reg1 = new RegExp(&quot;-&quot;, &quot;gi&quot;); const keywords = keyword.replace(reg1, &quot;\\\\-&quot;) const reg = new RegExp(keywords, &quot;gi&quot;); // 对原数据中的每一项都做正则匹配，得到高亮之后的字符串 const hLight = target.replace( reg, (val) =&gt; `&lt;span style=&quot;color:#FEAA00&quot;&gt;$&#123;val&#125;&lt;/span&gt;` ) return hLight&#125;computed: &#123; // 精准匹配 highLight() &#123; return (data) =&gt; &#123; return utils.highLight(this.keyword, data); &#125;; &#125;, &#125;, &lt;view class=&quot;name&quot; v-html=&quot;highLight(item.title)&quot;&gt;&lt;/view&gt; uniapp获取元素高度在页面渲染完成OnReady回调，获取元素高度时，如果不加定时器，获取的元素的高度还是没渲染完异步数据前的高度。故需要加定时器 12345678910111213141516171819202122232425&lt;view class=&quot;list&quot;&gt; &lt;view :class=&quot;[&apos;item&apos;, `img$&#123;index&#125;`]&quot; v-for=&quot;(item,index) in list&quot; :key=&quot;item&quot; @click=&quot;previewImage(index)&quot;&gt; &lt;image :src=&quot;item&quot; mode=&quot;widthFix&quot; lazy-load=&quot;true&quot; lazy-load-margin=&quot;1&quot; @load=&quot;load&quot;&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; // 初始化数据 init() &#123; // 获取数据后再调用 this.getImageHeight(); &#125;, // 获取第一个图片所在元素的高度，用于页码计算 getImageHeight() &#123; // 加延时才能获取到实际的高度 setTimeout(() =&gt; &#123; const query = uni.createSelectorQuery(); query .select(&quot;.img0&quot;) .boundingClientRect((res) =&gt; &#123; this.imageHeight = res.height; console.log(res, &quot;第一个图片&quot;); &#125;) .exec(); &#125;, 500); &#125;, 滚动到指定元素123456789// 点击目录将页面滚动到对应位置 pageScrollTo(index) &#123; this.isShowCatalogue = false; uni.pageScrollTo(&#123; selector: &quot;.img&quot; + index, // 状态栏+导航栏+头部固定区域的高度为偏移量 offsetTop: -this.headerHeight - 80, &#125;); &#125;, 监听用户滑动页面事件，判断当前页码第一种：整页所有图片高度一样可以使用 12345678// 监听用户滑动页面事件，判断当前页码 onPageScroll(e) &#123; if (e.scrollTop &gt; 0) &#123; // 小数向上取整 + this.headerHeight + 80 this.currentPage = Math.ceil((e.scrollTop + 80) / this.imageHeight); &#125; console.log(e, this.imageHeight, this.currentPage); &#125;, Math.ceil() 函数总是四舍五入并返回大于等于给定数字的最小整数。 1234567891011console.log(Math.ceil(.95));// expected output: 1console.log(Math.ceil(4));// expected output: 4console.log(Math.ceil(7.004));// expected output: 8console.log(Math.ceil(-7.004));// expected output: -7 第二种：尝试用循环获取元素高度，因为图片并没有都加载完，后面获取到的高度都一样，以失败告终 123456789101112131415161718192021// 加延时才能获取到实际的高度setTimeout(() =&gt; &#123; this.getImageHeight();&#125;, 500); // 获取第一个图片所在元素的高度，用于页码计算async getImageHeight() &#123; for (let i = 0; i &lt; this.list.length; i++) &#123; const query = uni.createSelectorQuery(); let start, end; await query .select(&quot;.img&quot; + i) .boundingClientRect(async (res) =&gt; &#123; start = i &gt; 0 ? this.imageHeight[i - 1].end : 0; end = res.height; this.imageHeight.push(&#123; start, end &#125;); console.log(res, &quot;图片高度&quot; + i, this.imageHeight); &#125;) .exec(); &#125;&#125;, 最终版：通过load触发（思路：循环获取图片每一个top(可用load)，存一个数组里，依次精确计算当前页码。） 1234567891011121314151617181920212223242526272829303132333435363738394041424344 screenWidth: getApp().globalData.screenWidth, // 屏幕实际宽度 list: [], imageHeight: [], // 图片高度 scrollTop: 0, computed: &#123; // 当前页码 currentPage() &#123; let page; this.imageHeight.forEach((item, index) =&gt; &#123; if ( this.scrollTop &gt;= item.start &amp;&amp; this.scrollTop &lt;= item.end ) &#123; page = index + 1; &#125; &#125;); return page; &#125;, &#125;, // 监听用户滑动页面事件，判断当前页码 onPageScroll(e) &#123; this.scrollTop = e.scrollTop; console.log(e, this.currentPage); &#125;, // 只需查看本事件触发即可知道image的加载情况 load(e) &#123; console.log(e); // 宽高比=宽/高=屏幕宽/实际高 const height = this.screenWidth / (e.detail.width / e.detail.height); let start, end; if (this.imageHeight.length === 0) &#123; start = 0; end = height; &#125; else &#123; start = this.imageHeight[this.imageHeight.length - 1].end; end = start + height; &#125; this.imageHeight.push(&#123; start, end &#125;); console.log(&quot;图片高度&quot; + height, start, end, this.imageHeight); &#125;, 微信小程序单独设置右上角胶囊颜色1234567&#123; &quot;path&quot;: &quot;index/index&quot;, &quot;style&quot;: &#123; &quot;navigationBarTitleText&quot;: &quot;首页&quot;, &quot;navigationBarTextStyle&quot;: &quot;black&quot; // white默认透明色、black白色 &#125;&#125; 判断是在朋友圈打开场景值1154：朋友圈内打开“单页模式” https://blog.csdn.net/aa2528877987/article/details/123127466 分包机制在这里指的是小程序分包机制，当我们每次打开小程序会发现有的小程序打开的很快，有些很慢，甚至白屏时间很长。原因是包代码量大小的问题。第一次进入小程序的时候，小程序会下载主包代码，如果我们的主包业务代码越多，那么白屏的时间也会越长。 小程序有个机制是在小程序启动时，默认会下载主包并启动主包内页面，当用户进入分包内某个页面时，客户端会把对应分包下载下来，下载完成后再进行展示。因此我们不能把所有代码都放在主页面里面。我们把次级页面放到分包里面。 在构建小程序分包项目时，通常会创建一个或多个分包。每个使用分包小程序必定含有一个主包。所谓的主包，即放置默认启动页面 TabBar 页面，以及一些所有分包都需用到公共资源（css，js，image）；而分包则是根据开发者的配置进行划分。 某些情况下，开发者需要将小程序划分成不同的子包，在构建时打包成不同的分包，用户在使用时按需进行加载。在 pages.json 我们需要 subPackages 管理次级页面的路由： 12345678910111213141516// pages.json&quot;pages&quot;: [],&quot;subPackages&quot;: [ &#123; &quot;root&quot;: &quot;pages/subpages/index&quot;, // 分包根目录 &quot;pages&quot;: [&#123; &quot;path&quot;: &quot;album&quot;, // 配置页面路径 &quot;style&quot;: &#123; &quot;navigationBarTitleText&quot;: &quot;歌单&quot;, &quot;app-plus&quot;: &#123; &quot;titleNView&quot;: false &#125; &#125; &#125;] &#125;], 分包里面的 pages 与主包的 pages 页面组成保持一致。对小程序进行分包，可以优化小程序首次启动的下载时间，以及在多团队共同开发时可以更好的解耦协作。 小程序自动更新1234567891011121314151617181920212223242526272829303132getUpdateInfo() &#123; // 小程序自动更新 if (uni.canIUse(&apos;getUpdateManager&apos;)) &#123; const updateManager = uni.getUpdateManager() updateManager.onCheckForUpdate(function (res) &#123; // 请求完新版本信息的回调 if (res.hasUpdate) &#123; updateManager.onUpdateReady(function () &#123; uni.showModal(&#123; title: &apos;更新提示&apos;, content: &apos;新版本已经准备好，是否重启应用？&apos;, showCancel: false, success: function (res) &#123; if (res.confirm) &#123; // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启 updateManager.applyUpdate() &#125; &#125; &#125;) &#125;) updateManager.onUpdateFailed(function () &#123; // 新的版本下载失败 uni.showModal(&#123; title: &apos;已经有新版本了哟~&apos;, content: &apos;新版本已经上线啦~，请您删除当前小程序，重新搜索打开哟~&apos; &#125;) &#125;) &#125; &#125;) &#125; &#125;, uniapp request中post传递数组值的时候，数组没有正确的被传递问题：前端传数组，后端接收到是字符串 1234567891011uni.request(&#123; method: &apos;POST&apos;, header: &#123; &apos;content-type&apos;: &apos;application/x-www-form-urlencoded&apos;, &#125;, dataType: &apos;json&apos;, url: &apos;http://api.cn&apos;, data: &#123; a: [1,2] &#125;&#125;) ‘content-type’换成 application/json即可解决 自定义导航栏透明渐变色pages.json设置自定义custom 1234567 &#123; &quot;path&quot;: &quot;pages/index/index&quot;, &quot;style&quot;: &#123; &quot;navigationBarTitleText&quot;: &quot;秀企车&quot;, &quot;navigationStyle&quot;: &quot;custom&quot; &#125;&#125; 首页 12345678910111213141516171819202122232425&lt;!-- 自定义导航栏 --&gt;&lt;view class=&quot;navbar&quot; v-if=&quot;envType !== 3&quot; :style=&quot;&#123; &apos;padding-top&apos;: systemInfo.statusBarHeight + 13 + &apos;px&apos; &#125;&quot;&gt;首页自定义标题&lt;/view&gt;.page &#123; width: 100vw; height: 100vh; position: relative;&#125;.navbar &#123; width: 100%; padding: 26rpx 0; position: absolute; top: 0; left: 0; z-index: 999; text-align: center; background-image: linear-gradient(#ffffff, transparent); // 白-&gt;透明（上到下）&#125;// 透明-&gt;白（上到下）background: linear-gradient( 180deg, rgba(255, 255, 255, 0) 0%, #ffffff 100%); 页面最小高度各平台保持一致由于在H5中，页面区域是标题栏下方部分，设置为100vh会导致页面滚动，所以应该区分设置。 123456789.page &#123; // #ifdef H5 height: 100%; // #endif // #ifndef H5 min-height: 100vh; // #endif background: #fff;&#125; 节流函数（防止重复提交）12345678910111213141516171819202122232425262728293031// 节流const throttle = (fn, wait) =&gt; &#123; let delay = wait || 500 // 不传默认500毫秒 let timer = +new Date() // 声明初始时间 return function (...arg) &#123; // 获取参数 let newTimer = +new Date() // 获取触发事件的时间 console.log(timer, newTimer) if (newTimer - timer &gt;= delay) &#123; // 时间判断,是否满足条件 fn.apply(this, arg) // 调用需要执行的函数,修改this值,并且传入参数 timer = +new Date() // 重置初始时间 &#125; &#125;&#125;// 类似上一种const throttle1 = function (func, delay) &#123; var prev = Date.now() return function () &#123; var context = this; var args = arguments; var now = Date.now(); console.log(prev, now) if (now - prev &gt;= delay) &#123; func.apply(context, args); prev = Date.now(); &#125; &#125;&#125;module.exports = &#123; throttle&#125; 页面中使用 1234567891011121314151617181920import Utils from &quot;@/utils/index&quot;;// 调用不成功示例 onClick1() &#123; Utils.throttle(this.submit1(), 1000) &#125;, submit1() &#123; console.log(&quot;点击事件随机值&quot; + Math.random()) &#125;, // 点击提交按钮（成功示例） onClick: Utils.throttle(function () &#123; console.log(&quot;点击事件随机值&quot; + Math.random()) this.submit() &#125;, 2000), // 提交数据 async submit() &#123; ... const res = await $http.addTripApi(this.formModel) ... &#125; 思路2. 前端：不允许二次或多次点击1.例如使用：wx.showToast，wx.showLoading 弹出提示框，提示框显示xx秒，提示框显示期间无法再操作 通俗讲，就是弹出屏蔽层，防止用户第二次点击 2.例如使用：hidden 或者 disable 或者 wx:if 点击一次后，立即禁用或隐藏按钮 此方法可能存在的问题：在弹出提示框前已经点击了多次 uniapp弹窗蒙层禁止滚动穿透滚动底层页面1234567// 弹窗蒙层&lt;view class=&quot;alert-bg&quot; v-if=&quot;isShow&quot; catchtouchmove=&apos;true&apos;&gt; // 弹窗内容 ...&lt;/view&gt; setIntervalwindow.setInterval(调用函数，延时时间); 与setTimeout区别： setTimeout是延时时间到了就去调用这个回调函数，只调用了一次 就结束了这个定时器。 setInterval是 每隔这个延迟时间 就去调用这个回调函数 会调用很多次 重复调用这个函数。 清除定时器 clearInterval() 12345678910111213141516171819onLoad(options) &#123; // 不是微信环境且当前页面出现在屏幕上时执行轮询 if (this.envType !== 1 &amp;&amp; this.isPolling) &#123; // 3秒刷新一次 this.timer = setInterval(() =&gt; &#123; this.getState() &#125;, 3000) &#125; &#125;, onShow() &#123; this.isPolling = true &#125;, onHide() &#123; this.isPolling = false &#125;, // 监听页面卸载 onUnload() &#123; clearInterval(this.timer) &#125;, 小程序首页onUnload中无法请求接口小程序首页的onUnload生命周期函数是在页面被关闭或隐藏时触发的，而请求接口需要在页面可见的状态下才能发送。因此，在onUnload中无法直接请求接口。 如果你想在小程序首页关闭或隐藏时发送接口请求，可以考虑使用其他生命周期函数或事件来实现。以下是一些可能的解决方案： 在页面的onHide生命周期函数中发送接口请求：onHide会在小程序页面隐藏时触发，这样可以确保页面仍然是可见状态，可以发送请求。但需要注意，如果用户频繁在首页和其他页面之间切换，可能会频繁触发该生命周期函数并发送多个接口请求，导致性能问题。 使用App全局对象的onHide生命周期函数：将请求接口的逻辑放在App全局对象的onHide生命周期函数中。这样无论哪个页面被关闭或隐藏，都能够在一处统一处理接口请求。 使用其他触发条件：根据具体需求，可以考虑使用其他触发条件来发送接口请求，例如点击按钮、进入其他页面等。你可以在合适的时机，结合业务场景，选择合适的触发条件来发送接口请求。 原生微信小程序转uniapp每个页面修改步骤12345678910111213141516171819202122232425262728293031this.data换成this/images换成/static/imagesbindtap和catchtap换成@clickwx.改成uni.var改成letthat改成_thisbind改成@wx:if改成v-if去掉大括号wx:elif改成v-else-if去掉大括号wx:else改成v-elsewx:for改成v-for看着改this.setData看着改data-改成函数传参style=和=&quot;&#123;&#123;看着改引用接口，改.then解决报错 vue移动端转uniapp每个页面修改步骤 div和&lt;p标签改成view span改成text ../../static改成/static/images img改成image alt=””改成/ api.改成$http. res.data改成res 修改Toast、Dialog lang=”scss” uniapp使用toast提示进行表单校验1234567891011121314151617181920212223242526272829showToast() &#123; this.formData.name = &apos;ww&apos; const arr = [ &#123; key: &apos;name&apos;, title: &apos;请输入姓名&apos; &#125;, &#123; key: &apos;index&apos;, title: &apos;请选择xxx&apos;, fun: (p) =&gt; &#123; return p === 0 &#125; &#125;, &#123; key: &apos;xxx&apos;, title: &apos;请输入xxx&apos; &#125; ] let key, title, fun for (let i = 0; i &lt; arr.length; i++) &#123; key = arr[i].key title = arr[i].title fun = arr[i].fun console.log(key, title, fun, this.formData[key]) if ((fun &amp;&amp; fun(this[key])) || (!fun &amp;&amp; !this.formData[key])) &#123; // 如果不满足条件或者为空就提示 uni.showToast(&#123; title, icon: &apos;none&apos; &#125;) return &#125; &#125; &#125;, this[key]和this.formData[key]根据实际data数据进行修改 封装一个通用的验证方法来简化代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;template&gt; &lt;div&gt; &lt;form @submit.prevent=&quot;submitForm&quot;&gt; &lt;input v-model=&quot;name&quot; type=&quot;text&quot; placeholder=&quot;Name&quot;&gt; &lt;input v-model=&quot;email&quot; type=&quot;email&quot; placeholder=&quot;Email&quot;&gt; &lt;!-- Add more input fields --&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; name: &apos;&apos;, email: &apos;&apos; &#125; &#125;, methods: &#123; submitForm() &#123; const validationResult = this.validateForm(); if (validationResult.isValid) &#123; // Submit the form &#125; else &#123; this.$toast.error(validationResult.errorMessage); &#125; &#125;, validateForm() &#123; const requiredFields = [ &#123; fieldName: &apos;name&apos;, label: &apos;Name&apos; &#125;, &#123; fieldName: &apos;email&apos;, label: &apos;Email&apos; &#125;, // Add more input fields ]; for (const field of requiredFields) &#123; if (!this[field.fieldName]) &#123; return &#123; isValid: false, errorMessage: `$&#123;field.label&#125; is required.` &#125; &#125; &#125; // Add more custom validation rules return &#123; isValid: true, errorMessage: &apos;&apos; &#125;; &#125;, &#125;,&#125;;&lt;/script&gt; 控制输入框是否自动聚焦1234567891011121314151617181920212223242526&lt;input v-model=&quot;formData.code&quot; type=&quot;number&quot; maxlength=&quot;4&quot; class=&quot;idCard-formItem-input&quot; placeholder=&quot;请输入短信验证码&quot; placeholder-class=&quot;placeholder&quot; :focus=&quot;autoFocus&quot; @blur=&quot;handleBlur&quot; @keydown.enter.native=&quot;phoneLogin&quot; /&gt; &lt;view class=&quot;code&quot; @click=&quot;getCode&quot; v-if=&quot;!codeData.status&quot;&gt;获取验证码&lt;/view&gt; getCode() &#123; this.autoFocus = true this.timerInterval = setInterval(() =&gt; &#123; if (this.codeData.count &gt; 0) &#123; this.codeData.count = this.codeData.count - 1 &#125; else &#123; this.codeData.count = 30 this.codeData.status = false this.dxToken = &apos;&apos; clearInterval(this.timerInterval) &#125; &#125;, 1000) &#125;, 输入框聚焦页面置顶切记:adjust-position=”false”，不然ios会自动上推页面导致有问题 .focus为输入框外层容器类名 12345678910111213141516171819202122232425&lt;input :placeholder-class=&quot;isCheck&amp;&amp;!formData.title?&apos;err&apos;:&apos;placeholder&apos;&quot; v-model=&quot;formData.title&quot; :adjust-position=&quot;false&quot; maxlength=&quot;32&quot; placeholder=&quot;请输入发票抬头（可检索）&quot; @focus=&quot;focusTitle&quot; @blur=&quot;blurTitle&quot; @input=&quot;inputTitle&quot; /&gt; // 发票抬头聚焦 focusTitle() &#123; this.$refs.dropRef.show() // 输入框聚焦置顶 this.isFocus = true const offsetTop = -this.systemInfo.statusBarHeight - 44 - 45 console.log(offsetTop) // 状态栏+导航栏+头部固定区域的高度为偏移量 this.$nextTick(() =&gt; &#123; // 防止键盘遮挡下拉框 uni.pageScrollTo(&#123; selector: &apos;.focus&apos;, offsetTop &#125;) &#125;) &#125;, 使用JSON.stringify遇到特殊字符如：&amp; 会报错[Vue warn]: Error in onLoad hook: “SyntaxError: Unexpected end of JSON input”SyntaxError: Unterminated string in JSON at position 90 12345678910111213[&#123; latitude: this.latitude, longitude: this.longitude, title: &apos;四创科技有限公司(星网锐捷科技园·一期&amp;二期西南)&apos;, // title: res.formatted_addresses.recommend, address: res.address, id: 0, width: 44, height: 60, iconPath: &apos;/static/images/spot_start.png&apos;, // 图标路径 clock_state: 0, time: &apos;&apos; &#125;] 解决方案： 1.通过编码解码的方式处理1234567let markers = encodeURIComponent(JSON.stringify(this.markers)) console.log(markers) uni.navigateTo(&#123; url: `/sub_trip/trip/SetTrip?isAdd=$&#123;isAdd&#125;&amp;tripList=$&#123;JSON.stringify( this.tripList )&#125;&amp;markers=$&#123;markers&#125;` &#125;) 接收页 12345678onLoad(options) &#123; console.log(options) if (options.tripList) &#123; this.tripList = JSON.parse(options.tripList) this.markers = JSON.parse(decodeURIComponent(options.markers)) &#125; console.log(this.tripList, this.markers)&#125; 2.使用vuex，不容易出问题因为这个字段过长，路由传参最多300多字符 数组深拷贝12345678910111213141516171819let [...markers] = this.markers // 数组深拷贝 markers.reverse() // 数组反转 // 处理markers数据 markers.forEach((item, index) =&gt; &#123; item.id = index item.width = 44 item.height = 60 item.clock_state = 0 item.time = &apos;&apos; if (index === 0) &#123; item.iconPath = &apos;/static/images/spot_start.png&apos; &#125; else if (index === this.markers.length - 1) &#123; item.iconPath = &apos;/static/images/spot_end.png&apos; &#125; else &#123; item.iconPath = `/static/images/spot$&#123;index&#125;.png` &#125; &#125;) this.markers = markers console.log(this.markers) 微信小程序textarea组件 输入字数 ＞ 限制字数 的bug当你需要给textarea组件添加一个统计输入字数的功能时 如果在手机上通过复制粘贴达到最大限制字数，这时候继续使用手机上的小键盘输入内容，就会出现输入字数大于限制字数的bug，而多出来的字数就是你小键盘上当前输入的内容长度。 或者超过最大限制字数，复制超字数会被统计出来 例如feedback.length可能会显示134、165，但文本框内实际有100个字符，实际问题只是显示字数不对 12345678&lt;textarea v-model=&quot;feedback&quot; placeholder=&apos;请输入反馈内容&apos; maxlength=&quot;100&quot; @blur=&quot;handleBlur&quot;&gt; &lt;/textarea&gt; &lt;text class=&quot;count&quot;&gt; &lt;text class=&quot;black&quot;&gt;&#123;&#123;feedback.length&#125;&#125;&lt;/text&gt;/100 &lt;/text&gt; 解决办法： 如果value的长度大于限制长度，则取限制长度展示 1&lt;text class=&quot;black&quot;&gt;&#123;&#123; feedback.length&gt;100 ? 100 : feedback.length &#125;&#125;&lt;/text&gt;/100 套div防止图片被挤压变形123456789101112131415161718192021222324252627282930313233343536373839&lt;view class=&quot;search&quot;&gt; &lt;view class=&quot;icon&quot;&gt; &lt;image :src=&quot;getSrc(&apos;search@2x.png&apos;)&quot; /&gt; &lt;/view&gt; &lt;input v-model=&quot;formData.keyword&quot; disabled @click=&quot;openPopup&quot; placeholder=&quot;任务名称、任务编号&quot; placeholder-class=&quot;placeholder&quot; /&gt;&lt;/view&gt; .search &#123; width: 646rpx; height: 60rpx; padding: 0 16rpx; margin-top: 20rpx; border-radius: 32rpx; box-sizing: border-box; display: flex; align-items: center; background: #fff; .icon &#123; // 套div防止图片被挤压 height: 42rpx; image &#123; width: 40rpx; height: 42rpx; margin-right: 16rpx; &#125; &#125; input &#123; width: 100%; height: 100%; font-size: 32rpx; letter-spacing: 2rpx; text-align: left; color: #464c5b; &#125; &#125; 小程序不支持table标签12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 &lt;view class=&quot;table&quot;&gt; &lt;!-- 表头(即第一行) --&gt; &lt;view class=&quot;tr&quot;&gt; &lt;view class=&quot;th&quot;&gt;插件名称&lt;/view&gt; &lt;view class=&quot;th&quot;&gt;插件提供方名称&lt;/view&gt; &lt;view class=&quot;th&quot;&gt;使用场景&lt;/view&gt; &lt;view class=&quot;th&quot;&gt;共享个人信息内容&lt;/view&gt; &lt;/view&gt; &lt;!-- 表格第二行 --&gt; &lt;view class=&quot;tr&quot;&gt; &lt;view class=&quot;td&quot;&gt;OCR身份证识别SDK&lt;/view&gt; &lt;view class=&quot;td&quot;&gt;北京市商汤科技开发有限公司&lt;/view&gt; &lt;view class=&quot;td&quot;&gt;实名认证&lt;/view&gt; &lt;view class=&quot;td&quot;&gt;身份证照片识别&lt;/view&gt; &lt;/view&gt; &lt;!-- 表格第三行 --&gt; &lt;view class=&quot;tr&quot;&gt; &lt;view class=&quot;td&quot;&gt;顶象验证SDK&lt;/view&gt; &lt;view class=&quot;td&quot;&gt;北京顶象技术有限公司&lt;/view&gt; &lt;view class=&quot;td&quot;&gt;验证码防刷&lt;/view&gt; &lt;view class=&quot;td&quot;&gt;设备信息、网络信息、IP地址、用户行为&lt;/view&gt; &lt;/view&gt; &lt;!-- 表格第四行 --&gt; &lt;view class=&quot;tr&quot;&gt; &lt;view class=&quot;td&quot;&gt;神策SDK&lt;/view&gt; &lt;view class=&quot;td&quot;&gt;神策网络科技（北京）有限公司&lt;/view&gt; &lt;view class=&quot;td&quot;&gt;用户行为分析&lt;/view&gt; &lt;view class=&quot;td&quot;&gt;手机IMEI、操作信息、设备型号、手机操作系统&lt;/view&gt; &lt;/view&gt; &lt;!-- 表格第五行 --&gt; &lt;view class=&quot;tr&quot;&gt; &lt;view class=&quot;td&quot;&gt;微信SDK&lt;/view&gt; &lt;view class=&quot;td&quot;&gt;深圳市腾讯计算机系统有限公司&lt;/view&gt; &lt;view class=&quot;td&quot;&gt;微信登录、分享&lt;/view&gt; &lt;view class=&quot;td&quot;&gt;微信信息（头像、昵称、地区、性别）&lt;/view&gt; &lt;/view&gt; &lt;/view&gt;.table &#123; display: flex; flex-direction: column; border-top: 2rpx solid #dadada; /* 单元格上线框 */ border-left: 2rpx solid #dadada; /* 单元格左线框 */ .tr &#123; display: flex; flex-direction: row; &#125; .th, .td &#123; width: 25%; /* 4个25%相加刚好100% */ padding: 2rpx; display: flex; flex-direction: row; flex-wrap: wrap; /* 自动换行 */ text-align: center; /* 文本居中 */ justify-content: center; /* 主轴居中 */ align-items: center; /* 交叉轴居中 */ border-bottom: 2rpx solid #dadada; /* 单元格下线框 */ border-right: 2rpx solid #dadada; /* 单元格右线框 */ &#125; .th &#123; font-weight: bold; &#125;&#125; uniapp中的textarea文本框设置长度限制在uniapp 的项目中要使用编辑文本域的功能，但是文本框的长度是不做限制的，虽然在不写maxlength的情况下是可以的。但是在测试的时候你会发现文本框输入文字的时候添加140个文字以后就不能再添加文字了（没有效果了）。我是在做uniapp的项目的时候，测试出这个问题的，后来发现，在不设置maxlength的情况下，uniapp中默认textarea中的最大字数限制为140。即 在不写maxlength的时候，会在审查元素的时候，会自动生成 maxlength=“140” 解决办法： 在textarea标签中添加maxlength=’’-1’’属性 1&lt;textarea maxlength=&quot;-1&quot; /&gt; 打开另一个小程序12345678910111213141516// 打开另一个小程序 navigateToMiniProgram() &#123; uni.navigateToMiniProgram(&#123; appId: &apos;wx3f3b615216e7cfbe&apos;, path: &apos;pages/my/My&apos;, extraData: &#123; sign_mch_id: &apos;WgrpwNplS8rL&apos;, phone: &apos;18734131475&apos; &#125;, envVersion: &apos;trial&apos;, // 要打开的小程序版本 success(res) &#123; // 打开成功 console.log(&apos;打开成功&apos;) &#125; &#125;) &#125;, envVersion： 要打开的小程序版本，有效值： develop（开发版），trial（体验版），release（正式版）。仅在当前小程序为开发版或体验版时此参数有效。如果当前小程序是正式版，则打开的小程序必定是正式版。 跳转回上一个小程序只有当另一个小程序跳转到当前小程序时才会能调用成功。 123456789101112// 返回第三方小程序 goBack() &#123; // 跳转回上一个小程序，只有当另一个小程序跳转到当前小程序时才会能调用成功 uni.navigateBackMiniProgram(&#123; extraData: &#123; msg: &apos;签约成功&apos; &#125;, success(res) &#123; // 返回成功 &#125; &#125;) &#125; 跳转到E证通小程序进行人脸识别123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import $http from &apos;@/api/http&apos;import &#123; mapState &#125; from &apos;vuex&apos;import &#123; initEid, startEid &#125; from &apos;@/mp_ecard_sdk/main&apos;export default &#123; data() &#123; return &#123; &#125;; &#125;, computed: &#123; ...mapState(&#123; userInfo: (state) =&gt; state.login.userInfo &#125;) &#125;, onLoad(option) &#123; // 初始化E证通 initEid() &#125;, methods: &#123; // 跳转到E证通小程序进行人脸识别 async faceEid() &#123; uni.showLoading(&#123; title: &apos;加载中&apos; &#125;) // 获取E证通EidToken const token = await $http.eidToken() uni.hideLoading() const param = &#123; data: &#123; token &#125;, // 核身完成的回调 verifyDoneCallback: async (res) =&gt; &#123; console.log(&apos;收到核身完成的res&apos;, res) const &#123; token, verifyDone &#125; = res console.log(&apos;核身验证成功的token是:&apos;, token) console.log(&apos;是否完成核身:&apos;, verifyDone) if (verifyDone) &#123; uni.showLoading(&#123; title: &apos;核验中&apos; &#125;) const data = await $http.checkEidToken(res) // name、phone、id_card console.log(data) if (data.name || this.userInfo.state === 1) &#123; // 认证成功 或者 已实名补录人脸的情况 console.log(&apos;认证成功&apos;) // 刷新缓存 await this.getUserInfo() uni.hideLoading() // 如果在我的页用reLaunch，核验完回来onShow刷新一次，等待上面核验接口执行完又reLaunch，页面感觉会刷新两次 uni.switchTab(&#123; url: &apos;/pages/my/My&apos; &#125;) &#125; else &#123; // 认证失败 uni.hideLoading() &#125; &#125; &#125; &#125; // 有token就进⼊E证通实名认证⻚ token &amp;&amp; startEid(param) &#125;, &#125;&#125; 常用返回值记录uniapp视频选择uni.chooseVideo返回值12345678910111213141516171819202122232425// 微信小程序视频选择真机返回值duration: 2errMsg: &quot;chooseVideo:ok&quot;height: 656size: 176181tempFilePath: &quot;wxfile://tmp_326eae5820787184e4351b9eb86e131c9b376dc6263e5304.mp4&quot;width: 296// web视频选择返回值duration: 8.9errMsg: &quot;chooseVideo:ok&quot;height: 960name: &quot;iphone底部按钮问题.mp4&quot;size: 1201520width: 442tempFilePath: &quot;blob:http://localhost:8080/e339462f-8f8a-4025-955a-e2a53760efba&quot;tempFile:&#123; lastModified: 1669347671458 lastModifiedDate: Fri Nov 25 2022 11:41:11 GMT+0800 (中国标准时间) &#123;&#125; name: &quot;iphone底部按钮问题.mp4&quot; size: 1201520 type: &quot;video/mp4&quot; webkitRelativePath: &quot;&quot;&#125; uniapp监听实时地理位置变化事件uni.onLocationChange返回值12345678910111213// 真机accuracy: 35altitude: 0direction: 0horizontalAccuracy: 35indoorLocationType: -1latitude: 39.866444498697916longitude: 116.30702663845486provider: &quot;network&quot;speed: 0steps: 0type: &quot;gcj02&quot;verticalAccuracy: 0","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"uni-app","slug":"uni-app","permalink":"https://qw8.github.io/tags/uni-app/"},{"name":"小程序","slug":"小程序","permalink":"https://qw8.github.io/tags/小程序/"}]},{"title":"vuex","slug":"knowledges/vuex","date":"2022-07-28T13:02:08.000Z","updated":"2024-02-28T03:11:10.000Z","comments":true,"path":"/knowledges/vuex.html","link":"","permalink":"https://qw8.github.io/knowledges/vuex.html","excerpt":"","text":"Vuex数据页面刷新丢失问题解决方案用Vue做项目开发很久了，对于vuex能用、会用，但是因为状态脱离页面和刷新丢失两个原因，一直都有种抵触，特别是一些简单的数据都是通过query或者本地存储就解决了，然而对于一些复杂内容，不可避免的还是要使用Vuex去处理(真香)，但是刷新丢失的问题，的确叫人头大。最近闲下来，我们来研究下怎么干掉这个问题～ 不大了解Vuex的同学，可以先去官网溜溜 由于Vuex的数据是存储在内存中的，相当于memory cache，当页面刷新的时候内存被清空重载新内容，原来的数据就丢了，为了解决这个我们可以借助浏览器的本地存储来解决，此时我们有两个选择 localStorage 真·持久存储 sessionStorage 会话期存储 相比之下localStorage太持久了，不主动清除都会一直在，而sessionStorage更符合Vuex会话期状态管理的设计初衷。因此下文中统一使用sessionStorage来做补充，解决问题。 有了补充对象之后，我们要做的只有两点1、每次在mutation中set state的时候，同步的塞到sessionStorage一份2、状态初始化的时候，从sessionStorage中读取相应内容并作为默认值(存在的话) 看起来很简单，于是第一版方案有了， 12345678910111213export default new Vuex.Store(&#123; state: &#123; userLevel: sessionStorage.getItem('userLevel') || '' &#125;, mutations: &#123; SET_USERLEVEL(state, userLevel) &#123; sessionStorage.setItem('userLevel', userLevel) state.userLevel = userLevel &#125; &#125;, modules: &#123; &#125;&#125;) 这个是解决问题了，但是每个mutation都要sessionStorage.setItem一下实在有点麻烦，而且初始化还要都getItem一遍，我很懒不想写。。。于是我们改进了第二版 123456789101112131415161718192021222324252627282930313233343536373839404142434445const storeMaker = (state) =&gt; &#123; // 初始化 Object.keys(state).map((key) =&gt; &#123; // 判断类型获取本地存储数据 if (typeof state[key] === 'object') &#123; if (sessionStorage.getItem(key) &amp;&amp; JSON.parse(sessionStorage.getItem(key))) &#123; state[key] = JSON.parse(sessionStorage.getItem(key)) &#125; &#125; else if (typeof state[key] === 'number') &#123; if (sessionStorage.getItem(key) &amp;&amp; parseInt(sessionStorage.getItem(key))) &#123; state[key] = parseInt(sessionStorage.getItem(key)) &#125; &#125; else &#123; if (sessionStorage.getItem(key)) &#123; state[key] = sessionStorage.getItem(key) &#125; &#125; &#125;) // 重写set处理 return new Proxy(state, &#123; set: function(target, key, value) &#123; let temp = value if (typeof temp === 'object') &#123; temp = JSON.stringify(temp) &#125; sessionStorage.setItem(key, temp) return Reflect.set(target, key, value) &#125; &#125;)&#125;export default new Vuex.Store(&#123; state: storeMaker(&#123; userLevel: '' &#125;), mutations: &#123; SET_USERLEVEL(state, userLevel) &#123; state.userLevel = userLevel &#125; &#125;, modules: &#123; &#125;&#125;) 内容不多，主要定义了一个storeMaker的函数实现了两个功能1、对传入的state初始值判断类型，并尝试从sessionStorage中读取数据替换默认值2、通过Proxy重置state的set逻辑，添加同步保存到sessionStorage的逻辑 其实本来可以通过Proxy重置get逻辑处理取值的问题，但是由于vuex本身通过defineProperty函数重置了get逻辑，在这里使用proxy覆盖会有冲突，因此在初始化的时候直接读取sessionStorage。 同时也存在一些问题：1、目前只处理了一级属性，二级以下属性没处理，对于初始化会有偏差。对于这点处理层级也不宜过深，因为过深的结构设计本来就并不合理，两层基本也足够了。基本处理就是对于state的每个key再去遍历一遍，如果是object(非null非数组非空对象)就重新proxy一下2、可以尝试打包成npm包，或者写成Vuex的插件形式，方便使用3、等等 ～状态不好，先写到这，大家有兴趣一起来讨论，清清脑子再来补充～ 联想到的一些点：1、memory cache和disk cache？内存怎么清理？js垃圾回收机制？2、SessionStorage怎么做到会话期缓存？3、session机制怎么回事？4、http的无状态？状态保持？客户端保持？服务端保持？5、等等等等发散开看看，一个地方真的能学到很多东西。。。 封装vuex，使其结合缓存持久化，并且在组件中方便使用chatGPT 在使用Vuex时结合缓存持久化，可以通过以下几个步骤来封装： 安装依赖：安装vuex和localforage（或其他合适的缓存库）。 1npm install vuex localforage 创建一个新的store.js文件，用于封装Vuex。 123456789101112131415161718192021222324252627282930313233343536373839404142import Vue from 'vue';import Vuex from 'vuex';import localforage from 'localforage';Vue.use(Vuex);// 初始化缓存库localforage.config(&#123; driver: localforage.LOCALSTORAGE, // 在本地存储中使用localStorage作为驱动程序 name: 'myApp' // 设置缓存库名称，可以根据你的应用名称进行设置&#125;);// 创建并导出store实例export default new Vuex.Store(&#123; state: &#123; // 初始化state // ... &#125;, mutations: &#123; // 定义mutations // ... &#125;, actions: &#123; // 定义actions // ... &#125;, plugins: [ store =&gt; &#123; // 在刷新时从缓存中恢复state localforage.getItem('vuex').then(value =&gt; &#123; if (value) &#123; store.replaceState(value); &#125; &#125;); // 在每次mutation后将state缓存起来 store.subscribe((mutation, state) =&gt; &#123; localforage.setItem('vuex', state); &#125;); &#125; ]&#125;); 在上面的代码中，我们使用了localforage作为缓存库，并且在每次mutation后将state缓存起来，在刷新时从缓存中恢复state。 在主应用文件（如main.js）中引入store.js并挂载到Vue实例上。 12345678import Vue from 'vue';import App from './App.vue';import store from './store';new Vue(&#123; store, render: h =&gt; h(App)&#125;).$mount('#app'); 现在，我们已经将Vuex结合缓存持久化封装好了。 在组件中，你可以像正常使用Vuex一样使用它： 1234567891011// 使用mapState和mapActions辅助函数获取state和actionsimport &#123; mapState, mapActions &#125; from 'vuex';export default &#123; computed: &#123; ...mapState(['count']) &#125;, methods: &#123; ...mapActions(['increment']) &#125;&#125;; 这样，你就可以在组件中通过this.count访问state，并且通过this.increment()来调用increment action。所有的状态更新都会被自动地缓存到本地存储中，以确保在刷新页面后能够重新加载。 需要注意的是，由于缓存是异步的，所以在应用初始化加载时，可能会出现短暂的闪屏情况。如果需要避免这种情况，可以在应用启动之前显示一个加载提示，然后在缓存加载完成后隐藏加载提示。 文心一言 封装 Vuex 以结合缓存持久化并在组件中方便使用，你可以遵循以下步骤来实现： 步骤 1: 安装必要的库首先，你需要安装 vuex 和一个用于缓存持久化的库，比如 vuex-persistedstate。你可以使用 npm 或 yarn 进行安装： 123npm install vuex vuex-persistedstate --save # 或者 yarn add vuex vuex-persistedstate 步骤 2: 创建 Vuex Store在 Vue 项目中，创建一个新的文件（例如 store.js）来定义你的 Vuex store。在这个文件中，导入 Vuex 和 vuex-persistedstate 插件，并定义你的 store： 123456789101112131415161718192021222324252627import Vue from 'vue'; import Vuex from 'vuex'; import createPersistedState from 'vuex-persistedstate'; Vue.use(Vuex); const store = new Vuex.Store(&#123; state: &#123; // 定义你的状态 &#125;, mutations: &#123; // 定义你的 mutations &#125;, actions: &#123; // 定义你的 actions &#125;, modules: &#123; // 定义你的模块（如果有的话） &#125;, plugins: [ createPersistedState(&#123; // 配置选项，例如存储位置（localStorage 或 sessionStorage） &#125;) ] &#125;); export default store; 步骤 3: 在 Vue 实例中使用 Vuex Store在你的 Vue 实例中，导入并使用刚才创建的 Vuex store： 12345678import Vue from 'vue'; import App from './App.vue'; import store from './store'; new Vue(&#123; store, render: h =&gt; h(App) &#125;).$mount('#app'); 步骤 4: 在组件中使用 Vuex现在，你可以在你的 Vue 组件中通过 this.$store 访问 Vuex store。为了更方便地使用 Vuex，你可以使用 mapState、mapMutations 和 mapActions 辅助函数来映射 state、mutations 和 actions 到组件的计算属性和方法上。 例如，在你的组件中： 12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;p&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt; &lt;button @click=\"incrementCount\"&gt;Increment&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import &#123; mapState, mapMutations &#125; from 'vuex'; export default &#123; computed: &#123; ...mapState(['count']) // 映射 state 中的 count 到组件的计算属性上 &#125;, methods: &#123; ...mapMutations(['incrementCount']) // 映射 mutations 中的 incrementCount 到组件的方法上 &#125; &#125;; &lt;/script&gt; 步骤 5: 测试缓存持久化现在，当你更改 Vuex store 中的状态时，这些更改应该会被持久化到浏览器的 localStorage 或 sessionStorage 中（取决于你在 vuex-persistedstate 插件中的配置）。你可以尝试刷新页面，看看状态是否仍然保持不变。 这样，你就成功地封装了 Vuex 以结合缓存持久化，并在组件中方便地使用 Vuex 了。","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://qw8.github.io/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"https://qw8.github.io/tags/vuex/"}]},{"title":"vuex","slug":"interview/vuex","date":"2022-07-27T13:02:08.000Z","updated":"2023-04-14T17:01:50.000Z","comments":true,"path":"/interview/vuex.html","link":"","permalink":"https://qw8.github.io/interview/vuex.html","excerpt":"","text":"vuex是什么？怎么使用？哪种功能场景使用它？Vuex 是一个专为 Vue.js 应用程序开发的状态管理插件。（公共数据库） 在main.js引入store，注入。新建了一个目录store，….. export 当项目遇到以下两种场景时 多个组件依赖于同一状态时。 来自不同组件的行为需要变更同一状态。 解决的问题：多个视图依赖同一个状态，来自不同视图的行为需要变更同一状态，适用于中大型的单页面应用。 场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车 vuex有哪几种属性？有五种，分别是 State、 Getter、Mutation 、Action、 Module state：存放公共数据的地方； getter：获取根据业务场景处理返回的数据； mutations：唯一修改state的方法，修改过程是同步的； action：异步处理，通过分发操作触发mutation； module：将store模块分割，减少代码臃肿； Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？如果请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入vuex 的state里。 如果被其他地方复用，这个很大几率上是需要的，如果需要，请将请求放入action里，方便复用。 页面刷新后vuex的state数据丢失怎么解决？就是放在localStorage 或者就是sessionStorage ，或者借用辅助插vuex-persistedstate。 使用vuex的优势是什么？其实vuex中的所有功能都能够通过其他的方式进行实现，只不过vuex对这些方法进行了整合处理，使用起来更加便捷，同时也便于维护。 Vuex中状态储存在哪里，怎么改变它？存储在state中，改变Vuex中的状态的唯一途径就是显式地提交 (commit) mutation。 Vuex中状态是对象时，使用时要注意什么？因为对象是引用类型，复制后改变属性还是会影响原始数据，这样会改变state里面的状态，是不允许的，所以先用深度克隆复制对象，再修改。 怎么在组件中批量使用Vuex的state状态？使用mapState辅助函数, 利用对象展开运算符将state混入computed对象中 123456import &#123;mapState&#125; from &apos;vuex&apos;export default&#123; computed:&#123; ...mapState([&apos;price&apos;,&apos;number&apos;]) &#125;&#125; Vuex中要从state派发一些状态出来，且多个组件使用它，该怎么做？使用getter属性，相当Vue中的计算属性computed，只有原状态改变派生状态才会改变。 getter接收两个参数，第一个是state，第二个是getters(可以用来访问其他getter)。 123456789101112131415const store = new Vuex.Store(&#123; state: &#123; price: 10, number: 10, discount: 0.7, &#125;, getters: &#123; total: state =&gt; &#123; return state.price * state.number &#125;, discountTotal: (state, getters) =&gt; &#123; return state.discount * getters.total &#125; &#125;,&#125;); 然后在组件中可以用计算属性computed通过this.$store.getters.total这样来访问这些派发状态。 然后在组件中可以用计算属性computed通过this.$store.getters.total这样来访问这些派发状态。 12345678computed: &#123; total() &#123; return this.$store.getters.total &#125;, discountTotal() &#123; return this.$store.getters.discountTotal &#125;&#125; vuex中 划分模块的好处state 更为 容易管理 保证了store完整的状态数 又避免了相互之间的state冲突 vuex的store特性vuex 就是一个仓库 仓库里放了很多对象 其中state就是数据源存放地 state里面存放的数据是 响应式的 vue组件从store读取数据 若是 store中的数据发生改变 依赖这项数据的组件 也会发生更新 通过 mapState 把全局的state 和 getters 映射到当前组件的 computed中 vuex怎么知道state是通过mutation修改还是外部直接修改的？通过$watch监听mutation的commit函数中_committing是否为true Vuex中action和mutation有什么相同点？第二参数都可以接收外部提交时传来的参数。this.$store.dispatch(‘ACTION_NAME’,data)和this.$store.commit(‘SET_NUMBER’,10) Vuex中action通常是异步的，那么如何知道action什么时候结束呢？在action函数中返回Promise，然后再提交时候用then处理 12345678910111213actions:&#123; SET_NUMBER_A(&#123;commit&#125;,data)&#123; return new Promise((resolve,reject) =&gt;&#123; setTimeout(() =&gt;&#123; commit(&apos;SET_NUMBER&apos;,10); resolve(); &#125;,2000) &#125;) &#125;&#125;this.$store.dispatch(&apos;SET_NUMBER_A&apos;).then(() =&gt; &#123; // ...&#125;) Vuex中有两个action，分别是actionA和actionB，其内都是异步操作，在actionB要提交actionA，需在actionA处理结束再处理其它操作，怎么实现？利用ES6的async和await来实现。 123456789actions:&#123; async actionA(&#123;commit&#125;)&#123; //... &#125;, async actionB(&#123;dispatch&#125;)&#123; await dispatch (&apos;actionA&apos;)//等待actionA完成 // ... &#125;&#125; 在模块中，getter和mutation接收的第一个参数state，是全局的还是模块的？第一个参数state是模块的state，也就是局部的state。 在v-model上怎么用Vuex中state的值？需要通过computed计算属性来转换。 123456789101112&lt;input v-model=&quot;message&quot;&gt;// ...computed: &#123; message: &#123; get () &#123; return this.$store.state.message &#125;, set (value) &#123; this.$store.commit(&apos;updateMessage&apos;, value) &#125; &#125;&#125; Vuex的严格模式是什么,有什么作用,怎么开启？在严格模式下，无论何时发生了状态变更且不是由 mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。 在Vuex.Store 构造器选项中开启,如下： 123const store = new Vuex.Store(&#123; strict:true,&#125;)","categories":[{"name":"前端面试题","slug":"前端面试题","permalink":"https://qw8.github.io/categories/前端面试题/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://qw8.github.io/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"https://qw8.github.io/tags/vuex/"}]},{"title":"vue项目思路","slug":"questions/vue项目思路","date":"2022-05-22T14:40:25.000Z","updated":"2024-06-06T02:21:10.215Z","comments":true,"path":"/questions/vue-xiang-mu-si-lu.html","link":"","permalink":"https://qw8.github.io/questions/vue-xiang-mu-si-lu.html","excerpt":"","text":"vue判断设备是手机端还是pc端在 App.vue（或者主页面）的 created 方法中对设置进行判断，如下: 123456789101112created() &#123; if (this.isMobile()) &#123; alert(&quot;手机端&quot;); this.$router.replace(&apos;/m_index&apos;); &#125; else &#123; alert(&quot;pc端&quot;); this.$router.replace(&apos;/pc_index&apos;); &#125; // 或者 this.isMobile() &#125; 在 App.vue（或者主页面）的 methods方法中做手机型号设置，如下: 123456789101112131415161718192021methods: &#123; isMobile() &#123; let flag = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i) return flag; &#125; // 或者 // 根据浏览器信息判断是否移动端并存到本地 isMobile()&#123; const isMobile = localStorage.getItem(&quot;isMobile&quot;) if(isMobile === null)&#123; const flag = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if(flag)&#123; localStorage.setItem(&quot;isMobile&quot;, true) &#125;else&#123; localStorage.setItem(&quot;isMobile&quot;, false) &#125; &#125; &#125; &#125; js判断设备是手机还是PC还是ipad123456789101112131415161718192021// 判断浏览器信息并存到本地 judgeDevice()&#123; // const device = localStorage.getItem(&quot;device&quot;) // if(device === null)&#123; // 只执行一次 const device = navigator.userAgent console.log(device) if (device.match(/android/ig)) &#123; localStorage.setItem(&quot;device&quot;, &quot;android&quot;) &#125; else if (device.match(/iPad/ig)) &#123; localStorage.setItem(&quot;device&quot;, &quot;iPad&quot;) &#125; else if (device.match(/WindowsWechat/ig)) &#123; // 因为企微也有Safari，所以提前判断 localStorage.setItem(&quot;device&quot;, &quot;pc&quot;) &#125; else if (device.match(/iphone|ipod|iOS|Safari/ig)) &#123; // 部分iPhone也有Safari localStorage.setItem(&quot;device&quot;, &quot;ios&quot;) &#125; else &#123; localStorage.setItem(&quot;device&quot;, &quot;pc&quot;) &#125; // &#125; &#125; ElementUI、iview中input回车触发页面刷新问题及其解决方法在日常的开发过程中，你可能会遇到一个问题：在ElementUI的el-form表单中，如果只存在一个el-input输入框，当你输入值后按下回车，页面会发生刷新。 这是因为当form元素中只有一个输入框时，按下回车将触发表单的默认提交事件，这是W3C标准的规定。form表单提交的时候会刷新页面。 解决方案： 在form表单里禁止自动提交 在页面全局禁止键盘按下enter事件 input禁止键盘按下enter事件 vue项目中可在form标签上加上@submit.native.prevent 直接去除掉form表单，当然这是最简单粗暴的方法。 如果一个input会自动提交，那么比较容易想到的是再加一个input。值得注意的是 这里的input不能设置type为hidden，这样一样是不生效的，form一样会认为只有一个input。 解决方法：ElementUI也给出了解决方法。如果你希望阻止这一默认行为，可以在标签上添加@submit.native.prevent 例如： 123456789101112131415161718&lt;el-form :model=&quot;form&quot; ref=&quot;form&quot; label-width=&quot;200px&quot; class=&quot;form&quot; @submit.native.prevent&gt; &lt;el-form-item label=&quot;姓名&quot; prop=&quot;name&quot; &gt; &lt;el-input v-model.number=&quot;form.name&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;submit(&apos;form&apos;)&quot;&gt;提交&lt;/el-button&gt; &lt;el-button @click=&quot;reset(&apos;form&apos;)&quot;&gt;重置&lt;/el-button&gt; &lt;/el-form-item&gt;&lt;/el-form&gt; 然而，上述方法只是阻止了默认行为，如果你仍需要回车来提交表单，你可以通过以下方式解决： 123456789101112131415161718&lt;el-form :model=&quot;form&quot; ref=&quot;form&quot; label-width=&quot;200px&quot; class=&quot;form&quot; @submit.native.prevent=&quot;() =&gt; submit(&apos;form&apos;)&quot;&gt; &lt;el-form-item label=&quot;姓名&quot; prop=&quot;name&quot; &gt; &lt;el-input v-model.number=&quot;form.name&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type=&quot;primary&quot; native-type=&quot;submit&quot;&gt;提交&lt;/el-button&gt; &lt;el-button @click=&quot;reset(&apos;form&apos;)&quot;&gt;重置&lt;/el-button&gt; &lt;/el-form-item&gt;&lt;/el-form&gt; 请注意以下几点： 确保使用 @submit.native.prevent 阻止原生事件，执行方法为搜索按钮按click事件 搜索按钮需要被包裹在 el-form 中 移除搜索按钮的click事件 确保增加 native-type=”submit” 属性 此外，原生的form表单的单input和form包裹el-input回车刷新的问题也可以解决，有以下几种方法： 在form表单内再增加一个隐藏的input框，可以通过hidden定义隐藏的输入字段，或者通过CSS样式进行隐藏。 去掉输入框的回车事件（根据需求来定，有的需要回车事件提交表单来查询或者执行其他操作则该方法不适用）。 阻止表单默认提交事件。例如，使用onsubmit句柄返回false来阻止原生form内的input的默认提交事件。 v-model直接绑定到v-for迭代别名，这将无法修改v-for源数组12345678910111213&lt;view class=&quot;trip-item&quot; v-for=&quot;(item, index) in tripList&quot; :key=&quot;index&quot;&gt; &lt;input v-if=&quot;index === 0&quot; v-model=&quot;item&quot; @input=&quot;inputSpot&quot; @focus=&quot;focus(index)&quot; placeholder=&quot;请输入起点&quot; maxlength=&quot;32&quot; :auto-focus=&quot;autoFocus[0]&quot; /&gt; &lt;/view&gt;tripList: [&apos;&apos;, &apos;&apos;] 编译模板时出错：11:03:46.014＜input v-model=“item”＞：您正在将v-model直接绑定到v-for迭代别名。这将无法修改v-for源数组，因为写入别名就像修改函数的局部变量。请考虑使用对象数组，并在对象属性上使用v-model。 12Errors compiling template:11:03:46.014 &lt;input v-model=&quot;item&quot;&gt;: You are binding v-model directly to a v-for iteration alias. This will not be able to modify the v-for source array because writing to the alias is like modifying a function local variable. Consider using an array of objects and use v-model on an object property instead. 解决方案 12345:value=&quot;item&quot;inputSpot(e) &#123; this.tripList[this.inputIndex] = e.detail.value&#125;, vue2升级最高版Vue 2 的最高版本是 2.7.16，也被称为“Swan Song”（绝唱）版本。这个版本在 2023 年 12 月 24 日正式发布，标志着 Vue 2 的生命周期终点。从 2023 年 12 月 31 日起，Vue 官方将不再对 Vue 2 进行维护，而是将精力全部放在 Vue 3 的维护上。 Vue 2.7.16 版本修复了一些已知问题，并改进了与 Vue 3 的类型一致性。如果你正在使用 Vue 2，并且计划启动一个新项目，Vue 官方强烈建议从 Vue 的最新版本（即 Vue 3.x）开始。Vue 3 提供了许多新的特性和改进，可以帮助你构建更高效、更可维护的应用程序。 记得同时升级vue-template-compiler 1&quot;vue-template-compiler&quot;: &quot;^2.7.16&quot;, vue-template-compiler是什么，有什么用？是一个用于编译Vue模板的包，它的主要作用是将Vue模板预编译为渲染函数（template =&gt; ast =&gt; render），以避免运行时编译开销和CSP（内容安全策略）限制。 在Vue工程中，vue-template-compiler通常与vue-loader一起使用，特别是在Webpack构建过程中，vue-loader会使用vue-template-compiler来完成实际编译的繁重工作，例如.vue文件的编译。vue-template-compiler的两个主要功能是：将模板转换为render()函数和解析单个文件组件。 此外，由于Vue模板只是一个普通的字符串，Vue模板编译器的compile()函数可以转换这个模板字符串，使其可以作为render()函数为组件提供功能。 在构建Vue项目时，需要注意vue-template-compiler和vue的版本必须保持一致，否则可能会引发错误。 域名1获取到token，跳转到域名2实现自动登录，写出思路和完整代码要实现域名1获取到token，然后跳转到域名2实现自动登录，可以使用以下思路和代码实现： 在域名1上，用户登录成功后生成一个包含token的URL，并将该URL传递给域名2。 在域名2上，接收到包含token的URL后，提取出token的值。 在域名2上，发送一个POST请求到域名1的某个登录验证接口，将token作为参数，并且将withCredentials设置为true以允许跨域携带凭证（例如cookies）。 在域名1的登录验证接口上，验证token的合法性，并通过设置response header的Access-Control-Allow-Origin为域名2，允许来自域名2的跨域请求。 在域名2上，根据返回的响应结果进行相应的操作，例如登录成功则跳转到用户页面，登录失败则返回错误提示。 下面是一个可能的代码示例： 在域名1上的页面： 123456// 用户登录成功后生成包含token的URLvar token = 'abc123'; // 假设已经获取到了tokenvar redirectURL = 'http://domain2.com/login?token=' + token;// 域名1跳转到域名2window.location.href = redirectURL; 在域名2上的登录页面： vue 123456789101112// 带token跳转过来自动登录 async tokenLogin() &#123; console.log(this.$route.query) let access_token = this.$route.query.access_token if (access_token) &#123; utils.saveLogin(&#123; access_token &#125;) await this.dispathAuthorCode() this.$router.push(&#123; name: &apos;app&apos; &#125;) &#125; &#125; HTML 1234567891011121314151617181920212223// 提取URL中的token值var tokenIndex = location.href.indexOf('?token=') + '?token='.length;var token = location.href.substring(tokenIndex);// 发送跨域POST请求到域名1的登录验证接口var xhr = new XMLHttpRequest();xhr.withCredentials = true;xhr.open('POST', 'http://domain1.com/login-verify', true);xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; var response = JSON.parse(xhr.responseText); // 根据响应结果进行相应的操作，例如登录成功则跳转到用户页面 if (response.status === 'success') &#123; window.location.href = 'http://domain2.com/user'; // 假设用户页面URL为http://domain2.com/user &#125; else &#123; alert('登录失败：' + response.message); &#125; &#125;&#125;;// 发送POST请求，将token作为参数xhr.send('token=' + token); 在域名1的登录验证接口上，根据具体的后端语言和框架来实现验证token合法性的逻辑，并设置response header的Access-Control-Allow-Origin为域名2。例如，在PHP中可以这样实现： 123456&lt;?phpheader('Access-Control-Allow-Origin: http://domain2.com');$response = array();$token = $_POST['token'];// 验证token的合法性，在此处根据具体需求编写验证 file_type是数组[1,2]，代表选中两个按钮，这两个按钮可以多选，请用vue写出按钮点击公用事件（两个按钮最少选中一个，只剩下一个选中按钮时禁止取消）好的，下面是根据您的要求使用 Vue 来实现按钮点击公用事件的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt; &lt;div&gt; &lt;button v-for=\"button in buttons\" :key=\"button\" @click=\"buttonClick(button)\" :class=\"&#123; active: selectedButtons.includes(button) &#125;\"&gt; Button &#123;&#123; button &#125;&#125; &lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; buttons: [1, 2], // 可选按钮列表 selectedButtons: [] // 当前选中的按钮列表 &#125; &#125;, methods: &#123; buttonClick(button) &#123; // 判断按钮是否已选中 const selectedIndex = this.selectedButtons.indexOf(button); if (selectedIndex &gt; -1) &#123; // 如果按钮已选中 if (this.selectedButtons.length === 1) &#123; // 如果只剩下一个选中按钮，则禁止取消选中 return; &#125; // 取消选中按钮 this.selectedButtons.splice(selectedIndex, 1); &#125; else &#123; // 如果按钮未选中 // 添加选中按钮 this.selectedButtons.push(button); &#125; &#125; &#125;, mounted() &#123; // 默认选中第一个按钮 this.selectedButtons.push(this.buttons[0]); &#125;&#125;&lt;/script&gt; 在上述代码中，我使用了 v-for 指令来循环渲染按钮，通过 给每个按钮绑定 @click 事件监听点击事件。 在 buttonClick 方法内部，首先判断按钮是否已选中。如果已选中，再判断是否只剩下一个选中按钮，如果是，则禁止取消选中。如果按钮未选中，则将其添加到 selectedButtons 中。 启动后，默认选中了第一个按钮。 这样，就实现了通过公用事件控制多个按钮的选中状态，并满足了最少选中一个按钮、只剩下一个选中按钮时禁止取消的需求。 有个key每天有一定使用额度次数，因为是不同用户在使用，无法计数，只能通过接口报错知道key用完了，需要用另一个key来替换，请用vue实现这个逻辑。12345678910111213141516171819202122232425// 腾讯地图接口失败处理 tMapFail(err) &#123; // 模拟失败的测试数据 // err.status = 121 // err.message = &apos;此key每日调用量已达到上限&apos; // err.request_id = err.request_id console.log(&apos;腾讯地图接口失败&apos;, err); if (err.status === 121) &#123; uni.showToast(&#123; title: &apos;地图key每日上限，请退出此页面重试&apos;, icon: &apos;none&apos;, duration: 2500 &#125;) const setTime = Utils.formatDate(new Date()) console.log(setTime); // 如果接口报错达到上限，启用备用的key（下次onLaunch，如果超过一天，会使用原始的key） this.$store.commit(&apos;setMap&apos;, &#123; key: Config.backupMapKey, keyName: Config.mapKeyName, setTime &#125;) this.newMap() &#125; &#125; onLaunch重置 12345678910111213141516// 设置地图信息 setMapInfo(context) &#123; const setTime = Utils.getDateFromTimeString(this.state.login.map.setTime) const time = new Date() let day = (time - setTime) / (1000 * 60 * 60 * 24) console.log(setTime, time, day) // 如果第一次进入 或者 超过一天，使用原始的key if (!setTime || day &gt; 1) &#123; // 保存腾讯地图信息 context.commit(&apos;setMap&apos;, &#123; key: Config.mapKey, keyName: Config.mapKeyName, setTime: Utils.formatDate(time) &#125;); &#125; &#125;, vue2怎么通过dargList数组元素顺序的改变、是否选中，对应同步实现表格数据数组元素顺序的改变、是否存在，并使用localStorage缓存dargList数据123456789101112131415161718192021222324252627282930313233343536373839表格列数据listTableColumns: [ &#123; prop: &apos;behavior&apos;, label: &apos;敏感行为类型&apos;, fixed: &apos;left&apos;, showOverflowTooltip: true, minWidth: &apos;160&apos; &#125;, &#123; prop: &apos;msgContent&apos;, label: &apos;消息内容&apos;, minWidth: &apos;230&apos;, showOverflowTooltip: true &#125;, &#123; prop: &apos;senderName&apos;, label: &apos;发送人&apos;, minWidth: &apos;150&apos;, showOverflowTooltip: true &#125;, &#123; prop: &apos;option&apos;, label: &apos;操作&apos;, fixed: &apos;right&apos;, &#125;]拖拽组件数据（没有fixed列）dargList: [ &#123; prop: &apos;msgContent&apos;, label: &apos;消息内容&apos;, checked: true &#125;, &#123; prop: &apos;senderName&apos;, label: &apos;发送人&apos;, checked: false &#125;] 通义：在Vue 2中，根据dargList的顺序和选中状态同步更新listTableColumns数组，并且使用localStorage来缓存dargList，你可以采取以下步骤： 1. 初始化数据首先，确保listTableColumns和dargList初始化时正确关联，并从localStorage加载dargList（如果之前保存过）。 12345678910111213141516171819202122232425262728293031323334data() &#123; return &#123; listTableColumns: [ // 初始列配置... ], dargList: [], // 将从localStorage加载 columnMap: new Map(), // 用于快速查找列 &#125;;&#125;,mounted() &#123; this.loadFromLocalStorage(); this.syncListTableColumns();&#125;,methods: &#123; loadFromLocalStorage() &#123; const storedDargList = localStorage.getItem('dargList'); if (storedDargList) &#123; try &#123; this.dargList = JSON.parse(storedDargList); this.dargList.forEach(item =&gt; &#123; this.columnMap.set(item.prop, item); &#125;); &#125; catch (e) &#123; console.error(\"Error loading dargList from localStorage\", e); &#125; &#125; &#125;, syncListTableColumns() &#123; // 根据dargList同步listTableColumns this.listTableColumns = this.dargList .filter(item =&gt; item.checked) .map(check =&gt; this.columnMap.get(check.prop)); &#125;,&#125;, 2. 更新listTableColumns逻辑创建一个方法来根据dargList的当前状态更新listTableColumns。 12345678910111213141516171819202122methods: &#123; // ...其他方法 updateListTableColumns() &#123; // 首先，提取出所有动态列 const dynamicColumns = this.dargList .filter(item =&gt; item.checked) .map(check =&gt; this.columnMap.get(check.prop)); // 然后，从原始的listTableColumns中筛选出固定列 const fixedColumnsLeft = this.listTableColumns.filter(col =&gt; col.fixed === 'left'); const fixedColumnsRight = this.listTableColumns.filter(col =&gt; col.fixed === 'right'); // 合并固定列与动态列，保持固定列在相应位置 const updatedListTableColumns = [...fixedColumnsLeft, ...dynamicColumns, ...fixedColumnsRight]; // 更新listTableColumns this.listTableColumns = updatedListTableColumns; // 保存更新后的dargList到localStorage this.saveToLocalStorage(); &#125;,&#125;, 这段代码首先根据dargList中的选中状态和顺序提取出动态列，然后分别提取出原始listTableColumns中的左固定列和右固定列。接下来，将固定列与动态列按期望的顺序合并：先是左固定列，接着是动态列，最后是右固定列。这样，无论动态列如何排序，固定列都会保持在它们应有的位置上。 记得在适当的地方调用updateListTableColumns方法，比如在dargList变化时，以确保视图始终与数据同步。 3. 监听dargList变化使用watch来监听dargList的任何变化（包括排序或选中状态的改变），然后调用updateListTableColumns方法同步listTableColumns。 123456789watch: &#123; dargList: &#123; deep: true, handler() &#123; this.updateListTableColumns(); this.saveToLocalStorage(); &#125;, &#125;,&#125;, 4. 保存到localStorage创建一个方法来将更新后的dargList保存到localStorage。 123456methods: &#123; // ...其他方法 saveToLocalStorage() &#123; localStorage.setItem('dargList', JSON.stringify(this.dargList)); &#125;,&#125;, 注意事项 确保在拖拽排序或改变列的选中状态后调用updateListTableColumns和saveToLocalStorage方法。 columnMap是用来快速根据prop找到dargList中对应项的，确保在初始化和数据变化时保持同步。 注意localStorage的大小限制和安全性问题，避免存储敏感信息。 一个项目有很多表格，请优化缓存方案在一个项目中，如果有多张表格需要根据用户自定义进行列显示的调整并进行缓存，那么单独为每张表格使用localStorage进行缓存可能会导致存储空间迅速消耗和管理上的复杂性。针对这种情况，可以采取一些优化策略来改进缓存方案： 1. 使用统一的键名规则与命名空间为了避免键名冲突，可以为不同的表格设置统一的命名规则，如使用表格的唯一标识符（如ID或名称）作为前缀，后面跟上固定的字符串如_columns，形成独特的键名。例如，对于表格A，键名为tableA_columns。 2. 结构化缓存数据考虑到可能有多个表格的配置需要缓存，可以将所有表格的配置整合成一个对象，再整体存入localStorage，这样可以减少存储条目，易于管理和查找。 1234&#123; \"tableA\": [&#123;\"prop\": \"col1\", \"label\": \"列1\", \"checked\": true&#125;, ...], \"tableB\": [&#123;\"prop\": \"colX\", \"label\": \"列X\", \"checked\": false&#125;, ...]&#125; 3. 压缩数据由于localStorage存储容量有限，对于大量或复杂的配置数据，可以考虑使用JSON.stringify的第二个参数进行深度递归，移除循环引用和不必要的属性，或者使用如LZ-String之类的轻量级库对数据进行压缩后再存储，使用时解压。 4. 分页或懒加载如果单个表格的列配置非常庞大，可以考虑分页或懒加载策略来管理这些配置。只在用户实际查看或编辑某一页的列配置时，才从localStorage中读取或写入这部分数据。 5. 过期策略为缓存数据设置过期时间，比如用户的配置在一周后自动清空，促使用户重新定制，或者定期清理旧的、不再访问的表配置，以释放存储空间。 6. 使用IndexedDB替代如果localStorage的大小限制成为瓶颈，考虑使用IndexedDB作为替代。IndexedDB提供了更大的存储空间和更灵活的数据操作能力，支持索引和事务处理，适合存储结构化的大量数据。 7. 用户体验与反馈在实施缓存策略时，确保提供良好的用户体验，比如在用户更改配置后给予明确的保存成功提示，以及在数据恢复时的反馈，让用户知道他们的设置被记忆并应用了。 通过上述策略，可以在保证用户个性化体验的同时，有效管理存储资源，提升应用的性能和稳定性。 根据这个方案重写saveToLocalStorage，loadFromLocalStorage方法基于之前的讨论，我们来优化saveToLocalStorage和loadFromLocalStorage方法，以便在一个项目中管理多张表格的列配置。我们将使用统一的命名空间和结构化数据的方式来存储和读取缓存。 修改后的数据结构首先，假设每张表格的配置数据被组织在一个对象中，便于整体存取和管理： 123456789101112data() &#123; return &#123; allTableConfigs: &#123; tableA: &#123; /* 表格A的列配置 */ &#125;, tableB: &#123; /* 表格B的列配置 */ &#125;, // ... &#125;, &#125;, currentTableName: 'tableA', // 当前操作的表格标识 // 其他数据... &#125;;&#125;, 重写saveToLocalStorage123456789methods: &#123; saveToLocalStorage(tableName = this.currentTableName) &#123; if (!tableName) return; // 如果没有指定表格名，则不保存 const configKey = `$&#123;tableName&#125;_columns`; const configsToSave = &#123;&#125;; configsToSave[configKey] = this.allTableConfigs[tableName]; localStorage.setItem('tableConfigs', JSON.stringify(configsToSave)); &#125;,&#125;, 重写loadFromLocalStorage12345678910111213141516171819202122232425methods: &#123; loadFromLocalStorage(tableName = this.currentTableName) &#123; if (!tableName) return; // 如果没有指定表格名，则不加载 const configKey = `$&#123;tableName&#125;_columns`; const storedData = localStorage.getItem('tableConfigs'); if (storedData) &#123; try &#123; const parsedData = JSON.parse(storedData); if (parsedData[configKey]) &#123; this.allTableConfigs[tableName] = parsedData[configKey]; // 如果是当前表格，可能需要调用syncListTableColumns来更新视图 if (tableName === this.currentTableName) &#123; this.syncListTableColumns(); &#125; &#125; else &#123; console.warn(`No configuration found for table $&#123;tableName&#125; in localStorage.`); &#125; &#125; catch (error) &#123; console.error(\"Error parsing stored table configurations\", error); &#125; &#125; else &#123; console.log(\"No table configurations found in localStorage.\"); &#125; &#125;,&#125;, 注意事项 确保在适当的时候调用saveToLocalStorage(tableName)，比如在表格配置发生变化后。 loadFromLocalStorage(tableName)可以在组件的mounted生命周期钩子中调用，或在需要时手动调用来恢复用户上次的配置。 currentTableName应根据当前操作的表格动态设置，以确保加载和保存正确的配置。 考虑到性能和存储限制，对于非常大的配置，还是建议使用更高效的存储解决方案如IndexedDB。 通过这种方式，我们可以更高效和有序地管理多个表格的列配置缓存，同时保持代码的清晰和可维护性。 vue2通过route.name+该页面序号来命名tableName，保证项目中所有tableName不重复，代码怎么实现1this.tableName = this.config.name ? `$&#123;this.$route.name&#125;-$&#123;this.config.name&#125;` : this.$route.name 拖拽排序问题1234567891011121314拖拽排序方法this.listTableColumns = this.dargList .filter(item =&gt; item.checked) .map(check =&gt; this.columnMap.get(check.prop))第一个写法不能更新表格顺序&lt;el-table-column v-for=&quot;item in listTableColumns&quot; :key=&quot;item.uniqueKey&quot;第二个写法可以更新表格顺序，但是否选中时偶尔会错乱&lt;el-table-column v-for=&quot;(item, index) in listTableColumns&quot; :key=&quot;index&quot;怎么解决:key=&quot;`$&#123;item.uniqueKey&#125;-$&#123;index&#125;`&quot; 最终源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118data () &#123; return &#123; listTableColumns: [], // 初始其他正常列 dargList: [], // 拖拽列表数据 columnMap: new Map(), // 正常列键值对数据，用于快速查找列 tableConfigs: &#123; // tableA: [] // 表格A的列配置 &#125;, tableName: &apos;&apos;, // 当前操作的表格标识（整个项目唯一） selection: false, // 是否需要多选列 tableMaxHeight: 0 &#125; &#125;,/** * 初始化方法： * 1、处理多选列是否显示 */ init () &#123; // 初始化列的键值对数据 this.columns.forEach(item =&gt; &#123; if (item.prop) &#123; this.columnMap.set(item.prop, item) &#125; &#125;) // 如果我后期加了一列，怎么更新缓存？可以改个表名config.name this.tableName = this.config.name ? `$&#123;this.$route.name&#125;-$&#123;this.config.name&#125;` : this.$route.name let hasCache = false const storedData = localStorage.getItem(&apos;tableConfigs&apos;) if (storedData) &#123; try &#123; const parsedData = JSON.parse(storedData) this.tableConfigs = parsedData if (parsedData[this.tableName]) &#123; hasCache = true this.dargList = parsedData[this.tableName] &#125; else &#123; // console.warn(`没找到$&#123;this.tableName&#125;的缓存`) &#125; &#125; catch (error) &#123; // console.error(&apos;Error parsing stored table configurations&apos;, error) &#125; &#125; else &#123; // console.log(&apos;没有tableConfigs&apos;) &#125; // 多选列是否显示 if (this.initShow) &#123; this.selection = this.columns &amp;&amp; this.columns[0] &amp;&amp; this.columns[0].selection &#125; else &#123; // 目前pc-manage-archives都是false this.selection = this.columns.length &gt; 0 ? this.columns[0].selection : false &#125; // 深度复制columns数组 const uniqueKeyList = _.cloneDeep(this.columns) if (hasCache) &#123; // 有缓存直接更新视图 this.updateColumns() &#125; else &#123; // 没有缓存，则初始化 const checks = [] uniqueKeyList.forEach((item, index) =&gt; &#123; // 每个元素添加一个唯一key，其值为索引、prop属性（如果存在）和当前时间的毫秒表示的组合 item.uniqueKey = `$&#123;index&#125;$&#123;item.prop ? item.prop : &apos;-&apos;&#125;$&#123;Date.parse(new Date())&#125;` // 设置拖拽列表需要的数据（有键、不固定） if (item.prop &amp;&amp; !item.fixed) &#123; checks.push(&#123; prop: item.prop, label: item.label, checked: true &#125;) &#125; &#125;) this.dargList = checks if (this.selection) &#123; // 多选列显示 if (this.initShow) &#123; this.listTableColumns = this.remove(uniqueKeyList) &#125; else &#123; // 目前pc-manage-archives都是false // 多选列显示：将第一列给剔除掉，使用后续的数据来初始化正常列 const len = uniqueKeyList.length - 1 this.listTableColumns = uniqueKeyList.splice(1, len) // 对 Table 进行重新布局。当 Table 或其祖先元素由隐藏切换为显示时，可能需要调用此方法 this.$refs.listTable &amp;&amp; this.$refs.listTable.doLayout() &#125; &#125; else &#123; // 多选列不显示 this.listTableColumns = uniqueKeyList &#125; &#125; console.log(this.columns, uniqueKeyList, this.listTableColumns, this.dargList) &#125;, remove (list) &#123; return list.filter(e =&gt; e.selection !== true) &#125;, // 更新列数据 updateColumns () &#123; // 首先，提取出所有动态列 const dynamicColumns = this.dargList .filter(item =&gt; item.checked) .map(check =&gt; this.columnMap.get(check.prop)) // 然后，从原始的listTableColumns中筛选出固定列 const fixedColumnsLeft = this.columns.filter(col =&gt; col.fixed === &apos;left&apos;) const fixedColumnsRight = this.columns.filter(col =&gt; col.fixed === &apos;right&apos;) // 合并固定列与动态列，保持固定列在相应位置 const updatedListTableColumns = [...fixedColumnsLeft, ...dynamicColumns, ...fixedColumnsRight] // 更新listTableColumns this.listTableColumns = updatedListTableColumns console.log(this.listTableColumns, this.dargList) &#125;, // 保存列设置 saveColumns () &#123; this.updateColumns() this.tableConfigs[this.tableName] = this.dargList localStorage.setItem(&apos;tableConfigs&apos;, JSON.stringify(this.tableConfigs)) &#125;, ChatGPT：在Vue 2中，你可以通过拖拽组件的排序事件，然后更新表格的列顺序，并将更新后的列顺序存储到localStorage中。下面是一个简单的步骤指南和示例代码，展示如何实现这一功能： 步骤指南 拖拽组件的排序事件*：拖拽组件通常会有一个事件，当列的顺序改变时触发。你需要 *这个事件，并获取新的列顺序。 更新表格列的顺序：一旦你获得了新的列顺序，你需要更新表格的列定义，以反映这个新的顺序。 存储到localStorage：将更新后的列顺序存储到localStorage中，以便在下次页面加载时恢复这个顺序。 示例代码假设你的拖拽组件提供了一个onChange事件，当列的顺序改变时触发，并传递一个包含新顺序的列对象数组。 首先，在你的Vue组件中，你需要一个方法来处理这个事件并更新列的顺序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253export default &#123; data() &#123; return &#123; columns: [ // ... 你的初始列定义 ], sortColumns: [ // ... 你的初始拖拽组件列定义 ] &#125;; &#125;, methods: &#123; handleSortChange(newSortColumns) &#123; // 更新表格的列顺序 this.columns = newSortColumns.map(sortColumn =&gt; &#123; const originalColumn = this.columns.find(column =&gt; column.prop === sortColumn.prop); if (originalColumn) &#123; return originalColumn; &#125; // 如果没有找到匹配的列，可以返回一个默认列或进行错误处理 return null; &#125;).filter(column =&gt; column !== null); // 过滤掉null值 // 存储到localStorage localStorage.setItem('sortColumns', JSON.stringify(newSortColumns)); &#125;, loadSavedSortColumns() &#123; // 加载localStorage中保存的列顺序 const savedSortColumns = localStorage.getItem('sortColumns'); if (savedSortColumns) &#123; try &#123; this.sortColumns = JSON.parse(savedSortColumns); &#125; catch (e) &#123; // 解析错误处理 console.error('Error parsing saved sort columns:', e); &#125; &#125; &#125; &#125;, created() &#123; // 在组件创建时加载保存的列顺序 this.loadSavedSortColumns(); &#125;, watch: &#123; // ** sortColumns的变化，以便在需要时更新localStorage（如果你需要在其他时候手动更新localStorage） sortColumns: &#123; deep: true, handler() &#123; localStorage.setItem('sortColumns', JSON.stringify(this.sortColumns)); &#125; &#125; &#125;&#125;; 在你的模板中，你需要绑定onChange事件到你的拖拽组件： 1&lt;your-draggable-component :columns=\"sortColumns\" @change=\"handleSortChange\"&gt;&lt;/your-draggable-component&gt; 请注意，你需要替换&lt;your-draggable-component&gt;和相关的属性、事件为你实际使用的拖拽组件的标记和API。此外，确保你的拖拽组件确实提供了类似onChange的事件，并且传递了正确的数据。 注意事项 localStorage只能存储字符串，因此你需要使用JSON.stringify()来存储数组，以及JSON.parse()来解析存储的数据。 如果你的列定义除了prop之外还有其他重要的属性（如label、width等），你需要在handleSortChange方法中确保这些属性也被正确地复制到新的列定义中。 如果拖拽组件没有直接提供列顺序变化的事件，你可能需要手动计算或追踪列的顺序变化。 错误处理是很重要的，特别是当处理localStorage时，因为用户可能禁用了这个功能，或者存储的数据可能已损坏。 通过watch监听数组改变好？还是通过拖拽事件触发好？关于通过watch 监听 数组改变还是通过拖拽事件触发，这个问题的答案实际上取决于你的具体需求和场景。 通过watch 数组改变： 优点： 可以自动捕获数组的任何变化，无需手动触发事件。 可以方便地执行与数组变化相关的逻辑。 缺点： 如果数组变化频繁，可能会导致性能问题，因为watch可能会多次触发。 如果只是关心特定的变化（例如，数组的某个特定元素的改变），watch可能不是最高效的方法。 通过拖拽事件触发： 优点： 可以精确地控制何时触发事件，只在用户进行拖拽操作时发生。 可以方便地获取拖拽的详细信息（如拖拽的起始位置、结束位置等）。 缺点： 需要手动编写拖拽事件的 ** 和处理逻辑。 如果拖拽逻辑复杂，可能需要更多的代码来维护。 建议： 如果你的应用主要依赖于数组的变化来执行某些操作，并且这些操作不需要精确地与用户的拖拽行为绑定，那么使用watch来监听数组的变化可能更为方便。 如果你的应用需要精确地响应用户的拖拽行为，并且拖拽操作与数组的变化紧密相关，那么通过拖拽事件触发可能更为合适。 总之，选择哪种方法取决于你的具体需求和场景。在实际开发中，可以根据应用的实际情况进行选择和调整。 vue2二维码列表通过v-for循环出来，并通过数组来管理每个二维码的显示状态，首次只展示第一张二维码，其他二维码通过用户点击事件获取，每个二维码从创建开始，倒计时5分钟后为不显示状态123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114 &lt;img class=&quot;code&quot; v-if=&quot;item.countdown&gt;0&quot; :src=&quot;item.codeUrl&quot; alt=&quot;&quot; @click=&quot;showImg(item.codeUrl)&quot; /&gt; &lt;img class=&quot;mask&quot; v-else src=&quot;@/assets/images/employee-group/mask@2x.png&quot; alt=&quot;&quot; /&gt; &lt;div class=&quot;btn&quot; v-if=&quot;item.countdown===0&quot; @click=&quot;getQRCode(item)&quot;&gt;获取我的二维码&lt;/div&gt;data() &#123; return &#123; groupList: [ &#123; empGroupId: 11111, empGroupName: &apos;名称1：&apos;, status: 1, codeUrl: require(&apos;@/assets/images/employee-group/code.png&apos;) &#125;, &#123; empGroupId: 22222, empGroupName: &apos;名称2：&apos;, status: 0, codeUrl: &apos;&apos; &#125; ], isCountingDown: false, // 控制倒计时是否正在进行 globalCountdownId: null, // 用于存储全局倒计时的ID countdownLimit: 10, // 倒计时总时长限制，单位：秒 &#125; &#125;, computed: &#123; // 获取当前最大的倒计时，即只要有一个倒计时大于0，表示还不能结束 countdownMax() &#123; return this.groupList.reduce( (max, item) =&gt; Math.max(max, item.countdown), 0 ) &#125; &#125;, watch: &#123; // 监听countdownMax变化 countdownMax(newMax) &#123; if (newMax &gt; 0 &amp;&amp; !this.isCountingDown) &#123; // 当有倒计时 且 尚未启动倒计时器时启动 this.startGlobalCountdown() &#125; else if (newMax === 0 &amp;&amp; this.isCountingDown) &#123; // 倒计时全部结束，停止倒计时器 this.stopGlobalCountdown() &#125; &#125; &#125;, created() &#123; // 初始化倒计时 this.groupList.forEach((item, index) =&gt; &#123; if (index === 0) &#123; // 首次只展示第一张二维码 item.countdown = this.countdownLimit &#125; else &#123; item.countdown = 0 &#125; &#125;) &#125;, beforeDestroy() &#123; // 组件销毁时，确保清除倒计时 this.stopGlobalCountdown() &#125;, methods: &#123; // 启动倒计时 startGlobalCountdown() &#123; console.log(&apos;启动倒计时&apos;, this.groupList) this.isCountingDown = true this.globalCountdownId = setInterval(() =&gt; &#123; this.updateQrCodesCountdown() // 检查是否所有倒计时已结束 if (this.groupList.every((item) =&gt; item.countdown === 0)) &#123; this.stopGlobalCountdown() &#125; &#125;, 1000) &#125;, // 更新倒计时 updateQrCodesCountdown() &#123; // 使用了数组的map方法来创建新的数组对象，避免了直接修改响应式依赖项的问题 this.groupList = this.groupList.map((item) =&gt; &#123; if (item.countdown &gt; 0) &#123; return &#123; ...item, countdown: item.countdown - 1 &#125; &#125; return item &#125;) console.log(&apos;当前最大的倒计时&apos;, this.countdownMax) &#125;, // 停止倒计时 stopGlobalCountdown() &#123; console.log(&apos;停止倒计时&apos;) clearInterval(this.globalCountdownId) this.isCountingDown = false this.globalCountdownId = null &#125;, // 图片预览 showImg(codeUrl) &#123; this.previewImages = [codeUrl] // this.previewImages = [this.$kaCommonUtils.file.getFileUrl(codeUrl)] this.isPreview = true &#125;, // 获取二维码 getQRCode(item) &#123; // 请求接口获取图片，开启倒计时 item.codeUrl = require(&apos;@/assets/images/employee-group/code.png&apos;) item.countdown = this.countdownLimit &#125;, &#125;","categories":[{"name":"前端问题","slug":"前端问题","permalink":"https://qw8.github.io/categories/前端问题/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://qw8.github.io/tags/vue/"},{"name":"前端","slug":"前端","permalink":"https://qw8.github.io/tags/前端/"}]},{"title":"vue问题","slug":"questions/vue问题","date":"2022-05-21T15:40:25.000Z","updated":"2024-06-06T02:20:20.510Z","comments":true,"path":"/questions/vue-wen-ti.html","link":"","permalink":"https://qw8.github.io/questions/vue-wen-ti.html","excerpt":"","text":"【VueJS】实例中data属性的三种写法及区别12345678&lt;script type=&quot;text/javascript&quot;&gt; var app=new Vue(&#123; el:&apos;#app&apos;, data:&#123; isLogin: false &#125; &#125;)&lt;/script&gt; 12345678910&lt;script type=&quot;text/javascript&quot;&gt; var app=new Vue(&#123; el:&apos;#app&apos;, data: function()&#123; return &#123; isLogin: false &#125; &#125; &#125;)&lt;/script&gt; 12345678910&lt;script type=&quot;text/javascript&quot;&gt; var app=new Vue(&#123; el:&apos;#app&apos;, data() &#123; return &#123; isLogin: false &#125; &#125; &#125;)&lt;/script&gt; 第3种是第2种的ES6写法 区别 1）在简单的Vue实例中，没什么区别，因为你app对象不会被复用。 1var app = new Vue(&#123;...&#125;) 2）但是在组件中，因为可能在多处调用同一组件，所以为了不让多处的组件共享同一data对象，只能返回函数。 1234567export default&#123; data()&#123; return &#123; ... &#125; &#125;&#125; 总结日期：2019.11.27 自定义路径别名 assets和static文件夹的区别相信有很多人知道vue-cli有两个放置静态资源的地方，分别是src/assets文件夹和static文件夹,这两者的区别很多人可能不太清楚。 assets目录中的文件会被webpack处理解析为模块依赖，只支持相对路径形式。例如，在 &lt;img src=&quot;./logo.png&quot;&gt;和background: url(./logo.png)中，”./logo.png” 是相对的资源路径，将由Webpack解析为模块依赖。 static/ 目录下的文件并不会被Webpack处理：它们会直接被复制到最终的打包目录（默认是dist/static）下。必须使用绝对路径引用这些文件，这是通过在 config.js 文件中的 build.assetsPublicPath 和 build.assetsSubDirectory 连接来确定的。 任何放在 static/ 中文件需要以绝对路径的形式引用：/static/[filename]。 在我们实际的开发中，总的来说：static放不会变动的文件 assets放可能会变动的文件。 vue项目有两个地方可以存放静态资源。一个是assets文件夹，一个是static文件夹（地址栏输入static可以直接访问）。放到static里面webpack打包后只会把资源复制到发布目录而不会把小图片优化为base64。而assets内的资源会被webpack打包,比如图片,会被转为BASE64。为了兼顾图片资源优化，所以还是不适合把图片资源放到static。 assets 里面的图片是会经过 webpack 的 loader 处理的，而 static 里面的图片是被直接复制到 dist/static 下面的。 总结日期：2019.11.27 在js数据中用 requier 的方法引用图片因为webpack会将图片当做模块来引用，所以在js中需要使用require将图片引用进来，不能直接以字符串的形式。 123456789js部分：data () &#123; return&#123; imgUrl: &apos;图片地址&apos;,//错误写法 imgUrl: require(&apos;图片地址&apos;)//正确的写法 &#125;&#125;template部分：img标签形式：&quot;img&quot;/&gt;或者p背景图形式：&quot;&#123;backgroundImage: &apos;url(&apos; + img + &apos;)&apos;&#125;&quot;&gt; 因为webpack会将图片当做模块来引用，所以在js中需要使用require将图片引用进来，而不是直接以字符串的形式。 node编程中最重要的思想就是模块化，import和 require都是被模块化所使用。 遵循规范 require是 AMD 规范引入方式 import是 ES6 的一个新的语法标准，如果要兼容浏览器的话必须转化成 ES5 的语法 调用时间 require 是在运行时调用，所以 require 理论上可以放在代码的任何地方 import 是在编译时调用，所以必须放在文件开头 本质 require 是赋值过程，其实 require 的结果就是对象、数字、字符串、函数等，再把 require 的结果赋值给某个变量 import 是解构过程，但是目前所有的引擎都还没有实现 import，我们在 node 中使用 babel 支持 ES6，也仅仅是将 ES6 转码为 ES5 再执行，import 语法会被转码为 require 总结日期：2019.11.27 –save-dev和–save的区别当你使用--save-dev或者-S，安装依赖的时候就会放在package.json的devDependencies对象下面，相反的，当你使用--save，安装依赖的时候就会出现在dependencies对象下面。 –save-dev 是你开发时候依赖的东西，–save 是你发布之后还依赖的东西。 总结日期：2019.11.27 创建vue项目完整流程1. 选定路径，新建vue项目test12npm install vue-cli -gvue init webpack test 一级文件夹： build：主要是用来配置构建项目以及webpack config:项目开发配置 node_modules ：npm或者cnpm或者yarm所下载的依赖包。 src:你的源代码 assets：存放资源文件，例如css、js、image公共文件 components：存放公共组件，例如menu、tabBar、sideBar等组件 static:静态文件夹 test：测试，一般可以删掉。 index.html ：最外层的页面一般title等都设置在这里。 package.json ：存放你要依赖包的json数据。 现在我们来看看HelloWorld.vue这个页面，这里js，css的代码放置格式它已经帮你写出来了，按照这种格式写就行了，需要提醒的就是style标签中的scoped属性，如果没写这条那么这个style的样式会影响到这个页面所有的子路由，如果加了那么这个样式只对当前页面起作用。 简单介绍一下routers中的结构，这里主要用来配置路由的，上面说过所有子路由都在App.vue下，所有App.vue是最外层的父路由，这里的routes中存的就是路由的数组，path就是你要访问你所创建的页面的路径，name想到与给它命名这个比较无关紧要，component相当于你要引用的页面，这里引用的是HelloWorld.vue这个页面，主要上面的import，这里的HelloWorld是一个变量，对应上面的路径文件。 router-link组件是用来跳转路由的，to属性是将要跳转的路由页地址。 router-view组件是用来展示组件页的。 编程式导航，也就是说通过js控制跳转路由页。 $route.query来获取URL 查询参数，例如你有一个路由地址：/detail?id=100，则有 let id= $route.query.id || -1，如果没有查询参数，则默认给了个-1的数值。 了解vue-router的history和hash两种模式。 2.npm start运行项目，浏览器打开http://localhost:80803.路由目录下文件index.js改成动态加载，@为src文件夹。12345&#123; path: &apos;/&apos;, name: &apos;HelloWorld&apos;, component:()=&gt;import(&quot;@/components/HelloWorld&quot;)&#125;, 4.安装所需依赖工具1234cnpm install element-ui -Scnpm install node-sass@4.13.0 -Scnpm install sass-loader@7.1.0 -Scnpm install axios -S 5.src下新建api文件夹，用于api统一管理和封装axios新建api.js 12345//集中管理所有api，可以增加export default &#123; LOGIN:&quot;/api/admin/login&quot;, UPLOAD:&quot;/api/upload/upload&quot;,&#125; 新建init.js 12345678910111213141516171819202122232425262728293031323334//初始化配置import axios from &quot;axios&quot;;import &#123;Message&#125; from &apos;element-ui&apos;;//单独引用messageconst instance = axios.create(&#123; timeout: 3000&#125;);// 添加请求拦截器instance.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 if (sessionStorage.getItem(&quot;token&quot;)) &#123; config[&quot;headers&quot;]=&#123; &quot;X_ACCESS_TOKEN&quot;:sessionStorage.token &#125;; &#125; return config;&#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error);&#125;);instance.interceptors.response.use(function (response) &#123; // 对响应数据做点什么 if (response.data.code !== 200) &#123; Message.error(response.data.msg); &#125; return response;&#125;, function (error) &#123; // 对响应错误做点什么 Message.error(&quot;服务器错误&quot;); return Promise.reject(error);&#125;);export &#123;instance&#125;; 新建methods.js 1234567891011121314151617181920212223242526272829303132//封装请求方法import &#123;instance&#125; from &quot;./init&quot;;export default &#123; get(url,data=&#123;&#125;)&#123; return instance(&#123; method:&quot;get&quot;, url, params:data &#125;) &#125;, post(url,data=&#123;&#125;)&#123; return instance(&#123; method:&quot;post&quot;, url, data &#125;) &#125;, put(url,data=&#123;&#125;)&#123; return instance(&#123; method:&quot;put&quot;, url, data &#125;) &#125;, delete(url,data=&#123;&#125;)&#123; return instance(&#123; method:&quot;delete&quot;, url, params:data &#125;) &#125;&#125; 6.配置mian.js1234567891011121314151617181920212223import Vue from &apos;vue&apos;import App from &apos;./App&apos;import router from &apos;./router&apos;import ElementUI from &apos;element-ui&apos;;import &apos;element-ui/lib/theme-chalk/index.css&apos;;import axios from &quot;./api/methods&quot;;//引入请求插件import api from &quot;./api/api&quot;;//引入api文件//全局注册到vue原型上Vue.prototype.$axios = axios;Vue.prototype.$api = api;Vue.config.productionTip = false;//阻止vue启动时生成生产提示Vue.use(ElementUI);//安装vue插件/* eslint-disable no-new */new Vue(&#123; el: &apos;#app&apos;, router, components: &#123; App &#125;, template: &apos;&lt;App/&gt;&apos;&#125;); 7.修改App.vue默认样式12345678910111213141516171819&lt;style&gt; #app &#123; font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; height: 100%; &#125; html, body &#123; width: 100%; height: 100%; &#125; * &#123; margin: 0; padding: 0; list-style: none; &#125;&lt;/style&gt; 8.新建vue.config.js文件1234module.exports = &#123; //所有的资源都会被链接为相对路径，这样打包出来可以被部署在任意路径 publicPath:&quot;./&quot;&#125;; 总结日期：2019.11.27 vue项目让局域网ip访问配置设置在开发中，为了让同一局域网的小伙伴，都可以通过IP地址访问到vue-cli搭建的项目，要怎么配置呢? 第一步：修改config文件夹中 index.js 文件里面的host改成 ‘0.0.0.0’，关闭开发机防火墙 *第二步：命令行输入ipconfig，查看开发机的ip地址，并告诉给其他小伙伴，IP地址+端口，如 http://192.168.1.87:8080/#/ * 总结日期：2019.12.2 行内样式绑定1234567891011121314151617:style=&quot;&#123; width: activewidth &#125;&quot;data: () =&gt; (&#123; collapse: false, activewidth: &quot;200px&quot; &#125;),methods: &#123; //导航栏伸缩 toggleMenu() &#123; this.collapse = !this.collapse; if (this.collapse) &#123; this.activewidth = &quot;72px&quot;; &#125;else &#123; this.activewidth = &quot;200px&quot;; &#125; &#125;,&#125; 总结日期：2019.12.2 手机号和图片上传的验证规则1thumb: &#123;required: true, message: &quot;请上传缩略图&quot;&#125;, 常用的验证对图片上传通不过，所以写个验证规则简单方便。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;el-form :model=&quot;form&quot; :rules=&quot;rules&quot; ref=&quot;loginForm&quot; :status-icon=&quot;true&quot;&gt; &lt;el-form-item prop=&quot;username&quot;&gt; &lt;el-input v-model=&quot;form.username&quot; placeholder=&quot;请输入手机号&quot; prefix-icon=&quot;el-icon-user&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;学生照片&quot; prop=&quot;avatorId&quot;&gt; &lt;!-- 头像type=1,--&gt; &lt;el-upload drag class=&quot;avatar-uploader&quot; :data=&#123;type:1&#125; :action=&quot;upload&quot; :show-file-list=&quot;false&quot; :on-success=&quot;handleAvatarSuccess&quot; :before-upload=&quot;beforeAvatarUpload&quot;&gt; &lt;img v-if=&quot;this.form.avatorId&quot; :src=&quot;studentImg&quot; class=&quot;avatar&quot;&gt; &lt;i v-else class=&quot;el-icon-plus avatar-uploader-icon&quot;&gt;&lt;/i&gt; &lt;/el-upload&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;扣课时数&quot; prop=&quot;useNumber&quot;&gt; &lt;el-input v-model=&quot;form.useNumber&quot; type=&quot;number&quot; placeholder=&quot;请输入扣课时数&quot; clearable style=&quot;width: 46%&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt;&lt;/el-form&gt; data() &#123; //手机号验证规则 let checkPhone = (rule, value, callback) =&gt; &#123; if (!value) &#123; return callback(new Error(&apos;手机号不能为空&apos;)); &#125; else &#123; const reg = /^1[3|4|5|7|8][0-9]\\d&#123;8&#125;$/ // console.log(reg.test(value)); if (reg.test(value)) &#123; callback(); &#125; else &#123; return callback(new Error(&apos;请输入正确的手机号&apos;)); &#125; &#125; &#125;; //图片上传验证规则 let checkAvator = (rule, value, callback) =&gt; &#123; if (!this.form.avatorId) &#123; callback(new Error(&apos;请上传图片&apos;)); &#125; else &#123; callback(); &#125;&#125;; //正整数验证规则 let checkNum = (rule, value, callback) =&gt; &#123; if (Number.isInteger(Number(value)) &amp;&amp; Number(value) &gt; 0 &amp;&amp; Number(value) &lt; 10001) &#123; callback() &#125; else &#123; callback(new Error(&apos;请输入1-10000的正整数&apos;)) &#125; &#125;; return &#123; form: &#123; username: &quot;&quot;, avatorId:&quot;&quot;, useNumber:&quot;&quot; &#125;, rules: &#123; username: [ &#123;required: true, message: &quot;手机号不能为空&quot;, trigger: &quot;blur&quot;&#125;, &#123;validator: checkPhone, trigger: &quot;blur&quot;&#125; ], avatorId: &#123;required: true, message: &quot;请上传学生照片&quot;,validator: checkAvator,trigger:&quot;change&quot;&#125;, useNumber: [&#123;required: true, message: &quot;请输入扣课时数&quot;, trigger: &quot;blur&quot;&#125;, &#123;validator: checkNum, trigger: &quot;blur&quot;&#125;], &#125; &#125; &#125;, 总结日期：2019.12.2 vuex使用1.安装 1cnpm install vuex -S 2.浏览器安装扩展程序Vue.js devtools 3.在src文件夹下创建一个store.js文件 123456789101112131415161718192021222324import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex);//要设置的全局访问的state对象const state = &#123; count: 0&#125;;const mutations = &#123;//自定义改变state初始值的方法，这里面的参数除了state之外还可以再传额外的参数(变量或对象); mutationsAddCount(state, n = 0) &#123; return (state.count += n) &#125;, mutationsReduceCount(state, n = 0) &#123; return (state.count -= n) &#125;&#125;export default new Vuex.Store(&#123; state, mutations&#125;) 4.在main.js中引入 123456789import store from &quot;./store&quot;;//引入vuexnew Vue(&#123; el: &apos;#app&apos;, router, store, components: &#123; App &#125;, template: &apos;&lt;App/&gt;&apos;&#125;); 5.在组件中引用 1&lt;h3&gt;&#123;&#123;$store.state.count&#125;&#125;&lt;/h3&gt; 总结日期：2019.12.3 全局导航守卫和退出123456789101112131415router.beforeEach((to, from, next) =&gt; &#123; //如果已经登陆或者本来就是登陆页面就不拦截 if (window.sessionStorage.getItem(&quot;userId&quot;) || to.name === &quot;login&quot;) &#123; next(); &#125; else &#123; //要跳转的不是login就强制跳到login，避免了直接访问内部路径，更加安全 next(&#123;name: &quot;login&quot;&#125;) &#125;&#125;);logout() &#123; //清除全部缓存，导航守卫自动跳到登陆页面 sessionStorage.clear(); location.reload();&#125; 总结日期：2019.12.3 数组或对象遍历渲染页面12345678910111213141516171819202122232425262728293031323334&lt;el-col class=&quot;circle&quot; v-for=&quot;(value, key) in items&quot; :key=&quot;key&quot;&gt; &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/el-col&gt; items: &#123; a: &apos;苹果&apos;, b: &apos;凤梨&apos;, c: &apos;香蕉&apos;&#125; &lt;!-- 班级详情循环数组渲染--&gt; &lt;el-col :span=&quot;6&quot; v-for=&quot;Details in classesDetailsList&quot; :key=&quot;Details.classesId&quot; class=&quot;circle&quot; :class=&quot;&#123; &apos;daban&apos;:Details.classesCategoryId===1||Details.classesCategoryId===4,&apos;zhoban&apos;:Details.classesCategoryId===2,&apos;xiaoban&apos;:Details.classesCategoryId===3&#125;&quot;&gt; &lt;h5&gt;&#123;&#123;Details.categoryName&#125;&#125;&lt;/h5&gt; &lt;pre&gt; 名称： &#123;&#123;Details.classesName&#125;&#125; 人数： &#123;&#123;Details.totalCount&#125;&#125;人 比例: 男&#123;&#123;Details.boyCount&#125;&#125;、女&#123;&#123;Details.girlCount&#125;&#125; 教师:&#123;&#123;Details.teacherName&#125;&#125; &lt;/pre&gt; &lt;el-row&gt; &lt;el-button icon=&quot;el-icon-edit&quot; @click=&quot;edit(Details.classesId)&quot; circle size=&quot;mini&quot; style=&quot;border: none&quot;&gt;&lt;/el-button&gt;&lt;!-- 总人数等于0才能删除--&gt; &lt;el-button icon=&quot;el-icon-delete&quot; v-if=&quot;Details.totalCount===0&quot; @click=&quot;del(Details.classesId)&quot; circle size=&quot;mini&quot; style=&quot;border: none&quot;&gt;&lt;/el-button&gt; &lt;el-button icon=&quot;el-icon-delete&quot; v-else disabled @click=&quot;del(Details.classesId)&quot; circle size=&quot;mini&quot; style=&quot;border: none&quot;&gt;&lt;/el-button&gt; &lt;/el-row&gt; &lt;/el-col&gt; 总结日期：2019.12.5 vue点击图片预览放大（可旋转、翻转、缩放、上下切换、键盘操作）因项目需求（ui框架element-ui），需要实现图片的点击放大，还要能旋转以及上下切换。适合vue的插件，viewerjs的GitHub地址：https://github.com/fengyuanchen/viewerjs 说实话，它的功能还是很多很强大的，大家可以自己去看。主要使用的旋转、翻转、缩放、上下切换、键盘操作等功能都有。 1、安装 1cnpm install v-viewer -S 2、安装完main.js中引用（还要记得引用它的css样式） 12import Viewer from 'v-viewer';import 'viewerjs/dist/viewer.css'; 3、vue注册调用，再调用setDefaults方法，根据自己项目需求配置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//注册调用图片展示插件Vue.use(Viewer);Viewer.setDefaults(&#123; 'inline':false,//true会直接打开大图模式 'button':true, //右上角按钮 \"navbar\": true, //底部缩略图 \"title\": true, //当前图片标题 \"toolbar\": true, //底部工具栏 \"tooltip\": true, //显示缩放百分比 \"movable\": true, //是否可以移动 \"zoomable\": true, //是否可以缩放 \"rotatable\": true, //是否可旋转 \"scalable\": true, //是否可翻转 \"transition\": true, //使用 CSS3 过度 \"fullscreen\": true, //播放时是否全屏 \"keyboard\": true, //是否支持键盘 \"url\": \"data-source\", //以下方法如果不需要自定义可以不写 ready: function (e) &#123; console.log(e.type,'组件以初始化'); &#125;, show: function (e) &#123; console.log(e.type,'图片显示开始'); &#125;, shown: function (e) &#123; console.log(e.type,'图片显示结束'); &#125;, hide: function (e) &#123; console.log(e.type,'图片隐藏完成'); &#125;, hidden: function (e) &#123; console.log(e.type,'图片隐藏结束'); &#125;, view: function (e) &#123; console.log(e.type,'视图开始'); &#125;, viewed: function (e) &#123; console.log(e.type,'视图结束'); // 索引为 1 的图片旋转20度 if(e.detail.index === 1)&#123; this.viewer.rotate(20); &#125; &#125;, zoom: function (e) &#123; console.log(e.type,'图片缩放开始'); &#125;, zoomed: function (e) &#123; console.log(e.type,'图片缩放结束'); &#125;&#125;); 表格说明： 名称 默认值 说明 inline false 启用 inline 模式 button true 显示右上角关闭按钮 navbar true 显示缩略图导航 title true 显示当前图片的标题 toolbar true 显示工具栏 tooltip true 显示缩放百分比 movable true 图片是否可移动 zoomable true 图片是否可缩放 rotatable true 图片是否可旋转 scalable true 图片是否可翻转 transition true 使用 CSS3 过度 fullscreen true 播放时是否全屏 keyboard true 是否支持键盘 url src 设置大图片的 url 图片说明： img 4、代码中使用 12345678&lt;viewer :images=\"images\" style=\"margin: 10px 0\"&gt; &lt;img v-for=\"item in images\" :src=\"item.src\" :key=\"item.index\" height=\"100\" style=\"width:97px; margin-right: 10px\"&gt;&lt;/viewer&gt;//data中定义images:[ &#123;src:'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3272199364,3404297250&amp;fm=26&amp;gp=0.jpg',index:1&#125;, &#123;src:'https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=3267295166,2381808815&amp;fm=26&amp;gp=0.jpg',index:2&#125;, &#123;src:'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3429654663,2972188411&amp;fm=26&amp;gp=0.jpg',index:3&#125;, &#123;src:'https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=3597323878,2962972725&amp;fm=26&amp;gp=0.jpg',index:4&#125;], 总结日期：2019.12.6 element-ui日期格式化（如何保存数据库中）一，日期格式为yyyy-mm-dd1，项目中需要的日期格式为yyyy-mm-dd，但是我们在使用的element-ui的 日期选择器后默认的时间格式为 1Fri Sep 07 2018 00:00:00 GMT+0800 (中国标准时间) 2，datepicker中添加一句value-format=”yyyy-MM-dd” 即可 123456&lt;el-date-picker v-model=&quot;editForm.birthday&quot; type=&quot;date&quot; value-format=yyyy-MM-dd placeholder=&quot;请选择日期&quot;&gt;&lt;/el-date-picker&gt; 3，格式化为时间戳datepicker中添加一句value-format=“timestamp” 即可 123456&lt;el-date-picker v-model=&quot;formInline.timeStart&quot; type=&quot;datetime&quot; placeholder=&quot;选择日期时间&quot; value-format=&quot;timestamp&quot;&gt;&lt;/el-date-picker&gt; 总结日期：2019.12.9 element-ui无法正常显示绑定值1.element-ui Radio 单选框组件默认值选不中？ 常是由于数据类型的问题导致，如数字/布尔等类型，比如请求返回的值是 radio = 1，而组件是这样写的： 1234&lt;template&gt; &lt;el-radio v-model=&quot;radio&quot; label=&quot;1&quot;&gt;备选项1&lt;/el-radio&gt; &lt;el-radio v-model=&quot;radio&quot; label=&quot;2&quot;&gt;备选项2&lt;/el-radio&gt;&lt;/template&gt; 此时label是字符串1， 而请求返回值是数字1，由于两者不匹配，于是该Radio单选框组件默认值就选不中备选项1 解决办法： 我们只要保证label的值和请求返回的值完全一样即可，如radio有数字有字符串，那么我们可以将请求返回值radio全转换为字符串即可。 若radio全是数字，我们仅需在label前加: 即可, 这样label中的值会被当成js元素来执行，1就变成了数字。 2.表单绑定选择器可能是数据库传过来是整型，文档默认为字符串 12345678options: [&#123; value: 1, label: &apos;男&apos;&#125;, &#123; value: 2, label: &apos;女&apos;&#125;] 3.switch开关绑定自定义数字1,2 123456789&lt;el-form-item label=&quot;是否可登陆&quot; prop=&quot;isUsable&quot;&gt; &lt;el-switch v-model=&quot;editForm.isUsable&quot; :active-value=1 :inactive-value=2 active-color=&quot;#13ce66&quot; inactive-color=&quot;#ff4949&quot;&gt; &lt;/el-switch&gt;&lt;/el-form-item&gt; 总结日期：2019.12.9 Vue 使用element-ui步骤条流程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;el-dialog title=&quot;添加学生&quot; :visible.sync=&quot;dialogVisible&quot;&gt; &lt;!--步骤条--&gt; &lt;el-steps :active=&quot;active&quot; finish-status=&quot;success&quot;&gt; &lt;el-step title=&quot;基本信息&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;其他信息&quot;&gt;&lt;/el-step&gt; &lt;/el-steps&gt; &lt;!--第一步，基本信息--&gt; &lt;el-form :model=&quot;addForm&quot; ref=&quot;addForm&quot; :rules=&quot;addRules&quot; label-width=&quot;100px&quot; v-if=&quot;active===1&quot;&gt; &lt;el-form-item label=&quot;姓名&quot; prop=&quot;name&quot;&gt; &lt;el-input v-model=&quot;addForm.name&quot; placeholder=&quot;请输入姓名&quot; clearable suffix-icon=&quot;el-icon-edit&quot; style=&quot;width: 65%&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;!--第二步，其他信息--&gt; &lt;el-form :model=&quot;addForm&quot; ref=&quot;addForm&quot; :rules=&quot;addRules&quot; label-width=&quot;100px&quot; v-if=&quot;active===2&quot;&gt; &lt;el-form-item label=&quot;手机号&quot; prop=&quot;phone&quot;&gt; &lt;el-input v-model=&quot;addForm.phone&quot; placeholder=&quot;该手机号为教师登录账号，密码会短信通知&quot; clearable suffix-icon=&quot;el-icon-edit&quot; style=&quot;width: 65%&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;!--上一步，下一步按钮--&gt; &lt;el-button @click=&quot;dialogVisible = false&quot; v-if=&quot;active===1&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;next&quot; v-if=&quot;active===1&quot;&gt;下一步&lt;/el-button&gt; &lt;el-button @click=&quot;prev&quot; v-if=&quot;active===2&quot;&gt;上一步&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;addSubmit&quot; v-if=&quot;active===2&quot;&gt;确 定&lt;/el-button&gt; &lt;/div&gt;&lt;/el-dialog&gt;data中定义active: 1,//打开默认第一步methods中定义方法//步骤条:上一步，下一步prev() &#123; --this.active; if (active &lt; 1) &#123; this.active = 1; &#125;&#125;,next() &#123; if (this.active++ &gt; 2) &#123; this.active = 1; &#125;&#125;, 总结日期：2019.12.9 改Element-UI默认样式不生效去掉scoped就可以显示样式，但此时会污染全局样式。 加一个该组件特定父类，避免全局变量污染 总结日期：2019.12.10 Element-UI的Backtop回到顶部1&lt;el-backtop target=&quot;.el-main&quot;&gt;&lt;/el-backtop&gt; 返回页面顶部的操作按钮 target为触发滚动的对象，挂载点需要是一个滚动区域（可设置高度。overflow-y：scroll） 总结日期：2019.12.10 图片上传123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;el-form-item label=&quot;照片&quot; prop=&quot;avatorId&quot;&gt; &lt;el-upload drag class=&quot;avatar-uploader studentimg&quot; :data=&quot;upLoadData&quot; :action=&quot;upload&quot; :show-file-list=&quot;false&quot; :on-success=&quot;handleAvatarSuccess&quot; :before-upload=&quot;beforeAvatarUpload&quot;&gt; &lt;img v-if=&quot;this.addForm.avatorId&quot; :src=&quot;studentImg&quot; class=&quot;avatar&quot;&gt; &lt;i v-else class=&quot;el-icon-plus avatar-uploader-icon&quot;&gt;&lt;/i&gt; &lt;/el-upload&gt;&lt;/el-form-item&gt;//限制9张图片上传&lt;el-form-item label=&quot;上课图片&quot; prop=&quot;imageIds&quot;&gt; &lt;el-upload multiple //可多选 ref=&apos;upload1&apos; //清空图片数组需要 :limit=&quot;9&quot; :action=&quot;upload&quot; list-type=&quot;picture-card&quot; :data=&quot;&#123;type:2&#125;&quot; //参数 :on-preview=&quot;handlePictureCardPreview&quot; //预览大图 :on-remove=&quot;handleRemove&quot; //清除 :on-exceed=&quot;beyondQuantity&quot; //超出数量提示 :on-success=&quot;handleSuccess&quot; :before-upload=&quot;beforeUpload&quot;&gt; &lt;i class=&quot;el-icon-plus&quot;&gt;&lt;/i&gt; &lt;/el-upload&gt; &lt;/el-form-item&gt;//预览大图&lt;el-dialog :visible.sync=&quot;dialogVisible&quot;&gt; &lt;img width=&quot;100%&quot; :src=&quot;dialogImageUrl&quot;&gt;&lt;/el-dialog&gt;data中 upload: &quot;&quot;,//上传图片的服务器路径 studentImg: &quot;&quot;,//返回的图片路径 upLoadData: &#123; type: 1, schoolId: sessionStorage.schoolId &#125;,//上传图片的时候额外参数 //大图 dialogVisible: false, dialogImageUrl: &apos;&apos;, addRules: &#123; imageIds: &#123;required: true, message: &quot;请上传上课照片&quot;&#125;, &#125;, methods中handleRemove(file, fileList) &#123;//删除图片钩子 // console.log(file); // console.log(fileList); let delId = file.response.avatorId + &quot;,&quot;; // console.log(delId); //删除图片数组中删除的那张图片id this.addForm.imageIds = this.addForm.imageIds.split(delId).join(&quot;&quot;); // console.log(this.addForm.imageIds); &#125;,handleAvatarSuccess(res) &#123;//成功钩子 if (res.data.code === 200) &#123; this.$message.success(&quot;图片上传成功(*^▽^*)&quot;); //上传成功返回图片路径，页面可以显示;返回图片id，可以表单提交 this.studentImg = res.data.studentImg; this.addForm.avatorId = res.data.avatorId; this.addForm.imageIds += res.avatorId + &quot;,&quot;; this.$refs.addForm.validateField(&quot;studentImg&quot;); &#125; else &#123; this.$message.error(&quot;图片上传失败(ಥ﹏ಥ)&quot;); &#125; &#125;,beforeAvatarUpload(file) &#123; //限制图片格式和大小 let typeArr = [&quot;image/jpg&quot;, &quot;image/jpeg&quot;, &quot;image/png&quot;, &quot;image/gif&quot;]; if (!typeArr.includes(file.type)) &#123; this.$message.error(&apos;请选择正确的图片格式&apos;); return false; &#125; //限制大小 const isLt2M = file.size / 1024 / 1024 &lt; 2; if (!isLt2M) &#123; this.$message.error(&apos;上传图片大小不能超过 2MB!&apos;); &#125; return true; &#125;,handlePictureCardPreview(file) &#123;//预览大图钩子 // console.log(file); this.dialogImageUrl = file.url; this.dialogVisible = true; &#125;,beyondQuantity(file, fileList) &#123;//超出图片数量钩子 // console.log(file, fileList); this.$message.error(&quot;(。・＿・。)ﾉsorry~最多上传9张图片&quot;); &#125;,addSubmit() &#123; this.$refs.addForm.validate(valid =&gt; &#123; if (valid) &#123; this.addForm.imageIds = this.addForm.imageIds.slice(0, -1); this.$axios.post(this.$api.addStudentAssessment, this.addForm).then(res =&gt; &#123; if (res.data.code === 200) &#123; this.$message.success(&quot;添加成功(*^▽^*)&quot;); this.fetchData(); //清空表单和图片 this.$refs.addForm.resetFields(); this.$refs.upload1.clearFiles(); this.dialogVisible1 = false; &#125; else &#123; this.$message.error(&quot;添加失败(ಥ﹏ಥ)&quot;); this.dialogVisible1 = false; &#125; &#125;) &#125; else &#123; return false; &#125; &#125;); &#125;, mounted() &#123; //图片上传路径 this.upload = this.$api.UPLOAD; &#125; 总结日期：2019.12.10 修改Vue项目名称1、创建一个新的项目文件夹，复制之前的项目文件夹里面除了node_modules文件夹以外的内容到新的项目文件夹 2、然后修改根目录下的package.json文件，把name修改成你的项目名称 3、修改根目录下面的index.html文件的title，改好之后，vue文件的title就改过来了 4、重新cnpm instrall一次，记得npm 之后，之前通过npm安装的插件，也要重新安装 总结日期：2019.12.11 按钮不可用提示123&lt;el-button size=&quot;small&quot; @click=&quot;shift&quot; v-if=&quot;searchForm.classesId===&apos;&apos;&quot; disabled title=&quot;请先选中班级&quot;&gt;批量调班&lt;/el-button&gt;&lt;el-button size=&quot;small&quot; @click=&quot;shift&quot; v-else&gt;批量调班&lt;/el-button&gt; 总结日期：2019.12.12 选择器触发事件，选项标签组合12345678910&lt;el-select v-model=&quot;searchForm.classesId&quot; filterable clearable placeholder=&quot;请选择班级名称&quot; size=&quot;small&quot; @change=fetchData&gt; &lt;el-option v-for=&quot;item in classesNameList&quot; :key=&quot;item.classesId&quot; :label=&quot;item.classesName+&apos;(&apos;+item.classesCategoryName+&apos;)&apos;&quot; :value=&quot;item.classesId&quot;&gt; &lt;/el-option&gt;&lt;/el-select&gt; 总结日期：2019.12.12 多选实现12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;el-row&gt; &lt;el-checkbox :indeterminate=&quot;isIndeterminate&quot; v-model=&quot;checkAll&quot; @change=&quot;handleCheckAll&quot;&gt;全选 &lt;/el-checkbox&gt; &lt;div style=&quot;margin: 15px 0;&quot;&gt;&lt;/div&gt; &lt;el-checkbox-group v-model=&quot;checkedStudents&quot; @change=&quot;handleCheckedStudentsChange&quot;&gt; &lt;el-col :span=&quot;1&quot; class=&quot;student&quot; v-for=&quot;student in studentList&quot; :key=&quot;student.studentId&quot;&gt; &lt;!-- label需要绑定数据，不然无法选中--&gt; &lt;el-checkbox :label=student.studentId&gt;&lt;/el-checkbox&gt; &lt;img src=&quot;../../assets/images/student/boy.png&quot; alt=&quot;男孩&quot; v-if=&quot;student.sex===1&quot;&gt; &lt;img src=&quot;../../assets/images/student/girl.png&quot; alt=&quot;女孩&quot; v-else&gt; &lt;p&gt;&#123;&#123;student.studentName&#125;&#125;&lt;/p&gt; &lt;/el-col&gt; &lt;/el-checkbox-group&gt; &lt;/el-row&gt; &lt;el-row&gt;已选择&#123;&#123;this.checkedStudents.length&#125;&#125;个学生&lt;/el-row&gt; data中checkAll: false,studentList: [],checkedStudents: [],isIndeterminate: true,methods中handleCheckAll(val) &#123; // val为布尔型，是否全选 if (val) &#123; this.checkedStudents = [];//清空之前的选中值 for (let student in this.studentList) &#123; this.checkedStudents.push(this.studentList[student].studentId); &#125; &#125; else &#123; this.checkedStudents = []; &#125; // console.log(this.checkedStudents); this.isIndeterminate = false; &#125;,handleCheckedStudentsChange(value) &#123; // value为选中值 // console.log(this.checkedStudents); let checkedCount = value.length; this.checkAll = checkedCount === this.studentList.length; this.isIndeterminate = checkedCount &gt; 0 &amp;&amp; checkedCount &lt; this.studentList.length; &#125;, 总结日期：2019.12.12 Element-ui滚动条在使用时要设置外层容器高度。并且要设置el-scrollbar 的高度为100% 12345678910111213141516171819202122&lt;template&gt; &lt;div style=&quot;height: 54vh&quot; class=&quot;tiaoban&quot;&gt; &lt;el-scrollbar&gt; ....... blabla..... &lt;/el-scrollbar&gt; &lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;scss&quot;&gt; .tiaoban .el-scrollbar &#123; height: 100%; margin: 10px 0; padding: 10px; border-radius: 4px; border: 1px #EEEEEE solid; &#125; //去掉横向的滚动条 .tiaoban .el-scrollbar__wrap &#123; overflow-x: hidden; &#125;&lt;/style&gt; 总结日期：2019.12.12 VUE中 @click 事件不生效给vue组件绑定事件时候，必须加上native ，不然不会生效（监听根元素的原生事件，使用 .native 修饰符） 123456&lt;el-col :span=&quot;1&quot; class=&quot;student&quot; v-for=&quot;student in studentList&quot; :key=&quot;student.studentId&quot; @click.native=&quot;edit(student.studentId)&quot;&gt; &lt;img src=&quot;../../assets/images/student/boy.png&quot; alt=&quot;男孩&quot; v-if=&quot;student.sex===1&quot;&gt; &lt;img src=&quot;../../assets/images/student/girl.png&quot; alt=&quot;女孩&quot; v-else&gt; &lt;p&gt;&#123;&#123;student.studentName&#125;&#125;&lt;/p&gt;&lt;/el-col&gt; 总结日期：2019.12.12 表格中switch开关触发事件1234567891011121314151617&lt;el-table-column label=&quot;上架状态&quot; prop=&quot;status&quot;&gt; &lt;template #default=&quot;o&quot;&gt; &lt;!-- 原生事件绑定到组件上--&gt; &lt;el-switch @click.native=&quot;changeState(o.row.id,o.row.status)&quot; :value=&quot;o.row.status===1&quot; active-color=&quot;#13ce66&quot; inactive-color=&quot;#ff4949&quot;&gt;&lt;/el-switch&gt; &lt;/template&gt;&lt;/el-table-column&gt;methods中 //表格中状态改变changeState(sourceId, status) &#123; this.$axios.get(this.$api.changeStudentStatus, &#123;sourceId, status: status === 1 ? 2 : 1&#125;).then(res =&gt; &#123; if (res.data.code === 200) &#123; this.fetchData(); this.$message.success(&quot;修改成功(*^▽^*)&quot;); &#125; &#125;)&#125;, 总结日期：2019.12.16 Element表单npm cache clean –force 清理npm缓存 忽然发现设置表单为对象时，无须定义添加表单字段，刚开始undefined，输入内容就自动添加上值了 12addForm: &#123; &#125;, 发现以前老师教的有点多余，表格编辑的时候无需获取后台信息，直接@click=”edit(o.row)”就能传过来全部数据，然后this.editForm=row，不用重新请求一个接口了 关闭对话框触发事件clean清空表单 1234567&lt;el-dialog title=&quot;编辑合同&quot; :visible.sync=&quot;dialogVisible1&quot; @close=&quot;clean&quot;&gt;methods中clean() &#123; this.dialogVisible = false; this.$refs.addForm.resetFields(); &#125; 总结日期：2019.12.19 VUE权限管理可以直接在主页main.vue中的导航栏写个v-if判断用户是那种角色（登陆后获取一下权限类别字段），然后根据权限写两种不同菜单，只改变一下下面的index路径就行，这样不同权限的人就显示不同的导航，这么简单的思路，不用改路由或者存数据库搞那么复杂的。 总结日期：2019.12.20 日期格式yyyy-MM-dd1234567891011121314151617181920212223242526//装b方法this.searchForm.courseDate=new Date().format(&quot;yyyy-MM-dd&quot;);//简单方法this.searchForm.courseDate=new Date().getFullYear()+&quot;-&quot;+(new Date().getMonth() + 1)+&quot;-&quot;+new Date().getDate();main.js中Date.prototype.format = function(fmt) &#123; var o = &#123; &quot;M+&quot; : this.getMonth()+1, //月份 &quot;d+&quot; : this.getDate(), //日 &quot;h+&quot; : this.getHours(), //小时 &quot;m+&quot; : this.getMinutes(), //分 &quot;s+&quot; : this.getSeconds(), //秒 &quot;q+&quot; : Math.floor((this.getMonth()+3)/3), //季度 &quot;S&quot; : this.getMilliseconds() //毫秒 &#125;; if(/(y+)/.test(fmt)) &#123; fmt=fmt.replace(RegExp.$1, (this.getFullYear()+&quot;&quot;).substr(4 - RegExp.$1.length)); &#125; for(var k in o) &#123; if(new RegExp(&quot;(&quot;+ k +&quot;)&quot;).test(fmt))&#123; fmt = fmt.replace(RegExp.$1, (RegExp.$1.length==1) ? (o[k]) : ((&quot;00&quot;+ o[k]).substr((&quot;&quot;+ o[k]).length))); &#125; &#125; return fmt;&#125; 总结日期：2019.12.24 对象中是否存在某个属性12345678910111213141516171819202122232425//表格选择事件，val为选中行的全部数据 handleSelectionChange(val) &#123; // console.log(val); this.addForm.studentList = val; &#125;,//提交前先判断是否选中学生if (&quot;studentList&quot; in this.addForm) &#123; console.log(this.addForm); this.$axios.post(this.$api.addAppointmentStudent, this.addForm).then(res =&gt; &#123; if (res.data.code === 200) &#123; this.$message.success(&quot;添加成功(*^▽^*)&quot;); this.fetchData(); //清空对象 this.addForm = &#123;&#125;; this.dialogVisible = false; &#125; else &#123; this.$message.error(&quot;添加失败(ಥ﹏ಥ)&quot;); this.dialogVisible = false; &#125; &#125;) &#125; else &#123; this.$message.error(&quot;请您至少选择一个学生&quot;); return; &#125; 总结日期：2019.12.28 今天日期1courseDate: new Date().getFullYear() + &quot;-&quot; + (new Date().getMonth() + 1) + &quot;-&quot; + new Date().getDate(), 总结日期：2019.12.28 课程表切换上一周下一周123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;el-row&gt; &lt;el-button @click=&quot;lastclick&quot;&gt;上一周&lt;/el-button&gt; &lt;span&gt;&#123;&#123;todayDate&#125;&#125;&lt;/span&gt; &lt;el-button @click=&quot;nextclick&quot;&gt;下一周&lt;/el-button&gt;&lt;/el-row&gt;&lt;el-row&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th v-if=&quot;educationType===1&quot;&gt;托育课程表&lt;/th&gt; &lt;th v-if=&quot;educationType===2&quot;&gt;早教课程表&lt;/th&gt; &lt;th&gt;时间段&lt;/th&gt; &lt;th v-for=&quot;(item,index) in weekDayArr&quot; :key=&quot;index&quot;&gt;&#123;&#123;item.adate&#125;&#125;&lt;/th&gt; &lt;/tr&gt; &lt;tr v-for=&quot;timeSlot in morning&quot;&gt; &lt;td&gt;上午&lt;/td&gt; &lt;td v-for=&quot;classes in timeSlot&quot;&gt; &lt;!-- 单选框需要绑定一个唯一值--&gt; &lt;el-radio v-model=&quot;radio&quot; :label=&quot;classes.courseName+classes.week+classes.startTime&quot; v-if=&quot;classes.courseTableId&gt;0&quot; @change=&quot;choose(classes)&quot; border size=&quot;mini&quot;&gt; &#123;&#123;classes.courseName&#125;&#125; &lt;/el-radio&gt; &lt;div v-else&gt;&#123;&#123;classes.courseName&#125;&#125;&lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr v-for=&quot;timeSlot in afternoon&quot;&gt; &lt;td&gt;下午&lt;/td&gt; &lt;td v-for=&quot;classes in timeSlot&quot;&gt; &lt;el-radio v-model=&quot;radio&quot; :label=&quot;classes.courseName+classes.week+classes.startTime&quot; v-if=&quot;classes.courseTableId&gt;0&quot; @change=&quot;choose(classes)&quot; border size=&quot;mini&quot;&gt; &#123;&#123;classes.courseName&#125;&#125; &lt;/el-radio&gt; &lt;div v-else&gt;&#123;&#123;classes.courseName&#125;&#125;&lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/el-row&gt;data中 currentFirstDate: &quot;&quot;, clen: 7, todayDate: &quot;&quot;, weekDayArr: []created() &#123; this.todayDate = this.formatDate(new Date()); this.setDate(new Date()); &#125;,methods: &#123;//单选 choose(classes) &#123; // console.log(classes); this.addForm.courseTableId = classes.courseTableId; this.addForm.week = classes.week; //重点：获取选中周次的日期拼接 this.addForm.subscribeDate = new Date().getFullYear() + &quot;-&quot; + this.weekDayArr[classes.week - 1].adate.slice(0, -4); console.log(this.addForm.subscribeDate); this.classes = classes;//保存参数 &#125;, // 日期格式处理 formatDate(date) &#123; var month = (date.getMonth() + 1) + &apos;-&apos;; var day = date.getDate(); var week = &apos;(&apos; + [&apos;周日&apos;, &apos;周一&apos;, &apos;周二&apos;, &apos;周三&apos;, &apos;周四&apos;, &apos;周五&apos;, &apos;周六&apos;][date.getDay()] + &apos;)&apos;; return month + day + &apos; &apos; + week; &#125;, addDate(date, n) &#123; date.setDate(date.getDate() + n); return date; &#125;, setDate(date) &#123; var week = date.getDay() - 1; date = this.addDate(date, week * -1); this.currentFirstDate = new Date(date); for (var i = 0; i &lt; this.clen; i++) &#123; this.weekDayArr.push(&#123;&quot;adate&quot;: this.formatDate(i == 0 ? date : this.addDate(date, 1))&#125;) &#125; &#125;, //上一周 lastclick() &#123; this.weekDayArr = []; this.setDate(this.addDate(this.currentFirstDate, -7)); console.log(this.weekDayArr); &#125;, //下一周 nextclick() &#123; this.weekDayArr = []; this.setDate(this.addDate(this.currentFirstDate, 7)); console.log(this.weekDayArr); &#125;,&#125;table &#123;//默认样式修改 text-align:center;/*文本居中*/ border-collapse:collapse; /*表格的边框合并，如果相邻，则共用一个边框*/ border-spacing:0; /*设置行与单元格边框的间距。当表格边框独立（即border-collapse:separate;）此属性才起作用*/ th, td &#123; padding: 5px 10px; white-space: nowrap; border: #C8161D 2px solid; &#125; &#125; 总结日期：2019.12.28 Vue的组件为什么要export defaultVue 的模块机制 Vue 是通过 webpack 实现的模块化，因此可以使用 import 来引入模块，例如： img 此外，你还可以在 bulid/webpack.base.conf.js 文件中修改相关配置： img 意思是，你的模块可以省略 “.js”，”.vue”，“.json” 后缀，weebpack 会在之后自动添加上；可以用 “@” 符号代替 “src” 字符串等。 export 用来导出模块，Vue 的单文件组件通常需要导出一个对象，这个对象是 Vue 实例的选项对象，以便于在其它地方可以使用 import 引入。而 new Vue() 相当于一个构造函数，在入口文件 main.js 构造根组件的同时，如果根组件还包含其它子组件，那么 Vue 会通过引入的选项对象构造其对应的 Vue 实例，最终形成一棵组件树。 export 和export default 的区别在于：export 可以导出多个命名模块，例如： 123456//demo1.jsexport const str = &apos;hello world&apos;export function f(a)&#123; return a+1&#125; 对应的引入方式： 12//demo2.jsimport &#123; str, f &#125; from &apos;demo1&apos; export default 只能导出一个默认模块，这个模块可以匿名，例如： 12345//demo1.jsexport default &#123; a: &apos;hello&apos;, b: &apos;world&apos; &#125; 对应的引入方式： 12//demo2.jsimport obj from &apos;demo1&apos; 引入的时候可以给这个模块取任意名字，例如 “obj”，且不需要用大括号括起来。 总结日期：2021.08.22 iPhone中style不生效问题1234567:style=&quot;&#123; &apos;height&apos;: transHeight + &apos;vh&apos;, &apos;padding-bottom&apos;: iosBottom + &apos;px&apos; &#125;&quot;// data中isIos: localStorage.getItem(&quot;device&quot;) === &quot;ios&quot; || localStorage.getItem(&quot;device&quot;) === &quot;iPad&quot;,// iPhone中试了一下:style不生效，只能绑定class，改为以下代码:class=&quot;isIos ? &apos;ios-bottom content-info&apos; : &apos;content-info&apos;&quot; 子组件props数据无法动态更新1.数据改变后使用this.$nextTick调用子组件方法就可以 1234567handleEdit(id)&#123; this.editId = id console.log(this.editId) this.$nextTick(() =&gt; &#123; this.$refs.addCar.openDrawer() &#125;); &#125;, 2.用watch监听子组件接收的数据的变化，从而实现更新操作 12345watch:&#123; addshow()&#123; this.addModelshow=this.addshow; &#125;&#125; 参考链接：https://blog.csdn.net/weixin_50576800/article/details/125092510 图片引用不生效12&lt;img :src=&quot;item.isOpened?&apos;@/assets/images/employee-group/up@2x.png&apos;:&apos;@/assets/images/employee-group/down@2x.png&apos;&quot; alt=&quot;&quot; /&gt; 下面使用了require()函数来直接导入图片。这种方式在Webpack环境下能够更好地处理图片资源，特别是当图片需要动态加载或者处理时。但请记得，这种方式在模板中使用会增加打包后的体积，因为每个可能的分支都会被包含进来。 1&lt;img :src=&quot;item.isOpened ? require(&apos;@/assets/images/employee-group/up@2x.png&apos;) : require(&apos;@/assets/images/employee-group/down@2x.png&apos;)&quot; alt=&quot;&quot; /&gt; Uncaught (in promise) far &lt;= 0腾讯地图初始化渲染的时候找不到所要渲染到的元素了，导致的报错。建议查找下对应元素是否书写正确，是否在渲染的过程中被隐藏或注销。 解决办法： 确保加载完成再调用 将Vue项目methods中的方法暴露在window上在接口调用中，有时会返回给我们一个函数回调，来自动执行我们在前端定义好的某个函数（多出现于通过回调的方式传递某个数值）。在原生项目中，我们只要提供一下这个方法就好了，通过函数回调会自动执行。问题就出现在，我使用的是Vue项目，方法是定义在methods中的，这样返回给我的函数回调就没有办法执行这段函数。 1234567891011121314151617 created() &#123; // Vue的方法给原生调用，则需要把方法挂在Window下面 window.cb = this.cb; &#125;,// 路线规划请求 reqPolyline(from, to) &#123; // WebServiceAPI请求URL（驾车路线规划默认会参考实时路况进行计算） var url = &quot;https://apis.map.qq.com/ws/direction/v1/driving/&quot;; //请求路径 url += `?from=$&#123;from.latitude&#125;,$&#123;from.longitude&#125;`; //起点坐标 url += `&amp;to=$&#123;to.latitude&#125;,$&#123;to.longitude&#125;`; //起点坐标 url += &quot;&amp;output=jsonp&amp;callback=cb&quot;; //指定JSONP回调函数名，本例为cb url = url + &quot;&amp;key=&quot; + this.mapKey; //开发key，可在控制台自助创建 //发起JSONP请求，获取路线规划结果（浏览器调用WebServiceAPI需要通过Jsonp的方式） var script = document.createElement(&apos;script&apos;); script.src = url; document.body.appendChild(script); &#125;, vue项目如何实现返回上一页 并刷新上一页数据vue 返回上一页有两种方法： 如果使用的是 vue-router ，this.$router.go(-1) 就可以回到上一页。 history.go(-1) 是回到浏览器上一页。 在上一页中重新获取数据 123activated() &#123; this.getList();&#125;, mounted中获取不到dom123456setTimeout(() =&gt; &#123; // 设置对话框位置，延时才能获取到dom let ele = document.getElementById(&quot;zc__sdk__container&quot;); ele.style.right = &quot;108px&quot;; ele.style.bottom = &quot;calc(50% - 360px)&quot;;&#125;, 500); vuex mutations或actions使用state中储存的数据在控制台中输出this，发现这里this指代的是store。输出this.state.a和this.state.b，显示的是需要的数据。 总结：在vuex的index,js中，this指代的是store，因此如果要在actions和mutations中使用state中的数据，需要写成this.state.xxx，而不是this.xxx 解决Duplicate keys detected: ‘0‘. This may cause an update error.在我们使用vue或者uniapp开做v-for时，可能会出现这种异常 问题产生原因分析vue规定v-for时我们必须指定一个key，而我们习惯将遍历索引作为key来使用。而key的作用也容易被我们所忽略，key的作用简单理解就是vue为dom做的标记 即在同一个dom节点中包含了两个v-for也就出现了两个key，而这两个key都是遍历的索引，所以两个key的值会是相同的，违反了类似唯一约束的原则。 解决方案1、我们可以不让他们在同一个dom节点内，用一个盒子来隔离他们。 2、我们可以修改其中一个key，让他和遍历索引可以区分开，比如修改为item.id。 vue中的__ob__: Le如果你发现你拿到的数据中含有这个不要惊慌，这是vue内部属性，如果想要去掉可以使用 1JSON.parse(JSON.stringify()) 之后使用的数组或者数组中的对象也不会再带有这个属性了百度所有的答案：__ob__: Le都说是vue设置的监控，如果删除将失去了vue的意义 执行settimeout后要清理吗在JavaScript中，使用setTimeout函数设置的定时器，默认情况下是不会自动清理的。一旦定时器到期，相关的代码逻辑将被执行。如果你希望在定时器完成后清理它，你可以使用clearTimeout函数来取消定时器。 clearTimeout函数接受一个参数，即要清除的定时器的ID。这个ID可以通过setTimeout函数返回的结果得到。例如： 123456const timerId = setTimeout(() =&gt; &#123; // 定时器到期时执行的代码逻辑&#125;, 1000);// 在需要的时候清除定时器clearTimeout(timerId); 以上代码将在设置了1秒后执行的定时器到期前，立即清除定时器。 另外，如果在页面卸载或刷新时，定时器仍然处于活动状态，可能会造成内存泄漏。因此，在不再需要定时器时，最好手动清除它，以确保浏览器不会继续持有它的引用。。 在vue中 12345678910closeTimer: null // 自动关闭弹窗定时器idthis.closeTimer = setTimeout(() =&gt; &#123; this.close()&#125;, 5000)console.log(&apos;定时器开启&apos;, this.closeTimer) // 清除上一个自动关闭弹窗定时器，防止一直重复点按钮 自动关闭的越来越快clearTimeout(this.closeTimer)console.log(&apos;定时器关闭&apos;, this.closeTimer) Unexpected token ‘??=‘ 报错处理UnhandledPromiseRejectionWarning: SyntaxError: Unexpected token ‘??=‘ 报错处理 使用Vue3+Vite创建项目时忽然报这个错 逻辑空赋值(??=)是ES2021的语法，node v15.0.0以上才支持逻辑空赋值(??=)的语法。之前为了兼容旧代码使用的node版本是14。 使用nvm切换16的node，成功解决 vxe-table清除表头编辑的iconshowIcon : false可以去掉 1:edit-config=&quot;&#123;trigger: &apos;manual&apos;, mode: &apos;row&apos;, showIcon : false&#125;&quot; 表格vxe-column循环，顺序和数组顺序不一致:key=”index”即可 之前绑定了item.key，造成dom复用，导致不更新 12345678910&lt;vxe-table show-overflow border=&quot;inner&quot; :data=&quot;tableData&quot; :loading=&quot;loading&quot;&gt; &lt;vxe-column v-for=&quot;(item,index) in columns&quot; :key=&quot;index&quot; :field=&quot;item.key&quot; :title=&quot;item.title&quot; :width=&quot;item?.width&quot;&gt;&lt;/vxe-column&gt; &lt;/vxe-table&gt; 乾坤微应用，重新进入子应用，vue组件怎么监听在乾坤微前端框架中，当重新进入子应用时，Vue组件想要监听这个事件，可以采取以下策略： 使用 QianKun 生命周期钩子乾坤微前端为子应用提供了特定的生命周期钩子，可以在这些钩子中触发自定义的监听逻辑。对于Vue组件来说，通常需要在子应用的入口文件（通常是main.js或类似文件）中利用这些钩子，然后通过Vue的事件总线、Vuex状态管理或props等方式将事件传递到需要监听的组件中。 具体步骤：1.在子应用入口文件中监听：利用QianKun提供的生命周期函数，如mount，在这个阶段可以认为是子应用被激活或重新进入的时候。在mount钩子中触发一个自定义事件或者更新全局状态（如Vuex）。 123456789101112131415161718// 子应用入口文件import &#123; mount &#125; from &apos;@qiankun/mount&apos;;export async function bootstrap() &#123; console.log(&apos;子应用：bootstrap&apos;);&#125;export async function mount(props) &#123; console.log(&apos;子应用：mount&apos;); // 触发全局事件或状态更新 window.dispatchEvent(new Event(&apos;subAppReentered&apos;)); // 或者使用Vuex来更新状态 store.commit(&apos;setSubAppStatus&apos;, &apos;reentered&apos;);&#125;export async function unmount() &#123; console.log(&apos;子应用：unmount&apos;);&#125; 2.Vue组件内监听： - 在需要监听的Vue组件内部，你可以根据上面选择的通信方式来监听变化。 - 如果是全局事件，使用mounted钩子绑定事件监听器，并在beforeDestroy或unmounted钩子中移除。 - 如果是Vuex状态，使用computed属性结合watch来监听状态变化。 123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;!-- 组件内容 --&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;YourComponent&apos;, computed: &#123; subAppState() &#123; return this.$store.state.subAppState; &#125;, &#125;, watch: &#123; subAppState(newValue) &#123; if (newValue === &apos;reentered&apos;) &#123; console.log(&apos;子应用被重新进入&apos;); // 执行你的逻辑 &#125; &#125;, &#125;, mounted() &#123; // 监听全局事件示例（如果使用了这种方式） window.addEventListener(&apos;subAppReentered&apos;, this.handleReentry); &#125;, beforeDestroy() &#123; // 清理事件监听器 window.removeEventListener(&apos;subAppReentered&apos;, this.handleReentry); &#125;, methods: &#123; handleReentry() &#123; console.log(&apos;子应用被重新进入&apos;); // 执行你的逻辑 &#125;, &#125;,&#125;;&lt;/script&gt; 这样，当子应用被重新进入时，相关组件就能通过上述机制监听到并作出响应。 离开子应用后重新进入，不会触发mouted钩子，怎么解决在Vue中，特别是使用了QianKun微前端框架的情况下，如果你发现离开子应用后重新进入时，组件的mounted钩子没有被触发，这可能是因为Vue为了性能考虑复用了已经创建的组件实例，而不是重新创建它们。此时，你可以利用Vue的activated钩子来处理这种情况。 解决方案：Vue提供了keep-alive组件来缓存组件实例，以避免重复渲染和优化性能。在QianKun框架中，当子应用被切换时，实际上是在管理这些缓存的组件。因此，你应该在组件内使用activated和deactivated这两个生命周期钩子来替代或补充原本的mounted和destroyed。 - activated: 当组件被激活（即从不可见变为可见）时调用，这发生在组件被缓存后重新进入时。- deactivated: 当组件被停用（即从可见变为不可见）时调用。 示例代码： 12345678910111213141516171819202122232425&lt;template&gt; &lt;div&gt; &lt;!-- 组件内容 --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;YourComponent&apos;, mounted() &#123; // 首次加载时的初始化逻辑依然可以放在这里 console.log(&apos;组件首次挂载&apos;); &#125;, activated() &#123; // 当组件从非活跃状态变为活跃状态时调用，类似重新进入 console.log(&apos;组件重新激活&apos;); // 在这里执行你需要在重新进入时运行的逻辑 &#125;, deactivated() &#123; // 当组件从活跃状态变为非活跃状态时调用，类似离开 console.log(&apos;组件失去焦点&apos;); // 可以在这里清理一些资源，例如取消未完成的请求 &#125;,&#125;;&lt;/script&gt; 确保在你的主应用中，对于需要缓存的子应用路由或组件，使用了&lt;keep-alive&gt;包裹&lt;router-view&gt;，这样Vue才会在路由切换时复用组件实例，并触发activated和deactivated钩子。 注意事项： - 如果你发现即使使用了activated依然没有达到预期效果，请检查是否有正确配置&lt;keep-alive&gt;，以及是否所有相关的路由切换逻辑都支持这种模式。- 对于需要在每次进入时都执行某些初始化逻辑的情况，activated是最佳选择。而对于只需在第一次加载时执行的逻辑，则应继续使用mounted。 vue使用动态路由引入组件，mounted钩子不会重新触发，怎么解决在Vue中，如果你发现使用动态路由时mounted钩子没有如预期那样触发，这可能是因为Vue为了性能考虑，对于已经创建过的组件实例，在路由参数改变但组件本身不变化时，不会再次调用mounted钩子。这种情况下，可以考虑使用其他生命周期钩子来处理数据的更新逻辑。 对于动态路由页面内容更新的问题，可以考虑使用以下钩子： updated: 当组件的响应式数据变化引起虚拟DOM重新渲染和打补丁时调用。但是，请注意频繁触发可能导致性能问题。 watch: 你可以使用watch来监听路由参数或查询参数的变化，并在变化时执行相应逻辑。这对于基于路由参数动态更新数据特别有用。 activated (对于keep-alive组件): 如果你的组件被包裹在&lt;keep-alive&gt;中，那么当组件被重新激活时（比如，从一个路由切换回来），activated钩子会被触发。这个钩子适合用来处理数据的重新获取或组件状态的恢复。 示例代码（使用watch）: 12345678910111213141516export default &#123; watch: &#123; '$route'(to, from) &#123; // 当路由发生变化时执行的逻辑 this.fetchData(); // 假设这是你获取数据的方法 &#125;, &#125;, mounted() &#123; this.fetchData(); // 首次加载时获取数据 &#125;, methods: &#123; fetchData() &#123; // 获取数据的逻辑 &#125;, &#125;,&#125;; 或者，如果你的组件被&lt;keep-alive&gt;包含，可以使用activated: 12345678910111213export default &#123; activated() &#123; this.fetchData(); // 每当组件被重新激活时获取数据 &#125;, mounted() &#123; this.fetchData(); // 首次加载时获取数据 &#125;, methods: &#123; fetchData() &#123; // 获取数据的逻辑 &#125;, &#125;,&#125;; 这样，无论是在首次加载还是路由参数变化时，都能确保数据的及时更新。 elment表格组件最大高度工具屏幕高度动态变化，如果头部和尾部不确定高度，怎么把表格封装为公共组件，动态最大高度，vue2具体怎么实现在 Vue 2 中，若要将 Element UI 的表格组件封装为一个公共组件，使其最大高度根据屏幕高度动态变化，同时考虑到头部和尾部高度是不确定的，可以采取以下策略： 步骤 1: 创建公共表格组件 首先，创建一个名为 DynamicHeightTable.vue 的公共组件文件。 DynamicHeightTable.vue 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;template&gt; &lt;div ref=&quot;tableContainer&quot; class=&quot;table-container&quot;&gt; &lt;el-table :data=&quot;tableData&quot; :max-height=&quot;computedMaxHeight&quot;&gt; &lt;!-- 表格列定义 --&gt; &lt;/el-table&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; tableData: &#123; type: Array, required: true &#125; &#125;, data() &#123; return &#123; // 这里可以初始化一些状态，如果需要的话 &#125;; &#125;, computed: &#123; computedMaxHeight() &#123; // 获取可视区高度 const windowHeight = window.innerHeight || document.documentElement.clientHeight; // 计算表格容器的实际可用高度 const containerRect = this.$refs.tableContainer.getBoundingClientRect(); const actualHeight = windowHeight - containerRect.top; // 减去估算的头部和尾部高度，可以通过实际获取这两个元素的高度或预留一定比例 // 这里假设头部和尾部高度未知，使用一个预留值或动态计算（如果头部和尾部组件是可控的） const estimatedHeaderFooterHeight = 200; // 示例预留值，实际情况需根据设计调整 return actualHeight - estimatedHeaderFooterHeight; &#125; &#125;, mounted() &#123; // 添加窗口大小变化的监听器 window.addEventListener(&apos;resize&apos;, this.$refs.tableContainer.offsetHeight); &#125;, beforeDestroy() &#123; // 在组件销毁前移除监听器 window.removeEventListener(&apos;resize&apos;, this.$refs.tableContainer.offsetHeight); &#125;&#125;;&lt;/script&gt;&lt;style scoped&gt;.table-container &#123; position: relative; /* 可能需要相对定位，以便计算正确的高度 */&#125;&lt;/style&gt; 步骤 2: 在父组件中使用公共表格组件 在需要使用此表格的父组件中，引入并使用 DynamicHeightTable 组件，无需直接传递头部和尾部高度，因为公共组件会根据屏幕高度动态计算。 1234567891011121314151617181920212223&lt;!-- ParentComponent.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;header&gt;动态高度的头部&lt;/header&gt; &lt;dynamic-height-table :table-data=&quot;yourTableData&quot;&gt;&lt;/dynamic-height-table&gt; &lt;footer&gt;动态高度的底部&lt;/footer&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import DynamicHeightTable from &apos;@/components/DynamicHeightTable.vue&apos;;export default &#123; components: &#123; DynamicHeightTable &#125;, data() &#123; return &#123; yourTableData: [] // 你的表格数据 &#125;; &#125;&#125;;&lt;/script&gt; 注意事项 - 上述代码中，为了简化，头部和尾部的高度预留了一个固定的估计值。在实际项目中，如果头部和尾部高度可以通过Vue实例访问到（例如，它们也是Vue组件且高度是响应式的），那么可以直接计算它们的实际高度，而不是使用固定值。- 确保父组件的布局方式（如使用Flexbox或Grid）支持动态高度调整，这样表格组件才能正确计算其可用空间。- 当头部或尾部高度变化时，如果这些变化是响应式的，那么表格组件的 computedMaxHeight 会自动重新计算，但如果是由于非Vue数据驱动的DOM操作导致的高度变化，则可能需要额外的逻辑来手动触发高度的重计算。 elment表格组件最大高度工具屏幕高度动态变化，如果头部和尾部不确定高度，怎么把表格封装为公共组件，动态最大高度，vue2具体怎么实现 如果头部和尾部的高度是动态不确定的，你可以进一步封装一个更通用的解决方案，使得表格组件能够自适应其外部容器的高度，而不直接依赖于固定高度的头部和尾部。下面是一种实现思路： 步骤 1: 使用 Flex 或 Grid 布局首先，确保你的页面布局采用 Flexbox 或 CSS Grid，这两种布局模式允许你更灵活地分配空间，特别是对于未知高度的情况。 步骤 2: 表格组件封装在封装表格组件时，可以通过传入一个引用或者父容器的高度来动态计算表格的最大高度。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!-- TableComponent.vue --&gt;&lt;template&gt; &lt;div ref=&quot;tableWrapper&quot; class=&quot;table-wrapper&quot;&gt; &lt;el-table :data=&quot;tableData&quot; :max-height=&quot;computedMaxHeight&quot;&gt; &lt;!-- 表格列定义 --&gt; &lt;/el-table&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; parentRef: &#123; // 传递父容器的引用 type: Object, required: true &#125; &#125;, data() &#123; return &#123; tableData: [] // 你的表格数据 &#125;; &#125;, computed: &#123; computedMaxHeight() &#123; if (this.parentRef) &#123; // 计算父容器高度减去头部和尾部高度 const parentRect = this.parentRef.getBoundingClientRect(); const headerRect = this.parentRef.querySelector(&apos;.header&apos;).getBoundingClientRect(); const footerRect = this.parentRef.querySelector(&apos;.footer&apos;).getBoundingClientRect(); // 动态计算表格最大高度 return parentRect.height - (headerRect.height + footerRect.height); &#125; return 0; // 默认值或错误处理 &#125; &#125;, mounted() &#123; // 如果头部和尾部高度可能变化，可以在这里添加监听器来响应变化 // 注意：这取决于头部和尾部高度变化的具体方式 &#125;&#125;;&lt;/script&gt; 步骤 3: 使用公共组件 在父组件中使用这个表格组件，并将包含头部、表格和尾部的容器的引用传递给它。 1234567891011121314151617181920212223242526272829&lt;!-- ParentComponent.vue --&gt;&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;header class=&quot;header&quot;&gt;头部内容&lt;/header&gt; &lt;TableComponent :parent-ref=&quot;$refs.container&quot; :table-data=&quot;yourData&quot;/&gt; &lt;footer class=&quot;footer&quot;&gt;底部内容&lt;/footer&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import TableComponent from &apos;./TableComponent.vue&apos;;export default &#123; components: &#123; TableComponent &#125;, data() &#123; return &#123; yourData: [] // 表格数据 &#125;; &#125;&#125;;&lt;/script&gt;&lt;style scoped&gt;.container &#123; display: flex; flex-direction: column; height: 100%; /* 或其他适合的百分比/视窗单位 */&#125;&lt;/style&gt; 通过这样的设计，你的表格组件能够动态适应其父容器的高度变化，即使头部和尾部的高度是动态的。 注意，这种方法依赖于外部容器的布局和高度管理，确保父容器有一个确定的或可计算的高度。","categories":[{"name":"前端问题","slug":"前端问题","permalink":"https://qw8.github.io/categories/前端问题/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://qw8.github.io/tags/vue/"},{"name":"前端","slug":"前端","permalink":"https://qw8.github.io/tags/前端/"},{"name":"ElementUI","slug":"ElementUI","permalink":"https://qw8.github.io/tags/ElementUI/"}]},{"title":"原生常见问题","slug":"questions/原生常见问题","date":"2022-05-20T11:45:42.000Z","updated":"2024-06-06T02:20:08.742Z","comments":true,"path":"/questions/yuan-sheng-chang-jian-wen-ti.html","link":"","permalink":"https://qw8.github.io/questions/yuan-sheng-chang-jian-wen-ti.html","excerpt":"","text":"JavaScript文件位置在本网站（HTML5学堂）正式上线之前，统计工具针对本网站的SEO优化提出了一些建议，说是将JS文件放置在body标签之后会提升加载速度。不过最终我们还是放置在了head标签里。这里就涉及到一个JS文件位置的选择。到底JS文件的引入放置在头部好还是尾部好？一起来看看吧。 具体将引入的JS放在哪里与代码执行的顺序有关。网页文件的读取是从上到下的，如果将JavaScript文件放置在head当中，会先加载JS文件，之后再继续执行，那么此时，如果JS文件比较大，页面加载就会比较慢，导致空白。 那么，如果将JavaScript文件放置在底部，如果说，也是比较大型的JS文件的话，是不是就没有问题了呢？ 其实，如果将JS文件放置在底部的话，可以让JS文件与图片几乎同时下载，使得页面当中的内容能够尽快的下载下来，但是，由于网页基本结构与样式均已经加载完成，那么此时负责交互的JS并没有下载下来，必然也会对用户的体验造成影响。 因此，整体来说，如果“交互性优先”，那么我们应当将JS放置在顶部。如果对于交互性要求没那么高的页面，我们将JS放置在底部。 阻塞方式加载JS 阻塞方式加载JS：JavaScript在头部会阻止其他元素并行加载(css,图片,网页)。目前绝大部分的浏览器都是采取阻塞方式(Scripts Block Downloads)进行JavaScript文件的加载的。 首先在HTML文件中js脚本是按顺序加载的。 假设你的js脚本是给页面上某个元素绑定了事件，如果你将js脚本放在尾部就会造成页面出来了，但是js脚本没加载出来的这段时间里对绑定事件了的元素进行操作是没有效果的。所以这种情况就适合放在头部。 但是针对那些不是需要及时的交互js脚本可以选在这L2Dwidget.init({\"model\":{\"scale\":1,\"hHeadPos\":0.5,\"vHeadPos\":0.618,\"jsonPath\":\"/live2dw/assets/tororo.model.json\"},\"display\":{\"superSample\":2,\"position\":\"right\",\"width\":150,\"height\":300,\"hOffset\":-25,\"vOffset\":30},\"mobile\":{\"show\":false,\"scale\":1.2},\"react\":{\"opacityDefault\":0.7,\"opacityOnHover\":0.2},\"log\":false,\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"pluginRootPath\":\"live2dw/\",\"tagMode\":false});!function(e){var r=Array.prototype.slice.call(document.querySelectorAll(\"img[data-original]\"));function t(){for(var c=0;c","categories":[{"name":"前端问题","slug":"前端问题","permalink":"https://qw8.github.io/categories/前端问题/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qw8.github.io/tags/JavaScript/"},{"name":"前端","slug":"前端","permalink":"https://qw8.github.io/tags/前端/"},{"name":"Css","slug":"Css","permalink":"https://qw8.github.io/tags/Css/"}]},{"title":"前端问题","slug":"questions/前端问题","date":"2022-05-19T15:40:25.000Z","updated":"2024-05-16T01:31:29.884Z","comments":true,"path":"/questions/qian-duan-wen-ti.html","link":"","permalink":"https://qw8.github.io/questions/qian-duan-wen-ti.html","excerpt":"","text":"本地pnpm版本与packageManager中pnpm版本不一致问题：ERR_PNPM_BAD_PM_VERSION This project is configured to use v8.6.10 of pnpm. Your current pnpm is v9.1.0 解决：If you want to bypass this version check, you can set the “package-manager-strict” configuration to “false” or set the “COREPACK_ENABLE_STRICT” environment variable to “0”在.npmrc中添加 1package-manager-strict=false Node16版本 对应node-sass和sass-loader的版本号12&quot;node-sass&quot;: &quot;6.0.1&quot;&quot;sass-loader&quot;: &quot;10.2.0&quot; 改完记得要打开终端重新npm install下","categories":[{"name":"前端问题","slug":"前端问题","permalink":"https://qw8.github.io/categories/前端问题/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://qw8.github.io/tags/前端/"}]},{"title":"前端代码片段","slug":"knowledges/前端代码片段","date":"2021-11-25T07:26:47.000Z","updated":"2024-06-03T03:11:37.352Z","comments":true,"path":"/knowledges/qian-duan-dai-ma-pian-duan.html","link":"","permalink":"https://qw8.github.io/knowledges/qian-duan-dai-ma-pian-duan.html","excerpt":"","text":"在日常的开发过程中，我们都会有一些常用的代码片段，这些代码片段可以直接复制到各个项目中使用，非常方便。如果你有接手过别人的项目，就可以很明显感受到几个项目一般都会有一些相同的工具类方法，这些方法就是之前开发者的常用代码片段。 现在前端社区相当完善，有许多好用质量又有保证的库，如 lodash、dayjs、classnames、js-cookie 等，这些库基本能满足你开发中对数组、日期、类名、cookie 等的处理。 所以本文会尽量不重复介绍那些很常见的代码片段。 1. 检测元素之外的点击在实现隐藏弹窗或收起下拉框时，如果你还在一层层判断是否点击了某个元素之外的区域，赶紧试试使用 contains 方法来实现。 1234document.addEventListener(&apos;click&apos;, function (evt) &#123; // isClickedOutside 为 true 如果点击的元素在 ele 之外 const isClickedOutside = !ele.contains(evt.target);&#125;); 2. 快速打开官网当你想查看第三方库的主页和代码仓库时，你可以使用一下命令快速打开： 1234567// 打开主页npm home PACKAGE_NAMEnpm home react// 打开代码仓库npm repo PACKAGE_NAMEnpm repo react 图片 3. 一次性的事件监听除了在监听的事件函数中移除当前的监听外，也可以使用 once 参数。 12const handler = function (e) &#123;&#125;;ele.addEventListener(&apos;event-name&apos;, handler, &#123; once: true &#125;); 4. 格式化时分秒在展示音视频时长之类的场景时，需要把时长秒数格式为 HH:mm:ss 的格式。 1234const formatSeconds = (s) =&gt; [parseInt(s / 60 / 60), parseInt((s / 60) % 60), parseInt(s % 60)] .join(&apos;:&apos;) .replace(/\\b(\\d)\\b/g, &apos;0$1&apos;) 如果你想显示“刚刚”、“5分钟前”之类的内容，可以尝试 timeago.js 库。 5. URL 参数转化为对象获取 url 参数有个热门的库 query-string，如果不想使用的话，可以通过 URLSearchParams API 实现。 1234567891011121314const getUrlParams = (query) =&gt; Array.from(new URLSearchParams(query)).reduce( (p, [k, v]) =&gt; Object.assign(&#123;&#125;, p, &#123; [k]: p[k] ? (Array.isArray(p[k]) ? p[k] : [p[k]]).concat(v) : v &#125;), &#123;&#125; ) // 获取 query 参数getUrlParams(location.query)// &#123; a: [&apos;1&apos;, &apos;4&apos;], b: &apos;2&apos;, c: &apos;3&apos; &#125;getUrlParams(&apos;?a=1&amp;b=2&amp;c=3&amp;a=4&apos;)// 获取 hash 参数getUrlParams(location.hash.split(&apos;?&apos;)[1]) 6. 打开新页签看似平平无奇的打开页签，但是需要关注下 rel，如果要打开外链，建议设置为 noopener noreferrer，避免一些恶意网站通过 window.opener.location 重定向你的网站地址。window.open 方法同理。 1234// 高版本浏览器 rel 默认为 noopener，不过建议显示设置，兼容低版本。&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;...&lt;/a&gt;// window.open rel 默认为 opener，需要自己设置window.open(&apos;https://baidu.com&apos;, &apos;baidu&apos;, &apos;noopener,noreferrer&apos;) 以下有安全漏洞，打开的新页签可以通过 window.opener.location 重定向你的网站 12&lt;a target=&quot;_blank&quot; rel=&quot;opener&quot;&gt;...&lt;/a&gt;window.opener.location = &apos;http://fake.website.here&apos;; 7. 显示上传的图片通过 fileReader API 的 readAsDataURL 方法来显示上传图片。 1234567891011121314151617181920function readImage() &#123; const fileReader = new FileReader() const file = document.getElementById(&apos;uploaded-file&apos;).files[0] if (file) &#123; fileReader.readAsDataURL(file) &#125; fileReader.addEventListener( &apos;load&apos;, () =&gt; &#123; const result = fileReader.result const resultContainer = document.getElementById(&apos;result&apos;) const img = document.createElement(&apos;img&apos;) img.src = result resultContainer.append(img) &#125;, &#123; once: true &#125; )&#125; 8. 文件下载使用 a 标签的 download 属性，同源才能触发下载，IE 不支持，移动端兼容性也不太好。 1234567891011&lt;a href=&quot;/path/to/file&quot; download&gt;Download&lt;/a&gt;// 或者 js 临时生成 afunction download(url) &#123; const link = document.createElement(&apos;a&apos;) link.download = &apos;file name&apos; link.href = &apos;url&apos; document.body.appendChild(link) link.click() document.body.removeChild(link)&#125; 静态资源服务器设置响应头也能触发浏览器下载。 1Content-Disposition: attachment; filename=&quot;filename.jpg&quot; 除了在线文件下载，你还可以创建一个 text 或 json 文件，并下载，主要用到了 Blob 对象和 createObjectURL 方法。 123456789101112const data = JSON.stringify(&#123; &apos;message&apos;: &apos;Hello Word&apos; &#125;);const blob = new Blob([data], &#123; type: &apos;application/json&apos; &#125;);// 创建一个 URLconst url = window.URL.createObjectURL(blob);// 用上面的 download 方法下载这个 url...// 释放创建的 URLwindow.URL.revokeObjectURL(url); 9. 缓存结果缓存函数的结果，当计算比较复杂时可以使用。 123456const memoize = (fn) =&gt; ( (cache = Object.create(null)) =&gt; (arg) =&gt; cache[arg] || (cache[arg] = fn(arg)) )() 10. 多行省略号单行或多行截断显示省略号，很常用的 CSS 片段。 123456789101112.truncate &#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125;.truncate &#123; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2; overflow: hidden;&#125; 11. 选中最后几个元素1234567891011121314// 前三个li:nth-child(-n + 3) &#123; text-decoration: underline;&#125;// 选中 2-5 的列表项li:nth-child(n + 2):nth-child(-n + 5) &#123; color: #2563eb;&#125;// 倒数两个li:nth-last-child(-n + 2) &#123; text-decoration-line: line-through;&#125; 图片 12. 滚动条样式自定义滚动条样式也是很常见的需求，除了通过样式，也可以通过第三方库（如 better-scroll 等）来实现自定义滚动条样式。 1234567891011121314151617181920212223/*定义滚动条高宽及背景 高宽分别对应横竖滚动条的尺寸*/::-webkit-scrollbar &#123; width: 8px; height: 8px;&#125;/*定义滚动条轨道 内阴影+圆角*/::-webkit-scrollbar-track &#123; border-radius: 10px; background-color: #fafafa;&#125;/*定义滑块 内阴影+圆角*/::-webkit-scrollbar-thumb &#123; border-radius: 10px; background: rgb(191, 191, 191);&#125;/*较新的 API*/body &#123; scrollbar-width: thin; scrollbar-color: #718096 #edf2f7;&#125; 13. 百分比计算 - 最大余额法计算百分比时，由于四舍五入，各个比例相加可能不等于 1，通过最大余额法可以保证总数为 1。 图片 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 输出 [&apos;32.56%&apos;, &apos;6.97%&apos;, &apos;27.91%&apos;, &apos;32.56%&apos;]getPercentWithPrecision([56, 12, 48, 56], 2)// 具体最大余额法算法可以网上搜索查看function getPercentWithPrecision(valueList, precision) &#123; // 根据保留的小数位做对应的放大 const digits = Math.pow(10, precision) const sum = valueList.reduce((total, cur) =&gt; total + cur, 0) // 计算每项占比，并做放大，保证整数部分就是当前获得的席位，小数部分就是余额 const votesPerQuota = valueList.map((val) =&gt; &#123; return val / sum * 100 * digits &#125;) // 整数部分就是每项首次分配的席位 const seats = votesPerQuota.map((val) =&gt; &#123; return Math.floor(val); &#125;); // 计算各项的余额 const remainder = votesPerQuota.map((val) =&gt; &#123; return val - Math.floor(val) &#125;) // 总席位 const totalSeats = 100 * digits // 当前已经分配出去的席位总数 let currentSeats = votesPerQuota.reduce((total, cur) =&gt; total + Math.floor(cur), 0) // 按最大余额法分配 while(totalSeats - currentSeats &gt; 0) &#123; let maxIdx = -1 // 余数最大的 id let maxValue = Number.NEGATIVE_INFINITY // 最大余额, 初始重置为无穷小 // 选出这组余额数据中最大值 for(var i = 0; i &lt; remainder.length; i++) &#123; if (maxValue &lt; remainder[i]) &#123; maxValue = remainder[i] maxIdx = i &#125; &#125; // 对应的项席位加 1，余额清零，当前分配席位加 1 seats[maxIdx]++ remainder[maxIdx] = 0 currentSeats++ &#125; return seats.map((val) =&gt; `$&#123;val / totalSeats * 100&#125;%`)&#125; 14. 限制并发当有大量请求需要发起时，往往需求限制并发数量保证其他请求能优先返回。 123456789101112131415161718192021222324252627async function asyncPool(poolLimit, iterable, iteratorFn) &#123; // 用于保存所有异步请求 const ret = []; // 用户保存正在进行的请求 const executing = new Set(); for (const item of iterable) &#123; // 构造出请求 Promise const p = Promise.resolve().then(() =&gt; iteratorFn(item, iterable)); ret.push(p); executing.add(p); // 请求执行结束后从正在进行的数组中移除 const clean = () =&gt; executing.delete(p); p.then(clean).catch(clean); // 如果正在执行的请求数大于并发数，就使用 Promise.race 等待一个最快执行完的请求 if (executing.size &gt;= poolLimit) &#123; await Promise.race(executing); &#125; &#125; // 返回所有结果 return Promise.all(ret);&#125;// 使用方法const timeout = i =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(i), i));asyncPool(2, [1000, 5000, 3000, 2000], timeout).then(results =&gt; &#123; console.log(results)&#125;) 15. uuid生成 uuid 的代码片段 1234const uuid = (a) =&gt; a ? (a ^ ((Math.random() * 16) &gt;&gt; (a / 4))).toString(16) : ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, uuid) 16. 打开 Modal 时禁止 body 滚动打开弹窗的时候，会发现背后的内容还是可以滚动，我们需要在弹窗出现时禁用滚动，在弹窗消失时恢复。 12345// 打开 Modal 时，禁止 body 滚动document.body.style.overflow = &apos;hidden&apos;;// 恢复滚动document.body.style.removeProperty(&apos;overflow&apos;); 将内容复制到剪贴板通过按钮，将指定 dom 中的内容复制到用户的剪贴板 123456789const copyToClipboard = (content) =&gt; &#123; const textarea = document.createElement(&quot;textarea&quot;) textarea.value = content document.body.appendChild(textarea) textarea.select() document.execCommand(&quot;Copy&quot;) textarea.remove()&#125; 使用URLSearchParams获取URL的搜索参数这应该是一个非常常见的操作，之前经常会使用 正则来完成，现在有了更简单的方式： 12345678const getQueryByName = (name) =&gt; &#123; const query = new URLSearchParams(location.search) return decodeURIComponent(query.get(name))&#125;// url: https://sunday.com/?name=fatfish&amp;age=100const name = getQueryByName(&apos;name&apos;) // fatfishconst age = getQueryByName(&apos;age&apos;) // 100const gender = getQueryByName(&apos;gender&apos;) // null 平滑滚动至页面顶部12345678const scrollToTop = () =&gt; &#123; const c = document.documentElement.scrollTop || document.body.scrollTop if (c &gt; 0) &#123; window.requestAnimationFrame(scrollToTop) window.scrollTo(0, c - c / 8) &#125;&#125; 获取当前页面滚动距离123456const getScrollPosition = (el = window) =&gt; (&#123; x: el.pageXOffset !== undefined ? el.pageXOffset : el.scrollLeft, y: el.pageYOffset !== undefined ? el.pageYOffset : el.scrollTop,&#125;)getScrollPosition() // &#123; x: 0, y: 215 &#125; 判断当前设备是Andoird还是iOS12345678910111213141516function getOSType() &#123; let u = navigator.userAgent, app = navigator.appVersion let isAndroid = u.indexOf(&quot;Android&quot;) &gt; -1 || u.indexOf(&quot;Linux&quot;) &gt; -1 let isIOS = !!u.match(/\\(i[^]+( U)? CPU.+Mac OS X/) if (isIOS) &#123; return 0 &#125; else if (isAndroid) &#123; return 1 &#125; else &#123; return 2 &#125;&#125;getOSType() // 0 格式化货币1234567const formatMoney = (money) =&gt; &#123; return money.toLocaleString()&#125;formatMoney(123456789) // &apos;123,456,789&apos;formatMoney(123456789.123) // &apos;123,456,789.123&apos;formatMoney(123) // &apos;123&apos; 进入和退出全屏12345678910111213141516171819202122232425262728// 进入全屏function fullScreen() &#123; let el = document.documentElement let rfs = el.requestFullScreen || el.webkitRequestFullScreen || el.mozRequestFullScreen || el.msRequestFullScreen //typeof rfs != &quot;undefined&quot; &amp;&amp; rfs if (rfs) &#123; rfs.call(el) &#125; else if (typeof window.ActiveXObject !== &quot;undefined&quot;) &#123; let wscript = new ActiveXObject(&quot;WScript.Shell&quot;) if (wscript != null) &#123; wscript.SendKeys(&quot;&#123;F11&#125;&quot;) &#125; &#125;&#125;// 退出全屏function exitScreen() &#123; let el = document let cfs = el.cancelFullScreen || el.webkitCancelFullScreen || el.mozCancelFullScreen || el.exitFullScreen //typeof cfs != &quot;undefined&quot; &amp;&amp; cfs if (cfs) &#123; cfs.call(el) &#125; else if (typeof window.ActiveXObject !== &quot;undefined&quot;) &#123; let wscript = new ActiveXObject(&quot;WScript.Shell&quot;) if (wscript != null) &#123; wscript.SendKeys(&quot;&#123;F11&#125;&quot;) &#125; &#125;&#125;","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://qw8.github.io/tags/前端/"}]},{"title":"术语名词","slug":"knowledges/术语名词","date":"2021-10-28T07:55:55.000Z","updated":"2024-05-20T10:06:13.020Z","comments":true,"path":"/knowledges/zhu-yu-ming-ci.html","link":"","permalink":"https://qw8.github.io/knowledges/zhu-yu-ming-ci.html","excerpt":"","text":"最近写了太多技术文章，今天想写一点简单的东西。当一个新人问：如何开始学前端？很多知乎人都会发这样的脑图： img 新人表示很淦，并点上右上角的“关闭”。 个人也有很讨厌找学习资源的时候，老手总是给一些“大而全”但对新人极度不友好的答案，我知道发图的人可能真的想为了新人好，但是这种图除了增加焦虑，没有大多作用。 但是前端发明了那么多的“名词”，不去了解又会一头雾水。这篇文章就给大家盘一盘前端开发那些“名词”的由来。 万维网让我们把时间倒回 1989 年。一个英国佬 Tim Berners-Lee img 发现他们实验室 CERN(European Organization for Nuclear Research)[1] 的资料越来越难管理了，资料很容易“丢失”，比如文件名忘了、或者维护这个文件的人走了，那么这些文件可能就永远“消失”在茫茫资料中了。 这个 CERN 实验室其实是研究物理的，并不是搞计算机的！但是当时各个地方的实验室都和这个实验室有合作，就难免要相互分享资料。当资料变得越发庞大的时候就很难管理了。另一个点是 CERN 的全名并不是英文名，而是法文：Conseil européen pour la recherche nucléaire 为此，Lee 提出 “Linked information systems” 的构想，并称为 World Wide Web，也即我们熟知的“万维网”。 两年后，在 1990 年，Lee 又发了第二个提案[2]。最后提出需要2个人在6个月内造出的万维网的想法。最后造出了第一个网站：http://info.cern.ch/。 img 从上面可以看到，一个简单的 Client-Server 架构已经出现了。把文件放到服务器上，在客户端上访问它。 img 构建页面骨架对于学术论文，一般都是有专业格式的，如果只是纯文字展示，换谁也受不了呀。 所以，Lee 受 SGML(Standard Generalized Markup Language) 的启发创建了 HTML(Hyper Text Markup Language)。一般常用的标签有：h1~h6, div, header, body, main, footer, table, ul, li, button 等。 123&lt;header&gt;头&lt;/header&gt;&lt;main&gt;身&lt;/main&gt;&lt;footer&gt;脚&lt;/footer&gt; 如果你简单尝试写一个 .html 出来，会发现 和 的效果是一样的。但是，为了代码更语义化，也即可以让后面的人能看得懂，一般在头部会使用 ，如果是文章则用 作代码块的区分。如果非要扛：我就喜欢用 div 行不行，那不用扛了，当然行！ 美化页面虽然标签可以做一些简单的样式，但是依然满足不了设计师的样式要求。 为了解决网页的样式问题，Lee 的同事 Håkon Wium Lie[3] 在 1994 年，起草并提出了 CSS(Cascading Styling Sheet)。一段简单的 CSS 就可以让页面丰富起来了： 123body &#123; color: red;&#125; 很多人可能都知道 CSS 这个玩意，用得理所当然，但是你有没有想过，其实 XML 也可以用来表示样式的，比如在 Android 上就是这么做的。在那个时候， DSSSL[4] 和 FOSI[5] 也曾是浏览器样式的候选人，但是用这两玩意来写样式太麻烦了，所以最后才选择 CSS 作为浏览器的样式书写标准。 现在我们使用 CSS 已经是非常好用了，但在以前 CSS 的标准化之路是充满着坎坷的： •当 CSS1.0 发布后，几乎没多少浏览器可以支持它。等支持 CSS1.0 的时候 CSS2.0 都已经被放出来了•CSS2.0 增加了更多的样式选择。CSS2.0 是在1997年提出来的，但是在升级为 3.0 的时候经历了大幅的打回、重改，重新提名。直到 2011年 CSS2.1 才作为标准发布出来•到了 CSS3.0，它不像 1.0 和 2.0 那样整个版本升级，而是将样式的升级模块化。现在，虽然我们用的还是 “CSS3.0”，但是其实某些模块已经可以算是 4.0 img CSS UI 库写了很多次 CSS 后，前端工程师们发现，一些好看的 CSS 样式可以拿出来共享呀，比如我写好了一个按钮的样式： 123.btn &#123; ...&#125; 然后，其它人只要复制这个 CSS 到他的项目里，然后在 HTML 用上 CSS 类名，就可以直接用上我写的效果啦。 1&lt;button class=\"btn\"&gt;我的按钮&lt;/button&gt; 在这段时间里，各种 UI 小组件的 CSS 样式满天飞，比如今天出个按钮的，明天就出了个输入框的。市面上还曾出现过很多类似《XX个好看的UI组件》和《XXXX年最好看的Y个UI组件》的文章。 不久后，开发者就发现另一 个问题：组件样式之间的冲突，比如，按钮的样式影响了自定义按钮的样式。另一个大问题是，单看一个组件的样式挺好看的，但是如果一个网页用了4 5 个别人写好的 CSS 样式，就会显得非常不协调，没有统一感。兼容性也很差。 Twitter 的 Mark Otto 和 Jacob Thornton 也想过这个问题，所以他们开发了 Bootstrap UI 库： img 1234&lt;div class=\"input-group mb-3\"&gt; &lt;span class=\"input-group-text\" id=\"basic-addon1\"&gt;@&lt;/span&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"Username\" aria-label=\"Username\" aria-describedby=\"basic-addon1\"&gt;&lt;/div&gt; 把常用的按钮、字体、输入框的一些样式都写好了，还提供示例代码。这个 UI 库发布了之后，几乎所有开发者用过了，毕竟 CSS 终于可以不用自己写了。 当时我的也用 Bootstrap 写过课堂作业，那真是爽啊，一行 CSS 都没写过。 响应式布局2011年，苹果发布了那款经典的 iPhone4S，标志着智能手机真正成为人们不可或缺的一部分，而手机上访问的需求也同时增加了不少。 img 当年在手机上看网页，用户都要先进入页面，手动放大，点击对应链接再进入下一个网页，操作非常复杂，而且界面很丑陋。 另一个方面，随着手机进入人们的生活，手机上的 App 也像雨后春笋一样疯狂冒出。这时，程序员就想：就把网页做成 App 的样子不就好看了嘛。 那怎么判断用户用的是手机还是电脑呢？很简单：通过屏幕宽度来判断嘛，而 CSS 的 media query（媒体查询） 正好可以用来解决这个问题： 12345678910111213/*屏幕宽度在 600px 以内时，背景色显示红色*/@media only screen and (max-width: 600px) &#123; body &#123; background-color: red; &#125;&#125;/*大于 600它时，背景色显示白色*/@media only screen and (min-width: 600px) &#123; body &#123; background-color: white; &#125;&#125; 问题又来了：难道每个兼容样式都要写两遍？能不能只写一种样式就能兼容手机和电脑端呢？程序员们开始通过百分比，em，rem，优化布局等方式，使得屏幕变小后样式还是不会乱。 这种写 CSS 的思路就叫做 响应式 布局，兼容了手机和网页。 不过 响应式 也不是万能的。比如今天淘宝页面里的一些花里胡哨的样式就没法兼容手机端，所以现在的做法是做两套网页，电脑端做一套，手机端做一套。区别是：手机端的样式做得像 App 一些，而且功能不会太多，样式也不会很复杂，而且提供“从XX App”打开的按钮，向自家的 App 引流。电脑端更酷炫，功能更强大。毕竟现在应该没人在手机网页上购物吧？ 如果你仔细看手机端的网页地址，都会以 m.xxxxx 开头，就表示网页只在手机上看的。 JavaScript 将内容动起来 注意：上面的 HTML、CSS 都不属于编程语言，HTML 是标记语言，而 CSS 是样式表。 现在我们有 HTML 和 CSS 已经可以让页面变好看了，但是页面内容都是定死的。为了能让页面“动”起来，浏览器必须要引入一种编程语言。那就是 JavaScript。 当年，本来有人想把 Java 用作浏览器的编程语言的，但是搞 Java 的 Sun 公司说：没空理你。所以，网景公司 NetSpace 只好自研编程语言。本来新语言想叫作 LiveScript，但是觉得这个名字又平平无其，不能一炮而红。当时 Java 正如日中天，所以，为了做个标题党、蹭个热度，在 12 月发布的时候改名为 JavaScript，并引入了一些 Java 的特性，然而，令人没想到的是，这些特性将会成为前端工程师的噩梦。 JavaScript 除了做一些简单的业务逻辑，比如判断是男是女： 123if (you === 'male') &#123; console.log('男男')&#125; 还会操作 HTML，但是 HTML 不是一段文本么？怎么操作呢？实际上当浏览器拿到 .html 文件后，会自动解析 HTML 文本，将其转为为 DOM(Document Object Modal)，将普通的文本转换为一棵树的结构。 img JS 只需操作 DOM 就可以修改 HTML 的布局和结构了。 1document.getDocumentById('hello').textContent = '我是帅哥' // 内容变成“我是帅哥” JavaScript 是一个设计极其糟糕的语言，比如 getMonth() 时，如果现在是1 月，返回的则是 0，而 getHours() 又会准确返回当前的小时数。对于数组的操作又少得可怜，比如没有 unique, findBy 这些 API。 为了给 JavaScript 的设计擦屁股，一些工具库营运而生： •jQuery: 提供很多操作 DOM 的 API•moment, dayjs：提供很多操作 Date 对象的 API•lodash：更多像是个工具库 服务端渲染虽然 JS 能动态修改内容了，但是，在以前发异步请求是一件很麻烦的事情。 Java 程序员想到了一个办法：JSP。反正要访问服务端，不如在你访问的时候，我直接从数据库里把数据读出来，生成一个 HTML 给你不就好了嘛。这种技术就叫做 JSP。 代码语言：javascript 复制 123456789101112131415161718192021222324252627&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ page import=\"java.io.*,java.util.*\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;HTTP 头部请求实例&lt;/h2&gt;&lt;table width=\"100%\" border=\"1\" align=\"center\"&gt;&lt;tr bgcolor=\"#949494\"&gt;&lt;th&gt;Header Name&lt;/th&gt;&lt;th&gt;Header Value(s)&lt;/th&gt;&lt;/tr&gt;&lt;% Enumeration headerNames = request.getHeaderNames(); while(headerNames.hasMoreElements()) &#123; String paramName = (String)headerNames.nextElement(); out.print(\"&lt;tr&gt;&lt;td&gt;\" + paramName + \"&lt;/td&gt;\\n\"); String paramValue = request.getHeader(paramName); out.println(\"&lt;td&gt; \" + paramValue + \"&lt;/td&gt;&lt;/tr&gt;\\n\"); &#125;%&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 被程序员一直喊为 “世界上最好的编程语言” PHP也沿用了这个思路。这类通过服务端动态生成 HTML 的方法就叫 服务端渲染。 但是这上面有两个问题： 1.如果 Java 里有报错的时候，页面会显示整个错误 Stack 给用户，体验非常不友好，而且一崩全崩 img 1.高度耦合的代码非常不利于维护，比如，第一眼看上面的代码能看出个啥子哦2.一个工程师除了要处理服务端的逻辑、也要考虑样式要怎么写、页面逻辑，职责不明确 虽然上面的 JSP 和 PHP 流行过一段时间，但是程序员们为了分工更明确，都选择了前端程序员管页面开发、而后端程序员管服务端的开发。这种开发模式也被称作 前后端分离。 而前后端的重要沟通桥梁就是异步请求，也即大家现在经常说的 Ajax请求，但是在很久以前，异步请求还是一个实现上特别困难的事情。在那个时候发完请求，页面就不得不重新刷新一遍，用户体验非常差。 JSONP上面说到的问题在于：浏览器很难在不刷新页面的情况下，向服务器发异步请求来获取内容。 聪明的程序员就开始想：什么东西能发异步请求呢？然后他们发现如果直接创建一个 img 标签并写上 src 就会向服务器发一个 xxx.jpg 的异步请求了： 1&lt;img src=\"xxx.jpg\"&gt; 那么如果要发个异步的 Get 请求，可以这样搞呀： 1.偷偷摸摸地创建一个看不见的 img 标签2.把要访问的 url 放到 src 里 123456789function getData(url) &#123; var imgEl = document.createElement('img') // 创建 img 标签 imgEl.visibility = 'none' // 把 img 标签变成不可见 imgEl.src = url document.appendChild(img) // 加在网页上，自动发送 Get 请求&#125; 但是上面这么又引出下面的问题： 1.不知道什么时候要清理新生成的 img2.请求发了就发了，响应后不知道怎么获取数据3.每次都要写 imgEl.visibility = &#39;none&#39; // 把 img 标签变成不可见 这句话 为此，程序员再次想了很多办法。 首先，不再使用 img 标签，而使用 script 标签，就可以把第 3 步省略了。 第二步，在全局定义一个函数用于获取 users 信息： 123function getUsers(users) &#123; console.log(users)&#125; 在写 url 的时候加一个参数上去：https://www.baidu.com/users?callback=getUsers。服务端从参数里读取到 getUsers，向浏览器返回 JS 脚本： 1getUsers(['Jack'. 'Mary']) 由于刚刚添加的标签是 script 标签，所以等服务器返回后，getUsers([&#39;Jack&#39;. &#39;Mary&#39;]) 就会被马上执行，最终就会将 users 打印出来。这种技术就叫做 JSONP，全称为 JSON with padding。 JSONP 另一个好处是可以实现跨域请求，因为 script 标签可以请求非同源策略的资源并获取返回的数据。但是这非常不安全，服务器很容易被一些恶意的 JS 代码给攻击了。 Ajax从上面看出来 JSONP 能用但是很不规范，程序员们非常想要一套完善的异步请求机制。 2004 年，Google 在开发 Gmail 和 Map 两个应用的时候，完善了异步请求的机制，并制定了一些标准。 2006年时， W3C 起草了第一份 XMLHttpRequest 的草案，然后不断完善，一直到最后一份草案则在 2016年 被提出，XMLHttpRequest 才成为正式的标准。我们经常所说的 Ajax 请求其实就是使用这个对象来发请求的。下面就是用这个对象发送请求的代码： 12345678910111213141516// 生成请求对象xmlhttp = new XMLHttpRequest();// 监听请求的状态和返回xmlhttp.onreadystatechange = function () &#123; if (xmlhttp.readyState === 4) &#123; if (xmlhttp.status === 200) &#123; // 200 = OK console.log('成功'); &#125; else &#123; console.log('失败'); &#125; &#125;&#125;;// 打开通道xmlhttp.open('GET', url, true)// 发送请求xmlhttp.send(null); Ajax 全名是 Asynchronous JavaScript[6] and XML[7]，它不是单单一门技术，而是多门技术的全集，所表求的是：在客户端创建异步应用的一系列技术。只不过核心其中一步就是发异步请求，而 XMLHttpRequest 正好可以帮助我们完成这项工作。 Node.js2009 年，前端另一大飓风席卷了全球。Ryan Dahl 编写了第一个最初版本的 Node.js，使得 JavaScript 除了可以在浏览器里运行，也可以在拥有 Node.js 平台的地方运行，比如自己电脑的终端里。 img JavaScript 终于不再是客户端语言，也可以做服务端的开发了。为了更方便做服务端的开发，TJ Holowaychuk 一个国外超级大佬，借鉴了 Ruby 社区的 Rack，开发了 Express.js，一个简易的 JS 服务器框架。 img 由于 Express.js 提供的功能太简单了，所以，很多开发者不断给这个框架开发各种各样的中间件，使用者可以用这些中间件增强自己服务器的功能，比如 body-parser, cookie-parser, passport 等。 后来，TJ 觉得 Express.js 写得还是不够精简，本来想重构的，但是重构成本太大了，干脆再造一个轮子吧，这个轮子也就是我们熟悉的 Koa.js。 img 为了让 JS 更好地完成服务端开发的工作，前端开发人员把后端开发的一些工具都造了一遍： •连接数据库：mysql, mysql2, mongodb•缓存：session, redis•ORM: TypeORM, sequelize•定时任务：node-schedule, cron•… Serverless当很多人都开始用 Node.js 的时候，大家又发现一些问题： 1.写完代码，本地跑起来也挺好的，那怎么部署到服务器上呢？2.服务器要怎么买？HTTPS证书从哪里获取？Nginx是个啥？啊，好烦啊，我只想 npm run start 啊 作为前端程序员，平时搬砖就够累了，还要我配置服务器，一剑杀了我算了。 聪明的程序员发现，不管你写 Express.js 还是 Koa.js 不就是写响应函数么？ 123app.get('/users', (req, res) =&gt; &#123; res.send('我是帅哥')&#125;) 那我把服务器、证书、域名这些东西都统统给你弄好，你就负责写相应函数和给钱不就很爽了么？这就是 Serverless 的由来。它的好处是不再操心服务器的配置、扩展等琐碎的事情，只需要写好响应函数就好了。而这种“响应函数”也被称为 云函数，Amazon 称此为 Lambda。 img 这时候有人发现，我自己写好的一些服务，比如收发邮件、数据库的存取也可以作为一种服务对外提供，前端工程师只需要给钱，然后请求我提供的 API 接口就可以享受我的服务啦。这也是很多云厂商另一种收入来源：卖服务。 比如，常见的：语言翻译服务、手机短信发送服务、鉴黄师、图形识别等。 模块化当工具变得越来越多，Web 应用体积也变得越来越大了。一个大项目里可能有成百上千个 JavaScript 文件，它们之间相互依赖，可怕的是当前没有工具可以告诉你到底哪个文件是最先被执行的。 文件的管理就成了一个大问题，所以以应用需要划分模块。 在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。 1const xxx = require('xxx') ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。 123import xxx from 'xxx'export default xxx 模块化思想的提出大大提高了 JS 程序员的幸福感，所有的 JS 文件都不再是同一层级，而可以分块管理了。对前端的工程化有着不可或缺的作用。 包管理工具有的工程师发现，自己抽象出来的模块其实也可以放在社区让别人使用，比如发异步请求的 axios，工具库 lodash 等。这就需要一个中心仓库来存放这些库了，同时也需要一个包管理工具来管理包的发布、安装、升级等。 目前 npm 就是使用最多的包管理工具，当电脑里装了 Node.js 后，npm 也会一并装上。不过使用 npm 在国内下载时会很慢，一般推荐使用 yarn 这个包管理工具，速度更快。 工程化模块拆分使得写代码时候爽了，但是如果把这些 JS 文件都引入到一个 HTML 上是不是太恐怖了？一个 HTML 里有 1000 个 script 标签，比内容还多也有点反人类了吧。CSS 文件同理。 为了解决这个问题，前端工程师提出了 bundle 这个概念——不管你的模块多乱，多分散，最终通过一个工具，直接转换为1 个 .js 文件。这样的工具就叫做打包工具。 在 2016 年，Grunt，一个 JavaScript Task Runner 被制作出来了，开发者可以编写自己的任务，然后流水线地执行。这已经有了工程化的雏形了。 但是 Grunt 的打包速度太慢了。工程师们受不了了，又造了一个 Glup 的打包工具，功能差不多，但是一个字快！ 与此同时，另一只巨兽也在悄然进化——Webpack。 img Webpack 以其强大的功能、高灵活配置度的特性直接抢夺了 Glup 的市场，很多人都纷纷用起了 Webpack。 随着 Webpack 的功能不断增强，开发者的要求也不断提高，市面上充斥着大量的 Loader 和插件： •热加载•代码混淆•代码压缩•精简代码、TreeShaking•loader: file-loader, css-loader, vue-loader•… Webpack 的另一个问题是，不同环境需要不同的 Webpack 打包配置，导致 Webpack 的配置越来越繁琐，前端工程师除了平常写代码之外，还要负责维护 webpack.config.js 的配置项目。 而 Parcel 的出现正好打破了这一局面，使用 Parcel 就像使用 iPhone 一样，不用太多配置可以马上跑出小网页。但是，治本不治根，在大型项目面前，还是没办法解决繁琐配置的问题。所以，Webpack 依旧是占领市场的巨头。 img 使用 Webpack 的另一个问题是本地开发打包很慢，Webpack 一般先打包构建再启动开发服务器。而 Evan You 则想到另一个方法：先启动开发服务器，当代码执行到模块加载时再请求对应模块的文件。加快本地开发时的打包编译速度，然后造出了 Vite。目前 Vite 还是个新生儿，可以关注一波，看看以它以后会迸发出什么好玩的东西。 img CSS 预处理器CSS 让人诟病的一点是不够简洁，很多东西不能复用。比如： 1234567.container &#123; background: red; /*背景为红色*/&#125;.container .title &#123; color: red; /*标题字体为红色*/&#125; 为什么不写成这样呢： 123456.container &#123; backtround: red; /*背景为红色*/ .title &#123; color: red; /*标题字体为红色*/ &#125;&#125; 遗憾的是，浏览器只认识 CSS，不认识上面这样的写法。程序员又开始思考了：其实我不用浏览器认识第二种写法，我只要把第二种写法在打包的时候转换成 CSS 不就行了嘛。有了打包工具的加成，这件事我觉得能成！所以，第二种高级写法被称为 CSS 预处理器，即这些写法要先被处理成 CSS，然后再以普通 CSS 使用。 于是，在 2007 年，Sass 诞生了，借鉴了 Ruby 社区的 Sass 语法，但是前端程序员比较傲娇：凭啥要跟你叫一个名，就叫为 Scss，不过一般叫法还是叫 Sass，因为 Scss 不会读，哈哈。 img 后来在 2009 年，Less 被创造出来了，语法 Scss 差不多，没多大差别。 img 在 2010 年，又一个预处理器 Stylus 诞生了。 img 目前 Scss 和 Less 用的比较多，Stylus 名气比较小。新手不用担心，这三玩意语法都差不多，大同小异，会一个相当于3个都会了。 进击的 JavaScript虽然 JavaScript 本来是一个设计非常糟糕的编程语言，但是 JS 它不是咸鱼，它也要努力成为世界上最好的编程语言！ JavaScript 总不能一成不变吧？但是也不能一下子就变天了吧？所以，需要有一个起草方案，审核方案，同意方案，变成规范的过程，这需要大量的人力和专家，那不如做一个 “JS爱好者协会”？European Computer Manufacturers Association (ECMA) 就是类似这样的组织，不过这个组织格局比“JS爱好者协会”的格局大多了，主要任务是是将 Computer System 标准化。 ECMA International 在 ECMA-262[8] 里规范了 JavaScript，可以认为 ECMAScript 就是标准的 JavaScript，所有浏览器都要支持标准的 JavaScript。这个 262 的标准规范从 1997 年开始提出了第 1 版。 img 从上面可以看到，往后几年就是第 N 代的 ES 标准对应标准的 JavaScript 就是 ECMAScript 201(N-1)，比如我们最熟悉的 ES6 其实就是 ECMAScript 2015。而 ES6 对 JavaScript 一个大变革，后面的 ES7，ES8 新增的东西就很少了，所以现在 ES6 其实是 ES6+ 的一个泛指。 但是你有没有想过一个问题：虽然我用最新的语法做开发，但是用户用的可能还是老版本的浏览器呀，这要怎么办呢？ 再次得益于自动化打包工具的兴起，我们可以在开发的时候用最新的语法，在打包生产代码时将新语法都转成旧语法就好了嘛。这种语法的转换听起来就很麻烦，不过，聪明的前端工程师已经帮各位大哥大嫂做好，那就是 Babel。 img Babel 发展到了现在，除了做新旧语法的转换，还支持 JSX 语法的转换。 TypeScript虽然 ES6 新增的语法和 API 已经大幅提升前端程序员的幸福感了，但是 JavaScript 依然是个弱类型的语言： img 类型不规范，同事两行泪。当不正确使用类型时： 那能不能强行给 JavaScript 加上类型呢？微软说：可以！由微软牵头，开发了 TypeScript 编程语言和 TypeScript 的编译器，前者其实是 JavaScript 的超集，只是多加了很多料；后者则是负责将 TypeScript 编译成 JavaScript。 注意：这里的 TypeScript -&gt; JavaScript 是不能用 Babel 实现的，因为这一步是编译，而不是新旧语法的替换。TypeScript 不是新语法，是一门正经的编程语言，只不过可以被编译成 JavaScript。 有了 TypeScript，开发者终于享受到了强类型约束的福利了： 1const x: string = '123' 再再再一次得益于自动化打包工具人 Webpack，可以在输出生产代码时将 TypeScript 编译成 JavaScript，如果再加上 Babel，则能进一步转为某个时代的 ECMAScript。 单页应用在打包工具不断厮杀的同时，单页应用框架也一并发展。 在以前，大部分都是一直在用 jQuery 直接操作 DOM 来更新页面。 每次操作 DOM 时就不得不写一些面条代码。但是这样很麻烦啊，操作 DOM 这一步能不能封装一下，数据更新时自动操作 DOM 去更新页面？ 2010 年，Google 研发的 Angular.js 率先实现了 MVVM 想法，即开发者不再需要操作 DOM，可以直接拿数据渲染页面 Modal-View，而页面的变化，比如输入值改变，可以反过来改变数据内容。后来又研发了 Angular2，但是无论是 Angular.js 还是 Angular 本身都太复杂了，借鉴了非常多的后端设计，前端工程师上手难度非常巨大，最终并没有形成大潮流。 注意 Angular.js 和 Angular 是两个不同的东西！ img 2013 年，一个新的前端框架诞生了——Facebook 的 React.js。React 可以说是一个非常纯净的 JS 框架，没有 Angular 繁琐的内容，开发者只需要关注单向数据流就可以上手撸页面了。最后 React.js 在前端社区流行了起来。 img 但是 React.js 也有自己的问题：由于 React.js 内容太过于纯净了，本身没有太多的功能，导致开发 React 应用时出现非常多的解决方案，但没有一个方案是最优的，各有各的优缺点。这也导致了 React 社区总是骂战不断、帮派林立、出现各式各样的鄙视链的局面。 比如，在写样式时你可以直接 import 样式文件： 123import 'xxx.css'const xxx = &lt;button className=\"xxx\"&gt;xxx&lt;/button&gt; 也可以用 CSS module 123import styles from 'xxx.css'const xxx = &lt;button className=&#123;styles.xxx&#125;&gt;xxx&lt;/button&gt; 也可以用 styled-component 12345const Button = styled.a` color: white;`const xxx = &lt;Button&gt;xxx&lt;/Button&gt; 但是偏偏有人说 styled-components 是高级人，别的都是垃圾，使用 CSS Module 的人就受不了了，说你天天引那么多库来干嘛？ 另一个麻烦点是，单向数据流并不是所有人都喜欢的，人们开始怀念 Angular 的数据双向绑定了。 到了 2014 年，那个男人来了，他带着 Vue.js 来了！ img Evan You 以前在 Google 和 Meteor 工作过。Vue.js 取了 Angular 和 React 的中间位置，以一种优雅、轻便的姿态登陆前端社区。保留了 Angular 的数据双向绑定，但是摒弃了 Angular 很多复杂的设计和 API，同时不像 React.js 那么纯净，开放很多方便的 API 给使用者爽爽。而且还基于 Webpack 开发了 vue-loader 用来解析 .vue 模板文件。这种 .vue 模板文件和 .html 非常相象，新人上手十分简单。 img 同时，得益于 Vue 简洁好看的中文官方文档，Vue.js 在中国迅速抢占了小公司的市场。 但是由于 Vue.js 太容易上手了，所以经常被 React.js 社区的一些人觉得写 Vue.js 的人都是新手。而 Vue.js 的人又觉得写 React.js 的人天天折腾这么多“最佳实践”，简直是在浪费生命，而且 JSX 的语法太丑了，不如我的 template 语法简洁好懂。直到现在，Vue 和 React 社区时不时就会爆发小规模的骂战。 img 另一个问题出现了：原来的 UI 库仅仅提供了简单的 CSS 和原生的 JS，这些 JS 放到单页应用里显得有点冗余了，有的还会报错，因为大多数都是 DOM 的操作。所以 UI 库必须要配合对应的 SPA 框架进行升级。在别的 UI 库升级的同时，饿了么针对 Vue.js 开发 Element UI，而蚂蚁金服则针对 React 开发了 Antd。随后，更多的 UI 库再次涌现，比如 iView、Ant Design for Vue, Ant Design for Angular 等。 总得来说，Angular, React.js, Vue.js 都开发了自己的一套单页应用框架，这套框架最后要做的就是 SPA(Single Page Application) 单页应用。即所有的逻辑都打包在 JavaScript 文件里了，对外，只会看到一个 .html，一个 .css 和一个 .js 文件。 等一下？一个 .html 文件？那不同页面怎么做跳转呢？这就是前端路由的由来了。 前端路由不妨想想以前是怎么做路由的：用户页是 user.html，首页是 index.html，一个 url 对应着一个文件，也就说我们每次键入 url 时，实际上是访问某个 .html。 img 而浏览器里有一个监听浏览器地址改变的功能，单页应用的开发者就想了：我只要监听地址 url 的变化，再用 JS 渲染对应的页面组件，不就可以实现前端控制路由了么？这就是前端路由的基本思想。 img 上面的三大单页应用框架都有自己的前端路由框架：@angular/router, react-router, vue-router。 img 数据管理单页应用框架另一个问题就是数据的管理，子组件访问的数据都只能靠父组件传过来，如果一个在很深的子组件想要最外层组件的数据时，就不得不把数据从头一路传到尾。 为了应对这种数据很难共享的问题，程序员就想：我把数据都存到一个公共的地方不就行了嘛？要的时候随便拿。 img 那公共地方是哪里呢？存全局变量？不行啊，会被别人覆盖啊，而且数据改了之后视图不能随之改变呀。所以，工程师又开发一些全局数据管理库：mobx, vuex, redux。 img 同构渲染用多了单页框架之后，程序员们又发现问题了，单页最后生成的 HTML 是这样的： 1234&lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;script src=\"bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt; 要知道搜索引擎每天都会用网络爬虫抓取成千上万个网页，分析 HTML 里的内容，以此来提高搜索准确性，这种做法做叫 SEO(Search engine optimization) 搜索引擎优化。但是你看上面这样的结构，搜索引擎根本不知道你这个网页是用来干嘛的。另一个问题是，如果用户网络环境很差，那只要 JS 还没被加载出来，网页永远是一片白色，这非常影响用户体验。这要怎么解决呢？ 大家开始怀念当时 JSP、PHP 服务端渲染 HTML 的时候了，因为服务端渲染 HTML 可以马上返回 HTML 结构，页面会先展示一些内容，不至于白屏，而且有了大概的 HTML 结构，搜索引擎更容易做 SEO。 前端工程师想到了：对于一些静态内容，比如商品种类、导航栏内容，其实可以在生成 HTML 的时候就加上，不需要再通过 API 获取了。这样的技术就叫做 SSG(Static Site Generation)。那动态的内容，比如朋友圈列表怎么做呢？初始展示的数据可以先通过服务端先渲染，等用户与页面发生交互，比如点击按钮后再发请求获取数据。这就是 同构渲染。 img 与传统的服务端渲染不同，同构渲染的服务端也使用 JavaScript 来编写，这样一来前后端都使用上了 JavaScript 了。 同构渲染简单来说就是一份代码，服务端先通过服务端渲染(server-side rendering)，生成html以及初始化数据，客户端拿到代码和初始化数据后，通过对 html 的 dom 进行 patch 和事件绑定对 Dom 进行客户端激活(client-side hydration)。 这个整体的过程叫同构渲染。既可以吸取服务端的优点，比如加速首屏渲染，又保留了 SPA 应用的特点，比如前端控制路由跳转，使得跳转时不需要再渲染新 HTML。 Single-SPA当越来越多项目用上了 SPA 框架后，当公司要把多个项目合并成一个项目的时候，这就很麻烦了，不同项目可能用的框架都不一样，比如用户详情用的是 Vue.js，而首页用的是 React.js，怎么把这两者结合呢？ single-spa 和国内阿里开发的乾坤就是解决这种问题的。本质上相当于造一个更大的“单页的应用”，这个“单页应用”里又会有多个单页的应用。 img 这种将多个 SPA 整合成一个大 Project 的技术就是 微前端。 自动化测试随着前端越来越工程化，自动化测试是比不可少的一件事。当造好一些轮子后，就需要接入自动化测试，不然每次修改都要做点点点的人工测试。 最简单的莫过于单元测试，目前单测常用的库有 *ava, jest, moch, sinon, chai 等。而前端又是一个非常依赖环境的工种，经常要用到不同的环境，比如 JSX 环境、浏览器环境，Vue 环境。又催生出很多提供 Mock 环境的库，比如 enzyme 就是用来提供 React 环境的。 img 同时，为了模拟一些特定的场景，前端还要 Mock 一些东西，比如 localStorage, indexedDB, cookie 等。这些都有不同的库和工具来实现，比如 mock-axios, mock-redux, mock-cookie 等。 上面的只是属于白盒测试的做法，前端能不能直接模拟人工做点点点的操作呢？可以的，这就叫端对端测试、或者叫 e2e 测试，或者叫集成测试。现在比较火的工具是 cypress 和 nightwatch。 img 不过对于业务经常频繁改动的项目，自动化测试并不是一件好事，改动频繁的业务带来的是变化无常的测试用例。写太多的测试代码，有时候变得事倍功半。 手机H5随着智能手机发展得越来越快，微信等一些应用里都不得不内嵌一些前端的 H5 页面，比如微信公众号文章，其实就是一个小型网页。 img 另一个应用场景是，工程师们发现 App 里也可以嵌入 H5 来做简单的展示和交互，这样一来移动端就可以少开发一些内容了。这种内嵌H5页面的应用开发也称为混合开发，开发出来的 App 就是 Hybird App. 现在我们手机上的支付宝、微信、QQ 等都是采用了混合开发的模式，既能使用原生的代码保证流畅度，同时又可以内嵌H5提升开发速度（注意，速度不等于效率）。 低代码手机上的 H5 写多了之后，前端工程师们又发现很多 H5 都千篇一律，很多都是模板一套，再改个颜色就OK了。 因此，聪明的程序员就想到了能不能用拖拽就生成网页呢？其实拖拽生成网页并不是什么新鲜事，也不难实现，早在 wordpress 的时代已经出现拖拽生成个人博客的工具了。只不过现在用到手机上了。 但是拖拽的问题在于不灵活，有时候非常死板。有些运营人员还是懂一点代码的。所以拖拽工具再度进化成了：可以给别人留个入口做一些简单的自定义事情。这种模板+简单代码做开发的就称为“低代码”开发，通过简单的配置就能自动生成页面。 需求生成代码除了拖拽，有没有更高级的生成代码工具呢？有！比如，用文字描述场景来生成前端代码，这也是阿里正在做的事情，它们正在研究 P2C （PRD to Code）。个人觉得这是一件好事，对于简单需求来说可以直接生成比什么都快。 img 有人会担心：这会不会取代前端工程师呢？答案是不可能，也不科学。再厉害的人工智能最终也无法实现设计复杂、灵活多变、千奇百怪、疯狂迭代的产品需求。最终取代的是只会写简单 html、css 的低级工程师。 最后不知不觉就写好了多东西，可见前端东西真的很多很杂。其实再下写去还能再细写下去，但是文章实在太长了，到此结束了。 这篇文章除了带大家了解前端常见的“名词”之外，还希望大家学前端时不要上来就我要精通XXX。你看前端的发展多么坎坷、都是通过解决一个一个问题才有今天的前端，学习也是同样的道理，先实现一个最 Low 的版本，再慢慢升级自己。 References[1] CERN(European Organization for Nuclear Research): https://en.wikipedia.org/wiki/CERN [2] 第二个提案: http://cds.cern.ch/record/369245/files/dd-89-001.pdf [3] Håkon Wium Lie: https://en.wikipedia.org/wiki/H%C3%A5kon_Wium_Lie [4] CSS4 (disambiguation): https://en.wikipedia.org/wiki/Document_Style_Semantics_and_Specification_Language [5] Formatting Output Specification Instance: https://en.wikipedia.org/wiki/Formatting_Output_Specification_Instance [6] JavaScript: https://en.wikipedia.org/wiki/JavaScript [7] XML: https://en.wikipedia.org/wiki/XML [8] ECMA-262: https://www.ecma-international.org/publications/standards/Ecma-262.htm 原文链接：https://mp.weixin.qq.com/s/1UZtXP83OTGEFHUTqDQVEw 1、什么是mvc、mvp、mvvm？什么是前后端分离，前后端分离的优缺点？mvc是model-view-control https://img1.sycdn.imooc.com//5b71441c00015da504160175.jpg 2、什么是单页面应用？为什么使用单页面应用？单页面应用路由实现的方法和原理？单页面应用可以叫做单页面多片段切换应用。通过控制页面的删除或者隐藏来实现单页面应用。单页面在移动端使用比较广泛。可以带来极致的体验。 https://img1.sycdn.imooc.com//5b725f76000141a506980682.jpg 3、什么是单线程？单线程与多线程的区别？什么是进程？进程和线程的区别和联系？单线程：就是同一时间只能做一件事情。JavaScript是单线程的。 多线程：就是同一时间可以同时做好几件事情。 进程中包含多个线程，单线程，多线程都是相对于同一个进程来说的。 一个浏览器tab页面就是一个进程。进程中包含js引擎线程，GUI线程、事件触发线程等。 进程是CPU资源分配的最小单位。 线程是CPU的最小调度单位。 4、异步调用的常用方法？什么是异步调用？回调函数、promise、async/await、generate。 异步调用主要是通过状态来管理的，到了这个时间点，或者任务完成后，就开始着手工作。例如： setTimeout(function(){},100),这个也可以看成是异步调用，100ms后开始执行函数内的代码。 5、对webpack的理解？为什么需要webpck？对构建、打包、编译的理解？webpack它是代码编译工具，有入口，出口、loader和插件。其天生就代码分割、模块化，webpack2.0中加入tree shaking，用来提取公共代码，去掉死亡代码。 构建、打包、编译他们都是为了提高开发效率，让前端朝着标准化的路上继续迈进 6、git常用命令？git和svn的区别？github是什么，npm又是什么？git的全部工作都是在这三个区之间工作。三个区是工作区，暂存区、远程仓库区。 建立一个git仓库：git init clone 远程仓库：git clone +git仓库地址 本地仓库和远程仓库建立连接：git remote add origin +git地址 拉去远程仓库 git pull origin master(master分支) 提交到暂存区：git add +文件 提交到master，此时Header指针指到这里：git commit -m ‘文件描述’ 推送到远程仓库：git push origin master 新建分支：git branch dev 删除本地分支：git branch -d dev (删除分支时，必须切换到另一个分支，才能删除想要删除的分支) 删除远程分支：git push origin -d dev 版本回退：git reset –hard HEAD^。 github是全球最大的代码托管平台。npm是全球最大的包管理工具。 github使用git clone +代码 ，可以下载代码。 npm通过npm install 安装，可以直接使用。 7、什么是构造函数？什么是原型链？原型链的用途？什么是对象？对象的用途？构造函数也是函数，无非让其具有扩展性功能，它使用扩展性功能又用了原型链的原理，原型链又用了计算机中核心局部性原理，你自身没有往上级找，上级没有继续往外找，这其中其实闭包也用了这种原理。 对象：万物皆是对象，就是先总体看待事情，然后再局部。对象中又有key和value。也可能包含方法。 8、对http的认识？从输入url到页面展现都发生了什么？这个参考链接： 1`https://segmentfault.com/a/1190000013662126` 9、什么是BFC？如何实现BFC？盒子模型认识？如何实现标准盒模型？这个是css中的块级格式化上下文。 盒子模型有标准盒模型和IE盒模型， https://img1.sycdn.imooc.com//5b725e3500018c4207550100.jpg 当设置为box-sizing:content-box时，将采用标准模式解析计算，也是默认模式； 当设置为box-sizing:border-box时，将采用怪异模式解析计算； 10、什么是栈，什么是堆？栈用来存储什么，堆用来存储什么？栈用来存储基本变量类型（number\\string\\Boolean\\undifeind\\null）和指针地址。 堆用来存储对象（key和val）或者函数大括号里面的代码。 栈和堆有下面的连接关系 ​ 11、什么是组件？什么是插件？组件和插件的区别和联系？组件是模版和UI逻辑的结合。而插件可以是一堆组件的结合，它是框架在功能上的扩展，如vue.prototype.add=function(){} 他们都是在封装、继承、多态思想上产生而来。 区别： vue插件可以将自己的模块添加到Vue原型对象上，然后组件中可以通过this直接引用。还要就是通过插件机制，可以通过一个入口，就可以将一系列组件添加到环境中，直接使用 插件是采用通用接口编写的，多用于制作好的东西功能扩展。 vue组件只是一个独立的模块，可重复使用并且可以和其他对象进行交互的对象 插件通常会为 Vue 添加全局功能。插件的范围没有限制——一般有下面几种：添加全局方法或者属性，如: vue-custom-element添加全局资源：指令/过滤器/过渡等，如 vue-touch通过全局 mixin 方法添加一些组件选项，如: vue-router添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。一个库，提供自己的 API，同时提供上面提到的一个或多个功能，如 vue-routerVue.js 的插件应当有一个公开方法 install 。 如果你的模块或者组件想对外公开，最友好的方式就是通过插件机制提供 12、对nodejs的认识？什么是事件驱动？什么是非阻塞I/O？nodejs是基于chrome V8引擎，以事件驱动，非阻塞I/O模型。他是一个可以在服务端运行js的环境。 事件驱动：就是触发一个事件，然后回调，再执行的过程。 非阻塞I/O：以异步来执行函数，先执行同步任务，耗时任务放在事件队列中，以此轮询执行 13、什么是hybrid？为什么使用hybrid？hybrid为什么可以不用审核直接发布？hybrid如何使用？hybrid：H5与原生端交互混合技术方案 web、native两个人交流，要么web主动，要么native主动，要么web、native都主动。 web主动就是webView UI 方案。也是市面上大部分采用的方案。通过jsbridge完成h5与native的双向通信，从而把native的一些原生能力（拍照、从相册中选取照片、查看通讯录、获取地理位置等，这些调用系统级别的能力，h5没有，所以这也是其不受审核，可以快速上线的原因）赋予给h5.（重点是webview渲染） native主动就是native UI 方案。例如reac-native\\weex，在赋予h5原生api能力的基础上。进一步通过jsbridge将js解析成虚拟节点树virtual Dom传递到native并使用原生渲染。（重点是原生端渲染） 两者都主动。目前流行的小程序。通过更加定制化的jsbridge，并使用webview双线程的模式，隔离了js逻辑与UI渲染，形成了特殊的开发模式。加强了h5与Native混合，提高了交互体验和页面性能。 hybrid本质是在原生的App中，使用webview作为容器承载web页面。这样就需要h5与native实现双向通信，这里我们就需要翻译员，保证我们两者的正常通信—跨语言通讯方案。native使用Java，object-c，h5使用jsbridge。两者通信翻译员就是jsBridge。是要有翻译员就要给他提供最优质的环境webview。一切的翻译也是通过webview的翻译机制。 基于webview的机制和开发的api，有三种方案 API注入，原理其实就是native获取JavaScript环境上下文，直接在JavaScript上插入原生方法或者对象，使用js（图灵完备语言，有逻辑）直接调用。 webview中prompt、alert、console拦截。通常使用prompt，但这个方法使用频率较低 3.webview URL Scheme跳转拦截，通过webview信息冒泡传递的拦截，从而达到通讯。 流程：定制协议—拦截协议—-参数传递—回调机制 （协议有http协议、https协议、file协议等） 原理：在webview中发出的网络请求，客户端都能够监听和捕获到。 14、什么是浅拷贝？什么是深拷贝？如何实现深拷贝？浅拷贝可以看做是一个快捷方式，实际共用一个内存地址。es6中的Object.assign({target},{obj})就是浅拷贝。 深拷贝相对于新开辟一块内存地址。使用JSON.stringify()可以实现深拷贝。 15、什么是缓存？缓存的分类？cache、localStorage和sessionStorage和理解？缓存是为了更快的进行磁盘I/O而存在的。有浏览器缓存、CDN缓存、路由缓存、服务器缓存等。 cache中会有http响应头和响应行的信息，如cache-control：max-age:20000。 还有就是cookie。cookie一般浏览器不超过4k ,主要是用来保存用户登陆信息。当发送请求时，会自动把其带上。 而localStorage和sessionStorage是浏览器本地storage中用来存取值的，sessionStorage浏览器关闭了就不存在了，localStorage浏览器关闭依然存在。 16、什么是闭包？闭包的用途？什么是递归？递归调用的用途？闭包就是有权访问另一个函数作用域内的变量函数都是闭包。 闭包就是一个函数引用另外一个函数的变量，因为变量被引用着所以不会被回收，因此可以用来封装一个私有变量。这是优点也是缺点，不必要的闭包只会徒增内存消耗！另外使用闭包也要注意变量的值是否符合你的要求，因为他就像一个静态私有变量一样 下面的就是闭包 https://img1.sycdn.imooc.com//5b72628900011edd03260248.jpg 原文链接：https://www.imooc.com/article/details/id/67905 toA、toB、toC、ToG是什么？有什么区别？TOA、TOB、TOC和ToG都是不同的业务模型或策略，它们分别针对不同的客户群体和市场。以下是这些术语的解释和它们之间的区别： TOA（Targeting of Audience）：即“瞄准目标受众”。这种策略强调对目标受众的深入了解和分析，以便为他们提供定制化的产品或服务。它类似于艺术家在创作画作前思考观众的口味和需求，销售人员努力满足广泛的需求，使产品或服务更容易被大众接受。 TOB（Targeting of Business）：即“面向企业”或“面向商业”。这种策略专注于为企业客户提供产品或服务，如设备制造商为企业提供设备。TOB市场策略侧重于吸引和满足其他企业的需求，通常需要更为专业的方法。销售人员需要深入了解客户的业务，提供针对性的解决方案。 TOC（Targeting of Consumers）：即“瞄准消费者”或“面向消费者”。这种策略主要针对个人用户的日常必需品，如衣食住行。这类需求普遍且客户群体庞大，因此需求指标多且分散。TOC模式关注的是如何满足消费者的日常需求，并提供具有吸引力的产品或服务。 ToG（Targeting of Government）：即“面向政府”或“面向公共部门”。这种策略主要为政府或公共部门提供产品或服务，如IT解决方案提供商为政府开发定制的软件系统。ToG模式关注的是如何满足政府或公共部门的需求，并提供符合其特定要求的产品或服务。 这些策略之间的主要区别在于它们所针对的客户群体和市场不同。TOA、TOB和TOC分别针对一般消费者、企业客户和个人消费者，而ToG则针对政府或公共部门。此外，这些策略在业务模式和营销策略上也可能存在差异，以适应不同客户群体的需求和偏好。 展业贷款、保险、理财等业务员为了寻找客户开展相应业务活动的总称 解耦解耦的定义解耦（Decoupling）是指通过降低代码之间的依赖性，减少模块或组件之间的耦合程度。在软件开发中，解耦是一种良好的设计原则，它可以提高代码的可维护性、可测试性和可扩展性。 当两个模块或组件之间高度耦合时，它们的改动往往会相互影响，一个模块的修改可能会导致其他模块的变动，这增加了系统的复杂性和风险。 解耦的目标解耦的目标是将这种紧密耦合的关系松散化，使得模块之间的改动互不影响或最小化影响。 实现解耦的方法 接口和抽象使用接口和抽象类定义模块之间的通信协议，而不是直接依赖具体实现。这样，当一个模块的实现发生变化时，其他模块不受影响，只需要适配新的实现即可。 依赖注入（DI）使用依赖注入来管理模块之间的依赖关系。通过将依赖关系的创建和绑定移到外部容器中，模块之间不再直接依赖具体实现，而是通过接口或抽象来进行通信，从而降低耦合度。 事件驱动编程使用事件驱动的方式来解耦模块之间的通信。模块通过发布和订阅事件来进行通信，而不是直接调用对方的方法。这样，模块之间的依赖关系可以通过事件进行解耦，每个模块只需要对感兴趣的事件进行订阅，而不需要知道具体的实现。 模块化设计将系统拆分成独立的模块，每个模块具有清晰的责任和功能。模块之间通过定义明确定义的接口进行通信，模块之间的依赖关系尽可能降低。 解耦的优点通过解耦，可以使系统更加灵活、可扩展和可维护。当一个模块需要修改或替换时，对其他模块的影响将最小化，使系统更具弹性和可扩展性。 同时，解耦也有助于提高代码的可测试性，因为模块可以更容易地进行单独的单元测试，而不需要依赖整个系统的其他部分。 前端hook在前端开发中，特别是在使用Vue.js这样的框架时，”Hook” 通常指的是一种机制，允许开发者在组件的特定生命周期阶段或满足某些条件时执行自定义的代码。然而，在Vue 2中，并没有直接引入名为”Hook”的概念，而是使用了一系列的选项（如data、methods、computed、watch等）和生命周期钩子（如created、mounted、updated、destroyed等）来实现类似的功能。 不过，从Vue 3开始，Vue引入了Composition API，其中的setup函数可以被视为一种“Hook”机制。 在setup函数中，你可以使用Vue提供的响应式系统、生命周期钩子和其他功能来组织你的组件逻辑。 转测是什么意思转测在软件开发领域主要有两层含义： 在软件开发流程中，转测指的是开发人员完成软件功能的编写后，将工作成果移交给测试团队进行专业测试的环节。这时，开发人员通常会发送一封转测邮件给测试团队，邮件中会详细说明本次转测的内容（包括变更及影响范围）、提供转测所需的软件包或访问地址、指明负责的开发人员，并可能附带相关辅助材料，如SQL脚本、配置手册等。转测的目的是全面检查软件的功能、性能、兼容性等，确保其达到既定的质量标准。 在数据库和系统迁移场景下，转测涉及验证现有系统中的数据能否成功转移到新的替代系统中。这包括测试数据转换的完整性和准确性，确保转换后的系统能够正常运作。转换测试（Conversion Testing）是确保数据处理软件或系统在经过转换后仍能正确工作的关键步骤，特别关注数据库和程序代码的转换效果。 简而言之，转测是一个确保软件质量的重要阶段，无论是从开发到测试的流程传递，还是在系统迁移中的数据与功能验证，都是为了发现并修复潜在问题，提升软件的稳定性和用户满意度。 提测和转测有啥区别提测和转测的区别是概念不同。 提测是指开发完成一个阶段的目标，将代码提交给测试人员，由测试人员对代码进行验证和测试。 而转测则是软件开发过程中一个特定的测试阶段，通常是在所有需求都开发完成并通过自测后进行的。转测的目的是对整个软件进行系统性的测试，以确保软件的整体质量和稳定性。","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"名词","slug":"名词","permalink":"https://qw8.github.io/tags/名词/"}]},{"title":"vue项目","slug":"link/vue项目","date":"2021-10-12T02:12:21.000Z","updated":"2024-05-09T10:10:09.830Z","comments":true,"path":"/link/vue-xiang-mu.html","link":"","permalink":"https://qw8.github.io/link/vue-xiang-mu.html","excerpt":"","text":"Vben Admin文档 http://doc.vvbin.cn/ 代码 https://github.com/vbenjs/vue-vben-admin.git 演示 https://vben.vvbin.cn/#/login 芋道管理后台的 Vue3 版本采用 vue-element-plus-admin ，Vue2 版本采用 vue-element-admin 文档 https://doc.iocoder.cn/ 代码 https://github.com/YunaiV/ruoyi-vue-pro https://gitee.com/zhijiantianya/ruoyi-vue-pro 演示 演示地址【Vue3 + element-plus】：http://dashboard-vue3.yudao.iocoder.cn 演示地址【Vue3 + vben(ant-design-vue)】：http://dashboard-vben.yudao.iocoder.cn 演示地址【Vue2 + element-ui】：http://dashboard.yudao.iocoder.cn RuoYi文档 http://doc.ruoyi.vip/ 代码 https://gitee.com/y_project/RuoYi-Vue 演示 http://vue.ruoyi.vip Soybean AdminSoybeanAdmin 是一个清新优雅、高颜值且功能强大的后台管理模板，基于最新的前端技术栈，包括 Vue3, Vite5, TypeScript, Pinia 和 UnoCSS。它内置了丰富的主题配置和组件，代码规范严谨，实现了自动化的文件路由系统。此外，它还采用了基于 ApiFox 的在线Mock数据方案。SoybeanAdmin 为您提供了一站式的后台管理解决方案，无需额外配置，开箱即用。同样是一个快速学习前沿技术的最佳实践。 文档 https://docs.soybeanjs.cn/zh/ 代码 https://github.com/honghuangdc/soybean-admin NaiveUI 版本: 预览地址 Github 仓库 Gitee 仓库 AntDesignVue 版本: 预览地址 Github 仓库 Gitee 仓库 旧版: 预览地址 Github 仓库 vue-element-admin这是一个基于 Vue 2.0 和 Element UI 的后台前端解决方案，适合快速搭建企业级中后台前端/设计研发界面。 提供了丰富的功能，如动态路由、权限验证、按钮级别权限控制、国际化多语言支持等。 源代码清晰，易于扩展和定制。 文档 https://panjiachen.github.io/vue-element-admin-site/zh/ 代码 https://github.com/PanJiaChen/vue-element-admin/ https://gitee.com/panjiachen/vue-element-admin 演示 https://panjiachen.github.io/vue-element-admin/ Geeker Admin文档 https://docs.spicyboy.cn/ 代码 https://gitee.com/HalseySpicy/Geeker-Admin 演示 https://admin.spicyboy.cn/ Nest-Admin 一款基于Nestjs最新版本的开箱即用的中后台管理系统 代码 https://github.com/taozhi1010/nest-admin https://gitee.com/tao-zhi/nest-admin 演示 https://nest-admin.dooring.vip 文档 代码 演示","categories":[{"name":"链接","slug":"链接","permalink":"https://qw8.github.io/categories/链接/"}],"tags":[{"name":"网站","slug":"网站","permalink":"https://qw8.github.io/tags/网站/"},{"name":"vue","slug":"vue","permalink":"https://qw8.github.io/tags/vue/"}]},{"title":"CSS","slug":"interview/CSS代码","date":"2021-07-07T15:30:10.000Z","updated":"2023-04-14T17:01:50.000Z","comments":true,"path":"/interview/css-dai-ma.html","link":"","permalink":"https://qw8.github.io/interview/css-dai-ma.html","excerpt":"","text":"如何居中 div？-水平居中：给 div 设置一个宽度，然后添加 margin:0 auto 属性 1234div &#123; width: 200px; margin: 0 auto;&#125; -水平居中，利用 text-align:center 实现 123456789101112.container &#123; background: rgba(0, 0, 0, 0.5); text-align: center; font-size: 0;&#125;.box &#123; display: inline-block; width: 500px; height: 400px; background-color: pink;&#125; -让绝对定位的 div 居中 1234567891011div &#123; position: absolute; width: 300px; height: 300px; margin: auto; top: 0; left: 0; bottom: 0; right: 0; background-color: pink; /*方便看效果*/&#125; -水平垂直居中一 123456789/*确定容器的宽高宽500高300的层设置层的外边距div&#123;*/position: absolute;/*绝对定位*/width: 500px;height: 300px;top: 50%;left: 50%;margin: -150px00-250px;/*外边距为自身宽高的一半*/background-color: pink;/*方便看效果*/&#125; -水平垂直居中二 12345678910/*未知容器的宽高，利用`transform`属性*/div &#123; position: absolute; /*相对定位或绝对定位均可*/ width: 500px; height: 300px; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: pink; /*方便看效果*/&#125; -水平垂直居中三 1234567891011/*利用flex布局实际使用时应考虑兼容性*/.container &#123; display: flex; align-items: center; /*垂直居中*/ justify-content: center; /*水平居中*/&#125;.containerdiv &#123; width: 100px; height: 100px; background-color: pink; /*方便看效果*/&#125; -水平垂直居中四 1234567891011121314151617181920212223242526272829/*利用text-align:center和vertical-align:middle属性*/.container &#123; position: fixed; top: 0; right: 0; bottom: 0; left: 0; background: rgba(0, 0, 0, 0.5); text-align: center; font-size: 0; white-space: nowrap; overflow: auto;&#125;.container::after &#123; content: ''; display: inline-block; height: 100%; vertical-align: middle;&#125;.box &#123; display: inline-block; width: 500px; height: 400px; background-color: pink; white-space: normal; vertical-align: middle;&#125; 回答： 12345678910111213141516171819一般常见的几种居中的方法有：对于宽高固定的元素（1）我们可以利用margin:0 auto来实现元素的水平居中。（2）利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。（3）利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素的中心点到页面的中心。（4）利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素的中心点到页面的中心。（5）使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。对于宽高不定的元素，上面的后面两种方法，可以实现元素的垂直和水平的居中。 怎么让一个不定宽高的 DIV，垂直水平居中？1.使用 CSS方法： 父盒子设置： 123display：table-cell；text-align：center；vertical-align：middle； Div 设置： 12display：inline-block；vertical-align：middle； 2.使用 CSS3transform： 父盒子设置： 1display：relative Div 设置： 1234transform：translate(-50%，-50%)；position：absolute；top：50%；left：50%； 用纯 CSS 创建一个三角形的原理是什么？123456789101112采用的是相邻边框连接处的均分原理。 将元素的宽高设为0，只设置 border ，把任意三条边隐藏掉（颜色设为 transparent），剩下的就是一个三角形。 #demo &#123; width: 0; height: 0; border-width: 20px; border-style: solid; border-color: transparent transparent red transparent;&#125; 为什么要初始化 CSS 样式？1234567891011121314151617181920212223-因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。-当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。最简单的初始化方法：*&#123;padding:0;margin:0;&#125;（强烈不建议）淘宝的样式初始化代码：body,h1,h2,h3,h4,h5,h6,hr,p,blockquote,dl,dt,dd,ul,ol,li,pre,form,fieldset,legend,button,input,textarea,th,td&#123;margin:0;padding:0;&#125;body,button,input,select,textarea&#123;font:12px/1.5tahoma,arial,\\5b8b\\4f53;&#125;h1,h2,h3,h4,h5,h6&#123;font-size:100%;&#125;address,cite,dfn,em,var&#123;font-style:normal;&#125;code,kbd,pre,samp&#123;font-family:couriernew,courier,monospace;&#125;small&#123;font-size:12px;&#125;ul,ol&#123;list-style:none;&#125;a&#123;text-decoration:none;&#125;a:hover&#123;text-decoration:underline;&#125;sup&#123;vertical-align:text-top;&#125;sub&#123;vertical-align:text-bottom;&#125;legend&#123;color:#000;&#125;fieldset,img&#123;border:0;&#125;button,input,select,textarea&#123;font-size:100%;&#125;table&#123;border-collapse:collapse;border-spacing:0;&#125; 如何实现单行／多行文本溢出的省略（…）？1234567891011121314151617181920212223/*单行文本溢出*/p &#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125;/*多行文本溢出*/p &#123; position: relative; line-height: 1.5em; /*高度为需要显示的行数*行高，比如这里我们显示两行，则为3*/ height: 3em; overflow: hidden;&#125;p:after &#123; content: '...'; position: absolute; bottom: 0; right: 0; background-color: #fff;&#125; 详细资料可以参考：《【CSS/JS】如何实现单行／多行文本溢出的省略》《CSS 多行文本溢出省略显示》 css 实现上下固定中间自适应布局？12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455利用绝对定位实现body &#123; padding: 0; margin: 0;&#125;.header &#123; position: absolute; top: 0; width: 100%; height: 100px; background: red;&#125;.container &#123; position: absolute; top: 100px; bottom: 100px; width: 100%; background: green;&#125;.footer &#123; position: absolute; bottom: 0; height: 100px; width: 100%; background: red;&#125;利用flex布局实现html,body &#123; height: 100%;&#125;body &#123; display: flex; padding: 0; margin: 0; flex-direction: column;&#125;.header &#123; height: 100px; background: red;&#125;.container &#123; flex-grow: 1; background: green;&#125;.footer &#123; height: 100px; background: red;&#125; 详细资料可以参考：《css 实现上下固定中间自适应布局》 css 两栏布局的实现？相关资料： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/*两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式。*//*以左边宽度固定为200px为例*//*（1）利用浮动，将左边元素宽度设置为200px，并且设置向左浮动。将右边元素的margin-left设置为200px，宽度设置为auto（默认为auto，撑满整个父元素）。*/.outer &#123; height: 100px;&#125;.left &#123; float: left; height: 100px; width: 200px; background: tomato;&#125;.right &#123; margin-left: 200px; width: auto; height: 100px; background: gold;&#125;/*（2）第二种是利用flex布局，将左边元素的放大和缩小比例设置为0，基础大小设置为200px。将右边的元素的放大比例设置为1，缩小比例设置为1，基础大小设置为auto。*/.outer &#123; display: flex; height: 100px;&#125;.left &#123; flex-shrink: 0; flex-grow: 0; flex-basis: 200px; background: tomato;&#125;.right &#123; flex: auto; /*11auto*/ background: gold;&#125;/*（3）第三种是利用绝对定位布局的方式，将父级元素设置相对定位。左边元素设置为absolute定位，并且宽度设置为200px。将右边元素的margin-left的值设置为200px。*/.outer &#123; position: relative; height: 100px;&#125;.left &#123; position: absolute; width: 200px; height: 100px; background: tomato;&#125;.right &#123; margin-left: 200px; height: 100px; background: gold;&#125;/*（4）第四种还是利用绝对定位的方式，将父级元素设置为相对定位。左边元素宽度设置为200px，右边元素设置为绝对定位，左边定位为200px，其余方向定位为0。*/.outer &#123; position: relative; height: 100px;&#125;.left &#123; width: 200px; height: 100px; background: tomato;&#125;.right &#123; position: absolute; top: 0; right: 0; bottom: 0; left: 200px; background: gold;&#125; 《两栏布局 demo 展示》 回答： 两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式。 以左边宽度固定为 200px 为例 -（1）利用浮动，将左边元素宽度设置为 200px，并且设置向左浮动。将右边元素的 margin-left 设置为 200px，宽度设置为 auto（默认为 auto，撑满整个父元素）。 -（2）第二种是利用 flex 布局，将左边元素的放大和缩小比例设置为 0，基础大小设置为 200px。将右边的元素的放大比例设置为 1，缩小比例设置为 1，基础大小设置为 auto。 -（3）第三种是利用绝对定位布局的方式，将父级元素设置相对定位。左边元素设置为 absolute 定位，并且宽度设置为 200px。将右边元素的 margin-left 的值设置为 200px。 -（4）第四种还是利用绝对定位的方式，将父级元素设置为相对定位。左边元素宽度设置为 200px，右边元素设置为绝对定位，左边定位为 200px，其余方向定位为 0。 css 三栏布局的实现？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158/*三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式。这里以左边宽度固定为100px，右边宽度固定为200px为例。*//*（1）利用绝对定位的方式，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。*/.outer &#123; position: relative; height: 100px;&#125;.left &#123; position: absolute; width: 100px; height: 100px; background: tomato;&#125;.right &#123; position: absolute; top: 0; right: 0; width: 200px; height: 100px; background: gold;&#125;.center &#123; margin-left: 100px; margin-right: 200px; height: 100px; background: lightgreen;&#125;/*（2）利用flex布局的方式，左右两栏的放大和缩小比例都设置为0，基础大小设置为固定的大小，中间一栏设置为auto*/.outer &#123; display: flex; height: 100px;&#125;.left &#123; flex: 00100px; background: tomato;&#125;.right &#123; flex: 00200px; background: gold;&#125;.center &#123; flex: auto; background: lightgreen;&#125;/*（3）利用浮动的方式，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式，中间一栏必须放到最后。*/.outer &#123; height: 100px;&#125;.left &#123; float: left; width: 100px; height: 100px; background: tomato;&#125;.right &#123; float: right; width: 200px; height: 100px; background: gold;&#125;.center &#123; height: 100px; margin-left: 100px; margin-right: 200px; background: lightgreen;&#125;/*（4）圣杯布局，利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。*/.outer &#123; height: 100px; padding-left: 100px; padding-right: 200px;&#125;.left &#123; position: relative; left: -100px; float: left; margin-left: -100%; width: 100px; height: 100px; background: tomato;&#125;.right &#123; position: relative; left: 200px; float: right; margin-left: -200px; width: 200px; height: 100px; background: gold;&#125;.center &#123; float: left; width: 100%; height: 100px; background: lightgreen;&#125;/*（5）双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元素的 padding 来实现的。本质上来说，也是通过浮动和外边距负值来实现的。*/.outer &#123; height: 100px;&#125;.left &#123; float: left; margin-left: -100%; width: 100px; height: 100px; background: tomato;&#125;.right &#123; float: left; margin-left: -200px; width: 200px; height: 100px; background: gold;&#125;.wrapper &#123; float: left; width: 100%; height: 100px; background: lightgreen;&#125;.center &#123; margin-left: 100px; margin-right: 200px; height: 100px;&#125; 《三栏布局 demo 展示》 回答： 12345678910111213三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式。这里以左边宽度固定为100px，右边宽度固定为200px为例。（1）利用绝对定位的方式，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。（2）利用flex布局的方式，左右两栏的放大和缩小比例都设置为0，基础大小设置为固定的大小，中间一栏设置为auto。（3）利用浮动的方式，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式，中间一栏必须放到最后。（4）圣杯布局，利用浮动和负边距来实现。父级元素设置左右的padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置margin负值将其移动到上一行，再利用相对定位，定位到两边。圣杯布局中间列的宽度不能小于两边任意列的宽度，而双飞翼布局则不存在这个问题。（5）双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的margin值来实现的，而不是通过父元素的padding来实现的。本质上来说，也是通过浮动和外边距负值来实现的。 实现一个宽高自适应的正方形123456789101112131415161718192021222324252627/*1.第一种方式是利用vw来实现*/.square &#123; width: 10%; height: 10vw; background: tomato;&#125;/*2.第二种方式是利用元素的margin/padding百分比是相对父元素width的性质来实现*/.square &#123; width: 20%; height: 0; padding-top: 20%; background: orange;&#125;/*3.第三种方式是利用子元素的margin-top的值来实现的*/.square &#123; width: 30%; overflow: hidden; background: yellow;&#125;.square::after &#123; content: ''; display: block; margin-top: 100%;&#125; 《自适应正方形 demo 展示》 实现一个三角形12345678/*三角形的实现原理是利用了元素边框连接处的等分原理。*/.triangle &#123; width: 0; height: 0; border-width: 100px; border-style: solid; border-color: tomatotransparenttransparenttransparent;&#125; 《三角形 demo 展示》 一个自适应矩形，水平垂直居中，且宽高比为 2:11234567891011121314/*实现原理参考自适应正方形和水平居中方式*/.box &#123; position: absolute; top: 0; right: 0; left: 0; bottom: 0; margin: auto; width: 10%; height: 0; padding-top: 20%; background: tomato;&#125; 文本超出部分显示省略号单行 123overflow: hidden;text-overflow: ellipsis;white-space: nowrap; 多行 1234display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 3; // 最多显示几行overflow: hidden; 什么是 Css Hack？ie6,7,8 的 hack 分别是什么？针对不同的浏览器写不同的 CSS code 的过程，就是 CSS hack。 示例如下： 12345678910111213141516171819#test&#123; width:300px; height:300px; background-color:blue; /_firefox_/ background-color:red\\9; /_all ie_/ background-color:yellow; /_ie8_/ +background-color:pink; /_ie7_/ \\_background-color:orange; /_ie6_/ &#125; :root #test &#123; background-color:purple\\9; &#125; /*ie9*/@media all and (min-width:0px) &#123; #test &#123;background-color:black;&#125; &#125; /*opera*/@media screen and (-webkit-min-device-pixel-ratio:0)&#123; #test &#123;background-color:gray;&#125; &#125; /*chrome and safari*/ 实现不使用 border 画出 1px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。1&lt;div style=\"height:1px;overflow:hidden;background:red\"&gt;&lt;/div&gt; input [type=search] 搜索框右侧小图标如何美化？12345678input[type=\"search\"]::-webkit-search-cancel-button&#123; -webkit-appearance: none; height: 15px; width: 15px; border-radius: 8px; background:url(\"images/searchicon.png\") no-repeat 0 0; background-size: 15px 15px;&#125; 网站图片文件，如何点击下载？而非点击预览？12&lt;a href=&quot;logo.jpg&quot; download&gt;下载&lt;/a&gt;&lt;a href=&quot;logo.jpg&quot; download=&quot;网站LOGO&quot; &gt;下载&lt;/a&gt; iOS safari 如何阻止“橡皮筋效果”？1234567$(document).ready(function()&#123; var stopScrolling = function(event) &#123; event.preventDefault(); &#125; document.addEventListener('touchstart', stopScrolling, false); document.addEventListener('touchmove', stopScrolling, false);&#125;); 怎么让Chrome支持小于12px 的文字？12345.shrink&#123; -webkit-transform:scale(0.8); -o-transform:scale(1); display:inline-block;&#125; 用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观 使用12px及12px以上字体大小：为了兼容各大主流浏览器，建议设计美工图时候设置大于或等于12px的字体大小，如果是接单的这个时候就需要给客户讲解小于12px浏览器不兼容等事宜 继续使用小于12px字体大小样式设置：如果不考虑chrome可以不用考虑兼容，同时在设置小于12px对象设置-webkit-text-size-adjust:none，做到最大兼容考虑 让页面里的字体变清晰，变细用CSS怎么做？（IOS手机浏览器字体齿轮设置）1-webkit-font-smoothing: antialiased; 一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度12345678- 方案1： .sub &#123; height: calc(100%-100px); &#125;- 方案2： .container &#123; position:relative; &#125; .sub &#123; position: absolute; top: 100px; bottom: 0; &#125;- 方案3： .container &#123; display:flex; flex-direction:column; &#125; .sub &#123; flex:1; &#125;","categories":[{"name":"前端面试题","slug":"前端面试题","permalink":"https://qw8.github.io/categories/前端面试题/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://qw8.github.io/tags/CSS/"},{"name":"选择器","slug":"选择器","permalink":"https://qw8.github.io/tags/选择器/"},{"name":"代码题","slug":"代码题","permalink":"https://qw8.github.io/tags/代码题/"}]},{"title":"大厂高频题","slug":"interview/大厂高频题","date":"2021-06-24T08:42:29.000Z","updated":"2023-04-14T17:01:50.000Z","comments":true,"path":"/interview/da-han-gao-pin-ti.html","link":"","permalink":"https://qw8.github.io/interview/da-han-gao-pin-ti.html","excerpt":"","text":"转载自 Advanced-Frontend/Daily-Interview-Question 第 1 题：写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？答案：key 是给每一个 vnode（虚拟节点）的唯一 id,可以依靠 key,更准确, 更快的拿到 oldVnode 中对应的 vnode 节点。 更准确因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。 更快利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快。 公司：滴滴、饿了么 解析：第 1 题 第 2 题：[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt) what &amp; why ?答案：[1, NaN, NaN] parseInt(‘1’, 0) //radix 为 0 时，且 string 参数不以“0x”和“0”开头时，按照 10 为基数处理。这个时候返回 1 parseInt(‘2’, 1) //基数为 1（1 进制）表示的数中，最大值小于 2，所以无法解析，返回 NaN parseInt(‘3’, 2) //基数为 2（2 进制）表示的数中，最大值小于 3，所以无法解析，返回 NaN 解析：第 2 题 第 3 题：什么是防抖和节流？有什么区别？如何实现？1、防抖(debounce)：触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间 举例：就好像在百度搜索时，每次输入之后都有联想词弹出，这个控制联想词的方法就不可能是输入框内容一改变就触发的，他一定是当你结束输入一段时间之后才会触发。 节流(thorttle)：高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率 举例：预定一个函数只有在大于等于执行周期时才执行，周期内调用不执行。就好像你在淘宝抢购某一件限量热卖商品时，你不断点刷新点购买，可是总有一段时间你点上是没有效果，这里就用到了节流，就是怕点的太快导致系统出现bug。 2、区别：防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行。 公司：挖财 解析：第 3 题 第 4 题：介绍下 Set、Map、WeakSet 和 WeakMap 的区别？答案： 1、Set 成员唯一、无序且不重复； [value, value]，键值与键名是一致的（或者说只有键值，没有键名）； 可以遍历，方法有：add、delete、has、clear、entries、forEach、keys、values Set 也能用来保存 NaN 和 undefined， 如果有重复的 NaN， Set 会认为就一个 NaN(实际上 NaN!=NaN); 2、Map 本质上是键值对的集合，类似集合； 可以遍历，方法很多，可以跟各种数据格式转换。 3、WeakSet 成员都是对象； 成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 DOM 节点，不容易造成内存泄漏； 不能遍历，方法有 add、delete、has。 4、WeakMap 只接受对象作为键名（null 除外），不接受其他类型的值作为键名； 键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的； 不能遍历，方法有 get、set、has、delete。 解析：第 4 题 第 5 题：介绍下深度优先遍历和广度优先遍历，如何实现？解析：第 5 题 第 6 题：请分别用深度优先思想和广度优先思想实现一个拷贝函数？答案： 解析：第 6 题 第 7 题：ES5/ES6 的继承除了写法以外还有什么区别？答案： 解析：第 7 题 第 8 题：setTimeout、Promise、Async/Await 的区别答案： 解析：第 8 题 第 9 题：Async/Await 如何通过同步的方式实现异步答案： 公司：头条、微医 解析：第 9 题 第 10 题：异步笔试题答案： 请写出下面代码的运行结果 1234567891011121314151617181920async function async1() &#123; console.log(\"async1 start\"); await async2(); console.log(\"async1 end\");&#125;async function async2() &#123; console.log(\"async2\");&#125;console.log(\"script start\");setTimeout(function() &#123; console.log(\"setTimeout\");&#125;, 0);async1();new Promise(function(resolve) &#123; console.log(\"promise1\"); resolve();&#125;).then(function() &#123; console.log(\"promise2\");&#125;);console.log(\"script end\"); 公司：头条 答案： 123456789// script start// async1 start// async2// promise1// script end// async1 end// promise2// undefined// setTimeout 解析：第 10 题 第 11 题：算法手写题答案： 已知如下数组： var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]; 编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组 公司：携程 答案： 123Array.from(new Set(arr.flat(Infinity))).sort((a, b) =&gt; &#123; return a - b;&#125;); 拆解： 123456arr.flat(Infinity); // 1.所有元素放到同一数组// [1, 2, 2, 3, 4, 5, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10]Array.from(new Set(arr.flat(Infinity))).sort((a, b) =&gt; &#123; return a - b;&#125;); // 2.去重及排序// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14] 解析：第 11 题 第 12 题：JS 异步解决方案的发展历程以及优缺点。答案： 公司：滴滴、挖财、微医、海康 解析：第 12 题 第 13 题：Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？答案： 公司：微医 解析：第 13 题 第 14 题：情人节福利题，如何实现一个 new答案： 公司：兑吧 解析：第 14 题 第 15 题：简单讲解一下 http2 的多路复用答案： 公司：网易 解析：第 15 题 第 16 题：谈谈你对 TCP 三次握手和四次挥手的理解答案： 解析：第 16 题 第 17 题：A、B 机器正常连接后，B 机器突然重启，问 A 此时处于 TCP 什么状态答案： 如果 A 与 B 建立了正常连接后，从未相互发过数据，这个时候 B 突然机器重启，问 A 此时处于 TCP 什么状态？如何消除服务器程序中的这个状态？（超纲题，了解即可） 解析：第 17 题 第 18 题：React 中 setState 什么时候是同步的，什么时候是异步的？答案：公司：微医 解析：第 18 题 第 19 题：React setState 笔试题，下面的代码输出什么？答案： 12345678910111213141516171819202122232425262728class Example extends React.Component &#123; constructor() &#123; super(); this.state = &#123; val: 0 &#125;; &#125; componentDidMount() &#123; this.setState(&#123; val: this.state.val + 1 &#125;); console.log(this.state.val); // 第 1 次 log this.setState(&#123; val: this.state.val + 1 &#125;); console.log(this.state.val); // 第 2 次 log setTimeout(() =&gt; &#123; this.setState(&#123; val: this.state.val + 1 &#125;); console.log(this.state.val); // 第 3 次 log this.setState(&#123; val: this.state.val + 1 &#125;); console.log(this.state.val); // 第 4 次 log &#125;, 0); &#125; render() &#123; return null; &#125;&#125; 解析：第 19 题 第 20 题：介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？答案：解析：第 20 题 第 21 题：有以下 3 个判断数组的方法，请分别介绍它们之间的区别和优劣答案： Object.prototype.toString.call() 、 instanceof 以及 Array.isArray() 解析：第 21 题 第 22 题：介绍下重绘和回流（Repaint &amp; Reflow），以及如何进行优化解析：第 22 题 第 23 题：介绍下观察者模式和订阅-发布模式的区别，各自适用于什么场景答案：解析：第 23 题 第 24 题：聊聊 Redux 和 Vuex 的设计思想答案：解析：第 24 题 第 25 题：说说浏览器和 Node 事件循环的区别答案：解析：第 25 题 第 26 题：介绍模块化发展历程答案： 可从 IIFE、AMD、CMD、CommonJS、UMD、webpack(require.ensure)、ES Module、&lt;script type=&quot;module&quot;&gt; 这几个角度考虑。 解析：第 26 题 第 27 题：全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取？答案： 解析：第 27 题 第 28 题：cookie 和 token 都存放在 header 中，为什么不会劫持 token？答案：解析：第 28 题 第 29 题：聊聊 Vue 的双向数据绑定，Model 如何改变 View，View 又是如何改变 Model 的答案：解析：第 29 题 第 30 题：两个数组合并成一个数组答案：请把两个数组 [‘A1’, ‘A2’, ‘B1’, ‘B2’, ‘C1’, ‘C2’, ‘D1’, ‘D2’] 和 [‘A’, ‘B’, ‘C’, ‘D’]，合并为 [‘A1’, ‘A2’, ‘A’, ‘B1’, ‘B2’, ‘B’, ‘C1’, ‘C2’, ‘C’, ‘D1’, ‘D2’, ‘D’]。 解析： 第 30 题 第 31 题：改造下面的代码，使之输出 0 - 9，写出你能想到的所有解法。答案： 12345for (var i = 0; i &lt; 10; i++) &#123; setTimeout(() =&gt; &#123; console.log(i); &#125;, 1000);&#125; 解析：第 31 题 第 32 题：Virtual DOM 真的比操作原生 DOM 快吗？谈谈你的想法。答案：解析：第 32 题 第 33 题：下面的代码打印什么内容，为什么？答案： 12345var b = 10;(function b() &#123; b = 20; console.log(b);&#125;)(); 解析：第 33 题 第 34 题：简单改造下面的代码，使之分别打印 10 和 20。答案： 12345var b = 10;(function b() &#123; b = 20; console.log(b);&#125;)(); 解析：第 34 题 第 35 题：浏览器缓存读取规则答案： 可以分成 Service Worker、Memory Cache、Disk Cache 和 Push Cache，那请求的时候 from memory cache 和 from disk cache 的依据是什么，哪些数据什么时候存放在 Memory Cache 和 Disk Cache 中？ 解析：第 35 题 第 36 题：使用迭代的方式实现 flatten 函数。答案：解析：第 36 题 第 37 题：为什么 Vuex 的 mutation 和 Redux 的 reducer 中不能做异步操作？答案：解析：第 37 题 第 38 题：下面代码中 a 在什么情况下会打印 1？答案： 1234var a = ?;if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3)&#123; console.log(1);&#125; 解析：第 38 题 公司：京东 第 39 题：介绍下 BFC 及其应用答案：解析：第 39 题 第 40 题：在 Vue 中，子组件为何不可以修改父组件传递的 Prop答案：如果修改了，Vue 是如何监控到属性的修改并给出警告的。 解析：第 40 题 第 41 题：下面代码输出什么答案： 12345678var a = 10;(function() &#123; console.log(a); a = 5; console.log(window.a); var a = 20; console.log(a);&#125;)(); 解析：第 41 题 第 42 题：实现一个 sleep 函数答案：比如 sleep(1000) 意味着等待 1000 毫秒，可从 Promise、Generator、Async/Await 等角度实现 解析：第 42 题 第 43 题：使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果答案：解析：第 43 题 第 44 题：介绍 HTTPS 握手过程答案：解析：第 44 题 第 45 题：HTTPS 握手过程中，客户端如何验证证书的合法性答案：解析：第 45 题 第 46 题：输出以下代码执行的结果并解释为什么答案： 12345678910var obj = &#123; \"2\": 3, \"3\": 4, length: 2, splice: Array.prototype.splice, push: Array.prototype.push&#125;;obj.push(1);obj.push(2);console.log(obj); 解析：第 46 题 第 47 题：双向绑定和 vuex 是否冲突答案：解析：第 47 题 第 48 题：call 和 apply 的区别是什么，哪个性能更好一些答案：解析：第 48 题 第 49 题：为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？答案：解析：第 49 题 第 50 题：实现 (5).add(3).minus(2) 功能。 例： 5 + 3 - 2，结果为 6 解析：第 50 题 公司：百度 第 51 题：Vue 的响应式原理中 Object.defineProperty 有什么缺陷？答案：为什么在 Vue3.0 采用了 Proxy，抛弃了 Object.defineProperty？ 解析：第 51 题 第 52 题：怎么让一个 div 水平垂直居中答案：解析：第 52 题 第 53 题：输出以下代码的执行结果并解释为什么答案： 123456var a = &#123; n: 1 &#125;;var b = a;a.x = a = &#123; n: 2 &#125;;console.log(a.x);console.log(b.x); 解析：第 53 题 第 54 题：冒泡排序如何实现，时间复杂度是多少， 还可以如何改进？答案：解析：第 54 题 第 55 题：某公司 1 到 12 月份的销售额存在一个对象里面答案：如下：{1:222, 2:123, 5:888}，请把数据处理为如下结构：[222, 123, null, null, 888, null, null, null, null, null, null, null]。 解析：第 55 题 第 56 题：要求设计 LazyMan 类，实现以下功能。答案： 12345678910111213141516171819202122232425262728293031LazyMan(\"Tony\");// Hi I am TonyLazyMan(\"Tony\") .sleep(10) .eat(\"lunch\");// Hi I am Tony// 等待了10秒...// I am eating lunchLazyMan(\"Tony\") .eat(\"lunch\") .sleep(10) .eat(\"dinner\");// Hi I am Tony// I am eating lunch// 等待了10秒...// I am eating dinerLazyMan(\"Tony\") .eat(\"lunch\") .eat(\"dinner\") .sleepFirst(5) .sleep(10) .eat(\"junk food\");// Hi I am Tony// 等待了5秒...// I am eating lunch// I am eating dinner// 等待了10秒...// I am eating junk food 解析：第 56 题 第 57 题：分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景。答案：解析：第 57 题 第 58 题：箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么？答案：解析：第 58 题 第 59 题：给定两个数组，写一个方法来计算它们的交集。答案： 例如：给定 nums1 = [1, 2, 2, 1]，nums2 = [2, 2]，返回 [2, 2]。 解析：第 59 题 第 60 题：已知如下代码，如何修改才能让图片宽度为 300px ？注意下面代码不可修改。 &lt;img src=&quot;1.jpg&quot; style=&quot;width:480px!important;”&gt; 解析：第 60 题 第 61 题：介绍下如何实现 token 加密答案：解析：第 61 题 第 62 题：redux 为什么要把 reducer 设计成纯函数答案：解析：第 62 题 第 63 题：如何设计实现无缝轮播答案：解析：第 63 题 第 64 题：模拟实现一个 Promise.finally答案：解析：第 64 题 第 65 题： a.b.c.d 和 a[&#39;b&#39;][&#39;c&#39;][&#39;d&#39;]，哪个性能更高？答案：解析：第 65 题 第 66 题：ES6 代码转成 ES5 代码的实现思路是什么答案：解析：第 66 题 第 67 题：数组编程题答案：随机生成一个长度为 10 的整数类型的数组，例如 [2, 10, 3, 4, 5, 11, 10, 11, 20]，将其排列成一个新数组，要求新数组形式如下，例如 [[2, 3, 4, 5], [10, 11], [20]]。 解析：第 67 题 第 68 题： 如何解决移动端 Retina 屏 1px 像素问题解析：第 68 题 第 69 题： 如何把一个字符串的大小写取反（大写变小写小写变大写），例如 ’AbC’ 变成 ‘aBc’ 。答案：解析：第 69 题 第 70 题： 介绍下 webpack 热更新原理，是如何做到在不刷新浏览器的前提下更新页面的答案：解析：第 70 题 第 71 题： 实现一个字符串匹配算法，从长度为 n 的字符串 S 中，查找是否存在字符串 T，T 的长度是 m，若存在返回所在位置。答案：解析：第 71 题 第 72 题： 为什么普通 for 循环的性能远远高于 forEach 的性能，请解释其中的原因。答案： image-20190512225510941 解析：第 72 题 第 73 题： 介绍下 BFC、IFC、GFC 和 FFC答案：解析：第 73 题 第 74 题： 使用 JavaScript Proxy 实现简单的数据绑定答案：解析：第 74 题 第 75 题：数组里面有 10 万个数据，取第一个元素和第 10 万个元素的时间相差多少答案：解析：第 75 题 第 76 题：输出以下代码运行结果答案： 12345678910111213141516171819// example 1var a=&#123;&#125;, b='123', c=123;a[b]='b';a[c]='c';console.log(a[b]);---------------------// example 2var a=&#123;&#125;, b=Symbol('123'), c=Symbol('123');a[b]='b';a[c]='c';console.log(a[b]);---------------------// example 3var a=&#123;&#125;, b=&#123;key:'123'&#125;, c=&#123;key:'456'&#125;;a[b]='b';a[c]='c';console.log(a[b]); 解析：第 76 题 第 77 题：算法题「旋转数组」答案： 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例 1： 123456输入: [1, 2, 3, 4, 5, 6, 7] 和 k = 3输出: [5, 6, 7, 1, 2, 3, 4]解释:向右旋转 1 步: [7, 1, 2, 3, 4, 5, 6]向右旋转 2 步: [6, 7, 1, 2, 3, 4, 5]向右旋转 3 步: [5, 6, 7, 1, 2, 3, 4] 示例 2： 12345输入: [-1, -100, 3, 99] 和 k = 2输出: [3, 99, -1, -100]解释:向右旋转 1 步: [99, -1, -100, 3]向右旋转 2 步: [3, 99, -1, -100] 解析：第 77 题 第 78 题：Vue 的父组件和子组件生命周期钩子执行顺序是什么答案：解析：第 78 题 第 79 题：input 搜索如何防抖，如何处理中文输入答案：解析：第 79 题 第 80 题：介绍下 Promise.all 使用、原理实现及错误处理答案：解析：第 80 题 第 81 题：打印出 1 - 10000 之间的所有对称数答案： 例如：121、1331 等 解析：第 81 题 第 82 题：周一算法题之「移动零」答案： 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 123&gt; 输入: [0,1,0,3,12]&gt; 输出: [1,3,12,0,0]&gt; 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 解析：第 82 题 第 83 题：var、let 和 const 区别的实现原理是什么答案：解析：第 83 题 第 84 题：请实现一个 add 函数，满足以下功能。答案： 1234567&gt; add(1); // 1&gt; add(1)(2); // 3&gt; add(1)(2)(3)；// 6&gt; add(1)(2, 3); // 6&gt; add(1, 2)(3); // 6&gt; add(1, 2, 3); // 6&gt; 解析：第 84 题 第 85 题：react-router 里的 &lt;Link&gt; 标签和 &lt;a&gt; 标签有什么区别答案： 如何禁掉 &lt;a&gt; 标签默认事件，禁掉之后如何实现跳转。 解析：第 85 题 第 86 题：周一算法题之「两数之和」答案：给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 示例： 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解析：第 86 题 公司：京东、快手 第 87 题：在输入框中如何判断输入的是一个正确的网址。答案：解析：第 87 题 第 88 题：实现 convert 方法，把原始 list 转换成树形结构，要求尽可能降低时间复杂度答案：以下数据结构中，id 代表部门编号，name 是部门名称，parentId 是父部门编号，为 0 代表一级部门，现在要求实现一个 convert 方法，把原始 list 转换成树形结构，parentId 为多少就挂载在该 id 的属性 children 数组下，结构如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 原始 list 如下let list =[ &#123;id:1,name:'部门A',parentId:0&#125;, &#123;id:2,name:'部门B',parentId:0&#125;, &#123;id:3,name:'部门C',parentId:1&#125;, &#123;id:4,name:'部门D',parentId:1&#125;, &#123;id:5,name:'部门E',parentId:2&#125;, &#123;id:6,name:'部门F',parentId:3&#125;, &#123;id:7,name:'部门G',parentId:2&#125;, &#123;id:8,name:'部门H',parentId:4&#125;];const result = convert(list, ...);// 转换后的结果如下let result = [ &#123; id: 1, name: '部门A', parentId: 0, children: [ &#123; id: 3, name: '部门C', parentId: 1, children: [ &#123; id: 6, name: '部门F', parentId: 3 &#125;, &#123; id: 16, name: '部门L', parentId: 3 &#125; ] &#125;, &#123; id: 4, name: '部门D', parentId: 1, children: [ &#123; id: 8, name: '部门H', parentId: 4 &#125; ] &#125; ] &#125;, ···]; 解析：第 88 题 第 89 题：设计并实现 Promise.race()答案：解析：第 89 题 第 90 题：实现模糊搜索结果的关键词高亮显示答案： 解析：第 90 题 第 91 题：介绍下 HTTPS 中间人攻击答案：解析：第 91 题 第 92 题：已知数据格式，实现一个函数 fn 找出链条中所有的父级 id答案： 123456&gt; const value = '112'&gt; const fn = (value) =&gt; &#123;&gt; ...&gt; &#125;&gt; fn(value) // 输出 [1， 11， 112]&gt; 解析：第 92 题 第 93 题：给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log(m+n))。答案：示例 1： 12nums1 = [1, 3];nums2 = [2]; 中位数是 2.0 示例 2： 12nums1 = [1, 2];nums2 = [3, 4]; 中位数是(2 + 3) / 2 = 2.5 解析：第 93 题 第 94 题：vue 在 v-for 时给每项元素绑定事件需要用事件代理吗？为什么？答案：解析：第 94 题 第 95 题：模拟实现一个深拷贝，并考虑对象相互引用以及 Symbol 拷贝的情况答案：解析：第 95 题 第 96 题：介绍下前端加密的常见场景和方法答案：解析：第 96 题 第 97 题：React 和 Vue 的 diff 时间复杂度从 O(n^3) 优化到 O(n) ，那么 O(n^3) 和 O(n) 是如何计算出来的？答案：解析：第 97 题 第 98 题：写出如下代码的打印结果12345678function changeObjProperty(o) &#123; o.siteUrl = \"http://www.baidu.com\"; o = new Object(); o.siteUrl = \"http://www.google.com\";&#125;let webSite = new Object();changeObjProperty(webSite);console.log(webSite.siteUrl); 公司：京东 解析：第 98 题 第 99 题：编程算法题答案： 用 JavaScript 写一个函数，输入 int 型，返回整数逆序后的字符串。如：输入整型 1234，返回字符串“4321”。要求必须使用递归函数调用，不能用全局变量，输入函数必须只有一个参数传入，必须返回字符串。 公司：bilibili 解析：第 99 题","categories":[{"name":"前端面试题","slug":"前端面试题","permalink":"https://qw8.github.io/categories/前端面试题/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qw8.github.io/tags/JavaScript/"},{"name":"vue","slug":"vue","permalink":"https://qw8.github.io/tags/vue/"}]},{"title":"电脑使用技巧","slug":"other/电脑使用技巧","date":"2021-06-09T03:58:08.000Z","updated":"2024-05-10T01:33:44.205Z","comments":true,"path":"/other/dian-nao-shi-yong-ji-qiao.html","link":"","permalink":"https://qw8.github.io/other/dian-nao-shi-yong-ji-qiao.html","excerpt":"","text":"桌面没有此电脑怎么办？设置—个性化—主题—相关设置—桌面图标设置 勾选“计算机”，点击确定 win11去掉搜索栏要删除Win11系统中的搜索栏，您可以按照以下步骤操作： 在桌面任务栏空白处右键点击，选择“任务栏设置”。 在设置窗口中，选择左侧的“个性化”选项。 在个性化设置的右侧，找到“任务栏”选项并点击进入。 在任务栏设置中，找到“搜索”选项，选择关闭，这样搜索框就不会在任务栏上显示了。 解决扩展屏幕上搜狗输入法光标不跟随问题的方法Ctrl+Shift切换输入法再切换回去即可解决 如何启用或禁用“Fn”键与“F1——F12”键的联用？一般情况下不用下载什么“BIOS”或“Lenovo Vatage”等驱动程序。 设置方法如下： 1、禁用“Fn”键与“F1——F12”键联用 先按住“Fn”键，再按住键盘区左上角的“Esc”键，待“Esc”键指示灯亮起，则设置成功，此时直接按“F1——F12”键即可实现相应功能。 2、启用“Fn”键与“F1——F12”键联用 先按住“Fn”键，再按住键盘区左上角的“Esc”键，待“Esc”键指示灯熄灭，则设置成功，此时想实现“F1——F12”键相应功能，需同时按“Fn”键与任意“F1——F12”键实现。 Hbuilder命令行清屏输入：CLS即CLear Screen（小写也可以）功能：清除屏幕上的所有显示，光标置于屏幕左上角 命令行切换到D盘某个文件夹1.打开cmd命令行窗口。 2.输入命令:D:,按下回车键。 3.切换成功后,我们可以在cmd窗口中看到当前所在磁盘已变为D盘。 12D:cd D:\\软件\\HBuilderX.3.6.18\\plugins\\launcher-tools\\tools\\adbs 命令行打开txt 使用cat命令查看txt文件内容。输入cat filename.txt即可将文件内容直接输出到终端窗口。 使用less命令分页查看txt文件内容。对于长文件，输入less filename.txt可以一页一页查看文件内容，便于浏览。 使用echo命令行输出txt文件内容。输入echo filename.txt可以将文件内容输出到终端。 执行txt文件中的命令。如果txt文件中包含可执行的命令，可以使用source或bash命令来执行这些命令。例如，输入source commands.txt或bash commands.txt来执行名为commands.txt的文件中的命令。 hosts文件位置1C:\\Windows\\System32\\drivers\\etc mac地址怎么查要查找MAC地址，可以根据不同的操作系统或设备采用不同的方法。以下是几种常见的方法： 使用命令提示符（Windows系统）。按下“Win+R”键，输入“cmd”打开命令提示符；输入命令“ipconfig/all”并按回车，在命令行输出的末尾找到“物理地址”或“Physical Address”，后面的十六进制数字就是MAC地址。 通过网络和共享中心（Windows系统）。右键点击任务栏的网络图标，选择“打开网络和Internet设置”；选择“网络和共享中心”，然后点击连接的网络的“详细信息”选项，在详细信息中可以找到MAC地址。 设置（iOS设备）。打开“设置”，选择“通用”，然后点击“关于本机”；滑动到“无线局域网地址”或“Wi-Fi地址”，这就是MAC地址。 设置（Android设备）。打开“设置”，连接到Wi-Fi网络；点击已连接的Wi-Fi网络旁边的三个点(…)，选择“查看网络详细信息”；在详细信息中找到“硬件地址”或“MAC地址”。 请根据使用的系统和设备选择合适的方法进行操作。 C盘文件夹“Program Files”和“Program Files (x86)”的区别主要区别在于它们的用途和软件兼容性。以下是相关介绍： Program Files目录。主要用于存放64位操作系统的64位应用程序和64位操作系统的32位应用程序的兼容层（如Windows on Windows 64，简称WoW64）。在64位Windows系统中，这个目录通常用于存放64位软件的安装目录。 Program Files (x86)目录。在64位Windows系统中，这个目录主要用于存放32位软件的安装目录。因为它允许64位系统运行32位应用程序，所以这个目录在安装有64位操作系统的电脑上很常见。 简单来说，这两个文件夹分别用于存放32位和64位软件的安装目录，这是为了兼容不同位数的软件。 电脑必须重启才能连接蓝牙，如何解决拔掉电脑所有外接电源就行，比如U盘、电源、外接屏等，就可以连上了 拔了电源马上就连上了，困扰了好久的问题，感谢知乎 https://www.zhihu.com/question/466784211","categories":[{"name":"其他","slug":"其他","permalink":"https://qw8.github.io/categories/其他/"}],"tags":[{"name":"电脑","slug":"电脑","permalink":"https://qw8.github.io/tags/电脑/"}]},{"title":"电脑常用快捷键","slug":"other/电脑常用快捷键","date":"2021-06-08T03:58:08.000Z","updated":"2023-04-14T17:01:50.000Z","comments":true,"path":"/other/dian-nao-chang-yong-kuai-jie-jian.html","link":"","permalink":"https://qw8.github.io/other/dian-nao-chang-yong-kuai-jie-jian.html","excerpt":"","text":"文件操作快捷键：Ctrl+C 复制 Ctrl+V 粘贴 Ctrl+X 剪切 Ctrl+A 全选 Ctrl 多选：按住Ctrl，再用鼠标单击即可选中文件，可以反选； Shift 多选：先选中一个文件a，按住Shift键，再用鼠标单击文件h，即可把从a到h选中； Ctrl+Shift+N 新建文件夹。注意：XP系统不行； Shift+Delete 彻底删除文件。选中文件后，先按住Shift键不放手，再按Delete键，彻底删除的文件不在回收站里； 文字输入快捷键：Tab与Shift+Tab：1、在输入账号之后按Tab键，会自动跳到输入密码框进行输入； 2、有些地方相当于输入两个汉字那么长的空格（如代码编写的缩进等）； 3、Shift+Tab为Tab的反操作； Delete 反向删除文字。比如”AB”字符，当光标在A与B之间时，按”Back”退格键时删除”A”，当按”Delete”键时则删除B； Home与End 当输入一行文字时发现有错误，可以按Home回到第一个字，按End时回到最后一个字。此时可以免去动鼠标或者按”←”或”→”方向键的麻烦； 窗口（Win）键【窗口】显示或隐藏“开始”菜单 【窗口】+F1帮助 【窗口】+D显示桌面，一个一个地关闭窗口或最小化窗口会很麻烦，这个快捷键很方便； 【窗口】+R打开“运行”窗口，可以输入”cmd”进入命令行黑窗口，还可以输入”msconfig”等命令； 【窗口】+E打开“我的电脑”，即使桌面上没有“我的电脑”图标也可以进入文件管理； 【窗口】+F搜索文件或文件夹 【窗口】+U打开“工具管理器” 【窗口】+BREAK显示“系统属性” 【窗口】+TAB在打开的项目之间切换 【窗口】+Pause 打开系统相关信息。可以快速查看别人电脑配置，相当于“控制面板\\系统和安全\\系统”。 【窗口】+U+U/R XP系统关机/重启（Win8不行）。注意：每按一个键都要松手，不是连按的； Ctrl键Ctrl+1,2,3… 功能：切换到从左边数起第1,2,3…个标签 Ctrl+A 功能：全部选中当前页面内容 Ctrl+C 功能：复制当前选中内容 Ctrl+D 功能：打开“添加收藏”面版(把当前页面添加到收藏夹中) Ctrl+E 功能：打开或关闭“搜索”侧边栏(各种搜索引擎可选) Ctrl+F 功能：打开“查找”面版 Ctrl+G 功能：打开或关闭“简易收集”面板 Ctrl+H 功能：打开“历史”侧边栏 Ctrl+I 功能：打开“收藏夹”侧边栏/另:将所有垂直平铺或水平平铺或层叠的窗口恢复 Ctrl+K 功能：关闭除当前和锁定标签外的所有标签 Ctrl+L 功能：打开“打开”面版(可以在当前页面打开Iternet地址或其他文件…) Ctrl+N 功能：新建一个空白窗口(可更改,Maxthon选项→标签→新建) Ctrl+O 功能：打开“打开”面版(可以在当前页面打开Iternet地址或其他文件…) Ctrl+P 功能：打开“打印”面板(可以打印网页,图片什么的…) Ctrl+Q 功能：打开“添加到过滤列表”面板(将当前页面地址发送到过滤列表) Ctrl+R 功能：刷新当前页面 Ctrl+S 功能：打开“保存网页”面板(可以将当前页面所有内容保存下来) Ctrl+T 功能：垂直平铺所有窗口 Ctrl+V 功能：粘贴当前剪贴板内的内容 Ctrl+W 功能：关闭当前标签(窗口) Ctrl+X 功能：剪切当前选中内容(一般只用于文本操作) Ctrl+Y 功能：重做刚才动作(一般只用于文本操作) Ctrl+Z 功能：撤消刚才动作(一般只用于文本操作) Ctrl+F4 功能：关闭当前标签(窗口) Ctrl+F5 功能：刷新当前页面 Ctrl+F6 功能：按页面打开的先后时间顺序向前切换标签(窗口) Ctrl+F11 功能：隐藏或显示菜单栏 Ctrl+Tab 功能：以小菜单方式向下切换标签(窗口) Ctrl+拖曳 功能：保存该链接的地址或已选中的文本或指定的图片到一个文件夹中(保存目录可更改,Maxthon选项→保存) Ctrl+小键盘’+’ 功能：当前页面放大20% Ctrl+小键盘’-‘ 功能：当前页面缩小20% Ctrl+小键盘’*’ 功能：恢复当前页面的缩放为原始大小 Ctrl+Alt+S 功能：自动保存当前页面所有内容到指定文件夹(保存路径可更改,Maxthon选项→保存) Ctrl+Shift+小键盘’+’ 功能：所有页面放大20% Ctrl+Shift+小键盘’-‘ 功能：所有页面缩小20% Ctrl+Shift+F 功能：输入焦点移到搜索栏 Ctrl+Shift+G 功能：关闭“简易收集”面板 Ctrl+Shift+H 功能：打开并激活到你设置的主页 Ctrl+Shift+N 功能：在新窗口中打开剪贴板中的地址,如果剪贴板中为文字,则调用搜索引擎搜索该文字(搜索引擎可选择,Maxthon选项→搜索) Ctrl+Shift+S 功能：打开“保存网页”面板(可以将当前页面所有内容保存下来,等同于Ctrl+S) Ctrl+Shift+W 功能：关闭除锁定标签外的全部标签(窗口) Ctrl+Shift+F6 功能：按页面打开的先后时间顺序向后切换标签(窗口) Ctrl+Shift+Tab 功能：以小菜单方式向上切换标签(窗口) 其他常用快捷键：END 显示当前窗口的底端 HOME 显示当前窗口的顶端 Ctrl+Alt+Delete 打开任务管理器（结束一些常规方法关闭不了的程序）。 Print 电脑屏幕截屏。（然后在画图或Word中粘贴保存）； Ctrl+Alt+Print 对当前窗口截屏。（然后在画图或Word中粘贴保存）； Alt+Tab 切换已打开的程序窗口。先用一个手指按住Alt键，再用另外一个手指陆续按Tab键切换不同窗口； Alt+F4 关闭当前窗口。如果没有窗口时则提示关机； F5 刷新当前窗口。包括系统和网页。 Alt+1 功能：保存当前表单 Alt+2 功能：保存为通用表单 Alt+A 功能：展开收藏夹列表 辅助功能按右边的SHIFT键八秒钟切换筛选键的开和关 按SHIFT五次切换粘滞键的开和关 按NUMLOCK五秒钟切换切换键的开和关 左边的ALT+左边的SHIFT+NUMLOCK切换鼠标键的开和关 左边的ALT+左边的SHIFT+PRINTSCREEN切换高对比度的开和关 QQ快捷键Alt+S 快速回复 Alt+C 关闭当前窗口 Alt+H 打开聊天记录 Alt+T 更改消息模式 Ait+J 打开聊天纪录 Ctrl+A 全选当前对话框里的内容 Ctrl+F QQ里直接显示字体设置工具条 Ctrl+J 输入框里回车(跟回车一个效果) Ctrl+M 输入框里回车(跟回车一个效果) Ctrl+L 对输入框里当前行的文字左对齐 Ctrl+R 对输入框里当前行的文字右对齐 Ctrl+E 对输入框里当前行的文字居中 Ctrl+V 在qq对话框里实行粘贴 Ctrl+Z 清空/恢复输入框里的文字 Ctrl+回车 快速回复 这个可能是聊QQ时最常用到的了 Ctrl+Alt+Z 快速提取消息 Ctrl+Alt+A 捕捉屏幕","categories":[{"name":"其他","slug":"其他","permalink":"https://qw8.github.io/categories/其他/"}],"tags":[{"name":"电脑","slug":"电脑","permalink":"https://qw8.github.io/tags/电脑/"},{"name":"快捷键","slug":"快捷键","permalink":"https://qw8.github.io/tags/快捷键/"}]},{"title":"光阴","slug":"other/光阴","date":"2021-04-30T02:18:08.000Z","updated":"2023-04-14T17:01:50.000Z","comments":true,"path":"/other/guang-yin.html","link":"","permalink":"https://qw8.github.io/other/guang-yin.html","excerpt":"","text":"作者：赵丽宏 谁也无法描绘出他的面目。但世界上处处能听到他的脚步。 当旭日驱散夜的残幕时,当夕阳被朦胧的地平线吞噬时,他不慌不忙地走着,光明和黑暗都无法改变他进行的节奏。 当蓓蕾在春风中灿然绽开湿润的花瓣时,当婴儿在产房里以响亮的哭声向人世报到时,他悄无声息地走着,欢笑不能挽留他的脚步。 当枯黄的树叶在寒风中飘飘坠落时,当垂危的老人以留恋的目光扫视周围的天地时,他还是沉着而又默然地走,叹息也不能使他停步。 他从你的手指缝里流过去。 从你的脚底下滑过去。 从你的视野和你的思想里飞过去….. 他是一把神奇而又无情的雕刻刀,在天地之间创造着种种奇迹,他能把巨石分裂成尘土,把幼苗雕成大树,把荒漠变成城市和园林,当然,他也能使繁华之都衰败成荒凉的废墟,使锃亮的金属爬满绿锈、失去光泽。老人额头的皱纹是他刻出来的,少女脸上的红晕也是他描绘出来的。生命的繁衍和世界的运动正是由他精心指挥着。 他按时撕下一张又一张日历,把将来变成现在,把现在变成过去,把过去变成越来越遥远的[历史])。 他慷慨。你不必乞求,属于你的,他总是如数奉献。 他公正。不管你权重如山、腰缠万贯,还是一个布衣、两袖清风,他都一视同仁。没有人能将他占为己有,哪怕你一掷千金,他也决不会因此而施舍一分一秒。 你珍重他，他便在你的身后长出绿阴，结出沉甸甸的果实。 你漠视他,他就化成轻烟,消散得无影无踪。 有时,短暂的一瞬会成为永恒,这是因为他把脚印深深地留在了人们心里。 有时,漫长的岁月会成为一瞬,这是因为浓雾和风沙湮没了他的脚印。","categories":[{"name":"其他","slug":"其他","permalink":"https://qw8.github.io/categories/其他/"}],"tags":[{"name":"散文","slug":"散文","permalink":"https://qw8.github.io/tags/散文/"}]},{"title":"计算机通识","slug":"interview/计算机通识","date":"2021-04-08T10:28:58.000Z","updated":"2023-04-14T17:01:50.000Z","comments":true,"path":"/interview/ji-suan-ji-tong-shi.html","link":"","permalink":"https://qw8.github.io/interview/ji-suan-ji-tong-shi.html","excerpt":"","text":"数据结构栈和队列的区别? 栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。 队列先进先出，栈先进后出。 栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除 栈和堆的区别？ 栈区（stack）— 由编译器自动分配释放，存放函数的参数值，局部变量的值等。 堆区（heap） — 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。 堆（数据结构）：堆可以被看成是一棵树，如：堆排序； 栈（数据结构）：一种先进后出的数据结构 拓展： 栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。 队列先进先出，栈先进后出。 栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除 快速排序的思想并实现一个快排？“快速排序”的思想很简单，整个排序过程只需要三步： （1）在数据集之中，找一个基准点 （2）建立两个数组，分别存储左边和右边的数组 （3）利用递归进行下次比较 123456789101112131415161718192021222324function quickSort(arr)&#123; if(arr.length&lt;=1)&#123; return arr;//如果数组只有一个数，就直接返回； &#125; var num = Math.floor(arr.length/2);//找到中间数的索引值，如果是浮点数，则向下取整 var numValue = arr.splice(num,1);//找到中间数的值 var left = []; var right = []; for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i]&lt;numValue)&#123; left.push(arr[i]);//基准点的左边的数传到左边数组 &#125; else&#123; right.push(arr[i]);//基准点的右边的数传到右边数组 &#125; &#125; return quickSort(left).concat([numValue],quickSort(right));//递归不断重复比较&#125;alert(quickSort([32,45,37,16,2,87]));//弹出“2,16,32,37,45,87” 计算机原理线程与进程的区别 一个程序至少有一个进程，一个进程至少有一个线程 线程的划分尺度小于进程，使得多线程程序的并发性高 进程在执行过程中拥有独立的内存单元，而多个线程共享内存 线程不能够独立执行，必须应用程序提供多个线程执行控制 数据库说说mongoDB和MySQL的区别 MySQL是传统的关系型数据库，MongoDB则是非关系型数据库 mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。 对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，MongoDB的优点有： ①弱一致性（最终一致），更能保证用户的访问速度： ②文档结构的存储方式，能够更便捷的获取数据","categories":[{"name":"前端面试题","slug":"前端面试题","permalink":"https://qw8.github.io/categories/前端面试题/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://qw8.github.io/tags/数据结构/"},{"name":"计算机原理","slug":"计算机原理","permalink":"https://qw8.github.io/tags/计算机原理/"},{"name":"数据库","slug":"数据库","permalink":"https://qw8.github.io/tags/数据库/"}]},{"title":"兼容性问题","slug":"knowledges/兼容性问题","date":"2021-03-21T07:11:22.000Z","updated":"2024-04-26T09:39:35.619Z","comments":true,"path":"/knowledges/jian-rong-xing-wen-ti.html","link":"","permalink":"https://qw8.github.io/knowledges/jian-rong-xing-wen-ti.html","excerpt":"","text":"浏览器内核市场上浏览器种类很多，不同浏览器的内核也不尽相同，所以各个浏览器对网页的解析存在一定的差异。 主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎，最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核 JS引擎则：解析和执行javascript来实现网页的动态效果 常见的浏览器内核有哪些？ Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等国产浏览器。[又称MSHTML] Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等 Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;] Webkit内核：Safari,Chrome等。 [ Chrome的Blink（WebKit的分支）] Blink内核：新版 Chrome、新版 Opera 常见的浏览器内核可以分四种：Trident、Gecko、Blink、WebkitIE浏览器 Trident内核，也称为IE内核Chrome浏览器 Webkit内核，现在是Blink内核Firefox浏览器 Gecko内核，俗称Firefox内核Safari浏览器 Webkit内核Opera浏览器 最初是自己的Presto内核，后来加入谷歌大军，从Webkit又到了Blink内核；360浏览器 IE+Chrome双内核猎豹浏览器 IE+Chrome双内核百度浏览器 IE内核QQ浏览器 Trident（兼容模式）+Webkit（高速模式） 为何会出现浏览器兼容问题 同一产品，版本越老 bug 越多 同一产品，版本越新，功能越多 不同产品，不同标准，不同实现方式 处理兼容问题的思路1.要不要做 产品的角度（产品的受众、受众的浏览器比例、效果优先还是基本功能优先） 成本的角度 (有无必要做某件事) 不同浏览器的解析器实现不同 2.做到什么程度 ​ 让哪些浏览器支持哪些效果 3.如何做 根据兼容需求选择技术框架/库(jquery) 根据兼容需求选择兼容工具(html5shiv.js、respond.js、css reset、normalize.css、Modernizr) 条件注释、CSS Hack、js 能力检测做一些修补 渐进增强(progressive enhancement): 针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验 优雅降级 (graceful degradation): 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 IE兼容性问题如何不让ie跳转到edge设置ie浏览器不跳转到edge浏览器需要进入IE浏览器的Internet选项，关闭启用第三方浏览器扩展即可。 1.点击设置符号 打开IE浏览器，点击右上角的菜单中的设置符号。 如何不让ie跳转到edge 2.点击高级 在弹出菜单中点击Internet选项，在弹出的Internet 选项窗口中点击高级。 如何不让ie跳转到edge 3.关闭启用第三方浏览器 在高级项下的设置里面滚动滑动，找到浏览，把勾选的启动第三方浏览器取消勾选即可。 如何不让ie跳转到edge 4.重启电脑才生效 IE设置background: rgb(0, 21, 51, .7);无效分开写就可以了 12background: #001533;opacity: .7; IE不支持ES6语法，如模板字符串``、箭头函数 将模板字符串改为字符串拼接 使用转换工具babel 12345&lt;script src=&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/babel&quot;&gt;const getMessage = () =&gt; `Hello World`;document.getElementById(&apos;output&apos;).innerHTML = getMessage();&lt;/script&gt; 子元素超出父元素宽度需单独设置子元素宽度，或者设置为100% Jquery + CSS 简易解决文字溢出省略问题（兼容IE）原理很简单，就是计算行高，然后与当前的元素判断，大于的话就截取，后面替换再拼接 ···，因为此处计算的是行高，需要有一个固定的行高。 123456789101112131415/* * 兼容IE省略多行 * @param &#123;number&#125; lines-行数 * @param &#123;string&#125; jDom-选择器 */ function ellipsis(lines, jDom) &#123; jDom.each(function () &#123; var lineHeight = Math.ceil($(this).css(&quot;lineHeight&quot;).slice(0, -2)); var maxHeight = lineHeight * lines; while ($(this).height() &gt; maxHeight) &#123; $(this).text($(this).text().slice(0, -4) + &quot;...&quot;); &#125; &#125;); &#125; ellipsis(2, $(&apos;.list .desc&apos;)) CSS-hover替换图片原来这种写法在ie没有hover效果，其他浏览器正常 12345678.arrow &#123; width: 22px; height: 22px; &#125; // 左箭头.arrow:first-of-type:hover &#123; content: url(&quot;http://xxxxx&quot;) &#125; 12345.txlhover:hover &#123; .imgText img &#123; content: url(/static/img/txl.png); &#125; &#125; 兼容ie 123456789101112.news .btn &#123; width: 58px; height: 58px;&#125;.news .left&#123; background: url(&apos;../../images/left1@2x.png&apos;) no-repeat; background-size: cover;&#125;.left:hover &#123; background: url(&apos;../../images/left1-hover@2x.png&apos;) no-repeat; background-size: cover;&#125; placeholder样式兼容各浏览器写法：input::placeholder{你想要修改的样式} 因为placeholder是 HTML5 中新增加的属性，需要注意浏览器的兼容性。 12345678910&lt;input type=&quot;text&quot; id=&quot;input&quot; placeholder=&quot;请输入用户名&quot; /&gt;/* 使用webkit内核的浏览器 */input::-webkit-input-placeholder&#123;&#125;/* Firefox版本4-18 */input:-moz-placeholder&#123;&#125;/* Firefox版本19+ */input::-moz-placeholder&#123;&#125;/* IE浏览器 */input:-ms-input-placeholder&#123;&#125; 其他兼容性问题flex布局兼容性写法1.容器写法123456display: -webkit-box; /* Chrome 4+, Safari 3.1, iOS Safari 3.2+ */ display: -moz-box; /* Firefox 17- */ display: -webkit-flex; /* Chrome 21+, Safari 6.1+, iOS Safari 7+, Opera 15/16 */ display: -moz-flex; /* Firefox 18+ */ display: -ms-flexbox; /* IE 10 */ display: flex; /* Chrome 29+, Firefox 22+, IE 11+, Opera 12.1/17/18, Android 4.4+ */ 2.其他12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/*display*/.display_flex&#123; display: -webkit-box; display: -ms-flexbox; display: -webkit-flex; display: flex;&#125;.display_flex &gt; *&#123; display: block;&#125;.display_inline-flex&#123; display: -webkit-inline-box; display: -ms-inline-flexbox; display: -webkit-inline-flex; display: inline-flex; &#125;.display_inline-flex &gt; *&#123; display: block;&#125;/*伸缩流方向*/.flex-direction_column&#123; -webkit-box-orient: vertical; -ms-flex-direction: column; -webkit-flex-direction: column; flex-direction: column;&#125;/*主轴对齐*/.justify-content_flex-center&#123; -webkit-box-pack: center; -ms-flex-pack: center; -webkit-justify-content: center; justify-content: center;&#125;.justify-content_flex-end&#123; -webkit-box-pack: end; -ms-flex-pack: end; -webkit-justify-content: flex-end; justify-content: flex-end;&#125;.justify-content_flex-justify&#123; -webkit-box-pack: justify; -ms-flex-pack: justify; -webkit-justify-content: space-between; justify-content: space-between;&#125;/*侧轴对齐*/.align-items_flex-start&#123; -webkit-box-align: start; -ms-flex-align: start; -webkit-align-items: flex-start; align-items: flex-start;&#125;.align-items_flex-end&#123; -webkit-box-align: end; -ms-flex-align: end; -webkit-align-items: flex-end; align-items: flex-end;&#125;.align-items_center&#123; -webkit-box-align: center; -ms-flex-align: center; -webkit-align-items: center; align-items: center;&#125;.align-items_baseline&#123; -webkit-box-align: baseline; -ms-flex-align: baseline; -webkit-align-items: baseline; align-items: baseline;&#125;/*伸缩性*/.flex_auto&#123; -webkit-box-flex: 1; -ms-flex: auto; -webkit-flex: auto; flex: auto;&#125;.flex_1&#123; width: 0; -webkit-box-flex: 1; -ms-flex: 1; -webkit-flex: 1; flex: 1; &#125;/*显示顺序*/.order_2&#123; -webkit-box-ordinal-group: 2; -ms-flex-order: 2; -webkit-order: 2; order: 2;&#125;.order_3&#123; -webkit-box-ordinal-group: 3; -ms-flex-order: 3; -webkit-order: 3; order: 3;&#125; 总结日期：2019.11.27 Vue.js浏览器兼容性问题IE兼容性问题 IE11不识别 data(){}定义的方法 123data()&#123; return &#123;&#125;&#125; 仅识别如下形式: 123data: function () &#123; return &#123;&#125;&#125; IE10不识别let标识符 Vue不支持IE8, 因为Vue使用了IE8无法模拟的ECMAScript 5 特性, 但它支持所有兼容ECMAScript 5 的浏览器 IE8不识别 vue.js 中的: var extendsFrom = child.extends; // 报错缺少标识符 腾讯、淘宝已经不支持IE8 xp系统最高只支持IE8 Microsoft Edge 均支持 let和data(){}定义的方法 360 均支持 let和data(){}定义的方法 vue-cli2：兼容ie9及其以上；flex：兼容ie10及其以上；vue-cli3：兼容ie11及其以上 1、首先，安装babel-polyfill，在main.js文件的开头引入。2、再次，使用IE11打开页面，看控制台的报错，然后都解决了。3、这时候，你的应用基本上就可以用手机打开了，就正常了。 以上思路是通过解决IE的兼容性，顺便就兼容了手机端。是不是很厉害啊？ 总结日期：2019.11.27 定义：浏览器兼容性又叫网页或者网站的兼容性问题，是指不同的浏览器（内核）对同一段代码有不同的解析，造成页面显示不一样的情况 所以需要考虑到：内核，客户端屏幕尺寸&amp;分辨率，操作系统，不同终端 什么时候需要做浏览器兼容性测试？大型的，用户群体多的网站都需要做浏览器兼容性测试，需要测试主流的浏览器（除特定要求的浏览器以外） 测试的内容： 一般是页面的排版，页面格式，字体，颜色，下拉菜单，复选框等测试（UI：CSS，HML，Js在不同浏览器下的表现） 再就是对功能进行检查 四个主流浏览器 IE8以上，360极速/ 安全浏览器、搜狗（Trident内核） 火狐（Gecko内核） google（Blink内核） 苹果、遨游浏览器（Gecko内核） 谷歌Chrome Blink，Webkit 体积小浏览速度快，本身安全性较高 火狐Firefox Gecko 跨多个平台，最大的特色就是兼容，速度比较快 ie Trident 使用用户越来越少，逐渐被其他浏览器取代 360 Blink（Webkit）-极速，Trident-兼容 现在主流浏览器，会将不能识别的软件作为病毒处理掉，会将它认为不安全的浏览器重新命名等 搜狗/QQ Webkit-极速，Trident-兼容 safari Webkit 是苹果计算机的操作系统Mac OS中的浏览器 Opera Blink 跨多个平台，快速、小巧和比其他浏览器更佳的标准兼容性 会对不同版本的浏览器进行测试吗？例如：兼容IE8~IE11 按照需求，做到一定程度上的向下兼容 用户手册、用户引导中，写推荐使用的浏览器（版本和内核） 小众浏览器需不需要做兼容性测试？用户反馈再小众浏览器上有问题？怎么处理？ 一般来说都需要做兼容性测试，保证我们在小众浏览器上也不会出现错位问题 ，但是具体怎么做要看用户的要求（eg：用户说是需要在谷歌浏览器上加宣传彩页，视觉效果最好，我们就得调查分析 市面上大多数用户使用的分辨率及谷歌浏览器多少分辨率视觉效果才是最好的）。 可以与用户沟通，看这个小众浏览器上的客户群体占比例情况能不能放弃，主推大众浏览器，如果不行，可以联系开发修改代码保证小众浏览器的兼容性 如果一个网站分为前台、后台是否都需要做浏览器兼容性测试？前台测试一般都会做兼容性测试，但是如果我的网站后台只有自己进行管理，一般不需要做兼容性测试，如果我们后台会分一部分权限对外，就得需要做兼容性测试，还是得根据用户的需求来定。 面试：你们做的项目是什么架构？BS： Browser/server 浏览器的兼容：IE，Firefox…..一般就是最新版本/稳定版本就可以了。是不是可以使用，展示是不是OK CS： Client/server CS客户端的兼容：在不同系统是不是兼容。可以安装就好 测试手段 手工测试：安装不同的浏览器，逐一进行测试（可能考虑高低版本，eg：IE工具ietester [ie8-ie11]）； 目标浏览器（高低版本）：1.需要和产品沟通好，以需求为准；2.或者参考行业领头的标准 主要环境已经明确，用例要进行全覆盖。侧重：主业务流程 云测试：wetest，Testin，人手不足的付费测试 测试环境需求：设备，正常网络，弱网，断网 总结日期：2019.12.2 常见的浏览器兼容性问题1、不同浏览器的标签默认的margin和padding不同解决方案：全局的 css文件 里增加通配符 * { margin: 0; padding: 0; } 2、IE6双边距问题在 IE6中设置了float , 同时又设置margin就会出现边距问题（如：元素向左浮动并且设置了左侧的外边距、元素向右浮动并且设置右边距；同一行如果有多个浮动元素，第一个浮动元素会出现这个双边距bug，其它的浮动元素则不会）。解决方案：给浮动元素加上display:inline; 3.margin-top，margin-bottom的bug父元素的第一个子元素设置了margin-top,会作用于父元素（值为父元素的margin-top与该margin-top两者中的最大值)，而子元素和父元素的边距则没有发生变化。 4、图片默认有间距解决方案：使用float为img 布局 5、IE9以下浏览器不能使用opacity解决方案： 123opacity: 0.5;filter: alpha(opacity = 50);filter: progid:DXImageTransform.Microsoft.Alpha(style = 0, opacity = 50); 6、cursorhand 显示手型在safari 上不支持解决方案：统一使用 cursor:pointer 7、两个块级元素，父元素设置了overflow:auto；子元素设置了position:relative ;且高度大于父元素，在IE6、IE7会被隐藏而不是溢出；解决方案：父级元素设置position:relative 8、不同浏览器都会带有自己的浏览器默认样式，一般我们需要把这些浏览器默认自带的样式给清除，一般我们借助reset.css来清楚浏览器默认样式。简单 12345678910111213141516* &#123; margin: 0; padding: 0; list-style: none; outline: none; font-weight: normal; box-sizing: border-box; font-family: PingFang, Microsoft Yahei, sans-serif;&#125;html,body &#123; text-rendering: optimizeLegibility; text-size-adjust: 100%; -webkit-font-smoothing: antialiased;&#125; 1234567891011121314151617181920212223242526//解决不同浏览器页面样视不统一问题@charset &quot;utf-8&quot;;html&#123;background-color:#fff;color:#000;font-size:12px&#125;body,ul,ol,dl,dd,h1,h2,h3,h4,h5,h6,figure,form,fieldset,legend,input,textarea,button,p,blockquote,th,td,pre,xmp&#123;margin:0;padding:0&#125;body,input,textarea,button,select,pre,xmp,tt,code,kbd,samp&#123;line-height:1.5;font-family:tahoma,arial,&quot;Hiragino Sans GB&quot;,simsun,sans-serif&#125;h1,h2,h3,h4,h5,h6,small,big,input,textarea,button,select&#123;font-size:100%&#125;h1,h2,h3,h4,h5,h6&#123;font-family:tahoma,arial,&quot;Hiragino Sans GB&quot;,&quot;微软雅黑&quot;,simsun,sans-serif&#125;h1,h2,h3,h4,h5,h6,b,strong&#123;font-weight:normal&#125;address,cite,dfn,em,i,optgroup,var&#123;font-style:normal&#125;table&#123;border-collapse:collapse;border-spacing:0;text-align:left&#125;caption,th&#123;text-align:inherit&#125;ul,ol,menu&#123;list-style:none&#125;fieldset,img&#123;border:0&#125;img,object,input,textarea,button,select&#123;vertical-align:middle&#125;article,aside,footer,header,section,nav,figure,figcaption,hgroup,details,menu&#123;display:block&#125;audio,canvas,video&#123;display:inline-block;*display:inline;*zoom:1&#125;blockquote:before,blockquote:after,q:before,q:after&#123;content:&quot;\\0020&quot;&#125;textarea&#123;overflow:auto;resize:vertical&#125;input,textarea,button,select,a&#123;outline:0 none;border: none;&#125;button::-moz-focus-inner,input::-moz-focus-inner&#123;padding:0;border:0&#125;mark&#123;background-color:transparent&#125;a,ins,s,u,del&#123;text-decoration:none&#125;sup,sub&#123;vertical-align:baseline&#125;html &#123;overflow-x: hidden;height: 100%;font-size: 50px;-webkit-tap-highlight-color: transparent;&#125;body &#123;font-family: Arial, &quot;Microsoft Yahei&quot;, &quot;Helvetica Neue&quot;, Helvetica, sans-serif;color: #333;font-size: .28em;line-height: 1;-webkit-text-size-adjust: none;&#125;hr &#123;height: .02rem;margin: .1rem 0;border: medium none;border-top: .02rem solid #cacaca;&#125;a &#123;color: #25a4bb;text-decoration: none;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/** * Eric Meyer&apos;s Reset CSS v2.0 (http://meyerweb.com/eric/tools/css/reset/) * http://cssreset.com */ html, body, div, span, applet, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,a, abbr, acronym, address, big, cite, code,del, dfn, em, img, ins, kbd, q, s, samp,small, strike, strong, sub, sup, tt, var,b, u, i, center,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td,article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary,time, mark, audio, video&#123; margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; font-weight: normal; vertical-align: baseline;&#125;/* HTML5 display-role reset for older browsers */article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section&#123; display: block;&#125;ol, ul, li&#123; list-style: none;&#125;blockquote, q&#123; quotes: none;&#125;blockquote:before, blockquote:after,q:before, q:after&#123; content: &apos;&apos;; content: none;&#125;table&#123; border-collapse: collapse; border-spacing: 0;&#125; /* custom */a&#123; color: #7e8c8d; text-decoration: none; -webkit-backface-visibility: hidden;&#125;::-webkit-scrollbar&#123; width: 5px; height: 5px;&#125;::-webkit-scrollbar-track-piece&#123; background-color: rgba(0, 0, 0, 0.2); -webkit-border-radius: 6px;&#125;::-webkit-scrollbar-thumb:vertical&#123; height: 5px; background-color: rgba(125, 125, 125, 0.7); -webkit-border-radius: 6px;&#125;::-webkit-scrollbar-thumb:horizontal&#123; width: 5px; background-color: rgba(125, 125, 125, 0.7); -webkit-border-radius: 6px;&#125;html, body&#123; width: 100%; font-family: &quot;Arial&quot;, &quot;Microsoft YaHei&quot;, &quot;黑体&quot;, &quot;宋体&quot;, &quot;微软雅黑&quot;, sans-serif;&#125;body&#123; line-height: 1; -webkit-text-size-adjust: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0);&#125;html&#123; overflow-y: scroll;&#125; /*清除浮动*/.clearfix:before,.clearfix:after&#123; content: &quot; &quot;; display: inline-block; height: 0; clear: both; visibility: hidden;&#125;.clearfix&#123; *zoom: 1;&#125; /*隐藏*/.dn&#123; display: none;&#125; 9、display:inline-block（IE7及以下不支持）需要对低版本IE特殊处理： 12345&#123; display:inline-block; display:inline; zoom:1;&#125; 10、display:inline-block 什么时候会显示间隙？怎样消除间隙？父元素font-size设置成0，子元素重新设置font-sizedisplay:inline-block滥用容易出现布局方面的问题，尤其在左中右、左右等布局方面的问题尤为突出。因此如果是左右布局的话，尽量都用浮动来代替。 11、z-indexz-index在IE7及以下版本的话，有时会发现不是谁z-index设置的越高谁就显示在最上面。碰到这种问题需要设置父元素有相对定位属性元素的z-index。先比较父元素的z-index再比较子元素的 12、IE8-(IE8及以下)rgba模式不兼容的解决方案IE8以及以下用滤镜， filter:Alpha(opacity=20); 13、当标签的高度设置小于10px，在IE6、IE7中会超出自己设置的高度解决方案：超出高度的标签设置overflow:hidden，或者设置line-height的值小于你的设置高度 14、png24位的图片在iE6浏览器上出现背景解决方案：是做成PNG8. 15、获取自定义属性IE下,可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性;Firefox下,只能使用getAttribute()获取自定义属性。 解决方法：统一通过getAttribute()获取自定义属性 16、IE下,even对象有x,y属性,但是没有pageX,pageY属性；Firefox下,event对象有pageX,pageY属性,但是没有x,y属性解决方法：使用 mX(mX = event.x ? event.x : event.pageX;)来代替 IE 下的 event.x 或者 Firefox 下的 event.pageX. IE6 遇到什么 bug？解决办法是？一、IE6 双倍边距 bug 当页面上的元素使用 float 浮动时，不管是向左还是向右浮动;只要该元素带有 margin 像素都会使该值乘以 2，例如“margin-left:10px” 在 IE6 中，该值就会被解析为 20px。想要解决这个 BUG 就需要在该元素中加入 display:inline 或 display:block 明确其元素类型即可解决双倍边距的 BUG 二、IE6 中 3 像素问题及解决办法 当元素使用 float 浮动后，元素与相邻的元素之间会产生 3px 的间隙。诡异的是如果右侧的容器没设置高度时 3px 的间隙在相邻容器的内部，当设定高度后又跑到容器的相反侧了。要解决这类 BUG 的话，需要使布局在同一行的元素都加上 float 浮动。 三、IE6 中奇数宽高的 BUG IE6 中奇数的高宽显示大小与偶数高宽显示大小存在一定的不同。其中要问题是出在奇数高宽上。要解决此类问题，只需要尽量将外部定位的 div 高宽写成偶数即可。 四、IE6 中图片链接的下方有间隙 IE6 中图片的下方会存在一定的间隙，尤其在图片垂直挨着图片的时候，即可看到这样的间隙。要解决此类问题，需要将 img 标签定义为 display:block 或定义 vertical-align 对应的属性。也可以为 img 对应的样式写入 font-size:0 五、IE6 下空元素的高度 BUG 如果一个元素中没有任何内容，当在样式中为这个元素设置了 0-19px 之间的高度时。此元素的高度始终为 19px。 解决的方法有四种: 1.在元素的 css 中加入：overflow:hidden 2.在元素中插入 html 注释： 3.在元素中插入 html 的空白符： 4.在元素的 css 中加入：font-size:0 六、重复文字的 BUG 在某些比较复杂的排版中，有时候浮动元素的最后一些字符会出现在 clear 清除元素的下面。 解决方法如下： 1.确保元素都带有 display:inline 2.在最后一个元素上使用“margin-right:-3px 3.为浮动元素的最后一个条目加上条件注释，xxx 4.在容器的最后元素使用一个空白的 div，为这个 div 指定不超过容器的宽度。 七、IE6 中 z-index 失效 具体 BUG 为，元素的父级元素设置的 z-index 为 1，那么其子级元素再设置 z-index 时会失效，其层级会继承父级元素的设置，造成某些层级调整上的 BUG。 写在最后：实际上 IE6 中，很多 BUG 的解决方法都可以使用 display:inline、font-size:0、float 解决。因此我们在书写代码时要记住，一旦使用了 float 浮动，就为元素增加一个 display:inline 样式，可以有效的避免浮动造成的样式错乱问题。使用空 DIV 时，为了避免其高度影响布局美观，也可以为其加上 font-size:0 这样就很容易避免一些兼容上的问题。 解析：参考 IE 和标准下有哪些兼容性的写法123var ev = ev || window.event;document.documentElement.clientWidth || document.body.clientWidth;var target = ev.srcElement || ev.target; 为什么不能定义 1px 左右的 div 容器？IE6 下这个问题是因为默认的行高造成的，解决的方法也有很多，例如：overflow:hidden | zoom:0.08 | line-height:1px 知道什么是 webkit 么? 知道怎么用浏览器的各种工具来调试和 debug 代码么?Webkit 是浏览器引擎，包括 html 渲染和 js 解析功能，手机浏览器的主流内核，与之相对应的引擎有 Gecko（Mozilla Firefox 等使用）和 Trident（也称 MSHTML，IE 使用）。对于浏览器的调试工具要熟练使用，主要是页面结构分析，后台请求信息查看，js 调试工具使用，熟练使用这些工具可以快速提高解决问题的效率 为什么要初始化CSS样式？因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。 什么是CSS hack？由于不同厂商的流览器或某浏览器的不同版本（如IE6-IE11,Firefox/Safari/Opera/Chrome等），对CSS的支持、解析不一样，导致在不同浏览器的环境中呈现出不一致的页面展现效果。这时，我们为了获得统一的页面效果，就需要针对不同的浏览器或不同版本写特定的CSS样式，我们把这个针对不同的浏览器/不同版本写相应的CSS code的过程，叫做CSS hack! CSS hack的原理由于不同的浏览器和浏览器各版本对CSS的支持及解析结果不一样，以及CSS优先级对浏览器展现效果的影响，我们可以据此针对不同的浏览器情景来应用不同的CSS。 CSS hack分类科普lte：就是Less than or equal to的简写，也就是小于或等于的意思。lt ：就是Less than的简写，也就是小于的意思。gte：就是Greater than or equal to的简写，也就是大于或等于的意思。gt ：就是Greater than的简写，也就是大于的意思。! ：就是不等于的意思，跟javascript里的不等于判断符相同CSS Hack大致有3种表现形式 CSS属性前缀法、选择器前缀法以及IE条件注释法（即HTML头部引用if IE）Hack，实际项目中CSS Hack大部分是针对IE浏览器不同版本之间的表现差异而引入的。 属性前缀法(即类内部Hack)例如 IE6能识别下划线””和星号” * “，IE7能识别星号” * “，但不能识别下划线””，IE6~IE10都认识”\\9”，但firefox前述三个都不能认识 12345678.all IE&#123;property:value\\9;&#125;.gte IE 8&#123;property:value\\0;&#125;.lte IE 7&#123;*property:value;&#125;.IE 8/9&#123;property:value\\0;&#125;.IE 9&#123;property:value\\9\\0;&#125;.IE 7&#123;+property:value;&#125;.IE 6&#123;_property:value;&#125;.not IE&#123;property//:value;&#125; 选择器前缀法(即选择器Hack)：例如 IE6能识别html .class{}，IE7能识别+html .class{}或者*:first-child+html .class{}。 IE条件注释法(即HTML条件注释Hack)针对所有IE(注：IE10+已经不再支持条件注释)： ，针对IE6及以下版本： 。 这类Hack不仅对CSS生效，对写在判断语句里面的所有代码都会生效。 有一个导航栏在chrome 里面样式完好？在 IE 里文字都聚到一起了，是哪个兼容性问题？ 用了 display：flex 属性，在 ie10 以下都是无效的。 兼容各种浏览器版本的事件绑定1234567891011/*兼容低版本IE，ele为需要绑定事件的元素，eventName为事件名（保持addEventListener语法，去掉on），fun为事件响应函数*/function addEvent(ele, eventName, fun) &#123; if (ele.addEventListener) &#123; ele.addEventListener(eventName, fun, false); &#125; else &#123; ele.attachEvent(\"on\" + eventNme, fun); &#125;&#125; const 问题Firefox 下,可以使用 const 关键字或 var 关键字来定义常量;IE 下,不能使用 const 关键字，只能使用 var 关键字来定义常量.解决方法：统一使用 var 关键字来定义常量. 关于高度问题如果是动态地添加内容，高度最好不要定义。 浏览器可以自动伸缩，然而如果是静态的内容，高度最好定好。 如果设定了高度，内容过多时，ie6 下会自动增加高度、其他浏览器会超出边框。 解决： 1.设置 overflow:hidden; 2.高度自增 height:auto!important;height:100px; 为什么无法定义 1px 左右高度的容器IE6 下这个问题是因为默认的行高造成的,解决的技巧也有很多： 例如:overflow:hidden zoom:0.08 line-height:1px 页面的最小宽度如上一个问题，IE 不识别 min，要实现最小宽度，可用下面的方法： #container{ min-width: 600px; width:expression(document.body.clientWidth ＜ 600? “600px”: “auto” );} 第一个 min-width 是正常的；但第 2 行的 width 使用了 Javascript，这只有 IE 才认得，这也会让你的 HTML 文档不太正规。它实际上通过 Javascript 的判断来实现最小宽度。 默认的内外边距不同问题： 各个浏览器默认的内外边距不同 解决方案： *{margin:0;padding:0;} 水平居中的问题问题： 设置 text-align: center ie6-7 文本居中，嵌套的块元素也会居中 ff /opera /safari /ie8 文本会居中，嵌套块不会居中解决： 块元素设置 1、margin-left:auto;margin-right:auto 2、margin:0 auto; 3、 垂直居中的问题问题：在浏览器中想要垂直居中，设置 vertical-align:middle; 不起作用。例如：ie6 下文本与文本输入框对不齐，需设置 vertical-align:middle，但是文本框的内容不会垂直居中 解决：给容器设置一个与其高度相同的行高line-height:与容器的 height 一样 除去滚动条的问题问题：隐藏滚动条解决：1、只有 ie6-7 支持2、除 ie6-7 不支持 body{overflow:hidden}3、所有浏览器 html{overflow:hidden} 子容器宽度大于父容器宽度时，内容超出问题：子 DIV 的宽度和父 DIV 的宽度都已经定义，在 IE6 中如果其子 DIV 的宽度大于父 DIV 的宽度，父 DIV 的宽度将会被扩展，在其他浏览器中父 DIV 的宽度将不会扩展，子 DIV 将超出父 DIV解决：设置 overflow:hidden，子 DIV 将不会超出父 DIV。 HTML 对象获取问题FireFox：document.getElementById(“idName”);ie:document.idname 或者 document.getElementById(“idName”).解决办法：统一使用 document.getElementById(“idName”); window.location.href 问题说明:IE 或者 Firefox2.0.x 下,可以使用 window.location 或 window.location.href;Firefox1.5.x 下,只能使用 window.location. 解决方法：使用 window.location 来代替 window.location.href. frame 问题以下面的 frame 为例： 1&lt;frame src=\"xxx.html\" id=\"frameId\" name=\"frameName\" /&gt; (1)访问 frame 对象:IE:使用 window.frameId 或者 window.frameName 来访问这个 frame 对象. frameId 和 frameName 可以同名。Firefox:只能使用 window.frameName 来访问这个 frame 对象.另外，在 IE 和 Firefox 中都可以使用 window.document.getElementById(“frameId”)来访问这个 frame 对象.(2)切换 frame 内容:在 IE 和 Firefox 中都可以使用 window.document.getElementById(“testFrame”).src = “xxx.html”或 window.frameName.location = “xxx.html”来切换 frame 的内容.如果需要将 frame 中的参数传回父窗口(注意不是 opener,而是 parent frame)，可以在 frame 中使用 parent 来访问父窗口。例如：parent.document.form1.filename.value=”Aqing”; 模态和非模态窗口问题说明:IE 下,可以通过 showModalDialog 和 showModelessDialog 打开模态和非模态窗口;Firefox 下则不能.解决方法：直接使用 window.open(pageURL,name,parameters)方式打开新窗口。如果需要将子窗口中的参数传递回父窗口,可以在子窗口中使用 window.opener 来访问父窗口.例如：var parWin = window.opener; parWin.document.getElementById(“Aqing”).value = “Aqing”; firefox 与 IE 的父元素(parentElement)的区别IE：obj.parentElementfirefox：obj.parentNode解决方法: 因为 firefox 与 IE 都支持 DOM,因此使用 obj.parentNode 是不错选择. document.formName.item(”itemName”) 问题问题说明：IE 下，可以使用 document.formName.item(”itemName”) 或 document.formName.elements [“elementName”]；Firefox 下，只能使用 document.formName.elements[“elementName”]。解决方法：统一使用 document.formName.elements[“elementName”]。 集合类对象问题问题说明：IE 下，可以使用 () 或 [] 获取集合类对象；Firefox 下，只能使用 [ ]获取集合类对象。解决方法：统一使用 [] 获取集合类对象。 自定义属性问题问题说明：IE 下，可以使用获取常规属性的方法来获取自定义属性，也可以使用 getAttribute() 获取自定义属性；Firefox 下，只能使用 getAttribute() 获取自定义属性。解决方法：统一通过 getAttribute() 获取自定义属性。 input.type 属性问题问题说明：IE 下 input.type 属性为只读；但是 Firefox 下 input.type 属性为读写。解决办法：不修改 input.type 属性。如果必须要修改，可以先隐藏原来的 input，然后在同样的位置再插入一个新的 input 元素。&gt; event.srcElement 问题问题说明：IE 下，even 对象有 srcElement 属性，但是没有 target 属性；Firefox 下，even 对象有 target 属性，但是没有 srcElement 属性。解决方法：使用 srcObj = event.srcElement ?event.srcElement : event.target;如果考虑第 8 条问题，就改用 myEvent 代替 event 即可。 body 载入问题问题说明：Firefox 的 body 对象在 body 标签没有被浏览器完全读入之前就存在；而 IE 的 body 对象则必须在 body 标签被浏览器完全读入之后才存在。[注] 这个问题尚未实际验证，待验证后再来修改。[注] 经验证，IE6、Opera9 以及 FireFox2 中不存在上述问题，单纯的 JS 脚本可以访问在脚本之前已经载入的所有对象和元素，即使这个元素还没有载入完成。 事件委托方法问题说明：IE 下，使用 document.body.onload = inject; 其中 function inject()在这之前已被实现；在 Firefox 下，使用 document.body.onload = inject();解决方法：统一使用 document.body.onload=new Function(’inject()’); 或者 document.body.onload = function(){}[注意] Function 和 function 的区别。 Table 操作问题问题说明：ie、firefox 以及其它浏览器对于 table 标签的操作都各不相同，在 ie 中不允许对 table 和 tr 的 innerHTML 赋值，使用 js 增加一个 tr 时，使用 appendChild 方法也不管用。解决方法：//向 table 追加一个空行：var row = otable.insertRow(-1);var cell = document.createElement(“td”);cell.innerHTML = “”;cell.className = “XXXX”;row.appendChild(cell);[注] 由于俺很少使用 JS 直接操作表格，这个问题没有遇见过。建议使用 JS 框架集来操作 table，如 JQuery。 对象宽高赋值问题问题说明：FireFox 中类似 obj.style.height = imgObj.height 的语句无效。 Ø CSS cursor:hand VS cursor:pointerfirefox 不支持 hand，但 ie 支持 pointer解决方法: 统一使用 pointer innerText 在 IE 中能正常工作，但在 FireFox 中却不行需用 textContent。解决方法: 12345if(navigator.appName.indexOf(&quot;Explorer&quot;) &gt; -1)&#123; document.getElementById(&apos;element&apos;).innerText = &quot;my text&quot;;&#125;else&#123; document.getElementById(&apos;element&apos;).textContent = &quot;my text&quot;;&#125; CSS 透明IE：filter:progid:DXImageTransform.Microsoft.Alpha(style=0,opacity=60)。FF：opacity:0.6。opacity 透明，子元素会继承透明属性。解决方式： 1、使用 background:rgba(0,0,0,.6) //IE8 及以下无效果。 2、使用定位，背景色与子元素处于同级关系。 css 中的 width 和 padding在 IE7 和 FF 中 width 宽度不包括 padding，在 Ie6 中包括 padding. FF 和 IEBOX 模型解释不一致导致相差 2pxbox.style{width:100;border 1px;}ie 理解为 box.width = 100ff 理解为 box.width = 100 + 1*2 = 102 //加上边框 2px 解决方法：div{margin:30px!important;margin:28px;}注意这两个 margin 的顺序一定不能写反， IE 不能识别!important 这个属性，但别的浏览器可以识别。所以在 IE 下其实解释成这样：div{maring:30px;margin:28px}重复定义的话按照最后一个来执行，所以不可以只写 margin:XXpx!important; IE5 和 IE6 的 BOX 解释不一致IE5 下 div{width:300px;margin:0 10px 0 10px;}div 的宽度会被解释为 300px-10px(右填充)-10px(左填充)，最终 div 的宽度为 280px，而在 IE6 和其他浏览器上宽度则是以 300px+10px(右填充)+10px(左填充)=320px 来计算的。这时我们可以做如下修改 div{width:300px!important;width :340px;margin:0 10px 0 10px} ul 和 ol 列表缩进问题消除 ul、ol 等列表的缩进时，样式应写成：list-style:none;margin:0px;padding:0px;经验证，在 IE 中，设置 margin:0px 可以去除列表的上下左右缩进、空白以及列表编号或圆点，设置 padding 对样式没有影响；在 Firefox 中，设置 margin:0px 仅仅可以去除上下的空白，设置 padding:0px 后仅仅可以去掉左右缩进，还必须设置 list- style:none 才能去除列表编号或圆点。也就是说，在 IE 中仅仅设置 margin:0px 即可达到最终效果，而在 Firefox 中必须同时设置 margin:0px、 padding:0px 以及 list-style:none 三项才能达到最终效果。 元素水平居中问题FF: margin:0 auto; IE: 父级{ text-align:center; } Div 的垂直居中问题vertical-align:middle; 将行距增加到和整个 DIV 一样高：line-height:200px; 然后插入文字，就垂直居中了。 缺点是要控制内容不要换行。 margin 加倍的问题设置为 float 的 div 在 ie 下设置的 margin 会加倍。这是一个 ie6 都存在的 bug。解决方案是在这个 div 里面加上 display:inline; 例如： 123456&lt;div id=”imfloat”&gt;相应的css为#imfloat&#123;float:left;margin:5px;display:inline;&#125; IE 与宽度和高度的问题IE 不认得 min-这个定义，但实际上它把正常的 width 和 height 当作有 min 的情况来使。这样问题就大了，如果只用宽度和高度，正常的浏览器里这两个值就不会变，如果只用 min-width 和 min-height 的话，IE 下面根本等于没有设置宽度和高度。 比如要设置背景图片，这个宽度是比较重要的。要解决这个问题，可以这样： #box{ width: 80px; height: 35px;}html&gt;body #box{ width: auto; height: auto; min-width: 80px; min-height: 35px;} DIV 浮动 IE 文本产生 3 像素的 bug左边对象浮动，右边采用外补丁的左边距来定位，右边对象内的文本会离左边有 3px 的间距. #box{ float:left; width:800px;} #left{ float:left; width:50%;} #right{ width:50%;}*html #left{ margin-right:-3px; //这句是关键} 123&lt;div id=&quot;box&quot;&gt;&lt;div id=&quot;left&quot;&gt;＜/div&gt;&lt;div id=&quot;right&quot;&gt;＜/div&gt; IE 捉迷藏的问题当 div 应用复杂的时候每个栏中又有一些链接，DIV 等这个时候容易发生捉迷藏的问题。 有些内容显示不出来，当鼠标选择这个区域是发现内容确实在页面。 解决办法：对#layout 使用 line-height 属性或者给#layout 使用固定高和宽。页面结构尽量简单。 float 的 div 闭合;清除浮动;自适应高度① 例如：＜ div id=”floatA”&gt;＜ div id=”floatB”&gt;＜ div id=”NOTfloatC”&gt; 这里的 NOTfloatC 并不希望继续平移，而是希望往下排。(其中 floatA、floatB 的属性已经设置为 float:left;) 这段代码在 IE 中毫无问题，问题出在 FF。原因是 NOTfloatC 并非 float 标签，必须将 float 标签闭合。在＜ div class=”floatB”&gt;＜ div class=”NOTfloatC”&gt;之间加上＜ div class=”clear”&gt;这个 div 一定要注意位置，而且必须与两个具有 float 属性的 div 同级，之间不能存在嵌套关系，否则会产生异常。并且将 clear 这种样式定义为为如下即可：.clear{clear:both;} ② 作为外部 wrapper 的 div 不要定死高度,为了让高度能自适应，要在 wrapper 里面加上 overflow:hidden; 当包含 float 的 box 的时候，高度自适应在 IE 下无效，这时候应该触发 IE 的 layout 私有属性(万恶的 IE 啊！)用 zoom:1;可以做到，这样就达到了兼容。例如某一个 wrapper 如下定义： .colwrapper{overflow:hidden; zoom:1; margin:5px auto;} ③ 对于排版,我们用得最多的 css 描述可能就是 float:left.有的时候我们需要在 n 栏的 float div 后面做一个统一的背景,譬如: 12345&lt;div id=”page”&gt; &lt;div id=”left”&gt;＜/div&gt; &lt;div id=”center”&gt;＜/div&gt; &lt;div id=”right”&gt;＜/div&gt;&lt;/div&gt; 比如我们要将 page 的背景设置成蓝色,以达到所有三栏的背景颜色是蓝色的目的,但是我们会发现随着 left center right 的向下拉长,而 page 居然保存高度不变,问题来了,原因在于 page 不是 float 属性,而我们的 page 由于要居中,不能设置成 float,所以我们应该这样解决： 1234567&lt;div id=”page”&gt; &lt;div id=”bg” style=”float:left;width:100%”&gt; &lt;div id=”left”&gt;＜/div&gt; &lt;div id=”center”&gt;＜/div&gt; &lt;div id=”right”&gt;＜/div&gt; &lt;/div&gt;&lt;/div&gt; 再嵌入一个 float left 而宽度是 100%的 DIV 解决之。 或者另一种方法：用选择器（：after）在 page 之后插入一个空标签,并清除浮动 .page:after { content: “”; display: table; clear: both; } ④ 万能 float 闭合(非常重要!) 关于 clear float 的原理可参见 [How To Clear Floats Without Structural Markup],将以下代码加入 Global CSS 中,给需要闭合的 div 加上 class=”clearfix” 即可,屡试不爽。 1234.clearfix:after &#123; content:&quot;.&quot;; display:block; height:0; clear:both; visibility:hidden; &#125;.clearfix &#123; display:inline-block; &#125;.clearfix &#123;display:block;&#125; 或者这样设置：.hackbox{ display:table; //将对象作为块元素级的表格显示} 高度不适应高度不适应是当内层对象的高度发生变化时外层高度不能自动进行调节，特别是当内层对象使用 margin 或 padding 时。 例： 1234567891011121314151617181920212223242526272829303132#box &#123; &#125;#box p &#123;margin-top: 20px;margin-bottom: 20px; text-align:center; &#125;&lt;div id=&quot;box&quot;&gt;&lt;p&gt;p对象中的内容＜/p&gt;&lt;/div&gt;解决技巧：在P对象上下各加2个空的div对象CSS代码&#123;height:0px;overflow:hidden;&#125;或者为DIV加上border属性。&lt;/details&gt;&lt;b&gt;&lt;details&gt;&lt;summary&gt;32. IE6下图片下有空隙产生&lt;/summary&gt;&lt;/b&gt;解决这个BUG的技巧有很多,可以是改变html的排版,或者设置img为display:block或者设置vertical-align属性为vertical-align:top/bottom/middle/text-bottom 都可以解决.&lt;/details&gt;&lt;b&gt;&lt;details&gt;&lt;summary&gt;33. 对齐文本与文本输入框&lt;/summary&gt;&lt;/b&gt;加上vertical-align:middle;&lt;style type=&quot;text/css&quot;&gt;&lt;!--input &#123;width:200px;height:30px;border:1px solid red;vertical-align:middle;&#125;--&gt;&lt;/style&gt;经验证，在IE下任一版本都不适用，而ff、opera、safari、chrome均OK！ LI 中内容超过长度后以省略号显示此技巧适用与 IE、Opera、safari、chrom 浏览器，FF 暂不支持。 123456789&lt;style type=&quot;text/css&quot;&gt; li &#123; width:200px; white-space:nowrap; text-overflow:ellipsis; -o-text-overflow:ellipsis; overflow: hidden; &#125;&lt;/style&gt; 为什么 web 标准中 IE 无法设置滚动条颜色了1234567891011121314151617解决办法是将body换成html&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;&lt;!--html &#123;scrollbar-face-color:#f6f6f6;scrollbar-highlight-color:#fff;scrollbar-shadow-color:#eeeeee;scrollbar-3dlight-color:#eeeeee;scrollbar-arrow-color:#000;scrollbar-track-color:#fff;scrollbar-darkshadow-color:#fff;&#125;--&gt;＜/style&gt; 怎么样才能让层显示在 FLASH 之上呢12解决的办法是给FLASH设置透明&lt;param name=&quot;wmode&quot; value=&quot;transparent&quot; /&gt; 链接(a 标签)的边框与背景a 链接加边框和背景色，需设置 display: block, 同时设置 float: left 保证不换行。参照 menubar, 给 a 和 menubar 设置高度是为了避免底边显示错位, 若不设 height, 可以在 menubar 中插入一个空格。 超链接访问过后 hover 样式就不出现的问题123456789101112被点击访问过的超链接样式不在具有hover和active了,很多人应该都遇到过这个问题,解决技巧是改变CSS属性的排列顺序: L-V-H-ACode:&lt;style type=&quot;text/css&quot;&gt;&lt;!--a:link &#123;&#125;a:visited &#123;&#125;a:hover &#123;&#125;a:active &#123;&#125;--&gt;&lt;/style&gt; FORM 标签这个标签在 IE 中,将会自动 margin 一些边距,而在 FF 中 margin 则是 0,因此,如果想显示一致,所以最好在 css 中指定 margin 和 padding,针对上面两个问题,我的 css 中一般首先都使用这样的样式 ul,form{margin:0;padding:0;}。 属性选择器(这个不能算是兼容,是隐藏 css 的一个 bug)p[id]{}div[id]{} 这个对于 IE6.0 和 IE6.0 以下的版本都隐藏,FF 和 OPera 作用.属性选择器和子选择器还是有区别的,子选择器的范围从形式来说缩小了,属性选择器的范围比较大,如 p[id]中,所有 p 标签中有 id 的都是同样式的. 为什么 FF 下文本无法撑开容器的高度标准浏览器中固定高度值的容器是不会象 IE6 里那样被撑开的,那我又想固定高度,又想能被撑开需要怎样设置呢？办法就是去掉 height 设置 min-height:200px; 这里为了照顾不认识 min-height 的 IE6 可以这样定义: 12345&#123; height:auto!important; height:200px; min-height:200px;&#125; IE 和 FireFox 对空格的尺寸解释不同，FireFox 为 4px,IE 为 8px;FireFox 对 div 与 div 之间的空格是忽略的，但是 IE 是处理的。因此在两个相邻 div 之间不要有空格跟回车，否则可能造成不同浏览间之间格式不正确，比如著名的 3px 偏差（多个 img 标签连着，然后定义 float: left;结果在 firefox 里面正常，而 IE 里面显示的每个 img 都相隔了 3px。我把标签之间的空格都删除都没有作用。解决方法是在 img 外面套 li，并且对 li 定义 margin: 0; 避免方式：在必要的时候不要无视 list 标签）而且原因难以查明。 条件注释123456789101112131415&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css.css&quot; /&gt;&lt;!--[if IE 7]&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie7.css&quot; /&gt;&lt;![endif]--&gt;&lt;!--[if lte IE 6]&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie.css&quot; /&gt;&lt;![endif]--&gt;lte -- 小于等于lt -- 小于gte -- 大于等于gt -- 大于！ -- 不等于 强制渲染1234567891011&lt;meta http-equiv=X-UA-Compatible content=IE=EmulateIE7&gt; //这句话的意思是强制使用IE7模式来解析网页代码！&lt;meta http-equiv=“X-UA-Compatible” content=“IE=8″&gt;&lt;meta http-equiv=“X-UA-Compatible” content=“chrome=1″ /&gt; //Google Chrome Frame也可以让IE用上Chrome的引擎&lt;meta http-equiv=“X-UA-Compatible” content=“IE=EmulateIE7″&gt;&lt;!– IE7 mode –&gt; 或者 &lt;meta http-equiv=“X-UA-Compatible” content=“IE=7″&gt;&lt;!– IE7 mode –&gt; //强制IE8使用IE7模式来解析&lt;meta http-equiv=“X-UA-Compatible” content=“IE=6″&gt;&lt;!– IE6 mode –&gt; &lt;meta http-equiv=“X-UA-Compatible” content=“IE=5″&gt;&lt;!– IE5 mode –&gt; //强制IE8使用IE6或IE5模式来解析&lt;meta http-equiv=“X-UA-Compatible” content=“IE=5; IE=8″ /&gt; //一个特定版本的IE支持所要求的兼容性模式多于一种 js 兼容文件123456789101112131415使IE5,IE6兼容到IE7模式（推荐）&lt;!–[if lt IE 7]&gt;&lt;script src=”http://ie7-js.googlecode.com/svn/version/2.0(beta)/IE7.js” type=”text/javascript”&gt;&lt;/script&gt;&lt;![endif]–&gt;使IE5,IE6,IE7兼容到IE8模式&lt;!–[if lt IE 8]&gt;&lt;script src=”http://ie7-js.googlecode.com/svn/version/2.0(beta)/IE8.js” type=”text/javascript”&gt;&lt;/script&gt;&lt;![endif]–&gt;使IE5,IE6,IE7,IE8兼容到IE9模式&lt;!–[if lt IE 9]&gt;&lt;script src=”http://ie7-js.googlecode.com/svn/version/2.1(beta4)/IE9.js”&gt;&lt;/script&gt;&lt;![endif]–&gt; 浏览器识别符12345678910111213p&#123; \\_color:red; &#125; IE6 专用*html p&#123; color:#red; &#125; IE6 专用p&#123; +color:red; &#125; IE6,7 专用p&#123; *color:red; &#125; IE6,7 专用_html p&#123; color:red; &#125; IE6,7 专用p&#123;_+color: red;&#125; IE7 专用Body&gt; p&#123; color: red; &#125; 屏蔽 IE6p&#123; color:red\\9; &#125; IE8Firefox: -moz-Safari: -webkit-Opera: -o-IE: -ms- 移动端兼容添加到主屏后的标题（IOS）1&lt;meta name=\"apple-mobile-web-app-title\" content=\"标题\" /&gt; 启用 WebApp123456全屏模式（IOS）当网站添加到主屏幕后再点击进行启动时，可隐藏地址栏（从浏览器跳转或输入链接进入并没有此效果）&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;&lt;meta name=&quot;apple-touch-fullscreen&quot; content=&quot;yes&quot; /&gt; 百度禁止转码12345通过百度手机打开网页时，百度可能会对你的网页进行转码，往你页面贴上它的广告，非常之恶心。不过我们可以通过这个meta标签来禁止它：&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt;百度SiteApp转码声明：http://t.cn/R28wSBl 设置状态栏的背景颜色（IOS）123456789101112设置状态栏的背景颜色，只有在&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;时生效&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black-translucent&quot; /&gt;content 参数：· default ：状态栏背景是白色。· black ：状态栏背景是黑色。· black-translucent ：状态栏背景是半透明。 如果设置为 default 或 black ,网页内容从状态栏底部开始。如果设置为 black-translucent ,网页内容充满整个屏幕，顶部会被状态栏遮挡。 移动端手机号码识别（IOS）12345678910111213141516171819202122在 iOS Safari （其他浏览器和Android均不会）上会对那些看起来像是电话号码的数字处理为电话链接，比如：· 7位数字，形如：1234567· 带括号及加号的数字，形如：(+86)123456789· 双连接线的数字，形如：00-00-00111· 11位数字，形如：13800138000可能还有其他类型的数字也会被识别。我们可以通过如下的meta来关闭电话号码的自动识别：&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt;开启电话功能&lt;a href=&quot;tel:123456&quot;&gt;123456&lt;/a&gt;开启短信功能：&lt;a href=&quot;sms:123456&quot;&gt;123456&lt;/a&gt; 移动端邮箱识别（Android）1234567与电话号码的识别一样，在安卓上会对符合邮箱格式的字符串进行识别，我们可以通过如下的meta来管别邮箱的自动识别：&lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot; /&gt;同样地，我们也可以通过标签属性来开启长按邮箱地址弹出邮件发送的功能：&lt;a mailto:dooyoe@gmail.com&quot;&gt;dooyoe@gmail.com&lt;/a&gt; 添加智能 App12广告条 Smart App Banner（IOS 6+ Safari）&lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL&quot;&gt; IOS Web app 启动动画123456789101112131415由于iPad 的启动画面是不包括状态栏区域的。所以启动图片需要减去状态栏区域所对应的方向上的20px大小，相应地在retina设备上要减去40px的大小。&lt;link href=&quot;apple-touch-startup-image-320×460.png&quot; media=&quot;(device-width: 320px)&quot; rel=&quot;apple-touch-startup-image&quot;&gt;&lt;link href=&quot;apple-touch-startup-image-640×960.png&quot; media=&quot;(device-width: 320px) and (-webkit-device-pixel-ratio: 2)&quot; rel=&quot;apple-touch-startup-image&quot;&gt;&lt;link href=&quot;apple-touch-startup-image-768×1004.png&quot; media=&quot;(device-width: 768px) and (orientation: portrait)&quot; rel=&quot;apple-touch-startup-image&quot;&gt;&lt;link href=&quot;apple-touch-startup-image-748×1024.png&quot; media=&quot;(device-width: 768px) and (orientation: landscape)&quot; rel=&quot;apple-touch-startup-image&quot;&gt;&lt;link href=&quot;apple-touch-startup-image-1536×2008.png&quot; media=&quot;(device-width: 1536px) and (orientation: portrait) and (-webkit-device-pixel-ratio: 2)&quot; rel=&quot;apple-touch-startup-image&quot;&gt;&lt;link href=&quot;apple-touch-startup-image-2048×1496.png&quot; media=&quot;(device-width: 1536px) and (orientation: landscape) and (-webkit-device-pixel-ratio: 2)&quot; rel=&quot;apple-touch-startup-image&quot;&gt;（landscape：横屏 | portrait：竖屏） 添加到主屏后的 APP 图标123456789101112131415161718192021222324252627282930313233343536373839指定web app添加到主屏后的图标路径，有两种略微不同的方式：&lt;!– 设计原图 –&gt;&lt;link href=&quot;short_cut_114x114.png&quot; rel=&quot;apple-touch-icon-precomposed&quot;&gt;&lt;!– 添加高光效果 –&gt;&lt;link href=&quot;short_cut_114x114.png&quot; rel=&quot;apple-touch-icon&quot;&gt;· apple-touch-icon：在IOS6及以下的版本会自动为图标添加一层高光效果（IOS7开始已使用扁平化的设计风格）· apple-touch-icon-precomposed：使用“设计原图图标”效果：图标尺寸：可通过指定size属性来为不同的设备提供不同的图标（但通常来说，我们只需提供一个114 x 114 pixels大小的图标即可 ）官方说明如下：Create different sizes of your app icon for different devices. If you’re creating a universal app, you need to supply appicons in all four sizes.For iPhone and iPod touch both of these sizes are required:57 x 57 pixels114 x 114 pixels (high resolution)For iPad, both of these sizes are required:72 x 72 pixels144 x 144 (high resolution) 优先使用最新版本 IE 和 Chrome1&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt; viewport 模板123456789101112131415161718&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; name=&quot;viewport&quot;&gt;&lt;meta content=&quot;yes&quot; name=&quot;apple-mobile-web-app-capable&quot;&gt;&lt;meta content=&quot;black&quot; name=&quot;apple-mobile-web-app-status-bar-style&quot;&gt;&lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot;&gt;&lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot;&gt;&lt;title&gt;标题&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot;&gt;&lt;/head&gt;&lt;body&gt;这里开始内容&lt;/body&gt;&lt;/html&gt; 移动端如何定义字体 font-family1234567891011121314151617181920212223三大手机系统的字体：iOS 系统· 默认中文字体是Heiti SC· 默认英文字体是Helvetica· 默认数字字体是HelveticaNeue· 无微软雅黑字体Android 系统· 默认中文字体是Droidsansfallback· 默认英文和数字字体是Droid Sans· 无微软雅黑字体Winphone 系统· 默认中文字体是Dengxian(方正等线体)· 默认英文和数字字体是Segoe· 无微软雅黑字体各个手机系统有自己的默认字体，且都不支持微软雅黑，如无特殊需求，手机端无需定义中文字体，使用系统默认英文字体和数字字体可使用 Helvetica ，三种系统都支持。* 移动端定义字体的代码 */body&#123;font-family:Helvetica;&#125; 移动端字体单位 font-size 选择 px 还是 rem1234567891011121314151617181920212223242526272829303132333435363738394041424344454647· 对于只需要适配手机设备，使用px即可· 对于需要适配各种移动设备，使用rem，例如只需要适配iPhone和iPad等分辨率差别比较挺大的设备rem配置参考：html &#123;font-size:10px&#125;@media screen and (min-width:480px) and (max-width:639px) &#123; html &#123; font-size: 15px &#125;&#125;@media screen and (min-width:640px) and (max-width:719px) &#123; html &#123; font-size: 20px &#125;&#125;@media screen and (min-width:720px) and (max-width:749px) &#123; html &#123; font-size: 22.5px &#125;&#125;@media screen and (min-width:750px) and (max-width:799px) &#123; html &#123; font-size: 23.5px &#125;&#125;@media screen and (min-width:800px) and (max-width:959px) &#123; html &#123; font-size: 25px &#125;&#125;@media screen and (min-width:960px) and (max-width:1079px) &#123; html &#123; font-size: 30px &#125;&#125;@media screen and (min-width:1080px) &#123; html &#123; font-size: 32px &#125;&#125; 移动端 touch 事件(区分 webkit 和 winphone)当用户手指放在移动设备在屏幕上滑动会触发的touch事件 以下支持webkit · touchstart——当手指触碰屏幕时候发生。不管当前有多少只手指 · touchmove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动 · touchend——当手指离开屏幕时触发 · touchcancel——系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用 以下支持winphone 8 · MSPointerDown——当手指触碰屏幕时候发生。不管当前有多少只手指 · MSPointerMove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用css的html{-ms-touch-action:none;}可以阻止默认情况的发生：阻止页面滚动 · MSPointerUp——当手指离开屏幕时触发 移动端 click 屏幕产生 200-300 ms 的延迟响应移动设备上的web网页是有300ms延迟的，玩玩会造成按钮点击延迟甚至是点击失效。 以下是历史原因： 2007年苹果发布首款iphone上IOS系统搭载的safari为了将适用于PC端上大屏幕的网页能比较好的展示在手机端上，使用了双击缩放 (double tap to zoom)的方案，比如你在手机上用浏览器打开一个PC上的网页，你可能在看到页面内容虽然可以撑满整个屏幕，但是字体、图片都很小看不清，此时可以快速 双击屏幕上的某一部分，你就能看清该部分放大后的内容，再次双击后能回到原始状态。 双击缩放是指用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。 原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接，此处浏览器会先捕获该次单击，但浏览器不能决定用户是单纯要点击链接还是要双击该部分区域进行缩放操作，所以，捕获第一次单击后，浏览器会先Hold一段时间t，如果在t时间区间里用户未进行下一次点击，则 浏览器会做单击跳转链接的处理，如果t时间里用户进行了第二次单击操作，则浏览器会禁止跳转，转而进行对该部分区域页面的缩放操作。那么这个时间区间t有 多少呢？在IOS safari下，大概为300毫秒。这就是延迟的由来。造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉，对于web开发者来说是，页面js捕获click事件的回调函数处理，需要300ms后才生效，也就间接导致影响其他业务逻辑的处理。 解决方案： · fastclick可以解决在手机上点击事件的300ms延迟 · zepto的touch模块，tap事件也是为了解决在click的延迟问题 触摸事件的响应顺序 1、ontouchstart 2、ontouchmove 3、ontouchend 4、onclick 解决300ms延迟的问题，也可以通过绑定ontouchstart事件，加快对事件的响应。 什么是 Retina12345678910111213141516显示屏，带来了什么问题retina：一种具备超高像素密度的液晶屏，同样大小的屏幕上显示的像素点由1个变为多个，如在同样带下的屏幕上，苹果设备的retina显示屏中，像素点1个变为4个在高清显示屏中的位图被放大，图片会变得模糊，因此移动端的视觉稿通常会设计为传统PC的2倍。那么，前端的应对方案是：设计稿切出来的图片长宽保证为偶数，并使用backgroud-size把图片缩小为原来的1/2//例如图片宽高为：200px*200px，那么写法如下.css&#123;width:100px;height:100px;background-size:100px 100px;&#125;其它元素的取值为原来的1/2，例如视觉稿40px的字体，使用样式的写法为20px.css&#123;font-size:20px&#125; ios 系统中元素被触摸时产生的半透明灰色遮罩怎么去掉123ios用户点击一个链接，会出现一个半透明灰色遮罩, 如果想要禁用，可设置-webkit-tap-highlight-color的alpha值为0，也就是属性值的最后一位设置为0就可以去除半透明灰色遮罩。a,button,input,textarea&#123;-webkit-tap-highlight-color: rgba(0,0,0,0;)&#125; 部分 android 系统中元素被点击时产生的边框怎么去掉12345678android用户点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样，可设置-webkit-tap-highlight-color的alpha值为0去除部分机器自带的效果。a,button,input,textarea&#123; -webkit-tap-highlight-color: rgba(0,0,0,0;) -webkit-user-modify:read-write-plaintext-only;&#125;-webkit-user-modify有个副作用，就是输入法不再能够输入多个字符。另外，有些机型去除不了，如小米2对于按钮类还有个办法，不使用a或者input标签，直接用div标签 winphone 系统 a、input 标签被点击时产生的半透明灰色背景怎么去掉1&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt; webkit 表单元素的默认外观怎么重置1.css&#123;-webkit-appearance:none;&#125; webkit 表单输入框 placeholder 的颜色值能改变么12input::-webkit-input-placeholder&#123;color:#AAAAAA;&#125;input:focus::-webkit-input-placeholder&#123;color:#E webkit 表单输入框 placeholder 的文字能换行么1234iOS可以，Android不行~1. 关闭iOS键盘首字母自动大写在iOS中，默认情况下键盘是开启首字母大写的功能的，如果启用这个功能，可以这样：&lt;input type=&quot;text&quot; autocapitalize=&quot;off&quot; /&gt; 关闭 iOS 输入自动修正12和英文输入默认自动首字母大写那样，IOS还做了一个功能，默认输入法会开启自动修正输入内容，这样的话，用户经常要操作两次。如果不希望开启此功能，我们可以通过input标签属性来关闭掉：&lt;input type=&quot;text&quot; autocorrect=&quot;off&quot; /&gt; 禁止文本缩放12345当移动设备横竖屏切换时，文本的大小会重新计算，进行相应的缩放，当我们不需要这种情况时，可以选择禁止：html &#123; -webkit-text-size-adjust: 100%;&#125;需要注意的是，PC端的该属性已经被移除，该属性在移动端要生效，必须设置 meta viewport。 移动端如何清除输入框内阴影123456在iOS上，输入框默认有内部阴影，但无法使用 box-shadow 来清除，如果不需要阴影，可以这样关闭：input,textarea &#123;border: 0; /* 方法1 */-webkit-appearance: none; /* 方法2 */&#125; 快速回弹滚动我们先来看看回弹滚动在手机浏览器发展的历史：· 早期的时候，移动端的浏览器都不支持非body元素的滚动条，所以一般都借助 iScroll;· Android 3.0/iOS解决了非body元素的滚动问题，但滚动条不可见，同时iOS上只能通过2个手指进行滚动；· Android 4.0解决了滚动条不可见及增加了快速回弹滚动效果，不过随后这个特性又被移除；· iOS从5.0开始解决了滚动条不可见及增加了快速回弹滚动效果在iOS上如果你想让一个元素拥有像 Native 的滚动效果，你可以这样做： 1234.xxx &#123; overflow: auto; /* auto | scroll */ -webkit-overflow-scrolling: touch; &#125; PS：iScroll用过之后感觉不是很好，有一些诡异的bug，这里推荐另外一个 iDangero Swiper，这个插件集成了滑屏滚动的强大功能（支持3D），而且还有回弹滚动的内置滚动条。iDangero官方地址： :www.idangero.us/swiper/#.VX_t9PmEB8Y 移动端禁止选中内容123456如果你不想用户可以选中页面中的内容，那么你可以在css中禁掉：.user-select-none &#123; -webkit-user-select: none; /* Chrome all / Safari all */ -moz-user-select: none; /* Firefox all （移动端不需要） */ -ms-user-select: none; /* IE 10+ */&#125; 移动端取消 touch 高亮效果在做移动端页面时，会发现所有 a 标签在触发点击时或者所有设置了伪类 :active 的元素，默认都会在激活状态时，显示高亮框，如果不想要这个高亮，那么你可以通过 css 以下方法来进行全局的禁止： html { -webkit-tap-highlight-color: rgba(0, 0, 0, 0);} 但这个方法在三星的机子上无效，有一种妥协的方法是把页面非真实跳转链接的 a 标签换成其它标签，可以解决这个问题。 如何禁止保存或拷贝图像（IOS）通常当你在手机或者 pad 上长按图像 img ，会弹出选项存储图像 或者拷贝图像，如果你不想让用户这么操作，那么你可以通过以下方法来禁止： img { -webkit-touch-callout: none; } 模拟按钮 hover 效果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566移动端触摸按钮的效果，可明示用户有些事情正要发生，是一个比较好体验，但是移动设备中并没有鼠标指针，使用css的hover并不能满足我们的需求，还好国外有个激活css的active效果，代码如下，&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; name=&quot;viewport&quot;&gt;&lt;meta content=&quot;yes&quot; name=&quot;apple-mobile-web-app-capable&quot;&gt;&lt;meta content=&quot;black&quot; name=&quot;apple-mobile-web-app-status-bar-style&quot;&gt;&lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot;&gt;&lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot;&gt;&lt;style type=&quot;text/css&quot;&gt;a&#123;-webkit-tap-highlight-color: rgba(0,0,0,0);&#125;.btn-blue&#123;display:block;height:42px;line-height:42px;text-align:center;border-radius:4px;font-size:18px;color:#FFFFFF;background-color: #4185F3;&#125;.btn-blue:active&#123;background-color: #357AE8;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;btn-blue&quot;&gt;按钮&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;document.addEventListener(&quot;touchstart&quot;, function()&#123;&#125;, true)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;兼容性ios5+、部分android 4+、winphone 8要做到全兼容的办法，可通过绑定ontouchstart和ontouchend来控制按钮的类名。&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; name=&quot;viewport&quot;&gt;&lt;meta content=&quot;yes&quot; name=&quot;apple-mobile-web-app-capable&quot;&gt;&lt;meta content=&quot;black&quot; name=&quot;apple-mobile-web-app-status-bar-style&quot;&gt;&lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot;&gt;&lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot;&gt;&lt;style type=&quot;text/css&quot;&gt;a&#123;-webkit-tap-highlight-color: rgba(0,0,0,0);&#125;.btn-blue&#123;display:block;height:42px;line-height:42px;text-align:center;border-radius:4px;font-size:18px;color:#FFFFFF;background-color: #4185F3;&#125;.btn-blue-on&#123;background-color: #357AE8;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;btn-blue&quot;&gt;按钮&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;var btnBlue = document.querySelector(&quot;.btn-blue&quot;);btnBlue.ontouchstart = function()&#123; this.className = &quot;btn-blue btn-blue-on&quot;&#125;btnBlue.ontouchend = function()&#123; this.className = &quot;btn-blue&quot;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 屏幕旋转的事件和样式事件1234567891011121314151617181920212223window.orientation，取值：正负90表示横屏模式、0和180表现为竖屏模式；window.onorientationchange = function()&#123; switch(window.orientation)&#123; case -90: case 90: alert(&quot;横屏:&quot; + window.orientation); case 0: case 180: alert(&quot;竖屏:&quot; + window.orientation); break; &#125;&#125;样式//竖屏时使用的样式@media all and (orientation:portrait) &#123; .css&#123;&#125;&#125;//横屏时使用的样式@media all and (orientation:landscape) &#123; .css&#123;&#125;&#125; audio 元素和 video 元素在 ios 和 andriod 中无法自动播放应对方案：触屏即播 123$(‘html’).one(‘touchstart’,function()&#123;audio.play()&#125;) 摇一摇功能HTML5 deviceMotion：封装了运动传感器数据的事件，可以获取手机运动状态下的运动加速度等数据。 手机拍照和上传图片12345678910111213&lt;input type=&quot;file&quot;&gt;的accept 属性&lt;!– 选择照片 –&gt;&lt;input type=file accept=&quot;image/*&quot;&gt;&lt;!– 选择视频 –&gt;&lt;input type=file accept=&quot;video/*&quot;&gt;使用总结：· iOS有拍照、录像、选取本地图片功能· 部分android只有选取本地图片功能· winphone不支持· input控件默认外观丑陋 不常用消除 transition 闪屏12345678910111213141516171819202122232425262728293031323334353637.css&#123; /*设置内嵌的元素在 3D 空间如何呈现：保留 3D*/ -webkit-transform-style: preserve-3d; /*（设置进行转换的元素的背面在面对用户时是否可见：隐藏）*/ -webkit-backface-visibility: hidden;&#125;开启硬件加速· 解决页面闪白· 保证动画流畅 .css &#123; -webkit-transform: translate3d(0, 0, 0); -moz-transform: translate3d(0, 0, 0); -ms-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0); &#125;设计高性能CSS3动画的几个要素· 尽可能地使用合成属性transform和opacity来设计CSS3动画· 不使用position的left和top来定位· 利用translate3D开启GPU加速 android 上去掉语音输入按钮input::-webkit-input-speech-button {display: none} 不同浏览器的标签默认外补丁 margin 和内补丁 padding 不同发生概率：100% 解决方案：使用 CSS 通配符*，设置内外补丁为 0 *{ margin: 0; padding: 0;} 块属性标签 float 之后，又有横向的 margin 值，在 IE6 中显示会比设置的大（IE6 双边距 bug）解决方案：在 float 标签样式控制中加入 display:inline; 设置较小的高度标签（一般小于 10px），在 IE6，IE7，遨游中超出自己设置的高度发生概率：60% 解决方案：给超出高度的标签设置 overflow:hidden;或者设置行高 line-height 小于你设置的高度。 行内标签设置 display:block;后又采用 float 布局，再设置横向 margin 值时，在 IE6 中显示会比设置的大（IE6 双边距 bug）发生概率：20% 解决方案：在 display:block;后面加上 display:inline;display:table; 图片默认有间距发生概率：20% 解决方案：使用 float 为 img 布局 标签最低高度设置 min-height 不兼容发生概率：5% 解决方案：例如要设置一个标签的最小高度为 200px { min-height: 200px; height: auto!important; height: 200px; overflow: visible;} 透明度兼容设置发生概率：主要看你要写的东西设不设透明度 解决方案：一句话 transparent_class { filter:alpha(opacity=50); -moz-opacity:0.5; -khtml-opacity: 0.5; opacity: 0.5; }opacity:0.5; This is the “most important” one because it is the currentstandard in CSS. This will work in most versions of Firefox, Safari, andOpera.This would be all you need if all browsers supported current standards. Which,of course, they don’t. filter:alpha(opacity=50); This one you need for IE. -moz-opacity:0.5; You need this one to support way old school versions of theMozilla browsers like Netscape Navigator. -khtml-opacity:0.5; This is for way old versions of Safari (1.x) when therendering engine it was using was still referred to as KTHML, asopposed to thecurrent WebKit . Box Model 的 bug描述：给一个元素设置了高度和宽度的同时，还为其设置 margin 和 padding 的值，会改变该元素的实际大小。 解决办法：在需要加 margin 和 padding 的 div 内部加一个 div,在这个 div 里设置 margin 和 padding 值。 IE6 中的列表 li 楼梯状 bug描述：通常在 li 中的元素（比如 a）设置了浮动 float，但 li 本身不浮动。 解决办法： ul li{float:left;} 或 ul li{display:inline;} li 空白间距描述：在 IE 下，会增加 li 和 li 之间的垂直间距 解决办法：给 li 里的 a 显式的添加宽度或者高度 li a{width:20px;} 或者 li a{display:block;float:left;clear:left;} 或者 li {display:inline;} li a{display:block;} 或者 在每个列表 li 上设置一个实线的底边，颜色和 li 的背景色相同 overflow：auto;和 position:relative 的碰撞描述：此 bug 只出现在 IE6 和 IE7 中，有两个块级元素，父元素设置了 overflow：auto;子元素设置了 position:relative;且高度大于父元素，在 IE6-7 中子元素不会被隐藏而是溢出。 解决方案：给父元素也设置 position:relative; 浮动层的错位描述：当内容超出外包容器定义的宽度时会导致浮动层错位问题。在 Firefox、IE7、IE8 及其他标准浏览器里,超出的内容仅仅只是超出边缘;但在 IE6 中容器会忽视定义的 width 值,宽度会错误地随内容宽度增长而增长。如果在这个浮动元素之后还跟着一个浮动元素,那么就会导致错位问题。 解决方案：overflow：hidden; IE6 克隆文本的 bug描述：若你的代码结构如下 123456789&lt;!--这是注释--&gt; &lt;div&gt; …… &lt;/div&gt;&lt;!--这是注释--&gt; 很有可能在 IE6 网页上出现一段空白文本 解决方案： 使用条件注释 删除所有注释 在注释前面的那个浮动元素加上 display：inline； IE 的图片缩放描述：图片在 IE 下缩放有时会影响其质量 解决方案：img{ -mg-interpolation-mode:bicubic;} IE6 下 png 图片的透明 bug描述：使用透明图片,使用 png24 或 png32 图片在 IE6 下面显示图片会有一层淡蓝色的背景。 解决方案： 123456789101112131415.img&#123;background:url('http://shenmo.wanmei.com/images/logo/sm_logo_202x104.png');_background:0;_filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='http://shenmo.wanmei.com/images/logo/sm_logo_202x104.png',sizingMethod='scale');&#125;img&#123;filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='http://shenmo.wanmei.com/images/logo/sm_logo_202x104.png',sizingMethod='scale');&#125;或&lt;imgsrc=\"test.png\" width=\"247\" height=\"216\"style=\"filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='http://shenmo.wanmei.com/images/logo/sm_logo_202x104.png',sizingMethod='scale');\" alt=\"\" /&gt; &lt;iframe&gt;透明背景 bug描述：在 IE 浏览器中，框架不会自动把背景设为透明 解决方案： &lt;iframesrc=”content.html”allowTransparency=”true”&gt; 在 iframe 调用的 content.html 页面中设置 body{background-color: transparent;} 禁用 IE 默认的垂直滚动条解决方案： html{ overflow:auto; } IE6 默认的 div 高度问题：ie6 默认 div 高度为一个字体显示的高度，所在 ie6 下 div 的高度大于等于一个字的高度，因此在 ie6 下定义高度为 1px 的容器，显示的是一个字体的高度解决：为这个容器设置下列属性之一1、设置 overflow:hidden;2、设置 line-height:1px;3、设置 zoom:0.08 IE6 最小高度(宽度)的问题问题：ie6 不支持 min-height、min-width 属性，默认 height 是最小高度，width 是最小宽度。解决：使用 ie6 不支持但其余浏览器支持的属性!important。设置属性 min-height:200px; height:auto !important; height:200px; td 高度的问题问题：table 中 td 的宽度都不包含 border 的宽度，但是 oprea 和 ff 中 td 的高度包含了 border 的高度解决：设置 line-height 和 height 一样。在 ie 中如果 td 中的没有内容，那么 border 将不会显示 div 嵌套 p 时，出现空白行问题：div 中显示文本，ff、oprea、Chrome：top 和 bottom 都会出现空白行，但是在 ie 下不会出现空白行。解决：设置 p 的 margin:0px，再设置 div 的 padding-top 和 padding-bottom IE6-7 图片下面有空隙的问题问题：块元素中含有图片时，ie6-7 中会出现图片下有空隙解决：1、在源代码中让和在同一行2、将图片转换为块级对象 display:block;3、设置图片的垂直对齐方式 vertical-align:top/middle/bottom4、改变父对象的属性，如果父对象的宽、高固定，图片大小随父对象而定，那么可以对父元素设置： overflow:hidden;5、设置图片的浮动属性 float:left; IE6 双倍边距的问题问题： ie6 中设置浮动，同时又设置 margin 时，会出现双倍边距的问题 例 float:left;width:100px;margin:0 100px; 解决： 设置 display:inline;IE6 width 为奇数，右边多出 1px 的问题问题： 父级元素采用相对定位，且宽度设置为奇数时，子元素采用绝对定位，在 ie6 中会出现右侧多出 1 像素 解决： 将宽度的奇数值改成偶数IE6 两个层之间 3px 的问题问题： 左边层采用浮动，右边没有采用浮动，这时在 ie6 中两层之间就会产生 3 像素的间距 解决： 1、右边层也采用浮动 float 2、左边层添加属性 margin-right:-3px;IE6 子元素绝对定位的问题问题： 父级元素使用 padding 后，子元素使用绝对定位，不能精确定位 解决： 在子元素中设置 \\_left:-20px; \\_top:-1px;显示手型 cursor:hand问题： ie6/7/8、opera 都支持 但是 safari 、 ff 不支持 解决： 写成 cursor:pointer; (所有浏览器都能识别)IE6-7 line-height 失效的问题问题： 在 ie 中 img 与文字放一起时， line-height 不起作用 解决： 都设置成 floattd 自动换行的问题问题： Table 宽度固定，td 自动换行 解决： 设置 Table 的 table-layout:fixed，td 的 word-wrap:break-word子容器浮动后，父容器扩展问题问题： 子容器都 float 以后，父容器没有设定高度,父容器将不会扩展 解决： 只需要添加一个 clear:both 的 div，代码如下：12345&lt;div style=\"border:1px solid#333;width:204px\"&gt; &lt;divstyle=\"width:100px;border:1px solid #333; float:left; \"&gt;子容器a&lt;/div&gt; &lt;divstyle=\"width:100px;border:1px solid #333; float:left;\"&gt;子容器b&lt;/div&gt; &lt;divstyle=\"clear:both\"&gt;&lt;/div&gt;&lt;/div&gt; 透明 png 图片会带背景色问题： 在 ie6 下透明的 png 图片会带一个背景色 解决： background-image: url(icon_home.png); background-repeat: no-repeat; \\_filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src=&apos;icon_home.png&apos;); \\_background-image: none;list-style-position 默认值的问题问题： ie 下 list-style-position 默认为 inside, firefox 默认为 outside 解决： css 中指定为 outside 即可解决兼容性问题list-style-image 准确定位的问题问题： li 前设置图片时，图片与其后的文字对齐问题 解决： 1、采用背景定位 和 字符缩进的方法 background:url() no-repeat left center;text-index:16px; 2、采用相对定位方法 li 设置 list-style:url(); li 的子元素 position:relative;top:-5px;ul 标签默认值的问题问题： ul 标签在 ff 中默认是有 padding 值的,而在 ie 中只有 margin 有值 解决： 定义 ul{margin:0;padding:0;}就能解决大部分问题IE 中 li 指定高度后，出现排版错误问题： 在 ie 下如果为 li 指定高度可能会出现排版错位 解决： 设置 line-heightul 或 li 浮动后，显示在 div 外问题： div 中的 ul 或 li 设置 float 以后，都不在 div 中 解决： 必须在 ul 标签后加&lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;来闭合外层 divul 浮动后，margin 变大问题： ul 设置 float 后，在 ie 中 margin 将变大 解决： 设置 ul 的 display:inline，li 的 list-style-position:outsideli 浮动后，margin 变大问题： li 设置 float 后，在 ie 中 margin 将变大 解决： 设置 li 的 display:inline嵌套使用 ul、li 的问题问题： ie 的 bug，嵌套使用 ul、li 时，里层的 li 设置 float 以后，外层 li 不设置 float, 里面的 ul 顶部和它外面的 li 总是有一段间距 解决： 设置里面的 ul 的 zoom:1IE6-7 li 底部有 3px 的问题问题： 这个 bug 产生的充要条件是 li 的子元素浮动并且 li 设置了以下 CSS 属性之一：width、height、zoom、padding-top、padding-bottom、margin-top、margin-bottom。 解决： 1、div 设置 clear:left|both，这时 li 不能设置 width、height、zoom。 2、li 设置 float:left，这时 li 可以设置 width、height、zoom。 3、li 设置 clear:left|both，这时 li 不能设置 width、height、zoom。 4、IE6/IE7 的这个 Bug 可以通过给 li 中的 div 设置 vertical-align:top|middle|bottom 解决。IE6 垂直列表间隙的问题问题： li 中有 a 且设置 display:block 时，ie6 中列表间会出现空隙 解决： 1、li 中加 display:inline; 2、li 使用 float 然后 clear:both; 3、给包含的文本末尾添加一个空格 4、设置 widthIE6 列表背景颜色失效的问题问题： 当父元素设置 position:relative;时，在 ie6 中第一个 ul、ol、dl 的背景颜色失效 解决： ul、ol、dl 都设置为 position:relative;IE6-7 列表背景颜色失效的问题问题： 做横向导航栏时，ul 设置为 float 且有背景色，li 设置为 float。ie6-7 背景颜色失效 解决： 很多 ie 的 bug 都可以通过触发 layout 来解决 ul 添加属性 1、height:1%; 2、float:left; 3、zoom:1;列表不能换行的问题问题： li 设置为浮动，后面的 li 紧随其后，不能换行 解决： 1、为这个 ul 定义合适的宽高 2、给包含这个 ul 的父 div 定义合适的宽高。li 中的内容以省略号显示问题： li 中内容超过长度时，想以省略号显示， 此方法适用于 ie6-7-8、opera、safari 浏览器 ff 浏览器不支持 解决： li{width:200px;white-space:nowrap;text-overflow:ellipsis; -o-text-overflow:ellipsis; overflow:hidden; }超链接访问过后 hover 样式不出现的问题问题： 点击超链接后，hover、active 样式没有效果 解决： 改变 CSS 属性的排列顺序: L-V-H-A禁用中文输入法的问题问题： 不能在输入框中输入汉字 解决： 只在 ie 系列和 ff 中有效 ime-mode:disabled (但可以粘贴) 禁用粘贴： onpaste=&quot;return false&quot;让层显示在 FLASH 之上问题： 想让层的内容显示在 flash 上 解决： 把 FLASH 设置透明 1、&lt;param name=&quot; wmode &quot; value=&quot;transparent&quot; /&gt; 2、&lt;param name=&quot;wmode&quot; value=&quot;opaque&quot;/&gt;去除链接虚线边框的问题问题： 当点击超链接后，ie6/7/8 ff 会出现虚线边框 ,而 opera、safari 没有虚线边框 解决： ie6/7 中 设置为 a {blr:expression_r(this.onFocus=this.blur()) } ie8 和 ff 都不支持 expression 在 ie8 、ff 中设置为 :focus { outline: none; }css 滤镜的问题问题： css 滤镜只在 ie 中有效，Firefox, Safari(WebKit), Opera 只能够设置透明，它们不支持滤镜 filter，无法实现图片切换中间变换的效果，只能通过透明度来设置。 解决： ff 中设置透明度 -moz-opacity:0.10; opacity:0.6; ie 中只设置 filter:alpha(opacity=50);时，ie6-7 失效，还要设置 1、zoom:1; 2、width:100%;IE6 背景闪烁的问题问题： 链接、按钮用 CSS sprites 作为背景，在 ie6 下会有背景图闪烁的现象。原因是:IE6 没有将背景图缓存，每次触发 hover 的时候都会重新加载 解决： 可以用 JavaScript 设置 ie6 缓存这些图片： document.execCommand(&quot;BackgroundImageCache&quot;,false,true);出现重复文字的问题问题： &lt;div style=&quot;width:400px&quot;&gt; &lt;div style=&quot;float:left&quot;&gt;&lt;/div&gt; &lt;!– _ –&gt; &lt;div style=&quot;float:right;width:400px&quot;&gt;↓这就是多出来的那只猪&lt;/div&gt; &lt;/div&gt; 解决： 1、 改变结构，不出现【一个容器包含2两个具有“float”样式的子容器】的结构。 2、减小第二个容器的宽度，使父容器宽度减去第二个容器宽度的值大于3 3、去掉所有的注释。 4、修正注释的写法。&lt;!--[if!IE]&gt;这里是注释内容&lt;![endif]--&gt; 5、在第二个容器后面加一个或者多个&lt;divstyle=&quot;clear&quot;&gt;&lt;/div&gt;来解决。ff、chrome 绝对定位无效问题： 在 IE 给 td 设置 position:relative，然后给它包含的一个容器使用 position:absolute 进行定位是有效的，但在 FF 和 Chrome 下却不可以。 解决： 设置 td 的 display:block。IE6 绝对定位的问题问题： &lt;div style=&quot;position:relative;border:1px solid orange;text-align:center;&quot;&gt; &lt;div style=&quot;position:absolute;top:0;left:0; background:#CCC;&quot;&gt;dovapour&lt;/div&gt; &lt;a href=&quot;#&quot; title=&quot;vapour的blog&quot;&gt;内容&lt;/a&gt; &lt;/div&gt; 解决： left的定位错误问题 1、给父层设置zoom:1触发layout。 2、给父层设置宽度widthbottom 的定位错误问题1、给父层设置 zoom:1 触发 layout。2、给父层设置高度 height float 的 div 闭合的问题问题： 例如：&lt;div id=”floatA” &gt;&lt;div id=”floatB” &gt;&lt;div id=”NOTfloatC” &gt;这里的 NOTfloatC 并不希望继续平移，而是希望往下排。(其中 floatA、floatB 的属性已经设置为 float:left;) 这段代码在 IE 中毫无问题，问题出在其他浏览器中。原因是 NOTfloatC 并非 float 标签，必须将 float 标签闭合。 解决： 在 &lt;#div class=”floatB”&gt; &lt;#div class=”NOTfloatC”&gt;之间加上 &lt;#div class=”clear”&gt;这个 div 一定要注意位置，而且必须与两个具有 float 属性的 div 同级，之间不能存在嵌套关系，否则会产生异常。并且将 clear 这种样式定义为为如下即可：.clear{ clear:both;}单选框、复选框与后面的文字对不齐问题： 单选框、复选框与后面的文字对不齐。 解决： .align{font-size:12px;} .align input{ display:block; float:left;} .align label{ display:block; float:left;padding-top:3px; \\*padding-top:5px;}需注意的问题： 设置 padding 后高度和宽带都会增加说明：除了 ie5.5，其他所有浏览器中，设置 padding 以后高度和宽带都会增加 使用 XHTML 1.0Transitional 后，div 宽度说明：在使用 XHTML 1.0Transitional 以后 div 宽度都不包含 border 的宽度了，设置宽度的时候需要注意下。 外层相对定位，内层绝对定位说明：ie6 下，外层 div 的 postion:relative，并设置 text-align，内层 div 的 postion: absolute，这时内层的位置是相对于 text-align 而言的例如： 123456&lt;div style=\"position:relative;border:1px solid orange;text-align:center;zoom:1\"&gt; position:relative &lt;div style=\"position:absolute;top:0;left:0;background:#CCC;\"&gt; position:absolute &lt;/div&gt;&lt;/div&gt; &amp;nbsp; 显示的大小不一致默认字本显示问题，导致&nbsp;显示的大小不一致，在 ie 下比较小一点，其他的浏览器都一致，当你使用了&nbsp;造成问题时请注意。 边框重叠说明说明：为 table、td 都指定了边框后，然后使用 border-collapse:collapse 让边框重叠，可以看出在发生重叠时，Firefox 是用 td 覆盖 table 的，而 IE 是用 table 覆盖 td 的。使用时候需要注意。 设置 td padding 的说明说明：设置 td 的 padding 以后高度和宽带都会增加,padding-left 和 padding-right 的效果都一样增加了 td 的宽带，但是 padding-top 和 padding-bottom 的效果不一样。最好不要使用 td 的 padding-top 和 padding-bottom ul 设置的说明说明：ul 一般设置：list-style-type:none;margin:0px;padding:0px；li 一般设置：list-style-type:none;list-style-position:outside 使一个层垂直居中于浏览器中说明：使用百分比绝对定位,与外补丁负值的技巧,负值的大小为其自身宽度高度除以二div {position:absolute; top:50%; lef:50%; margin:-100px 0 0 -100px;width:200px; height:200px; border:1px solidred;} 触发 layout说明：IE6 中很多 Bug 都可以通过触发 layout 得到解决.下列的 CSS 属性或取值会让一个元素获得 layout：position:absolute 绝对定位元素的包含区块(containingblock)就会经常在这一方面出问题float:left|right 由于 layout 元素的特性，浮动模型会有很多怪异的表现display:inline-block 当一个内联级别的元素需要 layout 的时候就往往符用到它，这也可能也是这个 CSS 属性的唯一效果—-让某个元素有 layoutwidth: 除 auto 外的任何值height: 除 auto 外的任何值zoom: 除 auto 外的任何值 如何使连续长字段自动换行ff 最新版本 word-wrap:break-word;就可以了ff 旧版本 还要使用 javascript 完成文字换行 123456789101112131415161718192021&lt;style type=&quot;text/css&quot;&gt;div &#123; width:300px; word-wrap:break-word; border:1px solid red; &#125;&lt;/style&gt;&lt;scripttype=&quot;text/javascript&quot;&gt;function toBreakWord(intLen)&#123;varobj=document.getElementByIdx_x(&quot;ff&quot;);var strContent=obj.innerHTML;var strTemp=&quot;&quot;;while(strContent.length&gt;intLen)&#123;strTemp+=strContent.substr(0,intLen)+&quot;&amp;#10;&quot;;strContent=strContent.substr(intLen,strContent.length);&#125;strTemp+=&quot;&amp;#10;&quot;+strContent;obj.innerHTML=strTemp;&#125;if(document.getElementByIdx_x &amp;&amp; !document.all) toBreakWord(37) 设置滚动条颜色 只对 ie 系列有效 在 html 中 而不是设置 body1234567891011&lt;style type=&quot;text/css&quot;&gt;html &#123; scrollbar-face-color:#f6f6f6; scrollbar-highlight-color:#fff; scrollbar-shadow-color:#eeeeee; scrollbar-3dlight-color:#eeeeee; scrollbar-arrow-color:#000; scrollbar-track-color:#fff; scrollbar-darkshadow-color:#fff; &#125;&lt;/style&gt; IE 不支持 float：inherit overflow:hidden 有 2 个用法，一个是隐藏溢出，另一个是清除浮动。 1234&lt;div&gt;, &lt;p&gt;, &lt;h1&gt;,&lt;form&gt;, &lt;ul&gt; 和 &lt;li&gt;是块元素的例子&lt;span&gt;, &lt;a&gt;, &lt;label&gt;,&lt;input&gt;, &lt;img&gt;, &lt;strong&gt; 和&lt;em&gt;是inline元素&lt;body oncontextmenu=&quot;returnfalse&quot; ondragstart=&quot;return false&quot; tstart=&quot;returnfalse&quot; scroll=&quot;auto&quot;&gt;这行代码放在body中，去掉了页面鼠标右键快捷菜单，达到防止图片另存为的目的。 document.form.item 问题问题：代码中存在 document.formName.item(“itemName”) 这样的语句，不能在 FF 下运行解决方法：改用 document.formName.elements[“elementName”] 集合类对象问题问题：代码中许多集合类对象取用时使用()，IE 能接受，FF 不能解决方法：改用 [] 作为下标运算，例：document.getElementsByName(“inputName”)(1) 改为 document.getElementsByName(“inputName”)[1] window.event问题：使用 window.event 无法在 FF 上运行解决方法：FF 的 event 只能在事件发生的现场使用，此问题暂无法解决。可以把 event 传到函数里变通解决： 12345onMouseMove = &quot;functionName(event)&quot;function functionName (e) &#123; e = e || window.event; ......&#125; HTML 对象的 id 作为对象名的问题在 IE 中，HTML 对象的 ID 可以作为 document 的下属对象变量名直接使用，在 FF 中不能解决方法：使用对象变量时全部用标准的 getElementById(“idName”) 用 idName 字符串取得对象的问题问题：在 IE 中，利用 eval_r(“idName”) 可以取得 id 为 idName 的 HTML 对象，在 FF 中不能解决方法：用 getElementById(“idName”) 代替 eval_r(“idName”) 变量名与某 HTML 对象 id 相同的问题问题：在 FF 中，因为对象 id 不作为 HTML 对象的名称，所以可以使用与 HTML 对象 id 相同的变量名，IE 中不能解决方法：在声明变量时，一律加上 var ，以避免歧义，这样在 IE 中亦可正常运行最好不要取与 HTML 对象 id 相同的变量名，以减少错误 event.x 与 event.y 问题问题：在 IE 中，event 对象有 x,y 属性，FF 中没有解决方法：在 FF 中，与 event.x 等效的是 event.pageX ，但 event.pageX IE 中没有故采用 event.clientX 代替 event.x ，在 IE 中也有这个变量event.clientX 与 event.pageX 有微妙的差别，就是滚动条要完全一样，可以这样：mX = event.x ? event.x : event.pageX;然后用 mX 代替 event.x 关于 frame问题：在 IE 中可以用 window.testFrame 取得该 frame，FF 中不行解决方法：window.top.document.getElementByIdx_x(“testFrame”).src = ‘xx.htm’window.top.frameName.location = ‘xx.htm’ 取得元素的属性在 FF 中，自己定义的属性必须 getAttribute() 取得 在 FF 中没有 parentElement，parement.children 而用 parentNode，parentNode.childNodes问题： childNodes 的下标的含义在 IE 和 FF 中不同，FF 的 childNodes 中会插入空白文本节点 解决方法： 可以通过 node.getElementsByTagName_r() 来回避这个问题 问题： 当 html 中节点缺失时，IE 和 FF 对 parentNode 的解释不同，例如： &lt;form&gt; &lt;table&gt; &lt;input/&gt; &lt;/table&gt; &lt;/form&gt; FF中 input.parentNode 的值为form，而IE中 input.parentNode 的值为空节点 问题： FF中节点自己没有 removeNode 方法 解决方法： 必须使用如下方法 node.parentNode.removeChild(node)body 对象FF 的 body 在 body 标签没有被浏览器完全读入之前就存在，而 IE 则必须在 body 完全被读入之后才存在 这会产生在 IE 下，文档没有载入完时，在 body 上 appendChild 会出现空白页面的问题 解决方法： 一切在 body 上插入节点的动作，全部在 onload 后进行url encoding问题： 一般 FF 无法识别 js 中的&amp; 解决方法： 在 js 中如果书写 url 就直接写&amp;不要写&amp;nodeName 和 tagName 问题问题： 在 FF 中，所有节点均有 nodeName 值，但 textNode 没有 tagName 值，在 IE 中，nodeName 的使用有问题 解决方法： 使用 tagName，但应检测其是否为空元素属性IE 下 input.type 属性为只读，但是 FF 下可以修改document.getElementsByName() 和 document.all[name] 的问题问题： 在 IE 中，getElementsByName()、document.all[name] 均不能用来取得 div 元素 是否还有其它不能取的元素还不知道（这个问题还有争议，还在研究中）调用子框架或者其它框架中的元素的问题在 IE 中，可以用如下方法来取得子元素中的值 document.getElementByIdx_x(&quot;frameName&quot;).(document.)elementName window.frames[&quot;frameName&quot;].elementName 在 FF 中则需要改成如下形式来执行，与 IE 兼容： window.frames[&quot;frameName&quot;].contentWindow.document.elementName window.frames[&quot;frameName&quot;].document.elementName对象宽高赋值问题问题： FireFox 中类似 obj.style.height = imgObj.height 的语句无效 解决方法： 统一使用 obj.style.height = imgObj.height + &quot;px&quot;;innerText 的问题问题： innerText 在 IE 中能正常工作，但是 innerText 在 FireFox 中却不行 解决方法： 在非 IE 浏览器中使用 textContent 代替 innerTextevent.srcElement 和 event.toElement 问题问题： IE 下，even 对象有 srcElement 属性，但是没有 target 属性；Firefox 下，even 对象有 target 属性，但是没有 srcElement 属性 解决方法： var source = e.target || e.srcElement; var target = e.relatedTarget || e.toElement;禁止选取网页内容问题： FF 需要用 CSS 禁止，IE 用 JS 禁止 解决方法： IE: obj.onselectstart = function() {return false;} FF: -moz-user-select:none;捕获事件12345678910111213141516171819问题：FF 没有 setCapture()、releaseCapture()方法解决方法：IE:obj.setCapture();obj.releaseCapture();FF:window.captureEvents(Event.MOUSEMOVE|Event.MOUSEUP);window.releaseEvents(Event.MOUSEMOVE|Event.MOUSEUP);if (!window.captureEvents) &#123; o.setCapture();&#125;else &#123; window.captureEvents(Event.MOUSEMOVE|Event.MOUSEUP);&#125;if (!window.captureEvents) &#123; o.releaseCapture();&#125;else &#123; window.releaseEvents(Event.MOUSEMOVE|Event.MOUSEUP);&#125; 常见浏览器bug及处理双边距IE6下,一个div盒子如果设置了margin和浮动，便会产生双边距问题。解决方案：给该div设置样式_display:inline。 overflow:hidden失效IE6，7下，当父元素的子元素的样式拥有position:relative时，父元素的overflow:hidden属性就会失效。 解决方案：父元素也设置position:relative 滚动条bugIE6，7下，当固定了一个元素的宽高，纵向溢出（overflow-y）为滚动（scroll）或者自动（auto）时，当其子元素有position:relative时，子元素不会随滚动条滚动解决方案: 给该元素也设置position:relative 浏览器未重绘导致的问题解决方式,用js,让其隐藏再显示 1$elem.hide().show(); li底部3px的BugIE6，7下，当li的子元素浮动（float），并且li设置了以下CSS属性之一：width、height、zoom、padding-top、padding-bottom、margin-top、margin-bottom，li会产生3px空隙。解决方案:给li的浮动的子元素上设置vertical-align:top|middle|bottom IE6注释bugIE6下，满足以下条件 一个容器包含2两个具有“float”样式的子容器。 容器的宽度大于父容器的宽度，或者父容器宽度减去第二个容器宽度的值小于3 在第二个容器前存在注释 会出现重复的字符内容解决方案： 破坏其中一个触发条件。最简单方式：删除注释。 body上设置overflow-y:hidden的问题在ie6，7中，设置在body元素上overflow-y:hidden不能隐藏滚动条。解决方案：在html元素上也设置overflow-y:hidden Firefox下input button内文字不垂直居中解决方案： 123456input[type=&quot;reset&quot;]::-moz-focus-inner,input[type=&quot;button&quot;]::-moz-focus-inner,input[type=&quot;submit&quot;]::-moz-focus-inner,input[type=&quot;file&quot;] &gt; input[type=&quot;button&quot;]::-moz-focus-inner&#123;border:none;padding:0;&#125;","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"浏览器兼容","slug":"浏览器兼容","permalink":"https://qw8.github.io/tags/浏览器兼容/"},{"name":"移动端兼容","slug":"移动端兼容","permalink":"https://qw8.github.io/tags/移动端兼容/"}]},{"title":"浏览器","slug":"knowledges/浏览器","date":"2021-03-12T02:10:10.000Z","updated":"2024-03-31T12:11:10.000Z","comments":true,"path":"/knowledges/liu-lan-qi.html","link":"","permalink":"https://qw8.github.io/knowledges/liu-lan-qi.html","excerpt":"","text":"浏览器端的存储技术有哪些？cookiecookie又叫会话跟踪技术（会员卡的意思）由web服务器保存在用户浏览器上的小文本文件，包含用户的相关信息。cookie 其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。 我的理解是 cookie 是服务器提供的一种用于维护会话状态信息的数据，通过服务器发送到浏览器，浏览器保存在本地，当下一次有同源的请求时，将保存的 cookie 值添加到请求头部，发送给服务端。这可以用来实现记录用户登录状态等功能。cookie 一般可以存储 4k 大小的数据，并且只能够被同源的网页所共享访问。 服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了9个属性值 name、value、expires、domain、path、secure、HttpOnly、SameSite、Priority。其中 name 和 value 分别是 cookie 的名字和值。expires 指定了 cookie 失效的时间，domain 是域名、path是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。SameSite 属性用来限制第三方 cookie，可以有效防止 CSRF 攻击，从而减少安全风险。Priority 是 chrome 的提案，定义了三种优先级，当 cookie 数量超出时低优先级的 cookie 会被优先清除。 在发生 xhr 的跨域请求的时候，即使是同源下的 cookie，也不会被自动添加到请求头部，除非显示地规定。 cookie是存放在浏览器中的，在每一个浏览器安装目录下，都存在一个文件夹，存放着不同域下对应的cookie。当浏览器通过http请求某一个域时，此时浏览器就会将该域下面的cookie自动放入request header中。我们需要注意，浏览器自动帮我们携带，此时如果很多无关紧要的数据都存放在cookie中，都会随着请求发送给后台，这样就无形当中增加了网络开销。此时我们再想想什么数据在每一次都需要?其实我们的身份认证信息在每一次都需要携带，所以存放在cookie的数据最合适的是身份认证信息，其他信息都不合适。 详细资料可以参考：《HTTP cookies》 《聊一聊 cookie》 特点： 禁用cookie后，用户无法正常注册登录 cookie与浏览器相关，不同浏览器之间保存的cookie是不能互相访问的；cookie还需要指定作用域，不可以跨域调用。 cookie的安全性不高，易受xss攻击 cookie值的类型先定位string类型，cookie大小一般只有4kb，可以进行单独配置 持久保存客户端数据提供了方便，分担了服务器存储的负担，极高的扩展性和可用性 Cookie 的弊端 Cookie数量和长度的限制。每个 domain 特定的域名下最多只能有 20 条 cookie，每个 cookie 长度不能超过 4KB，否则会被截掉。 安全性问题。如果 cookie 被人拦截了，那人就可以取得所有的 session 信息。即使加密也与事无补，因为拦截者并不需要知道 cookie 的意义，他只要原样转发 cookie 就可以达到目的了。 有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。 在请求头上带着数据，导致流量增加。 改进办法 通过良好的编程，控制保存在cookie中的session对象的大小。 通过加密和安全传输技术（SSL），减少cookie被破解的可能性。 只在cookie中存放不敏感数据，即使被盗也不会有重大损失。 控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。 cookie的作用 保存用户登录状态。例如将用户id存储于一个cookie内，这样当用户下次访问该页面时就不需要重新登录了，现在很多论坛和社区都提供这样的功能。cookie还可以设置过期时间，当超过时间期限后，cookie就会自动消失。因此，系统往往可以提示用户保持登录状态的时间：常见选项有一个月、三个 月、一年等。 跟踪用户行为。例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了 cookie后就会显得很人性化了，系统能够记住上一次访问的地区，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。因为一切都是在后台完成，所以这样的页面就像为某个用户所定制的一样，使用起来非常方便。 定制页面。如果网站提供了换肤或更换布局的功能，那么可以使用cookie来记录用户的选项，例如：背景色、分辨率等。当用户下次访问时，仍然可以保存上一次访问的界面风格。 存储位置浏览器控制面板(f12) - Application选项里面 - 左侧cookie 通过控制面板删除选中的或者全部的cookie 操作方式1234// 设置 cookiedocument.cookie = \"username=John Doe; expires=Thu, 18 Dec 2013 12:00:00 GMT;path=/\" // 删除 cookiedocument.cookie = \"username=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" 设置 cookie 的方法比较简单，其中除了键和值，还有几个参数可以添加 expires过期时间，当过了到期日期时，浏览器会自动删除该 cookie，如果想删除一个 cookie，只需要把它过期时间设置成过去的时间即可比如希望设置过期时间一年：new Date().getTime() + 365 _ 24 _ 60 _ 60 _ 1000 如果不设置过期时间，则表示这个 cookie 生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie 就消失了。 path路径，值可以是一个目录，或者是一个路径。 如果 cc.com/test/index.html 建立了一个 cookie，那么在 cc.com/test/目录里的所有页面，以及该目录下面任何子目录里的页面都可以访问这个 cookie。因此在 cc.com/test/test2/test3 里的任何页面都可以访问 cc.com/test/index.html 建立的 cookie。若 cc.com/test/ 若想访问 cc.com/test/index.html 设置的 cookes，需要把 cookies 的 path 属性设置成“/”。在指定路径的时候，凡是来自同一服务器，URL 里有相同路径的所有 WEB 页面都可以共享 cookies。 domain主机名，是指同一个域下的不同主机，例如：www.baidu.com 和 map.baidu.com 就是两个不同的主机名。默认情况下，一个主机中创建的 cookie 在另一个主机下是不能被访问的，但可以通过 domain 参数来实现对其的控制：document.cookie = “name=value;domain=.baidu.com”，这样，所有*.baidu.com 的主机都可以访问该 cookie。 什么是Cookie 隔离？（或者说：请求资源的时候不要带cookie怎么做） 通过使用多个非主要域名来请求静态文件，如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，所以不如隔离开，静态资源放CDN。 因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。 同时这种方式不会将cookie传入Web Server，也减少了Web Server对cookie的处理分析环节，提高了webserver的http请求的解析速度。 Cookie如何防范XSS攻击XSS（跨站脚本攻击）是指攻击者在返回的HTML中嵌入javascript脚本，为了减轻这些攻击，需要在HTTP头部配上，set-cookie： httponly-这个属性可以防止XSS,它会禁止javascript脚本来访问cookie。 secure - 这个属性告诉浏览器仅在请求为https的时候发送cookie。 结果应该是这样的：Set-Cookie=….. 在 HTTP 响应 Header 中，set-cookie 选项有哪些，分别代表什么含义？Set-Cookie: = Expires=&lt;date&gt; Max-Age=&lt;non-zero-digit&gt; Domain=&lt;domain-value&gt; Path=&lt;path-value&gt; Secure HttpOnly SameSite=Strict SameSite=Lax 123456789name = name; // 需要设置cookie的值(name不能使用\";\"和\",\"号),有多个name值时用\";\"分隔例如：name1=name1;name2=name2;name3=name3expires; //cookie的有效期限,格式为:expires=\"Wdy,DD-Mon-YYYY HH:MM:SS\"path; //设置cookie支持的路径,如果path是一个路径，则cookie对这个目录下的所有文件及子目录生效，例如：path=\"/cgi-bin/\"，如果path是一个文件，则cookie指对这个文件生效，例如：path=\"/cgi-bin/cookie.cgi\"domain; //对cookie生效的域名，例如：domain=\"gzdzw.51.net\"secure; //如果给出此标志，表示cookie只能通过SSL协议的https服务器来传递,cookie的接收是通过设置环境变量HTTP_COOKIE来实现的，CGI程序可以通过检索该变量获取cookie信息 解析：Cookie 相关的 Http 头 有两个 Http 头部和 Cookie 有关：Set-Cookie 和 Cookie Set-Cookie 由服务器发送，它包含在响应请求的头部中。它用于在客户端创建一个 Cookie Cookie 头由客户端发送，包含在 HTTP 请求的头部中。注意，只有 cookie 的 domain 和 path 与请求的 URL 匹配才会发送这个 cookie。 localStoragelocalStorage是以键值对(Key-Value)的方式持久化的本地存储，永久存储，永不失效，除非手动删除。IE8+支持，每个域名限制 5M 打开同域的新页面也能访问得到 操作方式： window.localStorage.username = ‘hehe’ // 设置window.localStorage.setItem(‘username’, ‘hehe’) // 设置window.localStorage.getItem(‘username’) // 读取window.localStorage.removeItem(‘username’) // 删除window.localStorage.key(1) // 读取索引为 1 的值window.localStorage.clear() // 清除所有可以存储数组、数字、对象等可以被序列化为字符串的内容 sessionStoragesessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。 sessionStorage 是 html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且sessionStorage 只能被同一个窗口的同源页面所访问共享。 sessionStorage 操作的方法与 localStroage 是一样的，区别在于 sessionStorage 在关闭页面后即被清空，而 localStorage 则会一直保存。很多时候数据只需要在用户浏览一组页面期间使用，关闭窗口后数据就可以丢弃了，这种情况使用 sessionStorage 就比较方便。 注意，刷新页面 sessionStorage 不会清除，但是打开同域新页面访问不到 描述 cookies、sessionStorage 和 localStorage 的区别？他们都是保存在浏览器端的存储方式。 与服务器交互： cookie 是网站为了标示用户身份而储存在用户本地终端上的数据（通常经过加密），服务器和客户端都可以访问。 cookie 始终会在同源 http 请求头中携带（即使不需要），在浏览器和服务器间来回传递。 因为每次 http 请求都会携带 cookie，所以 cookie 只适合保存很小的数据，如会话标识。 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在客户端（即浏览器）中保存 有效时间： localStorage 保存在本浏览器数据缓存区，用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 sessionStorage 用于本地存储一个session中的数据，这些数据保存在当前会话窗口，数据在当前浏览器窗口关闭（页面会话结束）后自动删除。 重新加载或恢复页面仍会保持原来的页面会话，在新标签或窗口打开一个页面时会在顶级浏览上下文中初始化一个新的会话。 Storage共同点：都是保存在浏览器端、仅同源可用的存储方式 cookie 设置的cookie过期时间之前一直有效，与浏览器是否关闭无关 存储大小： cookie 数据根据不同浏览器限制，大小一般不能超过 4k sessionStorage 和 localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 存储格式： cookie只能以字符串格式保存； webStorage以key-value格式保存，更便于存取（sessionStorage.setItem(“key”,”value”)，sessionStorage.getItem(“key”)）； 作用域不同： sessionStorage 只在同源的同窗口（或标签页）中共享数据，也就是只在当前会话中共享。 不在不同的浏览器页面中共享，即使是同一个页面（比如同一页面打开为两个标签页） localStorage 在所有同源窗口中都是共享的； cookie 也是在所有同源窗口中都是共享的。 在浏览器多个 tab 页中，cookie、localStorage 可以共享数据，sessionStorage 仅保存在当前 tab 页中不能共享。 操作方法： Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。 上面几种方式都是存储少量数据的时候的存储方式，当我们需要在本地存储大量数据的时候，我们可以使用浏览器的 indexDB 这是浏览器提供的一种本地的数据库存储机制。它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近 NoSQL 数据库。 《浏览器数据库 IndexedDB 入门教程》 cookie 和session 的区别： session： 是一个抽象概念，开发者为了实现中断和继续等操作，将 user agent和 server 之间一对一的交互，抽象为“会话”，进而衍生出“会话状态”，也就是 session 的概念 cookie：它是一个世纪存在的东西，http 协议中定义在 header 中的字段，可以认为是 session 的一种后端无状态实现 现在我们常说的 session，是为了绕开 cookie 的各种限制，通常借助 cookie本身和后端存储实现的，一种更高级的会话状态实现 session 的常见实现要借助cookie来发送 sessionID cookie数据存放在客户的浏览器上，session数据放在服务器上。 cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。 session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。 所以个人建议：将登陆信息等重要信息存放为SESSION其他信息如果需要保留，可以放在COOKIE中 web storage（包含sessionStorage和localStorage）和cookie的区别Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 而Web Storage仅仅是为了在本地“存储”数据而生。 cookie 数据还有路径（path）的概念，可以限制 cookie 只属于某个路径下。 Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。 Web Storage 的 api 接口使用更方便，cookie 的原生接口不友好，需要自己封装。 Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用 除此之外，WebStorage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie 但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生 浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等 如何实现浏览器内多个标签页之间的通信?调用 localstorge、cookies 等本地存储方式，注意sessionstorge不可以哦 安全性需要注意的是，不是什么数据都适合放在 Cookie、localStorage 和 sessionStorage 中的，因为它们保存在本地容易被篡改，使用它们的时候，需要时刻注意是否有代码存在 XSS 注入的风险。所以千万不要用它们存储你系统中的敏感数据。 事件机制我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。 请解释什么是事件代理事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。 顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。 原理是DOM元素的事件冒泡。 使用事件代理的好处是可以提高性能 怎么实现：在元素的父节点注册事件，通过事件冒泡，在父节点捕获事件 事件触发三阶段 document 往事件触发处传播，遇到注册的捕获事件会触发 传播到事件触发处时触发注册的事件 从事件触发处往 document 传播，遇到注册的冒泡事件会触发 事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行 1234567// 以下会先打印冒泡然后是捕获node.addEventListener(&apos;click&apos;,(event) =&gt;&#123; console.log(&apos;冒泡&apos;)&#125;,false);node.addEventListener(&apos;click&apos;,(event) =&gt;&#123; console.log(&apos;捕获 &apos;)&#125;,true) 注册事件 通常我们使用 addEventListener 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 useCapture 参数来说，该参数默认值为 false 。useCapture 决定了注册的事件是捕获事件还是冒泡事件 一般来说，我们只希望事件只触发在目标上，这时候可以使用 stopPropagation 来阻止事件的进一步传播。通常我们认为 stopPropagation 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。stopImmediatePropagation 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件 12345678node.addEventListener('click',(event) =&gt;&#123; event.stopImmediatePropagation() console.log('冒泡')&#125;,false);// 点击 node 只会执行上面的函数，该函数不会执行node.addEventListener('click',(event) =&gt; &#123; console.log('捕获 ')&#125;,true) 事件代理 如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上 12345678910111213&lt;ul id=\"ul\"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; let ul = document.querySelector('##ul') ul.addEventListener('click', (event) =&gt; &#123; console.log(event.target); &#125;)&lt;/script&gt; 事件代理的方式相对于直接给目标注册事件来说，有以下优点 节省内存 不需要给子节点注销事件 介绍DOM0，DOM2，DOM3事件处理方式区别 DOM0级事件处理方式： btn.onclick = func; btn.onclick = null; DOM2级事件处理方式： btn.addEventListener(&#39;click&#39;, func, false); btn.removeEventListener(&#39;click&#39;, func, false); btn.attachEvent(&quot;onclick&quot;, func); btn.detachEvent(&quot;onclick&quot;, func); DOM3级事件处理方式： eventUtil.addListener(input, &quot;textInput&quot;, func); eventUtil 是自定义对象，textInput 是DOM3级事件 事件的三个阶段捕获、目标、冒泡 介绍事件“捕获”和“冒泡”执行顺序和事件的执行次数？按照W3C标准的事件：首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段 事件执行次数（DOM2-addEventListener）：元素上绑定事件的个数 注意1：前提是事件被确实触发 注意2：事件绑定几次就算几个事件，即使类型和功能完全一样也不会“覆盖” 事件执行顺序：判断的关键是否目标元素 非目标元素：根据W3C的标准执行：捕获-&gt;目标元素-&gt;冒泡（不依据事件绑定顺序） 目标元素：依据事件绑定顺序：先绑定的事件先执行（不依据捕获冒泡标准） 最终顺序：父元素捕获-&gt;目标元素事件1-&gt;目标元素事件2-&gt;子元素捕获-&gt;子元素冒泡-&gt;父元素冒泡 注意：子元素事件执行前提 事件确实“落”到子元素布局区域上，而不是简单的具有嵌套关系 在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？ 该DOM上的事件如果被触发，会执行两次（执行次数等于绑定次数） 如果该DOM是目标元素，则按事件绑定顺序执行，不区分冒泡/捕获 如果该DOM是处于事件流中的非目标元素，则先执行捕获，后执行冒泡 事件的代理/委托事件委托是指将事件绑定目标元素的到父元素上，利用冒泡机制触发该事件 优点： 可以减少事件注册，节省大量内存占用 可以将事件应用于动态添加的子元素上 缺点：使用不当会造成事件在不应该触发时触发 示例： 123456ulEl.addEventListener(&apos;click&apos;, function(e)&#123; var target = event.target || event.srcElement; if(!!target &amp;&amp; target.nodeName.toUpperCase() === &quot;LI&quot;)&#123; console.log(target.innerHTML); &#125;&#125;, false); DOM事件的总结知识点主要包括以下几个方面： 基本概念：DOM事件的级别 面试不会直接问你，DOM有几个级别。但会在题目中体现：“请用DOM2 ….”。 DOM事件模型、DOM事件流 面试官如果问你“DOM事件模型”，你不一定知道怎么回事。其实说的就是捕获和冒泡。 DOM事件流，指的是事件传递的三个阶段。 描述DOM事件捕获的具体流程 讲的是事件的传递顺序。参数为false（默认）、参数为true，各自代表事件在什么阶段触发。 能回答出来的人，寥寥无几。也许有些人可以说出一大半，但是一字不落的人，极少。 Event对象的常见应用（Event的常用api方法） DOM事件的知识点，一方面包括事件的流程；另一方面就是：怎么去注册事件，也就是监听用户的交互行为。第三点：在响应时，Event对象是非常重要的。 自定义事件（非常重要） 一般人可以讲出事件和注册事件，但是如果让你讲自定义事件，能知道的人，就更少了。 DOM事件的级别 DOM事件的级别，准确来说，是DOM标准定义的级别。包括： DOM0的写法： 123element.onclick = function () &#123;&#125; 上面的代码是在 js 中的写法；如果要在html中写，写法是：在onclick属性中，加 js 语句。 DOM2的写法： 123element.addEventListener('click', function () &#123;&#125;, false); 【重要】上面的第三参数中，true表示事件在捕获阶段触发，false表示事件在冒泡阶段触发（默认）。如果不写，则默认为false。 DOM3的写法： 123element.addEventListener('keyup', function () &#123;&#125;, false); DOM3中，增加了很多事件类型，比如鼠标事件、键盘事件等。 PS：为何事件没有DOM1的写法呢？因为，DOM1标准制定的时候，没有涉及与事件相关的内容。 总结：关于“DOM事件的级别”，能回答出以上内容即可，不会出题目让你做。 DOM事件模型 DOM事件模型讲的就是捕获和冒泡，一般人都能回答出来。 捕获：从上往下。 冒泡：从下（目标元素）往上。 DOM事件流 DOM事件流讲的就是：浏览器在于当前页面做交互时，这个事件是怎么传递到页面上的。 完整的事件流，分三个阶段： 捕获：从 window 对象传到 目标元素。 目标阶段：事件通过捕获，到达目标元素，这个阶段就是目标阶段。 冒泡：从目标元素传到 Window 对象。 描述DOM事件捕获的具体流程 很少有人能说完整。 捕获的流程 说明：捕获阶段，事件依次传递的顺序是：window –&gt; document –&gt; html–&gt; body –&gt; 父元素、子元素、目标元素。 PS1：第一个接收到事件的对象是 window（有人会说body，有人会说html，这都是错误的）。 PS2：JS中涉及到DOM对象时，有两个对象最常用：window、doucument。它们俩也是最先获取到事件的。 代码如下： 1234567891011121314151617181920212223window.addEventListener(\"click\", function () &#123; alert(\"捕获 window\");&#125;, true);document.addEventListener(\"click\", function () &#123; alert(\"捕获 document\");&#125;, true);document.documentElement.addEventListener(\"click\", function () &#123; alert(\"捕获 html\");&#125;, true);document.body.addEventListener(\"click\", function () &#123; alert(\"捕获 body\");&#125;, true);fatherBox.addEventListener(\"click\", function () &#123; alert(\"捕获 father\");&#125;, true);childBox.addEventListener(\"click\", function () &#123; alert(\"捕获 child\");&#125;, true); 补充一个知识点： 在 js中： 如果想获取 body 节点，方法是：document.body； 但是，如果想获取 html节点，方法是document.documentElement。 冒泡的流程 与捕获的流程相反 Event对象的常见 api 方法 用户做的是什么操作（比如，是敲键盘了，还是点击鼠标了），这些事件基本都是通过Event对象拿到的。这些都比较简单，我们就不讲了。我们来看看下面这几个方法： 方法一 1event.preventDefault(); 解释：阻止默认事件。 比如，已知&lt;a&gt;标签绑定了click事件，此时，如果给&lt;a&gt;设置了这个方法，就阻止了链接的默认跳转。 方法二：阻止冒泡 这个在业务中很常见。 有的时候，业务中不需要事件进行冒泡。比如说，业务这样要求：单击子元素做事件A，单击父元素做事件B，如果不阻止冒泡的话，出现的问题是：单击子元素时，子元素和父元素都会做事件A。这个时候，就要用到阻止冒泡了。 w3c的方法：（火狐、谷歌、IE11） 1event.stopPropagation(); IE10以下则是： 1event.cancelBubble = true; 兼容代码如下： 12345678910111213box3.onclick = function (event) &#123; alert(\"child\"); //阻止冒泡 event = event || window.event; if (event &amp;&amp; event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; &#125; 上方代码中，我们对box3进行了阻止冒泡，产生的效果是：事件不会继续传递到 father、grandfather、body了。 方法三：设置事件优先级 1event.stopImmediatePropagation(); 这个方法比较长，一般人没听说过。解释如下： 比如说，我用addEventListener给某按钮同时注册了事件A、事件B。此时，如果我单击按钮，就会依次执行事件A和事件B。现在要求：单击按钮时，只执行事件A，不执行事件B。该怎么做呢？这是时候，就可以用到stopImmediatePropagation方法了。做法是：在事件A的响应函数中加入这句话。 大家要记住 event 有这个方法。 属性4、属性5（事件委托中用到） 123event.currentTarget //当前所绑定的事件对象。在事件委托中，指的是【父元素】。event.target //当前被点击的元素。在事件委托中，指的是【子元素】。 上面这两个属性，在事件委托中经常用到。 总结：上面这几项，非常重要，但是容易弄混淆。 自定义事件 自定义事件的代码如下： 1234567 var myEvent = new Event('clickTest'); element.addEventListener('clickTest', function () &#123; console.log('smyhvae'); &#125;);//元素注册事件 element.dispatchEvent(myEvent); //注意，参数是写事件对象 myEvent，不是写 事件名 clickTest 上面这个事件是定义完了之后，就直接自动触发了。在正常的业务中，这个事件一般是和别的事件结合用的。比如延时器设置按钮的动作： 123456789var myEvent = new Event('clickTest');element.addEventListener('clickTest', function () &#123; console.log('smyhvae');&#125;);setTimeout(function () &#123; element.dispatchEvent(myEvent); //注意，参数是写事件对象 myEvent，不是写 事件名 clickTest&#125;, 1000); IE与火狐的事件机制有什么区别？ 如何阻止冒泡？IE只事件冒泡，不支持事件捕获；火狐同时支持件冒泡和事件捕获（Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件） ev.stoPropagation();（旧ie的方法 ev.cancelBubble = true;） 如何添加 html 元素的事件，有几种方法？请列举直接在标签里添加；在元素上添加、使用事件注册函数添加 事件模型 DOM0直接绑定 1234&lt;input onclick=&quot;sayHi()&quot;/&gt;btn.onclick = function() &#123;&#125;btn.onclick = null DOM2DOM2 级事件可以冒泡和捕获通过 addEventListener 绑定通过 removeEventListener 解绑 1234// 绑定btn.addEventListener(&apos;click&apos;, sayHi)// 解绑btn.removeEventListener(&apos;click&apos;, sayHi) DOM3DOM3 具有更多事件类型DOM3 级事件在 DOM2 级事件的基础上添加了更多的事件类型，全部类型如下： 12345678UI事件，当用户与页面上的元素交互时触发，如：load、scroll焦点事件，当元素获得或失去焦点时触发，如：blur、focus鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel文本事件，当在文档中输入文本时触发，如：textInput键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified 解析：参考 如何自定义事件 原生提供了 3 个方法实现自定义事件 createEvent，设置事件类型，是 html 事件还是 鼠标事件 initEvent 初始化事件，事件名称，是否允许冒泡，是否阻止自定义事件 dispatchEvent 触发事件 MDN IE的事件处理和W3C的事件处理有哪些区别？ 绑定事件 W3C: targetEl.addEventListener(‘click’, handler, false); IE: targetEl.attachEvent(‘onclick’, handler); 删除事件 W3C: targetEl.removeEventListener(‘click’, handler, false); IE: targetEl.detachEvent(event, handler); 事件对象 W3C: var e = arguments.callee.caller.arguments[0] IE: window.event 事件目标 W3C: e.target IE: window.event.srcElement 阻止事件默认行为 W3C: e.preventDefault() IE: window.event.returnValue = false 阻止事件传播 W3C: e.stopPropagation() IE: window.event.cancelBubble = true W3C事件的 target 与 currentTarget 的区别？ target 只会出现在事件流的目标阶段 currentTarget 可能出现在事件流的任何阶段 当事件流处在目标阶段时，二者的指向相同 当事件流处于捕获或冒泡阶段时：currentTarget 指向当前事件活动的对象(一般为父级) 如何派发事件(dispatchEvent)？（如何进行事件广播？） W3C: 使用 dispatchEvent 方法 IE: 使用 fireEvent 方法 12345678910var fireEvent = function(element, event)&#123; if (document.createEventObject)&#123; var mockEvent = document.createEventObject(); return element.fireEvent('on' + event, mockEvent) &#125;else&#123; var mockEvent = document.createEvent('HTMLEvents'); mockEvent.initEvent(event, true, true); return !element.dispatchEvent(mockEvent); &#125;&#125; 跨域 因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败 JSONP JSONP 的原理很简单，就是利用 标签没有跨域限制的漏洞。通过 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时 123456&lt;script src=\"http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp\"&gt;&lt;/script&gt;&lt;script&gt; function jsonp(data) &#123; console.log(data) &#125;&lt;/script&gt; JSONP 使用简单且兼容性不错，但是只限于 get 请求 CORS CORS需要浏览器和后端同时支持 浏览器会自动进行 CORS 通信，实现CORS通信的关键是后端。只要后端实现了 CORS，就实现了跨域。 服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源 document.domain 该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。 只需要给页面添加 document.domain = &#39;test.com&#39; 表示二级域名都相同就可以实现跨域 postMessage 这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息 1234567891011// 发送消息端window.parent.postMessage('message', 'http://test.com');// 接收消息端var mc = new MessageChannel();mc.addEventListener('message', (event) =&gt; &#123; var origin = event.origin || event.originalEvent.origin; if (origin === 'http://test.com') &#123; console.log('验证通过') &#125;&#125;); Event loopJS中的event loop 众所周知 JS 是门非阻塞单线程语言，因为在最初 JS 就是为了和浏览器交互而诞生的。如果 JS 是门多线程的语言话，我们在多个线程中处理 DOM 就可能会发生问题（一个线程中新加节点，另一个线程中删除节点） JS 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 Task（有多种 task） 队列中。 一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为。 1234567console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0);console.log('script end'); 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task 1234567891011121314151617console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0);new Promise((resolve) =&gt; &#123; console.log('Promise') resolve()&#125;).then(function() &#123; console.log('promise1');&#125;).then(function() &#123; console.log('promise2');&#125;);console.log('script end');// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout 以上代码虽然 setTimeout 写在 Promise 之前，但是因为 Promise 属于微任务而 setTimeout 属于宏任务 微任务 process.nextTick promise Object.observe MutationObserver 宏任务 script setTimeout setInterval setImmediate I/O UI rendering 宏任务中包括了 script ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务 所以正确的一次 Event loop 顺序是这样的 执行同步代码，这属于宏任务 执行栈为空，查询是否有微任务需要执行 执行所有微任务 必要的话渲染 UI 然后开始下一轮 Event loop，执行宏任务中的异步代码 通过上述的 Event loop 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 DOM 的话，为了更快的响应界面响应，我们可以把操作 DOM 放入微任务中 Node 中的 Event loop Node 中的 Event loop 和浏览器中的不相同。 Node 的 Event loop 分为6个阶段，它们会按照顺序反复运行 123456789101112131415161718┌───────────────────────┐┌─&gt;│ timers ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ I/O callbacks ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ idle, prepare ││ └──────────┬────────────┘ ┌───────────────┐│ ┌──────────┴────────────┐ │ incoming: ││ │ poll │&lt;──connections─── ││ └──────────┬────────────┘ │ data, etc. ││ ┌──────────┴────────────┐ └───────────────┘│ │ check ││ └──────────┬────────────┘│ ┌──────────┴────────────┐└──┤ close callbacks │ └───────────────────────┘ timer timers 阶段会执行 setTimeout 和 setInterval 一个 timer 指定的时间并不是准确时间，而是在达到这个时间后尽快执行回调，可能会因为系统正在执行别的事务而延迟 I/O I/O 阶段会执行除了 close 事件，定时器和 setImmediate 的回调 idle, prepareidle, prepare 阶段内部实现 poll poll 阶段很重要，这一阶段中，系统会做两件事情 执行到点的定时器 执行 poll 队列中的事件 并且当 poll 中没有定时器的情况下，会发现以下两件事情 如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制 如果 poll 队列为空，会有两件事发生 如果有 setImmediate 需要执行，poll 阶段会停止并且进入到 check 阶段执行 setImmediate 如果没有 setImmediate 需要执行，会等待回调被加入到队列中并立即执行回调 如果有别的定时器需要被执行，会回到 timer 阶段执行回调。 check check 阶段执行 setImmediate close callbacks close callbacks 阶段执行 close 事件 并且在 Node 中，有些情况下的定时器执行顺序是随机的 12345678910setTimeout(() =&gt; &#123; console.log('setTimeout');&#125;, 0);setImmediate(() =&gt; &#123; console.log('setImmediate');&#125;)// 这里可能会输出 setTimeout，setImmediate// 可能也会相反的输出，这取决于性能// 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setImmediate// 否则会执行 setTimeout 上面介绍的都是 macrotask 的执行情况，microtask 会在以上每个阶段完成后立即执行 1234567891011121314151617181920setTimeout(()=&gt;&#123; console.log('timer1') Promise.resolve().then(function() &#123; console.log('promise1') &#125;)&#125;, 0)setTimeout(()=&gt;&#123; console.log('timer2') Promise.resolve().then(function() &#123; console.log('promise2') &#125;)&#125;, 0)// 以上代码在浏览器和 node 中打印情况是不同的// 浏览器中一定打印 timer1, promise1, timer2, promise2// node 中可能打印 timer1, timer2, promise1, promise2// 也可能打印 timer1, promise1, timer2, promise2 Node 中的 process.nextTick 会先于其他 microtask 执行 123456789101112setTimeout(() =&gt; &#123; console.log(\"timer1\"); Promise.resolve().then(function() &#123; console.log(\"promise1\"); &#125;);&#125;, 0);process.nextTick(() =&gt; &#123; console.log(\"nextTick\");&#125;);// nextTick, timer1, promise1 Service Worker代理服务器 Service workers 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。 它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。 他们还允许访问推送通知和后台同步API。 目前该技术通常用来做缓存文件，提高首屏速度 123456789101112131415161718192021222324252627282930313233// index.jsif (navigator.serviceWorker) &#123; navigator.serviceWorker .register(\"sw.js\") .then(function(registration) &#123; console.log(\"service worker 注册成功\"); &#125;) .catch(function(err) &#123; console.log(\"servcie worker 注册失败\"); &#125;);&#125;// sw.js// 监听 `install` 事件，回调中缓存所需文件self.addEventListener(\"install\", e =&gt; &#123; e.waitUntil( caches.open(\"my-cache\").then(function(cache) &#123; return cache.addAll([\"./index.html\", \"./index.js\"]); &#125;) );&#125;);// 拦截所有请求事件// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据self.addEventListener(\"fetch\", e =&gt; &#123; e.respondWith( caches.match(e.request).then(function(response) &#123; if (response) &#123; return response; &#125; console.log(\"fetch source\"); &#125;) );&#125;); 打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了 在 Cache 中也可以发现我们所需的文件已被缓存 当我们重新刷新页面可以发现我们缓存的数据是从 Service Worker 中读取的 渲染机制浏览器的渲染机制一般分为以下几个步骤 处理 HTML 并构建 DOM 树。 处理 CSS 构建 CSSOM 树。 将 DOM 与 CSSOM 合并成一个渲染树。 根据渲染树来布局，计算每个节点的位置。 调用 GPU 绘制，合成图层，显示在屏幕上 在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢 当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件。并且 CSS 也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM 浏览器的渲染过程 解析HTML构建 DOM(DOM树)，并行请求 css/image/js CSS 文件下载完成，开始构建 CSSOM(CSS树)（解析CSS生成CSSOM规则树） CSSOM 规则树构建结束后，和 DOM 一起生成 Render Tree(渲染树) 遍历渲染树开始布局(Layout)：计算出每个节点在屏幕中的位置、大小信息。 显示(Painting)：将渲染树每个节点绘制到屏幕（通过显卡把页面画到屏幕上） 解析： 使用 HTML 创建文档对象模型（DOM） 使用 CSS 创建 CSS 对象模型（CSSOM） 基于 DOM 和 CSSOM 执行脚本（Scripts） 合并 DOM 和 CSSOM 形成渲染树（Render Tree） 使用渲染树布局（Layout）所有元素 渲染（Paint）所有元素 参考 DOM树 和 渲染树 的区别：DOM树与HTML标签一一对应，包括head和隐藏元素 渲染树不包括head和隐藏元素，大段文本的每一个行都是独立节点，每一个节点都有对应的css属性 图层 一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。 不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。 但也不能生成过多的图层，会引起反作用 通过以下几个常用属性可以生成新图层 3D 变换：translate3d、translateZ will-change video、iframe 标签 通过动画实现的 opacity 动画转换 position: fixed 浏览器内核常见的浏览器内核有哪些？Trident 内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称 MSHTML] Gecko 内核：Netscape6 及以上版本，FF,MozillaSuite/SeaMonkey 等 Presto 内核：Opera7 及以上。 [Opera 内核原为：Presto，现为：Blink;] Webkit 内核：Safari,Chrome 等。 [ Chrome 的：Blink（WebKit 的分支）] 对浏览器内核的理解？主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS引擎则：解析和执行javascript来实现网页的动态效果。 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"存储技术","slug":"存储技术","permalink":"https://qw8.github.io/tags/存储技术/"},{"name":"事件机制","slug":"事件机制","permalink":"https://qw8.github.io/tags/事件机制/"},{"name":"跨域","slug":"跨域","permalink":"https://qw8.github.io/tags/跨域/"},{"name":"Service Worker","slug":"Service-Worker","permalink":"https://qw8.github.io/tags/Service-Worker/"},{"name":"渲染机制","slug":"渲染机制","permalink":"https://qw8.github.io/tags/渲染机制/"},{"name":"浏览器内核","slug":"浏览器内核","permalink":"https://qw8.github.io/tags/浏览器内核/"}]},{"title":"面试技巧","slug":"interview/面试技巧","date":"2021-02-22T07:30:21.000Z","updated":"2023-04-14T17:01:50.000Z","comments":true,"path":"/interview/mian-shi-ji-qiao.html","link":"","permalink":"https://qw8.github.io/interview/mian-shi-ji-qiao.html","excerpt":"","text":"面试是一个非常重要的过程，有些人在这个过程中感到不知所措，或者做得不好，使自己在求职中因小失大，达不到成功。在求职过程中注意了以下基本礼仪和技巧，才能达到事半功倍，增强面试的有效性。 面试前准备（1）穿着得体，干净。 （2）对公司做简单的了解 （3）保证充足睡眠，保持自信 注意事项(1)一旦约好面试时间，一定要提前 5-10 分钟到达地点，以表示求职者的诚意，给对方以信任感。 (2)面试时不要紧张，保持微笑，如果门关着，应先敲门，得到允许后再进去。开关门动作要轻。 (3) 对于面试官的问题要一一回答，可以适当点头，不要打断用人单位的问话或抢问抢答。回答问题是眼睛要注视面试官，切记不要左顾右盼。 谈话技巧(1)自我介绍在三分钟之内，口齿清晰，语言流利，吐字清晰。 (2) 注意听者的反应。比如，听者心不在焉，可能表示他对自己这段话没有兴趣，你得设法转移话题；侧耳倾听，可能说明由于自己音量过小使对方难于听清；皱眉、摆头可能表示自己言语有不当之处。根据对方的这些反应，就要适时地调整自己的语言、语调、语气、音量、修辞，包括陈述内容。这样才能取得良好的面试效果。 (3) 表示关注的手势。在与他人交谈中，一定要对对方的谈话表示关注，要表示出你在聚精会神地听。对方在感到自己的谈话被人关注和理解后，才能愉快专心地听取你的谈话，并对你产生好感。 回答问题的技巧(1) 把握重点，简捷明了，条理清楚，有理有据。一般情况下回答问题要结论在先，议论在后，先将自己的中心意思表达清晰，然后再做叙述和论证。否则，长篇大论，会让人不得要领。面试时间有限，神经有些紧张，多余的话太多，容易走题，反倒会将主题冲淡或漏掉。 (2) 讲清原委，避免抽象。 用人单位提问总是想了解一些应试者的具体情况，切不可简单地仅以“是”和“否”作答。应针对所提问题的不同，有的需要解释原因，有的需要说明程度。不讲原委，过于抽象的回答，往往不会给主试者留下具体的印象。 (3) 确认提问内容，切忌答非所问。面试中，如果对用人单位提出的问题，一时摸不到边际，以致不知从何答起或难以理解对方问题的含义时，可将问题复述一遍，并先谈自己对这一问题的理解，请教对方以确认内容。对不太明确的问题，一定要搞清楚，这样才会有的放矢，不致答非所问。 (4) 有个人见解，有个人特色。用人单位有时接待应试者若干名，相同的问题问若干遍，类似的回答也要听若干遍。因此，用人单位会有乏味、枯燥之感。只有具有独到的个人见解和个人特色的回答，才会引起对方的兴趣和注意。 (5) 知之为知之，不知为不知。面试遇到自己不知、不懂、不会的问题时，回避闪烁，默不作声，牵强附会，不懂装懂的做法均不足取，诚恳坦率地承认自己的不足之处，反倒会赢得主试者的信任和好感。 总结：保持自信，做自我介绍时，时间应控制在三分钟之内，不要啰嗦，把自己取得过什么成就，或者在公司做过什么贡献，总结自己的优势时刻保持微笑。最后，紧张的同学，可以把面试官当做同事，面试是一个相互选择的过程，你找我我还不一定干呢。 请你自我介绍一下你自己回答提示：一般人回答这个问题过于平常，只说姓名、年龄、爱好、工作经验，这些在简历上都有，其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，这些都可以和学习无关，也可以和学习有关，但要突出积极的个性和做事的能力，说得合情合理企业才会相信。企业很重视一个人的礼貌，求职者要尊重考官，在回答每个问题之后都说一句“谢谢”。企业喜欢有礼貌的求职者。 回答样本： 1、我叫xxx,来自于xxx，从网上看得到公司招聘的这个职位，觉得非常适合自己的发展。所以来这里争取下这份工作。2、接下来可以讲解自己的核心竞争力（最强的技能、最深入研究的知识领域、个性中最积极的部分）和闪光点（做过的最成功的事，主要的成就）。核心就是要体现自己胜任这份工作（介绍时候要自然有底气，合情合理，面试前要充分准备好）。3、先介绍到这里，面试官看看有什么问题，我可以再补充。4、最后要说谢谢，任何企业都喜欢有礼貌的人！ 注意：自曝其短（说自己的缺点）没有必要，自我介绍的时候千万不要和简历有冲突！ 你觉得你个性上最大的优点是什么？回答提示：沉着冷静、条理清楚、立场坚定、顽强向上、乐于助人和关心他人、适应能力和幽默感、乐观和友爱、技术狂热、学习能力强、为人谦和。 说说你最大的缺点？回答提示：这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼、爱忌妒人、非常懒、脾气大、工作效率低，企业肯定不会录用你。绝对不要自作聪明地回答“我最大的缺点是过于追求完美”，有的人以为这样回答会显得自己比较出色，但事实上，他已经岌芨可危了。企业喜欢求职者从自己的优点说起，中间加一些小缺点，最后再把问题转回到优点上，突出优点的部分。企业喜欢聪明的求职者。 你对加班的看法？回答提示：实际上好多公司问这个问题，并不证明一定要加班。 只是想测试你是否愿意为公司奉献。回答样本：如果是工作需要我会义不容辞加班。我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。 你对薪资的要求？回答提示：如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高，那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求聘的职位定下开支预算，因而他们第一次提出的价钱往往是他们所能给予的最高价钱。他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。 回答样本一：“我对工资没有硬性要求。我相信贵公司在处理我的问题上会友善合理。我注重的是找对工作机会，所以只要条件公平，我则不会计较太多 回答样本二：我受过系统的软件编程的训练，不需要进行大量的培训。而且我本人也对编程特别感兴趣。因此，我希望公司能根据我的情况和市场标准的水平，给我合理的薪水。 回答样本三：如果你必须自己说出具体数目，请不要说一个宽泛的范围，那样你将只能得到最低限度的数字。最好给出一个具体的数字，这样表明你已经对当今的人才市场作了调查，知道像自己这样学历的雇员有什么样的价值。 我们先来了解面试官如何评判应聘者的工资，知己知彼才能对症下药啊！ 一些正规的大公司主要是根据以下四个方面进行评判（重要性从上至下） 1、掌握的技术（通过笔试、项目经验、工作时间）2、表达3、学历4、其他素质（如英语四六级等） 面试官评判应聘者工资的重要性之所以采取如此的顺序，根本原因在于面试官最最重要的是程序员能不能把工作做好，让公司放心。所以学员技术很重要，表达也很重要（技术牛但不会表达，也会让人怀疑技术实力） 当 HR 问：你对薪资有什么要求？大家找工作，都希望找个高薪的，那我们如何和公司去谈薪酬呢？如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高，那又会显得你分量过重，公司受用不起。这个问题确实是个比较难于回答的问题，处理不好的话，会影响面试的效果，但又是不可避免的一个现实问题。 对于这个问题，第一首先要知道程序员等级、技能、工资的绑定情况，因为我们前端工程师主要是看技术。技术实力决定了我们的月薪；第二要打探出公司能给出的薪资范围。在这个范围内争取高薪资。 回答提示： 第一步是了解对方可以提供的薪酬幅度是多少，这里的关键是善于发问，让对方多讲，而自己了解足够的信息。当经过几轮面试后，面试官会问应聘者：你还有什么想了解的问题吗？应聘者就可问：像你们这样的大企业都有自己的一套薪酬体系，请问可以简单介绍一下吗？面试官一般就会简单介绍一下，如果介绍得不是太详细，还可以问：贵公司的薪酬水平在同行业中的位置是怎样的？除了工资之外还有哪些奖金、福利和培训机会？试用期后工资的加幅是多少？等问题。从对方的回答中，你再对照一下市场行情心里就有底了。 第二步是根据以上信息，提出自己的期望薪酬。如果对自己想提的薪资还是把握不准，那也可以把问题抛给对方：我想请教一个问题，以我现在的经历、学历和您对我面试的了解，在公司的薪酬体系中大约能达到怎么样的水平？对方就会透露给你准备开的工资水平。 迂回战术求高薪如果你对该公司开出的薪资标准不太满意，就可以尝试用探讨式、协商式的口气去争取高一些：比如我认为工作最重要的是合作开心，薪酬是其次的，不过我原来的月薪是××元，如果跳槽的话就希望自己能有点进步，如果不是让您太为难的话，您看这个工资是不是可以有一点提高？这时要看对方的口气是否可以松动，松动的话则可以再举出你值更高价的理由。 如果对方的口气坚决，则可以迂回争取试用期的缩短，比如说：我对自己是比较有自信的，您看能不能一步到位直接拿转正期的工资，或者把３个月的试用期缩短为１个月？额外工资多争取。 很多企业除了正式的工资以外，都会产生一些奖金、福利等额外工资，在这方面应聘者就要大胆争取了。应聘者要注意察言观色见好就收，不要过度要求，否则让对方破例后，到时你进来后对方也会以更高的要求来考核你，还可能答应了最后也不兑现。为了保险起见，应聘者最好让对方在接收函上写明薪酬、试用期限、上班时间等，这样可免去日后口说无凭的纠纷。 总之，好的薪水是要靠势力得到的,但多调查和多注意这方面的资讯,使自己在面试前做到对这个职位的大致薪水有个了解,就会使你不至于提太高或太低不切实际的要求,从而失去到手的工作。 HR 指责要薪太高怎么办？想象下，当你实事求是的按照以上的方法报出自己的工资为 7000 元的时候，面试官呵呵笑道：“你是应届生，却要求 7000 元的工资，是不是太高了？”此时，你该怎么办？ 回答提示： 1、北京的生活成本高，3000元在北京生存很艰难，在饭店工作也可能不值这个，北京的web前端平均工资我也是有过了解的。同学大都是这个工资（注意：这个同学可以向HR强调是平时一起讨论问题的同学，暗示水平差不多)；2、上几家都给我6千了，我没有去（觉得自己值多少钱，那就是值多少）；3、我不是乱要价，我有能力完成完成上级交代的任务，创造出超过7000元价值的能力（强调自己的能力）；4、对技术狂热，会沿着前端道路一直往前走（强调自己对这份工作的热爱）；5、再说公司会有试用期，试用期可以低于7000，我会在这个阶段证明我自己的能力，可以如果没有达到，公司也可以开除我。 在五年的时间内，你的职业规划？回答提示：这是每一个应聘者都不希望被问到的问题，但是几乎每个人都会被问到。比较多的答案是“管理者”。但是近几年来，许多公司都已经建立了专门的技术途径。这些工作地位往往被称作“顾问”、“参议技师”或“高级软件工程师”等等。当然，说出其他一些你感兴趣的职位也是可以的，比如产品销售部经理，生产部经理等一些与你的专业有相关背景的工作。要知道，考官总是喜欢有进取心的应聘者，此时如果说“不知道”，或许就会使你丧失一个好机会。最普通的回答应该是 “我准备在技术领域有所作为”或“我希望能按照公司的管理思路发展”。 你朋友对你的评价？回答提示： 想从侧面了解一下你的性格及与人相处的问题。回答样本：“我的朋友都说我是一个可以信赖的人。因为，我一旦答应别人的事情，就一定会做到。如果我做不到，我就不会轻易许诺。回答样本：”我觉的我是一个比较随和的人，与不同的人都可以友好相处。在我与人相处时，我总是能站在别人的角度考虑问题“ 你还有什么问题要问吗？回答提示：企业的这个问题看上去可有可无，其实很关键，企业不喜欢说“没有问题”的人，因为其很注重员工的个性和创新能力。企业不喜欢求职者问个人福利之类的问题，如果有人这样问：贵公司对新入公司的员工有没有什么培训项目，我可以参加吗？或者说贵公司的晋升机制是什么样的？企业将很欢迎，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。 如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？回答提示：一段时间发现工作不适合我，有两种情况： 1、如果你确实热爱这个职业，那你就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距； 2、你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。 在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？①.原则上我会尊重和服从领导的工作安排；同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法；② 如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作；③.还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见；如领导仍固执己见，我会毫不犹豫地再向上级领导反映。 你希望与什么样的上级共事？① 通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识，这既上一个陷阱，又是一次机会；② 最好回避对上级具体的希望，多谈对自己的要求；③ 如“做为刚步入社会的新人，我应该多要求自己尽快熟悉环境、适应环境，而不应该对环境提出什么要求，只要能发挥我的专长就可以了 分析：这个问题比较好的回答是，希望我的上级能够在工作中对我多指导，对我工作中的错误能够立即指出。总之，从上级指导这个方面谈，不会有大的纰漏。 在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？①.原则上我会尊重和服从领导的工作安排；同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法；② 如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作；③.还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见；如领导仍固执己见，我会毫不犹豫地再向上级领导反映。 与上级意见不一致，你将怎么办？① 一般可以这样回答“我会给上级以必要的解释和提醒，在这种情况下，我会服从上级的意见。”② 如果面试你的是总经理，而你所应聘的职位另有一位经理，且这位经理当时不在场，可以这样回答：“对于非原则性问题，我会服从上级的意见，对于涉及公司利益的重大问题，我希望能向更高层领导反映。” 分析：这个问题的标准答案是思路 1，如果用 2 的回答，必死无疑。你没有摸清楚改公司的内部情况，先想打小报告，这样的人没有人敢要。 如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？回答提示：我首先不会找那位上级领导说明这件事，我会主动找我的主管领导来沟通，因为沟通是解决人际关系的最好办法，但结果会有两种：我的主管领导认识到自己的错误，我想我会视具体情况决定是否原谅他；2.他更加变本加厉的来威胁我，那我会毫不犹豫地找我的上级领导反映此事，因为他这样做会造成负面影响，对今后的工作不利。 如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？① 我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决；② 是责任问题。分清责任，各负其责，如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸，作为一个团队，需要互相提携共同完成工作，安慰同事并且帮助同事查找原因总结经验。③ 总结经验教训，一个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中吸取经验教训，并在今后的工作中避免发生同类的错误。检讨自己的工作方法、分析问题的深度和力度是否不够，以致出现了本可以避免的错误。 如果你在这次考试中没有被录用，你怎么打算？回答提示：现在的社会是一个竞争的社会,从这次面试中也可看出这一点,有竞争就必然有优劣,有成功必定就会有失败.往往成功的背后有许多的困难和挫折,如果这次失败了也仅仅是一次而已,只有经过经验经历的积累才能塑造出一个完全的成功者。我会从以下几个方面来正确看待这次失败. 第一、要敢于面对,面对这次失败不气馁,接受已经失去了这次机会就不会回头这个现实,从心理意志和精神上体现出对这次失败的抵抗力。要有自信,相信自己经历了这次之后经过努力一定能行.能够超越自我. 第二、善于反思,对于这次面试经验要认真总结,思考剖析,能够从自身的角度找差距。正确对待自己,实事求是地评价自己,辩证的看待自己的长短得失,做一个明白人. 第三、走出阴影,要克服这一次失败带给自己的心理压力,时刻牢记自己弱点,防患于未然,加强学习,提高自身素质. 第四、认真工作,回到原单位岗位上后,要实实在在、踏踏实实地工作,三十六行,行行出状元,争取在本岗位上做出一定的成绩. 第五、再接再厉,成为软件工程师或网络工程师一直是我的梦想,以后如果有机会我仍然后再次参加竞争. 谈谈你对跳槽的看法？（1）正常的”跳槽”能促进人才合理流动，应该支持；（2）频繁的跳槽对单位和个人双方都不利，应该反对。 工作中你难以和同事、上司相处，你该怎么办？① 我会服从领导的指挥，配合同事的工作。② 我会从自身找原因，仔细分析是不是自己工作做得不好让领导不满意，同事看不惯。还要看看是不是为人处世方面做得不好。如果是这样的话 我会努力改正。③ 如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足。有问题就及时改正。④ 作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看见我在努力，总有一天会对我微笑的！ 假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？① 成绩比较突出，得到领导的肯定是件好事情，以后更加努力② 检讨一下自己是不是对工作的热心度超过同事间交往的热心了，加强同事间的交往及共同的兴趣爱好。③ 工作中，切勿伤害别人的自尊心④ 不再领导前拨弄是非⑤ 乐于助人对面 你最近是否参加了培训课程？谈谈培训课程的内容。是公司资助还是自费参加？回答提示：请自行根据自己情况做回答，这个没有统一标准答案。 你对于我们公司了解多少？回答提示：在去公司面试前上网查一下该公司主营业务。 请说出你选择这份工作的动机？你为什么选择我们公司？1.面试前，对应聘公司各方面，要了解详尽！至少要了解到行业、企业、岗位这三方面！最好要准备一些具体的数据和实例！2.面试时候，可以将之前对公司的了解（行业、企业、数据、实例）结合自己的面试岗位，大略的说一遍，然后强调自己“觉得这个工作合适”即可。3.如果对这个行业确实很喜欢，要说出你对这个行业的认识与热爱。 你最擅长的技术方向是什么？回答提示：说和你要应聘的职位相关的课程，表现一下自己的热诚没有什么坏处。 你能为我们公司带来什么呢？① 假如你可以的话，试着告诉他们你可以减低他们的费用——“我已经接受过专业的培训或者工作 X 年，立刻就可以上岗工作”。② 企业很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后说：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多的收益”。企业喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以说：“我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需求和消费。”等等。 最能概括你自己的三个词是什么？回答提示：我经常用的三个词是适应能力强，有责任心和做事有始终，结合具体例子向主考官解释。 你的业余爱好是什么？回答提示：找一些富于团体合作精神的，这里有一个真实的故事：有人被否决掉，因为他的爱好是深海潜水。主考官说：因为这是一项单人活动，我不敢肯定他能否适应团体工作。 作为被面试者给我打一下分回答提示：试着列出四个优点和一个非常非常非常小的缺点，（可以抱怨一下事实，没有明确责任人的缺点是不会有人介意的）。 你怎么理解你应聘的职位？回答提示：把岗位职责和任务及工作态度阐述一下 喜欢这份工作的哪一点？回答提示：相信其实大家心中一定都有答案了吧！每个人的价值观不同，自然评断的标准也会不同，但是，在回答面试官这个问题时可不能太直接就把自己心理的话说出来，尤其是薪资方面的问题，不过一些无伤大雅的回答是不错的考虑，如交通方便，工作性质及内容颇能符合自己的兴趣等等都是不错的答案，不过如果这时自己能仔细思考出这份工作的与众不同之处，相信在面试上会大大加分。 为什么要离职?您在前一家公司的离职原因是什么?① 回答这个问题时一定要小心，就算在前一个工作受到再大的委屈，对公司有多少的怨言，都千万不要表现出来，尤其要避免对公司本身主管的批评，避免面试官的负面情绪及印象；建议此时最好的回答方式是将问题归咎在自己身上，例如觉得工作没有学习发展的空间，自己想在面试工作的相关产业中多加学习，或是前一份工作与自己的生涯规划不合等等，回答的答案最好是积极正面的。② 我希望能获得一份更好的工作，如果机会来临，我会抓住；我觉得目前的工作，已经达到顶峰，即沒有升迁机会。③ 最重要的是：应聘者要使找招聘单位相信，应聘者在过往的单位的“离职原因”在此家招聘单位里不存在；④ 避免把“离职原因”说得太详细、太具体；⑤ 不能掺杂主观的负面感受，如“太辛苦”、“人际关系复杂”、“管理太混乱”、“公司不重视人才”、“公司排斥我们某某的员工”等；但也不能躲闪、回避，如“想换换环境”、“个人原因”等；⑥ 不能涉及自己负面的人格特征，如不诚实、懒惰、缺乏责任感、不随和等；尽量使解释的理由为应聘者个人形象添彩； 回答样本：如“我离职是因为这家公司倒闭；我在公司工作了三年多，有较深的感情；从去年始，由于市场形势突变，公司的局面急转直下；到眼下这一步我觉得很遗憾，但还要面对显示，重新寻找能发挥我能力的舞台。”同一个面试问题并非只有一个答案，而同一个答案并不是在任何面试场合都有效，关键在应聘者掌握了规律后，对面试的具体情况进行把握，有意识地揣摩面试官提出问题的心理背景，然后投其所好。 分析：除非是薪资太低，或者是最初的工作，否则不要用薪资作为理由。“求发展”也被考官听得太多，离职理由要根据每个人的真实离职理由来设计，但是在回答时一定要表现得真诚。实在想不出来的时候，家在外地可以说是因为家中有事，须请假几个月，公司又不可能准假，所以辞职。这个答案一般面试官还能接受。 说说你对行业、技术发展趋势的看法？回答提示：企业对这个问题很感兴趣，只有有备而来的求职者能够过关。求职者可以直接在网上查找对你所申请的行业部门的信息，只有深入了解才能产生独特的见解。企业认为最聪明的求职者是对所面试的公司预先了解很多，包括公司各个部门，发展情况，在面试回答问题的时候可以提到所了解的情况，企业欢迎进入企业的人是“知己”，而不是“盲人”。 对工作的期望与目标何在？回答提示：这是面试者用来评断求职者是否对自己有一定程度的期望、对这份工作是否了解的问题。对于工作有确实学习目标的人通常学习较快，对于新工作自然较容易进入状况，这时建议你，最好针对工作的性质找出一个确实的答案，如业务员的工作可以这样回答：“我的目标是能成为一个超级业务员，将公司的产品广泛的推销出去，达到最好的业绩成效；为了达到这个目标，我一定会努力学习，而我相信以我认真负责的态度，一定可以达到这个目标。”其他类的工作也可以比照这个方式来回答，只要在目标方面稍微修改一下就可以了。 说说你的家庭回答提示：企业面试时询问家庭问题不是非要知道求职者家庭的情况，探究隐私，企业不喜欢探究个人隐私，而是要了解家庭背景对求职者的塑造和影响。企业希望听到的重点也在于家庭对求职者的积极影响。企业最喜欢听到的是：我很爱我的家庭！我的家庭一向很和睦，虽然我的父亲和母亲都是普通人，但是从小，我就看到我父亲起早贪黑，每天工作特别勤劳，他的行动无形中培养了我认真负责的态度和勤劳的精神。我母亲为人善良，对人热情，特别乐于助人，所以在单位人缘很好，她的一言一行也一直在教导我做人的道理。企业相信，和睦的家庭关系对一个人的成长有潜移默化的影响。 就你申请的这个职位，你认为你还欠缺什么？回答提示：企业喜欢问求职者弱点，但精明的求职者一般不直接回答。他们希望看到这样的求职者：继续重复自己的优势，然后说：“对于这个职位和我的能力来说，我相信自己是可以胜任的，只是缺乏经验，这个问题我想我可以进入公司以后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。”企业喜欢能够巧妙地躲过难题的求职者。 你欣赏哪种性格的人？回答提示：诚实、不死板而且容易相处的人、有”实际行动”的人。 你通常如何处理別人的批评？① 沈默是金。不必说什么，否则情况更糟，不过我会接受建设性的批评； ② 我会等大家冷靜下来再讨论。 你怎样对待自己的失敗？回答提示：我们大家生来都不是十全十美的，我相信我有第二个机会改正我的错误。 什么会让你有成就感？回答提示：为贵公司竭力效劳；尽我所能，完成一个项目 眼下你生活中最重要的是什么？回答提示：对我来说，能在这个领域找到工作是最重要的；望能在贵公司任职对我说最重要。 你为什么愿意到我们公司来工作？回答提示：对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些详细的原因，像“公司本身的高技术开发环境很吸引我。”，“我同公司出生在同样的时代，我希望能够进入一家与我共同成长的公司。”“你们公司一直都稳定发展，在近几年来在市场上很有竞争力。”或者“我认为贵公司能够给我提供一个与众不同的发展道路。”这都显示出你已经做了一些调查，也说明你对自己的未来有了较为具体的远景规划。 你和别人发生过争执吗？你是怎样解决的？回答提示：这是面试中最险恶的问题。其实是考官布下的一个陷阱。千万不要说任何人的过错。应知成功解决矛盾是一个协作团体中成员所必备的能力。假如你工作在一个服务行业，这个问题简直成了最重要的一个环节。你是否能获得这份工作，将取决于这个问题的回答。考官希望看到你是成熟且乐于奉献的。他们通过这个问题了解你的成熟度和处世能力。在没有外界干涉的情况下，通过妥协的方式来解决才是正确答案。 你做过的哪件事最令自己感到骄傲?回答提示：这是考官给你的一个机会，让你展示自己把握命运的能力。这会体现你潜在的领导能力以及你被提升的可能性。假如你应聘于一个服务性质的单位，你很可能会被邀请去午餐。记住：你的前途取决于你的知识、你的社交能力和综合表现。 你新到一个部门,一天一个客户来找你解决问题,你努力想让他满意，可是始终达不到群众得满意,他投诉你们部门工作效率低,你这个时候怎么作?(1)首先，我会保持冷静。作为一名工作人员，在工作中遇到各种各样的问题是正常的，关键是如何认识它，积极应对，妥善处理。 (2)其次，我会反思一下客户不满意的原因。一是看是否是自己在解决问题上的确有考虑的不周到的地方，二是看是否是客户不太了解相关的服务规定而提出超出规定的要求，三是看是否是客户了解相关的规定，但是提出的要求不合理。 (3)再次，根据原因采取相对的对策。如果是自己确有不周到的地方，按照服务规定作出合理的安排，并向客户作出解释；如果是客户不太了解政策规定而造成的误解，我会向他作出进一步的解释，消除他的误会；如果是客户提出的要求不符合政策规定，我会明确地向他指出。 (4)再次，我会把整个事情的处理情况向领导作出说明，希望得到他的理解和支持。 (5)我不会因为客户投诉了我而丧失工作的热情和积极性，而会一如既往地牢记为客户服务的宗旨，争取早日做一名领导信任、公司放心、客户满意的职员。 对这项工作，你有哪些可预见的困难？① 不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行；② 可以尝试迂回战术，说出应聘者对困难所持有的态度——“工作中出现一些困难是正常的，也是难免的，但是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以克服。” 分析：一般问这个问题，面试者的希望就比较大了，因为已经在谈工作细节。但常规思路中的回答，又被面试官“骗”了。当面试官询问这个问题的时候，有两个目的。 第一，看看应聘者是不是在行，说出的困难是不是在这个职位中一般都不可避免的问题。 第二，是想看一下应聘者解决困难的手法对不对，及公司能否提供这样的资源。而不是想了解应聘者对困难的态度。 如果我录用你，你将怎样开展工作？① 如果应聘者对于应聘的职位缺乏足够的了解，最好不要直接说出自己开展工作的具体办法；② 可以尝试采用迂回战术来回答，如“首先听取领导的指示和要求，然后就有关情况进行了解和熟悉，接下来制定一份近期的工作计划并报领导批准，最后根据计划开展工作。” 分析：这个问题的主要目的也是了解应聘者的工作能力和计划性、条理性，而且重点想要知道细节。如果向思路中所讲的迂回战术，面试官会认为回避问题，如果引导了几次仍然是回避的话。此人绝对不会录用了。 你工作经验欠缺，如何能胜任这项工作？① 如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在乎“经验”，关键看应聘者怎样回答；② 对这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业；③ 如“作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。” 点评：这个问题思路中的答案尚可。突出自己的吃苦能力和适应性以及学习能力（不是学习成绩）为好。 为了做好你工作份外之事，你该怎样获得他人的支持和帮助？回答提示：每个公司都在不断变化发展的过程中；你当然希望你的员工也是这样。你希望得到那些希望并欢迎变化的人，因为这些人明白，为了公司的发展，变化是公司日常生活中重要组成部分。这样的员工往往很容易适应公司的变化，并会对变化做出积极的响应。此外，他们遇到矛盾和问题时，也能泰然处之。下面的问题能够考核应聘者这方面的能力。据说有人能从容避免正面冲突。请讲一下你在这方面的经验和技巧。有些时候，我们得和我们不喜欢的人在一起共事。说说你曾经克服了性格方面的冲突而取得预期工作效果的经历。 项目中遇到困难，你怎么办？怎么回答回答提示：自己能搞定的，就自己上网找资料；但如果比如在 2 个小时之内还没有头绪，就考虑问公司技术水平比较高的同事之类的，然后还要及时和项目经理沟通 那不浪费了 2 个小时时间 业务问题的话，谁清楚就问谁啊……即时沟通能够大大提高工作效率。 技术问题查资料，需求问题重新分析 还是写程序的时候有技术难点、技术难点又分普遍的技术难点、还是你个人不会做、 第一种这个要找项目负责人商量、甚至要找产品/运行或其他甲方沟通、 第二种普遍技术难点的话、参考资料或者和项目负责人商量看看怎么办、 第三种的话、先自己查资料试着解决、不行就找人其他资讯、、 你在现在的团队处于什么样的角色，起到了什么明显的作用？回答提示：请自行根据自己情况做回答，这个没有统一标准答案。 最近在学什么？能谈谈你未来 3，5 年给自己的规划吗？面试时，经常会被面试官问到关于职业规划的问题，比如：你准备在我们公司做多久？你未来几年的职业规划是什么？等等。还没有进入公司，对公司工作环境还不太了解就被面试官问到这些问题，该怎么答才能合情有合理呢？ 问：你准备在我们这家单位做多久？ 答： 这不是自己单方面决定的，还要看公司，但是可以肯定的是，如果公司跟自己的职业发展一致，我是会一直干下去的 以我对公司和现有职位的了解，如果能应聘上的话，目前来看至少可以稳定三年 问：未来五年的规划是怎样的？ 答： 1.如果应聘成功，我至少会稳定的做两年，踏实的做好自己的本职工作。2.在工作中，会向高手请教，研究些新技术，提高自己的技术水平。3.目前的规划是要优先做一名技术高手，如果有可能的话，做管理也是可以考虑的。 当然，说出其他一些你感兴趣的职位也是可以的，比如产品销售部经理，生产部经理等一些与你的专业有相关背景的工作。要知道，考官总是喜欢有进取心的应聘者，此时如果说“不知道”，或许就会使你丧失一个好机会。最普通的回答应该是“我准备在技术领域有所作为”或“我希望能按照公司的管理思路发展”。 大部分面试官司都会问你是否有职业规划，这个问题的背后是了解你的求职动机和对自己中长期职业发展的思考。在回答这个问题之前，要对自己有个清晰的认识，知道自己想往哪个方向发展以及未来有什么计划，要给面试官一种积极向上，好学上进，有追求，有规划的感觉，面试官喜欢有规划的求职者。 如何向 HR 介绍你做过的项目项目经验与工作经验是相辅相成的，但较之于工作经验，项目经验更侧重于表现求职者在某个专业领域内的技能水平（技能水平决定了工资水平）。因而，技术类岗招聘的时候，更注重项目经验。项目介绍是有套路的，面试时，要将简历中的项目准备好！ 我们在跟面试官讲解的时候，讲解项目一定要围绕着以下几个方面： 1、项目名称2、开发时间（这里有个注意点：时间不要说的太短，而应该把前期的构思、需求分析、准备工作等时间都可以加进去）；3、项目描述（做什么的）；4、项目职责（说清楚自己职责，同时为了提高自己的技术形象，可以将项目说大点）；5、项目使用的技术（除了说现在使用的技术，还可以说项目进行了压力测试、兼容性处理、数据库的3F、未来还要放mysql集群技术、页面静态化技术、以提升自己在对方心目中的技术形象）；6、项目的亮点；7、在自己的项目上可以想一些市面上没有但是自己觉得很有创意的点子。实现不实现都是无所谓了，但是你给面试官的印象会再上一个层次。8、项目体会（可以说说：多人协作、命名规范、模块划分）； HR 贬低项目时你该怎么办我们在上文讲解了如何向 HR 介绍项目。由于项目反映了技术，技术决定了薪资，所以面试官一般会把打压我们的项目变相打压我们技术，以达到打压我们薪资预期的目的，同时观察我们在打压环境中的表现来决定到底打压薪资到何种程度！所以，当 HR 说：“一个月的时间，四五个人的配合就完成了项目，可见你们项目不大、技术含量不高啊”，各位面试者一定要冷静！来学学在 HR 贬低项目时的应对方法！ 1.项目实现也许花的时间不多，但是前期的构思、需求分析、页面设计等等准备工作是花了很多时间的。2.项目大小和技术含量并不能够成正比，我们的项目，虽然小，但麻雀虽小，却五脏俱全。接着向面试官介绍你们团队在项目过程中所使用的技术等等。3.项目大小主要是体现在功能上，有些功能客户并没有提出。如果后期客户有提出，我们也能够快速的实现。 项目经验少该怎么办对于前端来说，技术水平是决定我们工资最重要的因素。技术水平是要通过我们的项目体现出来的，但项目经验少该怎么办？ 1、项目经验是拿高工资最重要的一个指标。这反映了程序员的价值，也是用人单位给出薪资报价最重要的因素。所以面试者一定要重视项目。2、简历中至少要写出3个项目。3、项目可以适当包装。可以多说一些比较高端大气上档次的技术。4、面试官问到简历中的项目细节你要能答上来。否则，就算是你做的，面试官因你答不上来也会认为不是你做的。所以要花时间，搞定写在简历上的项目模块。5、项目抓亮点来说，可以对照企业的需求，将最有竞争力的点说清楚。这种能够加分的亮点一定要说到。 你学历低，为什么要录用你？面试一份工作时，学历有时候是一块敲门砖。对于学历不高的面试者，如果 HR 问：你才高中学历，而现在大学生一大把，我们为什么要录用你？你如果学历真的很低，那该怎么回答呢？ 回答提示： 1、通过自信的表现，有效的沟通，让面试官主动忽略这个问题。或者说是你把你最好的展现出来，让面试官信服，觉得你是合适的人选而不提及或忽略掉这个问题。2、即使面试官提出来了，勇敢面对主动承认，赞同面试官的提问，确实学历较低，自已已经深刻认识此问题，也因为认识到这个事实，你才更加注重能力的培养，同时自己也在工作之余继续课堂学习，增加扎实的理论知识。同时说出你的学历提升打算，提升计划一定要与你现行的工作职位结合。3、如果面试官对学历一直抓住不放，或作为必要条件，以退为进吧，委婉表达自己想得到职位的态度，并做好了放弃的心理准备。 总的来说，在面试的时候，表现出自信，从谈吐和沟通上，给面试官好印象。如果问到你学历的时候，表现出“学历不代表能力”的自信来就好，一般的企业不会把这个当做决定性因素，还是看综合素质。 你是不是年龄太大了？都说 IT 行业是个吃青春饭的行业，你现在已经接近 30 岁了，你是不是年龄太大了？这个问题应该被问到的不多，但是万一真的被问到这个问题，你该如何作答呢？ 1、 能不能做事才是大问题。而不是年龄。是不是有能力，试用期间可以检验。2、 要表现出自己很喜欢这份工作，要长久的做下去（年龄大的人，工作经历多，接触的东西多，才能够在众多的经历中明确知道自己未来到底要走什么路）。要突出自己年龄大的优势，比如思想更成熟，眼界更开阔等等。 你太小了，你能承担项目吗？虽说 IT 行业是个吃青春饭的行业，但是你年纪太小了，让人感觉不踏实。虽然我们最重要拼的是技术，但真的被问到这个问题，你该如何作答呢？ 1、虽然我年纪小，但是我技术是没有问题的，也是有担当的。试用期间可以检验。2、对于前端，我做过很多的项目，也有系统的学习过。并不比年纪大的人差。3、正因为我年纪小，我对于工作有十足的干劲，我很想在这行好好的发展，也能承受比较强的工作压力。 你对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？a. 前端是最贴近用户的程序员，前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。前端的能力就是能让产品从 90 分进化到 100 分，甚至更好 b. 参与项目，快速高质量完成实现效果图，精确到 1px； c. 与团队成员，UI 设计，产品经理的沟通； d. 做好的页面结构，页面重构和用户体验； e. 处理 hack，兼容、写出优美的代码格式； f. 针对服务器的优化、拥抱最新前端技术。 1、实现界面交互 2、提升用户体验 3、有了 Node.js，前端可以实现服务端的一些事情 其它相关的加分项： 都使用和了解过哪些编辑器?都使用和了解过哪些日常工具? 都知道有哪些浏览器内核?开发过的项目都兼容哪些浏览器? 瀑布流布局或者流式布局是否有了解 HTML5 都有哪些新的 API? 都用过什么代码调试工具? 是否有接触过或者了解过重构。 你遇到过比较难的技术问题是？你是如何解决的？","categories":[{"name":"前端面试题","slug":"前端面试题","permalink":"https://qw8.github.io/categories/前端面试题/"}],"tags":[{"name":"面试技巧","slug":"面试技巧","permalink":"https://qw8.github.io/tags/面试技巧/"},{"name":"面试问题","slug":"面试问题","permalink":"https://qw8.github.io/tags/面试问题/"},{"name":"面试经验","slug":"面试经验","permalink":"https://qw8.github.io/tags/面试经验/"}]},{"title":"面试技术问题","slug":"interview/面试技术问题","date":"2021-02-09T12:48:55.000Z","updated":"2024-03-28T16:30:48.000Z","comments":true,"path":"/interview/mian-shi-ji-zhu-wen-ti.html","link":"","permalink":"https://qw8.github.io/interview/mian-shi-ji-zhu-wen-ti.html","excerpt":"","text":"HTML Doctype作用？严格模式与混杂模式如何区分？它们有何意义? HTML5 为什么只需要写 ？ 页面导入样式时，使用link和@import有什么区别？ 介绍一下你对浏览器内核的理解？ 常见的浏览器内核有哪些？ 如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？ HTML5的离线储存怎么使用，工作原理能不能解释一下？ 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？ iframe有那些缺点？ Label的作用是什么？是怎么用的？（加 for 或 包裹） HTML5的form如何关闭自动完成功能？ 如何实现浏览器内多个标签页之间的通信? (阿里) webSocket如何兼容低浏览器？(阿里) 页面可见性（Page Visibility）API 可以有哪些用途？ 如何在页面上实现一个圆形的可点击区域？ 实现不使用 border 画出1px高的线，在不同浏览器的Quirksmode和CSSCompat模式下都能保持同一效果。 网页验证码是干嘛的，是为了解决什么安全问题？ tite与h1的区别、b与strong的区别、i与em的区别？ CSS 介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？ CSS选择符有哪些？哪些属性可以继承？ CSS优先级算法如何计算？ CSS3新增伪类有那些？ 如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？ display有哪些值？说明他们的作用。 position的值relative和absolute定位原点是？ 请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？ 用纯CSS创建一个三角形的原理是什么？ 一个满屏 品 字布局 如何设计? 常见兼容性问题？ li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？ 经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？ 为什么要初始化CSS样式。 absolute的containing block计算方式跟正常流有什么不同？ CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？ position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？ 对BFC规范(块级格式化上下文：block formatting context)的理解？ CSS权重优先级是如何计算的？ 请解释一下为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式 移动端的布局用过媒体查询吗？ 浏览器是怎样解析CSS选择器的？ 在网页中的应该使用奇数还是偶数的字体？为什么呢？ margin和padding分别适合什么场景使用？ 抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题] 元素竖向的百分比设定是相对于容器的高度吗？ 全屏滚动的原理是什么？用到了CSS的那些属性？ 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？ 视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？） ::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。 如何修改chrome记住密码后自动填充表单的黄色背景 ？ 你对line-height是如何理解的？ 设置元素浮动后，该元素的display值是多少？（自动变成display:block） 怎么让Chrome支持小于12px 的文字？ 让页面里的字体变清晰，变细用CSS怎么做？（-webkit-font-smoothing: antialiased;） font-style属性可以让它赋值为“oblique” oblique是什么意思？ position:fixed;在android下无效怎么处理？ 如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里） display:inline-block 什么时候会显示间隙？(携程) overflow: scroll时不能平滑滚动的问题怎么处理？ 有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度。 png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？ style标签写在body后与body前有什么区别？ JavaScript 说说写JavaScript的基本规范？ JavaScript原型，原型链 ? 有什么特点？ JavaScript有几种类型的值？（堆：原始数据类型和 栈：引用数据类型），你能画一下他们的内存图吗？ Javascript如何实现继承？ Javascript创建对象的几种方式？ Javascript作用链域? 谈谈This对象的理解。 eval是做什么的？ 什么是window对象? 什么是document对象? null，undefined的区别？ 写一个通用的事件侦听器函数(机试题)。 [“1”, “2”, “3”].map(parseInt) 答案是多少？ 关于事件，IE与火狐的事件机制有什么区别？ 如何阻止冒泡？ 什么是闭包（closure），为什么要用它？ javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？ 如何判断一个对象是否属于某个类？ 用原生JavaScript的实现过什么功能吗？ Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？ 对JSON的了解？ [].forEach.call($$(“*”),function(a){ a.style.outline=”1px solid #”+(~~(Math.random()*(1&lt;&lt;24))).toString(16) }) - 能解释一下这段代码的意思吗？ js延迟加载的方式有哪些？ Ajax 是什么? 如何创建一个Ajax？ 同步和异步的区别? 如何解决跨域问题? 页面编码和被请求的资源编码如果不一致如何处理？ 模块化开发怎么做？ AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？ requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？） 让你自己设计实现一个requireJS，你会怎么做？ 谈一谈你对ECMAScript6的了解？ ECMAScript6 怎么写class么，为什么会出现class这种东西? 异步加载的方式有哪些？ documen.write和 innerHTML的区别? DOM操作——怎样添加、移除、移动、复制、创建和查找节点? 数组和对象有哪些原生方法，列举一下？ JS 怎么实现一个类。怎么实例化这个类 JavaScript中的作用域与变量声明提升？ 如何编写高性能的Javascript？ 那些操作会造成内存泄漏？ JQuery的源码看过吗？能不能简单概况一下它的实现原理？ jQuery.fn的init方法返回的this指的是什么对象？为什么要返回this？ jquery中如何将数组转化为json字符串，然后再转化回来？ jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？ jquery.extend 与 jquery.fn.extend的区别？ jQuery 的队列是如何实现的？队列可以用在哪些地方？ 谈一下Jquery中的bind(),live(),delegate(),on()的区别？ JQuery一个对象可以同时绑定多个事件，这是如何实现的？ 是否知道自定义事件。jQuery里的fire函数是什么意思，什么时候用？ jQuery 是通过哪个方法和 Sizzle 选择器结合的？（jQuery.fn.find()进入Sizzle） 针对 jQuery性能的优化方法？ Jquery与jQuery UI有啥区别？ JQuery的源码看过吗？能不能简单说一下它的实现原理？ jquery 中如何将数组转化为json字符串，然后再转化回来？ jQuery和Zepto的区别？各自的使用场景？ 针对 jQuery 的优化方法？ Zepto的点透问题如何解决？ jQueryUI如何自定义组件? 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？ 如何判断当前脚本运行在浏览器还是node环境中？（阿里） 移动端最小触控区域是多大？ jQuery 的 slideUp动画 ，如果目标元素是被外部事件驱动, 当鼠标快速地连续触发外部元素事件, 动画会滞后的反复执行，该如何处理呢? 把 Script 标签 放在页面的最底部的body封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？ 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？（click 有 300ms 延迟,为了实现safari的双击事件的设计，浏览器要知道你是不是要双击操作。） 知道各种JS框架(Angular, Backbone, Ember, React, Meteor, Knockout…)么? 能讲出他们各自的优点和缺点么? Underscore 对哪些 JS 原生对象进行了扩展以及提供了哪些好用的函数方法？ 解释JavaScript中的作用域与变量声明提升？ 那些操作会造成内存泄漏？ JQuery一个对象可以同时绑定多个事件，这是如何实现的？ Node.js的适用场景？ (如果会用node)知道route, middleware, cluster, nodemon, pm2, server-side rendering么? 解释一下 Backbone 的 MVC 实现方式？ 什么是“前端路由”?什么时候适合使用“前端路由”? “前端路由”有哪些优点和缺点? 知道什么是webkit么? 知道怎么用浏览器的各种工具来调试和debug代码么? 如何测试前端代码么? 知道BDD, TDD, Unit Test么? - 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)? 前端templating(Mustache, underscore, handlebars)是干嘛的, 怎么用? 简述一下 Handlebars 的基本用法？ 简述一下 Handlerbars 的对模板的基本处理流程， 如何编译的？如何缓存的？ 用js实现千位分隔符?(来源：前端农民工，提示：正则+replace) 检测浏览器版本版本有哪些方式？ 我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡，你来说下会执行几次事件，然后会先执行冒泡还是捕获] 其他问题 原来公司工作流程是怎么样的，如何与其他人协作的？如何夸部门合作的？ 你遇到过比较难的技术问题是？你是如何解决的？ 设计模式 知道什么是singleton, factory, strategy, decrator么? 常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？ 页面重构怎么操作？ 列举IE与其他浏览器不一样的特性？ 99%的网站都需要被重构是那本书上写的？ 什么叫优雅降级和渐进增强？ 是否了解公钥加密和私钥加密。 WEB应用从服务器主动推送Data到客户端有那些方式？ 对Node的优点和缺点提出了自己的看法？ 你有用过哪些前端性能优化的方法？ http状态码有那些？分别代表是什么意思？ 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好） 部分地区用户反应网站很卡，请问有哪些可能性的原因，以及解决方法？ 从打开app到刷新出内容，整个过程中都发生了什么，如果感觉慢，怎么定位问题，怎么解决? 除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？ 你用的得心应手用的熟练地编辑器&amp;开发环境是什么样子？ 对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？ 你怎么看待Web App 、hybrid App、Native App？ 你移动端前端开发的理解？（和 Web 前端开发的主要区别是什么？） 你对加班的看法？ 平时如何管理你的项目？ 说说最近最流行的一些东西吧？常去哪些网站？ 如何设计突发大规模并发架构？ 说说最近最流行的一些东西吧？常去哪些网站？ 是否了解开源的工具 bower、npm、yeoman、grunt、gulp，一个 npm 的包里的 package.json 具备的必要的字段都有哪些？（名称、版本号，依赖） 每个模块的代码结构都应该比较简单，且每个模块之间的关系也应该非常清晰，随着功能和迭代次数越来越多，你会如何去保持这个状态的？ Git知道branch, diff, merge么? 如何设计突发大规模并发架构？ 当团队人手不足，把功能代码写完已经需要加班的情况下，你会做前端代码的测试吗？ 说说最近最流行的一些东西吧？平时常去哪些网站？ 知道什么是SEO并且怎么优化么? 知道各种meta data的含义么? 移动端（Android IOS）怎么做好用户体验? 简单描述一下你做过的移动APP项目研发流程？ 你在现在的团队处于什么样的角色，起到了什么明显的作用？ 你认为怎样才是全端工程师（Full Stack developer）？ 介绍一个你最得意的作品吧？ 你有自己的技术博客吗，用了哪些技术？ 对前端安全有什么看法？ 是否了解Web注入攻击，说下原理，最常见的两种攻击（XSS 和 CSRF）了解到什么程度？ 项目中遇到国哪些印象深刻的技术难题，具体是什么问题，怎么解决？。 最近在学什么东西？ 你的优点是什么？缺点是什么？ 如何管理前端团队? 最近在学什么？能谈谈你未来3，5年给自己的规划吗？","categories":[{"name":"前端面试题","slug":"前端面试题","permalink":"https://qw8.github.io/categories/前端面试题/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qw8.github.io/tags/JavaScript/"},{"name":"HTML","slug":"HTML","permalink":"https://qw8.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://qw8.github.io/tags/CSS/"}]},{"title":"前端布局代码","slug":"interview/前端布局代码","date":"2021-01-18T10:36:27.000Z","updated":"2023-10-17T09:15:40.000Z","comments":true,"path":"/interview/qian-duan-bu-ju-dai-ma.html","link":"","permalink":"https://qw8.github.io/interview/qian-duan-bu-ju-dai-ma.html","excerpt":"","text":"左右居中 行内元素: text-align: center 定宽块状元素: 左右 margin 值为 auto 不定宽块状元素: table布局，position + transform 1234567891011121314151617181920212223/* 方案1 */.wrap &#123; text-align: center&#125;.center &#123; display: inline; /* or */ /* display: inline-block; */&#125;/* 方案2 */.center &#123; width: 100px; margin: 0 auto;&#125;/* 方案2 */.wrap &#123; position: relative;&#125;.center &#123; position: absulote; left: 50%; transform: translateX(-50%);&#125; 上下垂直居中 定高：margin，position + margin(负值) 不定高：position + transform，flex，IFC + vertical-align:middle 1234567891011121314151617181920212223242526272829303132333435363738394041/* 定高方案1 */.center &#123; height: 100px; margin: 50px 0; &#125;/* 定高方案2 */.center &#123; height: 100px; position: absolute; top: 50%; margin-top: -25px;&#125;/* 不定高方案1 */.center &#123; position: absolute; top: 50%; transform: translateY(-50%);&#125;/* 不定高方案2 */.wrap &#123; display: flex; align-items: center;&#125;.center &#123; width: 100%;&#125;/* 不定高方案3 *//* 设置 inline-block 则会在外层产生 IFC，高度设为 100% 撑开 wrap 的高度 */.wrap::before &#123; content: ''; height: 100%; display: inline-block; vertical-align: middle;&#125;.wrap &#123; text-align: center;&#125;.center &#123; display: inline-block; vertical-align: middle;&#125; 如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？ 给div设置一个宽度，然后添加margin:0 auto属性 1234div&#123; width:200px; margin:0 auto; &#125; 居中一个浮动元素 1234567891011//确定容器的宽高 宽500 高 300 的层//设置层的外边距 .div &#123; width:500px ; height:300px;//高度可以不设 margin: -150px 0 0 -250px; position:relative; //相对定位 background-color:pink; //方便看效果 left:50%; top:50%; &#125; 让绝对定位的div居中 12345678position: absolute;width: 1200px;background: none;margin: 0 auto;top: 0;left: 0;bottom: 0;right: 0; 垂直居中一个浮动元素？已知高度： 12345678910.son&#123;background-color:#ff0000;width:200px;height:200px;position:absolute;top:50%;left:50%;margin-left:-100px;margin-top:-100px;&#125; 未知高度： 1234567891011.son&#123;width: 200px;height: 200px;background-color: #ff0000;margin:auto;position: absolute;left: 0;top: 0;right: 0;bottom: 0;&#125; css3方法未知宽高 12345.father&#123;display:flex;justify-content:center;align-items:center;&#125; (详解c3div水平垂直居中：http://www.cnblogs.com/shenxiaolin/p/5387623.html) 123456789101112131415161718如何垂直居中一个&lt;img&gt;？第一种：.father&#123; display:table-cell; text-align:center; vertical-align:middle;&#125;第二种：.father&#123; height: 1000px; width: 1000px; text-align: center; margin: 0 auto; line-height: 1000px;&#125;.img&#123; vertical-align: middle;&#125; 如何垂直居中一个元素？方法一：绝对定位居中（原始版之已知元素的高宽） 12345678910.content &#123; width: 200px; height: 200px; background-color: #6699ff; position: absolute; /*父元素需要相对定位*/ top: 50%; left: 50%; margin-top: -100px; /*设为高度的1/2*/ margin-left: -100px; /*设为宽度的1/2*/&#125; 方法二：绝对定位居中（改进版之一未知元素的高宽） 123456789.content &#123; width: 200px; height: 200px; background-color: #6699ff; position: absolute; /*父元素需要相对定位*/ top: 50%; left: 50%; transform: translate(-50%, -50%); /*在水平和垂直方向上各偏移-50%*/&#125; 方法三：绝对定位居中（改进版之二未知元素的高宽） 1234567891011.content &#123; width: 200px; height: 200px; background-color: #6699ff; margin: auto; /*很关键的一步*/ position: absolute; /*父元素需要相对定位*/ left: 0; top: 0; right: 0; bottom: 0; /*让四个定位属性都为0*/&#125; 方法四：flex 布局居中 12345678910body &#123; display: flex; /*设置外层盒子display为flex*/ align-items: center; /*设置内层盒子的垂直居中*/ justify-content: center; /*设置内层盒子的水平居中*/ .content &#123; width: 200px; height: 200px; background-color: #6699ff; &#125;&#125; 那么问题来了，如何垂直居中一个 img（用更简便的方法。） 123456.content &#123; //img的容器设置如下 display: table-cell; text-align: center; vertical-align: middle;&#125; 如何居中div？ 水平居中：给div设置一个宽度，然后添加margin:0 auto属性 1234div&#123; width:200px; margin:0 auto; &#125; 让绝对定位的div居中 1234567891011div &#123; position: absolute; width: 300px; height: 300px; margin: auto; top: 0; left: 0; bottom: 0; right: 0; background-color: pink; /* 方便看效果 */&#125; 水平垂直居中一 确定容器的宽高 宽500 高 300 的层 设置层的外边距 12345678910div &#123; position: relative; /* 相对定位或绝对定位均可 */ width:500px; height:300px; top: 50%; left: 50%; margin: -150px 0 0 -250px; /* 外边距为自身宽高的一半 */ background-color: pink; /* 方便看效果 */ &#125; 水平垂直居中二 未知容器的宽高，利用 transform 属性 12345678910div &#123; position: absolute; /* 相对定位或绝对定位均可 */ width:500px; height:300px; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: pink; /* 方便看效果 */&#125; 水平垂直居中三 利用 flex 布局 实际使用时应考虑兼容性 1234567891011.container &#123; display: flex; align-items: center; /* 垂直居中 */ justify-content: center; /* 水平居中 */&#125;.container div &#123; width: 100px; height: 100px; background-color: pink; /* 方便看效果 */&#125; css垂直居中的方法有哪些？ 如果是单行文本, line-height 设置成和 height 值 1234.vertical &#123; height: 100px; line-height: 100px; &#125; 已知高度的块级子元素，采用绝对定位和负边距 123456789.container &#123; position: relative;&#125;.vertical &#123; height: 300px; /*子元素高度*/ position: absolute; top:50%; /*父元素高度50%*/ margin-top: -150px; /*自身高度一半*/&#125; 未知高度的块级父子元素居中，模拟表格布局 缺点：IE67不兼容，父级 overflow：hidden 失效 1234567.container &#123; display: table; &#125; .content &#123; display: table-cell; vertical-align: middle; &#125; 新增 inline-block 兄弟元素，设置 vertical-align 缺点：需要增加额外标签，IE67不兼容 12345678910.container &#123; height: 100%;/*定义父级高度，作为参考*/&#125;.extra .vertical&#123; display: inline-block; /*行内块显示*/ vertical-align: middle; /*垂直居中*/&#125;.extra &#123; height: 100%; /*设置新增元素高度为100%*/&#125; 绝对定位配合 CSS3 位移 12345.vertical &#123; position: absolute; top:50%; /*父元素高度50%*/ transform:translateY(-50%, -50%);&#125; CSS3弹性盒模型 12345.container &#123; display:flex; justify-content: center; /*子元素水平居中*/ align-items: center; /*子元素垂直居中*/&#125; 圣杯布局的实现原理？ 要求：三列布局；中间主体内容前置，且宽度自适应；两边内容定宽 好处：重要的内容放在文档流前面可以优先渲染 原理：利用相对定位、浮动、负边距布局，而不添加额外标签 12345678910111213141516171819202122.container &#123; padding-left: 150px; padding-right: 190px;&#125;.main &#123; float: left; width: 100%;&#125;.left &#123; float: left; width: 190px; margin-left: -100%; position: relative; left: -150px;&#125;.right &#123; float: left; width: 190px; margin-left: -190px; position: relative; right: -190px;&#125; 什么是双飞翼布局？实现原理？ 双飞翼布局：对圣杯布局（使用相对定位，对以后布局有局限性）的改进，消除相对定位布局 原理：主体元素上设置左右边距，预留两翼位置。左右两栏使用浮动和负边距归位，消除相对定位。 1234567891011121314151617181920212223242526.container &#123; /*padding-left:150px;*/ /*padding-right:190px;*/&#125;.main-wrap &#123; width: 100%; float: left;&#125;.main &#123; margin-left: 150px; margin-right: 190px;&#125;.left &#123; float: left; width: 150px; margin-left: -100%; /*position: relative;*/ /*left:-150px;*/&#125;.right &#123; float: left; width: 190px; margin-left: -190px; /*position:relative;*/ /*right:-190px;*/&#125; 用纯CSS创建一个三角形的原理是什么？ 把上、左、右三条边隐藏掉（颜色设为 transparent） 1234567#demo &#123; width: 0; height: 0; border-width: 20px; border-style: solid; border-color: transparent transparent red transparent;&#125; 左边定宽，右边自适应方案：float + margin，float + calc1234567891011121314151617/* 方案1 */ .left &#123; width: 120px; float: left;&#125;.right &#123; margin-left: 120px;&#125;/* 方案2 */ .left &#123; width: 120px; float: left;&#125;.right &#123; width: calc(100% - 120px); float: left;&#125; 左右两边定宽，中间自适应：float，float + calc, 圣杯布局（设置BFC，margin负值法），flex123456789101112131415161718192021222324252627282930313233343536373839404142434445.wrap &#123; width: 100%; height: 200px;&#125;.wrap &gt; div &#123; height: 100%;&#125;/* 方案1 */.left &#123; width: 120px; float: left;&#125;.right &#123; float: right; width: 120px;&#125;.center &#123; margin: 0 120px; &#125;/* 方案2 */.left &#123; width: 120px; float: left;&#125;.right &#123; float: right; width: 120px;&#125;.center &#123; width: calc(100% - 240px); margin-left: 120px;&#125;/* 方案3 */.wrap &#123; display: flex;&#125;.left &#123; width: 120px;&#125;.right &#123; width: 120px;&#125;.center &#123; flex: 1;&#125; 请用 CSS 实现：一个矩形内容，有投影，有圆角，hover 状态慢慢变透明1&lt;div class=\"test\"&gt;&lt;/div&gt; 1234567891011.test &#123; width: 200px; height: 100px; border-radius: 10px; box-shadow: 10px 10px 5px #888888; background-color: green; transition: 0.7s;&#125;.test:hover &#123; opacity: 0;&#125; 用纯CSS创建一个三角形的原理是什么？12345678// 把上、左、右三条边隐藏掉（颜色设为 transparent）#demo &#123; width: 0; height: 0; border-width: 20px; border-style: solid; border-color: transparent transparent red transparent;&#125; 一边固定宽度一边宽度自适应可以使用 flex 布局 复制下面的 HTML 和 CSS 代码 用浏览器打开可以看到效果 12345678910111213141516171819202122&lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;div1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;div2&quot;&gt;&lt;/div&gt;&lt;/div&gt;.wrap &#123; display: flex; justify-content: space-between;&#125;.div1 &#123; min-width: 200px;&#125;.div2 &#123; width: 100%; background: #e6e6e6;&#125;html,body,div &#123; height: 100%; margin: 0;&#125; 描述下 CSS3 里实现元素动画的方法 创建动画：@keyframes 规则 方式一：from{属性：值;} to{属性：值;} 1234567891011@keyframes myflash &#123; from &#123; width: 200px; height: 200px; &#125; to &#123; position: relative; left: 50px; transform: rotate(360deg); &#125;&#125; 方式二：0%{属性：值;} 100%{属性：值;}0% 是动画的开始，100% 是动画的完成。可以在二者之间加入 25%，50%等 1234567891011121314@keyframes myflash &#123; 0% &#123; background: red; &#125; 50% &#123; background: yellow; &#125; 75% &#123; background: green; &#125; 100% &#123; background: blue; &#125;&#125; 将动画绑定到选择器 在样式中，设置动画属性 animation，自定义动画名称和时长。 animation：动画名 时长； 此时就可以完成一个简单的动画了，要进行更多设置还需要其他属性。 123456#first &#123; animation: myflash 10s; animation-delay: 2s; animation-iteration-count: 2; animation-timing-function: ease-in;&#125; 如何用css实现瀑布流布局利用column-count和break-inside这两个CSS3属性即可，复制如下代码即可察看效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style&gt; body &#123; margin: 0; &#125; .waterfall-container &#123; /*分几列*/ column-count: 2; width: 100%; /* 列间距 */ column-gap: 10px; &#125; .waterfall-item &#123; break-inside: avoid; width: 100%; height: 100px; margin-bottom: 10px; background: #ddd; column-gap: 0; text-align: center; color: #fff; font-size: 40px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;waterfall-container&quot;&gt; &lt;div class=&quot;waterfall-item&quot; style=&quot;height: 100px&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;waterfall-item&quot; style=&quot;height: 300px&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;waterfall-item&quot; style=&quot;height: 400px&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;waterfall-item&quot; style=&quot;height: 100px&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;waterfall-item&quot; style=&quot;height: 300px&quot;&gt;5&lt;/div&gt; &lt;div class=&quot;waterfall-item&quot; style=&quot;height: 600px&quot;&gt;6&lt;/div&gt; &lt;div class=&quot;waterfall-item&quot; style=&quot;height: 400px&quot;&gt;7&lt;/div&gt; &lt;div class=&quot;waterfall-item&quot; style=&quot;height: 300px&quot;&gt;8&lt;/div&gt; &lt;div class=&quot;waterfall-item&quot; style=&quot;height: 700px&quot;&gt;9&lt;/div&gt; &lt;div class=&quot;waterfall-item&quot; style=&quot;height: 100px&quot;&gt;10&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 已知父级盒子的宽高，子级img宽高未知，想让img铺满父级盒子且图片不能变形需要用到css的object-fit属性 123456789div &#123; width: 200px; height: 200px;&#125;img &#123; object-fit: cover; width: 100%; height: 100%;&#125; 页面布局：假设高度默认100px ，请写出三栏布局，其中左栏、右栏各为300px，中间自适应。 分析： 初学者想到的答案有两种： 方法1：浮动 方法2：绝对定位 但要求你能至少写出三四种方法，才算及格。剩下的方法如下： 方法3：flexbox。移动开发里经常用到。 方法4：表格布局table。虽然已经淘汰了，但也应该了解。 方法5：网格布局 grid 方法1、浮动： 左侧设置左浮动，右侧设置右浮动即可，中间会自动地自适应。 方法2、绝对定位： 左侧设置为绝对定位， left：0px。右侧设置为绝对定位， right：0px。中间设置为绝对定位，left和right 都为300px，即可。中间的宽度会自适应。 使用article标签作为容器，包裹左、中、右三个部分。 方法1 和方法2 的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html * &#123; padding: 0px; margin: 0px; &#125; .layout &#123; margin-bottom: 150px; &#125; .layout article div &#123; /*注意，这里是设置每个小块儿的高度为100px，而不是设置大容器的高度。大容器的高度要符合响应式*/ height: 100px; &#125; /* 方法一 start */ .layout.float .left &#123; float: left; width: 300px; background: red; &#125; .layout.float .right &#123; float: right; width: 300px; background: blue; &#125; .layout.float .center &#123; background: green; &#125; /* 方法一 end */ /* 方法二 start */ .layout.absolute .left-center-right &#123; position: relative; &#125; .layout.absolute .left &#123; position: absolute; left: 0; width: 300px; background: red; &#125; /* 【重要】中间的区域，左侧定位300px，右侧定位为300px，即可完成。宽度会自使用 */ .layout.absolute .center &#123; position: absolute; left: 300px; right: 300px; background: green; &#125; .layout.absolute .right &#123; position: absolute; right: 0; width: 300px; background: blue; &#125; /* 方法二 end */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 方法一：浮动 start --&gt; &lt;!-- 输入 section.layout.float，即可生成 --&gt; &lt;section class=\"layout float\"&gt; &lt;!-- 用 article 标签包裹左、中、右三个部分 --&gt; &lt;article class=\"left-right-center\"&gt; &lt;!-- 输入 div.left+div.right+div.center，即可生成 --&gt; &lt;div class=\"left\"&gt; 我是 left &lt;/div&gt; &lt;div class=\"right\"&gt; 我是 right &lt;/div&gt; &lt;div class=\"center\"&gt; 浮动解决方案 我是 center &lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;!-- 方法一：浮动 end --&gt; &lt;section class=\"layout absolute\"&gt; &lt;article class=\"left-center-right\"&gt; &lt;div class=\"left\"&gt; 我是 left &lt;/div&gt; &lt;div class=\"right\"&gt; 我是 right &lt;/div&gt; &lt;div class=\"center\"&gt; &lt;h1&gt;绝对定位解决方案&lt;/h1&gt; 我是 center &lt;/div&gt; &lt;/article&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 方法3、flexbox布局 将左中右所在的容器设置为display: flex，设置两侧的宽度后，然后让中间的flex = 1，即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html * &#123; padding: 0; margin: 0; &#125; .layout article div &#123; height: 100px; &#125; .left-center-right &#123; display: flex; &#125; .layout.flex .left &#123; width: 300px; background: red; &#125; .layout.flex .center &#123; flex: 1; background: green; &#125; .layout.flex .right &#123; width: 300px; background: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section class=\"layout flex\"&gt; &lt;article class=\"left-center-right-\"&gt; &lt;div class=\"left\"&gt; 我是 left &lt;/div&gt; &lt;div class=\"center\"&gt; &lt;h1&gt;flex布局解决方案&lt;/h1&gt; 我是 center &lt;/div&gt; &lt;div class=\"right\"&gt; 我是 right &lt;/div&gt; &lt;/article&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 方法4、表格布局 table 设置整个容器的宽度为100%，设置三个部分均为表格，然后左边的单元格为 300px，右边的单元格为 300px，即可。中间的单元格会自适应。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html * &#123; padding: 0; margin: 0; &#125; .layout.table div &#123; height: 100px; &#125; /* 重要：设置容器为表格布局，宽度为100% */ .layout.table .left-center-right &#123; width: 100%; display: table; height: 100px; &#125; .layout.table .left-center-right div &#123; display: table-cell; /* 重要：设置三个模块为表格里的单元*/ &#125; .layout.table .left &#123; width: 300px; background: red; &#125; .layout.table .center &#123; background: green; &#125; .layout.table .right &#123; width: 300px; background: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section class=\"layout table\"&gt; &lt;article class=\"left-center-right\"&gt; &lt;div class=\"left\"&gt; 我是 left &lt;/div&gt; &lt;div class=\"center\"&gt; &lt;h1&gt;表格布局解决方案&lt;/h1&gt; 我是 center &lt;/div&gt; &lt;div class=\"right\"&gt; 我是 right &lt;/div&gt; &lt;/article&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 方法5、网格布局 grid 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html * &#123; padding: 0; margin: 0; &#125; /* 重要：设置容器为网格布局，宽度为100% */ .layout.grid .left-center-right &#123; display: grid; width: 100%; grid-template-rows: 100px; grid-template-columns: 300px auto 300px; /* 重要：设置网格为三列，并设置每列的宽度。即可。*/ &#125; .layout.grid .left &#123; background: red; &#125; .layout.grid .center &#123; background: green; &#125; .layout.grid .right &#123; background: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section class=\"layout grid\"&gt; &lt;article class=\"left-center-right\"&gt; &lt;div class=\"left\"&gt; 我是 left &lt;/div&gt; &lt;div class=\"center\"&gt; &lt;h1&gt;网格布局解决方案&lt;/h1&gt; 我是 center &lt;/div&gt; &lt;div class=\"right\"&gt; 我是 right &lt;/div&gt; &lt;/article&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 效果： 延伸：五种方法的对比 五种方法的优缺点 考虑中间模块的高度问题 兼容性问题：实际开发中，哪个最实用？ 方法1：浮动： 优点：兼容性好。 缺点：浮动会脱离标准文档流，因此要清除浮动。我们解决好这个问题即可。 方法:2：绝对定位 优点：快捷。 缺点：导致子元素也脱离了标准文档流，可实用性差。 方法3：flex 布局（CSS3中出现的） 优点：解决上面两个方法的不足，flex布局比较完美。移动端基本用 flex布局。 方法4：表格布局 优点：表格布局在很多场景中很实用，兼容性非常好。因为IE8不支持 flex，此时可以尝试表格布局 缺点：因为三个部分都当成了单元格来对待，此时，如果中间的部分变高了，其会部分也会被迫调整高度。但是，在很多场景下，我们并不需要两侧的高度增高。 什么时候用 flex布局 or 表格布局，看具体的场景。二者没有绝对的优势，也没有绝对的不足。 方法5：网格布局 CSS3中引入的布局，很好用。代码量简化了很多。 PS：面试提到网格布局，说明我们对新技术是有追求的。 延伸：如果题目中去掉高度已知 问题：题目中，如果去掉高度已知，我们往中间的模块里塞很多内容，让中间的模块撑开。会发生什么变化？哪个布局就不能用了？ 分析：其实可以这样理解，我们回去看上面的动画效果，当中间的模块变得很挤时，会发生什么效果？就是我们想要的答案。 答案是：flex 布局和表格布局可以通用，其他三个布局都不能用了。 总结 涉及到的知识点： 语义化掌握到位：每个区域用section、article代表容器、div代表块儿。如果通篇都用 div，那就是语义化没掌握好。 页面布局理解深刻。 CSS基础知识扎实。 思维灵活且积极上进。题目中可以通过网格布局来体现。 代码书写规范。注意命名。上面的代码中，没有一行代码是多的。","categories":[{"name":"前端面试题","slug":"前端面试题","permalink":"https://qw8.github.io/categories/前端面试题/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://qw8.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://qw8.github.io/tags/CSS/"},{"name":"页面布局","slug":"页面布局","permalink":"https://qw8.github.io/tags/页面布局/"}]},{"title":"前端工程化","slug":"interview/前端工程化","date":"2021-01-02T02:47:54.000Z","updated":"2024-03-29T16:16:26.000Z","comments":true,"path":"/interview/qian-duan-gong-cheng-hua.html","link":"","permalink":"https://qw8.github.io/interview/qian-duan-gong-cheng-hua.html","excerpt":"","text":"前端工程化是指将软件工程的方法和理念应用到前端开发中，以提高开发效率、保证项目质量、加快交付速度，并确保项目的可维护性和可扩展性。随着互联网技术的发展和用户需求的日益增长，前端工程化已经成为现代前端开发不可或缺的一部分。 前端工程化的关键组成部分： 模块化：将复杂的前端应用分解为独立的模块，每个模块负责一部分功能。这样可以提高代码的可读性和可维护性，便于团队协作开发。 组件化：与模块化类似，组件化是将界面拆分为独立的、可复用的组件。组件可以包含逻辑、样式和模板，使得开发更加高效。 自动化：通过自动化构建工具（如Webpack、Gulp等）来自动化执行代码编译、压缩、合并等任务，减少手动操作的错误和提高工作效率。 规范化：制定统一的编码规范和开发流程，确保团队成员按照相同的标准进行开发，提高代码质量和一致性。 版本控制：使用版本控制系统（如Git）来管理代码变更，便于追踪问题、协作开发和代码回退。 测试：编写单元测试、集成测试和端到端测试来确保代码质量，减少bug，提高软件的稳定性和可靠性。 持续集成/持续部署（CI/CD）：通过自动化流程实现代码的持续集成和持续部署，加快产品的迭代速度和交付效率。 前端工程化的工具和框架： 构建工具：Webpack、Rollup、Parcel等，用于打包、编译和优化前端资源。 任务运行器：Gulp、Grunt、NPM Scripts等，用于自动化执行重复性任务。 代码质量管理：ESLint、Prettier等，用于检查代码规范和自动格式化代码。 测试框架：Jest、Mocha、Cypress等，用于编写和执行测试用例。 版本控制工具：Git、SVN等，用于代码版本管理和团队协作。 IDE和编辑器：Visual Studio Code、WebStorm、Sublime Text等，提供代码高亮、智能提示和调试功能。 持续集成服务：Jenkins、Travis CI、GitHub Actions等，用于自动化测试和部署。 实践前端工程化的步骤： 需求分析：明确项目需求，制定合理的开发计划和里程碑。 技术选型：根据项目需求选择合适的技术栈和工具。 搭建开发环境：配置开发环境，包括IDE、版本控制、代码规范等。 编写代码：按照模块化和组件化的原则编写代码，并进行代码审查。 测试：编写测试用例，并执行自动化测试。 构建和部署：使用构建工具打包应用，并部署到生产环境。 监控和维护：监控应用性能，及时修复bug，持续优化代码。 通过前端工程化，开发者可以更加专注于创造有价值的功能和提升用户体验，而不是被繁琐的重复性工作所困扰。随着前端技术的不断进步，前端工程化也在不断地演进和完善，为开发者提供更多的便利和可能性。 前后端分离前后端分离是一种开发模式，前端负责将数据按照产品设计渲染以及调用后端接口实现产品功能，而后端则提供数据接口，功能接口。两个团队分别开发，预先设计好借口的规范和模拟数据，前端可以用mock去模拟请求到的数据，后端可以用postman模拟前端去调用接口。前后端分离的开发模式是为了让专业的人做专业的事，且现在前端和后端可以通过接口文档实现并行开发，提高开发效率。可以分服务器部署，也可以和后端接口打包在一起部署。 数据双向绑定原理：常见数据绑定的方案 Object.defineProperty（vue）：劫持数据的 getter 和 setter 脏值检测（angularjs）：通过特定事件进行轮循发布/订阅模式：通过消息发布并将消息进行订阅 MVC、MVP 与 MVVM 模式MVC 通信方式如下 视图（View）：用户界面。 传送指令到 Controller 控制器（Controller）：业务逻辑。完成业务逻辑后，要求 Model 改变状态 模型（Model）：数据保存。将新的数据发送到 View，用户得到反馈 所有通信都是单向的 MVP 通信方式如下 各部分之间的通信，都是双向的。 View 与 Model 不发生联系，都通过 Presenter 传递。 View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter 非常厚，所有逻辑都部署在那里。 首先阐述下你对 mvc 和 mvvm 的理解: 首先为什么我们会需要 MVC？因为随着代码规模越来越大，切分职责是大势所趋，还有为了后期维护方便，修改一块功能不影响其他功能。还有为了复用，因为很多逻辑是一样的。而 MVC 只是手段，终极目标是模块化和复用。 MVVMMVVM 是 Model-View-ViewModel 的缩写，是一种设计思想，由 Model、View、ViewModel 三部分构成。 Model代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。 View 代表UI 组件，它负责将数据模型转化成UI 展现出来。 ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。 在MVVM架构下，View 和 Model ，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。 ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。 在 JQuery 时期，如果需要刷新 UI 时，需要先取到对应的 DOM 再更新 UI，这样数据和业务的逻辑就和页面有强耦合 在 MVVM 中，UI 是通过数据驱动的，数据一旦改变就会相应的刷新对应的 UI，UI 如果改变，也会改变对应的数据。这种方式就可以在业务处理中只关心数据的流转，而无需直接和页面打交道。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。通信方式如下 唯一的区别是，它采用双向绑定（data-binding）：View 的变动，自动反映在 ViewModel，反之亦然。 mvvm 的优点低耦合：View 可以独立于 Model 变化和修改，同一个 ViewModel 可以被多个 View 复用；并且可以做到 View 和 Model 的变化互不影响； 可重用性：可以把一些视图的逻辑放在 ViewModel，让多个 View 复用； 独立开发：开发人员可以专注与业务逻辑和数据的开发（ViewModemvvmdi 计人员可以专注于 UI(View)的设计； 可测试性：清晰的 View 分层，使得针对表现层业务逻辑的测试更容易，更简单。 参考链接： MVVM的优点和缺点 MVVM架构的优缺点 mvvm 和 mvc 区别？它和其它框架（jquery）的区别是什么？哪些场景适合？ mvc 和 mvvm 其实区别并不大。都是一种设计思想。主要就是 mvc 中 Controller 演变成 mvvm 中的 viewModel。mvvm 主要解决了 mvc 中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。 区别：vue 数据驱动，通过数据来显示视图层而不是节点操作。 场景：数据操作比较多的场景，更加便捷。 什么是 MVC/MVP/MVVM/Flux？MVC(Model-View-Controller) V-&gt;C, C-&gt;M, M-&gt;V 通信都是单向的；C只起路由作用，业务逻辑都部署在V Backbone MVP(Model-View-Presenter) V&lt;-&gt;P, P&lt;-&gt;M 通信都是双向的；V和M不发生联系(通过P传)；V非常薄，逻辑都部署在P Riot.js MVVM(Model-View-ViewModel) V-&gt;VM, VM&lt;-&gt;M 采用双向数据绑定：View 和 ViewModel 的变动都会相互映射到对象上面 Angular Flux(Dispatcher-Store-View) Action-&gt;Dispatcher-&gt;Store-&gt;View, View-&gt;Action Facebook 为了解决在 MVC 应用中碰到的工程性问题提出一个架构思想 基于一个简单的原则：数据在应用中单向流动（单向数据流） React(Flux 中 View，只关注表现层) MVVM在 MVVM 中，最核心的也就是数据双向绑定，例如 Angluar 的脏数据检测，Vue 中的数据劫持。 脏数据检测 当触发了指定事件后会进入脏数据检测，这时会调用 $digest 循环遍历所有的数据观察者，判断当前值是否和先前的值有区别，如果检测到变化的话，会调用 $watch 函数，然后再次调用 $digest 循环直到发现没有变化。循环至少为二次 ，至多为十次 脏数据检测虽然存在低效的问题，但是不关心数据是通过什么方式改变的，都可以完成任务，但是这在 Vue 中的双向绑定是存在问题的。并且脏数据检测可以实现批量检测出更新的值，再去统一更新 UI，大大减少了操作 DOM 的次数 数据劫持 Vue 内部使用了 Obeject.defineProperty() 来实现双向绑定，通过这个函数可以监听到 set 和 get的事件 12345678910111213141516171819202122232425262728293031var data = &#123; name: 'yck' &#125;observe(data)let name = data.name // -&gt; get valuedata.name = 'yyy' // -&gt; change valuefunction observe(obj) &#123; // 判断类型 if (!obj || typeof obj !== 'object') &#123; return &#125; Object.keys(data).forEach(key =&gt; &#123; defineReactive(data, key, data[key]) &#125;)&#125;function defineReactive(obj, key, val) &#123; // 递归子属性 observe(val) Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter() &#123; console.log('get value') return val &#125;, set: function reactiveSetter(newVal) &#123; console.log('change value') val = newVal &#125; &#125;)&#125; 以上代码简单的实现了如何监听数据的 set 和 get 的事件，但是仅仅如此是不够的，还需要在适当的时候给属性添加发布订阅 123&lt;div&gt; &#123;&#123;name&#125;&#125;&lt;/div&gt; 在解析如上模板代码时，遇到 就会给属性 name 添加发布订阅 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 通过 Dep 解耦class Dep &#123; constructor() &#123; this.subs = [] &#125; addSub(sub) &#123; // sub 是 Watcher 实例 this.subs.push(sub) &#125; notify() &#123; this.subs.forEach(sub =&gt; &#123; sub.update() &#125;) &#125;&#125;// 全局属性，通过该属性配置 WatcherDep.target = nullfunction update(value) &#123; document.querySelector('div').innerText = value&#125;class Watcher &#123; constructor(obj, key, cb) &#123; // 将 Dep.target 指向自己 // 然后触发属性的 getter 添加监听 // 最后将 Dep.target 置空 Dep.target = this this.cb = cb this.obj = obj this.key = key this.value = obj[key] Dep.target = null &#125; update() &#123; // 获得新值 this.value = this.obj[this.key] // 调用 update 方法更新 Dom this.cb(this.value) &#125;&#125;var data = &#123; name: 'yck' &#125;observe(data)// 模拟解析到 `&#123;&#123;name&#125;&#125;` 触发的操作new Watcher(data, 'name', update)// update Dom innerTextdata.name = 'yyy' 接下来,对 defineReactive 函数进行改造 1234567891011121314151617181920212223function defineReactive(obj, key, val) &#123; // 递归子属性 observe(val) let dp = new Dep() Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter() &#123; console.log('get value') // 将 Watcher 添加到订阅 if (Dep.target) &#123; dp.addSub(Dep.target) &#125; return val &#125;, set: function reactiveSetter(newVal) &#123; console.log('change value') val = newVal // 执行 watcher 的 update 方法 dp.notify() &#125; &#125;)&#125; 以上实现了一个简易的双向绑定，核心思路就是手动触发一次属性的 getter 来实现发布订阅的添加 Proxy 与 Obeject.defineProperty 对比 Obeject.defineProperty 虽然已经能够实现双向绑定了，但是他还是有缺陷的。 只能对属性进行数据劫持，所以需要深度遍历整个对象 对于数组不能监听到数据的变化 虽然 Vue 中确实能检测到数组数据的变化，但是其实是使用了 hack 的办法，并且也是有缺陷的 解释下 Object.defineProperty()方法答案：这是 js 中一个非常重要的方法，ES6 中某些方法的实现依赖于它，VUE 通过它实现双向绑定，此方法会直接在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象 语法 Object.defineProperty(object, attribute, descriptor) 这三个参数都是必输项 第一个参数为 目标对象 第二个参数为 需要定义的属性或者方法 第三个参数为 目标属性所拥有的特性 descriptor 前两个参数都很明确，重点是第三个参数 descriptor， 它有以下取值 value: 属性的值 writable: 属性的值是否可被重写（默认为 false） configurable: 总开关，是否可配置，若为 false, 则其他都为 false（默认为 false） enumerable: 属性是否可被枚举（默认为 false） get: 获取该属性的值时调用 set: 重写该属性的值时调用 一个例子 1234567891011var a = &#123;&#125;;Object.defineProperty(a, \"b\", &#123; value: 123&#125;);console.log(a.b); //123a.b = 456;console.log(a.b); //123a.c = 110;for (item in a) &#123; console.log(item, a[item]); //c 110&#125; 因为 writable 和 enumerable 默认值为 false, 所以对 a.b 赋值无效，也无法遍历它 configurable 总开关，是否可配置，设置为 false 后，就不能再设置了，否则报错， 例子 12345678var a = &#123;&#125;;Object.defineProperty(a, \"b\", &#123; configurable: false&#125;);Object.defineProperty(a, \"b\", &#123; configurable: true&#125;);//error: Uncaught TypeError: Cannot redefine property: b writabl 是否可重写 12345678var a = &#123;&#125;;Object.defineProperty(a, \"b\", &#123; value: 123, writable: false&#125;);console.log(a.b); // 打印 123a.b = 25; // 没有错误抛出（在严格模式下会抛出，即使之前已经有相同的值）console.log(a.b); // 打印 123， 赋值不起作用。 enumerable 属性特性 enumerable 定义了对象的属性是否可以在 for…in 循环和 Object.keys() 中被枚举 123456var a = &#123;&#125;;Object.defineProperty(a, \"b\", &#123; value: 3445, enumerable: true&#125;);console.log(Object.keys(a)); // 打印[\"b\"] enumerable 改为 false 123456var a = &#123;&#125;;Object.defineProperty(a, \"b\", &#123; value: 3445, enumerable: false //注意咯这里改了&#125;);console.log(Object.keys(a)); // 打印[] set 和 get 如果设置了 set 或 get, 就不能设置 writable 和 value 中的任何一个，否则报错 12345678var a = &#123;&#125;;Object.defineProperty(a, \"abc\", &#123; value: 123, get: function() &#123; return value; &#125;&#125;);//Uncaught TypeError: Invalid property descriptor. Cannot both specify accessors and a value or writable attribute, #&lt;Object&gt; at Function.defineProperty 对目标对象的目标属性 赋值和取值 时， 分别触发 set 和 get 方法 12345678910111213141516var a = &#123;&#125;;var b = 1;Object.defineProperty(a, \"b\", &#123; set: function(newValue) &#123; b = 99; console.log(\"你要赋值给我,我的新值是\" + newValue); &#125;, get: function() &#123; console.log(\"你取我的值\"); return 2; //注意这里，我硬编码返回2 &#125;&#125;);a.b = 1; //打印 你要赋值给我,我的新值是1console.log(b); //打印 99console.log(a.b); //打印 你取我的值//打印 2 注意这里，和我的硬编码相同的 上面的代码中，给 a.b 赋值，b 的值也跟着改变了。原因是给 a.b 赋值，自动调用了 set 方法，在 set 方法中改变了 b 的值。vue 双向绑定的原理就是这个。 扩展：参考 什么是单页面应用(SPA)？ 单页面应用(SPA)是指用户在浏览器加载单一的HTML页面，后续请求都无需再离开此页 目标：旨在用为用户提供了更接近本地移动APP或桌面应用程序的体验。 流程：第一次请求时，将导航页传输到客户端，其余请求通过 REST API 获取 JSON 数据 实现：数据的传输通过 Web Socket API 或 RPC(远程过程调用)。 优点：用户体验流畅，服务器压力小，前后端职责分离 缺点：关键词布局难度加大，不利于 SEO 多页面（MPA）开发 VS 单页面（SPA）开发jQuery + Bootstrap 多页面应用： 优点： 数据可以直接渲染，对于搜索引擎（SEO）友好 BootStrap 对移动端和PC端界面展示都很友好 后期维护方便，成本低，易上手 缺点： 页面之间传递数据比较局限，可以URL/Cookie/Storage等方式吧 资源请求较多，不过就现在这个网速情况，大部分没有问题 Vue + ElementUI（BootStrap）单页面应用：（后台管理系统） 优点： 可以组件化，数据绑定。方便定义页面的各种逻辑和改变页面数据 路由之间跳转可以定制动画，使用懒加载，减少白屏时间；相比对多页面，减少了请求服务器加载静态资源的次数 页面之间可以通信 缺点 初始加载较大且多的静态资源(因为需要进行代码编译)，业务增长，项目加载时间越大 因为前后端分离，数据通过Ajax获取，网页爬虫抓取不到页面数据，不利于搜索引擎搜索，SEO不友好 ElementUI 基本不支持移动端设备的展示,BootStrap虽然支持移动端，但是综合考虑用多页面比较好 后期维护方便，但是成本高 什么是“前端路由”?什么时候适合使用“前端路由”? “前端路由”有哪些优点和缺点? 什么是前端路由？ 路由是根据不同的 url 地址展示不同的内容或页面 前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前是通过服务端根据 url 的不同返回不同的页面实现的。 什么时候使用前端路由？ 在单页面应用，大部分页面结构不变，只改变部分内容的使用 前端路由有什么优点和缺点？ 优点 用户体验好，不需要每次都从服务器全部获取，快速展现给用户 缺点 使用浏览器的前进，后退键的时候会重新发送请求，没有合理地利用缓存 单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置 什么是“前端路由”? 什么时候适用“前端路由”? 有哪些优点和缺点? 前端路由通过 URL 和 History 来实现页面切换 应用：前端路由主要适用于“前后端分离”的单页面应用(SPA)项目 优点：用户体验好，交互流畅 缺点：浏览器“前进”、“后退”会重新请求，无法合理利用缓存 虚拟节点（VDOM）：三个 part 虚拟节点类，将真实 DOM节点用 js 对象的形式进行展示，并提供 render 方法，将虚拟节点渲染成真实 DOM 节点 diff 比较：对虚拟节点进行 js 层面的计算，并将不同的操作都记录到 patch 对象 re-render：解析 patch 对象，进行 re-render 补充1：VDOM 的必要性？ 创建真实DOM的代价高：真实的 DOM 节点 node 实现的属性很多，而 vnode 仅仅实现一些必要的属性，相比起来，创建一个 vnode 的成本比较低。 触发多次浏览器重绘及回流：使用 vnode ，相当于加了一个缓冲，让一次数据变动所带来的所有 node 变化，先在 vnode 中进行修改，然后 diff 之后对所有产生差异的节点集中一次对 DOM tree 进行修改，以减少浏览器的重绘及回流。 补充2：vue 为什么采用 vdom？ 引入 Virtual DOM 在性能方面的考量仅仅是一方面。 性能受场景的影响是非常大的，不同的场景可能造成不同实现方案之间成倍的性能差距，所以依赖细粒度绑定及 Virtual DOM 哪个的性能更好还真不是一个容易下定论的问题。 Vue 之所以引入了 Virtual DOM，更重要的原因是为了解耦 HTML依赖，这带来两个非常重要的好处是： 不再依赖 HTML 解析器进行模版解析，可以进行更多的 AOT 工作提高运行时效率：通过模版 AOT 编译，Vue 的运行时体积可以进一步压缩，运行时效率可以进一步提升； 可以渲染到 DOM 以外的平台，实现 SSR、同构渲染这些高级特性，Weex等框架应用的就是这一特性。 综上，Virtual DOM 在性能上的收益并不是最主要的，更重要的是它使得 Vue 具备了现代框架应有的高级特性。 vue 和 react 区别 相同点：都支持 ssr，都有 vdom，组件化开发，实现 webComponents 规范，数据驱动等 不同点：vue 是双向数据流（当然为了实现单数据流方便管理组件状态，vuex 便出现了），react 是单向数据流。vue的 vdom 是追踪每个组件的依赖关系，不会渲染整个组件树，react 每当应该状态被改变时，全部子组件都会 re-render 模块化开发怎么做？ 封装对象作为命名空间 – 内部状态可以被外部改写 立即执行函数(IIFE) – 需要依赖多个JS文件，并且严格按顺序加载 使用模块加载器 – require.js, sea.js, EC6 模块 模块化开发怎么做？ AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。 CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。 AMD 是提前执行，CMD 是延迟执行。 AMD 推荐的风格通过返回一个对象做为模块对象，CommonJS 的风格通过对 module.exports 或 exports 的属性赋值来达到暴露模块对象的目的。 CMD 模块方式 123define(function(require, exports, module) &#123; // 模块代码&#125;); 模块化开发怎么做？立即执行函数,不暴露有成员 12345678910111213var module1 = (function()&#123; var _count = 0; var m1 = function()&#123; //... &#125;; var m2 = function()&#123; //... &#125;; return &#123; m1 : m1, m2 : m2 &#125;; &#125;)(); 通行的 Javascript 模块的规范有哪些？ CommonJS – 主要用在服务器端 node.js 12var math = require('./math');math.add(2,3); AMD(异步模块定义) – require.js 123require(['./math'], function (math) &#123; math.add(2, 3);&#125;); CMD(通用模块定义) – sea.js 12var math = require('./math');math.add(2,3); ES6 模块 12import &#123;math&#125; from './math';math.add(2, 3); 说说你对AMD和Commonjs的理解 CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数 AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的 AMD 与 CMD 规范的区别？规范化产出： AMD 由 RequireJS 推广产出 CMD 由 SeaJS 推广产出 模块的依赖: AMD 提前执行，推崇依赖前置 CMD 延迟执行，推崇依赖就近 API 功能: AMD 的 API 默认多功能（分全局 require 和局部 require） CMD 的 API 推崇职责单一纯粹（没有全局 require） 模块定义规则： AMD 默认一开始就载入全部依赖模块 1234define(['./a', './b'], function(a, b) &#123; a.doSomething(); b.doSomething();&#125;); CMD 依赖模块在用到时才就近载入 123456define(function(require, exports, module) &#123; var a = require('./a'); a.doSomething(); var b = require('./b'); b.doSomething();&#125;) AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？Asynchronous Module Definition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中 区别： 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible CMD 推崇依赖就近，AMD 推崇依赖前置。看代码： 1234567891011121314151617// CMDdefine(function(require, exports, module) &#123; var a = require(&apos;./a&apos;) a.doSomething() // 此处略去 100 行 var b = require(&apos;./b&apos;) // 依赖可以就近书写 b.doSomething() // ...&#125;)// AMD 默认推荐define([&apos;./a&apos;, &apos;./b&apos;], function(a, b) &#123; // 依赖必须一开始就写好 a.doSomething() // 此处略去 100 行 b.doSomething() // ...&#125;) 介绍类库和框架的区别？类库是一些函数的集合，帮助开发者写WEB应用，起主导作用的是开发者的代码 框架是已实现的特殊WEB应用，开发者只需对它填充具体的业务逻辑，起主导作用是框架 请你详细介绍一些 package.json 里面的配置scripts：npm run xxx 命令调用node执行的 .js 文件 dependencies：生产环境依赖包的名称和版本号，即这些 依赖包 都会打包进 生产环境的JS文件里 devDependencies：开发环境依赖包的名称和版本号，即这些 依赖包 只用于 代码开发 的时候，不会打包进 生产环境js文件 里面。 WEB 应用从服务器主动推送 Data 到客户端有那些方式？ html5 websoket WebSocket 通过 Flash XHR 长时间连接 XHR Multipart Streaming 不可见的 Iframe &lt;script&gt;标签的长时间连接(可跨域) 什么是响应式设计？它是关于网页制作的过程中让不同的设备有不同的尺寸和不同的功能。响应式设计是让所有的人能在这些设备上让网站运行正常 模块化的工具参考链接：常用模块化方案 webpack打包优化参考链接：webpack打包体积优化 设计一个自己的打包工具需要设计哪些主要功能参考链接：前端打包工具 介绍webpack是什么？ 有什么优势？WebPack 是一款[模块加载器]兼[打包工具]，用于把各种静态资源（js/css/image等）作为模块来使用。 WebPack 是一个模块打包工具，你可以使用 WebPack 管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包 Web 开发中所用到的 HTML、JavaScript、CSS 以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack 有对应的模块加载器。webpack 模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源。 WebPack 的优势： WebPack 同时支持 commonJS 和 AMD/CMD，方便代码迁移 不仅仅能被模块化 JS ，还包括 CSS、Image 等 能替代部分 grunt/gulp 的工作，如打包、压缩混淆、图片base64 扩展性强，插件机制完善，特别是支持 React 热插拔的功能 webpack 的两大特色 code splitting（可以自动完成） loader 可以处理各种类型的静态文件，并且支持串联操作 webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。 webpack 具有 requireJs 和 browserify 的功能，但仍有很多自己的新特性： 对 CommonJS 、 AMD 、ES6 的语法做了兼容 对 js、css、图片等资源文件都支持打包 串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对 CoffeeScript、ES6 的支持 有独立的配置文件 webpack.config.js 可以将代码切割成不同的 chunk，实现按需加载，降低了初始化时间 支持 SourceUrls 和 SourceMaps，易于调试 具有强大的 Plugin 接口，大多是内部插件，使用起来比较灵活 webpack 使用异步 IO 并具有多级缓存。这使得 webpack 很快且在增量编译上更加快 平时如何管理你的项目？ 先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等； 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）； 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）； 页面进行标注（例如 页面 模块 开始和结束）； CSS 跟 HTML 分文件夹并行存放，命名都得统一（例如 style.css）； JS 分文件夹存放 命名以该 JS 功能为准的英文翻译。 图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理 项目开发经历了哪几个阶段 需求分析及变更管理 项目模型及业务流程分析 系统分析及建模设计 界面设计及代码开发 系统测试，部署和文档编写 维护 怎么提高首屏加载速度服务端渲染等 首屏、白屏时间如何计算？Performance 接口可以获取到当前页面中与性能相关的信息。该类型的对象可以通过调用只读属性 Window.performance 来获得。白屏时间： 1performance.timing.responseStart - performance.timing.navigationStart 首屏时间 123window.onload = () =&gt; &#123; new Date() - performance.timing.responseStart&#125; 解析：参考 requireJS的核心原理是什么？每个模块所依赖模块都会比本模块预先加载 什么是 npm ？npm 是 Node.js 的模块管理和发布工具 什么是 WebKit ？ WebKit 是一个开源的浏览器内核，由渲染引擎(WebCore)和JS解释引擎(JSCore)组成 通常所说的 WebKit 指的是 WebKit(WebCore)，主要工作是进行 HTML/CSS 渲染 WebKit 一直是 Safari 和 Chrome(之前) 使用的浏览器内核，后来 Chrome 改用Blink 内核 如何测试前端代码? 知道 Unit Test，BDD, TDD 么? 怎么测试你的前端工程(mocha, jasmin..)? 通过为前端代码编写单元测试(Unit Test)来测试前端代码 Unit Test：一段用于测试一个模块或接口是否能达到预期结果的代码 BDD：行为驱动开发 – 业务需求描述产出产品代码的开发方法 TDD：测试驱动开发 – 单元测试用例代码产出产品代码的开发方法 单元测试框架： 12345678910111213// mocha 示例describe('Test add', function() &#123; it('1 + 2 = 3', function() &#123; expect(add(1, 2)).to.be.equal(3); &#125;);&#125;);// jasmin 示例describe('Test add', function () &#123; it('1 + 2 = 3', function () &#123; expect(add(1, 2)).toEqual(3); &#125;);&#125;); 介绍你知道的前端模板引擎？artTemplate, underscore, handlebars 什么是 Modernizr？ Modernizr 工作原理？Modernizr 是一个开源的 JavaScript 库，用于检测用户浏览器对 HTML5 与 CSS3 的支持情况 移动端最小触控区域是多大？44 * 44 px 移动端的点击事件的延迟时间是多长，为什么会有延迟？ 如何解决这个延时？移动端 click 有 300ms 延迟，浏览器为了区分“双击”（放大页面）还是“单击”而设计 解决方案： 禁用缩放(对safari无效) 使用指针事件(IE私有特性，且仅IE10+) 使用 Zepto 的 tap 事件(有点透BUG) 使用 FastClick 插件(体积大[压缩后8k]) 什么是函数式编程？函数式编程是一种”编程范式”，主要思想是把运算过程尽量写成一系列嵌套的函数调用 例如：var result = subtract(multiply(add(1,2), 3), 4); 函数式编程的特点： 函数核心化：函数可以作为变量的赋值、另一函数的参数、另一函数的返回值 只用“表达式”，不用“语句”：要求每一步都是单纯的运算，都必须有返回值 没有”副作用”：所有功能只为返回一个新的值，不修改外部变量 引用透明：运行不依赖于外部变量，只依赖于输入的参数 函数式编程的优点： 代码简洁，接近自然语言，易于理解 便于维护，利于测试、除错、组合 易于“并发编程“，不用担心一个线程的数据，被另一个线程修改 可“热升级”代码，在运行状态下直接升级代码，不需要重启，也不需要停机 什么是函数柯里化Currying)？通常也称部分求值，含义是给函数分步传递参数，每次递参部分应用参数，并返回一个更具体的函数，继续接受剩余参数。期间会连续返回具体函数，直至返回最后结果。因此，函数柯里化是逐步传参，逐步缩小函数的适用范围，逐步求解的过程。 柯里化的作用：延迟计算；参数复用；动态创建函数； 柯里化的缺点：函数柯里化会产生开销（函数嵌套，比普通函数占更多内存），但性能瓶颈首先来自其它原因（DOM 操作等） 什么是依赖注入？ 当一个类的实例依赖另一个类的实例时，自己不创建该实例，由IOC容器创建并注入给自己，因此称为依赖注入。 依赖注入解决的就是如何有效组织代码依赖模块的问题 设计模式：什么是 singleton, factory, strategy, decorator？ Singleton(单例) 一个类只有唯一实例，这个实例在整个程序中有一个全局的访问点 Factory (工厂) 解决实列化对象产生重复的问题 Strategy(策略) 将每一个算法封装起来，使它们还可以相互替换，让算法独立于使用 Observer(观察者) 多个观察者同时监听一个主体，当主体对象发生改变时，所有观察者都将得到通知 Prototype(原型) 一个完全初始化的实例，用于拷贝或者克隆 Adapter(适配器) 将不同类的接口进行匹配调整，尽管内部接口不兼容，不同的类还是可以协同工作 Proxy(代理模式) 一个充当过滤转发的对象用来代表一个真实的对象 Iterator(迭代器) 在不需要直到集合内部工作原理的情况下，顺序访问一个集合里面的元素 Chain of Responsibility(职责连) 处理请求组成的对象一条链，请求链中传递，直到有对象可以处理 什么是前端工程化？前端工程化就是把一整套前端工作流程使用工具自动化完成 前端开发基本流程： 项目初始化：yeoman, FIS 引入依赖包：bower, npm 模块化管理：npm, browserify, Webpack 代码编译：babel, sass, less 代码优化(压缩/合并)：Gulp, Grunt 代码检查：JSHint, ESLint 代码测试：Mocha 目前最知名的构建工具：Gulp, Grunt, npm + Webpack 介绍 Yeoman 是什么？Yeoman –前端开发脚手架工具，自动将最佳实践和工具整合起来构建项目骨架 Yeoman 其实是三类工具的合体，三类工具各自独立： yo — 脚手架，自动生成工具（相当于一个粘合剂，把 Yeoman 工具粘合在一起） Grunt、gulp — 自动化构建工具 （最初只有grunt，之后加入了gulp） Bower、npm — 包管理工具 （原来是bower，之后加入了npm） Backbone 是什么？Backbone 是一个基于 jquery 和 underscore 的前端(MVC)框架 AngularJS 是什么？AngularJS 是一个完善的前端 MVVM 框架，包含模板、数据双向绑定、路由、模块化、服务、依赖注入等 AngularJS 由 Google 维护，用来协助大型单一页面应用开发。 如何评价AngularJS和BackboneJS backbone具有依赖性，依赖underscore.js。Backbone + Underscore + jQuery(or Zepto)就比一个AngularJS 多出了2 次HTTP请求. Backbone的Model没有与UI视图数据绑定，而是需要在View中自行操作DOM来更新或读取UI数据。AngularJS与此相反，Model直接与UI视图绑定，Model与UI视图的关系，通过directive封装，AngularJS内置的通用directive，就能实现大部分操作了，也就是说，基本不必关心Model与UI视图的关系，直接操作Model就行了，UI视图自动更新 AngularJS的directive，你输入特定数据，他就能输出相应UI视图。是一个比较完善的前端MVW框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，并且是声明式的，自带了丰富的 Angular 指令 Meteor 是什么 Meteor 是一个全栈开发框架，基础构架是 Node.JS + MongoDB，并把延伸到了浏览器端。 Meteor 统一了服务器端和客户端的数据访问，使开发者可以轻松完成全栈式开发工作。 前端异常监控一：前端异常监控系统的构建目标 在对被监控页面无侵入的前提下，提供7*24小时全天候的监控任务，第一时间发现“裸奔”、“半裸奔”页面或是有JavaScript异常抛出的页面，并给网站前端负责人提供短信、邮件等方式的报警服务。 可以说，前端异常监控系统主要是解决两大异常情况：a. 页面上有javascript异常 b. 各种因素造成的页面的样式丢失。我先分别介绍下两种这两种异常的解决思路： 二：JavaScript的异常监控 由于客户端浏览器环境的不同，在开发环境中能够工作的代码，并非就能够在用户的电脑上正常运行，各种畸形浏览器造成的问题弄得我们很头大，如果能像后端开发那样可以随时地查看服务器端错误日志就好了！可为什么不呢？ JavaScript语言自身就提供了try catch的异常处理语法，我们假以利用的话，就能够在增强前端应用鲁棒性的同时，又可以把捕获到的异常抛送给前端异常监控系统，以错误日志的形式记录到数据库中。 给应用添加异常处理功能，我们是可以充分发挥javascript语言是动态语言这一优势的。我可不想为了添加异常处理而在代码中写N多的try-catch语句。 我的思路是：通过JavaScript类模块在应用中注册的时候，遍历类模块中的每个函数，然后统一的加上try-catch处理，这样前端里面的所有函数就都在异常处理的范围之内了。怎么样，是不是要比Java等静态语言cool很多？ 代码示例如下： 构建web前端异常监控系统–FdSafe 有了以上的全局异常处理函数之后，解决线上的JavaScript异常就是小菜一碟，只需要定义好错误message的格式，并在catch语句中向异常监控系统的固定接口发送请求即可。我们可以在错误消息中发送关于错误的浏览器信息，JS模块信息，函数信息，或具体的错误消息等，要传送哪些信息全看你自己的需要。在FdSafe异常监控系统中，我们传输了如下错误信息： 构建web前端异常监控系统–FdSafe 三：样式丢失的异常监控 如果你的页面在不该裸奔的时候突然裸奔了，那就是严重的可用性问题，需要前端同学在第一时间定位问题并迅速修复。引发“裸奔”的可能性很多，也许是CSS文件404了，也许是CSS文件@import url的问题，但是最终的表象只有一个，那就是页面样式突然发生极大改变。 在fdsafe系统中，我们使用了图片对比的方法来探测线上页面发生“裸奔”的现象，原理上很简单：对于被监控页面的URL，我们让监控系统保留其前一天页面被浏览器渲染后的截图，然后让监控系统周期性的定时抓取线上页面的截图，两张图片做相似度对比，如果相似度差值超过一定的阈值，则会触发报警条件。 页面的截图我们是使用QT的webkit内核渲染并截取的，当然也推荐使用selenium的浏览器截图功能。而图片相似度的算法很多，我们最终采用的是OpenCV中的cvCompareHist算法。 四：其它的异常监控 除了样式丢失及javascript异常之外，前端还是有很多其它异常可以通过系统来监控的，比如说JS、CSS文件的404错误，HTML源码的闭合异常，或JS、CSS文件的压缩异常等。fdSafe系统能够通过添加插件的方式来提供对不同异常的监控，然后统一汇总到异常日志中。 五：系统总体框架图 搭建前端的异常监控系统，自然也要体现我们前端的特色，后台的系统我们是基于NodeJS来实现的，它主要完成两个功能： 1）定时抓取被监控页面的HTML源码，并分析是否存在页面样式丢失异常或是其它异常。 2）接受来自用户浏览器发送的JavaScript异常。 一旦异常发生，且超出设定的允许阈值，则触发报警条件，给负责人发送报警短信，系统原理图如下： 构建web前端异常监控系统–FdSafe Ascii、GBK、UTF、UnicodeAscii（1 个字节 1 个字符） GBK 是国内的编码标准（汉字 2 个字节） Unicode 是国际编码标准（统一 2 个字节表示一个字符） UTF 是 Unicode 实现的另一个标准 unicode 同样也不完美，这里就有两个的问题，一个是，如何才能区别 unicode 和 ascii？由于”半角”英文符号只需要用到低 8 位，所以其高 8 位永远是 0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间unicode 在很长一段时间内无法推广，直到互联网的出现，为解决 unicode 如何在网络上传输的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF-8 就是每次 8 个位传输数据，而 UTF-16 就是每次 16 个位。UTF-8 就是在互联网上使用最广的一种 unicode 的实现方式，这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用 1~4 个字节表示一个符号，根据不同的符号而变化字节长度，当字符在 ASCII 码的范围时，就用一个字节表示，保留了 ASCII 字符一个字节的编码做为它的一部分，注意的是 unicode 一个中文字符占 2 个字节，而 UTF-8 一个中文字符占 3 个字节）。从 unicode 到 utf-8 并不是直接的对应，而是要过一些算法和规则来转换。 解析：参考 请谈谈你对Node.js技术及其生态的理解，并举例说明你如何在实际项目中利用webpack、Vite等构建打包工具提高开发效率的。 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时环境，它具有高效的异步 I/O 和事件驱动模型，适用于构建服务器端应用程序。其生态丰富，有许多常用的库和框架。 在实际项目中，可以利用 webpack 或 Vite 等构建打包工具，将多个模块和资源打包成一个或多个文件，提高开发效率。例如，使用 webpack 的模块化和代码分割功能，按需加载模块，减少初始加载时间。Vite 则通过即时编译提供了更快速的开发体验。 分享一次你独立开发前端项目的经验，特别是在技术架构设计、组件封装和维护方面的工作。你是如何确保项目的稳定交付的？ 在独立开发前端项目时，我注重技术架构的设计，选择合适的前端框架和工具。通过组件封装，提高代码复用性和可维护性。在维护方面，进行代码审查、测试和持续集成，确保项目稳定交付。例如，使用版本控制系统管理代码变更，及时修复 Bug，并定期更新文档，以便团队成员更好地理解和维护项目。 请详细描述一次你使用ES6/ES7或TypeScript进行项目开发的经历，包括你是如何应用这些技术来解决具体问题的。 在项目开发中，使用 ES6/ES7 的特性，如箭头函数、模板字符串和模块化，提高代码的可读性和简洁性。TypeScript 的静态类型检查和面向对象编程特性帮助我在开发过程中更早地发现错误，并构建更健壮的代码结构。例如，通过定义接口和类型注解，明确函数和变量的类型，从而提高代码的可维护性和可扩展性。","categories":[{"name":"前端面试题","slug":"前端面试题","permalink":"https://qw8.github.io/categories/前端面试题/"}],"tags":[{"name":"MVVM","slug":"MVVM","permalink":"https://qw8.github.io/tags/MVVM/"},{"name":"模块化","slug":"模块化","permalink":"https://qw8.github.io/tags/模块化/"},{"name":"前端异常监控","slug":"前端异常监控","permalink":"https://qw8.github.io/tags/前端异常监控/"}]},{"title":"前端简历","slug":"interview/前端简历","date":"2020-12-21T06:38:24.000Z","updated":"2023-04-14T17:01:50.000Z","comments":true,"path":"/interview/qian-duan-jian-li.html","link":"","permalink":"https://qw8.github.io/interview/qian-duan-jian-li.html","excerpt":"","text":"如今前端市场一片混乱，典型的金字塔形状，前端从业人员很多，但高级开发及以上却非常稀缺。前端招聘也是所有猎头及 HR 的痛点所在，在这种混乱的环境中，如何让自己突出重围？需要实力，也需要技巧。这里的技巧指的就是如何写一份好的前端简历 注意事项开发者最好像做项目一样维护一份自己的简历，需要的时候直接丢出去。很多同学跳槽一次，抓耳捞腮的写一次，简历质量可想而知。可以每做一个项目或者每有一段收获都整理一下，浓缩在简历里。实际写简历中可以按照以下方式写2-3家，项目经验也一样可以多写几个。不管工作经历还是项目经验都不需要过于冗余，多写精品。真正的一份好技术简历，不是在于内容有多少，而是你的内容到底是否有逼格！ 简历页数：2页最佳； 文件格式：word和pdf，推荐pdf； 文件名字：李四-高级前端开发-3年.pdf； 简历照片：不要附加照片； 文档字体：通常来说选用宋体5号字，正文行间距在1.2左右； 联系方式：不要在简历中写自己的微信号、QQ号。联系方式只留下一个邮箱和手机号即可。邮箱最好是126、163、outlook或者gmail，不建议使用qq邮箱； 标题如：李四的个人简历 个人信息123456姓名：李四 性别：男毕业院校：xx学校/xxx专业工作年限：3年应聘职位：前端开发GitHub地址：https://github.com/xxx（此处可选其他技术站点）联系邮箱：xxx@163.com 专业技能1234563年web开发设计经验，具有多端（H5，Native App，微信小程序，Nodejs服务端）开发能力；熟练原生JavaScript语言并有开发公用组件的经验，对于主流框架Vue.js及React.js有3个以上大型项目开发经验；熟悉性能优化，对于webpack等前端工程化解决方案有较深的涉及；熟悉产品设计研发上线以及版本迭代流程和项目管理流程；.....总之要多写自己的强项！ 工作经历12345678910111213141516172016/09 - 至今 XXX公司 | WEB高级前端岗位职责：负责前端项目需求分析，技术选型，项目架构搭建和整体业务流程把控；负责项目中所以公用代码的封装及优化，制定规范的代码结构；配合后端完成项目中测试环境及线上环境的数据完整性；2014/09 - 2016/09 XXX公司 | WEB中级前端岗位职责：负责前端项目需求分析，技术选型，项目架构搭建和整体业务流程把控；负责项目中所以公用代码的封装及优化，制定规范的代码结构；配合后端完成项目中测试环境及线上环境的数据完整性；2011/09 - 2014/09 XXX公司 | WEB初级前端岗位职责：负责前端项目需求分析，技术选型，项目架构搭建和整体业务流程把控；负责项目中所以公用代码的封装及优化，制定规范的代码结构；配合后端完成项目中测试环境及线上环境的数据完整性； 自我评价如：有三年的前端开发经验，能快速对接产品需求、前后端工作。对web前端有很大的兴趣并有独立自主学习的能力，具备独立分析并解决问题的能力。业余时间会自主钻研前端技术丰富自己的前端技能栈。代码强迫症患者，注重团队合作，具有良好的沟通能力。","categories":[{"name":"前端面试题","slug":"前端面试题","permalink":"https://qw8.github.io/categories/前端面试题/"}],"tags":[{"name":"简历","slug":"简历","permalink":"https://qw8.github.io/tags/简历/"}]},{"title":"前端通信","slug":"knowledges/前端通信","date":"2020-12-10T13:51:01.000Z","updated":"2023-12-25T08:44:40.000Z","comments":true,"path":"/knowledges/qian-duan-tong-xin.html","link":"","permalink":"https://qw8.github.io/knowledges/qian-duan-tong-xin.html","excerpt":"","text":"前言前端通信类的问题，主要包括以下内容： 前后端如何通信：如果你不准备，估计也就只能说出ajax。这个可以考察出知识面。 如何创建Ajax Ajax在前后端通信中经常用到。做业务时，可以借助第三方的库，比如vue框架里的库、jQuery也有封装好的方法。但如果让你用原生的js去实现，该怎么做？ 这就是考察你的动手能力，以及框架原理的掌握。如果能写出来，可以体现出你的基本功。是加分项。 在回答 Ajax 的问题时，要回答以下几个方面： XMLHttpRequest 的工作原理 兼容性处理 XMLHttpRequest只有在高级浏览器中才支持。在回答问题时，这个兼容性问题不要忽略。 事件的触发条件 事件的触发顺序 XMLHttpRequest有很多触发事件，每个事件是怎么触发的。 跨域通信的几种方式 这部分非常重要。无非就是问你：什么是跨域、跨域有什么限制、跨域有几种方式。 1.同源策略的概念和具体限制请解释一下 JavaScript 的同源策略同源策略：限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。 是客户端脚本（尤其是 Javascript）的重要的安全度量标准。它最早出自 Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。 所谓同源指的是：协议，域名，端口相同，同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性。 具体解释： 源包括三个部分：协议、域名、端口（http协议的默认端口是80）。如果有任何一个部分不同，则源不同，那就是跨域了。 限制：这个源的文档没有权利去操作另一个源的文档。这个限制体现在：（要记住） Cookie、LocalStorage和IndexDB无法获取。 无法获取和操作DOM。 不能发送Ajax请求。我们要注意，Ajax只适合同源的通信。 为什么要有同源限制？我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。 缺点 同源策略带来的麻烦：ajax 在不同域名下的请求无法实现，需要进行跨域操作 现在网站的JS都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。 2. 前后端如何通信主要有以下几种方式： Ajax：不支持跨域。 WebSocket：不受同源策略的限制，支持跨域 CORS：不受同源策略的限制，支持跨域。一种新的通信协议标准。可以理解成是：同时支持同源和跨域的Ajax。 多个页面之间如何进行通信 cookie web worker localeStorage 和 sessionStorage Ajax什么是 AjaxAjax 是全称是Asynchronous Javascript And XML，异步传输+js+xml，即异步 JavaScript 和 xml； 主要用来实现客户端与服务器异步数据交互，不用重载整个网页，实现页面局部刷新。 所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。 ajax 的优点 来自服务器的新内容可以动态更改，通过异步模式，无需重新加载整个页面，实现页面局部刷新 避免用户不断刷新或者跳转页面，提高用户体验 优化了浏览器和服务器之间的传输，降低数据传输量，减少不必要的数据往返，减少了带宽占用 Ajax 在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。 ajax 的缺点 ajax 不支持浏览器 back 按钮，要实现 ajax 下的前后退功能成本较大 可能造成请求数的增加跨域问题限制； 安全问题： AJAX 暴露了与服务器交互的细节。 对搜索引擎的支持比较弱。 破坏了程序的异常机制。 如何创建一个Ajax？(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象 (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息 (3)设置响应HTTP请求状态变化的函数 (4)发送HTTP请求 (5)获取异步调用返回的数据 (6)使用JavaScript和DOM实现局部刷新 Ajax 是什么? 如何创建一个Ajax？ ajax的全称：Asynchronous Javascript And XML 异步传输+js+xml 所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验 创建XMLHttpRequest对象,也就是创建一个异步调用对象 建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息 设置响应HTTP请求状态变化的函数 发送HTTP请求 获取异步调用返回的数据 用JavaScript和DOM实现局部刷新 创建 ajax 过程基本步骤 5步走：（创建对象、建立连接、发送数据、接收数据、局部刷新） 1.创建 XMLHttpRequest 对象,也就是创建一个异步调用对象 1var xhr=new XMLHttpRequest() //创建对象 2.创建一个新的 HTTP 请求,并指定该 HTTP 请求的方法、URL 及验证信息，跟服务器建立一个连接，设置响应 HTTP 请求状态变化的函数 12345xhr.open(&quot;type 提交方式&quot;, &quot;url 提交的地址&quot;)如果是post请求，需要设置请求头xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;); 3.我要发送数据给服务器（发送 HTTP 请求） ​ 如果是get 请求，请求的数据在地址的后面。 1xhr.send() //发送数据，这一步不能省略 4.获取异步调用服务器返回的数据 服务端返回数据会调用一个回调函数，通过回调函数去接收数据. 1234567xhr.onreadystatechange=function()&#123; if(xhr.readyState==4)&#123; 响应完成了 if(xhr.status==200)&#123; //响应成功了 responseText 属性接收服务端返回的数据. &#125; &#125; &#125; 5.使用 JavaScript 和 DOM 实现局部刷新 创建 ajax 步骤： 1.创建 XMLHttpRequest 对象 2.创建一个新的 HTTP 请求，并指定该 HTTP 请求的类型、验证信息 3.设置响应 HTTP 请求状态变化的回调函数 4.发送 HTTP 请求 5.获取异步调用返回的数据 6.使用 JavaScript 和 DOM 实现局部刷新 123456789var xhr = new XMLHttpRequest();xhr.open(\"POST\", url, true);xhr.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4 &amp;&amp; (xhr.status == 200 || xhr.status == 304)) &#123; fn.call(this, xhr.responseText); &#125;&#125;;xhr.send(data); Ajax 实现的原理浏览器提供的 XMLHttpRequest 对象 ajax 如何实现，readyState 的五种状态的含义？ 0 － （未初始化）还没有调用 send()方法 1 － （载入）已调用 send()方法，正在发送请求 2 － （载入完成）send()方法执行完成，已经接收到全部响应内容 3 － （交互）正在解析响应内容 4 － （完成）响应内容解析完成，可以在客户端调用了 解析： (0)未初始化 此阶段确认 XMLHttpRequest 对象是否创建，并为调用 open()方法进行未初始化作好准备。值为 0 表示对象已经存在，否则浏览器会报错－－对象不存在。 (1)载入 此阶段对 XMLHttpRequest 对象进行初始化，即调用 open()方法，根据参数(method,url,true)完成对象状态的设置。并调用 send()方法开始向服务端发送请求。值为 1 表示正在向服务端发送请求。 (2)载入完成 此阶段接收服务器端的响应数据。但获得的还只是服务端响应的原始数据，并不能直接在客户端使用。值为 2 表示已经接收完全部响应数据。并为下一阶段对数据解析作好准备。 (3)交互 此阶段解析接收到的服务器端响应数据。即根据服务器端响应头部返回的 MIME 类型把数据转换成能通过 responseBody、responseText 或 responseXML 属性存取的格式，为在客户端调用作好准备。状态 3 表示正在解析数据。 (4)完成 此阶段确认全部数据都已经解析为客户端可用的格式，解析已经完成。值为 4 表示数据解析完毕，可以通过 XMLHttpRequest 对象的相应属性取得数据。 参考 ajax 加载的页面，跳转到另外一个页面再跳转回来，内容相同，如何节约读取请求?后台做缓存，读取缓存里面的数据。CDN Ajax 解决浏览器缓存问题？1、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“If-Modified-Since”,”0”)。 2、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“Cache-Control”,”no-cache”)。 3、在URL后面加上一个随机数： “fresh=” + Math.random();。 4、在URL后面加上时间搓：”nowtime=” + new Date().getTime();。 5、如果是使用jQuery，直接这样就可以了 $.ajaxSetup({cache:false})。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录 GET 和 POST 的区别，何时使用 POST？GET： 一般用于信息获取，使用 URL 传递参数，对所发送信息的数量也有限制，一般在 2000 个字符，有的浏览器是 8000 个字符； 请求的参数都暴露在 url 地址当中，如果传递中文参数，需要自己进行编码操作，安全性较低。 POST： 一般用于提交数据和修改服务器上的资源，对所发送的信息没有限制 提交的数据内容存在于 http 请求体中，数据不会暴漏在 url 地址中。 在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 ajax 请求时，如何解析 json 数据使用 eval() 或者 JSON.parse() 鉴于安全性考虑，推荐使用 JSON.parse()更靠谱，对数据的安全性更好。 发送 get 请求和 post 请求 get请求举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Ajax 发送 get 请求&lt;/h1&gt;&lt;input type=\"button\" value=\"发送get_ajax请求\" id='btnAjax'&gt;&lt;script type=\"text/javascript\"&gt; // 绑定点击事件 document.querySelector('#btnAjax').onclick = function () &#123; // 发送ajax 请求 需要 五步 // （1）创建异步对象 var ajaxObj = new XMLHttpRequest(); // （2）设置请求的参数。包括：请求的方法、请求的url。 ajaxObj.open('get', '02-ajax.php'); // （3）发送请求 ajaxObj.send(); //（4）注册事件。 onreadystatechange事件，状态改变时就会调用。 //如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。 ajaxObj.onreadystatechange = function () &#123; // 为了保证 数据 完整返回，我们一般会判断 两个值 if (ajaxObj.readyState == 4 &amp;&amp; ajaxObj.status == 200) &#123; // 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的 // 5.在注册的事件中 获取 返回的 内容 并修改页面的显示 console.log('数据返回成功'); // 数据是保存在 异步对象的 属性中 console.log(ajaxObj.responseText); // 修改页面的显示 document.querySelector('h1').innerHTML = ajaxObj.responseText; &#125; &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; post 请求举例： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Ajax 发送 get 请求&lt;/h1&gt;&lt;input type=\"button\" value=\"发送put_ajax请求\" id='btnAjax'&gt;&lt;script type=\"text/javascript\"&gt; // 异步对象 var xhr = new XMLHttpRequest(); // 设置属性 xhr.open('post', '02.post.php'); // 如果想要使用post提交数据,必须添加此行 xhr.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\"); // 将数据通过send方法传递 xhr.send('name=fox&amp;age=18'); // 发送并接受返回值 xhr.onreadystatechange = function () &#123; // 这步为判断服务器是否正确响应 if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; alert(xhr.responseText); &#125; &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; onreadystatechange 事件 注册 onreadystatechange 事件后，每当 readyState 属性改变时，就会调用 onreadystatechange 函数。 readyState：（存有 XMLHttpRequest 的状态。从 0 到 4 发生变化） 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 事件的触发条件 事件的触发顺序 实际开发中用的 原生Ajax请求12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061var util = &#123;&#125;;//获取 ajax 请求之后的jsonutil.json = function (options) &#123; var opt = &#123; url: '', type: 'get', data: &#123;&#125;, success: function () &#123; &#125;, error: function () &#123; &#125;, &#125;; util.extend(opt, options); if (opt.url) &#123; //IE兼容性处理：浏览器特征检查。检查该浏览器是否存在XMLHttpRequest这个api，没有的话，就用IE的api var xhr = XMLHttpRequest ? new XMLHttpRequest() : new window.ActiveXObject('Microsoft.XMLHTTP'); var data = opt.data, url = opt.url, type = opt.type.toUpperCase(); dataArr = []; &#125; for (var key in data) &#123; dataArr.push(key + '=' + data[key]); &#125; if (type === 'GET') &#123; url = url + '?' + dataArr.join('&amp;'); xhr.open(type, url.replace(/\\?$/g, ''), true); xhr.send(); &#125; if (type === 'POST') &#123; xhr.open(type, url, true); // 如果想要使用post提交数据,必须添加此行 xhr.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\"); xhr.send(dataArr.join('&amp;')); &#125; xhr.onload = function () &#123; if (xhr.status === 200 || xhr.status === 304) &#123; //304表示：用缓存即可。206表示获取媒体资源的前面一部分 var res; if (opt.success &amp;&amp; opt.success instanceof Function) &#123; res = xhr.responseText; if (typeof res === 'string') &#123; res = JSON.parse(res); //将字符串转成json opt.success.call(xhr, res); &#125; &#125; &#125; else &#123; if (opt.error &amp;&amp; opt.error instanceof Function) &#123; opt.error.call(xhr, res); &#125; &#125; &#125;;&#125; 参考链接： http://www.runoob.com/ajax/ajax-tutorial.html http://3ms.huawei.com/km/blogs/details/5434911 4.json什么是 json JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式 它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小 JSON字符串转换为JSON对象: 123var obj =eval(&apos;(&apos;+ str +&apos;)&apos;);var obj = str.parseJSON();var obj = JSON.parse(str); JSON对象转换为JSON字符串： 12var last=obj.toJSONString();var last=JSON.stringify(obj); json优点: 数据格式比较简单，易于读写，支持复合数据类型（数组、对象、字符串、数字） 轻量级，格式都是压缩的，占用带宽小 便于机器（JavaScript）解析, 客户端 javascript 可以简单的通过 eval()进行 JSON 数据的读取搜索 支持多种语言, 包括 ActionScript, C, C#, ColdFusion, Java, JavaScript, Perl, php, Python, Ruby 等语言服务器端语言, 便于服务器端的解析 在 PHP 世界, 已经有 PHP-JSON 和 JSON-PHP 出现了, 便于 PHP 序列化后的程序直接调用. PHP 服务器端的对象、数组等能够直接生 JSON 格式, 便于客户端的访问提取. 另外 PHP 的 PEAR 类已经提出了支持 (http://pear.php.net/pepr/pepr-proposal-show.php?id=198) 因为 JSON 格式能够直接为服务器端代码使用, 大大简化了服务器端和客户端的代码开发量, 但是完成的任务不变, 且易于维护 json缺点: 没有 XML 格式这么推广的深入人心和使用广泛, 没有 XML 那么通用性 JSON 格式目前在 Web Service 中推广还属于初级阶段 PS: 据说 Google 的 Ajax 是使用 JSON+模板 做的 XML和JSON的区别？ 数据体积方面 JSON相对于XML来讲，数据的体积小，传递的速度更快些。 数据交互方面 JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互 数据描述方面 JSON对数据的描述性比XML较差 传输速度方面 JSON的速度要远远快于XML 5.跨域如何解决跨域问题?jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面 如何解决跨域问题? jsonp ，允许 script 加载第三方资源 反向代理（nginx 服务内部配置 Access-Control-Allow-Origin *） cors 前后端协作设置请求头部，Access-Control-Allow-Origin 等头部信息 iframe 嵌套通讯，postmessage 解析： 理解跨域的概念：协议、域名、端口都相同才同域，否则都是跨域 参考跨域资源共享 CORS 阮一峰 跨域通信的几种方式 方式如下： JSONP WebSocket CORS Hash postMessage 上面这五种方式，在面试时，都要说出来。 5.1 JSONP 面试会问：JSONP的原理是什么？怎么实现的？ 在CORS和postMessage以前，我们一直都是通过JSONP来做跨域通信的。 JSONP的原理：通过&lt;script&gt;标签的异步加载来实现的。比如说，实际开发中，我们发现，head标签里，可以通过&lt;script&gt;标签的src，里面放url，加载很多在线的插件。这就是用到了JSONP。 JSONP的实现： 比如说，客户端这样写： 1&lt;script src=\"http://www.smyhvae.com/?data=name&amp;callback=myjsonp\"&gt;&lt;/script&gt; 上面的src中，data=name是get请求的参数，myjsonp是和后台约定好的函数名。服务器端这样写： 1234myjsonp(&#123; data: &#123;&#125;&#125;) 于是，本地要求创建一个myjsonp 的全局函数，才能将返回的数据执行出来。 实际开发中，前端的JSONP是这样实现的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;script&gt; var util = &#123;&#125;; //定义方法：动态创建 script 标签 /** * [function 在页面中注入js脚本] * @param &#123;[type]&#125; url [description] * @param &#123;[type]&#125; charset [description] * @return &#123;[type]&#125; [description] */ util.createScript = function (url, charset) &#123; var script = document.createElement('script'); script.setAttribute('type', 'text/javascript'); charset &amp;&amp; script.setAttribute('charset', charset); script.setAttribute('src', url); script.async = true; return script; &#125;; /** * [function 处理jsonp] * @param &#123;[type]&#125; url [description] * @param &#123;[type]&#125; onsucess [description] * @param &#123;[type]&#125; onerror [description] * @param &#123;[type]&#125; charset [description] * @return &#123;[type]&#125; [description] */ util.jsonp = function (url, onsuccess, onerror, charset) &#123; var callbackName = util.getName('tt_player'); //事先约定好的 函数名 window[callbackName] = function () &#123; //根据回调名称注册一个全局的函数 if (onsuccess &amp;&amp; util.isFunction(onsuccess)) &#123; onsuccess(arguments[0]); &#125; &#125;; var script = util.createScript(url + '&amp;callback=' + callbackName, charset); //动态创建一个script标签 script.onload = script.onreadystatechange = function () &#123; //监听加载成功的事件，获取数据 if (!script.readyState || /loaded|complete/.test(script.readyState)) &#123; script.onload = script.onreadystatechange = null; // 移除该script的 DOM 对象 if (script.parentNode) &#123; script.parentNode.removeChild(script); &#125; // 删除函数或变量 window[callbackName] = null; //最后不要忘了删除 &#125; &#125;; script.onerror = function () &#123; if (onerror &amp;&amp; util.isFunction(onerror)) &#123; onerror(); &#125; &#125;; document.getElementsByTagName('head')[0].appendChild(script); //往html中增加这个标签，目的是把请求发送出去 &#125;;&lt;/script&gt; 5.2 WebSocket WebSocket的用法如下： 123456789101112131415161718192021//var ws = new WebSocket('wss://echo.websocket.org'); //创建WebSocket的对象。参数可以是 ws 或 wss，后者表示加密。//把请求发出去ws.onopen = function (evt) &#123; console.log('Connection open ...'); ws.send('Hello WebSockets!');&#125;;//对方发消息过来时，我接收ws.onmessage = function (evt) &#123; console.log('Received Message: ', evt.data); ws.close();&#125;;//关闭连接ws.onclose = function (evt) &#123; console.log('Connection closed.');&#125;; 面试一般不会让你写这个代码，一般是考察你是否了解 WebSocket概念，知道有这么回事即可。 5.3 CORS CORS 可以理解成是既可以同步、也可以异步的Ajax。 fetch是一个比较新的API，用来实现CORS`通信。用法如下： 12345678// url（必选），options（可选）fetch('/some/url/', &#123; method: 'get',&#125;).then(function (response) &#123; //类似于 ES6中的promise&#125;).catch(function (err) &#123; // 出错了，等价于 then 的第二个参数，但这样更好用更直观&#125;); 另外，如果面试官问：“CORS为什么支持跨域的通信？” 答案：跨域时，浏览器会拦截Ajax请求，并在http头中加Origin。 5.4 Hash url的#后面的内容就叫Hash。Hash的改变，页面不会刷新。这就是用 Hash 做跨域通信的基本原理。 补充：url的?后面的内容叫Search。Search的改变，会导致页面刷新，因此不能做跨域通信。 使用举例： 场景：我的页面 A 通过iframe或frame嵌入了跨域的页面 B。 现在，我这个A页面想给B页面发消息，怎么操作呢？ 首先，在我的A页面中： 123//伪代码var B = document.getElementsByTagName('iframe');B.src = B.src + '#' + 'jsonString'; //我们可以把JS 对象，通过 JSON.stringify()方法转成 json字符串，发给 B 然后，在B页面中： 1234// B中的伪代码window.onhashchange = function () &#123; //通过onhashchange方法监听，url中的 hash 是否发生变化 var data = window.location.hash;&#125;; 5.5 postMessage()方法 H5中新增的`postMessage()``方法，可以用来做跨域通信。既然是H5中新增的，那就一定要提到。 场景：窗口 A (http:A.com)向跨域的窗口 B (http:B.com)发送信息。步骤如下 在A窗口中操作如下：向B窗口发送数据： 12// 窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息 Bwindow.postMessage('data', 'http://B.com'); //这里强调的是B窗口里的window对象 在B窗口中操作如下： 123456// 在窗口B中监听 message 事件Awindow.addEventListener('message', function (event) &#123; //这里强调的是A窗口里的window对象 console.log(event.origin); //获取 ：url。这里指：http://A.com console.log(event.source); //获取：A window对象 console.log(event.data); //获取传过来的数据&#125;, false); 如何解决跨域问题JSONP： 原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入 由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求 优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求 JSONP：json+padding（内填充），顾名思义，就是把JSON填充到一个盒子里 1234567891011121314151617function createJs(sUrl)&#123; var oScript = document.createElement('script'); oScript.type = 'text/javascript'; oScript.src = sUrl; document.getElementsByTagName('head')[0].appendChild(oScript);&#125;createJs('jsonp.js');box(&#123; 'name': 'test'&#125;);function box(json)&#123; alert(json.name);&#125; CORS 服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问 通过修改document.domain来跨子域 将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域。主域相同的使用document.domain 使用window.name来进行跨域 window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的 使用HTML5中新引进的window.postMessage方法来跨域传送数据 还有flash、在服务器上设置代理页面等跨域方式。个人认为window.name的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法 如何解决跨域问题? jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面 如何解决跨域问题? document.domain + iframe：要求主域名相同 //只能跨子域 JSONP(JSON with Padding)``：response: callback(data)`` //只支持 GET 请求 跨域资源共享CORS(XHR2)``：Access-Control-Allow` //兼容性 IE10+ 跨文档消息传输(HTML5)：postMessage + onmessage //兼容性 IE8+ WebSocket(HTML5)：new WebSocket(url) + onmessage //兼容性 IE10+ 服务器端设置代理请求：服务器端不受同源策略限制 5.1 跨域 很多种方法，但万变不离其宗，都是为了搞定同源策略。重用的有 jsonp、iframe、cors、img、HTML5 postMessage等等。其中用到 html 标签进行跨域的原理就是 html 不受同源策略影响。但只是接受 Get 的请求方式，这个得清楚。 延伸1：img iframe script 来发送跨域请求有什么优缺点？ 1. iframe 优点：跨域完毕之后DOM操作和互相之间的JavaScript调用都是没有问题的 缺点：1.若结果要以URL参数传递，这就意味着在结果数据量很大的时候需要分割传递，巨烦。2.还有一个是iframe本身带来的，母页面和iframe本身的交互本身就有安全性限制。 2. script 优点：可以直接返回json格式的数据，方便处理 缺点：只接受GET请求方式 3. 图片ping 优点：可以访问任何url，一般用来进行点击追踪，做页面分析常用的方法 缺点：不能访问响应文本，只能监听是否响应 延伸2：配合 webpack 进行反向代理？ webpack 在 devServer 选项里面提供了一个 proxy 的参数供开发人员进行反向代理 1234567'/api': &#123; target: 'http://www.example.com', // your target host changeOrigin: true, // needed for virtual hosted sites pathRewrite: &#123; '^/api': '' // rewrite path &#125;&#125;, 然后再配合 http-proxy-middleware 插件对 api 请求地址进行代理 123456789const express = require('express');const proxy = require('http-proxy-middleware');// proxy api requestsconst exampleProxy = proxy(options); // 这里的 options 就是 webpack 里面的 proxy 选项对应的每个选项// mount `exampleProxy` in web serverconst app = express();app.use('/api', exampleProxy);app.listen(3000); 然后再用 nginx 把允许跨域的源地址添加到报头里面即可 说到 nginx ，可以再谈谈 CORS 配置，大致如下 123456789101112location / &#123; if ($request_method = 'OPTIONS') &#123; add_header 'Access-Control-Allow-Origin' '*'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS'; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Headers' 'DNT, X-Mx-ReqToken, Keep-Alive, User-Agent, X-Requested-With, If-Modified-Since, Cache-Control, Content-Type'; add_header 'Access-Control-Max-Age' 86400; add_header 'Content-Type' 'text/plain charset=UTF-8'; add_header 'Content-Length' 0; return 200; &#125;&#125; 解释 jsonp 的原理，以及为什么不是真正的 ajaxjsonp 是用来解决跨域获取数据的一种解决方案，具体是通过动态创建 script 标签，然后通过标签的 src 属性获取 js 文件中的 js 脚本，该脚本的内容是一个函数调用，参数就是服务器返回的数据，为了处理这些返回的数据，需要事先在页面定义好回调函数，本质上使用的并不是 ajax 技术 jsonp 优缺点优点 完美解决在测试或者开发中获取不同域下的数据,用户传递一个 callback 参数给服务端，然后服务端返回数据时会将这个 callback 参数作为函数名来包裹住 JSON 数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。简单来说数据的格式没有发生很大变化 它不像 XMLHttpRequest 对象实现的 Ajax 请求那样受到同源策略的限制，JSONP 可以跨越同源策略； 它的兼容性更好，在更加古老的浏览器中都可以运行，不需要 XMLHttpRequest 或 ActiveX 的支持 在请求完毕后可以通过调用 callback 的方式回传结果。将回调方法的权限给了调用方。这个就相当于将 controller 层和 view 层终于分 开了。我提供的 jsonp 服务只提供纯服务的数据，至于提供服务以 后的页面渲染和后续 view 操作都由调用者来自己定义就好了。如果有两个页面需要渲染同一份数据，你们只需要有不同的渲染逻辑就可以了，逻辑都可以使用同 一个 jsonp 服务。 缺点 它只支持 GET 请求而不支持 POST 等其它类型的 HTTP 请求， 也即是说如果想传给后台一个 json 格式的数据,此时问题就来了,浏览器会报一个 http 状态码 415 错误,告诉你请求格式不正确,这让我很蛋疼(在登录注册中需要给后台传一大串数据),如果都用参数的形式拼接在 url 后面的话不太现实,后台取值也会显得繁琐。 它只支持跨域 HTTP 请求这种情况，不能解决不同域的两个页面之间如何进行 JavaScript 调用的问题。 jsonp 在调用失败的时候不会返回各种 HTTP 状态码。 在登录模块中需要用到 session 来判断当前用户的登录状态,这时候由于是跨域的原因,前后台的取到的 session 是不一样的,那么就不能就行 session 来判断. 缺点是安全性。万一假如提供 jsonp 的服务存在页面注入漏洞，即它返回的 javascript 的内容被人控制的。那么结果是什么？所有调用这个 jsonp 的网站都会存在漏洞。于是无法把危险控制在一个域名下。所以在使用 jsonp 的时候必须要保证使用的 jsonp 服务必须是安全可信的 由于 jsonp 存在安全性问题(不知 qq 空间的跨域是怎么解决的,还是另有高招?)，后来考虑到上面的一系列问题,采用的是后台进行设置允许跨域请求(但还是存在缺陷的,实质上还是跨域,如上面说的 session 问题).Header set Access-Control-Allow-Origin 为了防止 XSS 攻击我们的服务器， 我们可以限制域，比如 Access-Control-Allow-Origin: http://blog.csdn.net 6.其他同步和异步的区别?同步：阻塞的 -张三叫李四去吃饭，李四一直忙得不停，张三一直等着，直到李四忙完两个人一块去吃饭 =浏览器向服务器请求数据，服务器比较忙，浏览器一直等着（页面白屏），直到服务器返回数据，浏览器才能显示页面 异步：非阻塞的 -张三叫李四去吃饭，李四在忙，张三说了一声然后自己就去吃饭了，李四忙完后自己去吃 =浏览器向服务器请求数据，服务器比较忙，浏览器可以自如的干原来的事情（显示页面），服务器返回数据的时候通知浏览器一声，浏览器把返回的数据再渲染到页面，局部更新 异步加载和延迟加载1.异步加载的方案： 动态插入 script 标签 2.通过 ajax 去获取 js 代码，然后通过 eval 执行 3.script 标签上添加 defer 或者 async 属性 4.创建并插入 iframe，让它异步执行 js 5.延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的。 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？1.浏览器地址栏输入 url 2.浏览器会先查看浏览器缓存–系统缓存–路由缓存，如有存在缓存，就直接显示。如果没有，接着第三步 3.域名解析（DNS）获取相应的 ip 4.浏览器向服务器发起 tcp 连接，与浏览器建立 tcp 三次握手 5.握手成功，浏览器向服务器发送 http 请求，请求数据包 6.服务器请求数据，将数据返回到浏览器 7.浏览器接收响应，读取页面内容，解析 html 源码，生成 DOm 树 8.解析 css 样式.浏览器渲染，js 交互绑定多个域名，数量不限； 页面编码和被请求的资源编码如果不一致如何处理？答案：get 请求中的中文需要 encodeURIComponent 编码处理，post 请求不需要进行编码 Ajax 和 Fetch 区别 ajax 是使用 XMLHttpRequest 对象发起的，但是用起来很麻烦，所以 ES6 新规范就有了 fetch，fetch 发一个请求不用像 ajax 那样写一大堆代码。 使用 fetch 无法取消一个请求，这是因为 fetch 基于 Promise，而 Promise 无法做到这一点。 在默认情况下，fetch 不会接受或者发送 cookies fetch 没有办法原生监测请求的进度，而 XMLHttpRequest 可以 fetch 只对网络请求报错，对 400，500 都当做成功的请求，需要封装去处理 fetch 由于是 ES6 规范，兼容性上比不上 XMLHttpRequest XML 和 JSON 的区别？ 数据体积方面：JSON 相对于 XML 来讲，数据的体积小，传递的速度更快些。 数据交互方面：JSON 与 JavaScript 的交互更加方便，更容易解析处理，更好的数据交互。 数据描述方面：JSON 对数据的描述性比 XML 较差。 传输速度方面：JSON 的速度要远远快于 XML。 RESTfulREST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。 GET get 方法在 Rest 中主要用于获取资源，能够发送参数，不过有限制，且参数都会以?开头的形 式附加在 URL 尾部。规范的 get 方法处理器应该是幂等的，也就是说对一个资源不论发送多少次 get 请求都不会更改数据或造成破坏。 POSTpost 方法在 Rest 请求中主要用于添加资源，参数信息存放在请求报文的消息体中相对安全，且可发送较大信息 PUTput 方法在 Rest 中主要用于更新资源，因为大多数浏览器不支持 put 和 delete，会自动将 put 和 delete 请求转化为 get 和 post. 因此为了使用 put 和 delete 方法,需要以 post 发送请求，在表单中使用隐藏域发送真正的请求。put 方法的参数是同 post 一样是存放在消息中的，同样具有安全性，可发送较大信息。put 方法是幂等的，对同一 URL 资源做出的同一数据的任意次 put 请求其对数据的改变都是一致的。 DELETEDelete 在 Rest 请求中主要用于删除资源，因为大多数浏览器不支持 put 和 delete，会自动将 put 和 delete 请求转化为 get 和 post。因此为了使用 put 和 delete 方法,需要以 post 发送请求，在表单中使用隐藏域发送真正的请求。Delete 方法的参数同 post 一样存放在消息体中,具有安全性，可发送较大信息 Delete 方法是幂等的，不论对同一个资源进行多少次 delete 请求都不会破坏数据 解析：参考 withCredentials详细介绍withCredentials是一个布尔值，用于指定是否在跨域请求中发送身份凭据（如cookie，HTTP认证和客户端SSL证明），默认为false。 跨域请求通常被浏览器限制，因为它们可能会引发安全风险。浏览器将通常只向同域发送身份凭据。然而，有时候我们需要在跨域请求中发送身份凭据，以实现认证、授权或其他相关功能。 当withCredentials设置为true时，浏览器在发送跨域请求时会包含身份凭据。服务器必须正确配置CORS（跨域资源共享）以接受带有身份凭据的请求。如果服务器没有正确配置CORS，浏览器将拒绝响应。 下面是一个使用withCredentials的示例： 123456789var xhr = new XMLHttpRequest();xhr.withCredentials = true;xhr.open('POST', 'https://api.example.com/login', true);xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; // 处理响应 &#125;&#125;;xhr.send(); 在这个示例中，我们创建了一个XMLHttpRequest对象，并将withCredentials设置为true。然后，我们打开一个跨域请求，并监听xhr对象的onreadystatechange事件。当请求完成并成功时（readyState为4且status为200），我们可以处理响应。 请注意，在跨域请求中发送身份凭据可能会导致安全风险。确保只在必要的情况下使用withCredentials，并在服务器端正确配置CORS以确保安全性。","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"同源策略","slug":"同源策略","permalink":"https://qw8.github.io/tags/同源策略/"},{"name":"通信方式","slug":"通信方式","permalink":"https://qw8.github.io/tags/通信方式/"},{"name":"Ajax","slug":"Ajax","permalink":"https://qw8.github.io/tags/Ajax/"},{"name":"JSON","slug":"JSON","permalink":"https://qw8.github.io/tags/JSON/"},{"name":"跨域通信","slug":"跨域通信","permalink":"https://qw8.github.io/tags/跨域通信/"},{"name":"异步","slug":"异步","permalink":"https://qw8.github.io/tags/异步/"}]},{"title":"前端新技术","slug":"knowledges/前端新技术","date":"2020-11-24T07:26:47.000Z","updated":"2023-04-14T17:01:50.000Z","comments":true,"path":"/knowledges/qian-duan-xin-ji-zhu.html","link":"","permalink":"https://qw8.github.io/knowledges/qian-duan-xin-ji-zhu.html","excerpt":"","text":"TypeScriptTypeScript 扩展了JavaScript语法，任何已经存在的JavaScript程序，可以不加任何改动，在TypeScript环境下运行。TypeScript只是向JavaScript添加了一些新的遵循ES6规范的语法，以及基于类的面向对象编程的这种特性。 TypeScript 是一门基于 JavaScript 基础之上的编程语言，很多时候我们都说它是一个 JavaScript 的超集，或者叫扩展集。所谓超集，其实就是 JavaScript 原有的基础之上多了一些扩展特性。多出来的呢，实际上就是一套更强大的类型系统，以及对 ECMAScript 新特性的支持。而且它最终会编译为原始的 JavaScript。 这也就是说，使用 TypeScript 过后，我们开发者开发过程中可以直接使用 TypeScript 所 那即便我们不需要类型系统，通过 TypeScript 去使用 ECMAScript 的新特性也是一个很好的选择。因为 TypeScript 最终可以选择编译到最低 ES3 版本的代码，所以兼容性非常好。 因为最终是编译为 JavaScript。所以任何一个 JavaScript 运行环境下的应用程序，都可以使用 TypeScript 开发。例如浏览器应用，Node.js 应用，React Native，或者是 Electron 桌面应用。 相比较于 Flow，TypeScript 作为一门完整的编程语言，它的功能更为强大。生态也更健全、更完善。特别是对于开发工具这一块，微软自家的开发工具对 TypeScript 的支持都特别友好。 Vue3.0Vue 是“一个用于构建用户应用程序的渐进式框架”。它的设计非常灵活，可以将单个 Vue 库集成到其他项目中，也可以完全使用 Vue 构建复杂的项目。Vue 通常被视为一个易于理解和实现的框架，它支持纯 HTML 模板，而 React 需要使用 JavaScript 定义来 DOM 元素。 Vue 3.0 的五个关键变化： 速度 速度更快是 Vue 目前的主要卖点之一,Vue 以其渲染速度而闻名，与其他框架一样，Vue 使用虚拟 DOM 来渲染组件。为了加速渲染过程，必须减少虚拟 DOM 的工作负载。通过编译时间提示、组件快速路径、单态调用、优化 slot 生成等手段来达到提速目的。 体积 目前，Vue 的体积已经很小了（压缩后 20KB。由于进行了摇树优化（消除非重要代码，3.0 的预计大小约为 10KB（压缩后。主要是移除了对 Vue 项目来说不是很重要的库，可以通过 import 语句来使用它们，而不是把它们打包主 src 代码中。 可维护性 Vue 3.0 将从 Flow 转到 TypeScript，同时又非常重视兼容性易用性，不喜欢使用 TypeScript 的用户仍然可以使用纯 JavaScript。Vue 3.0 提供了更好的模块化，从而变得更加可定制和灵活，还提供了透明性，开发人员可以深入到源代码中。编译器重写是最令人兴奋的功能之一，不仅带来了更好的 IDE 支持，而且可以创建源码映射，如果存运行时错误，它将给出错误对应的文件位置和行号。 面向原生 Vue 3.0 将与平台无关——它将运行纯 JavaScript，并且其主构建中不会假设使用诸如 Node.js 之类的东西。这种灵活性使构建 Web、iOS 或 Android 应用程序变得更容易。面向原生使 Vue 更像是 React 的替代品。 易用性 公开 Reactivity API——新的变更允许开发人员显式创建反应式对象和自定义重渲染 hook。3.0 还解决了 Vue 用户经常抱怨的一个问题：什么时候以及为什么要重新渲染组件？3.0 提供了一个 renderTriggered 事件，人们可以通过它查看是什么触发了更新。这个出色的功能将使 Vue 更加透明。 JAMStackJAMstack是指使用JavaScript、API和Markup构建的技术堆栈，JAM是JavaScript、API和Markup的简称，前面第一个字母缩写，JAMstack一种基于客户端JavaScript，可重用API和预构建Markup的现代Web开发架构，需要符合下面三个标准： JavaScript：请求/响应周期中的任何动态编程都由JavaScript处理，完全客户端上运行。这可以是任何前端框架，库，甚至是轻量JavaScript。 API：所有服务器端进程或数据库操作都被抽象为可重用的API，使用JavaScript通过HTTPS访问。这些可以是定制的或利用第三方服务。 Markup：模板化标记应该部署时预先构建，通常使用内容站点的站点生成器或Web应用程序的构建工具。 为什么JAMstack会逐渐流行？ 更好的性能：为什么要部署时生成页面时等待页面动态构建？当谈到最小化第一个字节的时间时，没有什么能比通过CDN提供的预构建文件更好。 安全性更高：将服务器端进程抽象为微服务API，可以减少攻击的表面区域。您还可以利用专业第三方服务的专业知识。 更便宜，更容易扩展：当您的部署相当于可以任何地方提供服务的一堆文件时，扩展就是更多地方提供这些文件的问题。CDN是完美的，通常包括扩展他们的所有计划。 更好的开发者体验：松散耦合和控制分离允许更有针对性的开发和调试，并且为站点生成器扩展选择CMS选项消除了为内容和营销维护单独堆栈的需要。 网站静态化 技术栈JAMStack https://jamstack.org/JAMstack是指使用JavaScript、API和Markup构建的技术堆栈，JAM是JavaScript、API和Markup的简称，前面第一个字母缩写，JAMstack一种基于客户端JavaScript，可重用API和预构建Markup的现代Web开发架构. Serverless Services（无服务器服务）Serverless（无服务器架构）概念的提出，实际上可以追溯到2012年。最早的原型当属AWS Lambda，也即函数计算。2019年，Serverless在阿里等大厂中其实已形成燎原之势。今年双十一、双十二的大部分前端业务都跑在Serverless架构上。那么，这么火的Serverless核心要解决的是什么问题？ 借用腾讯前端技术专家·河伯的一个词，就是「提效」。Serverless 带来的其实是前端研发模式上的颠覆。相对以往纯前端研发的方式，Serverless 屏蔽底层基础设施的复杂度，后台能力通过FaaS平台化，我们不再需要关注运维、部署的细节，开发难度得到了简化，前端开发群体的边界就得以拓宽，能够参与到业务逻辑的开发当中，更加贴近和理解业务，做更有价值的输出。 用最简单的方式实现最有价值的输出，这不正是我们一直所期盼的么。未来已来，Serverless浪潮，不能错过。 用了它，你们公司再也不用自己去买服务器做负载均衡各种恶心事儿了。目前典型的应用就是图床，你上传一堆图片，根据你的需求，别人家的服务器把各种尺寸给你做好，而且还做好防盗链和负载均衡。性能安全没的说。 WebAssembly2019年12月，W3C联盟宣布，WebAssembly核心规范正式成为其官方 Web 标准。这意味着 WebAssembly 成为了继 HTML、CSS 和 JavaScript之后的第四种 Web语言。消息一出，前端圈欢呼雀跃。 目前WebAssembly的应用场景更多集中在前端音视频的解码方面，UC研发效能出品的另一款产品 岩鼠云设备平台，其中的云真机视频流解码底层用到的就是WebAssembly技术，性能方面杠杠的。 除了性能，WebAssembly的另一个优点是代码复用和可移植性方面，让Web有机会能复用到像 C/C++、Go等语言生态中的优秀实践，让 Web 的世界充满想象和无限可能。 实际上，WebAssembly是2015年被提出的，前期更多的是在规范制定上花了较多时间，在得到Chrome和Firefox的有力支持和推广之后，今年是在技术实施层面发展较为不错的一年，国内外大厂都有较多的尝试。 也许，2020年，WebAssembly 就是下一朵绽放的技术之花。 小科普 WebAssembly 也叫 WASM，它是为基于栈的虚拟机设计的二进制指令格式，WASM 作为可移植目标，用于编译高级语言（如 C/C++/Rust），从而可以在 Web 上部署高性能客户端和服务器应用，同时它也可以在许多其它环境中使用。 GMTC大会期间，最爆场的当属阿里巴巴前端技术专家·桑世龙（狼叔）出品的 Serverless专题，以及腾讯前端技术专家刘恒兵（河伯）出品的 优化与全链路监控专题。 Serverless作为当红炸子鸡，现场火爆不出意料，而优化和全链路监控专题的受捧则略显意外。 Flutter自打跨端解决方案 Flutter以革命的姿态出现以来，在前端圈里就备受瞩目。经过2018年的试错或储备，2019年终于迎来了突破性的发展。无论是Flutter大版本发布的力度（Flutter For Web的发布尤为瞩目），还是各大厂大前端团队的深度实践，相较以往都更加重磅。 国内Flutter先行者·阿里闲鱼团队以布道者的形象，在过去一年里为我们带来了几十篇深度实践总结文章，更是直接开放下载《Flutter in action》。 从大会Flutter专题的分享中，我们也看到百度、蚂蚁金服以及字节跳动的前端团队其实也都在各自的业务中做了Flutter的落地和工程化，从研发体系上拥抱了Flutter。其实远不止这几家企业，像美团、阿里内部更多的BU其实都有较深的实践。这对于一个才诞生不久的框架来说，非常难得。 以往我们都说跨端没有完美的解决方案，或许 Flutter，就是最接近的那一个，2020年非常值得期待。 小程序如果说2017年是小程序元年，那么2019则是小程序爆炸性发展的一年，无论是小程序应用，还是小程序平台的数量，都让人眼花缭乱。 移动互联网头部流量的各大厂纷纷推出了自家的小程序平台，除了BAT三家，头条、QQ、美团等企业也都加入到了这一战壕。 img 多样小程序平台让本就膨胀的大前端知识体系更加显得复杂，开发者只能一脸黑人问号，一边吃力的适配。好在主流小程序的架构基本一致，语法上也是大致相同，结合 taro、mpvue等这样的上层框架，可以屏蔽部分的复杂度。 小程序蓬勃发展的景象，事实上也掩盖了目前在性能方面的一些不足。比如来自DCloud的崔红保老师在《小程序的未来方向》中也提到了这个问题，并分享了一些解法。 最新的好消息是阿里和百度前端联手发起了W3C小程序标准提案悄然发布了—— https://w3c.github.io/mini-app-white-paper（不要问我为什么没有鹅厂）。俗话说分久必合，2020年小程序标准化也许无法一蹴而就，但未来确实可期！ Web性能、优化与全链路监控、测试与安全、团队建设与成长css模块化设计 设计原则a、可复用能继承要完整b、周期性迭代 设计方法a、先整体后部分再颗粒化b、先抽象再具体 CSS Grid 布局CSS Grid 布局是 CSS 中最强大的布局系统。与 flexbox 的一维布局系统不同，CSS Grid 布局是一个二维布局系统，也就意味着它可以同时处理列和行。通过将 CSS 规则应用于 父元素 (成为 Grid Container 网格容器)和其 子元素（成为 Grid Items 网格项），你就可以轻松使用 Grid(网格) 布局。 CSS Grid 和 Flexbox 已经得到广泛支持。然而，在面试的时候，仍然在讨论 CSS 中如何使浮动实现多列布局和行内块级元素居中。 javascript AI了解JavaScript 构建的各种AI模型和机器学习模型。 javascript 物联网（lot）nodejs将 javascript推进了服务器端，而不是桎梏与浏览器。同理lot,将js推进到了更广泛的设备。 响应式在离线环境下也能够提供服务类似App的交互HTTPS可靠, 迅速, 更好 web组件化web 组件，江湖人称web components. 代码规范——ESLintESLint 是一个代码规范和错误检查工具，有以下几个特性： 所有东西都是可以插拔的。你可以调用任意的rule api或者formatter api 去打包或者定义rule or formatter。任意的rule 都是独立的没有特定的coding style，你可以自己配置 node.js通过各种调查，nodejs也已经作为一个必备技能，而不是拔高技能了。 koaeggexpres框架vue、react、angular至少要会一个，可以先从vue入门，然后学习react RN 及 Flutter使用什么跨平台框架来看，区别并不是太大。目前主流的方案，仍然是原生（含跨平台框架） + HTML5 应用。从业务的角度上来看待这个问题，那么还是希望，可以用 HTML 5 的地方多——更新功能方便。 vue后台管理框架https://github.com/herozhou/vue-framework-wz PWA进式网络应用程序（简称PWA）是一种带有一些额外功能的Web应用程序，是一种编写Web应用程序的新方式。Progressive Web Apps是一个web app但是在功能和样式上给用户带来原生应用使用体验的一项技术. GraphQLGraphQL 是 REST API 的替代品，搞数据接口用的如果你是创业公司或者小公司，没有以前的技术负担，用GraphQL爽歪歪如果你想成为全栈，GraphQL是你工资突破50K+的绝佳机会 Stylus基本使用基于Node.js的css的预处理框架，其本质上做的事情与 Sass/LESS 等类似， 可以以近似脚本的方式去写CSS代码，创建健壮的、动态的、富有表现力的CSS，默认使用 .styl 的作为文件扩展名，支持多样性的CSS语法。Stylus比LESS更强大，而且基于nodejs比Sass更符合我们的思路。 UI框架uni-app uni-app 是一个使用 Vue.js 开发跨平台应用的前端框架，开发者编写一套代码，可编译到iOS、Android、H5、小程序等多个平台。 数据可视化echartsD3.jsreactdavJS https://dvajs.com/ 区块链技术现在许多公司使用区块链技术进行数字交易, 因为它们更安全和有效率. Solidity(一门智能合约的编程语言)Mist(以太坊开发的浏览器, 用于发送交易和合约)比特币API(可以构建app和整和比特币的区块链开发) NignxNginx是一个轻量级、高性能、稳定性高、并发性好的HTTP和反向代理服务器。也是由于其的特性，其应用非常广。 2020年的预测 随着代码拆分和 PWA 的进一步使用，性能仍然是 Web 最关键的方面。 WebAssembly 会越来越普及，并得到实际采用和应用于产品中。 新兴创业公司和新项目都会采用 GraphQL，而其他公司也会纷纷从 REST 向 GraphQL 迁移。 TypeScript 将成为新兴创业公司和项目的默认选择。 我们有望看到没有服务器且构建在区块链之上的真实应用，这会让 Web 更加开放。 CSS-in-JS 可能取代普通的 CSS，会成为默认的样式设置方式。 “无代码”应用越来越流行。随着AI的改进和应用抽象层的增加，构建应用程序会越来越容易。2020年，我们有望看到无需编写代码即可创建应用的重大转变。 Flutter 可能会取代 React Native，成为构建跨平台移动应用的最佳方式。 Svelte 将会用于更多实际项目。 Deno（Node 创建者构建的 TypeScript 运行时）将投入实际使用。 AR / VR 将取得巨大进步，其中包括使用 A-Frame、React VR 和 Google VR 等库，并改进浏览器中原生的 AR / VR 工具。 容器化（例如 Docker、Kubernetes）的影响在前端开发中越来越普遍。 我认为的2020年前端开发者最应该掌握的一些比较火爆的技术与知识点。 1，前端框架和语言层面9月份 Vue3.0 发布，声称对 TypeScript 有着更好的开发体验，通过从不同框架级别 TS 支持上，我们可以看出社区的整个风向从2019年的大家都去学习应用 TS，变成了大家如何把 TS 用的更好这个方向上来了。 所以我认为今年 TypeScript 的火热程度还是应该排名很靠前的，我今年也使用 TypeScript 重构了 Daruk 的服务框架推出了2.0版本，让 TS 开发者拥有更好的 TS 开发体验。 接下来就是两大重磅框架的更新历程对比，Vue3 前面说了一句。而 React 也在十月也发布了 React 17 的 release 版本。这两大主流框架的频繁更新，也说明了社区和作者都在一同演化。 在 Vue 3中除了更好的支持 TS 外，还更新了Composition API。而 React 17 主要是集中精力在升级体验上，虽然没有新的 Feature 但是提升了和解决了很多之前版本潜在的问题。 要说哪个最火还是要看个人实际的使用场景和喜好，但是2020年来看还没有别的框架可以与之一战。 2，大前端相关技术栈今年基于Chromium的微软edge浏览器也已经推出。google 在 web 端的发展产生了对开发者深刻的影响。Chrome 80+ 也已经发布多个版本，提供了一系列的新特性，比如Core Web Vitals标准，Desktop PWA等都值得我们去关注。 我们说完了浏览器相关的那点技术之后，再聊聊大前端相关的一些技术实践，比如 Flutter。 很多前端在今年已经从 web 开发转型为 Flutter 开发，学习和使用 Dart 技术来构建 UI，这是很多大厂的前端工程师正在经历的事情（包括我的部门也在尝试这个事情），这个趋势应该在未来几年还会持续。客户端 electron 在今年也有着长足的进展，一年内多次更新版本一路到了10.1.5。随着疫情影响，国内在线教育的又一波兴起。很多桌面软件，网课软件都在采用这个技术来进行开发，市场上的岗位也开始变多，electron 技术可以说在今年也有火的趋势。 然后我们再看看BFF 层，nestjs依然坚挺，越来越多的人开始跳过学习 express 和 koa 开始学习更丰富的 web 框架了，比如 egg 或者我的 daruk，开发者已经在慢慢形成共识，在 web framework 的路上开始越走越远，裸写 nodejs web 服务的时代已经开始慢慢褪去。 不得不提的还有 serverless 在前端的普及，在2020年到达了一个新的高潮。阿里云，腾讯云，头条云等等国内的互联网厂商也都开始大玩 serverless 概念。从对内服务开始转向对外服务，普及的势头很猛，也有落地的趋势和场景。今年的 D2同样也有 serverless 的专场，可见受重视程度非比寻常。 在前端领域混了这几年，总结了一套前端学习的精讲视频和学习路线，如果有对前端开发感兴趣的伙伴，不管你是想转行，或是大学生，还有工作中想提升自己能力的web前端党，欢迎大家的加入我的前端开发交流群：603985993 希望大家诚心交流！，与企业需求同步。好友都在里面学习交流，每天都会有大牛定时讲解前端技术!也可以关注我的微信公众号：【前端留学生】 每天更新最新技术文章干货。 3，工程化提效和个人素质提升再离我们近一些的推动生产力的技术，比如据我所知在用 CI/CD 和 pipeline 管理上线流程的公司越来越多，这种去年还可以出去吹一吹的东西，今年也逐步变成了业界标配基础能力，如果不会的同学可要抓紧学习了。 2019年前大家都疯狂吐槽面试刷 medium 题目没用，而2020年后大家开始默认面试某些公司都至少要刷到medium程度的题目。这对很多前端来说是一个心智和素质的提升与转变，大家在接触新技术的同时，也慢慢发现，前端整个职业环境的变化，越来越多的公司对人的整体综合素质要求变高了。","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"前端新技术","slug":"前端新技术","permalink":"https://qw8.github.io/tags/前端新技术/"}]},{"title":"前端知识点","slug":"knowledges/前端知识点","date":"2020-11-17T12:30:00.000Z","updated":"2024-04-26T09:50:12.420Z","comments":true,"path":"/knowledges/qian-duan-zhi-shi-dian.html","link":"","permalink":"https://qw8.github.io/knowledges/qian-duan-zhi-shi-dian.html","excerpt":"","text":"前端开发知识点 front-end dev skills 对于任何类型的前端开发人员, HTML, CSS, DOM, JavaScript, HTTP/URL 和浏览器利用是基本的技术要求. 对于HTML, CSS, DOM, JavaScript, HTTP/URL 和浏览器开发之外的, 一个前端开发者还应该掌握下面技术列表中的一个或多个: Content Management System (内容管理系统, 又称 CMS) Node.js Cross-browser testing (跨浏览器测试) Cross-platform testing (跨平台测试) Unit Testing (单元测试) Cross-device testing (跨设备测试) Accessibility / WAI-ARIA (无障碍访问/无障碍富Internet应用程序) Search Engine Optimization (搜索引擎优化, 又称 SEO) Interaction or User Interface design (交互或用户设计) User Experience (用户体验) Usability (可用性/易用性) E-commerce Systems (电子商务系统) Portal Systems (门户系统) Wireframing (框架) CSS layout / Grids (CSS 布局/栅格系统) DOM manipulation (e.g. jQuery) (DOM 操作) Mobile Web Performance (移动Web性能) Load Testing (载荷测试) Performance Testing (性能测试) Progressive Enhancement / Graceful Degradation (渐进增强/优雅降级) Version Control (e.g. GIT) (版本控制) MVC / MVVM / MV* (MV* 框架) Functional Programming (函数式编程) Data Formats (e.g. JSON, XML) (数据格式) Data API’s (e.g Restful API) (数据API) Web Font Embedding (Web字体嵌入) Scalable Vector Graphics (可伸缩向量图形, 又称 SVG) Regular Expressions (正则表达式) Content Strategy (内容策略) Microdata / Microformats (微数据/微格式) Task Runners, Build Tools, Process Automation Tools (任务管道, 构建工具, 过程自动化工具) Responsive Web Design (响应式设计) Object Oriented Programming (面向对象编程) Application Architecture (应用架构) Modules (模块) Dependency Managers (依赖关系管理) Package Managers (包管理) JavaScript Animation (JavaScript 动画) CSS Animation (CSS 动画) Charts / Graphs (图表/图形) UI widgets (UI工具集) Code Quality Testing (代码质量测试) Code Coverage Testing (代码覆盖测试) Code Complexity Analysis (代码复杂度测试) Integration Testing (集成测试) Command Line / CLI (命令行/命令行界面) Templating Strategies (模板策略) Templating Engines (模板引擎) Single Page Applications (单页应用) XHR Requests (aka AJAX) (XHR 请求, 又称 AJAX) Web/Browser Security (Web/浏览器安全) HTML Semantics (HTML 语义化) Browser Developer Tools (浏览器开发者工具) 译者补充: 前端技能汇总 WebFrontEndStack front-end-skills1 front-end-skills2 HTMLHTML5、对Web标准的理解、布局、浏览器内核差异、兼容性 CSSCSS3、选择器优先级、Flexbox、渲染原理、依赖管理、层次关系，常用属性、选择器、权重、CSS盒模型、Hack、CSS预处理器等。 JavaScript数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、RegExp、JSON、Ajax、DOM、BOM、内存泄漏、跨域、异步装载、模板引擎、前端MVC、路由、模块化、Canvas、ECMAScript 、异步请求、Flux、Nodejs等。 框架和类库ajax、jQuery、Bootstrap、axios、Vue、Vuex、React、element-ui、layui、webpack等。 其他： 移动端、响应式、自动化构建、HTTP、离线存储、WEB安全、优化、重构、团队协作、可维护、易用性、SEO、UED、架构、职业生涯、快速学习能力 DOM结构 —— 两个节点之间可能存在哪些关系以及如何在节点之间任意移动。 DOM操作 —— 如何添加、移除、移动、复制、创建和查找节点等。 事件 —— 如何使用事件，以及IE和标准DOM事件模型之间存在的差别。 XMLHttpRequest —— 这是什么、怎样完整地执行一次GET请求、怎样检测错误。 严格模式与混杂模式 —— 如何触发这两种模式，区分它们有何意义。 盒模型 —— 外边距、内边距和边框之间的关系，及IE8以下版本的浏览器中的盒模型 块级元素与行内元素 —— 怎么用CSS控制它们、以及如何合理的使用它们 浮动元素 —— 怎么使用它们、它们有什么问题以及怎么解决这些问题。 HTML与XHTML —— 二者有什么区别，你觉得应该使用哪一个并说出理由。 JSON —— 作用、用途、设计结构 前端必备技能 基础 HTML / CSS 编程语言：Java / Python / PHP / Ruby等等 Web框架，如Spring MVC、Flask、Laravel等等 HTTP CGI基本原理 XML和JSON处理。。 中级篇 数据结构与算法 面向对象编程 CMS 高级篇 函数式编程 领域驱动设计 MVC / MVVM / MV* 安全性（如跨域） 操作系统原理 调试 远程调试 工程化 版本管理 单元测试 缓存篇 应用层缓存 数据库端缓存 分布式缓存 网络与架构 均衡负载 并发处理 性能优化 运行环境优化，如JVM 基础设施 Docker 自动化部署 依赖管理 包管理 Linux下包创建、管理 打包脚本编写 Web容器，如Jboss 数据持久化 SQL Database ORM DBMS 数据库 查询性能优化 结构优化 主从复制、主主复制等等 伸缩性与高可用性 备份恢复与容灾 安全 认证与会话管理 加密解密 XSS/CSRF/SQL注入 监控 应用性能监控 异常监控 日志 服务 REST SOA / RPC 消息 JMS IPC 其他 API设计 PS相关PNG,GIF,JPG的区别及如何选 GIF： 8位像素，256色 无损压缩 支持简单动画 支持boolean透明 适合简单动画 JPEG： 颜色限于256 有损压缩 可控制压缩质量 不支持透明 适合照片 PNG： 有PNG8和truecolor PNG PNG8类似GIF颜色上限为256，文件小，支持alpha透明度，无动画 适合图标、背景、按钮 Git相关git fetch和git pull的区别 git pull：相当于是从远程获取最新版本并merge到本地 git fetch：相当于是从远程获取最新版本到本地，不会自动merge SEO相关前端需要注意哪些SEO 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可 语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页 重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取 重要内容不要用js输出：爬虫不会执行js获取内容 少用iframe：搜索引擎不会抓取iframe中的内容 非装饰性图片必须加alt 提高网站速度：网站速度是搜索引擎排序的一个重要指标 如何做SEO优化? 标题与关键词 设置有吸引力切合实际的标题，标题中要包含所做的关键词 网站结构目录 最好不要超过三级，每级有“面包屑导航”，使网站成树状结构分布 页面元素 给图片标注”Alt”可以让搜索引擎更友好的收录 网站内容 每个月每天有规律的更新网站的内容，会使搜索引擎更加喜欢 友情链接 对方一定要是正规网站，每天有专业的团队或者个人维护更新 内链的布置 使网站形成类似蜘蛛网的结构，不会出现单独连接的页面或链接 流量分析 通过统计工具(百度统计，CNZZ)分析流量来源，指导下一步的SEO 重构相关谈谈你对重构的理解 网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化， 在扩展的同时保持一致的UI 对于传统的网站来说重构通常是： 表格(table)布局改为DIV+CSS 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) 对于移动平台的优化 针对于SEO进行优化 深层次的网站重构应该考虑的方面 页面重构怎么操作？网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI 对于传统的网站来说重构通常可以考虑的方面是： 升级第三方依赖 使用HTML5、CSS3、ES6 新特性 加入响应式布局 统一代码风格规范 减少代码间的耦合 压缩/合并JS、CSS、image等静态资源(通常是由服务器来解决) 程序的性能优化 采用CDN来加速资源加载 对于JS DOM的优化 HTTP服务器的文件缓存 表格(table)布局改为DIV+CSS 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) 对于移动平台的优化 针对于SEO进行优化 深层次的网站重构应该考虑的方面 让代码保持弹性 严格按规范编写代码 设计可扩展的API 代替旧有的框架、语言(如VB) 增强用户体验 通常来说对于速度的优化也包含在重构中 前端相关前端页面有哪三层构成，分别是什么？作用是什么？ 结构层：由 (X)HTML 标记语言负责，解决页面“内容是什么”的问题 表示层：由 CSS 负责，解决页面“如何显示内容”的问题 行为层：由 JS 脚本负责，解决页面上“内容应该如何对事件作出反应”的问题 Web 前端开发的注意事项？ 特别设置 meta 标签 viewport 百分比布局宽度，结合 box-sizing: border-box; 使用 rem 作为计算单位。rem 只参照跟节点 html 的字体大小计算 使用 css3 新特性。弹性盒模型、多列布局、媒体查询等 多机型、多尺寸、多系统覆盖测试 说说你对前端架构师的理解负责前端团队的管理及与其他团队的协调工作，提升团队成员能力和整体效率；带领团队完成研发工具及平台前端部分的设计、研发和维护； 带领团队进行前端领域前沿技术研究及新技术调研，保证团队的技术领先负责前端开发规范制定、功能模块化设计、公共组件搭建等工作，并组织培训 一些开放性题目 自我介绍：除了基本个人信息以外，面试官更想听的是你与众不同的地方和你的优势 项目介绍 如何看待前端开发？ 平时是如何学习前端开发的？ 未来三到五年的规划是怎样的？ 你觉得前端工程的价值体现在哪 为简化用户使用提供技术支持（交互部分） 为多个浏览器兼容性提供支持 为提高用户浏览速度（浏览器性能）提供支持 为跨平台或者其他基于webkit或其他渲染引擎的应用提供支持 为展示数据提供支持（数据接口） 你用的得心应手用的熟练地编辑器&amp;开发环境是什么样子？ Sublime Text 3 + 相关插件编写前端代码 Google chrome 、Mozilla Firefox浏览器 +firebug - 兼容测试和预览页面UI、动画效果和交互功能 Node.js+Gulp git 用于版本控制和Code Review 对前端工程师这个职位是怎么样理解的？它的前景会怎么样？ 前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近 实现界面交互 提升用户体验 有了Node.js，前端可以实现服务端的一些事情 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好， 参与项目，快速高质量完成实现效果图，精确到1px 与团队成员，UI设计，产品经理的沟通； 做好的页面结构，页面重构和用户体验； 处理hack，兼容、写出优美的代码格式； 针对服务器的优化、拥抱最新前端技术。 平时如何管理你的项目？ 先期团队必须确定好全局样式（globe.css）、编码模式(utf-8)、公共脚本 等； 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）； 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）； 严格要求代码注释(html/js/css)，页面进行标注（例如 页面 模块 开始和结束）； CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）； JS 分文件夹存放 命名以该JS功能为准的英文翻译 图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理，尽量整合在一起使用方便将来的管理 Git 提交必须填写说明 说说最近最流行的一些东西吧？常去哪些网站？ES6、WebAssembly、Node、MVVM、Web Components、React、React Native、Webpack 组件化 什么样的前端代码是好的高复用低耦合，这样文件小，好维护，而且好扩展。 移动端相关你怎么看待 Web App/hybrid App/Native App？（移动端前端 和 Web 前端区别？） Web App(HTML5)：采用HTML5生存在浏览器中的应用，不需要下载安装 优点：开发成本低，迭代更新容易，不需用户升级，跨多个平台和终端 缺点：消息推送不够及时，支持图形和动画效果较差，功能使用限制（相机、GPS等） Hybrid App(混合开发)：UI WebView，需要下载安装 优点：接近 Native App 的体验，部分支持离线功能 缺点：性能速度较慢，未知的部署时间，受限于技术尚不成熟 Native App(原生开发)：依托于操作系统，有很强的交互，需要用户下载安装使用 优点：用户体验完美，支持离线工作，可访问本地资源（通讯录，相册） 缺点：开发成本高（多系统），开发成本高（版本更新），需要应用商店的审核 在设计 Web APP 时，应当遵循以下几点 简化不重要的动画/动效/图形文字样式 少用手势，避免与浏览器手势冲突 减少页面内容，页面跳转次数，尽量在当前页面显示 增强 Loading 趣味性，增强页面主次关系 移动端（Android、IOS）怎么做好用户体验? 清晰的视觉纵线 信息的分组、极致的减法 利用选择代替输入 标签及文字的排布方式 依靠明文确认密码 合理的键盘利用 其他如何设计突发大规模并发架构？ 及时响应(NoSQL缓存) 数据安全(数据备份) 负载均衡 列举IE与其他浏览器不一样的特性？ IE 的渲染引擎是 Trident 与 W3C 标准差异较大：例如盒子模型的怪异模式 JS 方面有很多独立的方法，例如事件处理不同：绑定/删除事件，阻止冒泡，阻止默认事件等 CSS 方面也有自己独有的处理方式，例如设置透明，低版本IE中使用滤镜的方式 是否了解公钥加密和私钥加密？ 私钥用于对数据进行签名，公钥用于对签名进行验证 网站在浏览器端用公钥加密敏感数据，然后在服务器端再用私钥解密 WEB应用从服务器主动推送Data到客户端有那些方式？ AJAX 轮询 html5 服务器推送事件(new EventSource(SERVER_URL)).addEventListener(&quot;message&quot;, func); html5 Websocket (new WebSocket(SERVER_URL)).addEventListener(&quot;message&quot;, func); 不可见的iframe WebSocket通过Flash XHR长时间连接 XHR Multipart Streaming script标签的长时间连接(可跨域) 列举IE与其他浏览器不一样的特性？事件不同之处： 触发事件的元素被认为是目标（target）。而在 IE 中，目标包含在 event 对象的 srcElement 属性； 获取字符代码、如果按键代表一个字符（shift、ctrl、alt除外），IE 的 keyCode 会返回字符代码（Unicode），DOM 中按键的代码和字符是分离的，要获取字符代码，需要使用 charCode 属性； 阻止某个事件的默认行为，IE 中阻止某个事件的默认行为，必须将 returnValue 属性设置为 false，Mozilla 中，需要调用 preventDefault() 方法； 停止事件冒泡，IE 中阻止事件进一步冒泡，需要设置 cancelBubble 为 true，Mozzilla 中，需要调用 stopPropagation() 什么叫优雅降级和渐进增强？ 优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用 渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验 无障碍设计Web Content Accessibility Guidelines (网页内容无障碍设计指南, 又称 WCAG) &amp; Accessible Rich Internet Applications (富Internet应用程序的无障碍设计, 又称 ARIA) 无障碍设计是指产品, 设备, 服务, 或者环境是为残疾人设计的. 无障碍设计的概念意味着与一个人的辅助技术(例如, 电脑屏幕阅读器)相兼容, 确保直接访问(即独立)和”间接访问”. 无障碍设计可以理解为 “能够访问”, 并对一个系统或实体是有利的, 其侧重于使身体残障, 或有特殊需要, 或要依赖辅助技术的人群能够访问 Web. 然后, 研究和开发无障碍设计对每个人都带来了好处. 无障碍设计不应该和可用性混淆. 大多数情况下, 可用性是指产品(如: 设备, 服务, 或者环境)能在特定的环境下被特定的用户使用, 来高效地实现制定目标. 无障碍设计和通用性设计是息息相关的. 通用型设计是指产品的创造过程中, 产品对人们是可用的, 并尽可能最大范围覆盖各能力范围内的人群和各种情形下的操作, 即对所有人是可访问的(无论他们访问 Web 是否有障碍). - wikipedia 综合学习: Web应用程序通用设计 [read][RMB] Web 无障碍设计入门 [watch][$] Web 无障碍设计介绍 [read] 兼济天下·用户无障碍体验的可访问性设计 [read][RMB] UX 基础: 无障碍设计 [watch][$] Web 无障碍设计介绍 [watch] 标准/规范: 无障碍设计网络倡议 (WAI) 网页内容无障碍设计指南 (WCAG) 的目前状态 富 Internet 应用程序的无障碍设计 (WAI-ARIA) 的目前状态 译者补充: Web 端开发常用资源 Web 前端开发资源","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"前端技能","slug":"前端技能","permalink":"https://qw8.github.io/tags/前端技能/"},{"name":"PS","slug":"PS","permalink":"https://qw8.github.io/tags/PS/"},{"name":"Git","slug":"Git","permalink":"https://qw8.github.io/tags/Git/"},{"name":"SEO","slug":"SEO","permalink":"https://qw8.github.io/tags/SEO/"},{"name":"重构","slug":"重构","permalink":"https://qw8.github.io/tags/重构/"},{"name":"前端","slug":"前端","permalink":"https://qw8.github.io/tags/前端/"},{"name":"移动端","slug":"移动端","permalink":"https://qw8.github.io/tags/移动端/"}]},{"title":"网页设计模式","slug":"knowledges/网页设计模式","date":"2020-10-28T07:55:55.000Z","updated":"2023-04-14T17:01:50.000Z","comments":true,"path":"/knowledges/wang-ye-she-ji-mo-shi.html","link":"","permalink":"https://qw8.github.io/knowledges/wang-ye-she-ji-mo-shi.html","excerpt":"","text":"全屏网页设计(Full Screen Design)网站设计制作所谓设计不分家，近年来平面设计里“纯净”“留白”等概念也被互联网设计吸取，为了更简单明了的突出主体，提供更舒适的感官感受，很多网站开始采用全屏网页设计，利用精心挑选设计的漂亮背景，加上合理的页面布局，视觉冲击力大可很好的吸引观者注意。通常页面内的文字内容不会特别多(所出现的少量文字加上精美的排版将会变得更加吸引人)，主要以图片展示为主。这个样子的网站多用于摄影团队或个人作品集展示会比较常见。虽然简单养眼，但是承载信息有限，公司部门的主页很少见这样的设计。 响应式网页设计(Responsive Web Design)现在越来越多用户都拥有多种终端：台式机，笔记本，平板电脑，手机，能够适应不同尺寸显示屏的网页是现在的潮流，甚至是未来很长一段时间的设计趋势。那么响应式网页设计就是来解决这个问题的。这种特别的开发方式能保证网页适应不同的分辨率，让网页要素重组，使其无论在垂直的平板电脑还是智能手机上，都能达到最好的视觉效果。 网站设计制作除了多终端的多样化，我们还可以看到我们的电脑屏幕，手机屏幕都在不断变大，而在对未来生活的预测、概念设计里，“屏幕”这个产物更是被运用到多种新平台上。例如微软发布的“未来生活概念视频”里，厨房、室内墙壁、办公室玻璃墙面都成为了交互平台。所以我们可以发现，响应式网页设计所具备的良好的适应性和可塑性，在未来的网页设计里将占有举足轻重的位置。 扁平化设计(Flat Design)网站设计制作扁平化设计可以说是去繁从简的设计美学。去掉所有装饰性的设计，可以说是对之前所推崇的拟物化设计的颠覆。我们不能妄加评论说这是好还是不好，只能说它提供了一种新的设计思维。扁平化设计是否会成为将来的趋势我们也无法回答，尽管褒贬不一，备受争议，但是就现在来说它是当下的一种潮流。 视差滚动设计(Parallax Design)鼠标悬停视差效果、视差特效也一直是热门的设计趋势。在深色背景上，搭配粒子特效的视差特效几乎能够立马创造出3D的视觉效果。视差特效伟大的地方在于，你无需特别精准地选取特定的图片，就能营造出良好的视差效果。网站设计制作视差设计可以说是近年来网页设计中的一大突破，也备受推崇。视差滚动是让多层背景以不同速度滚动，以形成一种3D立体的运动效果，给观者带来一种独特的视觉感受。 除此以外，鼠标滚轮的流畅体验，让用户在观看此类网站时有一种控制感，简单来说这是有响应的交互体验。就好像童年看到走马灯，转动它你就能看到人物动起来，还能欣赏故事。视差滚动设计的趣味也在于此。所以无论是网站还是电商商品宣传页都经常采用视差设计，吸引眼球也很受用户喜爱。 当你需要让你的标题、LOGO和场景拥有真实的质感的时候，一个视差特效能够快速的给你以提升。当然，视差特效同样适用于各种抽象的动画。当触发鼠标悬停事件的时候，对应元素会增加一个维度，用就可以移动鼠标与之进行互动。 Alexandre Rochet 的个人作品页就将视差效果玩的出神入化。视差特效让页面中的元素显得非常的醒目。 小贴士：用来生成视差特效的代码库和代码片段有很多，最受欢迎的应该是Matthew Wagerfield 所创造的一款插件，名为 Parallax.js 。如果你在实际运用中更注重排版，那么不妨试试 Frontnerd，它的特色在于生成鼠标可控的3D视差效果。 无限滚动模式(瀑布流)有一些网站内容很多，但他们并没有简单分页，而是采用的是一种垂直瀑布流的方式布局。将那些内容垂直排布，当用户纵向滚动时，内容会不断更新好像永无止境。这样的瀑布流很早之前就开始流行，最早采用该布局的是pinterest。这样的滚动页面就大大减少了分页的数量，个人认为对于这类信息量大，每日更新数据快的网站是比较不错的方案。 滚动侦测网页设计(Scrollspy)网站设计制作利用CSS的实现将导航栏固定在网页顶部(大多数是顶部，当然也有侧面或底部)，并将版面内容按照导航顺序垂直或横向排布，使得用户点击相应导航tab时页面自动滑到相应页面，而若点击内容，导航也将随之改变。这样的网页设计页面基本不会跳转，每一个tab所指向的页面内容也基本一屏显示完整，所以在页面呈现的内容上会有所局限。为不影响布局一般也会伴随自适应。 滚动侦测式的网页会给设计师带来了很大挑战——要在有限空间内保证内容呈现的完整性，故设计师会在版面上下足功夫。而这类网站结构和视差设计有异曲同工之处，所以我们发现很多网站会结合两者，给观者带来不一样的视觉感受和用户体验。 网页的风格化设计(The style design of Webpage)网站设计制作现在的网页早已不再像过去受诸多条件和技术限制了。其呈现方式颇为丰富。风格从清新到复古，插画手绘到拟真设计，无奇不有。无论是版面版式，还是设计元素，用标新立异这个词形容绝不为过。根据自己撇到的冰山一角，提一下对我感触最深的变化： (1)注重字体设计(Pay attention to the font design) 近年来很多设计师将字体设计也融入了网页设计中，并作为设计的一个重要元素提升整个网页品味。通过使用CSS3设计师可以拥有许多自定义的字体，这给网页的视觉设计也增加了一个重要的设计思路。 (2)丰富灵活的动画(The flexible animation) Html5和flash的广泛应用，让网站设计制作的交互动画变得更加生动有趣。 通过观察这些趋势如何影响现代网站设计，或许可以为网页设计师带去指引，发散出新想法。 (3)平面设计感的加强(Strengthen the sense of graphic design) 网站设计制作随着设备和技术的革新，早已突破了过去单一框架的限制，变得更加灵活。所以就页面风格更多地开始向平面设计靠近，许多页面设计得极赋海报和杂志的版式感。时尚而富有冲击力。 简约风设计极简主义设计风格，也称简约设计风格，顾名思义，就是使用尽可能少的组件或部件，实现网站以及软件应用的人机交互。 当然，这并不代表设计师可以毫无节制的简化网页或软件界面，以致丢失掉其本有魅力和生命力，造成界面难以理解，甚至使用更加复杂的局面。反而应该在去除多余组件或模块的基础上，使用最少的元素，达到最佳的用户体验和销售效果。界面中每一个小细节都应该被重视，且饱含设计师创意和用心。 界面简单整洁，便于用户理解和操作，还因其在提升网站和软件应用的加载速度，页面屏幕兼容度，以及用户体验愉悦度等方面，作用巨大。 1.简约网页设计更加简洁易用，用户体验愉悦度极高 2.极简主义设计简单且兼容性强，更易于软件或网页响应式设计 3.简单干净的界面设计更符合现今快节奏的用户需求 4.简约整洁的网页设计，加载速度更快，能有效地降低网页跳出率 5.简洁低噪音的界面设计，更易于用户专注于界面内容和产品功能，提升产品销量 50个简约风黑白网页设计 极简网页设计技巧，打造简约之美 单页以及全屏视频背景设计 传统意义上的背景主要是使用图片，近几年开始流行视频背景了。而这些主要还是集中在网站的页头、Banner等位置，大多用来欢迎用户，推荐内容。许多网站都采取了相似的策略，让用户有所期待。 在网页上全屏幕显示视频，在以前应该只有 Flash 可以做到，不过现在使用 HTML5 和 JavaScript 可以很好地让视频根据浏览器窗口的尺寸伸缩，下面的网站很好的展示了全屏幕视频的使用技巧。 我非常喜欢的一个网站，感受特别好 30个运用全屏视频背景的网页设计欣赏 粒子动效粒子动效是目前最流行的选择之一，很大程度上是因为这种方案对于目前的网站和浏览器而言，负载并不大，并且足够优雅。它可以很好地同纯色背景、插画、矢量素材甚至照片结合起来使用。 除此之外，颗粒的动效变化也有很多变化。可以是在整个页面中随机散布移动的点，也可以模仿雨滴和流星的运动轨迹，还能参考星座、星空和宇宙中行星的运动来设计。粒子动效还能和鼠标运动以及触发事件结合起来：可以让粒子避开光标，也能让粒子围绕这光标运动，甚至让运动轨迹紧跟光标运动，等等。 Huub 这个网站就是一个典型的案例，不同的点构成群组，点和点之间有细线连接，在黑色的背景上移动着形成自转的效果。当鼠标移动到附近的时候，光标所在处会形成新的点，与最近的光点连接。 小贴士：如果你想实现类似 Huub 这样的动态背景效果，不妨看看 Dominic Kolbe 所创建的名为Mouse Parallax Demo 的项目，它能给你带来近似的效果。如果你立刻马上想要一个高度可用的粒子特效背景的话，那么你应该看看 Vincent Garreau 所创建的 Particles.js 这个JS库。 波纹颗粒特效波纹粒子特效这个效果则是借由Three.js 来实现的。它让粒子构成平滑的波纹，然后上下波动产生呼吸的画布一样的效果。你还可以借助鼠标光标让它向着不同的方向旋转，你可以探索各种不同的玩法。 StuurMen 这个网站就借助波纹粒子特效来制作欢迎页面。它看起来精致而极简，内容以一种毫无侵略性的方式进入用户的视野，而波动粒子特效则让整个项目的氛围显得平滑而稳定。 小贴士：你可以在这里看到ThreeJS的原始脚本，Deathfang 成功地改写了这个脚本，并且将它制作成一个名为 three.js canvas – particles – waves 的demo。 设计师和开发者都需要和市场接轨并跟上潮流的脚步，但是所谓的潮流是当下的，未来确是未知的。网站设计制作的确需要保证自己不被行业趋势甩到队尾，但更重要的是在浪潮中适应和学习。","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://qw8.github.io/tags/设计模式/"},{"name":"网页设计","slug":"网页设计","permalink":"https://qw8.github.io/tags/网页设计/"}]},{"title":"我的书签链接","slug":"link/我的书签链接","date":"2020-10-12T02:12:21.000Z","updated":"2023-04-14T17:01:50.000Z","comments":true,"path":"/link/wo-de-shu-qian-lian-jie.html","link":"","permalink":"https://qw8.github.io/link/wo-de-shu-qian-lian-jie.html","excerpt":"","text":"书签本文从我的浏览器收藏夹整理而来 中北大学-个人门户CCTV节目官网首页计算机二级office试题_百度文库欢迎使用中北大学体育选课系统大鹏教育-高品质的设计师在线教育淘宝联盟阿里巴巴1688.com - 全球领先的采购批发平台,批发网计算机报名ETEST通行证NCRE报名系统游戏充值 - 腾讯充值中心卓智校园自助服务系统百度文库——让每个人平等地提升自我西西软件园_西西游戏网_多重安全的软件下载基地电子书预览教务系统_登陆百度翻译中北大学个人门户教务系统_登陆电影天堂_免费电影_迅雷电影下载非法集资案件投资人信息登记平台学工系统Struts2教程™w3cschool - 学编程，从w3cschool开始FishC-Web-Demo脚本之家_www.jb51.net阳光电影_免费电影_迅雷电影下载_电影天堂500集Android视频教程从入门到精通（完整版）_黑马程序员黑客之门 - 黑客网站大全，免费黑客网站，中国黑客网址导航QQ资源网-专注分享网络优质资源我要自学网-视频教程|免费教程|自学电脑|3D教程|平面教程|影视动画教程|办公教程|机械设计教程|网站设计教程-我要自学网小风教程网-黑客_免费黑客网_黑客技术教程_黑客软件工具淘管家 - 阿里巴巴淘宝网 - 淘宝开店淘货源-淘宝卖家专属货源服务平台Android Developersandroid开发教程21篇（强烈推荐,几乎每一篇都是精华教程） - qianqianlianmeng - 博客园博客园 - 代码改变世界Android开发的经典入门教材和学习路线？ - 知乎手机开通QQ会员Web前端全套视频教程-百战程序员_IT6000集_影响6000万学习IT的中国人【官网】北京尚学堂官网-IT培训|Java培训|人工智能+Python培训|大数据培训|区块链培训|Web前端培训清华大学出版社CSDN-专业IT技术社区最代码-最全面，最专业的源代码分享网站全端开发优逸客实训平台杨青青个人博客勒索病毒两周年专题报告php中文网-教程_手册_视频-免费php在线学习平台Flex 布局教程：语法篇 - 阮一峰的网络日志如何将PSD文件快速转换成HTML方法psd快速转化html模版(切图) - YangJack的博客 - CSDN博客Iconfont-阿里巴巴矢量图标库Cutterman - 为设计更专注GitHub爱资料在线工具-好用的在线工具箱前端集锦：十款精心挑选的在线 CSS3 代码生成工具 - 梦想天空（山边小溪） - 博客园秦伟的个人博客首页Web开发™ECMAScript 6 入门 - ECMAScript 6入门QQ推广华为云 +智能，见未来星火资源下载网首页经典散文大全_优美散文_名家散文_散文精选腾讯云学生服务器_学生机_云服务器优惠套餐-云+校园 - 腾讯云阿里云 - 上云就上阿里云Uniregistry让域名变得简单。OpenAPI Explorer开发者平台_开发者中心腾讯云 - 产业智变 云启未来3个方法解决百度网盘限速 （2019-05-23 更新） | 奔跑中的奶酪百度图片-发现多彩世界助学贷款JavaScript Array 对象js数组方法大全 - 流sand - 博客园博客园 - 代码改变世界创建地图-百度地图生成器浏览器脚本教程交易首页-域名交易首页-万网-阿里云旗下品牌JS中String对象的常用方法 - .smile - 博客园BVB源码站js代码 - IT资源下载平台HTML5资源教程 | 分享HTML5开发资源和开发教程字体设计教程_字体设计视频课程学习-虎课网艺术字体在线生成器 艺术字转换器 字体转换器艺术字体在线生成器 艺术字体转换器 艺术字在线转换晓梦晶晶转换器 - 晓梦晶晶字体生成器 - 晓梦晶晶下载 - QT86.COM自动设计艺术图片_百度搜索jQuery全国大学生创业服务网首页 - 廖雪峰的官方网站PhpStorm 快捷键大全 PhpStorm 常用快捷键和配置+如何关闭快捷键ctrl+alt+方向键旋转屏幕 - 谦信君 - 博客园首页网站源码下载,A5源码 - 更快的站长下载站网站源代码_百度搜索CSS/CSS3 中文参考文档手册最新版 | CSS参考手册 | CSS3参考手册阿里妈妈 大数据营销平台网站建设：简单动态网站搭建-腾讯云学院-云计算-综合实战-在线课程-文档学习 - 在线学习中心小程序模板_微信小程序模板购买_小程序开发多少钱-腾讯云阿里妈妈推广网址方法_百度搜索菜鸟教程 - 学的不仅是技术，更是梦想！DIY小程序开发平台-国内最大的微信小程序开发工具手把手教你 如何免费制作和开发自己的小程序_百度经验小程序免费模板平台_百度搜索站长素材-分享综合设计素材的平台2019虎牙小程序技术挑战赛Stargazers · huya-ext/miniapp · GitHub千库网_免费png图片背景素材下载,做设计不抠图摄图网-正版高清图片免费下载_商用设计素材图库凡科商城-你想要的砍价软件、分销系统、小程序裂变营销，这里都有！企业中心Node.js 中文网Koala - LESS/Sass/Compass/CoffeeScript编译工具Sass世界上最成熟、稳定和强大的CSS扩展语言 | Sass中文网npm | build amazing things我的网站站长之家 - 站长资讯-我们致力于为中文网站提供动力！全国大学生创业服务网新职业微信开放文档网站建设：部署与发布（windows &amp; Linux）-腾讯云学院-云计算-综合实战-在线课程-文档学习 - 在线学习中心Swiper中文网中华励志网 - 青春正能量OSCHINA - 中文开源技术交流社区jQuery插件库-收集最全最新最好的jQuery插件友盟+，国内领先的第三方全域数据服务商jQueryAllcky’s Blog数据库md5_百度搜索Bootstrap中文网jQuery API 中文文档 | jQuery API 中文在线手册 | jquery api 下载 | jquery api chm四川爱趣五科技有限公司Ghost 开源博客平台 | Ghost中文网BootCDN - Bootstrap 中文网开源项目免费 CDN 加速服务Grunt: JavaScript 世界的构建工具 | Grunt 中文网Lodash 中文文档 | Lodash 中文网gulp.js - 基于流的自动化构建工具。 | gulp.js 中文网webpack 中文文档 | webpack 中文网rollup.js 中文文档 | rollup.js 中文网npm 中文文档 | npm 中文网SASS - 成熟、稳定、强大的 CSS 扩展语言解析器 | SASS 中文网Laravel-简洁、优雅的PHP开发框架(PHP Web Framework)。- Laravel中文网（Laravel中国社区）PHP 编程之道PHP: Hypertext PreprocessorECharts在线 JS/CSS/HTML 压缩ACAA教育考试系统登录ACAA+ADSK考试科目列表 - 图文 - 百度文库layui - 经典模块化前端 UI 框架开源软件 - 码云 Gitee.com码云 Gitee — 基于 Git 的代码托管和研发协作平台w3school 在线教程Phpcms-中国领先的网站内容管理系统|网站管理系统phpcms-帮助教程PHPCMS - 后台管理中心中北大学软件学院V9帮助中心MDN Web 文档2019百度智能云-智能ABC 共拓未来开放技术-百度开发者中心百度地图开放平台 | 百度地图API SDK | 地图开发经典励志名言_励志故事_励志文章_励志签名_90励志网励志一生_人生指南_励志指南–人生成功励志指南网（中国酷6）励志一生_励志名言名人名言大全_励志电影歌曲排行_经典语录语句中国大学生励志范文学习第一门户网站-大学生网网页模板,网站模板,DIV+CSS模板,企业网站模板下载-模板之家IT培训班选优逸客,专注成为国内顶尖IT人才培训机构 - 优逸客教育官网PaperPass论文检测_论文查重_免费论文检测系统_毕业论文抄袭检测ThinkPHP框架 | 中文最佳实践PHP开源框架,专注WEB应用快速开发8年！百度文库搜索 - 基于php的网站的设计与实现IntelliJ IDEA 注册码哔哩哔哩 (゜-゜)つロ 干杯~-bilibili掘金 - juejin.im - 一个帮助开发者成长的社区牛客网 - 互联网求职神器和备考学习平台AppleBlue Dream – A cannabis branding and marketing agency.七牛云 - 国内领先的企业级云服务商淘宝联盟Postman | API Development EnvironmentPostman API 中文白皮书文档_Postman使用教程 - Chrome插件(谷歌浏览器插件)淘宝开放平台千牛ui万堂书院首页 - LearnKu 编码学习区LearnKu 终身编程者的知识社区看云 | 专注文档在线创作、阅读、分享和托管PHP: PHP 手册 - ManualJS 索引数组、关联数组和静态数组、动态数组 - musings - 博客园本地写好网站之后怎么上线到服务器 - my476530的博客 - CSDN博客PHP案例：实现数据库增删改查功能 - howard2005的专栏 - CSDN博客CSDN博客-专业IT技术发表平台Laravel China 社区 | Laravel China 社区 - 高品质的 Laravel 开发者社区学UI网—UI设计师学习教程平台优阁网(UIGREAT) - UI设计师学习交流社区传智播客官网-好口碑IT培训机构,一样的教育,不一样的品质站酷 (ZCOOL) - 设计师互动平台 - 打开站酷，发现更好的设计！UI中国-专业用户体验设计平台ui前端网 - 专注ui、web设计、网页设计、前端开发站酷海洛 - 正版图片,视频,字体,音乐素材交易平台 - 站酷旗下品牌UIkit中文网魔工坊_专业模板分享平台logo在线制作_logo设计在线生成 - 【LogoFree】免费LOGO在线制作网源码之家 - 提供最新免费网站源码下载！SegmentFault 思否百度 H5UEditor - 首页PHP100中文网 - 中国第一档PHP资源分享门户wangEditor - 轻量级web富文本编辑器AngularJS — Superheroic JavaScript MVW Framework在线加密解密在线工具 —— OSCHINA.NET社区CKEditor | Smart WYSIWYG HTML editor | Collaborative rich text editor实训系统平台Bootstrap 中文文档 · Bootstrap 是世界上最流行的、移动设备优先的、响应式前端开发框架。ECharts · HomeBlade · 轻量级、高性能、简洁优雅的 Web 框架慕课网-程序员的梦工厂前端学习的几个网站 - 祈澈菇凉 - CSDN博客大前端-关注前端开发前端网址导航-大前端自强学堂 - 在线教程 - w3c - 学习, 分享, 让你更强!突唯阿，领先的响应式网站建设平台API数据接口_免费数据调用-聚合数据Laravel学院 - Laravel学院致力于提供优质Laravel中文学习资源ProcessOn - 免费在线作图，实时协作体验服专区-王者荣耀官方网站-腾讯游戏中国高等教育学生信息网（学信网）Vue.jsuni-app官网DCloud - HBuilder、HBuilderX、uni-app、uniapp、5+、mui、wap2app、流应用、快应用开发工具、HTML5Vue.js 教程 | 菜鸟教程前端开发 -shinian156 (十年庞小海)Yusen’s Blog | 学习弯道超车的技巧！hexovuejsReact – 用于构建用户界面的 JavaScript 库AngularJS中文网Headless CMS and Content API | ButterCMS常见网页七种设计模式字体下载,字体大全,免费字体下载,在线字体|字客网Prototype JavaScript framework: a foundation for ambitious web applications腾讯地图揭秘腾讯街景地图：一项浩大的工程 | 爱范儿淘宝 NPM 镜像Node.js 教程 | 菜鸟教程PHPJavaScriptElement - 网站快速成型工具uekshowJQuery EasyUI中文网Easy Mockaxios中文网|axios API 中文文档 | axios微软 Bing 搜索 - 国内版Poetry’s BlogWeb 开发技术 | MDNHTML5 - Web 开发者指南 | MDNHTML5手册，HTML5语义标签，HTML5新属性，HTML5教程前端开发博客-前端开发,前端博客HTML5和CSS3新特性一览 - FeMiner - 博客园推荐四个phpstorm酷炫实用插件 让你写代码的时候不在孤单! - 石头大叔 - 博客园php文章管理系统_百度搜索排名前10的vue前端UI框架框架值得你掌握 - 个人文章 - SegmentFault 思否RESTful 架构详解 | 菜鸟教程thinkphp文章管理_百度搜索back-manage作业React 中文文档 - 用于构建用户界面的 JavaScript 库TypeScript 中文手册 - TypeScript 中文手册jQuery API 中文文档 | jQuery 中文网Next.jsYarn 中文文档📦 Parcel 中文文档 | Parcel 中文网编码规范 by @mdoLESS « 一种动态样式语言腾讯开放平台beta|开放成就梦想腾讯游戏学院-成就游戏梦想！XMind思维导图 | XMind中文官方网站响应式设计快速指南_w3cschool网络违法犯罪举报网站Mindmap Gallery - XMind - Mind Mapping Softwarephp中文网-教程_手册_视频-免费php在线学习平台348万个编程源码资料 联合开发网 - pudn.com布布扣-打开技术之扣，分享程序人生-bubuko.com2015-2016前端知识体系 - 时间朋友 - 博客园《大规模 web服务开发》笔记 - 浮云比翼 - 博客园微信导出聊天记录为word_百度搜索Mock.js赵克立博客_网络编程百度搜索资源平台_让网站更具价值百度统计——最大的中文网站分析平台爱给网_音效配乐_3D模型_视频素材_游戏素材_免费下载图怪兽作图神器-在线图片编辑器-PS图片制作-搞定平面设计不求人前后端分离原理 - 云+社区 - 腾讯云预告片世界 - 2019最新电影预告片免费下载【抖音短视频】记录美好生活-Douyin.com美文阅读网_经典短篇爱情美文摘抄,优美情感散文日志精选_美文网全国互联网安全管理服务平台bailicangdu (cangdu)bailicangdu/vue2-manage: 基于 vue + element-ui 的后台管理系统生活没有如果，且行且珍惜-情感美文-748219美文网中国梦与我的梦_百度搜索php日记网站_百度搜索(青春日记)多用户网络日记PHP版|(青春日记)多用户网络日记PHP版 v1.0下载_网站源码_站长下载留言日记,php 留言本,留言板,许愿墙,留言系统 - 下载列表 - 中国站长下载Webpack 入门教程 | 菜鸟教程【vue.js的运行环境】 - CSDN婚礼MV视频短片制作_免费婚礼视频制作软件「拾光机」我图网-专注商用版权图片设计素材,专业设计素材图片下载网站pc6下载站-官方软件下载基地-安全、高速、放心的下载网站！网站建设指南 | 菜鸟教程拉勾网-专业的互联网招聘平台全国互联网安全管理服务平台中共中央网络安全和信息化委员会办公室中国互联网络信息中心如何导出安卓手机微信聊天记录到电脑查看腾讯微校-数字校园从微校开始微涅科技github上值得关注的前端项目 - trigkit4 - SegmentFault 思否前端最强面经汇总 - aoping - SegmentFault 思否AUI-靠谱的移动前端框架前端网站罗磊的独立博客WEEX黑马程序员官网-IT培训机构|java培训班|python培训|大数据培训|Web前端课程|软件测试课程web前端零基础视频教学_免费获取web前端精品资源_web前端交流个推，专业的数据智能服务商ionic 教程 | 菜鸟教程Amaze UI | 中国首个开源 HTML5 跨屏前端框架 | Amaze UIPhoneGap中国，致力于PhoneGap本地化的发展，关注html5，竭诚为广大中文移动以及Web开发者服务!最全前端资源各学科学习路线图-黑马程序员技术交流社区金数据 - 人人可用的在线表单工具Express - 基于 Node.js 平台的 web 应用开发框架 | Express 中文文档Vue全家桶 之 KTV前台收银管理系统 (不想努力啦，回家收钱去) - 个人文章 - SegmentFault 思否个人分享–web前端学习资源分享 - 守候书阁 - SegmentFault 思否CODING - 一站式软件研发管理平台docsify文档网站生成工具字节跳动内推-我们部门真的很缺人，leader一直找我要简历_讨论区_牛客网iView - A high quality UI Toolkit based on Vue.jsMuse-UIamWiki轻文库 - 轻量级前端化文库引擎九款个人知识管理工具介绍 - levbf的专栏 - CSDN博客Atom介绍 - v-chartslb-element-table资源邦 - 一个有态度的源码、模板、视频和教程资源分享平台!thinkphp与ajax_百度搜索vue_vue全家桶_个人博客梁兴华个人博客-一个IT互联网人士的的个人博客网站vuejs作者/awesome-vue: 🎉 A curated list of awesome things related to Vue.jsEvan You尤小右vue作者github上最全的资源教程-前端涉及的所有知识体系【转】 - Warriors - 博客园github上最全的资源教程-前端涉及的所有知识体系 - 蓝猫163 - 博客园Github资源收集——前端篇 - 简书整理一些前端开发大牛 -逐梦个人博客锐捷网络股份有限公司招聘系统vue项目实现github在线预览功能_vue.js_脚本之家全国招聘网_全国人才网_求职_找工作_上智联招聘兼容 IE6+、完美支持移动端、图表类型丰富的 HTML5 交互图表 | HighchartsFlutter中文网Babel · The compiler for next generation JavaScriptHexohexo史上最全搭建教程 - Fangzh的技术博客 - CSDN博客HexoYusen’s Blog | 学习弯道超车的技巧！poetries/mywiki: 收集整理日常发现的好资源、前端资源汇总设计订阅 - 腾讯设计导航HexohexohexoWeb安全测试之XSS - 小坦克 - 博客园Cookie/Session的机制与安全 | Harttle Land浅谈CSRF攻击方式 - hyddd - 博客园浏览器的同源策略 - Web 安全 | MDN不要再问我跨域的问题了 - 个人文章 - SegmentFault 思否跨域阿里Font Awesome 中文网 – | 字体图标hexouyan友言评论idGitment评论插件的使用 - Johnson木木 - 博客园尹华峰博客 - 关注互联网和搜索引擎网站SEO优化技术介绍 | ValineLeanCloud工业和信息化部ICP/IP地址/域名信息备案管理系统https://node.hnz.kimhttps://react.hnz.kimAngularallcky (Allcky)Material design 中文文档，指南，翻译hexohexo的TRHX’S BLOGhexo的主题Material X | xaoxuu’s wikiHexo 博客主题个性化 | TRHX’S BLOGhexo-EYHN (EEEEEEYHN)EYHN/hexo-helper-live2d: Add the Sseexxyyy live2d to your hexo!JavaScript 运行机制详解：再谈Event Loop - 阮一峰的网络日志静态文件jsDelivr - A free, fast, and reliable Open Source CDN for npm &amp; GitHub腾讯校园招聘Express 4.x API 中文文档 | 菜鸟教程Angular最全整理浏览器兼容性问题与解决方案 - weixin_38536027的博客 - CSDN博客1.1 ES6 教程 | 菜鸟教程校园招聘查询系统 - 海投网招聘岗位|阿里巴巴校园招聘|新世界 由你造百度校园招聘EJS – 嵌入式 JavaScript 模板引擎 | EJS 中文文档ruanyf (Ruan YiFeng)JavaScript 教程 - 网道网道 - 互联网开发文档ruanyf/jstraining: 全栈工程师培训材料中国知网BootstrapVue推荐几个山西的旅游景点-百度经验微信公众平台微信开放平台找工作，校园招聘信息，智联校园招聘Koa (koajs) – 基于 Node.js 平台的下一代 web 开发框架 | Koajs 中文文档egg - 为企业级框架和应用而生深入javascript之原型和原型链 - Yucihent的博客 - CSDN博客再谈javascriptjs原型与原型链及继承相关问题 - zhoulujun - 博客园好记么磁力搜 - 开源的磁力聚合搜索WeUI微信小程序WeUI小程序 中文文档 · 看云城市联合网络电视台 CUTV.COM城视网法制在线 - 城市联合网络电视台_太原台全国大学英语四、六级考试成绩查询 - 中国教育考试网找工作-互联网招聘求职网-拉勾网图片在线转换Base64_图片编码base64_image转base64_base64图片编码_base64图片转换 - 多视通北京威克逊顾问有限公司_百度百科北京东方国信科技股份有限公司招聘系统校园招聘-锐捷网络加入字节跳动-校园招聘奇安信集团2020校园招聘ByteDance字节跳动中北大学招生与就业工作处mpvue.com小程序WePY | 小程序组件化开发框架Electron | 使用 JavaScript, HTML 和 CSS 构建跨平台的桌面应用。Ionic - Cross-Platform Mobile App DevelopmentReact Native 中文网 · 使用React来编写原生应用的框架Aotu.io「凹凸实验室」Taro | 多端统一开发解决方案中北大学就业创业网【找工作_人才招聘_北京招聘信息】-百度百聘postcss-mpvue-wxss - npmPostCSS Wxss | mpvue.comMeituan-Dianping/mpvue: 基于 Vue.js 的小程序开发框架，从底层支持 Vue.js 语法和构建工具体系。michael-ciniawsky/postcss-load-config: Autoload Config for PostCSS百度网盘破解版王商博客 - 关注站长、区块链空投糖果的自媒体博客中北大学体育管理信息系统登录全国大学英语四、六级考试报名网中北大学中北大学教务处【58校招|58校园招聘|58 2020校园招聘|】 - 58校园招聘官网力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台帐号关联-帐号设置口袋影院 - 最新电影电视剧手机免费在线观看百度云观测 - 百度旗下网站云监测平台|免费安全检测|网站测速|漏洞扫描|网站检测百度Web开发者中心_BrilliantOpenWeb_前端开发_Web技术hexo高阶教程：想让你的博客被更多的人在搜索引擎中搜到吗？ - sunshine940326的博客 - CSDN博客影视大全 -无广告在线云点播 -迅雷电影下载电影天堂_免费电影_迅雷电影下载InfoQ - 促进软件开发领域知识与创新的传播-极客邦制作ico图标 | 在线ico图标转换工具 方便制作favicon.ico - 比特虫 - Bitbug.netPHP 将ThinkPHP项目部署阿里云服务器 - love and share - CSDN博客Ubuntu 16] - u014570569的博客 - CSDN博客2018 前端性能优化清单（转载） - QinBridge - OSCHINALeesin’s Blog（hexo）cherry-blog（hexo博客）Hexo加载优化 - 简书hexo高阶教程：教你怎么让你的hexo博客在搜索引擎中排第一 - 简书Hexo 优化 — lazyload 图片懒加载 | 赵俊的博客Asp.net源码专业站|- 51Aspx.com中北大学就业创业网从零开始nodejs系列文章-nodejs到底能干什么 - 小北哥哥和北妈 - CSDN博客什么是RESTFUL？REST的请求方法有哪些，有什么区别？ - IT修真院：初学者转行到互联网的聚集地 - CSDN博客Mock.js简书 - 创作你的创作ChanceCSS_网页制作 - 脚本之家前端开发者指南 2018(Front-End Developer Handbook 2018)天赋好书（cnToFu.com）– 分享开源电子书前端 - 掘金 - juejin.im - 一个帮助开发者成长的社区稀土区 – 优秀设计开发资源分享稀土 － 帮助开发者创造出影响世界的新技术[百度网盘-全部文件](https://pan.baidu.com/disk/home?errno=0&amp;errmsg=Auth Login Sucess&amp;&amp;bduss=&amp;ssnerror=0&amp;traceid=#/all?path=%2F&amp;vmode=list)coding团队概览 - 团队帐户 - qw8腾讯云开发者平台 | 技术助力开发朝阳繁星梦 - 个人首页 - 代码托管、DevOps、Git/SVN 、持续集成 、Jenkins秦伟 的工作台 - qw8","categories":[{"name":"链接","slug":"链接","permalink":"https://qw8.github.io/categories/链接/"}],"tags":[{"name":"网站","slug":"网站","permalink":"https://qw8.github.io/tags/网站/"},{"name":"个人收藏","slug":"个人收藏","permalink":"https://qw8.github.io/tags/个人收藏/"},{"name":"常用链接","slug":"常用链接","permalink":"https://qw8.github.io/tags/常用链接/"},{"name":"书签","slug":"书签","permalink":"https://qw8.github.io/tags/书签/"}]},{"title":"响应式布局","slug":"knowledges/响应式布局","date":"2020-09-29T08:25:46.000Z","updated":"2023-04-14T17:01:50.000Z","comments":true,"path":"/knowledges/xiang-ying-shi-bu-ju.html","link":"","permalink":"https://qw8.github.io/knowledges/xiang-ying-shi-bu-ju.html","excerpt":"","text":"响应式布局Responsive design，意在实现不同屏幕分辨率的终端上浏览网页的不同展示方式。通过响应式设计能使网站在手机和平板电脑上有更好的浏览阅读体验。屏幕尺寸不一样展示给用户的网页内容也不一样，我们利用媒体查询可以检测到屏幕的尺寸（主要检测宽度），并设置不同的CSS样式，就可以实现响应式的布局。 我们利用响应式布局可以满足不同尺寸的终端设备非常完美的展现网页内容，使得用户体验得到了很大的提升，但是为了实现这一目的我们不得不利用媒体查询写很多冗余的代码，使整体网页的体积变大，应用在移动设备上就会带来严重的性能问题。 响应式布局常用于企业的官网、博客、新闻资讯类型网站，这些网站以浏览内容为主，没有复杂的交互。 自适应与响应式区别自适应： 不管屏幕多大，都尽量不换行，而只是横向缩放。 响应式： 屏幕变小了之后，属于同一行的元素受到挤压后，行的右边元素自动换行显式； 屏幕大了后，本属于同一行的元素尽可能的排在同一行内； 使用媒体查询说明：适合于不太复杂的可以兼容的网站(一般都不太大) 语法：@media 媒体查询标志[only] screen [只]支持屏幕and 并且的意思min-width 最小宽度max-width 最大宽度min-height 最小高度(了解)max-height 最大高度(了解) 使用方式1：使用@media指定1234567@media screen and (max-width:768px) &#123;div &#123; width: 100%; height: 200px; background: green; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-view /&gt; &lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;less&quot;&gt; * &#123; margin: 0; padding: 0; list-style: none; &#125; html, body &#123; width: 100%; height: 100%; &#125; #app &#123; width: 100%; height: 100%; background-image: url(&apos;./assets/img/home/bg.png&apos;); background-size: 100% auto; overflow-x: hidden; &#125; // 适配移动端 @media screen and (max-width: 768px) &#123; .Home_Font &#123; .el-menu-item &#123; padding: 0 10px; font-size: 14px; &#125; &#125; &#125; // 适配PC端 @media screen and (min-width: 768px) &#123; .Home_Font &#123; .el-menu-item &#123; padding: 0 20px; font-size: 18px; &#125; &#125; &#125;&lt;/style&gt; 使用方式2：使用@import导入@import url(02-chaoxiao.css) screen and (max-width:768px); 使用方式3：使用link标签，然后指定media属性viewport说明：viewport 是用户网页的可视区域，翻译为中文可以叫做”视区”。是网页默认的宽度和高度 width：控制 viewport 的大小，可以指定的一个值，如 600，或者特殊的值，如 device-width 为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）。 height：和 width 相对应，指定高度。 initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。 maximum-scale：允许用户缩放到的最大比例。 minimum-scale：允许用户缩放到的最小比例。 user-scalable：用户是否可以手动缩放，设为no禁止缩放 在网页代码的头部，加入一行viewport元标签 12// viewport元标签，网页宽度默认等于屏幕宽度&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt; 可见如果不定义viewpoint的话，页面宽度以屏幕分辨率为基准，而设置以后可以根据设备宽度来调整页面，达到适配终端大小的效果 手机浏览器是把页面放在一个虚拟的“窗口”（viewport）中，通常这个虚拟的“窗口”（viewport）比屏幕宽，这样就不用把每个网页挤到很小的窗口中（这样会破坏没有针对手机浏览器优化的网页的布局），用户可以通过平移和缩放来看网页的不同部分。移动版的 Safari 浏览器最新引进了 viewport 这个 meta tag，让网页开发者来控制 viewport 的大小和缩放，其他手机浏览器也基本支持。 Boostrap简介： Bootstrap 是基于HTML、CSS、JavaScript 开发的简洁、直观、强悍的前端开发框架。 Bootstrap 是最受欢迎的 HTML、CSS 和 JS 框架，用于开发响应式布局、移动设备优先的 WEB 项目。 容器：所有的元素都要放在容器中，然后才能使用bootstrap提供的样式 containre：固定尺寸(有留白) container-fluid：流式布局(填满) 栅格系统：将给的的区域划分为12等分，通过份数来设置宽度 行：row、 份数：col-xs-份数、col-sm-份数、col-md-份数、col-lg-份数 列偏移：col-xs-offset-份数、col-sm-offset-份数、col-md-offset-份数、col-lg-offset-份数 列排序：col-md-push-份数（向右）、col-md-pull-份数（向左） 栅格系统可以嵌套 Boostrap的自适应功能其实理解栅栏模式之后，自适应功能就简单很多了，根据浏览器的大小，Boostrap有四种栅栏类名提供使用，用法与Css样式表类名选择器样式调用是一样的： xs：col-xs-1 ~ col-xs-12，多列始终在一行内。 sm：col-sm-1 ~ col-sm-12，多列在浏览器像素宽度大于等于768px时才在一行内。 md：col-md-1 ~ col-md-12，多列在浏览器像素宽度大于等于992px时才在一行内。 lg：col-lg-1 ~ col-lg-12，多列在浏览器像素宽度大于等于1200px时才在一行内。 使用Bootstrap响应式布局实现方式：通过查询screen的宽度来指定某个宽度区间的网页布局。 超小屏幕 （移动设备） w&lt;768px 小屏设备 768px-992px 768 &lt;= w &lt;992 中等屏幕 992px-1200px 992 =&lt; w &lt;1200 宽屏设备 1200px以上 w&gt;=1200 首先需要在head中引入meta标签，添加viewpirt属性，content中宽度等于设备宽度， initial-scale:页面首次被显示可见区域的缩放级别，取值1则页面按实际尺寸显示，无任何缩放；maximum-scale:允许用户缩放到的最小比例；user-scalable:用户是否可以手动缩放。代码如下： 123&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.bootcss.com/bootstrap/4.0.0/css/bootstrap.min.css&quot; integrity=&quot;sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm&quot; crossorigin=&quot;anonymous&quot;&gt; Boostrap的栅格系统Boostrap自适应功能的基础就是“栅栏”模式，它是将浏览器以行列形式去划分：一共12列，行数自定义，根据你所要显示的元素，确定每个元素显示的大小即需要的列数，如果超过范围，就会自动转行。每列的大小是Boostrap根据当前浏览器的大小自动平均分配。 Bootstrap 提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。它包含了易于使用的预定义类，还有强大的mixin 用于生成更具语义的布局。 简介栅格系统用于通过一系列的行（row）与列（column）的组合来创建页面布局，你的内容就可以放入这些创建好的布局中。下面就介绍一下 Bootstrap 栅格系统的工作原理： “行（row）”必须包含在 .container （固定宽度）或 .container-fluid （100% 宽度）中，以便为其赋予合适的排列（aligment）和内补（padding）。 通过“行（row）”在水平方向创建一组“列（column）”。 你的内容应当放置于“列（column）”内，并且，只有“列（column）”可以作为行（row）”的直接子元素。 类似 .row 和 .col-xs-4 这种预定义的类，可以用来快速创建栅格布局。Bootstrap 源码中定义的 mixin 也可以用来创建语义化的布局。 通过为“列（column）”设置 padding 属性，从而创建列与列之间的间隔（gutter）。通过为 .row 元素设置负值 margin 从而抵消掉为 .container 元素设置的 padding，也就间接为“行（row）”所包含的“列（column）”抵消掉了padding。 负值的 margin就是下面的示例为什么是向外突出的原因。在栅格列中的内容排成一行。 栅格系统中的列是通过指定1到12的值来表示其跨越的范围。例如，三个等宽的列可以使用三个 .col-xs-4 来创建。 如果一“行（row）”中包含了的“列（column）”大于 12，多余的“列（column）”所在的元素将被作为一个整体另起一行排列。 栅格类适用于与屏幕宽度大于或等于分界点大小的设备 ， 并且针对小屏幕设备覆盖栅格类。 因此，在元素上应用任何 .col-md-*栅格类适用于与屏幕宽度大于或等于分界点大小的设备 ， 并且针对小屏幕设备覆盖栅格类。 因此，在元素上应用任何 .col-lg-*不存在， 也影响大屏幕设备。 通过研究后面的实例，可以将这些原理应用到你的代码中。 媒体查询在栅格系统中，我们在 Less 文件中使用以下媒体查询（media query）来创建关键的分界点阈值。 Copy 1234567891011/* 超小屏幕（手机，小于 768px） *//* 没有任何媒体查询相关的代码，因为这在 Bootstrap 中是默认的（还记得 Bootstrap 是移动设备优先的吗？） *//* 小屏幕（平板，大于等于 768px） */@media (min-width: @screen-sm-min) &#123; ... &#125;/* 中等屏幕（桌面显示器，大于等于 992px） */@media (min-width: @screen-md-min) &#123; ... &#125;/* 大屏幕（大桌面显示器，大于等于 1200px） */@media (min-width: @screen-lg-min) &#123; ... &#125; 我们偶尔也会在媒体查询代码中包含 max-width 从而将 CSS 的影响限制在更小范围的屏幕大小之内。 Copy 1234@media (max-width: @screen-xs-max) &#123; ... &#125;@media (min-width: @screen-sm-min) and (max-width: @screen-sm-max) &#123; ... &#125;@media (min-width: @screen-md-min) and (max-width: @screen-md-max) &#123; ... &#125;@media (min-width: @screen-lg-min) &#123; ... &#125; 栅格参数通过下表可以详细查看 Bootstrap 的栅格系统是如何在多种屏幕设备上工作的。 超小屏幕 手机 (&lt;768px) 小屏幕 平板 (≥768px) 中等屏幕 桌面显示器 (≥992px) 大屏幕 大桌面显示器 (≥1200px) 栅格系统行为 总是水平排列 开始是堆叠在一起的，当大于这些阈值时将变为水平排列C .container 最大宽度 None （自动） 750px 970px 1170px 类前缀 .col-xs- .col-sm- .col-md- .col-lg- 列（column）数 12 最大列（column）宽 自动 ~62px ~81px ~97px 槽（gutter）宽 30px （每列左右均有 15px） 可嵌套 是 偏移（Offsets） 是 列排序 是 实例：从堆叠到水平排列使用单一的一组 .col-md-* 栅格类，就可以创建一个基本的栅格系统，在手机和平板设备上一开始是堆叠在一起的（超小屏幕到小屏幕这一范围），在桌面（中等）屏幕设备上变为水平排列。所有“列（column）必须放在 ” .row 内。 123456789101112131415161718192021222324252627&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-8&quot;&gt;.col-md-8&lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-6&quot;&gt;.col-md-6&lt;/div&gt; &lt;div class=&quot;col-md-6&quot;&gt;.col-md-6&lt;/div&gt;&lt;/div&gt; 实例：流式布局容器将最外面的布局元素 .container 修改为 .container-fluid，就可以将固定宽度的栅格布局转换为 100% 宽度的布局。 Copy 12345&lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;row&quot;&gt; ... &lt;/div&gt;&lt;/div&gt; 实例：移动设备和桌面屏幕是否不希望在小屏幕设备上所有列都堆叠在一起？那就使用针对超小屏幕和中等屏幕设备所定义的类吧，即 .col-xs-* 和 .col-md-*。请看下面的实例，研究一下这些是如何工作的。 .col-xs-12 .col-md-8 .col-xs-6 .col-md-4 .col-xs-6 .col-md-4 .col-xs-6 .col-md-4 .col-xs-6 .col-md-4 .col-xs-6 .col-xs-6 Copy 123456789101112131415161718&lt;!-- Stack the columns on mobile by making one full-width and the other half-width --&gt;&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-12 col-md-8&quot;&gt;.col-xs-12 .col-md-8&lt;/div&gt; &lt;div class=&quot;col-xs-6 col-md-4&quot;&gt;.col-xs-6 .col-md-4&lt;/div&gt;&lt;/div&gt;&lt;!-- Columns start at 50% wide on mobile and bump up to 33.3% wide on desktop --&gt;&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-6 col-md-4&quot;&gt;.col-xs-6 .col-md-4&lt;/div&gt; &lt;div class=&quot;col-xs-6 col-md-4&quot;&gt;.col-xs-6 .col-md-4&lt;/div&gt; &lt;div class=&quot;col-xs-6 col-md-4&quot;&gt;.col-xs-6 .col-md-4&lt;/div&gt;&lt;/div&gt;&lt;!-- Columns are always 50% wide, on mobile and desktop --&gt;&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-6&quot;&gt;.col-xs-6&lt;/div&gt; &lt;div class=&quot;col-xs-6&quot;&gt;.col-xs-6&lt;/div&gt;&lt;/div&gt; 实例：手机、平板、桌面在上面案例的基础上，通过使用针对平板设备的 .col-sm-* 类，我们来创建更加动态和强大的布局吧。 .col-xs-12 .col-sm-6 .col-md-8 .col-xs-6 .col-md-4 .col-xs-6 .col-sm-4 .col-xs-6 .col-sm-4 .col-xs-6 .col-sm-4 Copy 1234567891011&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-12 col-sm-6 col-md-8&quot;&gt;.col-xs-12 .col-sm-6 .col-md-8&lt;/div&gt; &lt;div class=&quot;col-xs-6 col-md-4&quot;&gt;.col-xs-6 .col-md-4&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-6 col-sm-4&quot;&gt;.col-xs-6 .col-sm-4&lt;/div&gt; &lt;div class=&quot;col-xs-6 col-sm-4&quot;&gt;.col-xs-6 .col-sm-4&lt;/div&gt; &lt;!-- Optional: clear the XS cols if their content doesn&apos;t match in height --&gt; &lt;div class=&quot;clearfix visible-xs-block&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-xs-6 col-sm-4&quot;&gt;.col-xs-6 .col-sm-4&lt;/div&gt;&lt;/div&gt; 实例：多余的列（column）将另起一行排列如果在一个 .row 内包含的列（column）大于12个，包含多余列（column）的元素将作为一个整体单元被另起一行排列。 .col-xs-9 .col-xs-4Since 9 + 4 = 13 &gt; 12, this 4-column-wide div gets wrapped onto a new line as one contiguous unit. .col-xs-6Subsequent columns continue along the new line. Copy 12345&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-9&quot;&gt;.col-xs-9&lt;/div&gt; &lt;div class=&quot;col-xs-4&quot;&gt;.col-xs-4&lt;br&gt;Since 9 + 4 = 13 &amp;gt; 12, this 4-column-wide div gets wrapped onto a new line as one contiguous unit.&lt;/div&gt; &lt;div class=&quot;col-xs-6&quot;&gt;.col-xs-6&lt;br&gt;Subsequent columns continue along the new line.&lt;/div&gt;&lt;/div&gt; 响应式列重置即便有上面给出的四组栅格class，你也不免会碰到一些问题，例如，在某些阈值时，某些列可能会出现比别的列高的情况。为了克服这一问题，建议联合使用 .clearfix 和 响应式工具类。 .col-xs-6 .col-sm-3Resize your viewport or check it out on your phone for an example. .col-xs-6 .col-sm-3 .col-xs-6 .col-sm-3 .col-xs-6 .col-sm-3 Copy 12345678910&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-6 col-sm-3&quot;&gt;.col-xs-6 .col-sm-3&lt;/div&gt; &lt;div class=&quot;col-xs-6 col-sm-3&quot;&gt;.col-xs-6 .col-sm-3&lt;/div&gt; &lt;!-- Add the extra clearfix for only the required viewport --&gt; &lt;div class=&quot;clearfix visible-xs-block&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-xs-6 col-sm-3&quot;&gt;.col-xs-6 .col-sm-3&lt;/div&gt; &lt;div class=&quot;col-xs-6 col-sm-3&quot;&gt;.col-xs-6 .col-sm-3&lt;/div&gt;&lt;/div&gt; 除了列在分界点清除响应， 您可能需要 重置偏移, 后推或前拉某个列。请看此栅格实例。 Copy 123456789&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-5 col-md-6&quot;&gt;.col-sm-5 .col-md-6&lt;/div&gt; &lt;div class=&quot;col-sm-5 col-sm-offset-2 col-md-6 col-md-offset-0&quot;&gt;.col-sm-5 .col-sm-offset-2 .col-md-6 .col-md-offset-0&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-6 col-md-5 col-lg-6&quot;&gt;.col-sm-6 .col-md-5 .col-lg-6&lt;/div&gt; &lt;div class=&quot;col-sm-6 col-md-5 col-md-offset-2 col-lg-6 col-lg-offset-0&quot;&gt;.col-sm-6 .col-md-5 .col-md-offset-2 .col-lg-6 .col-lg-offset-0&lt;/div&gt;&lt;/div&gt; 列偏移使用 .col-md-offset-* 类可以将列向右侧偏移。这些类实际是通过使用 * 选择器为当前元素增加了左侧的边距（margin）。例如，.col-md-offset-4 类将 .col-md-4 元素向右侧偏移了4个列（column）的宽度。 .col-md-4 .col-md-4 .col-md-offset-4 .col-md-3 .col-md-offset-3 .col-md-3 .col-md-offset-3 .col-md-6 .col-md-offset-3 Copy 1234567891011&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt; &lt;div class=&quot;col-md-4 col-md-offset-4&quot;&gt;.col-md-4 .col-md-offset-4&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-3 col-md-offset-3&quot;&gt;.col-md-3 .col-md-offset-3&lt;/div&gt; &lt;div class=&quot;col-md-3 col-md-offset-3&quot;&gt;.col-md-3 .col-md-offset-3&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-6 col-md-offset-3&quot;&gt;.col-md-6 .col-md-offset-3&lt;/div&gt;&lt;/div&gt; You can also override offsets from lower grid tiers with .col-*-offset-0 classes. Copy 12345678&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-6 col-sm-4&quot;&gt; &lt;/div&gt; &lt;div class=&quot;col-xs-6 col-sm-4&quot;&gt; &lt;/div&gt; &lt;div class=&quot;col-xs-6 col-xs-offset-3 col-sm-4 col-sm-offset-0&quot;&gt; &lt;/div&gt;&lt;/div&gt; 嵌套列为了使用内置的栅格系统将内容再次嵌套，可以通过添加一个新的 .row 元素和一系列 .col-sm-* 元素到已经存在的 .col-sm-* 元素内。被嵌套的行（row）所包含的列（column）的个数不能超过12（其实，没有要求你必须占满12列）。 Level 1: .col-sm-9 Level 2: .col-xs-8 .col-sm-6 Level 2: .col-xs-4 .col-sm-6 Copy 12345678910111213&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-9&quot;&gt; Level 1: .col-sm-9 &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-8 col-sm-6&quot;&gt; Level 2: .col-xs-8 .col-sm-6 &lt;/div&gt; &lt;div class=&quot;col-xs-4 col-sm-6&quot;&gt; Level 2: .col-xs-4 .col-sm-6 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 列排序通过使用 .col-md-push-* 和 .col-md-pull-* 类就可以很容易的改变列（column）的顺序。 .col-md-9 .col-md-push-3 .col-md-3 .col-md-pull-9 Copy 1234&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-9 col-md-push-3&quot;&gt;.col-md-9 .col-md-push-3&lt;/div&gt; &lt;div class=&quot;col-md-3 col-md-pull-9&quot;&gt;.col-md-3 .col-md-pull-9&lt;/div&gt;&lt;/div&gt;","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"网页设计","slug":"网页设计","permalink":"https://qw8.github.io/tags/网页设计/"},{"name":"响应式布局","slug":"响应式布局","permalink":"https://qw8.github.io/tags/响应式布局/"}]},{"title":"性能优化","slug":"knowledges/性能优化","date":"2020-09-05T09:46:24.000Z","updated":"2023-04-14T17:01:50.000Z","comments":true,"path":"/knowledges/xing-neng-you-hua.html","link":"","permalink":"https://qw8.github.io/knowledges/xing-neng-you-hua.html","excerpt":"","text":"如何进行网站性能优化减少HTTP请求 CSS精灵（CSS Sprites） inline Image 合并样式和脚本 初始首屏之外的图片资源按需加载，静态资源延迟加载 文件大小 JS、CSS 源码压缩 图片大小控制合适、压缩图片 CSS/JS minify，减少文件体积 content方面 减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS查询 避免重定向：多余的中间访问 使Ajax可缓存 非必须组件延迟加载 未来所需组件预加载 减少DOM元素数量 将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量 减少iframe数量 不要404 Server方面 使用CDN 添加Expires或者Cache-Control响应头 对组件使用Gzip压缩 配置ETag Flush Buffer Early Ajax使用GET进行请求 避免空src的img标签 Cookie方面 减小cookie大小 引入资源的域名不要包含cookie CSS方面 将样式表放到页面顶部 避免使用css表达式，避免使用高级选择器，通配选择器 不使用IE的Filter Javascript方面 将脚本放到页面底部 将javascript和css从外部引入 压缩javascript和css 删除不需要的脚本 减少DOM访问 合理设计事件监听器 图片方面 优化图片：根据实际颜色需要选择色深、压缩 使用css图片精灵 不要在HTML中拉伸图片 保证favicon.ico小并且可缓存 移动方面 保证组件小于25k Pack Components into a Multipart Document 代码层面的优化 用hash-table来优化查找 少用全局变量 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能 用setTimeout来避免页面失去响应 缓存DOM节点查找的结果 避免使用CSS Expression 避免全局查询 避免使用with(with会创建自己的作用域，会增加作用域链长度) 多个变量声明合并 避免图片和iFrame等的空Src。空Src会重新加载当前页面，影响速度和效率 尽量避免写在HTML标签中写Style属性 性能优化方法 网页 Gzip（开启 Gzip 压缩），data 缓存 ，图片服务器。 前端模板 JS+数据，减少由于 HTML 标签导致的带宽浪费，前端用变量保存 AJAX 请求结果，每次操作本地变量，不用请求，减少请求次数 用 innerHTML 代替 DOM 操作，减少 DOM 操作次数，优化 javascript 性能。 当需要设置的样式很多时设置 className 而不是直接操作 style。 少用全局变量、缓存 DOM 节点查找的结果。减少 IO 读取操作。 避免使用 CSS Expression（css 表达式)又称 Dynamic properties(动态属性)。 图片预加载，将 CSS 放到顶部，JavaScript 放到尾部加上时间戳。 避免在页面的主体布局中使用 table，table 要等其中的内容完全下载之后才会显示出来，显示比 div+css 布局慢。 避免不必要的重绘与重排 优化 CSS 选择器（从右向左匹配） 使用 CDN 加速，适当进行文件缓存 合理控制 cookie 大小（每次请求都会包含 cookie） 缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等 请求带宽：压缩文件，开启GZIP 对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。 向前端优化：指的是在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。 减少数据库操作：指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询）。 减少磁盘IO：指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的 前端性能优化最佳实践？ 性能评级工具（PageSpeed 或 YSlow） 合理设置 HTTP 缓存：Expires 与 Cache-control 静态资源打包，开启 Gzip 压缩（节省响应流量） CSS3 模拟图像，图标base64（降低请求数） 模块延迟(defer)加载/异步(async)加载 Cookie 隔离（节省请求流量） localStorage（本地存储） 使用 CDN 加速（访问最近服务器） 启用 HTTP/2（多路复用，并行加载） 前端自动化（gulp/webpack） 简述一下你对 web 性能优化的方案1、尽量减少 HTTP 请求2、使用浏览器缓存3、使用压缩组件4、图片、JS 的预载入5、将脚本放在底部6、将样式文件放在页面顶部7、使用外部的 JS 和 CSS8、精简代码 移动端性能优化 尽量使用 css3 动画，开启硬件加速。 适当使用 touch 事件代替 click 事件。 避免使用 css3 渐变阴影效果。 尽可能少的使用 box-shadow 与 gradients，box-shadow 与 gradients 往往都是页面的性能杀手 页面大量图片，如何优化加载，优化用户体验图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。 如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。 如果图片为 css 图片，可以使用 CSSsprite，SVGsprite，Iconfont、Base64 等技术。 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。 如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。 渲染优化1、禁止使用 iframe（阻塞父文档 onload 事件） iframe 会阻塞主页面的 Onload 事件； 搜索引擎的检索程序无法解读这种页面，不利于 SEO; iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 使用 iframe 之前需要考虑这两个缺点。如果需要使用 iframe，最好是通过 javascript动态给 iframe 添加 src 属性值，这样可以绕开以上两个问题。 2、禁止使用 gif 图片实现 loading 效果（降低 CPU 消耗，提升渲染性能）；3、使用 CSS3 代码代替 JS 动画（尽可能避免重绘重排以及回流）css3 平面动画开启 translateZ(0)，打开浏览器 3d 加速，在一定程度可缓解卡顿。不宜多用； 4、对于一些小图标，可以使用 base64 位编码，以减少网络请求。但不建议大图使用，比较耗费 CPU；小图标优势在于： 1.减少 HTTP 请求； 2.避免文件跨域； 3.修改及时生效； 5、页面头部的&lt;style&gt;&lt;/style&gt; 会阻塞页面；（因为 Renderer 进程中 JS 线程和渲染线程是互斥的）；6、页面头部&lt;script&lt;/script&gt; 会阻塞页面；（因为 Renderer 进程中 JS 线程和渲染线程是互斥的）；7、页面中空的 href 和 src 会阻塞页面其他资源的加载 (阻塞下载进程)； 8、网页 Gzip，CDN 托管，data 缓存 ，图片服务器；9、前端模板 JS+数据，减少由于 HTML 标签导致的带宽浪费，前端用变量保存 AJAX 请求结果，每次操作本地变量，不用请求，减少请求次数10、用 innerHTML 代替 DOM 操作，减少 DOM 操作次数，优化 javascript 性能。11、当需要设置的样式很多时设置 className 而不是直接操作 style。12、少用全局变量、缓存 DOM 节点查找的结果。减少 IO 读取操作。13、避免使用 CSS Expression（css 表达式)又称 Dynamic properties(动态属性)。14、图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。 15、 避免在页面的主体布局中使用 table，table 要等其中的内容完全下载之后才会显示出来，显示比 div+css 布局慢。16、通过改变 src 的情况下**.MP3（不同于 mp3）在移动端有可能不能播放。 小程序首屏加载时间优化图片资源首先要选择合适的图片格式照片图片使用 webP。复杂的图形使用 PNG 或 JPG，看哪个格式的文件小。有透明度的图形使用 PNG 或 webP。可能缩放的图形、图标等使用 SVG。动态图尽量不使用 GIF，无法使用 CSS 的用视频替代。JS 优化首先排查在主线程上不要使用同步方法，减小主线程阻塞。开启小程序中的代码按需注入，避免没有使用的代码注入到小程序运行环境中，影响注入耗时和内存占用。生产环境去掉不必要的日志打印CSS 优化因为构建 CSSOM 树时会阻塞页面的解析，因此需要：删除没有使用的 CSS 代码减小 CSS 文件大小，如 #FFFFFF -&gt; #FFF ， 0px -&gt; 0，不要使用 Base64 编码的图片。资源优化 按照页面访问的频次，将图片资源分成常用的和不常用的，将常用的放入小程序代码包通过本地加载，将不常用的转换成 webp 放到服务器。 减小代码包体积：压缩代码包中的图片资源，对 PNG 格式的透明图设置更少的颜色数；通过依赖分析，更换体积更小的 markdown 渲染依赖。网络优化 为解决不同地域和运营商的访问速度，开启全站动态加速。 首次请求时需要进行域名的解析和建连，链路复用网络请求时间会变短。 对不经常变更且频繁访问的接口，在 DCDN 中设置静态缓存，并触发接口预热，将接口的响应缓存到 DCDN 的二级节点上。这样用户发起这些请求时，直接由 DCDN 做出应答而不回源到真实服务器处理。 在服务端和客户端开启 http/2 协议支持。 对超过 1kb 的响应体开启 gzip 压缩。 对服务端的图片等静态资源设置浏览器缓存。 利用网站测速提供的服务，发送 GET 测速，让各地运营商缓存 DNS 结果。 开启 OCSP Stapling，提高证书的校验性能。 代码编写 代码中对图片标签开启懒加载。 减小冗余的 层次嵌套。 为 data 赋初始值，避免在网络请求结束后赋值引起页面元素的位置变动。 开启代码的按需注入 将网络请求从 onReady 提前到 onLoad 。业务逻辑 所有新用户（首次访问）最初进入小程序时，页面和 data 中的数据都是一样的。将这些数据作为 data 的默认值，直接显示出来，网络请求到达后，由于 data 内容不变，不会发生页面的重新渲染。 用户使用程序后，将从网络请求中获取的用户数据存储到 storage 中。 在服务端，当小程序用户登入后，开启异步线程将主要的用户数据从 MySQL 刷入Redis 进行热备。 对于长列表改为数据分页加载。 在 css/js 代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次 js 请求一般情况下有哪些地方会有缓存处理？dns 缓存，cdn 缓存，浏览器缓存，服务器缓存。 什么是渐进式渲染（progressive rendering）？渐进式渲染是用于提高网页性能（尤其是提高用户感知的加载速度），以尽快呈现页面的技术。 在以前互联网带宽较小的时期，这种技术更为普遍。如今，移动终端的盛行，而移动网络往往不稳定，渐进式渲染在现代前端开发中仍然有用武之地。 一些举例： 图片懒加载——页面上的图片不会一次性全部加载。当用户滚动页面到图片部分时，JavaScript 将加载并显示图像。 确定显示内容的优先级（分层次渲染）——为了尽快将页面呈现给用户，页面只包含基本的最少量的 CSS、脚本和内容，然后可以使用延迟加载脚本或监听DOMContentLoaded/load事件加载其他资源和内容。 异步加载 HTML 片段——当页面通过后台渲染时，把 HTML 拆分，通过异步请求，分块发送给浏览器。 解析：更多相关细节可以在这里找到。 网络相关：DNS 预解析DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP 1&lt;link rel=\"dns-prefetch\" href=\"//yuchengkai.cn\"&gt; 缓存 缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度 通常浏览器缓存策略分为两种：强缓存和协商缓存 强缓存 实现强缓存可以通过两种响应头实现：Expires和 Cache-Control 。强缓存表示在缓存期间不需要请求，state code为 200 1Expires: Wed, 22 Oct 2018 08:41:00 GMT Expires 是 HTTP / 1.0 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效 1Cache-control: max-age=30 Cache-Control 出现于 HTTP / 1.1，优先级高于 Expires 。该属性表示资源会在 30 秒后过期，需要再次请求 协商缓存 如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304 协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式 Last-Modified 和 If-Modified-Since Last-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来 但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag ETag 和 If-None-Match ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高 选择合适的缓存策略 对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略 对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存 对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。 对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件 使用 HTTP / 2.0 因为浏览器会有并发请求限制，在 HTTP / 1.1 时代，每个请求都需要建立和断开，消耗了好几个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间 在 HTTP / 2.0 中引入了多路复用，能够让多个请求使用同一个 TCP 链接，极大的加快了网页的加载速度。并且还支持 Header 压缩，进一步的减少了请求的数据大小 预加载 在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载 预加载其实是声明式的 fetch ，强制浏览器请求资源，并且不会阻塞 onload 事件，可以使用以下代码开启预加载 1&lt;link rel=\"preload\" href=\"http://example.com\"&gt; 预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好 预渲染 可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染 1&lt;link rel=\"prerender\" href=\"http://example.com\"&gt; 预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染 什么是CDN公共库？CDN公共库是指将常用的JS库存放在CDN节点，以方便广大开发者直接调用。与将JS库存放在服务器单机上相比，CDN公共库更加稳定、高速。一般的CDN公共库都会包含全球所有最流行的开源JavaScript库。 为什么要引用CDN公共库？1.减少等待时间 CDN-Content Delivery Network（内容分发网络），通过各种各样的服务途径把你的一些静态内容分散开来，当用户的浏览器提交这些文件的链接请求，他们便会自动下载网络上最近的可用的文件。这样任何使用你的服务的用户从JS库下载都将获得比从你自己的服务器上下载更快的速度。 2.增加网页的同时载入速度 为了避免服务的过载，浏览器限制了同时连接的数目，依据不同的浏览器，这个限制可能是每个机房仅仅两个之少。使用CDN公共库加载JS，使你本地服务器上更多服务可以同时进行。 3.更好的缓存 使用CDN公共库的最大好处是你的用户可能根本不需要下载jQuery.不论你的缓存多么强大，如果你用自己的服务器提供jQuery，那么你的用户至少要下载一次它，某个用户很有可能在他们浏览器的缓存区里下载了许多完全相同的jQuery.min.js的拷贝版本，但是当他们第一次访问你的网站的时候，这些拷贝版本会被忽略。 而当浏览器检测到同样版本的指向CDN公共库的链接，它就会知道这是下载同一个文件，不仅是CDN公共库的服务器会返回一个304（不需要修改文件的指令，即服务器上的文件未改动过）来回复一个重复的请求，而且会命令浏览器的缓存该文件长达一年的时间。 这意味着即使一些人访问了数百的使用CDN公共库的网站,他们只需要下载一次就够了。 优化渲染过程懒执行懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒 懒加载 懒加载就是将不关键的资源延后加载 懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载 懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://qw8.github.io/tags/性能优化/"},{"name":"渲染优化","slug":"渲染优化","permalink":"https://qw8.github.io/tags/渲染优化/"},{"name":"网络优化","slug":"网络优化","permalink":"https://qw8.github.io/tags/网络优化/"}]},{"title":"flex","slug":"knowledges/flex","date":"2020-08-30T14:30:10.000Z","updated":"2024-05-06T02:12:57.272Z","comments":true,"path":"/knowledges/flex.html","link":"","permalink":"https://qw8.github.io/knowledges/flex.html","excerpt":"","text":"flex: 1 flex: auto flex: none flex: 0到底有什么区别 ？使用场景？我们在日常使用flex布局的时候，经常会用到 flex 缩写。flex简写设置了项目如何增大或缩小以适应在容器中可用的空间。 flex简写属性在下面有三个值的定义 默认值为 0 1 auto; flex-grow :定义项目的放大比例，默认为0 flex-shrink :定义项目的缩小比例,默认为 1 flex-basis :定义项目在分配多余的空间之前，项目占据的主轴空间 默认为auto（item本来大小） 在了解了flex的基本值之后，我们会用一些用例来实验一下(没有特殊声明的话，用例代码都是以下的结构) 123456html复制代码 &lt;div class=\"wrapper \"&gt; &lt;item class=\"inner\"&gt;一一一一一一一一一一一一一一一一&lt;/item&gt; &lt;item class=\"inner\"&gt;二二&lt;/item&gt; &lt;item class=\"inner\"&gt;三三&lt;/item&gt; &lt;item class=\"inner\"&gt;四四四四四四四四四四四四四四四四&lt;/item&gt; &lt;/div&gt; flex:11flex:1` = `flex: 1 1 0%; flex:1在父元素尺寸不足的时候，会优先最小化内容尺寸。 下面我们给用例设置样式看下这句话是什么意思 1234567891011CSS复制代码.wrapper&#123; margin: 0 auto; width: 560px; height: 40px; border: black 1px solid; display: flex; &#125; .wrapper &gt; .inner&#123; border: chartreuse 1px solid; flex:1; &#125; image.png 从例子我们可以看出 flex:1 ，在充分分配容器尺寸的前提下，会优先牺牲自己,填充父容器的尺寸 使用场景当我们希望元素可以充分的利用剩余的空间，同时不会很多的占用其他同级元素的空间的时候使用。 等分布局 等比例列表 flex:auto1flex:auto` = `flex: 1 1 auto; flex:auto在父元素尺寸不足的时候，会优先最大化内容尺寸。 1234567891011CSS复制代码.wrapper&#123; margin: 0 auto; width: 560px; height: 40px; border: black 1px solid; display: flex; &#125; .wrapper &gt; .inner&#123; border: chartreuse 1px solid; flex:auto; &#125; image.png 从例子我们可以看出 flex:auto ，在充分分配容器尺寸的前提下，会优先扩展自己,填充父容器的尺寸 使用场景当我们希望元素充分的使用剩余的空间，各自元素按照各自内容进行分配的时候使用 内容动态适配布局 自适应布局 子元素个数不确定时 flex:01flex:0` = `flex: 0 1 0%; flex:0 :通常表现为内容最小化宽度 123456789101112css复制代码 .wrapper&#123; margin: 0 auto; width: 560px; height: 40px; border: black 1px solid; display: flex; &#125; .wrapper &gt; .inner&#123; border: chartreuse 1px solid; flex:0; &#125; image.png 从以上的例子可以看出:flex:0的时候元素的内容宽度最小化，并没有充分的分配容器的尺寸。 使用场景当希望元素item占用最小化的内容宽度的时候 flex:none1flex:none` = `flex:0 0 auto; flex:none;表示元素的大小由内容决定，但是flex-grow，flex-shrink都是0，元素没有弹性，通常表现为内容最大化宽度 123456789101112css复制代码 .wrapper&#123; margin: 0 auto; width: 560px; height: 40px; border: black 1px solid; display: flex; &#125; .wrapper &gt; .inner&#123; border: chartreuse 1px solid; flex:none; &#125; image.png 从以上的例子可以看出:flex:none的时候元素的内容直接溢出容器，没有换行，表现为最大内容宽度 使用场景：元素的宽度就是内容的宽度，并且内容永远不会换行 按钮里面文字不换行处理 总结 flex:1 &amp; flex:auto 的区别主要体现在 =&gt;在充分分配父元素宽度的情况下，子元素是优先扩展（auto）自己的尺寸还是优先减小（1）自己的尺寸 flex:0 &amp; flex: none 的区别主要体现在 =&gt;不考略父元素宽度的情况下，最大化内容宽度（none）还是最小化内容宽度（0） 对于不同的使用场景，我们应该使用不同的flex。比如flex：1多用于等分布局中，flex：auto多用于内容动态适配中，flex：none多用于元素内容最大化处理 参考： 阮一峰flex布局语法篇 张鑫旭博客 原文链接：https://juejin.cn/post/6967177565458923557","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://qw8.github.io/tags/CSS/"},{"name":"选择器","slug":"选择器","permalink":"https://qw8.github.io/tags/选择器/"},{"name":"flex","slug":"flex","permalink":"https://qw8.github.io/tags/flex/"}]},{"title":"CSS","slug":"knowledges/CSS","date":"2020-08-29T14:30:10.000Z","updated":"2024-05-13T03:09:35.704Z","comments":true,"path":"/knowledges/css.html","link":"","permalink":"https://qw8.github.io/knowledges/css.html","excerpt":"","text":"前端水平垂直居中的十种方法第1种： 弹性盒子的方式 通过给父元素设置justify-content: center; align-items: center;就可以了 优点： 移动端使用灵活自如 缺点： pc端需要根据兼容情况来判定 第2种： line-height 只对文本有效果，对定宽高的div是没有用的。所以在文本水平垂直居中时使用。 优点：代码简洁 缺点：只对文本有效，只对单行文本有效，多行文本不可以 第3种： 通过绝对定位的方式 absolute + 负margin 首先知道子元素的宽高，给子元素设置top：50%；left：50%， 但绝对定位是基于子元素的左上角，我们所希望的效果是子元素的中心居中显示。。。。借助外边距的负值，负的外边距可以让元素向相反方向定位， 通过指定子元素的外边距为子元素宽度一半的负值，就可以让子元素居中了 优点： 比较好理解，兼容性好 缺点： 需要知道子元素的宽高 第4种： 也是通过绝对定位的方式 absolute + margin auto 这个是需要将各个方向的距离都设0，再讲margin设为auto；就行 优点： 兼容性也很好 缺点： 需要知道子元素的宽高 第5种： absolute + calc（计算） 这种方法top的百分比是基于元素的左上角，那么在减去宽度与高度的一半就好了 calc :任何长度值都可以使用calc()函数进行计算； calc()函数使用标准的数学运算优先级规则； 它支持 “+”, “-”,“*”, “/” 运算 也可以查看calc教程：https://www.runoob.com/cssref/func-calc.html 优点： 他的兼容性依赖的是calc的兼容性 缺点： 同样是需要知道子元素的宽高 第6种： absolute + transform （过渡） 这个方法不需要子元素固定宽高 修复绝对定位的问题，还可以使用css3新增的transform，transform的translate 属性也可以设置百分比，其是相对于自身的宽和高，所以可以将translate设置为-50%，就可以做到居中了 优点： 代码量少 缺点： IE8不支持, 属性需要追加浏览器厂商前缀, 可能干扰其他 transform 效果, 某些情形下会出现文本或元素边界渲染模糊的现象。 第7种： writing-mode 可以参考：https://www.runoob.com/cssref/css-pr-writing-mode.html 这种方法稍微有些复杂，writing-mode可以改变文字的显示方向。 第8种： table-cell实现水平垂直居中: table-cell middle center组合使用直接给父级设 123display: table-cell;vertical-align: middle;text-align: center; 为了可以明显看出，我们可以给它设个宽高与边框 123width: 240px;height: 180px;border:1px solid #666; 第9种： table 形式 通过table单元格的形式设 优点： tabel单元格中的内容天然就是垂直居中的，只要添加一个水平居中属性就好了 缺点： 这个不是table的正确方法，不是很建议使用，但是也是可以实现的 第10种： grid（网格布局） 给父级设display:grid; 给子元素设align-self: center;justify-self: center; 优点： 代码量少 缺点： 兼容不如flex，建议用flex 介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？盒模型：分为内容（content）、填充（padding）、边界（margin）、边框（border）四个部分 有两种盒子模型：IE盒模型（border-box）、W3C标准盒模型（content-box） IE盒模型和W3C标准盒模型的区别： （1）W3C标准盒模型：属性width，height只包含内容content，不包含border和padding（2）IE盒模型：属性width，height包含content、border和padding，指的是content+padding+border 一般来说，我们可以通过修改元素的box-sizing属性来改变元素的盒模型。 在ie8+浏览器中使用哪个盒模型可以由box-sizing（CSS新增的属性）控制，默认值为content-box，即标准盒模型；如果将box-sizing设为border-box则用的是IE盒模型。如果在ie6，7，8中DOCTYPE缺失会将盒子模型解释为IE盒子模型。若在页面中声明了DOCTYPE类型，所有的浏览器都会把盒模型解释为W3C盒模型。 介绍一下box-sizing属性？box-sizing属性主要用来控制元素的盒模型的解析模式。默认值是content-box。 content-box：让元素维持W3C的标准盒模型。元素的宽度/高度由border + padding + content的宽度/高度决定，设置width/height属性指的是content部分的宽/高 border-box：让元素维持IE传统盒模型（IE6以下版本和IE6~7的怪异模式）。设置width/height属性指的是border + padding + content 标准浏览器下，按照W3C规范对盒模型解析，一旦修改了元素的边框或内距，就会影响元素的盒子尺寸，就不得不重新计算元素的盒子尺寸，从而影响整个页面的布局。 CSS 选择符有哪些？1234567891011（1）id选择器（#myid）（2）类选择器（.myclassname）（3）标签选择器（div,h1,p）（4）后代选择器（h1 p）（5）相邻后代选择器（子）选择器（ul&gt;li）（6）兄弟选择器（li~a）（7）相邻兄弟选择器（li+a）（8）属性选择器（a[rel=&quot;external&quot;]）（9）伪类选择器（a:hover,li:nth-child）（10）伪元素选择器（::before、::after）（11）通配符选择器（*） 介绍使用过的 CSS 预处理器？最常用的 CSS 预处理器语言包括：Sass（SCSS）和 LESS CSS 预处理器基本思想：为 CSS 增加了一些编程的特性（变量、逻辑判断、函数等） 开发者使用这种语言进行进行 Web 页面样式设计，再编译成正常的 CSS 文件使用 使用 CSS 预处理器，增强了css代码的复用性，可以使 CSS 更加简洁、适应性更强、可读性更佳，无需考虑兼容性，极大的提高工作效率 什么是 CSS 预处理器/后处理器？12345678CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。通俗的说，CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件。预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less csssprite，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。CSS后处理器是对CSS进行处理，并最终生成CSS的预处理器，它属于广义上的CSS预处理器。我们很久以前就在用CSS后处理器了，最典型的例子是CSS压缩工具（如clean-css），只不过以前没单独拿出来说过。还有最近比较火的Autoprefixer，以CanIUse上的浏览器支持数据为基础，自动处理兼容性问题。后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。 详细资料可以参考：《CSS 预处理器和后处理器》 CSS优化、提高性能的方法有哪些？ 多个css合并，尽量减少HTTP请求 将css文件放在页面最上面 移除空的css规则 避免使用CSS表达式 选择器优化嵌套，尽量避免层级过深 充分利用css继承属性，减少代码量 属性值为0时，不加单位 属性值为小于1的小数时，省略小数点前面的0 css雪碧图 提取项目的通用公有样式，增强可复用性，按模块编写组件；增强项目的协同开发性、可维护性和可扩展性; 使用预处理工具或构建工具（gulp对css进行语法检查、自动补前缀、打包压缩、自动优雅降级） CSS 优化、提高性能的方法有哪些？加载性能：（1）css压缩：将写好的css进行打包压缩，可以减少很多的体积。（2）css单一样式：当需要下边距和左边距的时候，很多时候选择:margin:top 0 bottom 0;但margin-bottom:bottom;margin-left:left;执行的效率更高。（3）减少使用@import，而建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。 选择器性能：（1）关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等； （2）如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。 （3）避免使用通配规则，如*{}计算次数惊人！只对需要用到的元素进行选择。 （4）尽量少的去对标签进行选择，而是用class。 （5）尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。 （6）了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。 渲染性能：（1）慎重使用高性能属性：浮动、定位。 （2）尽量减少页面重排、重绘。 （3）去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。 （4）属性值为0时，不加单位。 （5）属性值为浮动小数0.**，可以省略小数点之前的0。 （6）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。 （7）不使用@import前缀，它会影响css的加载速度。 （8）选择器优化嵌套，尽量避免层级过深。 （9）css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。 （10）正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。 （11）不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏览器在下载web fonts时会阻塞页面渲染损伤性能。 可维护性、健壮性：（1）将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。（2）样式与内容分离：将css代码定义到外部css中。 详细资料可以参考：《CSS 优化、提高性能的方法有哪些？》《CSS 优化，提高性能的方法》 ### ::before 和:after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用。相关知识点： 12345678单冒号（:）用于CSS3伪类，双冒号（::）用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，比如:first-line、:first-letter、:before、:after等，而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。想让插入的内容出现在其它内容前，使用::before，否者，使用::after；在代码顺序上，::after生成的内容也比::before生成的内容靠后。如果按堆栈视角，::after生成的内容会在::before生成的内容之上。 回答： 1234在css3中使用单冒号来表示伪类，用双冒号来表示伪元素。但是为了兼容已有的伪元素的写法，在一些浏览器中也可以使用单冒号来表示伪元素。伪类一般匹配的是元素的一些特殊状态，如hover、link等，而伪元素一般匹配的特殊的位置，比如after、before等。 伪类与伪元素的区别123456789101112css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句话中的第一个字母，或者是列表中的第一个元素。伪类用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态。伪元素用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。比如说，我们可以通过::before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。有时你会发现伪元素使用了两个冒号（::）而不是一个冒号（:）。这是CSS3的一部分，并尝试区分伪类和伪元素。大多数浏览器都支持这两个值。按照规则应该使用（::）而不是（:），从而区分伪类和伪元素。但是，由于在旧版本的W3C规范并未对此进行特别区分，因此目前绝大多数的浏览器都支持使用这两种方式表示伪元素。 详细资料可以参考：《总结伪类与伪元素》 CSS 中哪些属性可以继承？相关资料： 1234567891011121314151617181920212223242526272829303132333435每个CSS属性定义的概述都指出了这个属性是默认继承的，还是默认不继承的。这决定了当你没有为元素的属性指定值时该如何计算值。当元素的一个继承属性没有指定值时，则取父元素的同属性的计算值。只有文档根元素取该属性的概述中给定的初始值（这里的意思应该是在该属性本身的定义中的默认值）。当元素的一个非继承属性（在Mozilla code里有时称之为reset property）没有指定值时，则取属性的初始值initial value（该值在该属性的概述里被指定）。有继承性的属性：（1）字体系列属性font、font-family、font-weight、font-size、font-style、font-variant、font-stretch、font-size-adjust（2）文本系列属性text-indent、text-align、text-shadow、line-height、word-spacing、letter-spacing、text-transform、direction、color（3）表格布局属性caption-side border-collapse empty-cells（4）列表属性list-style-type、list-style-image、list-style-position、list-style（5）光标属性cursor（6）元素可见性visibility（7）还有一些不常用的；speak，page，设置嵌套引用的引号类型quotes等属性注意：当一个属性不是继承属性时，可以使用inherit关键字指定一个属性应从父元素继承它的值，inherit关键字用于显式地指定继承性，可用于任何继承性/非继承性属性。 回答： 1234567每一个属性在定义中都给出了这个属性是否具有继承性，一个具有继承性的属性会在没有指定值的时候，会使用父元素的同属性的值来作为自己的值。一般具有继承性的属性有，字体相关的属性，font-size和font-weight等。文本相关的属性，color和text-align等。表格的一些布局属性、列表属性如list-style等。还有光标属性cursor、元素可见性visibility。当一个属性不是继承属性的时候，我们也可以通过将它的值设置为inherit来使它从父元素那获取同名的属性值来继承。 详细的资料可以参考：《继承属性》《CSS 有哪些属性可以继承？》 CSS 优先级算法如何计算？相关知识点： 123456789101112131415161718192021222324252627282930313233343536CSS的优先级是根据样式声明的特殊性值来判断的。选择器的特殊性值分为四个等级，如下：（1）标签内选择符x,0,0,0（2）ID选择符0,x,0,0（3）class选择符/属性选择符/伪类选择符 0,0,x,0（4）元素和伪元素选择符0,0,0,x计算方法：（1）每个等级的初始值为0（2）每个等级的叠加为选择器出现的次数相加（3）不可进位，比如0,99,99,99（4）依次表示为：0,0,0,0（5）每个等级计数之间没关联（6）等级判断从左向右，如果某一位数值相同，则判断下一位数值（7）如果两个优先级相同，则最后出现的优先级高，!important也适用（8）通配符选择器的特殊性值为：0,0,0,0（9）继承样式优先级最低，通配符样式优先级高于继承样式（10）!important（权重），它没有特殊性值，但它的优先级是最高的，为了方便记忆，可以认为它的特殊性值为1,0,0,0,0。计算实例：（1）#demo a&#123;color: orange;&#125;/*特殊性值：0,1,0,1*/（2）div#demo a&#123;color: red;&#125;/*特殊性值：0,1,0,2*/注意：（1）样式应用时，css会先查看规则的权重（!important），加了权重的优先级最高，当权重相同的时候，会比较规则的特殊性。（2）特殊性值越大的声明优先级越高。（3）相同特殊性值的声明，根据样式引入的顺序，后声明的规则优先级高（距离元素出现最近的） (4) 部分浏览器由于字节溢出问题出现的进位表现不做考虑 回答： 123456789判断优先级时，首先我们会判断一条属性声明是否有权重，也就是是否在声明后面加上了!important。一条声明如果加上了权重，那么它的优先级就是最高的，前提是它之后不再出现相同权重的声明。如果权重相同，我们则需要去比较匹配规则的特殊性。一条匹配规则一般由多个选择器组成，一条规则的特殊性由组成它的选择器的特殊性累加而成。选择器的特殊性可以分为四个等级，第一个等级是行内样式，为1000，第二个等级是id选择器，为0100，第三个等级是类选择器、伪类选择器和属性选择器，为0010，第四个等级是元素选择器和伪元素选择器，为0001。规则中每出现一个选择器，就将它的特殊性进行叠加，这个叠加只限于对应的等级的叠加，不会产生进位。选择器特殊性值的比较是从左向右排序的，也就是说以1开头的特殊性值比所有以0开头的特殊性值要大。比如说特殊性值为1000的的规则优先级就要比特殊性值为0999的规则高。如果两个规则的特殊性值相等的时候，那么就会根据它们引入的顺序，后出现的规则的优先级最高。 对于组合声明的特殊性值计算可以参考：《CSS 优先级计算及应用》《CSS 优先级计算规则》《有趣：256 个 class 选择器可以干掉 1 个 id 选择器》 关于伪类 LVHA 的解释?12345678910111213a标签有四种状态：链接访问前、链接访问后、鼠标滑过、激活，分别对应四种伪类:link、:visited、:hover、:active；当链接未访问过时：（1）当鼠标滑过a链接时，满足:link和:hover两种状态，要改变a标签的颜色，就必须将:hover伪类在:link伪类后面声明；（2）当鼠标点击激活a链接时，同时满足:link、:hover、:active三种状态，要显示a标签激活时的样式（:active），必须将:active声明放到:link和:hover之后。因此得出LVHA这个顺序。当链接访问过时，情况基本同上，只不过需要将:link换成:visited。这个顺序能不能变？可以，但也只有:link和:visited可以交换位置，因为一个链接要么访问过要么没访问过，不可能同时满足，也就不存在覆盖的问题。 display 有哪些值？说明他们的作用。1234567block 块类型。默认宽度为父元素宽度，可设置宽高，换行显示。none 元素不显示，并从文档流中移除。inline 行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。list-item 像块类型元素一样显示，并添加样式列表标记。table 此元素会作为块级表格来显示。inherit 规定应该从父元素继承display属性的值。 详细资料可以参考：《CSS display 属性》 position 的值 relative 和 absolute 定位原点是？相关知识点： 123456789101112131415absolute生成绝对定位的元素，相对于值不为static的第一个父元素的padding box进行定位，也可以理解为离自己这一级元素最近的一级position设置为absolute或者relative的父元素的padding box的左上角为原点的。fixed（老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。relative生成相对定位的元素，相对于其元素本身所在正常位置进行定位。static默认值。没有定位，元素出现在正常的流中（忽略top,bottom,left,right,z-index声明）。inherit规定从父元素继承position属性的值。 回答： 12345relative定位的元素，是相对于元素本身的正常位置来进行定位的。absolute定位的元素，是相对于它的第一个position值不为static的祖先元素的padding box来进行定位的。这句话我们可以这样来理解，我们首先需要找到绝对定位元素的一个position的值不为static的祖先元素，然后相对于这个祖先元素的padding box来定位，也就是说在计算定位距离的时候，padding的值也要算进去。 position几个属性的作用？position的常见四个属性值： relative，absolute，fixed，static。 一般都要配合”left”、”top”、”right”以及 “bottom” 属性使用： 1.Static： 默认位置，设置为 static 的元素，它始终会处于页面流给予的位置（static 元素会忽略任何 top、bottom、left 或 right 声明）。一般不常用。 2.Relative： 位置被设置为 relative 的元素，可将其移至相对于其正常位置的地方，意思就是如果设置了 relative 值，那么，它偏移的 top，right，bottom，left 的值都以它原来的位置为基准偏移，而不管其他元素会怎么样。注意 relative 移动后的元素在原来的位置仍占据空间。 3.Absolute： 位置设置为 absolute 的元素，可定位于相对于包含它的元素的指定坐标。意思就是如果它的父容器设置了 position 属性，并且 position 的属性值为 absolute 或者 relative，那么就会依据父容器进行偏移。如果其父容器没有设置 position 属性，那么偏移是以 body 为依据。注意设置 absolute 属性的元素在标准流中不占位置。 4.Fixed： 位置被设置为 fixed 的元素，可定位于相对于浏览器窗口的指定坐标。不论窗口滚动与否，元素都会留在那个位置。它始终是以 body 为依据的。 注意设置 fixed 属性的元素在标准流中不占位置。 px，em，rem的区别？ 1.px 像素（Pixel）。绝对单位。 像素 px 是相对于显示器屏幕分辨率而言的，是一个虚拟长度单位，是计算机系统的数字化图像长度单位，如果 px 要换算成物理长度，需要指定精度 DPI。 2.em 是相对长度单位，相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。它会继承父级元素的字体大小，因此并不是一个固定的值。 3.rem是CSS3新增的一个相对单位（rootem，根 em），使用 rem 为元素设定字体大小时，仍然是相对大小，但相对于HTML 根元素。 4.区别：IE 无法调整那些使用 px 作为单位的字体大小，而 em 和 rem 可以缩放，rem 相对的只是 HTML 根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。目前，除了 IE8 及更早版本外，所有浏览器均已支持 rem。 页面导入样式时，使用link和@import有什么区别？ link属于XHTML标签，除了加载CSS外，还能用于定义RSS,定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载 import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题 CSS3 有哪些新特性？（根据项目回答）12345678910新增各种CSS选择器 （:not(.input)：所有class不是“input”的节点）圆角 （border-radius:8px）多列布局 （multi-column layout）阴影和反射 （Shadow\\Reflect）文字特效 （text-shadow）文字渲染 （Text-decoration）线性渐变 （gradient）旋转 （transform）缩放，定位，倾斜，动画，多背景例如：transform:\\scale(0.85,0.90)\\translate(0px,-30px)\\skew(-9deg,0deg)\\Animation: 请解释一下 CSS3 的 Flex box（弹性盒布局模型），以及适用场景？相关知识点： 1234567891011121314151617181920212223242526272829303132333435363738394041Flex是FlexibleBox的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。行内元素也可以使用Flex布局。注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。采用Flex布局的元素，称为Flex容器（flex container），简称&quot;容器&quot;。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称&quot;项目&quot;。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），项目默认沿主轴排列。以下6个属性设置在容器上。flex-direction属性决定主轴的方向（即项目的排列方向）。flex-wrap属性定义，如果一条轴线排不下，如何换行。flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。justify-content属性定义了项目在主轴上的对齐方式。align-items属性定义项目在交叉轴上如何对齐。align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。以下6个属性设置在项目上。order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 回答： 123456789flex布局是CSS3新增的一种布局方式，我们可以通过将一个元素的display属性值设置为flex从而使它成为一个flex容器，它的所有子元素都会成为它的项目。一个容器默认有两条轴，一个是水平的主轴，一个是与主轴垂直的交叉轴。我们可以使用flex-direction来指定主轴的方向。我们可以使用justify-content来指定元素在主轴上的排列方式，使用align-items来指定元素在交叉轴上的排列方式。还可以使用flex-wrap来规定当一行排列不下时的换行方式。对于容器中的项目，我们可以使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，项目的放大比例。还可以使用flex-shrink来指定当排列空间不足时，项目的缩小比例。 详细资料可以参考：《Flex 布局教程：语法篇》《Flex 布局教程：实例篇》 一个满屏品字布局如何设计?1234简单的方式： 上面的div宽100%， 下面的两个div分别宽50%， 然后用float或者inline使其不换行即可 CSS 多列等高如何实现？12345678（1）利用padding-bottom|margin-bottom正负值相抵，不会影响页面布局的特点。设置父容器设置超出隐藏（overflow:hidden），这样父容器的高度就还是它里面的列没有设定padding-bottom时的高度，当它里面的任一列高度增加了，则父容器的高度被撑到里面最高那列的高度，其他比这列矮的列会用它们的padding-bottom补偿这部分高度差。（2）利用table-cell所有单元格高度都相等的特性，来实现多列等高。（3）利用flex布局中项目align-items属性默认为stretch，如果项目未设置高度或设为auto，将占满整个容器的高度的特性，来实现多列等高。 详细资料可以参考：《前端应该掌握的 CSS 实现多列等高布局》《CSS：多列等高布局》 经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用 hack 的技巧？12345678910111213141516171819202122232425262728293031323334353637383940414243444546（1）png24位的图片在iE6浏览器上出现背景解决方案：做成PNG8，也可以引用一段脚本处理。（2）浏览器默认的margin和padding不同解决方案：加一个全局的*&#123;margin:0;padding:0;&#125;来统一。（3）IE6双边距bug：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。#box&#123;float:left;width:10px;margin:0 0 0 10px;&#125;这种情况之下IE会产生20px的距离解决方案：在float的标签样式控制中加入_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)（4）渐进识别的方式，从总体中逐渐排除局部。首先，巧妙的使用&quot;\\9&quot;这一标记，将IE游览器从所有情况中分离出来。接着，再次使用&quot;+&quot;将IE8和IE7、IE6分离开来，这样IE8已经独立识别。.bb&#123;background-color:#f1ee18;/*所有识别*/.background-color:#00deff\\9;/*IE6、7、8识别*/+background-color:#a200ff;/*IE6、7识别*/_background-color:#1e0bd1;/*IE6识别*/&#125;（5）IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用getAttribute()获取自定义属性；Firefox下，只能使用getAttribute()获取自定义属性解决方法：统一通过getAttribute()获取自定义属性。（6）IE下，event对象有x、y属性，但是没有pageX、pageY属性;Firefox下，event对象有pageX、pageY属性，但是没有x、y属性。解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。（7）Chrome中文界面下默认会将小于12px的文本强制按照12px显示解决方法：1.可通过加入CSS属性-webkit-text-size-adjust:none;解决。但是，在chrome更新到27版本之后就不可以用了。2.还可以使用-webkit-transform:scale(0.5);注意-webkit-transform:scale(0.75);收缩的是整个span的大小，这时候，必须要将span转换成块元素，可以使用display：block/inline-block/...；（8）超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有hover和active了解决方法：改变CSS属性的排列顺序L-V-H-A（9）怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。 双边距重叠问题(外边距折叠)多个相邻（兄弟或者父子关系）普通流的块元素垂直方向margin会重叠 两个相邻的外边距都是正数时、折叠结果是它们两者之间的较大值 都是负数时、折叠结果是两者绝对值的较大值 一正一负时、折叠结果是两者的相加值 解决嵌套块元素塌陷问题： 可以给父元素定义边框 可以为父元素定义内边距 可以为父元素添加overflow:hidden; 将块级div设置成行内div（display：inline-block；） li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？1234567891011121314浏览器会把inline元素间的空白字符（空格、换行、Tab等）渲染成一个空格。而为了美观。我们通常是一个&lt;li&gt;放在一行，这导致&lt;li&gt;换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。解决办法：（1）为&lt;li&gt;设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。（2）将所有&lt;li&gt;写在同一行。不足：代码不美观。（3）将&lt;ul&gt;内的字符尺寸直接设为0，即font-size:0。不足：&lt;ul&gt;中的其他字符尺寸也被设为0，需要额外重新设定其他字符尺寸，且在Safari浏览器依然会出现空白间隔。（4）消除&lt;ul&gt;的字符间隔letter-spacing:-8px，不足：这也设置了&lt;li&gt;内的字符间隔，因此需要将&lt;li&gt;内的字符间隔设为默认letter-spacing:normal。 详细资料可以参考：《li 与 li 之间有看不见的空白间隔是什么原因引起的？》 什么是包含块，对于包含块的理解?123456789101112131415161718包含块（containing block）就是元素用来计算和定位的一个框。（1）根元素（很多场景下可以看成是&lt;html&gt;）被称为“初始包含块”，其尺寸等同于浏览器可视窗口的大小。（2）对于其他元素，如果该元素的position是relative或者static，则“包含块”由其最近的块容器祖先盒的content box边界形成。（3）如果元素position:fixed，则“包含块”是“初始包含块”。（4）如果元素position:absolute，则“包含块”由最近的position不为static的祖先元素建立，具体方式如下：如果该祖先元素是纯inline元素，则规则略复杂：•假设给内联元素的前后各生成一个宽度为0的内联盒子（inline box），则这两个内联盒子的padding box外面的包围盒就是内联元素的“包含块”；•如果该内联元素被跨行分割了，那么“包含块”是未定义的，也就是CSS2.1规范并没有明确定义，浏览器自行发挥否则，“包含块”由该祖先的padding box边界形成。如果没有符合条件的祖先元素，则“包含块”是“初始包含块”。 CSS 里的 visibility 属性有个 collapse 属性值是干嘛用的？在不同浏览器下以后什么区别？1234567891011（1）对于一般的元素，它的表现跟visibility：hidden;是一样的。元素是不可见的，但此时仍占用页面空间。（2）但例外的是，如果这个元素是table相关的元素，例如table行，table group，table列，table column group，它的表现却跟display:none一样，也就是说，它们占用的空间也会释放。在不同浏览器下的区别：在谷歌浏览器里，使用collapse值和使用hidden值没有什么区别。在火狐浏览器、Opera和IE11里，使用collapse值的效果就如它的字面意思：table的行会消失，它的下面一行会补充它的位置。 详细资料可以参考：《CSS 里的 visibility 属性有个鲜为人知的属性值：collapse》 width:auto 和 width:100%的区别12345一般而言width:100%会使元素box的宽度等于父元素的content box的宽度。width:auto会使元素撑满整个父元素，margin、border、padding、content区域会自动分配水平空间。 绝对定位元素与非绝对定位元素的百分比计算的区别123绝对定位元素的宽高百分比是相对于临近的position不为static的祖先元素的padding box来计算的。非绝对定位元素的宽高百分比则是相对于父元素的content box来计算的。 简单介绍使用图片 base64 编码的优点和缺点。123456789101112131415161718base64编码是一种图片处理格式，通过特定的算法将图片编码成一长串字符串，在页面上显示的时候，可以用该字符串来代替图片的url属性。使用base64的优点是：（1）减少一个图片的HTTP请求使用base64的缺点是：（1）根据base64的编码原理，编码后的大小会比原文件大小大1/3，如果把大图片编码到html/css中，不仅会造成文件体积的增加，影响文件的加载速度，还会增加浏览器对html或css文件解析渲染的时间。（2）使用base64无法直接缓存，要缓存只能缓存包含base64的文件，比如HTML或者CSS，这相比域直接缓存图片的效果要差很多。（3）兼容性的问题，ie8以前的浏览器不支持。一般一些网站的小图标可以使用base64图片来引入。 详细资料可以参考：《玩转图片 base64 编码》《前端开发中，使用 base64 图片的弊端是什么？》《小 tip:base64:URL 背景图片与 web 页面性能优化》 ‘display’、’position’和’float’的相互关系？123456789101112131415（1）首先我们判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。（2）然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被设置为table或者block，具体转换需要看初始转换值。（3）如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对于浮动后的最终位置定位。（4）如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，则保持指定的display属性值不变。总的来说，可以把它看作是一个类似优先级的机制，&quot;position:absolute&quot;和&quot;position:fixed&quot;优先级最高，有它存在的时候，浮动不起作用，&apos;display&apos;的值也需要调整；其次，元素的&apos;float&apos;特性的值不是&quot;none&quot;的时候或者它是根元素的时候，调整&apos;display&apos;的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，&apos;display&apos;特性值同设置值。 详细资料可以参考：《position 跟 display、margincollapse、overflow、float 这些特性相互叠加后会怎么样？》 margin 重叠问题的理解。相关知识点： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748块级元素的上外边距（margin-top）与下外边距（margin-bottom）有时会合并为单个外边距，这样的现象称为“margin合并”。产生折叠的必备条件：margin必须是邻接的!而根据w3c规范，两个margin是邻接的必须满足以下条件：•必须是处于常规文档流（非float和绝对定位）的块级盒子，并且处于同一个BFC当中。•没有线盒，没有空隙，没有padding和border将他们分隔开•都属于垂直方向上相邻的外边距，可以是下面任意一种情况•元素的margin-top与其第一个常规文档流的子元素的margin-top•元素的margin-bottom与其下一个常规文档流的兄弟元素的margin-top•height为auto的元素的margin-bottom与其最后一个常规文档流的子元素的margin-bottom•高度为0并且最小高度也为0，不包含常规文档流的子元素，并且自身没有建立新的BFC的元素的margin-top和margin-bottommargin合并的3种场景：（1）相邻兄弟元素margin合并。解决办法：•设置块状格式化上下文元素（BFC）（2）父级和第一个/最后一个子元素的margin合并。解决办法：对于margin-top合并，可以进行如下操作（满足一个条件即可）：•父元素设置为块状格式化上下文元素；•父元素设置border-top值；•父元素设置padding-top值；•父元素和第一个子元素之间添加内联元素进行分隔。对于margin-bottom合并，可以进行如下操作（满足一个条件即可）：•父元素设置为块状格式化上下文元素；•父元素设置border-bottom值；•父元素设置padding-bottom值；•父元素和最后一个子元素之间添加内联元素进行分隔；•父元素设置height、min-height或max-height。（3）空块级元素的margin合并。解决办法：•设置垂直方向的border；•设置垂直方向的padding；•里面添加内联元素（直接Space键空格是没用的）；•设置height或者min-height。 回答： 1234567891011121314151617margin重叠指的是在垂直方向上，两个相邻元素的margin发生重叠的情况。一般来说可以分为四种情形：第一种是相邻兄弟元素的marin-bottom和margin-top的值发生重叠。这种情况下我们可以通过设置其中一个元素为BFC来解决。第二种是父元素的margin-top和子元素的margin-top发生重叠。它们发生重叠是因为它们是相邻的，所以我们可以通过这一点来解决这个问题。我们可以为父元素设置border-top、padding-top值来分隔它们，当然我们也可以将父元素设置为BFC来解决。第三种是高度为auto的父元素的margin-bottom和子元素的margin-bottom发生重叠。它们发生重叠一个是因为它们相邻，一个是因为父元素的高度不固定。因此我们可以为父元素设置border-bottom、padding-bottom来分隔它们，也可以为父元素设置一个高度，max-height和min-height也能解决这个问题。当然将父元素设置为BFC是最简单的方法。第四种情况，是没有内容的元素，自身的margin-top和margin-bottom发生的重叠。我们可以通过为其设置border、padding或者高度来解决这个问题。 对 BFC 规范（块级格式化上下文：block formatting context）的理解？相关知识点： 123456789101112131415块格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。通俗来讲•BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。•如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。创建BFC（1）根元素或包含根元素的元素（2）浮动元素float＝left|right或inherit（≠none）（3）绝对定位元素position＝absolute或fixed（4）display＝inline-block|flex|inline-flex|table-cell或table-caption（5）overflow＝hidden|auto或scroll(≠visible) 回答： 12345BFC指的是块级格式化上下文，一个元素形成了BFC之后，那么它内部元素产生的布局不会影响到外部元素，外部元素的布局也不会影响到BFC中的内部元素。一个BFC就像是一个隔离区域，和其他区域互不影响。一般来说根元素是一个BFC区域，浮动和绝对定位的元素也会形成BFC，display属性的值为inline-block、flex这些属性时也会创建BFC。还有就是元素的overflow的值不为visible时都会创建BFC。 详细资料可以参考：《深入理解 BFC 和 MarginCollapse》《前端面试题-BFC（块格式化上下文）》 IFC 是什么？12345IFC指的是行级格式化上下文，它有这样的一些布局规则：（1）行级上下文内部的盒子会在水平方向，一个接一个地放置。（2）当一行不够的时候会自动切换到下一行。（3）行级上下文的高度由内部最高的内联盒子的高度决定。 详细资料可以参考：《[译]:BFC 与 IFC》《BFC 和 IFC 的理解（布局）》 请解释一下为什么需要清除浮动？清除浮动的方式1234567891011121314浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现“高度塌陷”。清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。清除浮动的方式（1）使用clear属性清除浮动。参考28。（2）使用BFC块级格式化上下文来清除浮动。参考26。因为BFC元素不会影响外部元素的特点，所以BFC元素也可以用来清除浮动的影响，因为如果不清除，子元素浮动则父元素高度塌陷，必然会影响后面元素布局和定位，这显然有违BFC元素的子元素不会影响外部元素的设定。 使用 clear 属性清除浮动的原理？1234567891011121314151617181920212223242526使用clear属性清除浮动，其语法如下：clear:none|left|right|both如果单看字面意思，clear:left应该是“清除左浮动”，clear:right应该是“清除右浮动”的意思，实际上，这种解释是有问题的，因为浮动一直还在，并没有清除。官方对clear属性的解释是：“元素盒子的边不能和前面的浮动元素相邻。”，我们对元素设置clear属性是为了避免浮动元素对该元素的影响，而不是清除掉浮动。还需要注意的一点是clear属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“前面的”3个字，也就是clear属性对“后面的”浮动元素是不闻不问的。考虑到float属性要么是left，要么是right，不可能同时存在，同时由于clear属性对“后面的”浮动元素不闻不问，因此，当clear:left有效的时候，clear:right必定无效，也就是此时clear:left等同于设置clear:both；同样地，clear:right如果有效也是等同于设置clear:both。由此可见，clear:left和clear:right这两个声明就没有任何使用的价值，至少在CSS世界中是如此，直接使用clear:both吧。一般使用伪元素的方式清除浮动.clear::after&#123;content:&apos;&apos;;display:table;//也可以是&apos;block&apos;，或者是&apos;list-item&apos;clear:both;&#125;clear属性只有块级元素才有效的，而::after等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置display属性值的原因。 zoom:1 的清除浮动原理?123456789101112清除浮动，触发hasLayout；zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug。譬如外边距（margin）的重叠，浮动清除，触发ie的haslayout属性等。来龙去脉大概如下：当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。zoom属性是IE浏览器的专有属性，火狐和老版本的webkit核心的浏览器都不支持这个属性。然而，zoom现在已经被逐步标准化，出现在CSS3.0规范草案中。目前非ie由于不支持这个属性，它们又是通过什么属性来实现元素的缩放呢？可以通过css3里面的动画属性scale进行缩放。 移动端的布局用过媒体查询吗？12345678假设你现在正用一台显示设备来阅读这篇文章，同时你也想把它投影到屏幕上，或者打印出来，而显示设备、屏幕投影和打印等这些媒介都有自己的特点，CSS就是为文档提供在不同媒介上展示的适配方法当媒体查询为真时，相关的样式表或样式规则会按照正常的级联规被应用。当媒体查询返回假，标签上带有媒体查询的样式表仍将被下载（只不过不会被应用）。包含了一个媒体类型和至少一个使用宽度、高度和颜色等媒体属性来限制样式表范围的表达式。CSS3加入的媒体查询使得无需修改内容便可以使样式应用于某些特定的设备范围。 详细资料可以参考：《CSS3@media 查询》《响应式布局和自适应布局详解》 浏览器是怎样解析 CSS 选择器的？12345样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则。试想一下，如果采用从左至右的方式读取CSS规则，那么大多数规则读到最后（最右）才会发现是不匹配的，这样做会费时耗能，最后有很多都是无用的；而如果采取从右向左的方式，那么只要发现最右边选择器不匹配，就可以直接舍弃了，避免了许多无效匹配。 详细资料可以参考：《探究 CSS 解析原理》 在网页中应该使用奇数还是偶数的字体？为什么呢？1234（1）偶数字号相对更容易和web设计的其他部分构成比例关系。比如：当我用了14px的正文字号，我可能会在一些地方用14×0.5=7px的margin，在另一些地方用14×1.5=21px的标题字号。（2）浏览器缘故，低版本的浏览器ie6会把奇数字体强制转化为偶数，即13px渲染为14px。（3）系统差别，早期的Windows里，中易宋体点阵只有12和14、15、16px，唯独缺少13px。 详细资料可以参考：《谈谈网页中使用奇数字体和偶数字体》《现在网页设计中的为什么少有人用 11px、13px、15px 等奇数的字体？》 margin 和 padding 分别适合什么场景使用？12345678910111213margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。margin用于布局分开元素使元素与元素互不相干。padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段距离。何时应当使用margin：•需要在border外侧添加空白时。•空白处不需要背景（色）时。•上下相连的两个盒子之间的空白，需要相互抵消时。如15px+20px的margin，将得到20px的空白。何时应当时用padding：•需要在border内测添加空白时。•空白处需要背景（色）时。•上下相连的两个盒子之间的空白，希望等于两者之和时。如15px+20px的padding，将得到35px的空白。 抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题]12我的理解是把常用的css样式单独做成css文件……通用的和业务相关的分离出来，通用的做成样式模块儿共享，业务相关的，放进业务相关的库里面做成对应功能的模块儿。 详细资料可以参考：《CSS 规范-分类方法》 简单说一下 css3 的 all 属性。12345678910all属性实际上是所有CSS属性的缩写，表示，所有的CSS属性都怎样怎样，但是，不包括unicode-bidi和direction这两个CSS属性。支持三个CSS通用属性值，initial,inherit,unset。initial是初始值的意思，也就是该元素元素都除了unicode-bidi和direction以外的CSS属性都使用属性的默认初始值。inherit是继承的意思，也就是该元素除了unicode-bidi和direction以外的CSS属性都继承父元素的属性值。unset是取消设置的意思，也就是当前元素浏览器或用户设置的CSS忽略，然后如果是具有继承特性的CSS，如color，则使用继承值；如果是没有继承特性的CSS属性，如background-color，则使用初始值。 详细资料可以参考：《简单了解 CSS3 的 all 属性》 为什么不建议使用统配符初始化 css 样式。123456采用*&#123;padding:0;margin:0;&#125;这样的写法好处是写起来很简单，但是是通配符，需要把所有的标签都遍历一遍，当网站较大时，样式比较多，这样写就大大的加强了网站运行的负载，会使网站加载的时候需要很长一段时间，因此一般大型的网站都有分层次的一套初始化样式。出于性能的考虑，并不是所有标签都会有padding和margin，因此对常见的具有默认padding和margin的元素初始化即可，并不需使用通配符*来初始化。 absolute 的 containingblock（包含块）计算方式跟正常流有什么不同？12345（1）内联元素也可以作为“包含块”所在的元素；（2）“包含块”所在的元素不是父块级元素，而是最近的position不为static的祖先元素或根元素；（3）边界是padding box而不是content box。 对于 hasLayout 的理解？1234hasLayout是IE特有的一个属性。很多的IE下的css bug都与其息息相关。在IE中，一个元素要么自己对自身的内容进行计算大小和组织，要么依赖于父元素来计算尺寸和组织内容。当一个元素的hasLayout属性值为true时，它负责对自己和可能的子孙元素进行尺寸计算和定位。虽然这意味着这个元素需要花更多的代价来维护自身和里面的内容，而不是依赖于祖先元素来完成这些工作。 详细资料可以参考：《CSS 基础篇–CSS 中 IE 浏览器的 hasLayout，IE 低版本的 bug 根源》《CSS 魔法堂：hasLayout 原来是这样的！》 元素竖向的百分比设定是相对于容器的高度吗？123如果是height的话，是相对于包含块的高度。如果是padding或者margin竖直方向的属性则是相对于包含块的宽度。 全屏滚动的原理是什么？用到了 CSS 的哪些属性？（待深入实践）12345原理：有点类似于轮播，整体的元素一直排列下去，假设有5个需要展示的全屏页面，那么高度是500%，只是展示100%，容器及容器内的页面取当前可视区高度，同时容器的父级元素overflow属性值设为hidden，通过更改容器可视区的位置来实现全屏滚动效果。主要是响应鼠标事件，页面通过CSS的动画效果，进行移动。overflow：hidden；transition：all 1000 ms ease； 详细资料可以参考：《js 实现网页全屏切换（平滑过渡），鼠标滚动切换》《用 ES6 写全屏滚动插件》 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？（待深入了解）12响应式网站设计是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。页面头部必须有meta声明的viewport。 详细资料可以参考：《响应式布局原理》《响应式布局的实现方法和原理》 视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）1视差滚动是指多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验。 详细资料可以参考：《如何实现视差滚动效果的网页？》 如何修改 chrome 记住密码后自动填充表单的黄色背景？123456789101112131415161718chrome表单自动填充后，input文本框的背景会变成黄色的，通过审查元素可以看到这是由于chrome会默认给自动填充的input表单加上input:-webkit-autofill私有属性，然后对其赋予以下样式：&#123;background-color:rgb(250,255,189)!important;background-image:none!important;color:rgb(0,0,0)!important;&#125;对chrome默认定义的background-color，background-image，color使用important是不能提高其优先级的，但是其他属性可使用。使用足够大的纯色内阴影来覆盖input输入框的黄色背景，处理如下input:-webkit-autofill,textarea:-webkit-autofill,select:-webkit-autofill&#123;-webkit-box-shadow:000px 1000px white inset;border:1px solid #CCC !important;&#125; 详细资料可以参考：《去掉 chrome 记住密码后的默认填充样式》《修改谷歌浏览器 chrome 记住密码后自动填充表单的黄色背景》 怎么让 Chrome 支持小于 12px 的文字？12345678910111213在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。解决办法：（1）可以使用Webkit的内核的-webkit-text-size-adjust的私有CSS属性来解决，只要加了-webkit-text-size-adjust:none;字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器已经不再支持-webkit-text-size-adjust样式，所以要使用时候慎用。（2）还可以使用css3的transform缩放属性-webkit-transform:scale(0.5);注意-webkit-transform:scale(0.75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用display：block/inline-block/...；（3）使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。 详细资料可以参考：《谷歌浏览器不支持 CSS 设置小于 12px 的文字怎么办？》 让页面里的字体变清晰，变细用 CSS 怎么做？1234webkit内核的私有属性：-webkit-font-smoothing，用于字体抗锯齿，使用后字体看起来会更清晰舒服。在MacOS测试环境下面设置-webkit-font-smoothing:antialiased;但是这个属性仅仅是面向MacOS，其他操作系统设置后无效。 详细资料可以参考：《让字体变的更清晰 CSS 中-webkit-font-smoothing》 font-style 属性中 italic 和 oblique 的区别？1234italic和oblique这两个关键字都表示“斜体”的意思。它们的区别在于，italic是使用当前字体的斜体字体，而oblique只是单纯地让文字倾斜。如果当前字体没有对应的斜体字体，则退而求其次，解析为oblique，也就是单纯形状倾斜。 设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？123456789设备像素指的是物理像素，一般手机的分辨率指的就是设备像素，一个设备的设备像素是不可变的。css像素和设备独立像素是等价的，不管在何种分辨率的设备上，css像素的大小应该是一致的，css像素是一个相对单位，它是相对于设备像素的，一个css像素的大小取决于页面缩放程度和dpr的大小。dpr指的是设备像素和设备独立像素的比值，一般的pc屏幕，dpr=1。在iphone4时，苹果推出了retina屏幕，它的dpr为2。屏幕的缩放会改变dpr的值。ppi指的是每英寸的物理像素的密度，ppi越大，屏幕的分辨率越大。 详细资料可以参考：《什么是物理像素、虚拟像素、逻辑像素、设备像素，什么又是 PPI,DPI,DPR 和 DIP》《前端工程师需要明白的「像素」》《CSS 像素、物理像素、逻辑像素、设备像素比、PPI、Viewport》《前端开发中像素的概念》 layout viewport、visual viewport 和 ideal viewport 的区别？相关知识点： 1234567891011如果把移动设备上浏览器的可视区域设为viewport的话，某些网站就会因为viewport太窄而显示错乱，所以这些浏览器就决定默认情况下把viewport设为一个较宽的值，比如980px，这样的话即使是那些为桌面设计的网站也能在移动浏览器上正常显示了。ppk把这个浏览器默认的viewport叫做layout viewport。layout viewport的宽度是大于浏览器可视区域的宽度的，所以我们还需要一个viewport来代表浏览器可视区域的大小，ppk把这个viewport叫做visual viewport。ideal viewport是最适合移动设备的viewport，ideal viewport的宽度等于移动设备的屏幕宽度，只要在css中把某一元素的宽度设为ideal viewport的宽度（单位用px），那么这个元素的宽度就是设备屏幕的宽度了，也就是宽度为100%的效果。ideal viewport的意义在于，无论在何种分辨率的屏幕下，那些针对ideal viewport而设计的网站，不需要用户手动缩放，也不需要出现横向滚动条，都可以完美的呈现给用户。 回答： 1234567891011121314移动端一共需要理解三个viewport的概念的理解。第一个视口是布局视口，在移动端显示网页时，由于移动端的屏幕尺寸比较小，如果网页使用移动端的屏幕尺寸进行布局的话，那么整个页面的布局都会显示错乱。所以移动端浏览器提供了一个layout viewport布局视口的概念，使用这个视口来对页面进行布局展示，一般layout viewport的大小为980px，因此页面布局不会有太大的变化，我们可以通过拖动和缩放来查看到这个页面。第二个视口指的是视觉视口，visual viewport指的是移动设备上我们可见的区域的视口大小，一般为屏幕的分辨率的大小。visual viewport和layout viewport的关系，就像是我们通过窗户看外面的风景，视觉视口就是窗户，而外面的风景就是布局视口中的网页内容。第三个视口是理想视口，由于layout viewport一般比visual viewport要大，所以想要看到整个页面必须通过拖动和缩放才能实现。所以又提出了ideal viewport的概念，ideal viewport下用户不用缩放和滚动条就能够查看到整个页面，并且页面在不同分辨率下显示的内容大小相同。ideal viewport其实就是通过修改layout viewport的大小，让它等于设备的宽度，这个宽度可以理解为是设备独立像素，因此根据ideal viewport设计的页面，在不同分辨率的屏幕下，显示应该相同。 详细资料可以参考：《移动前端开发之 viewport 的深入理解》《说说移动前端中 viewport（视口）》《移动端适配知识你到底知多少》 position:fixed;在 android 下无效怎么处理？12345678因为移动端浏览器默认的viewport叫做layout viewport。在移动端显示时，因为layout viewport的宽度大于移动端屏幕的宽度，所以页面会出现滚动条左右移动，fixed的元素是相对layout viewport来固定位置的，而不是移动端屏幕来固定位置的，所以会出现感觉fixed无效的情况。如果想实现fixed相对于屏幕的固定效果，我们需要改变的是viewport的大小为ideal viewport，可以如下设置：&lt;metaname=&quot;viewport&quot;content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no&quot;/&gt; 如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）1多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60*1000ms＝16.7ms 如何让去除 inline-block 元素间间距？1移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing 详细资料可以参考：《去除 inline-block 元素间间距的 N 种方法》 overflow:scroll 时不能平滑滚动的问题怎么处理？12以下代码可解决这种卡顿的问题：-webkit-overflow-scrolling:touch;是因为这行代码启用了硬件加速特性，所以滑动很流畅。 详细资料可以参考：《解决页面使用 overflow:scroll 在 iOS 上滑动卡顿的问题》 有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度。1234（1）外层div使用position：relative；高度要求自适应的div使用position:absolute;top:100px;bottom:0;left:0;right:0;（2）使用flex布局，设置主轴为竖轴，第二个div的flex-grow为1。 详细资料可以参考：《有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度(三种方案)》 png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？相关知识点： 12345678910111213141516171819202122232425262728293031（1）BMP，是无损的、既支持索引色也支持直接色的、点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常具有较大的文件大小。（2）GIF是无损的、采用索引色的、点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但，GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。（3）JPEG是有损的、采用直接色的、点阵图。JPEG的图片的优点，是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。（4）PNG-8是无损的、使用索引色的、点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。现在，除非需要动画的支持，否则我们没有理由使用GIF而不是PNG-8。（5）PNG-24是无损的、使用直接色的、点阵图。PNG-24的优点在于，它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。（6）SVG是无损的、矢量图。SVG是矢量图。这意味着SVG图片由直线和曲线以及绘制它们的方法组成。当你放大一个SVG图片的时候，你看到的还是线和曲线，而不会出现像素点。这意味着SVG图片在放大时，不会失真，所以它非常适合用来绘制企业Logo、Icon等。（7）WebP是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的、点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。•在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；•在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；•WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。但是目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。 回答： 1234567891011121314151617181920212223我了解到的一共有七种常见的图片的格式。（1）第一种是BMP格式，它是无损压缩的，支持索引色和直接色的点阵图。由于它基本上没有进行压缩，因此它的文件体积一般比较大。（2）第二种是GIF格式，它是无损压缩的使用索引色的点阵图。由于使用了LZW压缩方法，因此文件的体积很小。并且GIF还支持动画和透明度。但因为它使用的是索引色，所以它适用于一些对颜色要求不高且需要文件体积小的场景。（3）第三种是JPEG格式，它是有损压缩的使用直接色的点阵图。由于使用了直接色，色彩较为丰富，一般适用于来存储照片。但由于使用的是直接色，可能文件的体积相对于GIF格式来说更大。（4）第四种是PNG-8格式，它是无损压缩的使用索引色的点阵图。它是GIF的一种很好的替代格式，它也支持透明度的调整，并且文件的体积相对于GIF格式更小。一般来说如果不是需要动画的情况，我们都可以使用PNG-8格式代替GIF格式。（5）第五种是PNG-24格式，它是无损压缩的使用直接色的点阵图。PNG-24的优点是它使用了压缩算法，所以它的体积比BMP格式的文件要小得多，但是相对于其他的几种格式，还是要大一些。（6）第六种格式是svg格式，它是矢量图，它记录的图片的绘制方式，因此对矢量图进行放大和缩小不会产生锯齿和失真。它一般适合于用来制作一些网站logo或者图标之类的图片。（7）第七种格式是webp格式，它是支持有损和无损两种压缩方式的使用直接色的点阵图。使用webp格式的最大的优点是，在相同质量的文件下，它拥有更小的文件体积。因此它非常适合于网络图片的传输，因为图片体积的减少，意味着请求时间的减小，这样会提高用户的体验。这是谷歌开发的一种新的图片格式，目前在兼容性上还不是太好。 详细资料可以参考：《图片格式那么多，哪种更适合你？》 浏览器如何判断是否支持 webp 格式图片123456（1）宽高判断法。通过创建image对象，将其src属性设置为webp格式的图片，然后在onload事件中获取图片的宽高，如果能够获取，则说明浏览器支持webp格式图片。如果不能获取或者触发了onerror函数，那么就说明浏览器不支持webp格式的图片。（2）canvas判断方法。我们可以动态的创建一个canvas对象，通过canvas的toDataURL将设置为webp格式，然后判断返回值中是否含有image/webp字段，如果包含则说明支持WebP，反之则不支持。 详细资料可以参考：《判断浏览器是否支持 WebP 图片》《toDataURL()》 style 标签写在 body 后与 body 前有什么区别？123页面加载自上而下当然是先加载样式。写在body标签后由于浏览器以逐行方式对HTML文档进行解析，当解析到写在尾部的样式表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在windows的IE下可能会出现FOUC现象（即样式失效导致的页面闪烁问题） 阐述一下 CSSSprites1234567891011121314将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的background-image，background-repeat，background-position的组合进行背景定位。利用CSSSprites能很好地减少网页的http请求，从而很好的提高页面的性能；CSSSprites能减少图片的字节。优点：减少HTTP请求数，极大地提高页面加载速度增加图片信息重复度，提高压缩比，减少图片大小更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现缺点：图片合并麻烦维护麻烦，修改一个图片可能需要重新布局整个图片，样式 使用 rem 布局的优缺点？123456789优点：在屏幕分辨率千差万别的时代，只要将rem与屏幕分辨率关联起来就可以实现页面的整体缩放，使得在设备上的展现都统一起来了。而且现在浏览器基本都已经支持rem了，兼容性也非常的好。缺点：（1）在奇葩的dpr设备上表现效果不太好，比如一些华为的高端机型用rem布局会出现错乱。（2）使用iframe引用也会出现问题。（3）rem在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问题。 详细资料可以参考：《css3 的字体大小单位 rem 到底好在哪？》《VW:是时候放弃 REM 布局了》《为什么设计稿是 750px》《使用 Flexible 实现手淘 H5 页面的终端适配》 几种常见的 CSS 布局详细的资料可以参考：《几种常见的 CSS 布局》 画一条 0.5px 的线12345采用meta viewport的方式采用border-image的方式采用transform:scale()的方式 详细资料可以参考：《怎么画一条 0.5px 的边（更新）》 transition 和 animation 的区别123transition关注的是CSS property的变化，property值和时间的关系是一个三次贝塞尔曲线。animation作用于元素本身而不是样式属性，可以使用关键帧的概念，应该说可以实现更自由的动画效果。 详细资料可以参考：《CSSanimation 与 CSStransition 有何区别？》《CSS3Transition 和 Animation 区别及比较》《CSS 动画简介》《CSS 动画：animation、transition、transform、translate》 什么是首选最小宽度？12345678“首选最小宽度”，指的是元素最适合的最小宽度。东亚文字（如中文）最小宽度为每个汉字的宽度。西方文字最小宽度由特定的连续的英文字符单元决定。并不是所有的英文字符都会组成连续单元，一般会终止于空格（普通空格）、短横线、问号以及其他非英文字符等。如果想让英文字符和中文一样，每一个字符都用最小宽度单元，可以试试使用CSS中的word-break:break-all。 为什么 height:100%会无效？123456对于普通文档流中的元素，百分比高度值要想起作用，其父级必须有一个可以生效的高度值。原因是如果包含块的高度没有显式指定（即高度由内容决定），并且该元素不是绝对定位，则计算值为auto，因为解释成了auto，所以无法参与计算。使用绝对定位的元素会有计算值，即使祖先元素的height计算为auto也是如此。 min-width/max-width 和 min-height/max-height 属性间的覆盖规则？123（1）max-width会覆盖width，即使width是行类样式或者设置了!important。（2）min-width会覆盖max-width，此规则发生在min-width和max-width冲突的时候。 内联盒模型基本概念12345678910（1）内容区域（content area）。内容区域指一种围绕文字看不见的盒子，其大小仅受字符本身特性控制，本质上是一个字符盒子（character box）；但是有些元素，如图片这样的替换元素，其内容显然不是文字，不存在字符盒子之类的，因此，对于这些元素，内容区域可以看成元素自身。（2）内联盒子（inline box）。“内联盒子”不会让内容成块显示，而是排成一行，这里的“内联盒子”实际指的就是元素的“外在盒子”，用来决定元素是内联还是块级。该盒子又可以细分为“内联盒子”和“匿名内联盒子”两类。（3）行框盒子（line box），每一行就是一个“行框盒子”（实线框标注），每个“行框盒子”又是由一个一个“内联盒子”组成的。（4）包含块（containing box），由一行一行的“行框盒子”组成。 什么是幽灵空白节点？123“幽灵空白节点”是内联盒模型中非常重要的一个概念，具体指的是：在HTML5文档声明中，内联元素的所有解析和渲染表现就如同每个行框盒子的前面有一个“空白节点”一样。这个“空白节点”永远透明，不占据任何宽度，看不见也无法通过脚本获取，就好像幽灵一样，但又确确实实地存在，表现如同文本节点一样，因此，我称之为“幽灵空白节点”。 什么是替换元素？123456789101112131415161718通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。因此，&lt;img&gt;、&lt;object&gt;、&lt;video&gt;、&lt;iframe&gt;或者表单元素&lt;textarea&gt;和&lt;input&gt;和&lt;select&gt;都是典型的替换元素。替换元素除了内容可替换这一特性以外，还有以下一些特性。（1）内容的外观不受页面上的CSS的影响。用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素本身的外观需要类似appearance属性，或者浏览器自身暴露的一些样式接口，（2）有自己的尺寸。在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像素，如&lt;video&gt;、&lt;iframe&gt;或者&lt;canvas&gt;等，也有少部分替换元素为0像素，如&lt;img&gt;图片，而表单元素的替换元素的尺寸则和浏览器有关，没有明显的规律。（3）在很多CSS属性上有自己的一套表现规则。比较具有代表性的就是vertical-align属性，对于替换元素和非替换元素，vertical-align属性值的解释是不一样的。比方说vertical-align的默认值的baseline，很简单的属性值，基线之意，被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。（4）所有的替换元素都是内联水平元素，也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认的display值却是不一样的，有的是inline，有的是inline-block。 替换元素的计算规则？1234567891011121314151617181920212223替换元素的尺寸从内而外分为3类：固有尺寸、HTML尺寸和CSS尺寸。（1）固有尺寸指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。（2）HTML尺寸只能通过HTML原生属性改变，这些HTML原生属性包括&lt;img&gt;的width和height属性、&lt;input&gt;的size属性、&lt;textarea&gt;的cols和rows属性等。（3）CSS尺寸特指可以通过CSS的width和height或者max-width/min-width和max-height/min-height设置的尺寸，对应盒尺寸中的content box。这3层结构的计算规则具体如下（1）如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。（2）如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。（3）如果有CSS尺寸，则最终尺寸由CSS属性决定。（4）如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。（5）如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。（6）内联替换元素和块级替换元素使用上面同一套尺寸计算规则。 content 与替换元素的关系？123456789content属性生成的对象称为“匿名替换元素”。（1）我们使用content生成的文本是无法选中、无法复制的，好像设置了user select:none声明一般，但是普通元素的文本却可以被轻松选中。同时，content生成的文本无法被屏幕阅读设备读取，也无法被搜索引擎抓取，因此，千万不要自以为是地把重要的文本信息使用content属性生成，因为这对可访问性和SEO都很不友好。（2）content生成的内容不能左右:empty伪类。（3）content动态生成值无法获取。 margin:auto 的填充规则？12345margin的&apos;auto&apos;可不是摆设，是具有强烈的计算意味的关键字，用来计算元素对应方向应该获得的剩余间距大小。但是触发margin:auto计算有一个前提条件，就是width或height为auto时，元素是具有对应方向的自动填充特性的。（1）如果一侧定值，一侧auto，则auto为剩余空间大小。（2）如果两侧均是auto，则平分剩余空间。 margin 无效的情形12345678（1）display计算值inline的非替换元素的垂直margin是无效的。对于内联替换元素，垂直margin有效，并且没有margin合并的问题。（2）表格中的&lt;tr&gt;和&lt;td&gt;元素或者设置display计算值是table-cell或table-row的元素的margin都是无效的。（3）绝对定位元素非定位方位的margin值“无效”。（4）定高容器的子元素的margin-bottom或者宽度定死的子元素的margin-right的定位“失效”。 border 的特殊性？12345678910（1）border-width却不支持百分比。（2）border-style的默认值是none，有一部分人可能会误以为是solid。这也是单纯设置border-width或border-color没有边框显示的原因。（3）border-style:double的表现规则：双线宽度永远相等，中间间隔±1。（4）border-color默认颜色就是color色值。（5）默认background背景图片是相对于padding box定位的。 什么是基线和 x-height？1234567字母x的下边缘（线）就是我们的基线。x-height指的就是小写字母x的高度，术语描述就是基线和等分线（meanline）（也称作中线，midline）之间的距离。在CSS世界中，middle指的是基线往上1/2x-height高度。我们可以近似理解为字母x交叉点那个位置。ex是CSS中的一个相对单位，指的是小写字母x的高度，没错，就是指x-height。ex的价值就在其副业上不受字体和字号影响的内联元素的垂直居中对齐效果。内联元素默认是基线对齐的，而基线就是x的底部，而1ex就是一个x的高度。 line-height 的特殊性？123456789101112131415161718192021222324252627（1）对于非替换元素的纯内联元素，其可视高度完全由line-height决定。对于文本这样的纯内联元素，line-height就是高度计算的基石，用专业说法就是指定了用来计算行框盒子高度的基础高度。（2）内联元素的高度由固定高度和不固定高度组成，这个不固定的部分就是这里的“行距”。换句话说，line-height之所以起作用，就是通过改变“行距”来实现的。在CSS中，“行距”分散在当前文字的上方和下方，也就是即使是第一行文字，其上方也是有“行距”的，只不过这个“行距”的高度仅仅是完整“行距”高度的一半，因此，也被称为“半行距”。（3）行距=line-height-font-size。（4）border以及line-height等传统CSS属性并没有小数像素的概念。如果标注的是文字上边距，则向下取整；如果是文字下边距，则向上取整。（5）对于纯文本元素，line-height直接决定了最终的高度。但是，如果同时有替换元素，则line-height只能决定最小高度。（6）对于块级元素，line-height对其本身是没有任何作用的，我们平时改变line-height，块级元素的高度跟着变化实际上是通过改变块级元素里面内联级别元素占据的高度实现的。（7）line-height的默认值是normal，还支持数值、百分比值以及长度值。为数值类型时，其最终的计算值是和当前font-size相乘后的值。为百分比值时，其最终的计算值是和当前font-size相乘后的值。为长度值时原意不变。（8）如果使用数值作为line-height的属性值，那么所有的子元素继承的都是这个值；但是，如果使用百分比值或者长度值作为属性值，那么所有的子元素继承的是最终的计算值。（9）无论内联元素line-height如何设置，最终父级元素的高度都是由数值大的那个line-height决定的。（10）只要有“内联盒子”在，就一定会有“行框盒子”，就是每一行内联元素外面包裹的一层看不见的盒子。然后，重点来了，在每个“行框盒子”前面有一个宽度为0的具有该元素的字体和行高属性的看不见的“幽灵空白节点”。 vertical-align属性垂直对齐图像： 123img &#123; vertical-align:text-top;&#125; 属性定义及使用说明vertical-align 属性设置一个元素的垂直对齐方式。 该属性定义行内元素的基线相对于该元素所在行的基线的垂直对齐。允许指定负长度值和百分比值。这会使元素降低而不是升高。在表单元格中，这个属性会设置单元格框中的单元格内容的对齐方式。 默认值： baseline 继承： no 版本： CSS1 JavaScript 语法： object.style.verticalAlign=”bottom” 属性值 值 描述 baseline 默认。元素放置在父元素的基线上。 sub 垂直对齐文本的下标。 super 垂直对齐文本的上标 top 把元素的顶端与行中最高元素的顶端对齐 text-top 把元素的顶端与父元素字体的顶端对齐 middle 把此元素放置在父元素的中部。 bottom 使元素及其后代元素的底部与整行的底部对齐。 text-bottom 把元素的底端与父元素字体的底端对齐。 length 将元素升高或降低指定的高度，可以是负数。 % 使用 “line-height” 属性的百分比值来排列此元素。允许使用负值。 inherit 规定应该从父元素继承 vertical-align 属性的值。 vertical-align 的特殊性？（1）vertical-align的默认值是baseline，即基线对齐，而基线的定义是字母x的下边缘。因此，内联元素默认都是沿着字母x的下边缘对齐的。对于图片等替换元素，往往使用元素本身的下边缘作为基线。：一个inline-block元素，如果里面没有内联元素，或者overflow不是visible，则该元素的基线就是其margin底边缘；否则其基线就是元素里面最后一行内联元素的基线。 （2）vertical-align:top就是垂直上边缘对齐，如果是内联元素，则和这一行位置最高的内联元素的顶部对齐；如果display计算值是table-cell的元素，我们不妨脑补成元素，则和元素上边缘对齐。 （3）vertical-align:middle是中间对齐，对于内联元素，元素的垂直中心点和行框盒子基线往上1/2x-height处对齐。对于table-cell元素，单元格填充盒子相对于外面的表格行居中对齐。 （4）vertical-align支持数值属性，根据数值的不同，相对于基线往上或往下偏移，如果是负值，往下偏移，如果是正值，往上偏移。 （5）vertical-align属性的百分比值则是相对于line-height的计算值计算的。 （6）vertical-align起作用是有前提条件的，这个前提条件就是：只能应用于内联元素以及display值为table-cell的元素。 （7）table-cell元素设置vertical-align垂直对齐的是子元素，但是其作用的并不是子元素，而是table-cell元素自身。 overflow 的特殊性？（1）一个设置了overflow:hidden声明的元素，假设同时存在border属性和padding属性，则当子元素内容超出容器宽度高度限制的时候，剪裁的边界是border box的内边缘，而非padding box的内边缘。 （2）HTML中有两个标签是默认可以产生滚动条的，一个是根元素，另一个是文本域。 （3）滚动条会占用容器的可用宽度或高度。 （4）元素设置了overflow:hidden声明，里面内容高度溢出的时候，滚动依然存在，仅仅滚动条不存在！ 无依赖绝对定位是什么？没有设置left/top/right/bottom属性值的绝对定位称为“无依赖绝对定位”。 无依赖绝对定位其定位的位置和没有设置position:absolute时候的位置相关。 absolute 与 overflow 的关系？（1）如果overflow不是定位元素，同时绝对定位元素和overflow容器之间也没有定位元素，则overflow无法对absolute元素进行剪裁。 （2）如果overflow的属性值不是hidden而是auto或者scroll，即使绝对定位元素高宽比overflow元素高宽还要大，也都不会出现滚动条。 （3）overflow元素自身transform的时候，Chrome和Opera浏览器下的overflow剪裁是无效的。 clip 裁剪是什么？所谓“可访问性隐藏”，指的是虽然内容肉眼看不见，但是其他辅助设备却能够进行识别和访问的隐藏。 clip剪裁被我称为“最佳可访问性隐藏”的另外一个原因就是，它具有更强的普遍适应性，任何元素、任何场景都可以无障碍使用。 relative 的特殊性？12345（1）相对定位元素的left/top/right/bottom的百分比值是相对于包含块计算的，而不是自身。注意，虽然定位位移是相对自身，但是百分比值的计算值不是。（2）top和bottom这两个垂直方向的百分比值计算跟height的百分比值是一样的，都是相对高度计算的。同时，如果包含块的高度是auto，那么计算值是0，偏移无效，也就是说，如果父元素没有设定高度或者不是“格式化高度”，那么relative类似top:20%的代码等同于top:0。（3）当相对定位元素同时应用对立方向定位值的时候，也就是top/bottom和left/right同时使用的时候，只有一个方向的定位属性会起作用。而谁起作用则是与文档流的顺序有关的，默认的文档流是自上而下、从左往右，因此top/bottom同时使用的时候，bottom失效；left/right同时使用的时候，right失效。 什么是层叠上下文？12345678910111213141516171819层叠上下文，英文称作stacking context，是HTML中的一个三维的概念。如果一个元素含有层叠上下文，我们可以理解为这个元素在z轴上就“高人一等”。层叠上下文元素有如下特性：（1）层叠上下文的层叠水平要比普通元素高（原因后面会说明）。（2）层叠上下文可以阻断元素的混合模式。（3）层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的“层叠上下文”。（4）每个层叠上下文和兄弟元素独立，也就是说，当进行层叠变化或渲染的时候，只需要考虑后代元素。（5）每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。层叠上下文的创建：（1）页面根元素天生具有层叠上下文，称为根层叠上下文。根层叠上下文指的是页面根元素，可以看成是&lt;html&gt;元素。因此，页面中所有的元素一定处于至少一个“层叠结界”中。（2）对于position值为relative/absolute以及Firefox/IE浏览器（不包括Chrome浏览器）下含有position:fixed声明的定位元素，当其z-index值不是auto的时候，会创建层叠上下文。Chrome等WebKit内核浏览器下，position:fixed元素天然层叠上下文元素，无须z-index为数值。根据我的测试，目前IE和Firefox仍是老套路。（3）其他一些CSS3属性，比如元素的opacity值不是1。 什么是层叠水平？1234层叠水平，英文称作stacking level，决定了同一个层叠上下文中元素在z轴上的显示顺序。显而易见，所有的元素都有层叠水平，包括层叠上下文元素，也包括普通元素。然而，对普通元素的层叠水平探讨只局限在当前层叠上下文元素中。 元素的层叠顺序？层叠顺序，英文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。 层叠顺序 层叠准则？123（1）谁大谁上：当具有明显的层叠水平标识的时候，如生效的z-index属性值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。（2）后来居上：当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素。 font-weight 的特殊性？1如果使用数值作为font-weight属性值，必须是100～900的整百数。因为这里的数值仅仅是外表长得像数值，实际上是一个具有特定含义的关键字，并且这里的数值关键字和字母关键字之间是有对应关系的。 text-indent 的特殊性？12345678910（1）text-indent仅对第一行内联盒子内容有效。（2）非替换元素以外的display计算值为inline的内联元素设置text-indent值无效，如果计算值inline-block/inline-table则会生效。（3）&lt;input&gt;标签按钮text-indent值无效。（4）&lt;button&gt;标签按钮text-indent值有效。（5）text-indent的百分比值是相对于当前元素的“包含块”计算的，而不是当前元素。 letter-spacing 与字符间距？12345678910letter-spacing可以用来控制字符之间的间距，这里说的“字符”包括英文字母、汉字以及空格等。letter-spacing具有以下一些特性。（1）继承性。（2）默认值是normal而不是0。虽然说正常情况下，normal的计算值就是0，但两者还是有差别的，在有些场景下，letter-spacing会调整normal的计算值以实现更好的版面布局。（3）支持负值，且值足够大的时候，会让字符形成重叠，甚至反向排列。（4）和text-indent属性一样，无论值多大或多小，第一行一定会保留至少一个字符。（5）支持小数值，即使0.1px也是支持的。（6）暂不支持百分比值。 word-spacing 与单词间距？12letter-spacing作用于所有字符，但word-spacing仅作用于空格字符。换句话说，word-spacing的作用就是增加空格的间隙宽度。 white-space 与换行和空格的控制？12345678910white-space属性声明了如何处理元素内的空白字符，这类空白字符包括Space（空格）键、Enter（回车）键、Tab（制表符）键产生的空白。因此，white-space可以决定图文内容是否在一行显示（回车空格是否生效），是否显示大段连续空白（空格是否生效）等。其属性值包括下面这些。•normal：合并空白字符和换行符。•pre：空白字符不合并，并且内容只在有换行符的地方换行。•nowrap：该值和normal一样会合并空白字符，但不允许文本环绕。•pre-wrap：空白字符不合并，并且内容只在有换行符的地方换行，同时允许文本环绕。•pre-line：合并空白字符，但只在有换行符的地方换行，允许文本环绕。 隐藏元素的 background-image 到底加不加载？相关知识点： 123456789根据测试，一个元素如果display计算值为none，在IE浏览器下（IE8～IE11，更高版本不确定）依然会发送图片请求，Firefox浏览器不会，至于Chrome和Safari浏览器则似乎更加智能一点：如果隐藏元素同时又设置了background-image，则图片依然会去加载；如果是父元素的display计算值为none，则背景图不会请求，此时浏览器或许放心地认为这个背景图暂时是不会使用的。如果不是background-image，而是&lt;img&gt;元素，则设置display:none在所有浏览器下依旧都会请求图片资源。还需要注意的是如果设置的样式没有对应的元素，则background-image也不会加载。hover情况下的background-image，在触发时加载。 回答： -（1）元素的背景图片 -元素本身设置 display:none，会请求图片 -父级元素设置 display:none，不会请求图片 -样式没有元素使用，不会请求-:hover 样式下，触发时请求 -（2）img 标签图片任何情况下都会请求图片 详细资料可以参考：《CSS 控制前端图片 HTTP 请求的各种情况示例》 常见的元素隐藏方式？-（1）使用 display:none;隐藏元素，渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。 -（2）使用 visibility:hidden;隐藏元素。元素在页面中仍占据空间，但是不会响应绑定的监听事件。 -（3）使用 opacity:0;将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。 -（4）通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。 -（5）通过 z-index 负值，来使其他元素遮盖住该元素，以此来实现隐藏。 -（6）通过 clip/clip-path 元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。 -（7）通过 transform:scale(0,0)来将元素缩放为 0，以此来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。 详细资料可以参考：《CSS 隐藏元素的八种方法》 你知道 CSS 中不同属性设置为百分比%时对应的计算基准？1234567891011121314公式：当前元素某CSS属性值 = 基准 * 对应的百分比元素的 position 为 relative 和 absolute 时，top和bottom、left和right基准分别为包含块的 height、width元素的 position 为 fixed 时，top和bottom、left和right基准分别为初始包含块（也就是视口）的 height、width，移动设备较为复杂，基准为 Layout viewport 的 height、width元素的 height 和 width 设置为百分比时，基准分别为包含块的 height 和 width元素的 margin 和 padding 设置为百分比时，基准为包含块的 width（易错）元素的 border-width，不支持百分比元素的 text-indent，基准为包含块的 width元素的 border-radius，基准为分别为自身的height、width元素的 background-size，基准为分别为自身的height、width元素的 translateX、translateY，基准为分别为自身的height、width元素的 line-height，基准为自身的 font-size元素的 font-size，基准为父元素字体 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？有两种， IE 盒子模型、W3C 盒子模型； 区别： IE的content部分把 border 和 padding计算了进去; 盒子模型构成：内容(content)、内填充(padding)、 边框(border)、外边距(margin) IE8及其以下版本浏览器，未声明 DOCTYPE，内容宽高会包含内填充和边框，称为怪异盒模型(IE盒模型) 标准(W3C)盒模型：元素宽度 = width + padding + border + margin 怪异(IE)盒模型：元素宽度 = width + margin 标准浏览器通过设置 css3 的 box-sizing: border-box 属性，触发“怪异模式”解析计算宽高 IE盒子模型 标准盒子模型 标准模式与怪异模式的区别浏览器解析 CSS 的两种模式：标准模式(strict mode)和怪异模式(quirks mode) 标准模式：浏览器按 W3C 标准解析执行代码； 怪异模式：使用浏览器自己的方式解析执行代码，因为不同浏览器解析执行的方式不一样，所以称之为怪异模式。 浏览器解析时使用标准模式还是怪异模式，与网页中的 DTD 声明直接相关，DTD 声明定义了标准文档的类型（标准模式解析）文档类型，会使浏览器使用相关的方式加载网页并显示，忽略 DTD 声明，将使网页进入怪异模式（quirks mode）。 选择器优先级是怎样的？！important&gt;行内样式&gt;id 选择器&gt;类选择器&gt;标签选择器&gt;通配符&gt;继承 权重算法： （0，0，0，0）==》第一个 0 对应的是 important 的个数，第二个 0 对应的是 id 选择器的个数，第三个 0 对应的类选择器的个数，第四个 0 对应的是标签选择器的个数，就是当前选择器的权重。 比较： 先从第一个 0 开始比较，如果第一个 0 大，那么说明这个选择器的权重高，如果第一个相同，比较第二个，依次类推 link 与 @import 的区别 link 是HTML方式， @import 是CSS方式 link最大限度支持并行下载，@import 过多嵌套导致串行下载，出现FOUC link 可以通过 rel=&quot;alternate stylesheet&quot; 指定候选样式 浏览器对 link 支持早于@import ，可以使用 @import 对老浏览器隐藏样式 @import 必须在样式规则之前，可以在css文件中引用其他文件 总体来说：link优于@import display有哪些值？说明他们的作用。 block 块类型。默认宽度为父元素宽度，可设置宽高，换行显示。 none 缺省值。像行内元素类型一样显示。 inline 行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示 inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。 list-item 像块类型元素一样显示，并添加样式列表标记。 table 此元素会作为块级表格来显示。 inherit 规定应该从父元素继承 display 属性的值 display 有哪些值？说明他们的作用默认值：inline 12345678910111213141516171819202122none： 隐藏对象。与visibility属性的hidden值不同，其不为被隐藏的对象保留其物理空间inline： 指定对象为内联元素。block： 指定对象为块元素。list-item： 指定对象为列表项目。inline-block： 指定对象为内联块元素。（CSS2）table： 指定对象作为块元素级的表格。类同于html标签&lt;table&gt;（CSS2）inline-table： 指定对象作为内联元素级的表格。类同于html标签&lt;table&gt;（CSS2）table-caption： 指定对象作为表格标题。类同于html标签&lt;caption&gt;（CSS2）table-cell： 指定对象作为表格单元格。类同于html标签&lt;td&gt;（CSS2）table-row： 指定对象作为表格行。类同于html标签&lt;tr&gt;（CSS2）table-row-group： 指定对象作为表格行组。类同于html标签&lt;tbody&gt;（CSS2）table-column： 指定对象作为表格列。类同于html标签&lt;col&gt;（CSS2）table-column-group： 指定对象作为表格列组显示。类同于html标签&lt;colgroup&gt;（CSS2）table-header-group： 指定对象作为表格标题组。类同于html标签&lt;thead&gt;（CSS2）table-footer-group： 指定对象作为表格脚注组。类同于html标签&lt;tfoot&gt;（CSS2）run-in： 根据上下文决定对象是内联对象还是块级对象。（CSS3）box： 将对象作为弹性伸缩盒显示。（伸缩盒最老版本）（CSS3）inline-box： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒最老版本）（CSS3）flexbox： 将对象作为弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3）inline-flexbox： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3）flex： 将对象作为弹性伸缩盒显示。（伸缩盒最新版本）（CSS3）inline-flex： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒最新版本）（CSS3） 参考 display: none; 与 visibility: hidden; 的区别联系：它们都能让元素不可见 区别： display:none：会让元素完全从渲染树中消失，隐藏对应的元素，渲染的时候不占据任何空间；visibility: hidden：不会让元素从渲染树消失，隐藏对应的元素，渲染时元素仍占据空间位置，只是内容不可见。 即是，使用 CSS display:none 属性后，HTML 元素（对象）的宽度、高度等各种属性值都将“丢失”;而使用 visibility:hidden 属性后，HTML 元素（对象）仅仅是在视觉上看不见（完全透明），而它所占据的空间位置仍然存在。 display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility:hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式 修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘 读屏器不会读取display: none;元素内容；会读取visibility: hidden元素内容 display:none、visibile:hidden、opacity:0 的区别 是否隐藏 是否在文档中占用空间 是否会触发事件 display: none 是 否 否 visibile: hidden 是 是 否 opacity: 0 是 是 是 display:inline-block 什么时候会显示间隙？(携程) 移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing inline-block 布局的元素在编辑器里写在同一行 间隙产生的原因是因为，换行或空格会占据一定的位置 推荐解决方法： 父元素中设置font-size:0;letter-spaceing:-4px; 设置元素浮动后，该元素的 display 值会如何变化？设置元素浮动后，该元素的 display 值自动变成 block css中属性定义，使得dom元素不显示在浏览器可视范围内？1.display属性为none、visibility设为hidden（但是仍然占据页面空间）2.设置宽高为 0，设置透明度为 0，设置 z-index 位置在-1000em(附：该属性仅在定位元素中生效)； display,float,position的关系 如果 display 为none，那么position和float都不起作用，这种情况下元素不产生框 否则，如果position值为absolute或者fixed，框就是绝对定位的，float的计算值为none，display根据下面的表格进行调整 否则，如果float不是none，框是浮动的，display根据下表进行调整 否则，如果元素是根元素，display根据下表进行调整 其他情况下display的值为指定值 总结起来：绝对定位、浮动、根元素都需要调整 display css hack原理及常用hack 原理：利用不同浏览器对CSS的支持和解析结果不一样编写针对特定浏览器样式。 常见的hack有 属性hack 选择器hack IE条件注释 CSS有哪些继承属性 关于文字排版的属性如： font word-break letter-spacing text-align text-rendering word-spacing white-space text-indent text-transform text-shadow line-height color visibility cursor 什么是外边距重叠(collapsing margins)？相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，结合而成的外边距称为折叠外边距 两个或多个毗邻的普通流中的块元素垂直方向上的margin会折叠 浮动元素或inline-block元素或绝对定位元素的margin不会和垂直方向上的其他元素的margin折叠 创建了块级格式化上下文的元素，不会和它的子元素发生margin折叠 元素自身的margin-bottom和margin-top相邻时也会折 重叠的结果是什么？ 折叠结果遵循下列计算规则： 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值 两个外边距一正一负时，折叠结果是两者的相加的和 CSS选择符有哪些？哪些属性可以继承？ id选择器（ # myid） 类选择器（.myclassname） 标签选择器（div, h1, p） 相邻选择器（h1 + p） 子选择器（ul &gt; li） 后代选择器（li a） 通配符选择器（ * ） 属性选择器（a[rel = “external”]） 伪类选择器（a:hover, li:nth-child） 可继承的样式： font-size font-family color, UL LI DL DD DT 不可继承的样式：border padding margin width height CSS3新增伪类有那些？1234567891011p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。:after 在元素之前添加内容,也可以用来做清除浮动。:before 在元素之后添加内容:enabled :disabled 控制表单控件的禁用状态。:checked 单选框或复选框被选中 用 H5+CSS3 解决下导航栏最后一项掉下来的问题答案：box-sizing: border-box; position的值relative和absolute定位原点是？absolute 生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。 fixed （老IE不支持） 生成绝对定位的元素，相对于浏览器窗口进行定位。 relative 生成相对定位的元素，相对于其正常位置进行定位。 static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right - z-index 声明）。 inherit 规定从父元素继承 position 属性的值 CSS3有哪些新特性？ 新增选择器 p:nth-child(n){color: rgba(255, 0, 0, 0.75)}；E:last-child 匹配父元素的最后一个子元素 E；not(.input)：所有 class 不是“input”的节点 弹性盒模型 display: flex; 多列布局 column-count: 5; 媒体查询 @media (max-width: 480px) {.box: {column-count: 1;}} 个性化字体 @font-face{font-family: BorderWeb; src:url(BORDERW0.eot);} 颜色透明度 color: rgba(255, 0, 0, 0.75); 圆角 border-radius: 5px; 线性渐变 background:linear-gradient(red, green, blue); 阴影 box-shadow:3px 3px 3px rgba(0, 64, 128, 0.3); 倒影 box-reflect: below 2px; 反射 reflect 文字装饰 text-stroke-color: red; 文字溢出 text-overflow:ellipsis; 文字特效 text-shadow 文字渲染 Text-decoration 背景效果 background-size: 100px 100px; 边框效果 border-image:url(bt_blue.png) 0 10; 转换 旋转 transform: rotate(20deg); 倾斜 transform: skew(150deg, -10deg); 位移 transform: translate(20px, 20px); 缩放 transform: scale(.5); 平滑过渡 transition: all .3s ease-in .1s; 动画 @keyframes anim-1 {50% {border-radius: 50%;}} animation: anim-1 1s; css tricks：如何活用CSS，以及了解CSS新特性，这里可以满足你 2020不容错过！24个CSS新特性来了 CSS3 新增伪类有那些？12345678910111213141516171819202122232425262728（1）elem:nth-child(n)选中父元素下的第n个子元素，并且这个子元素的标签名为elem，n可以接受具体的数值，也可以接受函数。（2）elem:nth-last-child(n)作用同上，不过是从后开始查找。（3）elem:last-child选中最后一个子元素。（4）elem:only-child如果elem是父元素下唯一的子元素，则选中之。（5）elem:nth-of-type(n)选中父元素下第n个elem类型元素，n可以接受具体的数值，也可以接受函数。（6）elem:first-of-type选中父元素下第一个elem类型元素。（7）elem:last-of-type选中父元素下最后一个elem类型元素。（8）elem:only-of-type如果父元素下的子元素只有一个elem类型元素，则选中该元素。（9）elem:empty选中不包含子元素和内容的elem类型元素。（10）elem:target选择当前活动的elem元素。（11）:not(elem)选择非elem元素的每个元素。（12）:enabled 控制表单控件的禁用状态。（13）:disabled 控制表单控件的禁用状态。 (14) :checked单选框或复选框被选中。 详细的资料可以参考：《CSS3 新特性总结(伪类)》《浅谈 CSS 伪类和伪元素及 CSS3 新增伪类》 css3 有哪些新特性 选择器 E:last-child 匹配父元素的最后一个子元素 E。 E:nth-child(n)匹配父元素的第 n 个子元素 E。 E:nth-last-child(n) CSS3 匹配父元素的倒数第 n 个子元素 E。 多栏布局 1234567891011121314&lt;div class=\"mul-col\"&gt; &lt;div&gt; &lt;h3&gt;新手上路&lt;/h3&gt; &lt;p&gt;新手专区 消费警示 交易安全 24小时在线帮助 免费开店&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;h3&gt;付款方式&lt;/h3&gt; &lt;p&gt;快捷支付 信用卡 余额宝 蚂蚁花呗 货到付款&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;h3&gt;淘宝特色&lt;/h3&gt; &lt;p&gt;手机淘宝 旺信 大众评审 B格指南&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 12345678.mul-col &#123; column-count: 3; column-gap: 5px; column-rule: 1px solid gray; border-radius: 5px; border: 1px solid gray; padding: 10px;&#125; 多背景图 1/* backgroundimage:url('1.jpg),url('2.jpg') */ CSS3 word-wrap 属性 123p.test &#123; word-wrap: break-word;&#125; 文字阴影 1text-shadow: 5px 2px 6px rgba(64, 64, 64, 0.5); @font-face 属性 Font-face 可以用来加载字体样式，而且它还能够加载服务器端的字体文件，让客户端显示客户端所没有安装的字体。 12345678910111213141516171819202122232425@font-face &#123; font-family: BorderWeb; src: url(BORDERW0.eot);&#125;@font-face &#123; font-family: Runic; src: url(RUNICMT0.eot);&#125;.border &#123; font-size: 35px; color: black; font-family: \"BorderWeb\";&#125;.event &#123; font-size: 110px; color: black; font-family: \"Runic\";&#125;/* 淘宝网字体使用 */@font-face &#123; font-family: iconfont; src: url(//at.alicdn.com/t/font_1465189805_4518812.eot);&#125; 圆角 1border-radius: 15px; 边框图片 CSS3 border-image 属性 盒阴影 1/* box-shadow: 水平方向的偏移量 垂直方向的偏移量 模糊程度 扩展程度 颜色 是否具有内阴影 */ 盒子大小 CSS3 box-sizing 属性 媒体查询 CSS3 @media 查询 CSS3 动画 @keyframes 1234567891011@keyframes abc &#123; from &#123; transform: rotate(0); &#125; 50% &#123; transform: rotate(90deg); &#125; to &#123; transform: rotate(360deg); &#125;&#125; animation 属性 1/* animation：name duration timing-function delay interation-count direction play-state */ 渐变效果 1234567background-image: -webkit-gradient( linear, 0% 0%, 100% 0%, from(#2a8bbe), to(#fe280e)); CSS3 弹性盒子模型 弹性盒子是 CSS3 的一种新的布局模式。 CSS3 弹性盒（ Flexible Box 或 flexbox），是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。 引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。 CSS3 过渡 123456div &#123; transition: width 2s; -moz-transition: width 2s; /* Firefox 4 */ -webkit-transition: width 2s; /* Safari 和 Chrome */ -o-transition: width 2s; /* Opera */&#125; CSS3 变换 rotate()旋转 translate()平移 scale( )缩放 skew()扭曲/倾斜 变换基点 3d 转换 参考 一个满屏 品 字布局 如何设计?简单的方式： 上面的div宽100%， 下面的两个div分别宽50%， 然后用float或者inline使其不换行即可 请写出多种等高布局css定义的权重1234567891011121314151617181920212223// 以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100//以下例子是演示各种定义的权重值：/*权重为1*/div&#123;&#125;/*权重为10*/.class1&#123;&#125;/*权重为100*/#id1&#123;&#125;/*权重为100+1=101*/#id1 div&#123;&#125;/*权重为10+1=11*/.class1 div&#123;&#125;/*权重为10+10+1=21*/.class1 .class2 div&#123;&#125;// 如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现 谈谈浮动和清除浮动浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上 解释下什么是浮动和它的工作原理？非IE浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。 工作原理： 浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象） 浮动元素碰到包含它的边框或者其他浮动元素的边框停留 浮动元素引起的问题？ 父元素的高度无法被撑开，影响与父元素同级的元素 与浮动元素同级的非浮动元素会跟随其后 列举几种清除浮动的方式？ 添加额外标签，例如 &lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt; 使用 br 标签和其自身的 clear 属性，例如 &lt;br clear=&quot;all&quot; /&gt; 父元素设置 overflow：hidden; 在IE6中还需要触发 hasLayout，例如zoom：1; 父元素也设置浮动 使用 :after 伪元素。由于IE6-7不支持 :after，使用 zoom:1 触发 hasLayout 清除浮动的方式以及各自的优点1.额外标签法（在最后一个浮动标签后，新加一个标签，给其设置 clear： both）不推荐o 优点：通俗易懂，方便o 缺点：添加无意义标签，语义化差2.父级添加 overflow 属性 （overflow：hidden）不推荐o 优点：代码简洁o 缺点：内容增多的时候容易造成不会自动换行导致内容被隐蔽掉，无法显示要溢出的元素3.给父级设置高度o 优点：简单，代码少，容易掌握o 缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级 div 不一样时，会产生问题4.父级 div 定义 overflow:auto(必须定义 width 或 zoom:1，同时不能定义 height，使用 overflow:auto 时，浏览器会自动检查浮动区域的高度)o 优点：简单，代码少，浏览器支持好o 缺点：内部宽高超过父级 div 时，会出现滚动条。5.使用 after 伪元素清除浮动（推荐使用） 12345678.clear:after&#123;content:&quot;&quot;;display:block;clear:both;height:0;overflow:hidden;visibility:hidden&#125; o 优点：符合闭合浮动思想，结构语义化正确o 缺点：ie6-7 不支持伪元素：after，使用 zoom：1 触发 hasLayout CSS 清除浮动的几种方法（至少两种）清除浮动： 核心：clear:both; 1.（不推荐使用） 在浮动的盒子下面再放一个标签，使用 clear:both;来清除浮动 a 内部标签：会将父盒子的高度重新撑开 b 外部标签：只能将浮动盒子的影响清除，但是不会撑开盒子 2.使用 overflow 清除浮动（不推荐使用） 先找到浮动盒子的父元素，给父元素添加一个属性：overflow:hidden;就会清除子元素对页面的影响 3.使用伪元素清除浮动(用的最多) 伪元素：在页面上不存在的元素，但是可以通过 css 添加上去 种类： :after(在。。。之后) :before(在。。。之前) 注意：每个元素都有自己的伪元素 12345678910111213.clearfix:after &#123; content:&quot;&quot;; height:0; line-height:0; display:block; clear:both; visibility:hidden; /_将元素隐藏起来_/ 在页面的 clearfix 元素后面添加了一个空的块级元素 （这个元素的高为 0 行高也为 0 并且这个元素清除了浮动）&#125;.clearfix &#123; zoom:1;/_为了兼容 IE6_/&#125; 清除浮动最佳实践（after伪元素闭合浮动）123456789.clearfix:after&#123; content: &quot;\\200B&quot;; display: table; height: 0; clear: both; &#125; .clearfix&#123; *zoom: 1; &#125; 请解释一下为什么需要清除浮动？清除浮动的方式清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示 父级div定义height 父级div 也一起浮动； 常规的使用一个class； 12345678910.clearfix:before, .clearfix:after &#123; content: &quot; &quot;; display: table;&#125;.clearfix:after &#123; clear: both;&#125;.clearfix &#123; *zoom: 1;&#125; SASS编译的时候，浮动元素的父级div定义伪类:after 1234567&amp;:after,&amp;:before&#123; content: &quot; &quot;; visibility: hidden; display: block; height: 0; clear: both;&#125; 解析原理： display:block 使生成的元素以块级元素显示,占满剩余空间 height:0 避免生成内容破坏原有布局的高度。 visibility:hidden 使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互 通过 content:”.”生成内容作为最后一个元素，至于content里面是点还是其他都是可以的，例如oocss里面就有经典的 content:”.”,有些版本可能content 里面内容为空,一丝冰凉是不推荐这样做的,firefox直到7.0 content:”” 仍然会产生额外的空隙 zoom：1 触发IE hasLayout 通过分析发现，除了clear：both用来闭合浮动的，其他代码无非都是为了隐藏掉content生成的内容，这也就是其他版本的闭合浮动为什么会有font-size：0，line-height：0 zoom:1的清除浮动原理? 清除浮动，触发hasLayout； Zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug 譬如外边距（margin）的重叠，浮动清除，触发ie的haslayout属性等 css的content属性？有什么作用与应用css的content属性专门应用在before/after伪元素上，用来插入生成内容。常用伪类清除浮动： 12345678910.clearfix:after&#123;content:&quot;.&quot;;display:block;height:0;visibility:hidden;clear:both;&#125;.clearfix&#123;*zoom:1;&#125; 清除浮动的方式1、给父元素定义height2、结尾处加空div标签clear：both；3、父级元素定义伪类：如上；4、父级元素定义overflow：hidden；5、父级元素定义overflow：auto；6、父级元素也浮动,需要定义宽度；7、父级元素定义display：table；8、结尾处加br标签clear：both； 第三种：after伪元素方法清理浮动，文档结构更加清晰 内联元素的尺寸标准模式下，non-replaced inline 元素无法自定义大写； 怪异模式下，定义这些元素的 width、height 属性可以影响这些元素显示的尺寸。 元素的百分比高度 CSS 中对于元素的百分比高度规定：百分比为元素包含块的高度，不可为负值；如果包含块的高度没有显示给出，该值等同于 auto，所以百分比的高度必须是在元素有高度声明的情况下使用。 当一个元素使用百分比高度是，标准模式下，高度取决于内容变化，怪异模式下，百分比高度被准确应用 元素溢出的处理标准模式下，overflow 取值默认为 visible；在怪异模式在，该溢出会被当做扩展 box 来对待，即元素的大小由内容决定，溢出不会裁剪，元素框自动调整，包含溢出内容。 知道 css 计数器（序列数字字符自动递增）吗？如何通过 css content 属性实现 css 计数器？css 计数器是通过设置 counter-reset 、counter-increment 两个属性 、及 counter()/counters()一个方法配合 after / before 伪类实现。 box-sizing 常用的属性有哪些？分别有什么作用？ box-sizing: content-box; // 默认的标准(W3C)盒模型元素效果 box-sizing: border-box; // 触发怪异(IE)盒模型元素的效果 box-sizing: inherit; // 继承父元素 box-sizing 属性的值 CSS选择器有哪些？ id选择器 #id 类选择器 .class 标签选择器 div, h1, p 相邻选择器 h1 + p 子选择器 ul &gt; li 后代选择器 li a 通配符选择器 * 属性选择器 a[rel=’external’] 伪类选择器 a:hover, li:nth-child CSS哪些属性可以继承？哪些属性不可以继承？ 可以继承的样式：font-size、font-family、color、list-style、cursor 不可继承的样式：width、height、border、padding、margin、background CSS3新增伪类有哪些？ :root 选择文档的根元素，等同于 html 元素 :empty 选择没有子元素的元素 :target 选取当前活动的目标元素 :not(selector) 选择除 selector 元素意外的元素 :enabled 选择可用的表单元素 :disabled 选择禁用的表单元素 :checked 选择被选中的表单元素 :after 在元素内部最前添加内容 :before 在元素内部最后添加内容 :nth-child(n) 匹配父元素下指定子元素，在所有子元素中排序第n :nth-last-child(n) 匹配父元素下指定子元素，在所有子元素中排序第n，从后向前数 :nth-child(odd) :nth-child(even) :nth-child(3n+1) :first-child :last-child :only-child :nth-of-type(n) 匹配父元素下指定子元素，在同类子元素中排序第n :nth-last-of-type(n) 匹配父元素下指定子元素，在同类子元素中排序第n，从后向前数 :nth-of-type(odd) :nth-of-type(even) :nth-of-type(3n+1) :first-of-type :last-of-type :only-of-type ::selection 选择被用户选取的元素部分 :first-line 选择元素中的第一行 :first-letter 选择元素中的第一个字符 请列举几种隐藏元素的方法 visibility: hidden; 这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在 opacity: 0; CSS3属性，设置0可以使一个元素完全透明 position: absolute; 设置一个很大的 left 负值定位，使元素定位在可见区域之外 display: none; 元素会变得不可见，并且不会再占用文档的空间。 transform: scale(0); 将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留 &lt;div hidden=&quot;hidden&quot;&gt; HTML5属性,效果和display:none;相同，但这个属性用于记录一个元素的状态 height: 0; 将元素高度设为 0 ，并消除边框 filter: blur(0); CSS3属性，将一个元素的模糊度设置为0，从而使这个元素“消失”在页面中 rgba() 和 opacity 的透明效果有什么不同？rgba()和 opacity 都能实现透明效果 opacity 作用于元素以及元素内的所有内容（包括文字）的透明度 rgba() 只作用于元素自身的颜色或其背景色，子元素不会继承透明效果 css样式继承拓展：http://www.cnblogs.com/thislbq/p/5882105.html css 属性 content 有什么作用？content 属性专门应用在 before/after 伪元素上，用于插入额外内容或样式 请解释一下 CSS3 的 Flexbox（弹性盒布局模型）以及适用场景？Flexbox 用于不同尺寸屏幕中创建可自动扩展和收缩布局 经常遇到的浏览器的JS兼容性有哪些？解决方法是什么？ 当前样式：getComputedStyle(el, null) VS el.currentStyle 事件对象：e VS window.event 鼠标坐标：e.pageX, e.pageY VS window.event.x, window.event.y 按键码：e.which VS event.keyCode 文本节点：el.textContent VS el.innerText 在列的父元素上使用这个背景图进行Y轴的铺放，从而实现一种等高列的假像 模仿表格布局等高列效果：兼容性不好，在ie6-7无法正常运行 css3 flexbox 布局： .container{display: flex; align-items: stretch;} 在CSS样式中常使用 px、em 在表现上有什么区别？ px 相对于显示器屏幕分辨率，无法用浏览器字体放大功能 em 值并不是固定的，会继承父级的字体大小： em = 像素值 / 父级font-size 为什么要初始化CSS样式？ 不同浏览器对有些标签样式的默认值解析不同 不初始化CSS会造成各现浏览器之间的页面显示差异 可以使用 reset.css 或 Normalize.css 做 CSS 初始化 去掉标签的默认样式如：margin,padding，其他浏览器默认解析字体大小，字体设置。 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化 设置css样式的三种方式？外部样式表，引入一个外部css文件内部样式表，将css代码放在标签内部内联样式，将css样式直接定义在html元素内部 浏览器是怎样解析CSS选择器的？浏览器解析 CSS 选择器的方式是从右到左 在网页中的应该使用奇数还是偶数的字体？在网页中的应该使用“偶数”字体： 偶数字号相对更容易和 web 设计的其他部分构成比例关系 使用奇数号字体时文本段落无法对齐 宋体的中文网页排布中使用最多的就是 12 和 14 margin和padding分别适合什么场景使用？ 需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin 需要在border内测添加空白，且空白处需要背景（色）时，使用 padding 抽离样式模块怎么写，说出思路？CSS可以拆分成2部分：公共CSS 和 业务CSS： 网站的配色，字体，交互提取出为公共CSS。这部分CSS命名不应涉及具体的业务 对于业务CSS，需要有统一的命名，使用公用的前缀。可以参考面向对象的CSS 元素竖向的百分比设定是相对于容器的高度吗？元素竖向的百分比设定是相对于容器的宽度，而不是高度 全屏滚动的原理是什么？ 用到了CSS的那些属性？ 原理类似图片轮播原理，超出隐藏部分，滚动时显示 可能用到的CSS属性：overflow:hidden; transform:translate(100%, 100%); display:none; 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？ 响应式设计就是网站能够兼容多个终端，而不是为每个终端做一个特定的版本 基本原理是利用CSS3媒体查询，为不同尺寸的设备适配不同样式 对于低版本的IE，可采用JS获取屏幕宽度，然后通过resize方法来实现兼容： 12345678910111213141516$(window).resize(function () &#123; screenRespond();&#125;);screenRespond();function screenRespond()&#123;var screenWidth = $(window).width();if(screenWidth &lt;= 1800)&#123; $(\"body\").attr(\"class\", \"w1800\");&#125;if(screenWidth &lt;= 1400)&#123; $(\"body\").attr(\"class\", \"w1400\");&#125;if(screenWidth &gt; 1800)&#123; $(\"body\").attr(\"class\", \"\");&#125;&#125; 什么是视差滚动效果，如何给每页做不同的动画？ 视差滚动是指多层背景以不同的速度移动，形成立体的运动效果，具有非常出色的视觉体验 一般把网页解剖为：背景层、内容层和悬浮层。当滚动鼠标滚轮时，各图层以不同速度移动，形成视差的 实现原理 以 “页面滚动条” 作为 “视差动画进度条” 以 “滚轮刻度” 当作 “动画帧度” 去播放动画的 监听 mousewheel 事件，事件被触发即播放动画，实现“翻页”效果 a标签上四个伪类的执行顺序是怎么样的？> visited > hover > active```123456789- L-V-H-A love hate 用喜欢和讨厌两个词来方便记忆### 伪元素和伪类的区别和作用？- 伪元素 -- 在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。- 它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如： p::before {content:”第一章：”;}p::after {content:”Hot!”;}p::first-line {background:red;}p::first-letter {font-size:30px;} 12- 伪类 -- 将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如： a:hover {color: #FF00FF}p:first-child {color: red} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161### ::before 和 :after 中双冒号和单冒号有什么区别？* 在 CSS 中伪类一直用 : 表示，如 :hover, :active 等* 伪元素在CSS1中已存在，当时语法是用 : 表示，如 :before 和 :after* 后来在CSS3中修订，伪元素用 :: 表示，如 ::before 和 ::after，以此区分伪元素和伪类* 由于低版本IE对双冒号不兼容，开发者为了兼容性各浏览器，继续使使用 :after 这种老语法表示伪元素* 综上所述：::before 是 CSS3 中写伪元素的新语法； :after 是 CSS1 中存在的、兼容IE的老语法### 如何修改Chrome记住密码后自动填充表单的黄色背景？- 产生原因：由于Chrome默认会给自动填充的input表单加上 input:-webkit-autofill 私有属性造成的- 解决方案1：在form标签上直接关闭了表单的自动填充：autocomplete=&quot;off&quot;- 解决方案2：input:-webkit-autofill &#123; background-color: transparent; &#125;### 你对 line-height 是如何理解的？* line-height 指一行字的高度，包含了字间距，实际上是下一行基线到上一行基线距离* 如果一个标签没有定义 height 属性，那么其最终表现的高度是由 line-height 决定的* 一个容器没有设置高度，那么撑开容器高度的是 line-height 而不是容器内的文字内容* 把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中* line-height 和 height 都能撑开一个高度，height 会触发 haslayout，而 line-height 不会### line-height 三种赋值方式有何区别？（带单位、纯数字、百分比）* 带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高* 纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px* 百分比：将计算后的值传递给后代### font-style 属性 oblique 是什么意思？font-style: oblique; 使没有 italic 属性的文字实现倾斜### display:inline-block 什么时候会显示间隙？* 相邻的 inline-block 元素之间有换行或空格分隔的情况下会产生间距* 非 inline-block 水平元素设置为 inline-block 也会有水平间距* 可以借助 vertical-align:top; 消除垂直间隙* 可以在父级加 font-size：0; 在子元素里设置需要的字体大小，消除垂直间隙* 把 li 标签写到同一行可以消除垂直间隙，但代码可读性差### 去除 inline-block 元素间间距的方法- 移除空格- 使用 margin 负值- 使用 font-size:0- letter-spacing- word-spacing解析：更详细的介绍请看[去除 inline-block 元素间间距的 N 种方法](https://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%E5%8E%BB%E9%99%A4%E9%97%B4%E8%B7%9D/)### 那么问题来了，浏览器还有默认的天生 inline-block 元素（拥有内在尺寸，可设置高宽，但不会自动换行），有哪些？`&lt;input&gt; 、&lt;img&gt; 、&lt;button&gt; 、&lt;texterea&gt; 、&lt;label&gt;。`### overflow: scroll 时不能平滑滚动的问题怎么处理？监听滚轮事件，然后滚动到一定距离时用 jquery 的 animate 实现平滑效果。### CSS选择符有哪些？哪些属性可以继承？- id选择器（ # myid）- 类选择器（.myclassname）- 标签选择器（div, h1, p）- 相邻选择器（h1 + p）- 子选择器（ul &gt; li）- 后代选择器（li a）- 通配符选择器（ * ）- 属性选择器（a[rel = &quot;external&quot;]）- 伪类选择器（a:hover, li:nth-child）- 可继承的样式： font-size font-family color, UL LI DL DD DT- 不可继承的样式：border padding margin width height### CSS3新增伪类有那些？- p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。- p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。- p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。- p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。- p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。- :after 在元素之前添加内容,也可以用来做清除浮动。- :before 在元素之后添加内容- :enabled - :disabled 控制表单控件的禁用状态。- :checked 单选框或复选框被选中### position的值relative和absolute定位原点是？- absolute 生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。- fixed （老IE不支持） 生成绝对定位的元素，相对于浏览器窗口进行定位。- relative 生成相对定位的元素，相对于其正常位置进行定位。- static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。- inherit 规定从父元素继承 position 属性的值### 请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？- 一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间- 较为复杂的布局还可以通过嵌套一个伸缩容器（flex container）来实现- 采用Flex布局的元素，称为Flex容器（flex container），简称&quot;容器&quot;。- 它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称&quot;项目&quot;- 常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做局中，能对不同屏幕大小自适应- 在布局上有了比以前更加灵活的空间### css多列等高如何实现？- 利用padding-bottom|margin-bottom正负值相抵；- 设置父容器设置超出隐藏（overflow:hidden），这样子父容器的高度就还是它里面的列没有设定padding-bottom时的高度- 当它里面的任 一列高度增加了，则父容器的高度被撑到里面最高那列的高度- 其他比这列矮的列会用它们的padding-bottom补偿这部分高度差### 经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧- png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8- 浏览器默认的margin和padding不同。解决方案是加一个全局的*&#123;margin:0;padding:0;&#125;来统一- IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大- 浮动ie产生的双倍距离 #box&#123; float:left; width:10px; margin:0 0 0 100px;&#125;- 这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)- 渐进识别的方式，从总体中逐渐排除局部- 首先，巧妙的使用“\\9”这一标记，将IE游览器从所有情况中分离出来。- 接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别 .bb{ background-color:red;/所有识别/ background-color:#00deff\\9; /IE6、7、8识别/ +background-color:#a200ff;/IE6、7识别/ _background-color:#1e0bd1;/IE6识别/ } 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849- IE下,可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性;- Firefox下,只能使用getAttribute()获取自定义属性- 解决方法:统一通过getAttribute()获取自定义属性。- IE下,even对象有x,y属性,但是没有pageX,pageY属性- Firefox下,event对象有pageX,pageY属性,但是没有x,y属性- 解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。- Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,- 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。- 超链接访问过后hover样式就不出现了。被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:- `L-V-H-A : a:link &#123;&#125; a:visited &#123;&#125; a:hover &#123;&#125; a:active &#123;&#125;`### absolute的containing block(容器块)计算方式跟正常流有什么不同？- 无论属于哪种，都要先找到其祖先元素中最近的 position 值不为 static 的元素，然后再判断： 1、若此元素为 inline 元素，则 containing block为能够包含这个元素生成的第一个和最后一个 inline box 的 padding box (除 margin, border 外的区域) 的最小矩形； 2、否则,则由这个祖先元素的 padding box 构成。如果都找不到，则为 initial containing block。- 补充： 1. static(默认的)/relative：简单说就是它的父元素的内容框（即去掉padding的部分） 2. absolute: 向上找最近的定位为absolute/relative的元素 3. fixed: 它的containing block一律为根元素(html/body)，根元素也是initial containing block### CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？- 对于普通元素visibility:collapse;会将元素完全隐藏,不占据页面布局空间,与display:none;表现相同.- 如果目标元素为table,visibility:collapse;将table隐藏,但是会占据页面布局空间.- 仅在Firefox下起作用,IE会显示元素,Chrome会将元素隐藏,但是占据空间.### position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？- 如果元素的display为none,那么元素不被渲染,position,float不起作用,- 如果元素拥有position:absolute;或者position:fixed;属性那么元素将为绝对定位,float不起作用.- 如果元素float属性不是none,元素会脱离文档流,根据float属性值来显示.有浮动,绝对定位,inline-block属性的元素,margin不会和垂直方向上的其他元素margin折叠### css定义的权重- 以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下例子是演示各种定义的权重值 /权重为1/div{}/权重为10/.class1{}/权重为100/ #id1{}/权重为100+1=101/ #id1 div{}/权重为10+1=11/.class1 div{}/权重为10+10+1=21/.class1 .class2 div{} 1234567891011121314- 如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现 ### 移动端的布局用过媒体查询吗？- 假设你现在正用一台显示设备来阅读这篇文章，同时你也想把它投影到屏幕上，或者打印出来，而显示设备、屏幕投影和打印等这些媒介都有自己的特点，CSS就是为文档提供在不同媒介上展示的适配方法- &lt;!-- link元素中的CSS媒体查询 --&gt; - 当媒体查询为真时，相关的样式表或样式规则会按照正常的级联规被应用。 - 当媒体查询返回假， &lt;link&gt; 标签上带有媒体查询的样式表 仍将被下载 （只不过不会被应用）- &lt;link rel=&quot;stylesheet&quot; media=&quot;(max-width: 800px)&quot; href=&quot;example.css&quot; /&gt;- &lt;!-- 样式表中的CSS媒体查询 --&gt; - 包含了一个媒体类型和至少一个使用 宽度、高度和颜色等媒体属性来限制样式表范围的表达式 - CSS3加入的媒体查询使得无需修改内容便可以使样式应用于某些特定的设备范围 @media (min-width: 700px) and (orientation: landscape){ .sidebar { display: none; } } 1234567891011121314151617181920212223242526272829### 浏览器是怎样解析CSS选择器的？- 样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素- 只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则### margin和padding分别适合什么场景使用？- margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。- margin用于布局分开元素使元素与元素互不相干；- padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段### ::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用- 单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）- 双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法- 比如:first-line、:first-letter、:before、:after等，而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。- 想让插入的内容出现在其它内容前，使用::before，否者，使用::after；在代码顺序上，::after生成的内容也比::before生成的内容靠后。- 如果按堆栈视角，::after生成的内容会在::before生成的内容之上### 如何修改chrome记住密码后自动填充表单的黄色背景 ？ input:-webkit-autofill, textarea:-webkit-autofill, select:-webkit-autofill { background-color: rgb(250, 255, 189); /* #FAFFBD; */ background-image: none; color: rgb(0, 0, 0);} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157### 让页面里的字体变清晰，变细用CSS怎么做？-webkit-font-smoothing: antialiased;### font-style属性可以让它赋值为“oblique” oblique是什么意思？倾斜的字体样式### position:fixed;在android下无效怎么处理？- fixed的元素是相对整个页面固定位置的，你在屏幕上滑动只是在移动这个所谓的viewport，原来的网页还好好的在那，fixed的内容也没有变过位置，- 所以说并不是iOS不支持fixed，只是fixed的元素不是相对手机屏幕固定的- `&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;/&gt;`### 如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms### 什么是CSS 预处理器 / 后处理器？- 预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。- 后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。### 盒模型：content（元素内容） + padding（内边距） + border（边框） + margin（外边距）&gt; 延伸： `box-sizing`- `content-box`：默认值，总宽度 = `margin` + `border` + `padding` + `width`- `border-box`：盒子宽度包含 `padding` 和 `border`，`总宽度 = margin + width`- `inherit`：从父元素继承 `box-sizing` 属性### BFC、IFC、GFC、FFC：FC（Formatting Contexts），格式化上下文&gt; `BFC`：块级格式化上下文，容器里面的子元素不会在布局上影响到外面的元素，反之也是如此(按照这个理念来想，只要脱离文档流，肯定就能产生 `BFC`)。产生 `BFC` 方式如下- `float` 的值不为 `none`。- `overflow` 的值不为 `visible`。- `position` 的值不为 `relative` 和 `static`。- `display` 的值为 `table-cell`, `table-caption`, `inline-block`中的任何一个&gt; 用处？常见的多栏布局，结合块级别元素浮动，里面的元素则是在一个相对隔离的环境里运行&gt; `IFC`：内联格式化上下文，`IFC` 的 `line` `box`（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的 `padding/margin` 影响)。&gt; `IFC`中的`line box`一般左右都贴紧整个 `IFC`，但是会因为 `float` 元素而扰乱。`float` 元素会位于 IFC 与 `line box` 之间，使得 `line box` 宽度缩短。 同个 `ifc` 下的多个 `line box` 高度会不同。 `IFC`中时不可能有块级元素的，当插入块级元素时（如 `p` 中插入 `div `）会产生两个匿名块与 `div` 分隔开，即产生两个 `IFC` ，每个 `IFC` 对外表现为块级元素，与 `div` 垂直排列。用处？- 水平居中：当一个块要在环境中水平居中时，设置其为 `inline-block` 则会在外层产生`IFC`，通过 `text-align` 则可以使其水平居中。- 垂直居中：创建一个 `IFC`，用其中一个元素撑开父元素的高度，然后设置其 `vertical-align`: `middle`，其他行内元素则可以在此父元素下垂直居中&gt; - **GFC**：网格布局格式化上下文（`display: grid`）&gt; - **FFC**：自适应格式化上下文（`display: flex`）### BFC 什么是 BFCBFC（Block Formatting Context）格式化上下文，是 Web 页面中盒模型布局的 CSS 渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。形成 BFC 的条件- 浮动元素，float 除 none 以外的值- 定位元素，position（absolute，fixed）- display 为以下其中之一的值 inline-block，table-cell，table-caption- overflow 除了 visible 以外的值（hidden，auto，scroll）BFC 的特性- 内部的 Box 会在垂直方向上一个接一个的放置。- 垂直方向上的距离由 margin 决定- bfc 的区域不会与 float 的元素区域重叠。- 计算 bfc 的高度时，浮动元素也参与计算- bfc 就是页面上的一个独立容器，容器里面的子元素不会影响外面元素。### 对BFC规范(块级格式化上下文：block formatting context)的理解？- 一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型- 不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响### 谈一谈你对CSS盒模型的认识及BFC&gt; 专业的面试，一定会问 `CSS` 盒模型。对于这个题目，我们要回答一下几个方面：1. 基本概念：`content`、`padding`、`margin`2. 标准盒模型、`IE`盒模型的区别。不要漏说了`IE`盒模型，通过这个问题，可以筛选一部分人3. `CSS`如何设置这两种模型（即：如何设置某个盒子为其中一个模型）？如果回答了上面的第二条，还会继续追问这一条。4. `JS`如何设置、获取盒模型对应的宽和高？这一步，已经有很多人答不上来了。5. 实例题：根据盒模型解释**边距重叠**。&gt; 前四个方面是逐渐递增，第五个方面，却鲜有人知。6. `BFC`（边距重叠解决方案）或`IFC`。&gt; 如果能回答第五条，就会引出第六条。`BFC`是面试频率较高的。**总结**：以上几点，从上到下，知识点逐渐递增，知识面从理论、`CSS`、`JS`，又回到`CSS`理论接下来，我们把上面的六条，依次讲解。### 标准盒模型和IE盒子模型标准盒子模型：![](http://img.smyhvae.com/2015-10-03-css-27.jpg)`IE`盒子模型：![](http://img.smyhvae.com/2015-10-03-css-30.jpg)上图显示：&gt; 在 `CSS` 盒子模型 (`Box Model`) 规定了元素处理元素的几种方式：- `width`和`height`：**内容**的宽度、高度（不是盒子的宽度、高度）。- `padding`：内边距。- `border`：边框。- `margin`：外边距。&gt; `CSS`盒模型和`IE`盒模型的区别：- 在**标准盒子模型**中，**width 和 height 指的是内容区域**的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。- **IE盒子模型**中，**width 和 height 指的是内容区域+border+padding**的宽度和高度。**CSS如何设置这两种模型**代码如下：```javascript/* 设置当前盒子为 标准盒模型（默认） */box-sizing: content-box;/* 设置当前盒子为 IE盒模型 */box-sizing: border-box; 备注：盒子默认为标准盒模型。 JS如何设置、获取盒模型对应的宽和高 方式一：通过DOM节点的 style 样式获取 1element.style.width/height; 缺点：通过这种方式，只能获取行内样式，不能获取内嵌的样式和外链的样式。 这种方式有局限性，但应该了解。 方式二（通用型） 1window.getComputedStyle(element).width/height; 方式二能兼容 Chrome、火狐。是通用型方式。 方式三（IE独有的） 1element.currentStyle.width/height; 和方式二相同，但这种方式只有IE独有。获取到的即时运行完之后的宽高（三种css样式都可以获取）。 方式四 1element.getBoundingClientRect().width/height; 此 api 的作用是：获取一个元素的绝对位置。绝对位置是视窗 viewport 左上角的绝对位置。此 api 可以拿到四个属性：left、top、width、height。 总结： 上面的四种方式，要求能说出来区别，以及哪个的通用型更强。 margin塌陷/margin重叠 标准文档流中，竖直方向的margin不叠加，只取较大的值作为margin(水平方向的margin是可以叠加的，即水平方向没有塌陷现象)。 PS：如果不在标准流，比如盒子都浮动了，那么两个盒子之间是没有margin重叠的现象的。 我们来看几个例子。 兄弟元素之间 如下图所示： 子元素和父元素之间 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .father &#123; background: green; &#125; /* 给儿子设置margin-top为10像素 */ .son &#123; height: 100px; margin-top: 10px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"father\"&gt; &lt;div class=\"son\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上面的代码中，儿子的height是 100px，magin-top 是10px。注意，此时父亲的 height 是100，而不是110。因为儿子和父亲在竖直方向上，共一个margin。 儿子这个盒子： 父亲这个盒子： 上方代码中，如果我们给父亲设置一个属性：overflow: hidden，就可以避免这个问题，此时父亲的高度是110px，这个用到的就是BFC（下一段讲解）。 善于使用父亲的padding，而不是儿子的margin 其实，这一小段讲的内容与上一小段相同，都是讲父子之间的margin重叠。 我们来看一个奇怪的现象。现在有下面这样一个结构：（div中放一个p） 123&lt;div&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 上面的结构中，我们尝试通过给儿子p一个margin-top:50px;的属性，让其与父亲保持50px的上边距。结果却看到了下面的奇怪的现象： 此时我们给父亲div加一个border属性，就正常了： 如果父亲没有border，那么儿子的margin实际上踹的是“流”，踹的是这“行”。所以，父亲整体也掉下来了。 margin这个属性，本质上描述的是兄弟和兄弟之间的距离； 最好不要用这个marign表达父子之间的距离。 所以，如果要表达父子之间的距离，我们一定要善于使用父亲的padding，而不是儿子的`margin。 BFC（边距重叠解决方案） BFC（Block Formatting Context）：块级格式化上下文。你可以把它理解成一个独立的区域。 另外还有个概念叫IFC。不过，BFC问得更多。 BFC 的原理/BFC的布局规则【非常重要】 BFC 的原理，其实也就是 BFC 的渲染规则（能说出以下四点就够了）。包括： BFC 内部的子元素，在垂直方向，边距会发生重叠。 BFC在页面中是独立的容器，外面的元素不会影响里面的元素，反之亦然。（稍后看举例1） BFC区域不与旁边的float box区域重叠。（可以用来清除浮动带来的影响）。（稍后看举例2） 计算BFC的高度时，浮动的子元素也参与计算。（稍后看举例3） 如何生成BFC 有以下几种方法： 方法1：overflow: 不为visible，可以让属性是 hidden、auto。【最常用】 方法2：浮动中：float的属性值不为none。意思是，只要设置了浮动，当前元素就创建了BFC。 方法3：定位中：只要posiiton的值不是 static或者是relative即可，可以是absolute或fixed，也就生成了一个BFC。 方法4：display为inline-block, table-cell, table-caption, flex, inline-flex BFC 的应用 举例1：解决 margin 重叠 当父元素和子元素发生 margin 重叠时，解决办法：给子元素或父元素创建BFC。 比如说，针对下面这样一个 div 结构： 1234&lt;div class=\"father\"&gt; &lt;p class=\"son\"&gt; &lt;/p&gt;&lt;/div&gt; 上面的div结构中，如果父元素和子元素发生margin重叠，我们可以给子元素创建一个 BFC，就解决了： 1234&lt;div class=\"father\"&gt; &lt;p class=\"son\" style=\"overflow: hidden\"&gt; &lt;/p&gt;&lt;/div&gt; 因为第二条：BFC区域是一个独立的区域，不会影响外面的元素。 举例2：BFC区域不与float区域重叠： 针对下面这样一个div结构； 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father-layout &#123; background: pink; &#125; .father-layout .left &#123; float: left; width: 100px; height: 100px; background: green; &#125; .father-layout .right &#123; height: 150px; /*右侧标准流里的元素，比左侧浮动的元素要高*/ background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;section class=\"father-layout\"&gt; &lt;div class=\"left\"&gt; 左侧，生命壹号 &lt;/div&gt; &lt;div class=\"right\"&gt; 右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae， &lt;/div&gt;&lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 上图中，由于右侧标准流里的元素，比左侧浮动的元素要高，导致右侧有一部分会跑到左边的下面去。 如果要解决这个问题，可以将右侧的元素创建BFC，因为第三条：BFC区域不与float box区域重叠。解决办法如下：（将right区域添加overflow属性） 123&lt;div class=\"right\" style=\"overflow: hidden\"&gt; 右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，&lt;/div&gt; 上图表明，解决之后，father-layout的背景色显现出来了，说明问题解决了。 举例3：清除浮动 现在有下面这样的结构： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father &#123; background: pink; &#125; .son &#123; float: left; background: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;section class=\"father\"&gt; &lt;div class=\"son\"&gt; 生命壹号 &lt;/div&gt;&lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 上面的代码中，儿子浮动了，但由于父亲没有设置高度，导致看不到父亲的背景色（此时父亲的高度为0）。正所谓有高度的盒子，才能关住浮动。 如果想要清除浮动带来的影响，方法一是给父亲设置高度，然后采用隔墙法。方法二是 BFC：给父亲增加 overflow=hidden属性即可， 增加之后，效果如下： 为什么父元素成为BFC之后，就有了高度呢？这就回到了第四条：计算BFC的高度时，浮动元素也参与计算。意思是，在计算BFC的高度时，子元素的float box也会参与计算 CSS 隐藏元素的几种方法（至少说出三种）Opacity:元素本身依然占据它自己的位置并对网页的布局起作用。它也将响应用户交互; Visibility:与 opacity 唯一不同的是它不会响应任何用户交互。此外，元素在读屏软件中也会被隐藏; Display:display 设为 none 任何对该元素直接打用户交互操作都不可能生效。此外，读屏软件也不会读到元素的内容。这种方式产生的效果就像元素完全不存在; Position:不会影响布局，能让元素保持可以操作; Clip-path:clip-path 属性还没有在 IE 或者 Edge 下被完全支持。如果要在你的 clip-path 中使用外部的 SVG 文件，浏览器支持度还要低; 页面导入样式时，使用 link 和@import 有什么区别？ Link 属于 html 标签，而@import 是 CSS 中提供的 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载 @import 只在IE5以上才能识别，而link是XHTML标签，无兼容问题 Link 引入样式的权重大于@import 的引用（@import 是将引用的样式导入到当前的页面中） Link支持使用 javascript 改变样式，@import不可 CSS引入的方式有哪些?答：内联 内嵌 外链 导入 CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？ id选择器（ # myid） 类选择器（.myclassname） 标签选择器（div, h1, p） 相邻选择器（h1 + p） 子选择器（ul &lt; li） 后代选择器（li a） 通配符选择器（ * ） 属性选择器（a[rel = “external”]） 伪类选择器（a: hover, li: nth - child） 可继承： font-size font-family color, UL LI DL DD DT; 不可继承 ：border padding margin width height ; 优先级就近原则，样式定义最近者为准; 载入样式以最后载入的定位为准; 优先级为: !important &gt; id &gt; class &gt; tag important 比内联优先级高 CSS3新增伪类举例p:first-of-type 选择属于其父元素的首个元素的每个元素。 p:last-of-type 选择属于其父元素的最后元素的每个元素。 p:only-of-type 选择属于其父元素唯一的元素的每个元素。 p:only-child 选择属于其父元素的唯一子元素的每个元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个元素。 :enabled、:disabled 控制表单控件的禁用状态。 :checked，单选框或复选框被选中。 伪元素和伪类的区别？1、伪元素使用 2 个冒号，常见的有：::before，::after，::first-line，::first-letter，::selection、::placeholder 等； 1伪类使用1个冒号，常见的有：:hover，:link，:active，:target，:not()，:focus等。 2、伪元素添加了一个页面中没有的元素（只是从视觉效果上添加了，不是在文档树中添加）； 1伪类是给页面中已经存在的元素添加一个类。 解析： CSS 伪元素是添加到选择器的关键字，去选择元素的特定部分。它们可以用于装饰（:first-line，:first-letter）或将元素添加到标记中（与 content:…组合），而不必修改标记（:before，:after）。 :first-line和:first-letter可以用来修饰文字。 上面提到的.clearfix方法中，使用clear: both来添加不占空间的元素。 使用:before和after展示提示中的三角箭头。鼓励关注点分离，因为三角被视为样式的一部分，而不是真正的 DOM。如果不使用额外的 HTML 元素，只用 CSS 样式绘制三角形是不太可能的。 参考 CSS优先级算法如何计算？ 优先级就近原则，同权重情况下样式定义最近者为准 载入样式以最后载入的定位为准 优先级为: !important &gt; id &gt; class &gt; tag important 比 内联优先级高 同权重: 内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。 !important &gt; id &gt; class &gt; tag important 比 内联优先级高 CSS如何计算选择器优先？ 相同权重，定义最近者为准：行内样式 &gt; 内部样式 &gt; 外部样式 含外部载入样式时，后载入样式覆盖其前面的载入的样式和内部样式 选择器优先级: 行内样式[1000] &gt; id[100] &gt; class[10] &gt; Tag[1] 在同一组属性设置中，!important 优先级最高，高于行内样式 CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？CSS3 新增伪类有那些？ 1.id选择器（ # myid） 2.类选择器（.myclassname） 3.标签选择器（div, h1, p） 4.相邻选择器（h1 + p） 5.子选择器（ul &lt; li） 6.后代选择器（li a） 7.通配符选择器（ * ） 8.属性选择器（a[rel = &quot;external&quot;]） 9.伪类选择器（a: hover, li: nth - child） * 可继承： font-size font-family color, UL LI DL DD DT; * 不可继承 ：border padding margin width height ; * 优先级就近原则，样式定义最近者为准; * 载入样式以最后载入的定位为准;优先级为: !important &gt; id &gt; class &gt; tag important 比 内联优先级高CSS3新增伪类举例： 12345678910111213p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。 :enabled、:disabled 控制表单控件的禁用状态。 :checked，单选框或复选框被选中。 CSS 选择器的优先级是如何计算的？浏览器通过优先级规则，判断元素展示哪些样式。优先级通过 4 个维度指标确定，我们假定以a、b、c、d命名，分别代表以下含义： a表示是否使用内联样式（inline style）。如果使用，a为 1，否则为 0。 b表示 ID 选择器的数量。 c表示类选择器、属性选择器和伪类选择器数量之和。 d表示标签（类型）选择器和伪元素选择器之和。 优先级的结果并非通过以上四个值生成一个得分，而是每个值分开比较。a、b、c、d权重从左到右，依次减小。判断优先级时，从左到右，一一比较，直到比较出最大值，即可停止。所以，如果b的值不同，那么c和d不管多大，都不会对结果产生影响。比如0，1，0，0的优先级高于0，0，10，10。 当出现优先级相等的情况时，最晚出现的样式规则会被采纳。如果你在样式表里写了相同的规则（无论是在该文件内部还是其它样式文件中），那么最后出现的（在文件底部的）样式优先级更高，因此会被采纳。 在写样式时，我会使用较低的优先级，这样这些样式可以轻易地覆盖掉。尤其对写 UI 组件的时候更为重要，这样使用者就不需要通过非常复杂的优先级规则或使用!important的方式，去覆盖组件的样式了。 解析：参考、参考 行内元素和块级元素的具体区别？行内元素的padding和margin可设置吗？ 块级元素(block)特性： 总是独占一行，表现为另起一行开始，而且其后的元素也必须另起一行显示; 宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可控制; 内联元素(inline)特性： 和相邻的内联元素在同一行; 宽度(width)、高度(height)、内边距的 top/bottom(padding-top/padding-bottom)和外边距的 top/bottom(margin-top/margin-bottom)都不可改变（也就是 padding 和 margin 的 left 和 right 是可以设置的），就是里面文字或图片的大小。 块级元素：div、p、h1~h6、hr、ul、ol、li、dl、dt、dd、form、table、tbody、tfoot、thead、（header、article、footer、nav、section）内联元素：span、a、b、br、em、strong、img、input、abbr、button、label、textarea（拓展：浏览器默认的inline-block元素）、、、、 12345678附：行内块元素的兼容性使用？ div｛ display:inline-blcok; //触发ie的hasLayout display:inline; ｝ div｛ display：inline；*zoom：1; ｝ 外边距重叠是什么？导致的结果是什么？在css当中两个（普通文档流）竖直方向上的毗邻（没有被非空内容、padding、border 或 clear 分隔开）盒子的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，所结合而成的外边距成为折叠外边距。注意：父块级盒子与子块级盒子在垂直方向上毗邻也会导致外边距重叠； 123456789计算规则： 两个竖直方向上相邻的外边距都是正数，折叠结果是他们两者之间较大的值。 两个竖直方向上相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 两个竖直方向上相邻的外边距一正一负时，折叠结果是两者的相加的和；(附：如何使元素上下margin不折叠？) 1、浮动、inline-block、绝对定位； 2、创建块级格式化上下文（BFC）的元素，不和它的子元素发生margin折叠； (详细链接：https://www.zhihu.com/question/19823139) css中文字的水平垂直居中？line-height 设置为盒子高度text-align center; box-sizing 常用的属性？分别有什么作用？box-sizing：content-box|border-box|inherit；content-box：宽、高应用到元素的内容框。在高、宽之外绘制元素的内边距和边框（默认效果）；border-box：元素的任何内边距和边框都在已设定的宽度和高度内进行绘制。此时的宽高=content+padding+border； css 中可以让文字在垂直和水平方向上重叠的两个属性是什么？垂直方向：line-height 水平方向：letter-spacing letter-spacing 的妙用知道有哪些么？可以用于消除 inline-block 元素间的换行符空格间隙问题。 px 和em的区别px 和 em 都是长度单位 px 的值是固定的，指定是多少就是多少，计算比较容易。 em 得值不是固定的，并且 em 会继承父级元素的字体大小。 浏览器的默认字体高都是 16px。所以未经调整的浏览器都符合: 1em=16px。那么 12px=0.75em, 10px=0.625em。 用纯 CSS 创建一个三角形的原理是什么？12345678span &#123; width: 0; height: 0; border-top: 40px solid transparent; border-left: 40px solid transparent; border-right: 40px solid transparent; border-bottom: 40px solid #ff0000;&#125; css_001 Sass、LESS 是什么？大家为什么要使用他们？他们是 CSS 预处理器。他是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。 例如 Less 是一种动态样式语言. 将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数. LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可一在服务端运行 (借助 Node.js)。 为什么要使用它们？ 结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。这个不用多说，封装对浏览器语法差异的重复处理，减少无意义的机械劳动。 可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。 移动端 1px 问题的解决办法推荐解决方法：媒体查询 + transfrom 1234567891011121314/* 2倍屏 */@media only screen and (-webkit-min-device-pixel-ratio: 2.0) &#123; .border-bottom::after &#123; -webkit-transform: scaleY(0.5); transform: scaleY(0.5); &#125;&#125;/* 3倍屏 */@media only screen and (-webkit-min-device-pixel-ratio: 3.0) &#123; .border-bottom::after &#123; -webkit-transform: scaleY(0.33); transform: scaleY(0.33); &#125;&#125; 其他解决方案参考 哪些 css 属性可以继承？可继承： font-size font-family color, ul li dl dd dt; 不可继承 ：border padding margin width height ; li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？行框的排列会受到中间空白（回车\\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔 解决办法：在ul设置设置font-size=0,在li上设置需要的文字大小（把字符大小设为0），就没有空格了 ### 浏览器的默认行为是把 inline 元素间的空白字符（空格换行 tab）渲染成一个空格，也就是我们上面的代码换行后会产生换行字符，而它会变成一个空格，当然空格就占用一个字符的宽度。 解决方案： 方法一：既然是因为&lt;li&gt;换行导致的，那就可以将&lt;li&gt;代码全部写在一排，如下 123456789&lt;div class=\"wrap\"&gt; &lt;h3&gt;li标签空白测试&lt;/h3&gt; &lt;ul&gt; &lt;li class=\"part1\"&gt;&lt;/li&gt; &lt;li class=\"part2\"&gt;&lt;/li&gt; &lt;li class=\"part3\"&gt;&lt;/li&gt; &lt;li class=\"part4\"&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 方法二：我们为了代码美观以及方便修改，很多时候我们不可能将&lt;li&gt;全部写在一排，那怎么办？既然是空格占一个字符的宽度，那我们索性就将&lt;ul&gt;内的字符尺寸直接设为 0，将下面样式放入样式表，问题解决。 123.wrap ul &#123; font-size: 0px;&#125; 但随着而来的就是&lt;ul&gt;中的其他文字就不见了，因为其尺寸被设为 0px 了，我们只好将他们重新设定字符尺寸。方法三：本来以为方法二能够完全解决问题，但经测试，将 li 父级标签字符设置为 0 在 Safari 浏览器依然出现间隔空白；既然设置字符大小为 0 不行，那咱就将间隔消除了，将下面代码替换方法二的代码，目前测试完美解决。同样随来而来的问题是 li 内的字符间隔也被设置了，我们需要将 li 内的字符间隔设为默认。 123.wrap ul &#123; letter-spacing: -5px;&#125; 之后记得设置 li 内字符间隔 123.wrap ul li &#123; letter-spacing: normal;&#125; png、jpg、gif 这些图片格式解释一下，分别什么时候用？，webp 呢gif 图形交换格式，索引颜色格式，颜色少的情况下，产生的文件极小，支持背景透明，动画，图形渐进，无损压缩（适合线条，图标等），缺点只有 256 种颜色 jpg 支持上百万种颜色，有损压缩，压缩比可达 180：1，而且质量受损不明显，不支持图形渐进与背景透明，不支持动画 png 为替代 gif 产生的，位图文件，支持透明，半透明，不透明。不支持动画，无损图像格式。Png8 简单说是静态 gif，也只有 256 色，png24 不透明，但不止 256 色。 webp 谷歌开发的旨在加快图片加载速度的图片格式，图片压缩体积是 jpeg 的 2/3，有损压缩。高版本的 W3C 浏览器才支持，google39+，safari7+ style 标签写在 body 后与 body 前有什么区别？从上向下加载，加载顺序不同 超链接访问过后 hover 样式就不出现的问题是什么？如何解决？被点击访问过的超链接样式不在具有 hover 和 active 了,解决方法是改变 CSS 属性的排列顺序: L-V-H-A（link,visited,hover,active） 重置（resetting）CSS 和 标准化（normalizing）CSS 的区别是什么？你会选择哪种方式，为什么？ 重置（Resetting）： 重置意味着除去所有的浏览器默认样式。对于页面所有的元素，像margin、padding、font-size这些样式全部置成一样。你将必须重新定义各种元素的样式。 标准化（Normalizing）： 标准化没有去掉所有的默认样式，而是保留了有用的一部分，同时还纠正了一些常见错误。 当需要实现非常个性化的网页设计时，我会选择重置的方式，因为我要写很多自定义的样式以满足设计需求，这时候就不再需要标准化的默认样式了。 解析：参考 什么是 Fouc(文档样式短暂失效Flash of Unstyled Content)？在引用 css 的过程中，如果方法不当或者位置引用不对，会导致某些页面在 windows 下的 ie 出现一些奇怪的现象，以无样式显示页面内容的瞬间闪烁，这种现象称之为文档样式短暂失效，简称 FOCU。 原因： 当样式表晚于结构性html加载时，加载到此样式表时，页面将停止之前的渲染。等待此样式表被下载和解析后，再重新渲染页面，期间导致短暂的花屏现象。 使用 import 方法导入样式表 将样式表放在页面底部 有几个样式表，放在 html 结构的不同位置。 其实原理很清楚：当样式表晚于结构性 html 加载，当加载到此样式表时，页面将停止之前的渲染。此样式表被下载和解析后，将重新渲染页面，也就出现了短暂的花屏现象。 解决方法：使用 link 标签将样式表放在文档 head 中。 PNG,GIF,JPG 的区别及如何选GIF： 1：256 色 2： 无损，编辑 保存时候，不会损失。 3：支持简单动画。 4：支持 boolean 透明，也就是要么完全透明，要么不透明 JPEG： 1：millions of colors 2： 有损压缩， 意味着每次编辑都会失去质量。 3：不支持透明。 4：适合照片，实际上很多相机使用的都是这个格式。 PNG： 1：无损，其实 PNG 有好几种格式的，一般分为两类：PNG8 和 truecolor PNGs； 与 GIF 相比： 它通常会产生较小的文件大小。 它支持阿尔法（变量）透明度。 无动画支持 与 JPEG 相比： 文件更大 无损 因此可以作为 JPEG 图片中间编辑的中转格式。 结论： JPEG 适合照片 GIF 适合动画 PNG 适合其他任何种类——图表，buttons，背景，图表等等。 参考 position 的值， relative 和 absolute 分别是相对于谁进行定位的？ absolute :生成绝对定位的元素， 相对于最近一级的 定位不是 static 的父元素来进行定位。 fixed （老 IE 不支持）生成绝对定位的元素，通常相对于浏览器窗口或 frame 进行定位。 relative 生成相对定位的元素，相对于其在普通流中的位置进行定位。 static 默认值。没有定位，元素出现在正常的流中 sticky 生成粘性定位的元素，容器的位置根据正常文档流计算得出 对偏移、卷曲、可视的理解偏移offsetWidth width + padding + borderoffsetHeight height + padding + borderoffsetLeftoffsetTopoffsetParent注意：没有offsetRight和offsetBottom 卷曲scrollWidth width + paddingscrollHeight 当内部的内容溢出盒子的时候， 顶边框的底部，计算到内容的底部；如果内容没有溢出盒子，计算方式为盒子内部的真实高度（边框到边框）scrollLeft 这个scroll系列属性不是只读的scrollTopscroll() 此函数可以获取卷曲的高度和卷曲的宽度 123456function myScroll() &#123; return &#123; top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0, left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0 &#125;;&#125; 滚动滚动条的时候触发事件box（window）.onscroll = function () {} 可视clientWidth 获取的是元素内部的真实宽度 width + paddingclientHeight 边框之间的高度clientLeft 相当于左边框的宽度 如果元素包含了滚动条，并且滚动条显示在元素的左侧。这时，clientLeft属性会包含滚动条的宽度17pxclientTop 相当于顶边框的宽度client() 此函数可以获取浏览器可视区域的宽高 123456function myClient() &#123; return &#123; wid: window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth || 0, heit: window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight || 0 &#125;;&#125; @offsetHeight和style.height的区别 demo.style.height只能获取行内样式，如果样式写到了其他地方，甚至根本就没写，便无法获取style.height是字符串（而且带单位），offsetHeight是数值demo.style.height可以设置行内样式，offsetHeight是只读属性因此，一般用demo.offsetHeight来获取某元素的真实宽度/高度，用style.height来设置宽度/高度 @offsetLeft和style.left的区别 一、style.left只能获取行内样式二、offsetLeft只读，style.left可读可写三、offsetLeft是数值，style.left是字符串并且有单位px四、如果没有加定位，style.left获取的数值可能是无效的五、最大区别在于offsetLeft以border左上角为基准，style.left以margin左上角为基准 @scrollHeight和scrollWidth 标签内部实际内容的高度/宽度不计算边框，如果内容不超出盒子，值为盒子的宽高（不带边框）如果内容超出了盒子，就是从顶部或左部边框内侧一直到内容a的最外部分 @scrollTop和scrollLeft 被卷去部分的 顶部/左侧 到可视区域 顶部/左侧 的距离 解析： offset大全 scroll大全 三个height比较 style.left和offsetLeft client大全 简述一下 Sass、Less，且说明区别？他们是动态的样式语言，是 CSS 预处理器,CSS 上的一种抽象层。他们是一种特殊的语法/语言而编译成 CSS。 变量符不一样，less 是@，而 Sass 是$; Sass 支持条件语句，可以使用 if{}else{},for{}循环等等。而 Less 不支持; Sass 是基于 Ruby 的，是在服务端处理的，而 Less 是需要引入 less.js 来处理 Less 代码输出 Css 到浏览器 Css Sprites概念： 将多个小图片拼接到一个图片中。通过 background-position 和元素尺寸调节需要显示的背景图案。 介绍：Css Sprites（雪碧图或 css 精灵），是网页图片处理的一种方式，它允许你将一个页面涉及到的所有零星图片都包含到一张大图中去，这样一来，当访问该页面时，载入的图片就不会像以前那样一幅一幅地慢慢显示出来了。 原理：将许多的小图片整合到一张大图片中，利用 css 中的 background-image 属性，background-position 属性定位某个图片位置，来达到在大图片中引用某个部位的小图片的效果。 优点：减少网页的 http 请求，提升网页加载速度。增加图片信息重复度，提高压缩比，减少图片大小。合并多张小图片成大图，能减少字节总数（大图大小&lt;=多张小图大小） 缺点：前期需要处理图片将小图合并，多些许工程量，图片合并麻烦。对于需要经常改变的图片维护起来麻烦，修改一个图片可能需要从新布局整个图片，样式。 base64介绍：base64 是网络上最常见的用于传输 8Bit 字节代码的编码方式之一，要求把每三个 8Bit 的字节转换为四个 6Bit 的字节，Base64 是网络上最常见的用于传输 8Bit 字节代码的编码方式之一。 通俗点讲：将资源原本二进制形式转成以 64 个字符基本单位，所组成的一串字符串。一张图片转成 base64 编码，图片直接以 base64 形式嵌入文件中（很长没截完）： 生成 base64 编码：图片生成 base64 可以用一些工具，如在线工具，但在项目中这样一个图片这样生成是挺繁琐。特别说下，webpack 中的 url-loader 可以完成这个工作，可以对限制大小的图片进行 base64 的转换，非常方便。 优点：base64 的图片会随着 html 或者 css 一起下载到浏览器,减少了请求.可避免跨域问题 缺点：老东西（低版本）的 IE 浏览器不兼容。体积会比原来的图片大一点。css 中过多使用 base64 图片会使得 css 过大，不利于 css 的加载。 适用场景：应用于小的图片几 k 的，太大的图片会转换后的大小太大，得不偿失。用于一些 css sprites 不利处理的小图片，如一些可以通过 background-repeat 平铺来做成背景的图片 解析：参考 如果设计中使用了非标准的字体，你该如何去实现？使用@font-face并为不同的font-weight定义font-family。 请阐述Float定位的工作原理。浮动（float）是 CSS 定位属性。浮动元素从网页的正常流动中移出，但是保持了部分的流动性，会影响其他元素的定位（比如文字会围绕着浮动元素）。这一点与绝对定位不同，绝对定位的元素完全从文档流中脱离。 CSS 的clear属性通过使用left、right、both，让该元素向下移动（清除浮动）到浮动元素下面。 如果父元素只包含浮动元素，那么该父元素的高度将塌缩为 0。我们可以通过清除（clear）从浮动元素后到父元素关闭前之间的浮动来修复这个问题。 有一种 hack 的方法，是自定义一个.clearfix类，利用伪元素选择器::after清除浮动。另外还有一些方法，比如添加空的&lt;div&gt;&lt;/div&gt;和设置浮动元素父元素的overflow属性。与这些方法不同的是，clearfix方法，只需要给父元素添加一个类，定义如下： 12345.clearfix::after &#123; content: \"\"; display: block; clear: both;&#125; 值得一提的是，把父元素属性设置为overflow: auto或overflow: hidden，会使其内部的子元素形成块格式化上下文（Block Formatting Context），并且父元素会扩张自己，使其能够包围它的子元素。 解析：参考 请阐述z-index属性，并说明如何形成层叠上下文（stacking context）CSS 中的z-index属性控制重叠元素的垂直叠加顺序。z-index只能影响position值不是static的元素。 没有定义z-index的值时，元素按照它们出现在 DOM 中的顺序堆叠（层级越低，出现位置越靠上）。非静态定位的元素（及其子元素）将始终覆盖静态定位（static）的元素，而不管 HTML 层次结构如何。 层叠上下文是包含一组图层的元素。 在一组层叠上下文中，其子元素的z-index值是相对于该父元素而不是 document root 设置的。每个层叠上下文完全独立于它的兄弟元素。如果元素 B 位于元素 A 之上，则即使元素 A 的子元素 C 具有比元素 B 更高的z-index值，元素 C 也永远不会在元素 B 之上. 每个层叠上下文是自包含的：当元素的内容发生层叠后，整个该元素将会在父层叠上下文中按顺序进行层叠。少数 CSS 属性会触发一个新的层叠上下文，例如opacity小于 1，filter不是none，transform不是none。 解析：参考 1、参考 2、参考 3 如何解决不同浏览器的样式兼容性问题？ 在确定问题原因和有问题的浏览器后，使用单独的样式表，仅供出现问题的浏览器加载。这种方法需要使用服务器端渲染。 使用已经处理好此类问题的库，比如 Bootstrap。 使用 autoprefixer 自动生成 CSS 属性前缀。 使用 Reset CSS 或 Normalize.css。 如何为功能受限的浏览器提供页面？ 使用什么样的技术和流程？ 优雅的降级：为现代浏览器构建应用，同时确保它在旧版浏览器中正常运行。 Progressive enhancement - The practice of building an application for a base level of user experience, but adding functional enhancements when a browser supports it. 渐进式增强：构建基于用户体验的应用，但在浏览器支持时添加新增功能。 利用 caniuse.com 检查特性支持。 使用 autoprefixer 自动生成 CSS 属性前缀。 使用 Modernizr进行特性检测。 有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器）？这些方法与可访问性（a11y）有关。 visibility: hidden：元素仍然在页面流中，并占用空间。 width: 0; height: 0：使元素不占用屏幕上的任何空间，导致不显示它。 position: absolute; left: -99999px： 将它置于屏幕之外。 text-indent: -9999px：这只适用于block元素中的文本。 Metadata： 例如通过使用 Schema.org，RDF 和 JSON-LD。 WAI-ARIA：如何增加网页可访问性的 W3C 技术规范。 即使 WAI-ARIA 是理想的解决方案，我也会采用绝对定位方法，因为它具有最少的注意事项，适用于大多数元素，而且使用起来非常简单。 解析：参考 1、参考 2、参考 3 除了screen，你还能说出一个 @media 属性的例子吗？ all适用于所有设备。 print为了加载合适的文档到当前使用的可视窗口. 需要提前咨询 paged media（媒体屏幕尺寸）, 以满足个别设备网页尺寸不匹配等问题。 screen主要适用于彩色的电脑屏幕 speech 解析：speech 这个合成器. 注意: CSS2 已经有一个相似的媒体类型叫 aural.参考 编写高效的 CSS 应该注意什么？首先，浏览器从最右边的选择器，即关键选择器（key selector），向左依次匹配。根据关键选择器，浏览器从 DOM 中筛选出元素，然后向上遍历被选元素的父元素，判断是否匹配。选择器匹配语句链越短，浏览器的匹配速度越快。避免使用标签和通用选择器作为关键选择器，因为它们会匹配大量的元素，浏览器必须要进行大量的工作，去判断这些元素的父元素们是否匹配。 BEM (Block Element Modifier) methodology recommends that everything has a single class, and, where you need hierarchy, that gets baked into the name of the class as well, this naturally makes the selector efficient and easy to override.BEM (Block Element Modifier)原则上建议为独立的 CSS 类命名，并且在需要层级关系时，将关系也体现在命名中，这自然会使选择器高效且易于覆盖。 搞清楚哪些 CSS 属性会触发重新布局（reflow）、重绘（repaint）和合成（compositing）。在写样式时，避免触发重新布局的可能。 解析：参考 1、参考 2 使用 CSS 预处理的优缺点分别是什么？优点： 提高 CSS 可维护性。 易于编写嵌套选择器。 引入变量，增添主题功能。可以在不同的项目中共享主题文件。 通过混合（Mixins）生成重复的 CSS。 Splitting your code into multiple files. CSS files can be split up too but doing so will require a HTTP request to download each CSS file. 将代码分割成多个文件。不进行预处理的 CSS，虽然也可以分割成多个文件，但需要建立多个 HTTP 请求加载这些文件。 缺点： 需要预处理工具。 重新编译的时间可能会很慢。 对于你使用过的 CSS 预处理，说说喜欢和不喜欢的地方？喜欢： 绝大部分优点上题以及提过。 Less 用 JavaScript 实现，与 NodeJS 高度结合。 Dislikes: 我通过node-sass使用 Sass，它用 C ++ 编写的 LibSass 绑定。在 Node 版本切换时，我必须经常重新编译。 Less 中，变量名称以@作为前缀，容易与 CSS 关键字混淆，如@media、@import和@font-face。 解释浏览器如何确定哪些元素与 CSS 选择器匹配。这部分与上面关于编写高效的 CSS 有关。浏览器从最右边的选择器（关键选择器）根据关键选择器，浏览器从 DOM 中筛选出元素，然后向上遍历被选元素的父元素，判断是否匹配。选择器匹配语句链越短，浏览器的匹配速度越快。 例如，对于形如p span的选择器，浏览器首先找到所有&lt;span&gt;元素，并遍历它的父元素直到根元素以找到&lt;p&gt;元素。对于特定的&lt;span&gt;，只要找到一个&lt;p&gt;，就知道’`已经匹配并停止继续匹配。 解析：参考 说说你对盒模型的理解，以及如何告知浏览器使用不同的盒模型渲染布局。CSS 盒模型描述了以文档树中的元素而生成的矩形框，并根据排版模式进行布局。每个盒子都有一个内容区域（例如文本，图像等）以及周围可选的padding、border和margin区域。 CSS 盒模型负责计算： 块级元素占用多少空间。 边框是否重叠，边距是否合并。 盒子的尺寸。 盒模型有以下规则： 块级元素的大小由width、height、padding、border和margin决定。 如果没有指定height，则块级元素的高度等于其包含子元素的内容高度加上padding（除非有浮动元素，请参阅下文）。 如果没有指定width，则非浮动块级元素的宽度等于其父元素的宽度减去父元素的padding。 元素的height是由内容的height来计算的。 元素的width是由内容的width来计算的。 默认情况下，padding和border不是元素width和height的组成部分。 解析：参考 * { box-sizing: border-box; }会产生怎样的效果？ 元素默认应用了box-sizing: content-box，元素的宽高只会决定内容（content）的大小。 box-sizing: border-box改变计算元素width和height的方式，border和padding的大小也将计算在内。 元素的height = 内容（content）的高度 + 垂直方向的padding + 垂直方向border的宽度 元素的width = 内容（content）的宽度 + 水平方向的padding + 水平方向border的宽度 relative、fixed、absolute和static四种定位有什么区别？经过定位的元素，其position属性值必然是relative、absolute、fixed或static。 static：默认定位属性值。该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。 relative：该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。 absolute：不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。 fixed：不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。 static：盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 table 时），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。position: static 对 table 元素的效果与 position: relative 相同。 解析：参考 你使用过哪些现有的 CSS 框架？你是如何改进它们的？ Bootstrap： 更新周期缓慢。Bootstrap 4 已经处于 alpha 版本将近两年了。添加了在页面中广泛使用的微调按钮组件。 Semantic UI：源代码结构使得自定义主题很难理解。非常规主题系统的使用体验很差。外部库的路径需要硬编码（hard code）配置。变量重新赋值没有 Bootstrap 设计得好。 Bulma： 需要很多非语义的类和标记，显得很多余。不向后兼容，以至于升级版本后，会破坏应用的正常运行。 你了解 CSS Flex 和 Grid 吗？lex 主要用于一维布局，而 Grid 则用于二维布局。 Flexflex 容器中存在两条轴， 横轴和纵轴， 容器中的每个单元称为 flex item。 在容器上可以设置 6 个属性： flex-direction flex-wrap flex-flow justify-content align-items align-content 注意：当设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效。 Flex 项目属性有六种属性可运用在 item 项目上: order flex-basis flex-grow flex-shrink flex align-self GridCSS 网格布局用于将页面分割成数个主要区域，或者用来定义组件内部元素间大小、位置和图层之间的关系。 像表格一样，网格布局让我们能够按行或列来对齐元素。 但是，使用 CSS 网格可能还是比 CSS 表格更容易布局。 例如，网格容器的子元素可以自己定位，以便它们像 CSS 定位的元素一样，真正的有重叠和层次。 响应式设计与自适应设计有何不同？响应式设计和自适应设计都以提高不同设备间的用户体验为目标，根据视窗大小、分辨率、使用环境和控制方式等参数进行优化调整。 响应式设计的适应性原则：网站应该凭借一份代码，在各种设备上都有良好的显示和使用效果。响应式网站通过使用媒体查询，自适应栅格和响应式图片，基于多种因素进行变化，创造出优良的用户体验。就像一个球通过膨胀和收缩，来适应不同大小的篮圈。 自适应设计更像是渐进式增强的现代解释。与响应式设计单一地去适配不同，自适应设计通过检测设备和其他特征，从早已定义好的一系列视窗大小和其他特性中，选出最恰当的功能和布局。与使用一个球去穿过各种的篮筐不同，自适应设计允许使用多个球，然后根据不同的篮筐大小，去选择最合适的一个。 解析：参考 1、参考 2、参考 3 你有没有使用过视网膜分辨率的图形？当中使用什么技术？我倾向于使用更高分辨率的图形（显示尺寸的两倍）来处理视网膜显示。更好的方法是使用媒体查询，像@media only screen and (min-device-pixel-ratio: 2) { ... }，然后改变background-image。 对于图标类的图形，我会尽可能使用 svg 和图标字体，因为它们在任何分辨率下，都能被渲染得十分清晰。 还有一种方法是，在检查了window.devicePixelRatio的值后，利用 JavaScript 将&lt;img&gt;的src属性修改，用更高分辨率的版本进行替换。 解析：参考 什么情况下，用translate()而不用绝对定位？什么时候，情况相反。translate()是transform的一个值。改变transform或opacity不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。而改变绝对定位会触发重新布局，进而触发重绘和复合。transform使浏览器为元素创建一个 GPU 图层，但改变绝对定位会使用到 CPU。 因此translate()更高效，可以缩短平滑动画的绘制时间。 当使用translate()时，元素仍然占据其原始空间（有点像position：relative），这与改变绝对定位不同。 解析：参考、参考、参考、参考 过渡与动画的区别是什么transition 可以在一定的时间内实现元素的状态过渡为最终状态，用于模拟以一种过渡动画效果，但是功能有限，只能用于制作简单的动画效果而动画属性 animation 可以制作类似 Flash 动画，通过关键帧控制动画的每一步，控制更为精确，从而可以制作更为复杂的动画。 css有哪些选择器？ id选择器 类选择器 标签选择器 123456又可以细分为：派生选择器（包括后代选择器、子元素选择器、相邻兄弟选择器）伪元素选择器属性选择器群组选择器通配符选择器 css优先级定义？一般而言，选择器越特殊指向越准确，优先级越高； 计算方法： 标签选择器优先级为1 类选择器优先级为10 id选择器优先级为100 行内样式优先级为1000 ！important 无限大； 附：css选择器执行效率与兼容性详列：http://www.cnblogs.com/xiaowuzi/p/3726835.html 超链接访问过后hover样式就不出现？如何解决？改变css属性的排列顺序（LVHA）link visited hover active css hack的原理？由于不同的浏览器和浏览器各版本对css的支持及解析结果不一样，以及css优先级对浏览器展现效果的影响，我们可以据此针对不同浏览器情景来应用不同的css。 css hack的分类？css hack有三种表现形式，css属性前缀法、选择器前缀法以及ie条件注释法（即头部引用if ie）。实际项目中css hack大部分是针对ie浏览器不同版本之间的表现差异而引入的。 属性前缀法：例：ie6能识别下划线“_”和星号“”，ie7能识别星号“”（以上版本并不支持），但不能识别下划线“_”，ie6~ie10都认识“\\9”，但是其他浏览器不能支持（也就是说可以利用这个特性恶心一下还在使用老版本的用户，哈哈）（“\\9”测试网址http://www.jb51.net/css/24944.html）选择器前缀法（选择器hack） 例：ie6能识别html .class{},ie7能识别+html .class{} 或者*:first-child+html .class{}; ie条件注释法：​ 针对所有ie（ie10+已经不再支持条件注释）：，针对ie6及以下版本：.这类hack不仅针对css生效，对写在判断语句里面的所有代码都会生效。 css hack书写顺序：​ 一般将适用范围广，能识别能力强的css定义在前面。因为写在后面代码如果被识别会覆盖前面识别的。​ （hack参考大全：http://blog.csdn.net/freshlover/article/details/12132801） vertical-align属性","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://qw8.github.io/tags/CSS/"},{"name":"选择器","slug":"选择器","permalink":"https://qw8.github.io/tags/选择器/"},{"name":"盒子模型","slug":"盒子模型","permalink":"https://qw8.github.io/tags/盒子模型/"},{"name":"样式表","slug":"样式表","permalink":"https://qw8.github.io/tags/样式表/"},{"name":"CSS精灵","slug":"CSS精灵","permalink":"https://qw8.github.io/tags/CSS精灵/"}]},{"title":"yarn","slug":"knowledges/yarn","date":"2020-08-27T11:21:17.000Z","updated":"2024-05-20T10:30:48.063Z","comments":true,"path":"/knowledges/yarn.html","link":"","permalink":"https://qw8.github.io/knowledges/yarn.html","excerpt":"","text":"1.1. 什么是 yarn?Yarn 是 facebook 发布的一款取代 npm 的包管理工具。 1.2. yarn 的特点1.2.1. 速度超快。Yarn 缓存了每个下载过的包, 所以再次使用时无需重复下载。 同时利用并行下载以最大化资源利用率, 因此安装速度更快。 1.2.2. 超级安全。在执行代码之前, Yarn 会通过算法校验每个安装包的完整性。 1.2.3. 超级可靠。使用详细、简洁的锁文件格式和明确的安装算法, Yarn 能够保证在不同系统上无差异的工作。 1.3. 为什么会出现 yarnnpm 存在一些历史遗留问题, npm 很多依赖不会指定版本号, 默认会安装最新的版本, 这样就会出现问题: 当新版本无法兼容之前的项目, 原项目可能会出现 bug。yarn 为了解决这个问题推出了 yarn.lock 的机制, 把依赖模块的版本号全部锁定, 当你执行 yarn install 的时候, yarn 会读取这个文件获得依赖的版本号, 然后依照这个版本号去安装对应的依赖模块, 这样依赖就会被锁定, 以后再也不用担心版本号的问题了。其他人或者其他环境下使用的时候, 把这个 yarn.lock 拷贝到相应的环境项目下再安装即可。注意: 这个文件不要手动修改它, 当你使用一些操作如 yarn add 时, yarn 会自动更新 yarn.lock。 1.4. yarn 的安装1.4.1. 下载 node.js, 使用 npm 安装 1npm install -g yarn 查看版本: yarn –version 1.4.2. Yarn 淘宝源安装, 分别复制粘贴以下代码行到黑窗口运行即可 12yarn config set registry https://registry.npm.taobao.org -gyarn config set sass_binary_site http://cdn.npm.taobao.org/dist/node-sass -g 1.5. yarn 的常用命令1.5.1. 初始化项目 1yarn init // 同 npm init, 执行输入信息后, 会生成 package.json 文件 1.5.2. yarn 的配置项 1234yarn config list // 显示所有配置项yarn config get &lt;key&gt; // 显示某配置项yarn config delete &lt;key&gt; // 删除某配置项yarn config set &lt;key&gt; &lt;value&gt; [-g|--global] // 设置配置项 1.5.3. 安装包 123456yarn install // 安装 package.json 里所有包, 并将包及它的所有依赖项保存进 yarn.lockyarn install --flat // 安装一个包的单一版本yarn install --force // 强制重新下载所有包yarn install --production // 只安装 dependencies 里的包yarn install --no-lockfile // 不读取或生成 yarn.lockyarn install --pure-lockfile // 不生成 yarn.lock 1.5.4. 添加包 (会更新 package.json 和 yarn.lock) 123yarn add [package] // 在当前的项目中添加一个依赖包, 会自动更新到 package.json 和 yarn.lock 文件中yarn add [package]@[version] // 安装指定版本, 这里指的是主要版本, 如果需要精确到小版本, 使用 - E 参数yarn add [package]@[tag] // 安装某个 tag(比如 beta,next 或者 latest) 默认安装包的主要版本里的最新版本, 下面两个命令可以指定版本: 12yarn add --exact/-E // 安装包的精确版本。例如 yarn add foo@1.2.3 会接受 1.9.1 版, 但是 yarn add foo@1.2.3 --exact 只会接受 1.2.3 版yarn add --tilde/-T // 安装包的次要版本里的最新版。例如 yarn add foo@1.2.3 --tilde 会接受 1.2.9, 但不接受 1.3.0 1.5.5. 发布包 1yarn publish 1.5.6. 移除一个包yarn remove : 移除一个包, 会自动更新 package.json 和 yarn.lock 1.5.7. 更新一个依赖yarn upgrade用于更新包到基于规范范围的最新版本 更新到特定版本，可以指定版本号 1yarn upgrade vue@2.7.16 1.5.8. 运行脚本yarn run 用来执行在 package.json 中 scripts 属性下定义的脚本 1.5.9. 显示某个包的信息yarn info 可以用来查看某个模块的最新版本信息 1.5.10. 缓存yarn cacheyarn cache list # 列出已缓存的每个包 yarn cache dir # 返回 全局缓存位置 yarn cache clean # 清除缓存 1.6. npm 与 yarn 命令比较 NPM YARN 说明 npm init yarn init 初始化某个项目 npm install/link yarn install/link 默认的安装依赖操作 npm install taco –save yarn add taco 安装某个依赖, 并且默认保存到 package npm uninstall taco –save yarn remove taco 移除某个依赖项目 npm install taco –save –dev yarn add taco –dev 安装某个开发时依赖项目 npm update taco –save yarn upgrade taco 更新某个依赖项目 npm install taco –global yarn global add taco 安装某个全局依赖项目 npm publish/login/logout yarn publish/login/logout 发布 / 登录 / 登出, 一系列 NPM Registry 操作 npm run/test yarn run/test 运行某个命令 1.7. 使用 yrm 工具管理一些 npm 源1.7.1. 安装 1yarn global add yrm 1.7.2. 查看可用源 1yrm ls 1.7.3. 选择源 1yrm use yarn 1.8. 快速删除 node_modules手动删除真的很慢: 12安装: npm install rimraf -g使用: rimraf node_modules rimraf 是 node 的一个包, 可以快速删除 node_modules, 再也不用等半天了。 1.9. Yarn docsYarn 1 (Classic): https://classic.yarnpkg.com/en/docs/cli/runYarn 2+: https://yarnpkg.com/getting-started/migration yarn与npm区别Yarn和npm都是JavaScript的包管理工具，用于在项目中安装、更新、删除和管理依赖关系。 以下是Yarn和npm之间的一些区别： 性能：Yarn在性能方面通常比npm更快。Yarn使用并行和缓存机制来加快包的下载和安装速度。 离线模式：Yarn可以离线运行，因为它会缓存所有已安装过的包。这使得在没有网络连接或网络不稳定的情况下，能够继续安装依赖项。 安全性：Yarn通过使用哈希算法验证每个下载的包的完整性，以提供更高的安全性。 依赖关系解析：Yarn使用锁定文件 (yarn.lock) 来确保在不同设备上的开发者之间共享相同的依赖版本。这可以防止由于环境差异而引起的构建问题。 脚本执行：npm允许在项目中运行自定义脚本（例如npm run build），而Yarn则需要使用yarn run命令来运行类似的脚本。 不论选择使用Yarn还是npm，都要根据项目的需求和团队的偏好来决定。 Yarn的优点？ 速度快 。速度快主要来自以下两个方面： 并行安装：无论 npm 还是 Yarn 在执行包的安装时，都会执行一系列任务。npm 是按照队列执行每个 package，也就是说必须要等到当前 package 安装完成之后，才能继续后面的安装。而 Yarn 是同步执行所有任务，提高了性能。 离线模式：如果之前已经安装过一个软件包，用Yarn再次安装时之间从缓存中获取，就不用像npm那样再从网络下载了。 安装版本统一：为了防止拉取到不同的版本，Yarn 有一个锁定文件 (lock file) 记录了被确切安装上的模块的版本号。每次只要新增了一个模块，Yarn 就会创建（或更新）yarn.lock 这个文件。这么做就保证了，每一次拉取同一个项目依赖时，使用的都是一样的模块版本。npm 其实也有办法实现处处使用相同版本的 packages，但需要开发者执行 npm shrinkwrap 命令。这个命令将会生成一个锁定文件，在执行 npm install 的时候，该锁定文件会先被读取，和 Yarn 读取 yarn.lock 文件一个道理。npm 和 Yarn 两者的不同之处在于，Yarn 默认会生成这样的锁定文件，而 npm 要通过 shrinkwrap 命令生成 npm-shrinkwrap.json 文件，只有当这个文件存在的时候，packages 版本信息才会被记录和更新。 更简洁的输出：npm 的输出信息比较冗长。在执行 npm install 的时候，命令行里会不断地打印出所有被安装上的依赖。相比之下，Yarn 简洁太多：默认情况下，结合了 emoji直观且直接地打印出必要的信息，也提供了一些命令供开发者查询额外的安装信息。 多注册来源处理：所有的依赖包，不管他被不同的库间接关联引用多少次，安装这个包时，只会从一个注册来源去装，要么是 npm 要么是 bower, 防止出现混乱不一致。 更好的语义化： yarn改变了一些npm命令的名称，比如 yarn add/remove，感觉上比 npm 原本的 install/uninstall 要更清晰。 Yarn和npm命令对比 npm yarn npm install yarn npm install react –save yarn add react npm uninstall react –save yarn remove react npm install react –save-dev yarn add react –dev npm update –save yarn upgrade 123456789101112131415161718192021222324252627282930313233343536373839404142431、查看版本yarn --versionnpm -version(或者 node -v)2、安装淘宝镜像yarn config set registry &apos;https://registry.npm.taobao.org&apos;npm install -g cnpm --registry=http://registry.npm.taobao.org3、初始化某个项目yarn init npm init4、默认安装项目依赖yarn installcnpm install5、安装某个依赖，并且默认保存到packageyarn add xxxcnpm install xxx --save6、卸载某个项目依赖yarn remove xxxcnpm uninstall xxx --save7、更新某个项目依赖yarn upgrade xxxcnpm update xxx --save8、安装某个全局的项目依赖yarn global add xxxcnpm install xxx -g9、安装某个特定版本号的项目依赖yarn add xxx@cnpm install xxx@1.2.33 --save10、发布/登录/登出，一系列NPM Registry操作yarn publish/login/logoutnpm publish/login/logout11、运行某个命令yarn run/testnpm run/test yarn使用报错系统上禁止运行脚本yarn使用报错信息yarn : 无法加载文件 C:\\Users\\Administrator\\AppData\\Roaming\\npm\\yarn.ps1，因为在此系统上禁止运行脚本。有关详细信息 解决方法要解决这个问题，可以通过以下步骤打开 PowerShell 的管理权限窗口，修改 PowerShell 执行策略即可： 1.以管理员身份运行 PowerShell 终端。方法是：在开始菜单中找到“Windows PowerShell”，右键点击它并选择“以管理员身份运行”。 2.运行以下命令：Get-ExecutionPolicy -List 3.查看目前 PowerShell 的执行策略。输出结果应该类似于下面这样： 12Scope ExecutionPolicy----- --------------- MachinePolicy UndefinedUserPolicy UndefinedProcess RemoteSignedCurrentUser RestrictedLocalMachine Undefined4.把当前用户的执行策略改为 RemoteSigned 或者更为宽松的 Unrestricted，方法是运行以下命令： 1Set-ExecutionPolicy RemoteSigned -Scope CurrentUser 或者 Set-ExecutionPolicy Unrestricted -Scope CurrentUser 5.输入 Y 并按回车确认更改。然后再次输入以下命令验证更改是否生效： 1Get-ExecutionPolicy -List 6.输出应该会显示类似如下所示的结果： 12Scope ExecutionPolicy----- --------------- MachinePolicy UndefinedUserPolicy UndefinedProcess UndefinedCurrentUser RemoteSignedLocalMachine Undefined 再次尝试现在再尝试使用 yarn 进行安装，应该就能正常执行了。完成之后，如果担心安全问题可以把 PowerShell 的执行策略修改回 Restricted 阻止运行脚本。 怎么更新yarn.lock文件要更新yarn.lock文件，你可以遵循以下步骤： 安装或更新依赖包： 添加新依赖：使用命令yarn add [package_name]来添加一个新的依赖包到项目中。这将自动更新yarn.lock文件以包含新包及其依赖的精确版本。 更新依赖包：要更新一个已存在的依赖到最新版本，可以使用yarn upgrade [package_name]。如果想更新到特定版本，可以指定版本号，如yarn upgrade [package_name]@[version]。此操作同样会更新yarn.lock文件。 删除依赖：使用yarn remove [package_name]来移除不再需要的依赖，这也会相应地更新yarn.lock文件。 整体更新所有依赖： 要将所有依赖更新到它们各自的最新版本（符合package.json中的版本范围），可以运行yarn upgrade或yarn upgrade-interactive。后者提供了一个交互式的界面，让你可以选择要更新的包。 解决冲突或不一致： 在团队协作中，如果yarn.lock文件存在合并冲突或需要与远程分支同步，首先解决冲突，然后运行yarn install以确保本地环境与yarn.lock文件匹配，这也会解决任何潜在的依赖不一致问题。 记住，不要直接手动编辑yarn.lock文件，除非你非常清楚自己在做什么，因为手动更改容易引入错误，导致依赖不一致。始终让Yarn工具自动管理这个文件，以保证依赖的确定性和项目环境的一致性。","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"yarn","slug":"yarn","permalink":"https://qw8.github.io/tags/yarn/"}]},{"title":"ES6","slug":"interview/ES6","date":"2020-08-13T03:42:39.000Z","updated":"2023-04-14T17:01:50.000Z","comments":true,"path":"/interview/es6.html","link":"","permalink":"https://qw8.github.io/interview/es6.html","excerpt":"","text":"ES6（2015）1. 类（class）12345678910class Man &#123; constructor(name) &#123; this.name = '小豪'; &#125; console() &#123; console.log(this.name); &#125;&#125;const man = new Man('小豪');man.console(); // 小豪 2. 模块化(ES Module)12345// 模块 A 导出一个方法export const sub = (a, b) =&gt; a + b;// 模块 B 导入使用import &#123; sub &#125; from './A';console.log(sub(1, 2)); // 3 3. 箭头（Arrow）函数12const func = (a, b) =&gt; a + b;func(1, 2); // 3 4. 函数参数默认值1function foo(age = 25,)&#123; // ...&#125; 5. 模板字符串12const name = '小豪';const str = `Your name is $&#123;name&#125;`; 6. 解构赋值12let a = 1, b= 2;[a, b] = [b, a]; // a 2 b 1 7. 延展操作符1let a = [...'hello world']; // [\"h\", \"e\", \"l\", \"l\", \"o\", \" \", \"w\", \"o\", \"r\", \"l\", \"d\"] 8. 对象属性简写12const name='小豪',const obj = &#123; name &#125;; 9. Promise123Promise.resolve().then(() =&gt; &#123; console.log(2); &#125;);console.log(1);// 先打印 1 ，再打印 2 10. let和const12let name = '小豪'；const arr = []; ES7（2016）1. Array.prototype.includes()1[1].includes(1); // true 2. 指数操作符12**10; // 1024 ES8（2017）1. async/await异步终极解决方案 1234async getData()&#123; const res = await api.getTableData(); // await 异步任务 // do something &#125; 2. Object.values()1Object.values(&#123;a: 1, b: 2, c: 3&#125;); // [1, 2, 3] 3. Object.entries()1Object.entries(&#123;a: 1, b: 2, c: 3&#125;); // [[\"a\", 1], [\"b\", 2], [\"c\", 3]] 4. String padding1234// padStart'hello'.padStart(10); // \" hello\"// padEnd'hello'.padEnd(10) \"hello \" 5. 函数参数列表结尾允许逗号6. Object.getOwnPropertyDescriptors() 获取一个对象的所有自身属性的描述符,如果没有任何自身属性，则返回空对象。 7. SharedArrayBuffer对象 SharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区， 123456/** * * @param &#123;*&#125; length 所创建的数组缓冲区的大小，以字节(byte)为单位。 * @returns &#123;SharedArrayBuffer&#125; 一个大小指定的新 SharedArrayBuffer 对象。其内容被初始化为 0。 */new SharedArrayBuffer(10) 8. Atomics对象 Atomics 对象提供了一组静态方法用来对 SharedArrayBuffer 对象进行原子操作。 ES9（2018）1. 异步迭代await可以和for…of循环一起使用，以串行的方式运行异步操作 12345async function process(array) &#123; for await (let i of array) &#123; // doSomething(i); &#125;&#125; 2. Promise.finally()1Promise.resolve().then().catch(e =&gt; e).finally(); 3. Rest/Spread 属性12const values = [1, 2, 3, 5, 6];console.log( Math.max(...values) ); // 6 4. 正则表达式命名捕获组12const reg = /(?&lt;year&gt;[0-9]&#123;4&#125;)-(?&lt;month&gt;[0-9]&#123;2&#125;)-(?&lt;day&gt;[0-9]&#123;2&#125;)/;const match = reg.exec('2021-02-23'); img 5. 正则表达式反向断言123(?=p)、(?&lt;=p) p 前面(位置)、p 后面(位置)(?!p)、(?&lt;!p&gt;) 除了 p 前面(位置)、除了 p 后面(位置)(?&lt;=w) img `(? img 6. 正则表达式dotAll模式 正则表达式中点.匹配除回车外的任何单字符，标记s改变这种行为，允许行终止符的出现 1/hello.world/.test('hello\\nworld'); // false img ES10（2019）1. Array.flat()和Array.flatMap()flat() 1[1, 2, [3, 4]].flat(Infinity); // [1, 2, 3, 4] flatMap() 1[1, 2, 3, 4].flatMap(a =&gt; [a**2]); // [1, 4, 9, 16] 2. String.trimStart()和String.trimEnd()去除字符串首尾空白字符 3. String.prototype.matchAll matchAll（）为所有匹配的匹配对象返回一个迭代器 12const raw_arr = 'test1 test2 test3'.matchAll((/t(e)(st(\\d?))/g));const arr = [...raw_arr]; img 4. Symbol.prototype.description 只读属性，回 Symbol 对象的可选描述的字符串。 1Symbol('description').description; // 'description' 5. Object.fromEntries() 返回一个给定对象自身可枚举属性的键值对数组 123// 通过 Object.fromEntries， 可以将 Map 转化为 Object:const map = new Map([ ['foo', 'bar'], ['baz', 42] ]);console.log(Object.fromEntries(map)); // &#123; foo: \"bar\", baz: 42 &#125; 6. 可选 CatchES11（2020）1. Nullish coalescing Operator(空值处理)表达式在 ?? 的左侧 运算符求值为undefined或null，返回其右侧。 1234567891011let user = &#123; u1: 0, u2: false, u3: null, u4: undefined u5: '',&#125;let u2 = user.u2 ?? '用户2' // falselet u3 = user.u3 ?? '用户3' // 用户3let u4 = user.u4 ?? '用户4' // 用户4let u5 = user.u5 ?? '用户5' // '' 2. Optional chaining（可选链）?.用户检测不确定的中间节点 123let user = &#123;&#125;let u1 = user.childer.name // TypeError: Cannot read property 'name' of undefinedlet u1 = user.childer?.name // undefined 3. Promise.allSettled 返回一个在所有给定的promise已被决议或被拒绝后决议的promise，并带有一个对象数组，每个对象表示对应的promise结果 123456789const promise1 = Promise.resolve(3);const promise2 = 42;const promise3 = new Promise((resolve, reject) =&gt; reject('我是失败的Promise_1'));const promise4 = new Promise((resolve, reject) =&gt; reject('我是失败的Promise_2'));const promiseList = [promise1,promise2,promise3, promise4]Promise.allSettled(promiseList).then(values=&gt;&#123; console.log(values)&#125;); img 4. import()按需导入 5. 新基本数据类型BigInt 任意精度的整数 6. globalThis 浏览器：window worker：self node：global ES12（2021）1. replaceAll 返回一个全新的字符串，所有符合匹配规则的字符都将被替换掉 12const str = 'hello world';str.replaceAll('l', ''); // \"heo word\" 2. Promise.any Promise.any() 接收一个Promise可迭代对象，只要其中的一个 promise 成功，就返回那个已经成功的 promise 。如果可迭代对象中没有一个 promise 成功（即所有的 promises 都失败/拒绝），就返回一个失败的 promise 12345678910const promise1 = new Promise((resolve, reject) =&gt; reject('我是失败的Promise_1'));const promise2 = new Promise((resolve, reject) =&gt; reject('我是失败的Promise_2'));const promiseList = [promise1, promise2];Promise.any(promiseList).then(values=&gt;&#123; console.log(values);&#125;).catch(e=&gt;&#123; console.log(e);&#125;); img 3. WeakRefs 使用WeakRefs的Class类创建对对象的弱引用(对对象的弱引用是指当该对象应该被GC回收时不会阻止GC的回收行为) 4. 逻辑运算符和赋值表达式 逻辑运算符和赋值表达式，新特性结合了逻辑运算符（&amp;&amp;，||，??）和赋值表达式而JavaScript已存在的 复合赋值运算符有： 1234567891011a ||= b//等价于a = a || (a = b)a &amp;&amp;= b//等价于a = a &amp;&amp; (a = b)a ??= b//等价于a = a ?? (a = b) 5. 数字分隔符 数字分隔符，可以在数字之间创建可视化分隔符，通过_下划线来分割数字，使数字更具可读性 12345const money = 1_000_000_000;//等价于const money = 1000000000;1_000_000_000 === 1000000000; // true img 以上内容来自https://segmentfault.com/a/1190000039272641 箭头函数一、ES6标准新增加了一种新的匿名函数定义方法:箭头函数(Arrow Function)。箭头函数并没有替代以前定义匿名函数的方法，只是新增的一种定义匿名函数的方式！ 12345678910111213// 正常函数function name(形参列表)&#123;代码块&#125;// ES6之前的匿名函数function(形参列表)&#123;代码块&#125;function(x,y)&#123;return x+y&#125;// ES6新特性箭头函数(形参列表)=&gt;&#123;代码块&#125;x =&gt; x+1 ; // 只有一个形参省略括号x =&gt; (&#123;foo: x&#125;); // 返回对象字面量表达式(x,y) =&gt; x+y;(x,y) =&gt; &#123;return x+y&#125; 二、箭头函数没有定义this绑定。 箭头函数最大的好处是解决了匿名函数的this指向问题，有利于封装回调函数。箭头函数体内的this对象，就是定义该函数时所在的作用域指向的对象，而不是使用时所在的作用域指向的对象。（简述：箭头函数的this是继承所在作用域的this）。 12345678910111213141516171819var obj = &#123; msg: &quot;你好&quot;, fn1: function () &#123; // 你好 console.log(this.msg); // undefined （this指向该当前对象） setTimeout(function () &#123; console.log(this.msg); &#125;, 500); // 你好 （this指向定义该箭头函数时所在的作用域） setTimeout(() =&gt; &#123; console.log(this.msg); &#125;, 500); &#125;, fn2: () =&gt; &#123; // undefined （this指向window） console.log(this.msg); &#125;,&#125;; 三、箭头函数不绑定Arguments 对象，不能用作构造器，没有prototype属性，yield关键字通常不能在箭头函数中使用。 12345678910var fn1 = function (x) &#123; // arguments数组 console.log(arguments);&#125;;var fn2 = (x) =&gt; &#123; // ReferenceError console.log(arguments);&#125;;fn2.prototype; // undefinedlet fn3 = new fn2(); // ReferenceError 四、其他 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 三元运算var simple = a =&gt; a &gt; 10 ? 15 : a;simple(18); // 15simple(8); // 8// 递归var mult = (x) =&gt; ( x==0 ? 1 : x*mult(x-1) );mult(5); // 120// 标准的闭包函数function fn1() &#123; var i = 0; return function fn2() &#123; return ++i; &#125;;&#125;fn1()(); // 1var v = fn1();v(); //1 v(); //2//箭头函数体的闭包（ i=0 是默认参数）var Add = (i = 0) =&gt; &#123; return () =&gt; ++i;&#125;;//因为仅有一个返回，return 及括号（）也可以省略var Add = (i = 0) =&gt; () =&gt; ++i;var q = Add ();q(); //1 q(); //2// 箭头函数内定义的变量及其作用域// 常规写法 函数体内var let定义的变量是局部变量var whatTime = () =&gt; &#123; let now = new Date(); // var now = new Date(); return now.getHours() &gt; 17 ? &quot;晚上好&quot; : &quot;日安&quot;;&#125;;whatTime(); // &quot;晚上好&quot;console.log(now); // ReferenceError: now is not defined// 参数括号内定义的变量是局部变量（默认参数）var whatTime = (now = new Date()) =&gt; (now.getHours() &gt; 17 ? &quot;晚上好&quot; : &quot;日安&quot;);whatTime(); // &quot;晚上好&quot;console.log(now); // ReferenceError: now is not defined// 对比：函数体内&#123;&#125;不使用var定义的变量是全局变量var whatTime = () =&gt; &#123; now = new Date(); return now.getHours() &gt; 17 ? &quot;晚上好&quot; : &quot;日安&quot;;&#125;;whatTime(); // &quot;晚上好&quot;console.log(now); // Thu Oct 14 2021 18:21:21 GMT+0800 (中国标准时间) 原文链接：https://blog.csdn.net/lusy258/article/details/120767707 ES5、ES6和ES2015有什么区别? ES2015特指在2015年发布的新一代JS语言标准，ES6泛指下一代JS语言标准，包含ES2015、ES2016、ES2017、ES2018等。现阶段在绝大部分场景下，ES2015默认等同ES6。ES5泛指上一代语言标准。ES2015可以理解为ES5和ES6的时间分界线 ES6的了解es6 是一个新的标准，它包含了许多新的语言特性和库，是 JS 最实质性的一次升级。比如’箭头函数’、’字符串模板’、’generators(生成器)’、’async/await’、’解构赋值’、’class’等等，还有就是引入 module 模块的概念。 增加了块级作用域。let命令实际上就增加了块级作用域。ES6规定，var命令和function命令声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。 块级作用域let a = 1;可定义常量const PI = 3.141592654;` ES6将promise对象纳入规范，提供了原生的Promise对象。增加了let和const命令，用来声明变量。 var promise = new Promise(func); 箭头函数（操作符左边为输入的参数，而右边则是进行的操作以及返回的值Inputs=&gt;outputs。） 新增模板字符串（为JavaScript提供了简单的字符串插值功能，字符串的扩展） var sum =${a + b}; arguments对象可被不定参数和默认参数完美代替。 ES6新的语法糖，类，module模块化等新特性 解析：参考 谈一谈你了解ECMAScript6的新特性？ 变量解构赋值 var [a, b, c] = [1, 2, 3]; 数组的扩展(转换数组类型) Array.from($(&#39;li&#39;)); 函数的扩展(扩展运算符) [1, 2].push(...[3, 4, 5]); 对象的扩展(同值相等算法) Object.is(NaN, NaN); 新增数据类型(Symbol) let uid = Symbol(&#39;uid&#39;); 新增数据结构(Map) let set = new Set([1, 2, 2, 3]); for…of循环（用来遍历数据—例如数组中的值。） for(let val of arr){}; Promise对象 Generator函数 function* foo(x){yield x; return x*x;} 引入Class(类) class Foo {} 引入模块体系 export default func; 引入async函数[ES7] 1234async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value) &#125; 日常前端代码开发中，有哪些值得用ES6去改进的编程优化或者规范？ 常用箭头函数来取代var self = this;的做法。 常用let取代var命令。 常用数组/对象的结构赋值来命名变量，结构更清晰，语义更明确，可读性更好。 在长字符串多变量组合场合，用模板字符串来取代字符串累加，能取得更好地效果和阅读体验。 用Class类取代传统的构造函数，来生成实例化对象。 在大型应用开发中，要保持module模块化开发思维，分清模块之间的关系，常用import、export方法。 var、let、const 的区别 var 定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。 let 定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。（通常配合 for 循环或者 {} 进行使用产生块级作用域） const 用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改（内存地址不变）。 同一个变量只能使用一种方式声明，不然会报错 参考链接 let有什么用，有了var为什么还要用let？ 在ES6之前，声明变量只能用var，var方式声明变量其实是很不合理的，准确的说，是因为ES5里面没有块级作用域是很不合理的。没有块级作用域回来带很多难以理解的问题，比如for循环var变量泄露，变量覆盖等问题。let声明的变量拥有自己的块级作用域，且修复了var声明变量带来的变量提升问题。 123456789101112131415161718192021222324252627282930313233343536373839&lt;script type=\"text/javascript\"&gt; // 块作用域 &#123; var a = 1; let b = 2; const c = 3; // c = 4; // 报错 // let a = 'a'; // 报错 注：是上面 var a = 1; 那行报错 // var b = 'b'; // 报错：本行报错 // const a = 'a1'; // 报错 注：是上面 var a = 1; 那行报错 // let c = 'c'; // 报错：本行报错 var aa; let bb; // const cc; // 报错 console.log(a); // 1 console.log(b); // 2 console.log(c); // 3 console.log(aa); // undefined console.log(bb); // undefined &#125; console.log(a); // 1 // console.log(b); // 报错 // console.log(c); // 报错 // 函数作用域 (function A() &#123; var d = 5; let e = 6; const f = 7; console.log(d); // 5 console.log(e); // 6 (在同一个&#123; &#125;中,也属于同一个块，可以正常访问到) console.log(f); // 7 (在同一个&#123; &#125;中,也属于同一个块，可以正常访问到) &#125;)(); // console.log(d); // 报错 // console.log(e); // 报错 // console.log(f); // 报错&lt;/script&gt; JS 块级作用域、变量提升块级作用域 JS 中作用域有：全局作用域、函数作用域。没有块作用域的概念。ECMAScript 6(简称 ES6)中新增了块级作用域。块作用域由 { } 包括，if 语句和 for 语句里面的{ }也属于块作用域。 变量提升 如果变量声明在函数里面，则将变量声明提升到函数的开头 如果变量声明是一个全局变量，则将变量声明提升到全局作用域的开头 解析： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;script type=\"text/javascript\"&gt; &#123; var a = 1; console.log(a); // 1 &#125; console.log(a); // 1 // 可见，通过var定义的变量可以跨块作用域访问到。 (function A() &#123; var b = 2; console.log(b); // 2 &#125;)(); // console.log(b); // 报错， // 可见，通过var定义的变量不能跨函数作用域访问到 if(true) &#123; var c = 3; &#125; console.log(c); // 3 for(var i = 0; i &lt; 4; i++) &#123; var d = 5; &#125;; console.log(i); // 4 (循环结束i已经是4，所以此处i为4) console.log(d); // 5 // if语句和for语句中用var定义的变量可以在外面访问到， // 可见，if语句和for语句属于块作用域，不属于函数作用域。 &#123; var a = 1; let b = 2; const c = 3; &#123; console.log(a); // 1 子作用域可以访问到父作用域的变量 console.log(b); // 2 子作用域可以访问到父作用域的变量 console.log(c); // 3 子作用域可以访问到父作用域的变量 var aa = 11; let bb = 22; const cc = 33; &#125; console.log(aa); // 11 // 可以跨块访问到子 块作用域 的变量 // console.log(bb); // 报错 bb is not defined // console.log(cc); // 报错 cc is not defined &#125;&lt;/script&gt; var let 在 for 循环中的区别解析：参考 如何避免回调函数嵌套？使用 Promises 将回调写成单独的函数 Promise是什么，有什么作用？ 这里你谈 promise的时候，除了将他解决的痛点以及常用的 API 之外，最好进行拓展把 eventloop 带进来好好讲一下，microtask(微任务)、macrotask(任务) 的执行顺序； 如果看过 promise 源码，最好可以谈一谈 原生 Promise 是如何实现的。Promise 的关键点在于callback 的两个参数，一个是 resovle，一个是 reject。还有就是 Promise 的链式调用（Promise.then()，每一个 then 都是一个责任人） Promise是ES6引入的一个新的对象，他的主要作用是用来解决JS异步机制里，回调机制产生的“回调地狱”。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。它并不是什么突破性的API，只是封装了异步回调形式，使得异步回调可以写的更加优雅，可读性更高，而且可以链式调用。 Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件监听——更合理和更强大。简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise 就是一个对象，用来表示并传递异步操作的最终结果 Promise 最主要的交互方式：将回调函数传入 then 方法来获得最终结果或出错原因 Promise 代码书写上的表现：以“链式调用”代替回调函数层层嵌套（回调地狱） 有两个特点: 对象的状态不受外界影响，Promise 对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和 Rejected（已失败） 一旦状态改变，就不会再变，任何时候都可以得到这个结果。 依照 Promise/A+ 的定义，Promise 有四种状态： pending: 初始状态, 非 fulfilled 或 rejected. fulfilled: 成功的操作. rejected: 失败的操作. settled: Promise已被fulfilled或rejected，且不是pending 另外， fulfilled 与 rejected 一起合称 settled Promise 对象用来进行延迟(deferred) 和异步(asynchronous ) 计算 解析：参考、参考链接 Promise 的构造函数构造一个 Promise，最基本的用法如下： 1234567var promise = new Promise(function(resolve, reject) &#123; if (...) &#123; // succeed resolve(result); &#125; else &#123; // fails reject(Error(errMessage)); &#125; &#125;); Promise 实例拥有 then 方法（具有 then 方法的对象，通常被称为thenable）。它的使用方法如下： 1promise.then(onFulfilled, onRejected) 接收两个函数作为参数，一个在 fulfilled 的时候被调用，一个在rejected的时候被调用，接收参数就是 future，onFulfilled 对应 resolve, onRejected 对应 reject async函数是什么，有什么作用？async函数可以理解为内置自动执行器的Generator函数语法糖，它配合ES6的Promise近乎完美的实现了异步编程解决方案。 async、awaitasync/await 是写异步代码的新方式，以前的方法有回调函数和 Promise。 async/await 是基于 Promise 实现的，它不能用于普通的回调函数。async/await 与 Promise 一样，是非阻塞的。 async/await 使得异步代码看起来像同步代码，这正是它的魔力所在。 Generator 函数的语法糖。有更好的语义、更好的适用性、返回值是 Promise。 async =&gt; * await =&gt; yield 123456789101112// 基本用法async function timeout (ms) &#123; await new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms) &#125;)&#125;async function asyncConsole (value, ms) &#123; await timeout(ms) console.log(value)&#125;asyncConsole('hello async and await', 1000) 注：最好把2，3，4 连到一起讲 箭头函数和普通函数有什么区别箭头函数可以让 this 指向固定化，这种特性很有利于封装回调函数 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象，用call apply bind也不能改变this指向 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 箭头函数没有原型对象prototype 第一点尤其值得注意。this 对象的指向是可变的，但是在箭头函数中，它是固定的。 12345678910function foo() &#123; setTimeout(() =&gt; &#123; console.log(\"id:\", this.id); &#125;, 100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;);// id: 42 解析：参考 举一些ES6对Function函数类型做的常用升级优化?优化部分 箭头函数(核心)。箭头函数是ES6核心的升级项之一，箭头函数里没有自己的this,这改变了以往JS函数中最让人难以理解的this运行机制。主要优化点 箭头函数内的this指向的是函数定义时所在的对象，而不是函数执行时所在的对象。ES5函数里的this总是指向函数执行时所在的对象，这使得在很多情况下this的指向变得很难理解，尤其是非严格模式情况下，this有时候会指向全局对象，这甚至也可以归结为语言层面的bug之一。ES6的箭头函数优化了这一点，它的内部没有自己的this,这也就导致了this总是指向上一层的this，如果上一层还是箭头函数，则继续向上指，直到指向到有自己this的函数为止，并作为自己的this 箭头函数不能用作构造函数，因为它没有自己的this，无法实例化 也是因为箭头函数没有自己的this,所以箭头函数 内也不存在arguments对象。（可以用扩展运算符代替） 函数默认赋值。ES6之前，函数的形参是无法给默认值得，只能在函数内部通过变通方法实现。ES6以更简洁更明确的方式进行函数默认赋值 1234function es6Fuc (x, y = 'default') &#123; console.log(x, y);&#125;es6Fuc(4) // 4, default 升级部分 ES6新增了双冒号运算符，用来取代以往的bind，call,和apply。(浏览器暂不支持，Babel已经支持转码) 1234567foo::bar;// 等同于bar.bind(foo);foo::bar(...arguments);// 等同于bar.apply(foo, arguments); 模板字符串就是这种形式${varible},在以往的时候我们在连接字符串和变量的时候需要使用这种方式’string’ + varible + ‘string’但是有了模版语言后我们可以使用string${varible}string 这种进行连接。基本用途有如下： 1、基本的字符串格式化，将表达式嵌入字符串中进行拼接，用${}来界定。 123456//es5var name = \"lux\";console.log(\"hello\" + name);//es6const name = \"lux\";console.log(`hello $&#123;name&#125;`); //hello lux 2、在 ES5 时我们通过反斜杠()来做多行字符串或者字符串一行行拼接，ES6 反引号(``)直接搞定。 12345678910//ES5var template = \"hello \\world\";console.log(template); //hello world//ES6const template = `helloworld`;console.log(template); //hello 空行 world module、export、import是什么，有什么作用？ module、export、import是ES6用来统一前端模块化方案的设计思路和实现方案。export、import的出现统一了前端模块化的实现方案，整合规范了浏览器/服务端的模块化方法，用来取代传统的AMD/CMD、requireJS、seaJS、commondJS等等一系列前端模块不同的实现方案，使前端模块化更加统一规范，JS也能更加能实现大型的应用程序开发。 import引入的模块是静态加载（编译阶段加载）而不是动态加载（运行时加载）。 import引入export导出的接口值是动态绑定关系，即通过该接口，可以取到模块内部实时的值 ES6 如何动态加载 import123import(\"lodash\").then(_ =&gt; &#123; // Do something with lodash (a.k.a '_')...&#125;); 解析：参考 什么是 Babelbabel是一个 ES6 转码器，可以将 ES6 代码转为 ES5 代码，以便兼容那些还没支持ES6的平台 Babel 是一个 JS 编译器，自带一组 ES6 语法转化器，用于转化 JS 代码。这些转化器让开发者提前使用最新的 JS语法(ES6/ES7)，而不用等浏览器全部兼容。 Babel 默认只转换新的 JS 句法(syntax)，而不转换新的API。 Object.is() 与原来的比较操作符“ ===”、“ ==”的区别？ == 相等运算符，比较时会自动进行数据类型转换 === 严格相等运算符，比较时不进行隐式类型转换（类型不同则会返回false）； Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 Object.is(NaN, NaN) 会返回 true 123456//Object.is 同值相等算法，在 === 基础上对 0 和 NaN 特别处理+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // true Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。 for…in 和for…of有什么区别？ 如果看到问题十六，那么就很好回答。问题十六提到了ES6统一了遍历标准，制定了可遍历对象，那么用什么方法去遍历呢？答案就是用for...of。ES6规定，有所部署了载了Iterator接口的对象(可遍历对象)都可以通过for...of去遍历，而for..in仅仅可以遍历对象 这也就意味着，数组也可以用for...of遍历，这极大地方便了数组的取值，且避免了很多程序用for..in去遍历数组的恶习 Symbol是什么，有什么作用？ Symbol是ES6引入的第七种原始数据类型（说法不准确，应该是第七种数据类型，Object不是原始数据类型之一，已更正），所有Symbol()生成的值都是独一无二的，可以从根本上解决对象属性太多导致属性名冲突覆盖的问题。对象中Symbol()属性不能被for...in遍历，但是也不是私有属性 Set是什么，有什么作用？ Set是ES6引入的一种类似Array的新的数据结构，Set实例的成员类似于数组item成员。 区别是Set实例的成员都是唯一，不重复的。这个特性可以轻松地实现数组去重 Set 数据结构 es6 方法,Set 本身是一个构造函数，它类似于数组，但是成员值都是唯一的。 123const set = new Set([1, 2, 3, 4, 4]);console.log([...set]); // [1,2,3,4]console.log(Array.from(new Set([2, 3, 3, 5, 6]))); //[2,3,5,6] Map是什么，有什么作用？ Map是ES6引入的一种类似Object的新的数据结构，Map可以理解为是Object的超集，打破了以传统键值对形式定义对象，对象的key不再局限于字符串，也可以是Object。可以更加全面的描述对象的属性 Proxy是什么，有什么作用？ Proxy是ES6新增的一个构造函数，可以理解为JS语言的一个代理，用来改变JS默认的一些语言行为，包括拦截默认的get/set等底层方法，使得JS的使用自由度更高，可以最大限度的满足开发者的需求。比如通过拦截对象的get/set方法，可以轻松地定制自己想要的key或者value。下面的例子可以看到，随便定义一个myOwnObj的key,都可以变成自己想要的函数` 12345678910111213141516171819202122232425262728293031323334function createMyOwnObj() &#123; //想把所有的key都变成函数，或者Promise,或者anything return new Proxy(&#123;&#125;, &#123; get(target, propKey, receiver) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; let randomBoolean = Math.random() &gt; 0.5; let Message; if (randomBoolean) &#123; Message = `你的$&#123;propKey&#125;运气不错，成功了`; resolve(Message); &#125; else &#123; Message = `你的$&#123;propKey&#125;运气不行，失败了`; reject(Message); &#125; &#125;, 1000); &#125;); &#125; &#125;);&#125;let myOwnObj = createMyOwnObj();myOwnObj.hahaha.then(result =&gt; &#123; console.log(result) //你的hahaha运气不错，成功了&#125;).catch(error =&gt; &#123; console.log(error) //你的hahaha运气不行，失败了&#125;)myOwnObj.wuwuwu.then(result =&gt; &#123; console.log(result) //你的wuwuwu运气不错，成功了&#125;).catch(error =&gt; &#123; console.log(error) //你的wuwuwu运气不行，失败了&#125;) Reflect是什么，有什么作用？ Reflect是ES6引入的一个新的对象，他的主要作用有两点，一是将原生的一些零散分布在Object、Function或者全局函数里的方法(如apply、delete、get、set等等)，统一整合到Reflect上，这样可以更加方便更加统一的管理一些原生API。其次就是因为Proxy可以改写默认的原生API，如果一旦原生API别改写可能就找不到了，所以Reflect也可以起到备份原生API的作用，使得即使原生API被改写了之后，也可以在被改写之后的API用上默认的API 举一些ES6对String字符串类型做的常用升级优化?优化部分 ES6新增了字符串模板，在拼接大段字符串时，用反斜杠()`取代以往的字符串相加的形式，能保留所有空格和换行，使得字符串拼接看起来更加直观，更加优雅 升级部分 ES6在String原型上新增了includes()方法，用于取代传统的只能用indexOf查找包含字符的方法(indexOf返回-1表示没查到不如includes方法返回false更明确，语义更清晰), 此外还新增了startsWith(), endsWith(), padStart(),padEnd(),repeat()等方法，可方便的用于查找，补全字符串 举一些ES6对Array数组类型做的常用升级优化优化部分 数组解构赋值。ES6可以直接以let [a,b,c] = [1,2,3]形式进行变量赋值，在声明较多变量时，不用再写很多let(var),且映射关系清晰，且支持赋默认值 扩展运算符。ES6新增的扩展运算符(...)(重要),可以轻松的实现数组和松散序列的相互转化，可以取代arguments对象和apply方法，轻松获取未知参数个数情况下的参数集合。（尤其是在ES5中，arguments并不是一个真正的数组，而是一个类数组的对象，但是扩展运算符的逆运算却可以返回一个真正的数组）。扩展运算符还可以轻松方便的实现数组的复制和解构赋值（let a = [2,3,4]; let b = [...a]） 升级部分 ES6在Array原型上新增了find()方法，用于取代传统的只能用indexOf查找包含数组项目的方法,且修复了indexOf查找不到NaN的bug([NaN].indexOf(NaN) === -1).此外还新增了copyWithin(),includes(), fill(),flat()等方法，可方便的用于字符串的查找，补全,转换等 举一些ES6对Number数字类型做的常用升级优化优化部分 ES6在Number原型上新增了isFinite(), isNaN()方法，用来取代传统的全局isFinite(), isNaN()方法检测数值是否有限、是否是NaN。ES5的isFinite(), isNaN()方法都会先将非数值类型的参数转化为Number类型再做判断，这其实是不合理的，最造成isNaN(&#39;NaN&#39;) === true的奇怪行为--&#39;NaN&#39;是一个字符串，但是isNaN却说这就是NaN。而Number.isFinite()和Number.isNaN()则不会有此类问题(Number.isNaN(&#39;NaN&#39;) === false)。（isFinite()同上） 升级部分 ES6在Math对象上新增了Math.cbrt()，trunc()，hypot()等等较多的科学计数法运算方法，可以更加全面的进行立方根、求和立方根等等科学计算 举一些ES6对Object类型做的常用升级优化?(重要)优化部分 对象属性变量式声明。ES6可以直接以变量形式声明对象属性或者方法，。比传统的键值对形式声明更加简洁，更加方便，语义更加清晰 12let [apple, orange] = ['red appe', 'yellow orange'];let myFruits = &#123;apple, orange&#125;; // let myFruits = &#123;apple: 'red appe', orange: 'yellow orange'&#125;; 尤其在对象解构赋值(见优化部分b.)或者模块输出变量时，这种写法的好处体现的最为明显 12let &#123;keys, values, entries&#125; = Object;let MyOwnMethods = &#123;keys, values, entries&#125;; // let MyOwnMethods = &#123;keys: keys, values: values, entries: entries&#125; 可以看到属性变量式声明属性看起来更加简洁明了。方法也可以采用简洁写法 123456let es5Fun = &#123; method: function()&#123;&#125;&#125;; let es6Fun = &#123; method()&#123;&#125;&#125; 对象的解构赋值。 ES6对象也可以像数组解构赋值那样，进行变量的解构赋值 1let &#123;apple, orange&#125; = &#123;apple: 'red appe', orange: 'yellow orange'&#125;; 对象的扩展运算符(...)。 ES6对象的扩展运算符和数组扩展运算符用法本质上差别不大，毕竟数组也就是特殊的对象。对象的扩展运算符一个最常用也最好用的用处就在于可以轻松的取出一个目标对象内部全部或者部分的可遍历属性，从而进行对象的合并和分解 12345let &#123;apple, orange, ...otherFruits&#125; = &#123;apple: 'red apple', orange: 'yellow orange', grape: 'purple grape', peach: 'sweet peach'&#125;; // otherFruits &#123;grape: 'purple grape', peach: 'sweet peach'&#125;// 注意: 对象的扩展运算符用在解构赋值时，扩展运算符只能用在最有一个参数(otherFruits后面不能再跟其他参数)let moreFruits = &#123;watermelon: 'nice watermelon'&#125;;let allFruits = &#123;apple, orange, ...otherFruits, ...moreFruits&#125;; super 关键字。ES6在Class类里新增了类似this的关键字super。同this总是指向当前函数所在的对象不同，super关键字总是指向当前函数所在对象的原型对象 升级部分 ES6在Object原型上新增了is()方法，做两个目标对象的相等比较，用来完善&#39;===&#39;方法。&#39;===&#39;方法中NaN === NaN //false其实是不合理的，Object.is修复了这个小bug。(Object.is(NaN, NaN) // true) ES6在Object原型上新增了assign()方法，用于对象新增属性或者多个对象合并 12345const target = &#123; a: 1 &#125;;const source1 = &#123; b: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; 注意: assign合并的对象target只能合并source1、source2中的自身属性，并不会合并source1、source2中的继承属性，也不会合并不可枚举的属性，且无法正确复制get和set属性（会直接执行get/set函数，取return的值） ES6在Object原型上新增了getOwnPropertyDescriptors()方法，此方法增强了ES5中getOwnPropertyDescriptor()方法，可以获取指定对象所有自身属性的描述对象。结合defineProperties()方法，可以完美复制对象，包括复制get和set属性 ES6在Object原型上新增了getPrototypeOf()和setPrototypeOf()方法，用来获取或设置当前对象的prototype对象。这个方法存在的意义在于，ES5中获取设置prototype对像是通过__proto__属性来实现的，然而__proto__属性并不是ES规范中的明文规定的属性，只是浏览器各大产商“私自”加上去的属性，只不过因为适用范围广而被默认使用了，再非浏览器环境中并不一定就可以使用，所以为了稳妥起见，获取或设置当前对象的prototype对象时，都应该采用ES6新增的标准用法 ES6在Object原型上还新增了Object.keys()，Object.values()，Object.entries()方法，用来获取对象的所有键、所有值和所有键值对数组 ES6 都有什么 Iterator 遍历器答案：Set、Map 1、遍历器（Iterator）是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员） 2、Iterator 的作用有三个： 一是为各种数据结构，提供一个统一的、简便的访问接口； 二是使得数据结构的成员能够按某种次序排列； 三是 ES6 创造了一种新的遍历命令 for…of 循环，Iterator 接口主要供 for…of 消费。 3、默认部署了 Iterator 的数据有 Array、Map、Set、String、TypedArray、arguments、NodeList 对象，ES6 中有的是 Set、Map、 Iterator是什么，有什么作用？(重要) Iterator是ES6中一个很重要概念，它并不是对象，也不是任何一种数据类型。因为ES6新增了Set、Map类型，他们和Array、Object类型很像，Array、Object都是可以遍历的，但是Set、Map都不能用for循环遍历，解决这个问题有两种方案，一种是为Set、Map单独新增一个用来遍历的API，另一种是为Set、Map、Array、Object新增一个统一的遍历API，显然，第二种更好，ES6也就顺其自然的需要一种设计标准，来统一所有可遍历类型的遍历方式。Iterator正是这样一种标准。或者说是一种规范理念 就好像JavaScript是ECMAScript标准的一种具体实现一样，Iterator标准的具体实现是Iterator遍历器。Iterator标准规定，所有部署了key值为[Symbol.iterator]，且[Symbol.iterator]的value是标准的Iterator接口函数(标准的Iterator接口函数: 该函数必须返回一个对象，且对象中包含next方法，且执行next()能返回包含value/done属性的Iterator对象)的对象，都称之为可遍历对象，next()后返回的Iterator对象也就是Iterator遍历器 123456789101112131415161718192021//obj就是可遍历的，因为它遵循了Iterator标准，且包含[Symbol.iterator]方法，方法函数也符合标准的Iterator接口规范。//obj.[Symbol.iterator]() 就是Iterator遍历器let obj = &#123; data: [ 'hello', 'world' ], [Symbol.iterator]() &#123; const self = this; let index = 0; return &#123; next() &#123; if (index &lt; self.data.length) &#123; return &#123; value: self.data[index++], done: false &#125;; &#125; else &#123; return &#123; value: undefined, done: true &#125;; &#125; &#125; &#125;; &#125;&#125;; ES6给Set、Map、Array、String都加上了[Symbol.iterator]方法，且[Symbol.iterator]方法函数也符合标准的Iterator接口规范，所以Set、Map、Array、String默认都是可以遍历的 1234567891011121314151617181920//Arraylet array = ['red', 'green', 'blue'];array[Symbol.iterator]() //Iterator遍历器array[Symbol.iterator]().next() //&#123;value: \"red\", done: false&#125;//Stringlet string = '1122334455';string[Symbol.iterator]() //Iterator遍历器string[Symbol.iterator]().next() //&#123;value: \"1\", done: false&#125;//setlet set = new Set(['red', 'green', 'blue']);set[Symbol.iterator]() //Iterator遍历器set[Symbol.iterator]().next() //&#123;value: \"red\", done: false&#125;//Maplet map = new Map();let obj= &#123;map: 'map'&#125;;map.set(obj, 'mapValue');map[Symbol.iterator]().next() &#123;value: Array(2), done: false&#125; Generator函数是什么，有什么作用？ 如果说JavaScript是ECMAScript标准的一种具体实现、Iterator遍历器是Iterator的具体实现，那么Generator函数可以说是Iterator接口的具体实现方式。 执行Generator函数会返回一个遍历器对象，每一次Generator函数里面的yield都相当一次遍历器对象的next()方法，并且可以通过next(value)方法传入自定义的value,来改变Generator函数的行为。 Generator函数可以通过配合Thunk 函数更轻松更优雅的实现异步编程和控制流管理。 Generator 遍历器对象生成函数，最大的特点是可以交出函数的执行权 function 关键字与函数名之间有一个星号； 函数体内部使用 yield表达式，定义不同的内部状态； next指针移向下一个状态 这里你可以说说 Generator的异步编程，以及它的语法糖 async 和 awiat，传统的异步编程。ES6 之前，异步编程大致如下 回调函数 事件监听 发布/订阅 传统异步编程方案之一：协程，多个线程互相协作，完成异步任务。 Class、extends是什么，有什么作用？ ES6 的class可以看作只是一个ES5生成实例对象的构造函数的语法糖。它参考了java语言，定义了一个类的概念，让对象原型写法更加清晰，对象实例化更像是一种面向对象编程。Class类可以通过extends实现继承。它和ES5构造函数的不同点 类的内部定义的所有方法，都是不可枚举的 123456789101112131415161718192021222324///ES5function ES5Fun (x, y) &#123; this.x = x; this.y = y;&#125;ES5Fun.prototype.toString = function () &#123; return '(' + this.x + ', ' + this.y + ')';&#125;var p = new ES5Fun(1, 3);p.toString();Object.keys(ES5Fun.prototype); //['toString']//ES6class ES6Fun &#123; constructor (x, y) &#123; this.x = x; this.y = y; &#125; toString () &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125;Object.keys(ES6Fun.prototype); //[] ES6的class类必须用new命令操作，而ES5的构造函数不用new也可以执行。 ES6的class类不存在变量提升，必须先定义class之后才能实例化，不像ES5中可以将构造函数写在实例化之后。 ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。 AMD，CMD，CommonJs，ES6 Module：解决原始无模块化的痛点 AMD：requirejs 在推广过程中对模块定义的规范化产出，提前执行，推崇依赖前置 CMD：seajs 在推广过程中对模块定义的规范化产出，延迟执行，推崇依赖就近 CommonJs：模块输出的是一个值的 copy，运行时加载，加载的是一个对象（module.exports 属性），该对象只有在脚本运行完才会生成 ES6 Module：模块输出的是一个值的引用，编译时输出接口，ES6模块不是对象，它对外接口只是一种静态定义，在代码静态解析阶段就会生成。 Class 的讲解class 语法相对原型、构造函数、继承更接近传统语法，它的写法能够让对象原型的写法更加清晰、面向对象编程的语法更加通俗这是 class 的具体用法。 解析：参考 ECMAScript6 怎么写class么，为什么会出现class这种东西?123456789class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '('+this.x+', '+this.y+')'; &#125;&#125; ES6 中类的定义123456// 1、类的基本定义class Parent &#123; constructor(name = \"小白\") &#123; this.name = name; &#125;&#125; 12345// 2、生成一个实例let g_parent = new Parent();console.log(g_parent); //&#123;name: \"小白\"&#125;let v_parent = new Parent(\"v\"); // 'v'就是构造函数name属性 , 覆盖构造函数的name属性值console.log(v_parent); // &#123;name: \"v\"&#125; 1234567891011// 3、继承class Parent &#123; //定义一个类 constructor(name = \"小白\") &#123; this.name = name; &#125;&#125;class Child extends Parent &#123;&#125;console.log(\"继承\", new Child()); // 继承 &#123;name: \"小白\"&#125; 12345678910111213141516// 4、继承传递参数class Parent &#123; //定义一个类 constructor(name = \"小白\") &#123; this.name = name; &#125;&#125;class Child extends Parent &#123; constructor(name = \"child\") &#123; // 子类重写name属性值 super(name); // 子类向父类修改 super一定放第一行 this.type = \"preson\"; &#125;&#125;console.log(\"继承\", new Child(\"hello\")); // 带参数覆盖默认值 继承&#123;name: \"hello\", type: \"preson\"&#125; 12345678910111213141516171819202122// 5、ES6重新定义的ES5中的访问器属性class Parent &#123; //定义一个类 constructor(name = \"小白\") &#123; this.name = name; &#125; get longName() &#123; // 属性 return \"mk\" + this.name; &#125; set longName(value) &#123; this.name = value; &#125;&#125;let v = new Parent();console.log(\"getter\", v.longName); // getter mk小白v.longName = \"hello\";console.log(\"setter\", v.longName); // setter mkhello 1234567891011121314// 6、类的静态方法class Parent &#123; //定义一个类 constructor(name = \"小白\") &#123; this.name = name; &#125; static tell() &#123; // 静态方法:通过类去调用，而不是实例 console.log(\"tell\"); &#125;&#125;Parent.tell(); // tell 1234567891011121314151617181920// 7、类的静态属性：class Parent &#123; //定义一个类 constructor(name = \"小白\") &#123; this.name = name; &#125; static tell() &#123; // 静态方法:通过类去调用，而不是实例 console.log(\"tell\"); // tell &#125;&#125;Parent.type = \"test\"; // 定义静态属性console.log(\"静态属性\", Parent.type); // 静态属性 testlet v_parent = new Parent();console.log(v_parent); // &#123;name: \"小白\"&#125; 没有tell方法和type属性 解构赋值及其原理解构赋值：其实就是分解出一个对象的解构，分成两个步骤： 变量的声明 变量的赋值 原理：ES6 变量的解构赋值本质上是“模式匹配”,只要等号两边的模式相同，左边的变量就会被赋予匹配的右边的值，如果匹配不成功变量的值就等于 undefined 解析： 一、 数组的解构赋值 123456789// 对于数组的解构赋值，其实就是获得数组的元素，而我们一般情况下获取数组元素的方法是通过下标获取，例如：let arr = [1, 2, 3];let a = arr[0];let b = arr[1];let c = arr[2];// 而数组的解构赋值给我们提供了极其方便的获取方式，如下：let [a, b, c] = [1, 2, 3];console.log(a, b, c); //1,2,3 模式匹配解构赋值 12let [foo, [[bar], baz]] = [1, [[2], 3]];console.log(foo, bar, baz); //1,2,3 省略解构赋值 12let [, , a, , b] = [1, 2, 3, 4, 5];console.log(a, b); //3,5 含剩余参数的解构赋值 12let [a, ...reset] = [1, 2, 3, 4, 5];console.log(a, reset); //1,[2,3,4,5] 其转成 ES5 的原理如下： 123var a = 1, reset = [2, 3, 4, 5];console.log(a, reset); //1,[2,3,4,5] 注意：如果剩余参数是对应的值为 undefined，则赋值为[]，因为找不到对应值的时候，是通过 slice 截取的，如下： 12let [a, ...reset] = [1];console.log(a, reset); //1,[] 其转成 ES5 的原理如下： 1234var _ref = [1], a = _ref[0], reset = _ref.slice(1);console.log(a, reset); //1,[] 非数组解构成数组(重点，难点) 一条原则：要解构成数组的前提：如果等号右边，不是数组(严格地说，不是可遍历的解构)，则直接报错，例如： 123456let [foo] = 1; //报错let [foo1] = false; //报错let [foo2] = NaN; //报错let [foo3] = undefined; //报错let [foo4] = null; //报错let [foo5] = &#123;&#125;; //报错 为什么？转成 ES5 看下原理就一清二楚了： 123456789101112var _ = 1, foo = _[0]; //报错var _false = false, foo1 = _false[0]; //报错var _NaN = NaN, foo2 = _NaN[0]; //报错var _undefined = undefined, foo3 = _undefined[0]; //报错var _ref = null;foo4 = _ref[0]; //报错var _ref2 = &#123;&#125;, foo5 = _ref2[0]; //报错 Set 的解构赋值 先执行 new Set()去重，然后对得到的结果进行解构 12let [a, b, c] = new Set([1, 2, 2, 3]);console.log(a, b, c); //1,2,3 迭代器解构 1234567891011function* fibs() &#123; let a = 0; let b = 1; while (true) &#123; yield a; [a, b] = [b, a + b]; &#125;&#125;let [first, second, third, fourth, fifth, sixth] = fibs();sixth; // 5 总结 1：只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。 解构赋值的默认值 当变量严格等于 undefined 的时候，会读取默认值，所谓的严格等于，就是“===” 123456789101112131415161718192021222324252627----------let [a,b = 'default'] = [1];console.log(a,b);//1,'default'----------let [c = 'default'] = [undefined];console.log(c);//'default'----------function f() &#123; console.log('aaa');&#125;let [x = f()] = [1];console.log(x);//1----------function f() &#123; console.log('aaa');//'aaa'&#125;let [a,x = f()] = [1];console.log(a,x);//1,undefined 总结 2：如果不使用默认值，则不会执行默认值的函数 二、对象的解构赋值 解构赋值的举例： 123456let p1 = &#123; name: \"zhuangzhuang\", age: 25&#125;;let &#123; name, age &#125; = p1; //注意变量必须为属性名console.log(name, age); //\"zhuangzhuang\",25 其转成 es5 的原理则为： 1234var _p1 = p1, name = _p1.name, age = _p1.age;console.log(name, age); //\"zhuangzhuang\",25 解构赋值的别名 如果使用别名，则不允许再使用原有的解构出来的属性名，看以下举例则会明白： 1234567let p1 = &#123; name: \"zhuangzhuang\", age: 25&#125;;let &#123; name: aliasName, age: aliasAge &#125; = p1; //注意变量必须为属性名console.log(aliasName, aliasAge); //\"zhuangzhuang\",25console.log(name, age); //Uncaught ReferenceError: age is not defined 为何打印原有的属性名则会报错？让我们看看转成 es5 后的原理是如何实现的： 12345var _p1 = p1, aliasName = _p1.name, aliasAge = _p1.age;console.log(aliasName, aliasAge); //\"zhuangzhuang\",25console.log(name, age); //所以打印name和age会报错——“Uncaught ReferenceError: age is not defined”，但是为何只报错age，不报错name呢？ 只报错 age，不报错 name，这说明其实 name 是存在的，那么根据 js 的解析顺序，当在当前作用域 name 无法找到时，会向上找，直到找到 window 下的 name,而我们打印 window 可以发现，其下面确实有一个 name，值为“”，而其下面并没有属性叫做 age，所以在这里 name 不报错，只报 age 的错。类似 name 的属性还有很多，比如 length 等。 解构赋值的默认值 有些情况下，我们解构出来的值并不存在，所以需要设定一个默认值，例如： 12345let obj = &#123; name: \"zhuangzhuang\"&#125;;let &#123; name, age &#125; = obj;console.log(name, age); //\"zhuangzhuang\",undefined 我们可以看到当 age 这个属性并不存在于 obj 的时候，解构出来的值为 undefined，那么为了避免这种尴尬的情况，我们常常会设置该属性的默认值，如下： 12345let obj = &#123; name: \"zhuangzhuang\"&#125;;let &#123; name, age = 18 &#125; = obj;console.log(name, age); //\"zhuangzhuang\",18 当我们取出来的值不存在，即为 undefined 的时候，则会取默认值(假设存在默认值)，ES6 的默认值是使用“变量=默认值”的方式。 注意：只有当为 undefined 的时候才会取默认值，null 等均不会取默认值 12345678let obj = &#123; name: \"zhuangzhuang\", age: 27, gender: null, //假设未知使用null isFat: false&#125;;let &#123; name, age = 18, gender = \"man\", isFat = true, hobbies = \"study\" &#125; = obj;console.log(name, age, gender, isFat, hobbies); //\"zhuangzhuang\"，27，null，false，\"study\" 解构赋值的省略赋值 当我们并不是需要取出所有的值的时候，其实可以省略一些变量，这就是省略赋值，如下 123let arr = [1, 2, 3];let [, , c] = arr;console.log(c); //3 注意：省略赋值并不存在与对象解构，因为对象解构，明确了需要的属性 1234567let obj = &#123; name: \"zhuangzhuang\", age: 27, gender: \"man\"&#125;;let &#123; age &#125; = obj;console.log(age); //27 解构赋值的嵌套赋值(易错点，重点，难点) 12345let obj = &#123;&#125;, arr = [];(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: true &#125;);console.log(obj, arr); //&#123;prop:123&#125;,[true] 注意当解构出来是 undefined 的时候，如果再给子对象的属性，则会报错，如下 12345678let &#123; foo: &#123; bar &#125;&#125; = &#123; baz: \"baz\" &#125;;//报错，原因很简单，看下原理即可，如下：//原理:let obj = &#123; baz: \"baz\" &#125;;let foo = obj.foo; //foo为undefinedlet bar = foo.bar; //undefined的bar，可定报错 {}是块还是对象？ 当我们写解构赋值的时候，很容易犯一个错误——{}的作用是块还是对象混淆，举例如下： 12345678//举例一：let &#123;a&#125; = &#123;a:\"a\"&#125;;console.loh(a);//'a',这个很简单//很多人觉得，以下这种写法也是可以的：let a;&#123;a&#125; = &#123;a:\"a\"&#125;;//直接报错，因为此时a已经声明过了，在语法解析的时候，会将这一行的&#123;&#125;看做块结构，而“块=对象”，显然是语法错误，所以正确的做法是不将大括号写在开头，如下：let a;(&#123;a&#125; = &#123;a:\"a\"&#125;) 空解构 按照之前写的，解构赋值，左边则为解构出来的属性名，当然，在这里，我们也可以不写任何属性名称，也不会又任何的语法错误，即便这样没有任何意义，如下： 123(&#123;&#125; = [true, false]);(&#123;&#125; = \"abc\");(&#123;&#125; = []); 解构成对象的原则 如果解构成对象，右侧不是 null 或者 undefined 即可!之前说过，要解构成数组，右侧必须是可迭代对象，但是如果解构成对象，右侧不是 null 活着 undefined 即可! 三、字符串的解构赋值 字符串也是可以解构赋值的 12const [a, b, c, d, e] = \"hello\";console.log(a, b, c, d, e); //'h','e','l','l','o' 转成 es5 的原理如下: 123456var _hello = \"hello\", a = _hello[0], b = _hello[1], c = _hello[2];console.log(a, b, c); 注意：字符串有一个属性 length，也可以被解构出来，但是要注意，解构属性一定是对象解构 12let &#123; length &#125; = \"hello\";console.log(length); //5 布尔值和数值的解构 布尔值和数值的解构，其实就是对其包装对象的解构，取的是包装对象的属性 12345&#123;toString:s&#125; = 123;console.log(s);//s === Number.prototype.toString&#123;toString:s&#125; = true;console.log(s);//s === Boolean.prototype.toString 总结：解构赋值的规则是： 解构成对象，只要等号右边的值不是对象或数组，就先将其转为对象。由于 undefined 和 null 无法转为对象，所以对它们进行解构赋值，都会报错。 解构成数组，等号右边必须为可迭代对象 参考 Array.from() 与 Array.reduce()Array.from()方法就是将一个类数组对象或者可遍历对象转换成一个真正的数组Array.reduce()方法对累加器和数组中的每个元素 (从左到右)应用一个函数，将其减少为单个值。 解析： Array.from() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 那么什么是类数组对象呢？所谓类数组对象，最基本的要求就是具有length属性的对象。// 1、将类数组对象转换为真正数组：let arrayLike = &#123; 0: \"tom\", 1: \"65\", 2: \"男\", 3: [\"jane\", \"john\", \"Mary\"], length: 4&#125;;let arr = Array.from(arrayLike);console.log(arr); // ['tom','65','男',['jane','john','Mary']]// 那么，如果将上面代码中length属性去掉呢？实践证明，答案会是一个长度为0的空数组。// 这里将代码再改一下，就是具有length属性，但是对象的属性名不再是数字类型的，而是其他字符串型的，代码如下：let arrayLike = &#123; name: \"tom\", age: \"65\", sex: \"男\", friends: [\"jane\", \"john\", \"Mary\"], length: 4&#125;;let arr = Array.from(arrayLike);console.log(arr); // [ undefined, undefined, undefined, undefined ]// 会发现结果是长度为4，元素均为undefined的数组// 由此可见，要将一个类数组对象转换为一个真正的数组，必须具备以下条件：// 1、该类数组对象必须具有length属性，用于指定数组的长度。如果没有length属性，那么转换后的数组是一个空数组。// 2、该类数组对象的属性名必须为数值型或字符串型的数字// ps: 该类数组对象的属性名可以加引号，也可以不加引号// 2、将Set结构的数据转换为真正的数组：let arr = [12, 45, 97, 9797, 564, 134, 45642];let set = new Set(arr);console.log(Array.from(set)); // [ 12, 45, 97, 9797, 564, 134, 45642 ]// Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。如下：let arr = [12, 45, 97, 9797, 564, 134, 45642];let set = new Set(arr);console.log(Array.from(set, item =&gt; item + 1)); // [ 13, 46, 98, 9798, 565, 135, 45643 ]// 3、将字符串转换为数组：let str = \"hello world!\";console.log(Array.from(str)); // [\"h\", \"e\", \"l\", \"l\", \"o\", \" \", \"w\", \"o\", \"r\", \"l\", \"d\", \"!\"]// 4、Array.from参数是一个真正的数组：console.log(Array.from([12, 45, 47, 56, 213, 4654, 154]));// 像这种情况，Array.from会返回一个一模一样的新数组 参考 Array.reduce() 12345678910111213语法：array.reduce(function(accumulator, currentValue, currentIndex, array), initialValue)；accumulator：累加器，即函数上一次调用的返回值。第一次的时候为 initialValue || arr[0]currentValue：数组中函数正在处理的的值。第一次的时候initialValue || arr[1]currentIndex：数据中正在处理的元素索引，如果提供了 initialValue ，从0开始；否则从1开始array： 调用 reduce 的数组initialValue：可选项，累加器的初始值。没有时，累加器第一次的值为currentValue；注意：在对没有设置初始值的空数组调用reduce方法时会报错。 1234//无初始值[1, 2, 3, 4].reduce(function(accumulator, currentValue, currentIndex, array) &#123; return accumulator + currentValue;&#125;); // 10 callback accumulator currentValue currentIndex array return value first call 1(数组第一个元素) 2(数组第二个元素) 1(无初始值为 1) [1, 2, 3, 4] 3 second call 3 3 2 [1, 2, 3, 4] 6 third call 6 4 3 [1, 2, 3, 4] 10 1234//有初始值[1, 2, 3, 4].reduce(function(accumulator, currentValue, currentIndex, array) &#123; return accumulator + currentValue;&#125;, 10); // 20 callback accumulator currentValue currentIndex array return value first call 10(初始值) 1(数组第一个元素) 0(有初始值为 0) [1, 2, 3, 4] 11 second call 11 2 1 [1, 2, 3, 4] 13 third call 13 3 2 [1, 2, 3, 4] 16 fourth call 16 4 3 [1, 2, 3, 4] 20 1234567891011121314151617181920212223242526272829303132333435363738//1.数组元素求和[1, 2, 3, 4].reduce((a, b) =&gt; a + b); //10//2.二维数组转化为一维数组[[1, 2], [3, 4], [5, 6]] .reduce((a, b) =&gt; a.concat(b), []) //[1, 2, 3, 4, 5, 6] [ //3.计算数组中元素出现的次数 (1, 2, 3, 1, 2, 3, 4) ].reduce((items, item) =&gt; &#123; if (item in items) &#123; items[item]++; &#125; else &#123; items[item] = 1; &#125; return items; &#125;, &#123;&#125;) //&#123;1: 2, 2: 2, 3: 2, 4: 1&#125; [ //数组去重① (1, 2, 3, 1, 2, 3, 4, 4, 5) ].reduce((init, current) =&gt; &#123; if (init.length === 0 || init.indexOf(current) === -1) &#123; init.push(current); &#125; return init; &#125;, []) //[1, 2, 3, 4, 5] [ //数组去重② (1, 2, 3, 1, 2, 3, 4, 4, 5) ].sort() .reduce((init, current) =&gt; &#123; if (init.length === 0 || init[init.length - 1] !== current) &#123; init.push(current); &#125; return init; &#125;, []); //[1, 2, 3, 4, 5] 参考","categories":[{"name":"前端面试题","slug":"前端面试题","permalink":"https://qw8.github.io/categories/前端面试题/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qw8.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://qw8.github.io/tags/ES6/"}]},{"title":"HTML知识点","slug":"knowledges/HTML知识点","date":"2020-07-28T04:12:12.000Z","updated":"2023-04-14T17:01:50.000Z","comments":true,"path":"/knowledges/html-zhi-shi-dian.html","link":"","permalink":"https://qw8.github.io/knowledges/html-zhi-shi-dian.html","excerpt":"","text":"HTML5语义化标签 标签 描述 页面独立的内容区域。 页面的侧边栏内容。 允许您设置一段文本，使其脱离其父元素的文本方向设置。 命令按钮，比如单选按钮、复选框或按钮 用于描述文档或文档某个部分的细节 对话框，比如提示框 标签包含 details 元素的标题 规定独立的流内容（图像、图表、照片、代码等等）。 元素的标题 section 或 document 的页脚。 文档的头部区域 带有记号的文本。 度量衡。仅用于已知最大和最小值的度量。 导航链接的部分。 任何类型的任务的进度。 ruby 注释（中文注音或字符）。 字符（中文注音或字符）的解释或发音。 在 ruby 注释中使用，不支持 ruby 元素的浏览器所显示的内容。 文档中的节（section、区段）。 日期或时间。 规定在文本中的何处适合添加换行符。 语义化标签的使用&lt;title&gt;&lt;/title&gt; 页面主要内容（1） 标签的特点是简短、描述性、唯一，用于提升搜索引擎排名。 （2）搜索引擎会把 title 作为判断页面主要内容的指标，有效的 title 应该包含几个与页面内容密切相关的关键字，建议将 title 的核心内容写在前 60 个字符。 &lt;header&gt;&lt;/header&gt; 页眉（1）HTML5 规范描述为“一组解释性或导航型性的条目”，通常有网站标志、主导航、全站链接以及搜索框。 &lt;nav&gt;&lt;/nav&gt; 导航（1）页面的导航链接区域，用于定义页面的主要导航部分。 （2）导航通常使用 ** 无序列表。若是面包屑链接，则使用 ** 有序列表。 （3）HTML5 规范不推荐对辅助页脚链接使用 nav，除非页脚再次显示顶级全局导航、或者是招聘信息等重要链接。 &lt;main&gt;&lt;/main&gt; 主要内容（1）网站页面的主要内容，并且一个页面只能使用一次 标签。 （2）若是 web 应用，则包含其主要功能。 &lt;article&gt;&lt;/article&gt; 文章标记（1）表示的是一个文档、页面、应用或是网站中的一个独立的容器。 （2）HTML5 规范声明 标签适用于自包含的窗口小部件:股票行情，计算器，钟表，天气窗口小部件等。 （3）这个标签可以嵌套使用，但是他们必须是部分与整体的关系。 &lt;section&gt;&lt;/section&gt; 区块（1）一组相似主题的内容，一般会有一个标题。 （2）实现比如文章的章节，标签式对话框中的各种标签页等功能。 &lt;aside&gt;&lt;/aside&gt; 侧边栏（1）表示一部分内容与页面的主体并没有较大的关系，并且可以独立存在。 （2）实现比如升式引用、侧边栏、相关文章的链接、广告、友情链接等功能。 &lt;footer&gt;&lt;/footer&gt; 页脚（1）和 标签对应，可以实现比如附录、索引、版权页、许可协议等功能。 &lt;cite&gt;&lt;/cite&gt; 引用（1）表示它所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题。 （2）按照惯例，引用的文本将以斜体显示。 （3）用 标签把指向其他文档的引用分离出来，尤其是分离那些传统媒体中的文档，如书籍、杂志、期刊，等等。 &lt;blockquote&gt;&lt;/blockquote&gt; 块引用（1） 与 之间的所有文本都会从常规文本中分离出来，经常会在左、右两边进行缩进（增加外边距），而且有时会使用斜体。也就是说，块引用拥有它们自己的空间。 &lt;q&gt;&lt;/q&gt; 短的引用（1）浏览器经常在引用的内容周围添加引号。 （2）根据 HTML 4.01 规范，q 元素应当使用分界引号来呈现，就是说，q 元素包含的文本必须以引号来开始和结束。 &lt;time&gt;&lt;/time&gt; 日期或时间（1）如果未定义 datetime 属性，则必须在元素的内容中规定日期或时间。 &lt;abbr&gt;&lt;/abbr&gt;简称或缩写（1）通过对缩写进行标记，您能够为浏览器、拼写检查和搜索引擎提供有用的信息。 （2）可以在 标签中使用全局的 title 属性，这样就能够在鼠标指针移动到 元素上时显示出简称/缩写的完整版本。 &lt;dfn&gt;&lt;/dfn&gt; 特殊术语或短语的定义（1）现在流行的浏览器通常用斜体来显示 中的文本。 （2）与其他许多基于内容的样式和物理样式标签一样， 标签尽量少用为妙。 ~~~~ 删除的文本（1）和 标签配合使用，来描述文档中的更新和修正。 &lt;ins&gt;&lt;/ins&gt; 插入文本`` 源代码（1）用于表示计算机源代码或者其他机器可以阅读的文本内容。 &lt;pre&gt;&lt;/pre&gt;·预格式化的文本（1）被包围在 pre 元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体。 （2）若使用 标签来定义计算机源代码，比如 HTML 源代码，则使用符号实体来表示特殊字符，比如 \"\"，\"&\" 代表 \"&\"。","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://qw8.github.io/tags/HTML/"},{"name":"语义化","slug":"语义化","permalink":"https://qw8.github.io/tags/语义化/"}]},{"title":"HTML","slug":"knowledges/HTML","date":"2020-07-26T03:11:11.000Z","updated":"2023-04-14T17:01:50.000Z","comments":true,"path":"/knowledges/html.html","link":"","permalink":"https://qw8.github.io/knowledges/html.html","excerpt":"","text":"HTML是什么HTML的全称为超文本标记语言，是一种标记语言。它包括一系列标签．通过这些标签可以将网络上的文档格式统一，使分散的资源连接为一个逻辑整体。HTML文本是由HTML命令组成的描述性文本。 HTML中元素分类HTML中元素可分：行内元素(inline)、块级元素(block) 行内元素(inline)行内元素也称为内联元素，行内元素不占有独立区域，其大小仅仅被动的依赖于自身内容的大小（例如文字和图片），所以一般不能随意设置其宽高、对齐等属性。 行内元素的特点： 总是和相邻的行内元素在同一行上。 设置宽高无效，水平方向的padding和margin属性可以设置，但是垂直方向上的无效。 默认宽度是他自身内容的宽度。 行内元素只能容纳其他行内元素或者文本。 常见的行内元素：123&lt;span&gt;、&lt;a&gt;、&lt;b&gt;、&lt;i&gt;、&lt;u&gt;、&lt;li&gt;、&lt;em&gt;、&lt;strong&gt;&lt;img&gt;、&lt;input&gt;、&lt;button&gt;、&lt;textarea&gt;、&lt;select&gt;、&lt;section&gt;、&lt;label&gt;&lt;sup&gt;、&lt;sub&gt;、&lt;big&gt;、&lt;small&gt;、&lt;ins&gt;、&lt;del&gt;、&lt;code&gt;、&lt;cite&gt;、&lt;dfn&gt;、&lt;kbd&gt;、&lt;var&gt; 块级元素(block)块级元素占据其父元素（容器）的整个水平空间，垂直空间等于其内容高度，因此创建了一个“块” 块级元素的特点： 总是在新行上开始； 高度，行高以及外边距和内边距都可控制； 宽度缺省是它的容器的100%，除非设定一个宽度。 它可以容纳内联元素和其他块元素 常见的块级元素：12345&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;~&lt;h6&gt;&lt;nav&gt;、&lt;aside&gt;、&lt;header&gt;、&lt;footer&gt;、&lt;section&gt;、&lt;article&gt;&lt;ul&gt;、&lt;li&gt;、&lt;ol&gt;、&lt;dl&gt;、&lt;dt&gt;、&lt;dd&gt;&lt;form&gt;、&lt;address&gt;、&lt;caption&gt;&lt;table&gt;、&lt;thead&gt;、&lt;tbody&gt;、&lt;tfoot&gt;、&lt;td&gt;、&lt;th&gt;、&lt;tr&gt; 行内元素与块级元素的区别？HTML4中，元素被分成两大类：inline （内联元素）与 block （块级元素）。 （1） 格式上，默认情况下，行内元素不会以新行开始，而块级元素会新起一行。（2） 内容上，默认情况下，行内元素只能包含文本和其他行内元素。而块级元素可以包含行内元素和其他块级元素。（3） 行内元素与块级元素属性的不同，主要是盒模型属性上：行内元素设置 width 无效，height 无效（可以设置 line-height），设置 margin 和 padding 的上下不会对其他元素产生影响。 空元素定义 标签内没有内容的 HTML 标签被称为空元素。空元素是在开始标签中关闭的。 常见的空元素有： 1&lt;br&gt;、&lt;hr&gt;、&lt;img&gt;、&lt;input&gt;、&lt;link&gt;、&lt;meta&gt; HTML5 元素的分类 HTML4中，元素被分成两大类: inline（内联元素）与 block（块级元素）。但在实际的开发过程中，因为页面表现的需要，前端工程师经常把 inline 元素的 display 值设定为 block （比如 a 标签），也经常把 block 元素的 display 值设定为inline 之后更是出现了 inline-block 这一对外呈现 inline 对内呈现 block 的属性。因此，简单地把 HTML 元素划分为inline 与 block 已经不再符合实际需求。 HTML5中，元素主要分为7类：Metadata Flow Sectioning Heading Phrasing Embedded Interactive 简述一下你对 HTML 语义化的理解？ （1） html 语义化主要指的是我们应该使用合适的标签来划分网页内容的结构; （2） html 语义化让页面的内容结构化，结构更清晰，易于理解，便于对浏览器、搜索引擎解析; （3） 即使在去掉或者丢失样式 CSS 情况下也以一种文档格式显示，呈现出清晰的结构，并且是容易阅读的; （4） 有助于爬虫抓取更多的有效信息，搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，有利于 SEO ; （5） 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。便于团队开发和维护，语义化更具可读性，遵循W3C标准的团队都遵循这个标准，可以减少差异化 （6) 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页 回答： 比如说我们常用的 b 标签和 strong 标签，它们在样式上都是文字的加粗，但是 strong 标签拥有强调的语义。 对于一般显示来说，可能我们看上去没有差异，但是对于机器来说，就会有很大的不同。如果用户使用的是屏幕阅读器来访问网页的话，使用 strong 标签就会有明显的语调上的变化，而 b 标签则没有。如果是搜索引擎的爬虫对我们网页进行分析的话，那么它会依赖于 html 标签来确定上下文和各个关键字的权重，一个语义化的文档对爬虫来说是友好的，是有利于爬虫对文档内容解读的，从而有利于我们网站的 SEO 。从 html5 我们可以看出，标准是倾向于以语义化的方式来构建网页的，比如新增了 header 、footer 这些语义标签，删除了 big 、font 这些没有语义的标签。 详细资料可以参考： 《语义化的 HTML 结构到底有什么好处？》 《如何理解 Web 语义化？》 《我的 HTML 会说话——从实用出发，谈谈 HTML 的语义化》 html5有哪些新特性、移除了那些元素？HTML5 现在已经不是 SGML的子集，主要是关于图像，位置，存储，多任务等功能的增加 新增功能 用于媒介回放的 video 和 audio 元素; 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失; sessionStorage 的数据在浏览器关闭后自动删除; 语意化更好的内容元素，比如 article、footer、header、nav、section、aside; 表单控件，calendar、date、time、email、url、search 新的技术webworker, websocket, Geolocation 新的文档属性 document.visibilityState 拖拽释放(Drag and drop) API 地理(Geolocation) API 画布(Canvas) API; 移除的元素： 纯表现的元素：basefont，big，center，font, s，strike，tt，u; 对可用性产生负面影响的元素：frame，frameset，noframes 如何处理HTML5新标签的浏览器兼容问题？支持HTML5新标签： IE8/IE7/IE6支持通过document.createElement方法产生的标签，可以利用这一特性让这些浏览器支持HTML5新标签， 浏览器支持新标签后，还需要添加标签默认的样式： 当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架 1&lt;!--[if lt IE 9]&gt; src=\"http://html5shim.googlecode.com/svn/trunk/html5.js\" &lt;![endif]–&gt; 123456789101112131415161718### HTML和HTML5的区别#### 什么是HTML？HTML全称为超文本标记语言(Hyper Text Markup Language)，它包括一系列标签，通过这些标签可以将网络上的文档格式统一，使分散的Internet资源连接为一个逻辑整体。#### 什么是HTML5?HTML5是HTML的第五个版本，HTML5已经远远超越了标记语言的范畴，它的设计目的是在移动设备上支持多媒体，和HTML比起来，深度和广度上都做了进一步提升。HTML5更方便书写、精简，有利于程序员快速的阅读和开发。#### 区别：1.文档声明 HTML： 12或 12HTML5： 122.结构语义 HTML：没有体现结构语义化的标签，如HTML5：添加了许多具有语义化的标签，如、、、、… 123456789101112131415161718192021223.绘图方式HTML：指可伸缩矢量图形，用于定义网络的基于矢量的图形。HTML5：HTML5的canvas元素使用脚本（通常使用JavaScript）在网页上绘制图像，可以控制画布每一个像素。4.音频和视频支持HTML如果不使用Flash播放器支持，它不支持音频和视频。HTML5使用&lt;audio&gt;和&lt;video&gt;标签来支持音频和视频控制。5.语法处理HTML无法处理不准确的语法。HTML5能够处理不准确的语法。### DOCTYPE 的作用是什么？ 相关知识点： IE5.5 引入了文档模式的概念，而这个概念是通过使用文档类型（DOCTYPE）切换实现的。 声明位于 HTML 文档中的第一行，处于 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。 DOCTYPE 不存在或格式不正确会导致文档以兼容模式呈现。 12回答（参考1-5）： 声明一般位于文档的第一行，它的作用主要是告诉浏览器以什么样的模式来解析文档。一般指定了之后会以标准模式来 进行文档解析，否则就以兼容模式进行解析。在标准模式下，浏览器的解析规则都是按照最新的标准进行解析的。而在兼容模式下，浏 览器会以向后兼容的方式来模拟老式浏览器的行为，以保证一些老的网站的正确访问。 在 html5 之后不再需要指定 DTD 文档，因为 html5 以前的 html 文档都是基于 SGML 的，所以需要通过指定 DTD 来定义文 档中允许的属性以及一些规则。而 html5 不再基于 SGML 了，所以不再需要使用 DTD。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350### 标准模式与兼容模式各有什么区别？标准模式的渲染方式和 JS 引擎的解析方式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。### HTML5 为什么只需要写 `&lt;!DOCTYPE HTML&gt;`，而不需要引入 DTD？HTML5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 DOCTYPE 来规范浏览器的行为（让浏览器按照它们应该的方式来运行）。而 HTML4.01 基于 SGML ，所以需要对 DTD 进行引用，才能告知浏览器文档所使用的文档类型。### SGML 、 HTML 、XML 和 XHTML 的区别？SGML（Standard Generalized Markup language）是标准通用置标语言，是一种定义电子文档结构和描述其内容的国际标准语言，是所有电子文档标记语言的起源。HTML（HyperText Markup Language）是超文本标记语言，主要是用于规定怎么显示网页。XML（Extensible Markup Language）是可扩展标记语言是未来网页语言的发展方向，XML 和 HTML 的最大区别就在于 XML 的标签是可以自己创建的，数量无限多，而 HTML 的标签都是固定的而且数量有限。XHTML（Extensible Hypertext Markup Language）也是现在基本上所有网页都在用的标记语言，他其实和 HTML 没什么本质的区别，标签都一样，用法也都一样，就是比 HTML 更严格，比如标签必须都用小写，标签都必须有闭合标签等。### DTD 介绍DTD（ Document Type Definition 文档类型定义）是一组机器可读的规则，它们定义 XML 或 HTML 的特定版本中所有允许元素及它们的属性和层次关系的定义。在解析网页时，浏览器将使用这些规则检查页面的有效性并且采取相应的措施。DTD 是对 HTML 文档的声明，还会影响浏览器的渲染模式（工作模式）。### link 标签定义 link 标签定义文档与外部资源的关系。 link 元素是空元素，它仅包含属性。 此元素只能存在于 head 部分，不过它可出现任何次数。 link 标签中的 rel 属性定义了当前文档与被链接文档之间的关系。常见的 stylesheet 指的是定义一个外部加载的样式表。### 页面导入样式时，使用 link 和 @import 有什么区别？ （1）从属关系区别。 @import 是 CSS 提供的语法规则，只有导入样式表的作用；link 是 HTML 提供的标签，不仅可以加 载 CSS 文件，还可以定义 RSS、rel 连接属性、引入网站图标等。 （2）加载顺序区别。加载页面时，link 标签引入的 CSS 被同时加载；@import 引入的 CSS 将在页面加载完毕后被加载。 （3）兼容性区别。@import 是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link 标签作为 HTML 元素，不存在兼容 性问题。 （4）DOM 可控性区别。可以通过 JS 操作 DOM ，插入 link 标签来改变样式；由于 DOM 方法是基于文档的，无法使用 @i mport 的方式插入样式。### 你对浏览器的理解？ 浏览器的主要功能是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常 是 HTML，也包括 PDF、image 及其他格式。用户用 URI（Uniform Resource Identifier 统一资源标识符）来指定所请 求资源的位置。 HTML 和 CSS 规范中规定了浏览器解释 html 文档的方式，由 W3C 组织对这些规范进行维护，W3C 是负责制定 web 标准的 组织。 但是浏览器厂商纷纷开发自己的扩展，对规范的遵循并不完善，这为 web 开发者带来了严重的兼容性问题。 简单来说浏览器可以分为两部分，shell 和 内核。 其中 shell 的种类相对比较多，内核则比较少。shell 是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作， 参数设置等等。它是调用内核来实现各种功能的。内核才是浏览器的核心。内核是基于标记语言显示内容的程序或模块。也有一些 浏览器并不区分外壳和内核。从 Mozilla 将 Gecko 独立出来后，才有了外壳和内核的明确划分。### 介绍一下你对浏览器内核的理解？ 主要分成两部分：渲染引擎和 JS 引擎。 渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也 可以借助插件（一种浏览器扩展）显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。 JS 引擎：解析和执行 javascript 来实现网页的动态效果。 最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。### 常见的浏览器内核比较 Trident：这种浏览器内核是 IE 浏览器用的内核，因为在早期 IE 占有大量的市场份额，所以这种内核比较流行，以前有很多 网页也是根据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好。但是由于 IE 的高市场占有率，微 软也很长时间没有更新 Trident 内核，就导致了 Trident 内核和 W3C 标准脱节。还有就是 Trident 内核的大量 Bug 等 安全问题没有得到解决，加上一些专家学者公开自己认为 IE 浏览器不安全的观点，使很多用户开始转向其他浏览器。 Gecko：这是 Firefox 和 Flock 所采用的内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩 展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。 Presto：Opera 曾经采用的就是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的 天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快3倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。 Webkit：Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和 Trid ent，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。WebKit 前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。 Blink：谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 B link 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实 Blink 引擎就是 Webkit 的一个分支，就像 webkit 是 KHTML 的分支一样。Blink 引擎现在是谷歌公司与 Opera Software 共同研发，上面提到过的，Opera 弃用了自己的 Presto 内核，加入 Google 阵营，跟随谷歌一起研发 Blink。 详细的资料可以参考： [《浏览器内核的解析和对比》](http://www.cnblogs.com/fullhouse/archive/2011/12/19/2293455.html) [《五大主流浏览器内核的源起以及国内各大浏览器内核总结》](https://blog.csdn.net/Summer_15/article/details/71249203)### 常见浏览器所用内核​ （1） IE 浏览器内核：Trident 内核，也是俗称的 IE 内核；​ （2） Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink内核；​ （3） Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核；​ （4） Safari 浏览器内核：Webkit 内核；​ （5） Opera 浏览器内核：最初是自己的 Presto 内核，后来加入谷歌大军，从 Webkit 又到了 Blink 内核；​ （6） 360浏览器、猎豹浏览器内核：IE + Chrome 双内核；​ （7） 搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）；​ （8） 百度浏览器、世界之窗内核：IE 内核；​ （9） 2345浏览器内核：好像以前是 IE 内核，现在也是 IE + Chrome 双内核了；​ （10）UC 浏览器内核：这个众口不一，UC 说是他们自己研发的 U3 内核，但好像还是基于 Webkit 和 Trident ，还有说​ 是基于火狐内核。### 浏览器的渲染原理？​ （1）首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。​ （2）然后对 CSS 进行解析，生成 CSSOM 规则树。​ （3）根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩​ 形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM ​ 元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。​ （4）当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也​ 可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动​ 重排”。​ （5）布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组​ 件。​ 值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的​ html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其​ 余内容。 详细资料可以参考： [《浏览器渲染原理》](https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc7207f265da613c09425d) [《浏览器的渲染原理简介》](https://coolshell.cn/articles/9666.html) [《前端必读：浏览器内部工作原理》](https://kb.cnblogs.com/page/129756/) [《深入浅出浏览器渲染原理》](https://blog.fundebug.com/2019/01/03/understand-browser-rendering/)### 渲染过程中遇到 JS 文件怎么处理？（浏览器解析过程）​ JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么​ 它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解​ 析文档。​ 也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的​ 原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。### async 和 defer 的作用是什么？有什么区别？（浏览器解析过程）​ （1）脚本没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执​ 行。​ （2）defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。​ 当整个 document 解析完毕后再执行脚本文件，在 DOMContentLoaded 事件触发之前完成。多个脚本按顺序执行。​ （3）async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执​ 行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。多个脚本的执行顺序无法保证。 详细资料可以参考： [《defer 和 async 的区别》](https://segmentfault.com/q/1010000000640869)### 什么是文档的预解析？（浏览器解析过程） Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加 载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析 过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。### CSS 如何阻塞文档解析？（浏览器解析过程） ​ 理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们，然而，存在一个问题，JavaScript 脚本执行时可​ 能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。​ 所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档​ 的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，​ 最后再继续文档的解析。### 渲染页面时常见哪些不良现象？（浏览器渲染过程）​ FOUC：主要指的是样式闪烁的问题，由于浏览器渲染机制（比如firefox），在 CSS 加载之前，先呈现了 HTML，就会导致展示​ 出无样式内容，然后样式突然呈现的现象。会出现这个问题的原因主要是 CSS 加载时间过长，或者 CSS 被放在了文档底​ 部。​ 白屏：有些浏览器渲染机制（比如chrome）要先构建 DOM 树和 CSSOM 树，构建完成后再进行渲染，如果 CSS 部分放在 HTML ​ 尾部，由于 CSS 未加载完成，浏览器迟迟未渲染，从而导致白屏；也可能是把 JS 文件放在头部，脚本的加载会阻塞后面​ 文档内容的解析，从而页面迟迟未渲染出来，出现白屏问题。 详细资料可以参考： [《前端魔法堂：解秘 FOUC》](https://juejin.im/entry/58f867045c497d0058e2ff3a) [《白屏问题和 FOUC》](https://www.jianshu.com/p/6617efa874b0)### 如何优化关键渲染路径？（浏览器渲染过程）​ 为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：​ （1）关键资源的数量。​ （2）关键路径长度。​ （3）关键字节的数量。​ 关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。​ 同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，​ 并且资源越大，下载所需的往返次数就越多。​ 最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它​ 们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。​ 优化关键渲染路径的常规步骤如下：​ （1）对关键路径进行分析和特性描述：资源数、字节数、长度。​ （2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。​ （3）优化关键字节数以缩短下载时间（往返次数）。​ （4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度。 详细资料可以参考： [《优化关键渲染路径》](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/optimizing-critical-rendering-path?hl=zh-cn)### 什么是重绘和回流？（浏览器绘制过程）​ 重绘: 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 background​ -color，我们将这样的操作称为重绘。​ ​ 回流：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样​ 的操作我们称为回流。​ 常见引起回流属性和方法：​ 任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。​ （1）添加或者删除可见的 DOM 元素；​ （2）元素尺寸改变——边距、填充、边框、宽度和高度​ （3）内容变化，比如用户在 input 框中输入文字​ （4）浏览器窗口尺寸改变——resize事件发生时​ （5）计算 offsetWidth 和 offsetHeight 属性​ （6）设置 style 属性的值​ （7）当你修改网页的默认字体时。​ 回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列​ 回流。 常见引起重绘属性和方法： ![常见引起回流属性和方法](https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-14.png) 常见引起回流属性和方法： ![常见引起重绘属性和方法](https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-13.png) 详细资料可以参考： [《浏览器的回流与重绘》](https://juejin.im/post/5a9923e9518825558251c96a)### 如何减少回流？（浏览器绘制过程）​ （1）使用 transform 替代 top​ （2）不要把节点的属性值放在一个循环里当成循环里的变量​ （3）不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局​ （4）把 DOM 离线后修改。如：使用 documentFragment 对象在内存里操作 DOM​ （5）不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。### 为什么操作 DOM 慢？（浏览器绘制过程） 一些 DOM 的操作或者属性访问可能会引起页面的回流和重绘，从而引起性能上的消耗。### DOMContentLoaded 事件和 Load 事件的区别？​ 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和​ 子框架的加载完成。​ Load 事件是当所有资源加载完成后触发的。 详细资料可以参考： [《DOMContentLoaded 事件 和 Load 事件的区别？》](https://www.jianshu.com/p/ca8dae435a2c)### 如何处理 HTML5 新标签的浏览器兼容问题？ ```html （1） IE8/IE7/IE6 支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器 支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式。 （2） 当然也可以直接使用成熟的框架，比如 html5shiv ; `&lt;!--[if lt IE 9]&gt; &lt;script&gt; src=&quot;https://cdn.jsdelivr.net/npm/html5shiv/dist/html5shiv.min.js&quot;&lt;/script&gt; &lt;![endif]--&gt;` [if lte IE 9]……[endif] 判断 IE 的版本，限定只有 IE9 以下浏览器版本需要执行的语句。 b 与 strong 的区别和 i 与 em 的区别？ 1234从页面显示效果来看，被 &lt;b&gt; 和 &lt;strong&gt; 包围的文字将会被加粗，而被 &lt;i&gt; 和 &lt;em&gt; 包围的文字将以斜体的形式呈现。但是 &lt;b&gt; &lt;i&gt; 是自然样式标签，分别表示无意义的加粗，无意义的斜体，表现样式为 &#123; font-weight: bolder&#125;，仅仅表示「这里应该用粗体显示」或者「这里应该用斜体显示」，此两个标签在 HTML4.01 中并不被推荐使用。而 &lt;em&gt; 和 &lt;strong&gt; 是语义样式标签。 &lt;em&gt; 表示一般的强调文本，而 &lt;strong&gt; 表示比 &lt;em&gt; 语义更强的强调文本。使用阅读设备阅读网页时：&lt;strong&gt; 会重读，而 &lt;b&gt; 是展示强调内容。 详细资料可以参考： 《HTML5 中的 b/strong，i/em 有什么区别？》 前端需要注意哪些 SEO ？​ （1）合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超​ 过2次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不​ 同页面 description 有所不同；keywords 列举出重要关键词即可。 ​ （2）语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页。 ​ （3）重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容肯定被​ 抓取。 ​ （4）重要内容不要用 js 输出：爬虫不会执行 js 获取内容 ​ （5）少用 iframe：搜索引擎不会抓取 iframe 中的内容 ​ （6）非装饰性图片必须加 alt ​ （7）提高网站速度：网站速度是搜索引擎排序的一个重要指标 HTML5 的离线储存怎么使用，工作原理能不能解释一下？在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。 原理：HTML5 的离线存储是基于一个新建的 .appcache 文件的缓存机制（不是存储技术），通过这个文件上的解析清单离线存储资源，这些资源就会像 cookie 一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。 123456789101112131415161718192021222324252627282930313233如何使用： （1）创建一个和 html 同名的 manifest 文件，然后在页面头部像下面一样加入一个 manifest 的属性。 &lt;html lang=&quot;en&quot; manifest=&quot;index.manifest&quot;&gt; （2）在如下 cache.manifest 文件的编写离线存储的资源。 CACHE MANIFEST #v0.11 CACHE: js/app.js css/style.css NETWORK: resourse/logo.png FALLBACK: / /offline.html CACHE: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。 NETWORK: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。 FALLBACK: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。 （3）在离线状态时，操作 window.applicationCache 进行离线缓存的操作。 如何更新缓存： （1）更新 manifest 文件 （2）通过 javascript 操作 （3）清除浏览器缓存 注意事项： （1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。 （2）如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。 （3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。 （4）FALLBACK 中的资源必须和 manifest 文件同源。 （5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。 （6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。 （7）当 manifest 文件发生改变时，资源请求本身也会触发更新。 详细的使用可以参考： 《HTML5 离线缓存-manifest 简介》 《有趣的 HTML5：离线存储》 浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢？​ 在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。 ​ 离线的情况下，浏览器就直接使用离线存储的资源。 iframe 有那些缺点？​ iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。 ​ 主要缺点有： ​ （1） iframe 会阻塞主页面的 onload 事件。window 的 onload 事件需要在所有 iframe 加载完毕后（包含里面的元素）才会触发。在 Safari 和 Chrome 里，通过 JavaScript 动态设置 iframe 的 src 可以避免这种阻塞情况。​ （2） 搜索引擎的检索程序无法解读这种页面，不利于网页的 SEO 。​ （3） iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。​ （4） 浏览器的后退按钮失效。​ （5） 小型的移动设备无法完全显示框架。 详细的资料可以参考： 《使用 iframe 的优缺点》 《iframe 简单探索以及 iframe 跨域处理》 Label 的作用是什么？是怎么用的？ 1234label 标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。&lt;label for=&quot;Name&quot;&gt;Number:&lt;/label&gt;&lt;input type=“text“ name=&quot;Name&quot; id=&quot;Name&quot;/&gt; HTML5 的 form 的自动完成功能是什么？​ autocomplete 属性规定输入字段是否应该启用自动完成功能。默认为启用，设置为 autocomplete=off 可以关闭该功能。 ​ 自动完成允许浏览器预测对字段的输入。当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。 ​ autocomplete 属性适用于 ，以及下面的 类型：text, search, url, telephone, email, password,​ datepickers, range 以及 color。 如何实现浏览器内多个标签页之间的通信? 相关资料： ​ （1）使用 WebSocket，通信的标签页连接同一个服务器，发送消息到服务器后，服务器推送消息给所有连接的客户端。 ​ （2）使用 SharedWorker （只在 chrome 浏览器实现了），两个页面共享同一个线程，通过向线程发送数据和接收数据来实现标签页之间的双向通行。 ​ （3）可以调用 localStorage、cookies 等本地存储方式，localStorge 另一个浏览上下文里被添加、修改或删除时，它都会触发一个 storage 事件，我们通过监听 storage 事件，控制它的值来进行页面信息通信； ​ （4）如果我们能够获得对应标签页的引用，通过 postMessage 方法也是可以实现多个标签页通信的。 回答： ​ 实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。 ​ 第一种实现的方式是使用 websocket 协议，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。​ 标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。 ​ 第二种是使用 ShareWorker 的方式，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。 ​ 第三种方式是使用 localStorage 的方式，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。 ​ 还有一种方式是使用 postMessage 方法，如果我们能够获得对应标签页的引用，我们就可以使用postMessage 方法，进行通信。 详细的资料可以参考： 《WebSocket 教程》 《WebSocket 协议：5分钟从入门到精通》 《WebSocket 学习（一）——基于 socket.io 实现简单多人聊天室》 《使用 Web Storage API》 《JavaScript 的多线程，Worker 和 SharedWorker》 《实现多个标签页之间通信的几种方法》 webSocket 如何兼容低版本浏览器？ Adobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR 页面可见性（Page Visibility API） 可以有哪些用途？​ 这个新的 API 的意义在于，通过监听网页的可见性，可以预判网页的卸载，还可以用来节省资源，减缓电能的消耗。比如，一旦用户​ 不看网页，下面这些网页行为都是可以暂停的。 ​ （1）对服务器的轮询​ （2）网页动画​ （3）正在播放的音频或视频 详细资料可以参考： 《Page Visibility API 教程》 如何在页面上实现一个圆形的可点击区域？​ （1）纯 html 实现，使用 来给 图像标记热点区域的方式， 标签用来定义一个客户端图像映射， 标签用来定义图像映射中的区域，area 元素永远嵌套在 map 元素内部，我们可以将 area 区域设置为圆形，从而实现可点击的圆形区域。 ​ （2）纯 css 实现，使用 border-radius ，当 border-radius 的长度等于宽高相等的元素值的一半时，即可实现一个圆形的点击区域。 ​ （3）纯 js 实现，判断一个点在不在圆上的简单算法，通过监听文档的点击事件，获取每次点击时鼠标的位置，判断该位置是否在我们规定的圆形区域内。 详细资料可以参考： 《如何在页面上实现一个圆形的可点击区域？》 《HTML 标签及在实际开发中的应用》 实现不使用 border 画出 1 px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。 1&lt;div style=\"height:1px;overflow:hidden;background:red\"&gt;&lt;/div&gt; title 与 h1 的区别？ title 属性没有明确意义只表示是个标题，h1 则表示层次明确的标题，对页面信息的抓取也有很大的影响。 &lt;img&gt; 的 title 和 alt 有什么区别？​ title 通常当鼠标滑动到元素上的时候显示 ​ alt 是 的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装​ 饰图片外都必须设置有意义的值，搜索引擎会重点分析。 Canvas 和 SVG 有什么区别？ Canvas 是一种通过 JavaScript 来绘制 2D 图形的方法。Canvas 是逐像素来进行渲染的，因此当我们对 Canvas 进行缩放时， 会出现锯齿或者失真的情况。 SVG 是一种使用 XML 描述 2D 图形的语言。SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。我们可以为某个元素 附加 JavaScript 事件监听函数。并且 SVG 保存的是图形的绘制方法，因此当 SVG 图形缩放时并不会失真。 详细资料可以参考： 《SVG 与 HTML5 的 canvas 各有什么优点，哪个更有前途？》 网页验证码是干嘛的，是为了解决什么安全问题？ （1）区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水 （2）有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试 渐进增强和优雅降级的定义​ 渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 ​ 优雅降级：一开始就根据高版本浏览器构建完整的功能，然后再针对低版本浏览器进行兼容。 attribute 和 property 的区别是什么？ attribute 是 dom 元素在文档中作为 html 标签拥有的属性； property 就是 dom 元素在 js 中作为对象拥有的属性。 对于 html 的标准属性来说，attribute 和 property 是同步的，是会自动更新的， 但是对于自定义的属性来说，他们是不同步的。 对 web 标准、可用性、可访问性的理解可用性（Usability）：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看产品的质量。可用性好意味着产品质量高，是企业的核心竞争力 可访问性（Accessibility）：Web 内容对于残障用户的可阅读和可理解性 可维护性（Maintainability）：一般包含两个层次 一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。二是代码是否容易被人理解，是否容易修改和增强功能。 IE 各版本和 Chrome 可以并行下载多少个资源？ （1） IE6 2 个并发 （2） iE7 升级之后的 6 个并发，之后版本也是 6 个 （3） Firefox，chrome 也是6个 Flash、Ajax 各自的优缺点，在使用中如何取舍？​ Flash：​ （1） Flash 适合处理多媒体、矢量图形、访问机器​ （2） 对 CSS、处理文本上不足，不容易被搜索 ​ Ajax：​ （1） Ajax 对 CSS、文本支持很好，支持搜索​ （2） 多媒体、矢量图形、机器访问不足 ​ 共同点：​ （1） 与服务器的无刷新传递消息​ （2） 可以检测用户离线和在线状态​ （3） 操作 DOM 怎么重构页面？ （1） 编写 CSS （2） 让页面结构更合理化，提升用户体验 （3） 实现良好的页面效果和提升性能 浏览器架构 123456789101112* 用户界面 * 主进程 * 内核 * 渲染引擎 * JS 引擎 * 执行栈 * 事件触发线程 * 消息队列 * 微任务 * 宏任务 * 网络异步线程 * 定时器线程 常用的 meta 标签 1234567891011121314151617181920212223242526272829303132333435&lt;meta&gt; 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。&lt;meta&gt; 标签位于文档的头部，不包含任何内容。&lt;meta&gt; 标签的属性定义了与文档相关联的名称/值对。&lt;!DOCTYPE html&gt; H5标准声明，使用 HTML5 doctype，不区分大小写&lt;head lang=&quot;en&quot;&gt; 标准的 lang 属性写法&lt;meta charset=&quot;utf-8&quot;&gt; 声明文档使用的字符编码&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt; 优先使用 IE 最新版本和 Chrome&lt;meta name=&quot;description&quot; content=&quot;不超过150个字符&quot;/&gt; 页面描述&lt;meta name=&quot;keywords&quot; content=&quot;&quot;/&gt; 页面关键词者&lt;meta name=&quot;author&quot; content=&quot;name, email@gmail.com&quot;/&gt; 网页作&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt; 搜索引擎抓取&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no&quot;&gt; 为移动设备添加 viewport&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;标题&quot;&gt; iOS 设备 begin&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;/&gt; 添加到主屏后的标题（iOS 6 新增）是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏&lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL&quot;&gt;添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;/&gt;&lt;meta name=&quot;format-detection&quot; content=&quot;telphone=no, email=no&quot;/&gt; 设置苹果工具栏颜色&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; 启用360浏览器的极速模式(webkit)&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; 避免IE使用兼容模式&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt; 不让百度转码&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt; 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓&lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt; 微软的老式浏览器&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt; uc强制竖屏&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt; QQ强制竖屏&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt; UC强制全屏&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt; QQ强制全屏&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt; UC应用模式&lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt; QQ应用模式&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt; windows phone 点击无高光设置页面不缓存&lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot;&gt;&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt;&lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot;&gt; 详细资料可以参考： 《Meta 标签用法大全》 css reset 和 normalize.css 有什么区别？ 相关知识点： ​ 为什么会有 CSS Reset 的存在呢？那是因为早期的浏览器支持和理解的 CSS 规范不同，导致渲染页面时效果不一致，会出现很多​ 兼容性问题。 ​ reset 的目的，是将所有的浏览器的自带样式重置掉，这样更易于保持各浏览器渲染的一致性。 ​ normalize 的理念则是尽量保留浏览器的默认样式，不进行太多的重置，而尽力让这些样式保持一致并尽可能与现代标准相符合。 ​ 1.Normalize.css 保护了有价值的默认值 ​ Reset 通过为几乎所有的元素施加默认样式，强行使得元素有相同的视觉效果。 相比之下，Normalize.css 保持了许多默认的浏​ 览器样式。 这就意味着你不用再为所有公共的排版元素重新设置样式。 当一个元素在不同的浏览器中有不同的默认值时，Normali​ ze.css 会力求让这些样式保持一致并尽可能与现代标准相符合。 ​ 2.Normalize.css 修复了浏览器的 bug ​ 它修复了常见的桌面端和移动端浏览器的 bug。这往往超出了 Reset 所能做到的范畴。关于这一点，Normalize.css 修复的问题​ 包含了 HTML5 元素的显示设置、预格式化文字的 font-size 问题、在 IE9 中 SVG 的溢出、许多出现在各浏览器和操作系统中​ 的与表单相关的 bug。 ​ 3.Normalize.css 没有复杂的继承链 ​ 使用 Reset 最让人困扰的地方莫过于在浏览器调试工具中大段大段的继承链。在 Normalize.css 中就不会有这样的问题，因为在​ 我们的准则中对多选择器的使用时非常谨慎的，我们仅会有目的地对目标元素设置样式。 ​ 4.Normalize.css 是模块化的 ​ 这个项目已经被拆分为多个相关却又独立的部分，这使得你能够很容易也很清楚地知道哪些元素被设置了特定的值。因此这能让你自己​ 选择性地移除掉某些永远不会用到部分（比如表单的一般化）。 ​ 5.Normalize.css 拥有详细的文档 ​ Normalize.css 的代码基于详细而全面的跨浏览器研究与测试。这个文件中拥有详细的代码说明并在 Github Wiki 中有进一步的​ 说明。这意味着你可以找到每一行代码具体完成了什么工作、为什么要写这句代码、浏览器之间的差异，并且你可以更容易地进行自己​ 的测试。 回答： ​ css reset 是最早的一种解决浏览器间样式不兼容问题的方案，它的基本思想是将浏览器的所有样式都重置掉，从而达到所有浏览器​ 样式保持一致的效果。但是使用这种方法，可能会带来一些性能上的问题，并且对于一些元素的不必要的样式的重置，其实反而会造成​ 画蛇添足的效果。 ​ 后面出现一种更好的解决浏览器间样式不兼容的方法，就是 normalize.css ，它的思想是尽量的保留浏览器自带的样式，通过在原​ 有的样式的基础上进行调整，来保持各个浏览器间的样式表现一致。相对与 css reset，normalize.css 的方法保留了有价值的默​ 认值，并且修复了一些浏览器的 bug，而且使用 normalize.css 不会造成元素复杂的继承链。 详细资料可以参考： 《关于CSS Reset 那些事（一）之 历史演变与 Normalize.css》 《Normalize.css 和 Reset CSS 有什么本质区别没？》 用于预格式化文本的标签是？ 12预格式化就是保留文字在源码中的格式 最后显示出来样式与源码中的样式一致 所见即所得。&lt;pre&gt; 定义预格式文本，保持文本原有的格式 DHTML 是什么？​ DHTML 将 HTML、JavaScript、DOM 以及 CSS 组合在一起，用于创造动态性更强的网页。通过 JavaScript 和 HTML DOM，能​ 够动态地改变 HTML 元素的样式。 ​ DHTML 实现了网页从 Web 服务器下载后无需再经过服务的处理，而在浏览器中直接动态地更新网页的内容、排版样式和动画的功​ 能。例如，当鼠标指针移到文章段落中时，段落能够变成蓝色，或者当鼠标指针移到一个超级链接上时，会自动生成一个下拉式子链​ 接目录等。 ​ 包括：​ （1）动态内容（Dynamic Content）：动态地更新网页内容，可“动态”地插入、修改或删除网页的元件，如文字、图像、标记等。 ​ （2）动态排版样式（Dynamic Style Sheets）：W3C 的 CSS 样式表提供了设定 HTML 标记的字体大小、字形、样式、粗细、​ 文字颜色、行高度、加底线或加中间横线、缩排、与边缘距离、靠左右或置中、背景图片或颜色等排版功能，而“动态排版样​ 式”即可以“动态”地改变排版样式。 head 标签中必不少的是？12&lt;head&gt; 标签用于定义文档的头部，它是所有头部元素的容器。&lt;head&gt; 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等等。&lt;title&gt; 定义文档的标题，它是 head 部分中唯一必需的元素。 文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数 据都不会真正作为内容显示给读者。 ​ 下面这些标签可用在 head 部分：, , , , , 以及 。 ​ HTML5 新增的表单元素有？ datalist 规定输入域的选项列表，通过 option 创建！ keygen 提供一种验证用户的可靠方法，密钥对生成器，私钥存于客户端，公钥发到服务器，用于之后验证客户端证书！ output 元素用于不同类型的输出！ 在 HTML5 中，哪个方法用于获得用户的当前位置？ 1getCurrentPosition() 文档的不同注释方式？12345HTML 的注释方法 &lt;!--注释内容--&gt; CSS 的��释方法 /*注释内容*/ JavaScript 的注释方法 /* 多行注释方式 */ //单行注释方式 disabled 和 readonly 的区别？disabled 指当 input 元素加载时禁用此元素。input 内容不会随着表单提交。readonly 规定输入字段为只读。input 内容会随着表单提交。 无论设置 readonly 还是 disabled，通过 js 脚本都能更改 input 的 value 主流浏览器内核私有属性 css 前缀？ mozilla 内核 （firefox,flock 等） -moz webkit 内核 （safari,chrome 等） -webkit opera 内核 （opera 浏览器） -o trident 内核 （ie 浏览器） -ms 前端性能优化？​ 前端性能优化主要是为了提高页面的加载速度，优化用户的访问体验。我认为可以从这些方面来进行优化。 ​ 第一个方面是页面的内容方面 ​ （1）通过文件合并、css 雪碧图、使用 base64 等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况。 ​ （2）通过 DNS 缓存等机制来减少 DNS 的查询次数。 ​ （3）通过设置缓存策略，对常用不变的资源进行缓存。 ​ （4）使用延迟加载的方式，来减少页面首屏加载时需要请求的资源。延迟加载的资源当用户需要访问时，再去请求加载。 ​ （5）通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度。 ​ 第二个方面是服务器方面 ​ （1）使用 CDN 服务，来提高用户对于资源请求时的响应速度。 ​ （2）服务器端启用 Gzip、Deflate 等方式对于传输的资源进行压缩，减小文件的体积。 ​ （3）尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie ​ 第三个方面是 CSS 和 JavaScript 方面 ​ （1）把样式表放在页面的 head 标签中，减少页面的首次渲染的时间。 ​ （2）避免使用 @import 标签。 ​ （3）尽量把 js 脚本放在页面底部或者使用 defer 或 async 属性，避免脚本的加载和执行阻塞页面的渲染。 ​ （4）通过对 JavaScript 和 CSS 的文件进行压缩，来减小文件的体积。 详细的资料可以参考： 《前端性能优化之雅虎35条军规》 《你真的了解 gzip 吗？》 《前端性能优化之 gzip》 Chrome 中的 Waterfall ？ 详细资料可以参考： 《前端性能之 Chrome 的 Waterfall》 《教你读懂网络请求的瀑布图》 《前端妹子跟我抱怨她们的页面加载很慢的时候，如何在她面前优雅地装逼？》 扫描二维码登录网页是什么原理，前后两个事件是如何联系的？​ 核心过程应该是：浏览器获得一个临时 id，通过长连接等待客户端扫描带有此 id 的二维码后，从长连接中获得客户端上报给 serv​ er的帐号信息进行展示。并在客户端点击确认后，获得服务器授信的令牌，进行随后的信息交互过程。在超时、网络断开、其他设备​ 上登录后，此前获得的令牌或丢失、或失效，对授权过程形成有效的安全防护。 ​ 我的理解 ​ 二维码登录网页的基本原理是，用户进入登录网页后，服务器生成一个 uid 来标识一个用户。对应的二维码对应了一个对应 uid​ 的链接，任何能够识别二维码的应用都可以获得这个链接，但是它们没有办法和对应登录的服务器响应。比如微信的二维码登录，只​ 有用微信识这个二维码才有效。当微信客户端打开这个链接时，对应的登录服务器就获得了用户的相关信息。这个时候登录网页根据​ 先前的长连接获取到服务器传过来的用户信息进行显示。然后提前预加载一些登录后可能用到的信息。当客户端点击确认授权登陆后，​ 服务器生成一个权限令牌给网页，网页之后使用这个令牌进行信息的交互过程。由于整个授权的过程都是在手机端进行的，因此能够​ 很好的防止 PC 上泛滥的病毒。并且在超时、网络断开、其他设备上登录后，此前获得的令牌或丢失、或失效，对授权过程能够形成​ 有效的安全防护。 详细资料可以参考： 《微信扫描二维码登录网页》 Html 规范中为什么要求引用资源不加协议头http或者https？​ 如果用户当前访问的页面是通过 HTTPS 协议来浏览的，那么网页中的资源也只能通过 HTTPS 协议来引用，否则浏览器会出现​ 警告信息，不同浏览器警告信息展现形式不同。 ​ 为了解决这个问题，我们可以省略 URL 的协议声明，省略后浏览器照样可以正常引用相应的资源，这项解决方案称为​ protocol-relative URL，暂且可译作协议相对 URL。 ​ 如果使用协议相对 URL，无论是使用 HTTPS，还是 HTTP 访问页面，浏览器都会以相同的协议请求页面中的资源，避免弹出类似​ 的警告信息，同时还可以节省5字节的数据量。 详细资料可以参考： 《协议相对 URL》 《Why you need protocol-relative URLs now》 行内元素首先：CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素 一个行内元素只占据它对应标签的边框所包含的空间一般情况下，行内元素只能包含数据和其他行内元素 常用：a b span img input select strong（强调的语气） 1234big, i, small, ttabbr, acronym, cite, code, dfn, em, kbd, samp, varbdo, br, map, object, q, script, sub, supbutton, label, textarea 块级元素占据一整行，高度、行高、内边距和外边距都可以改变，可以容纳块级标签和其他行内标签 常用：div ul ol li dl dt dd h1 h2 h3 h4…p 1header,form,table,article,hr,aside,figure,canvas,video,audio,footer 空(void)元素有那些？常见的空元素:&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt; Iframe的作用？ 用法： Iframe是用来在网页中插入第三方页面，早期的页面使用 iframe 主要是用于导航栏这种很多页面都相同的部分，这样可以在切换页面的时候避免重复下载。 优点： 便于修改，模块分离，像一些信息管理系统会用到。 iframe 能够原封不动的把嵌入的网页展现出来。 用来加载速度较慢的第三方内容如图标和广告 可以使脚本可以并行下载，可以实现跨子域通信 如果有多个网页引用 iframe，那么你只需要修改 iframe 的内容，就可以实现调用的每一个页面内容的更改，方便快捷。 网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用 iframe 来嵌套，可以增加代码的可重用。 缺点： iframe 的创建比一般的 DOM 元素慢了 1-2 个数量级 会产生很多页面，不容易管理，iframe 页面会增加服务器的 http 请求 搜索引擎的检索程序（爬虫）无法解读这种页面，不利于 SEO；替代方案一般就是动态语言的 Incude 机制和 ajax 动态填充内容等。 框架结构中出现各种滚动条 使用框架结构时，保证设置正确的导航链接。 iframe 会阻塞主页面的 Onload （加载）事件，如果页面的onload 事件不能及时触发，会让用户觉得网页加载很慢，用户体验不好； 本上不推荐使用，如果需要使用iframe，在 Safari 和 Chrome 中可以通过javascript动态给iframe添加src属性值来避免阻塞。 iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 HTML 与 XHTM有什么区别，你觉得应该使用哪一个并说出理由。区别： HTML是一种基本的 WEB 网页设计语言，XHTML 是一个基于 XML 的置标语言。 应该使用XHTML，因为XHTML是XML重写了HTML的规范，比HTML更加严格，表现如下： 1、XHTML中所有的标记都必须有一个相应的结束标签；XHTML文档必须拥有根元素。 2、XHTML所有标签的元素和属性的名字都必须使用小写； 3、所有的XML标记都必须合理嵌套； 4、所有的属性都必须用引号“”括起来； 5、把所有系统缓存->路由器缓存）dns查找过程如下：1、浏览器缓存——浏览器会缓存dns记录一段时间，但是操作系统不会告诉浏览器存储dns的记录事件，所以不同浏览器会自固定一个时间（2~30分钟）；2、系统缓存——如果在浏览器缓存里没有找到需要的记录，浏览器会做一个系统调用，以便获得系统缓存中的记录；3、路由器缓存——接着，请求发向路由器，它一般会有自己的dns缓存；4、ISP（网络服务提供商）DNS缓存——接下来检查ISP缓存DNS的服务器。这里一般能找到相应的缓存记录。5、递归搜索——ISP的DNS服务器从根域名服务器开始进行递归搜索，从com顶级域名服务器到example的域名服务器。3、浏览器给web服务器发送一个HTTP请求请求中可能包含存储该域名的cookies，也会存储登录用户名和密码以及一些用户设置等。4、HTTP（超文本传输协议）请求的建立建立TCP（传输控制协议）链接：在HTTP工作开始之前，web浏览器首先要通过网络与web服务器建立连接，该连接通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层的应用层协议。根据规则只有低层协议建立之后，才能进行更高层协议的连接。因此，首先要建立TCP链接，一般TCP链接的端口号是80。在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。第一次握手：主机A发送位码syn=1，随机产生seq（sequence序列号） number=1234567的数据包到服务器，主机B由syn=1知道，A要求建立联机；第二次握手：主机B收到请求后确认联机信息，向A发送ack（Acknowledgement 确认信息） number=(主机A的seq+1)，syn=1，ack=1.随机产生seq=7654321的包；第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1，以及位码syn是否为1，若正确，主机A会再发送ack number=（主机B的seq+1），ack=1；主机B收到后确认seq值与ack=1则链接建立成功。完成三次握手，主机A与主机B开始传送数据。一旦建立了TCP连接，web浏览器就会向web服务器发送请求命令。浏览器发送其求命令之后，还要以头信息的形式向web服务器发送一些别的信息，之后浏览器发送一空白行来通知服务器，它已经结束了该头信息的发送。5、服务器的永久重定向响应服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问“http://www.chenxixunhan.com/”而非\"http://chenxixunhan.com/\"。为什么要重定向而不直接发回用户想看到的网页内容？其中一个原因跟搜索引擎排名相关。如果一个页面有两个地址，就像“http://www.chenxixunhan.com/”和\"http://chenxixunhan.com/\"，搜索引擎会认为他们是两个网站，结果造成每一个的搜索链接都减少从而降低排名。而搜索引擎知道301永久重定向，会把访问带www的和不带www的地址归到同一个网站排名下。还有一个原因是用不同的地址会造成缓存友好性变差。当一个页面有好几个名字时，它可能会在缓存里出现好几次。HTTP/1.1 301 Moved PermanentlyCache-Control: private, no-store, no-cache, must-revalidate, post-check=0,pre-check=0Expires: Sat, 01 Jan 2000 00:00:00 GMTLocation: HTTP://www.facebook.com/P3P: CP=”DSP LAW”Pragma: no-cacheSet-Cookie: made_write_conn=deleted; expires=Thu, 12-Feb-2009 05:09:50 GMT;path=/; domain=.facebook.com; httponlyContent-Type: text/html; charset=utf-8X-Cnection: closeDate: Fri, 12 Feb 2010 05:09:51 GMTContent-Length: 06、浏览器跟踪重定向地址现在，浏览器知道了“http://www.chenxixunhan.com/”才是要访问的正确地址，所以它会发送另一个获取请求也就是GET HTTP://www.facebook.com/ HTTP/1.1Accept: application/x-ms-application, image/jpeg, application/xaml+xml, [...]Accept-Language: en-USUser-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; [...]Accept-Encoding: gzip, deflateConnection: Keep-AliveCookie: lsd=XW[...]; c_user=21[...]; x-referer=[...]Host: www.facebook.com头信息以之前请求中的意义相同；7、服务器“处理”请求服务器接收到获取请求，然后处理返回一个响应。8、服务器发回一个HTML响应HTTP/1.1 200 OKCache-Control: private, no-store, no-cache, must-revalidate, post-check=0,pre-check=0Expires: Sat, 01 Jan 2000 00:00:00 GMTP3P: CP=”DSP LAW”Pragma: no-cacheContent-Encoding: gzipContent-Type: text/html; charset=utf-8X-Cnection: closeTransfer-Encoding: chunkedDate: Fri, 12 Feb 2010 09:05:55 GMT 2b3Tn@[...]整个响应大小为35kB，其中大部分在整理后以blob（二进制）类型传输。内容编码头告诉浏览器整个响应体用gzip算法进行压缩。解压blob块后，你可以看到html文档。关于压缩，头信息说明了是否缓存这个页面，如果缓存的话如何去做，有什么cookies要去设置（前面响应没有这点）和隐私信息等等。注意：报头中把Content-type设置为“text/html”。报头让浏览器将该响应内容以HTML形式呈现，而不是以文件格式下载它。浏览器会根据报头信息决定如何解释该响应，不过同时也会考虑像URL扩展内容等其他因素。9、浏览器开始显示HTML在浏览器没有完整接受全部HTML文档时，它就开始显示这个页面了。10、浏览器发送获取嵌入在HTML中的对象在浏览器显示HTML时，它会注意到需要获取其它地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。下面几个是一个叫雷锋的作者访问facebook.com时需要重获取的几个URL* 图片HTTP://static.ak.fbcdn.net/rsrc.php/z12E0/hash/8q2anwu7.gifHTTP://static.ak.fbcdn.net/rsrc.php/zBS5C/hash/7hwy7at6.gif…* CSS 式样表HTTP://static.ak.fbcdn.net/rsrc.php/z448Z/hash/2plh8s4n.cssHTTP://static.ak.fbcdn.net/rsrc.php/zANE1/hash/cvtutcee.css…* JavaScript 文件HTTP://static.ak.fbcdn.net/rsrc.php/zEMOA/hash/c8yzb6ub.jsHTTP://static.ak.fbcdn.net/rsrc.php/z6R9L/hash/cq2lgbs8.js ​ 这些地址都要经历一个和HTML读取类似的过程。所以浏览器会在DNS查找这些域名，发送请求，重定向等等。​ 但不像动态页面那样，静态文件会允许浏览器对其进行缓存。有的文件可能不需要与服务器通讯，而从缓存中直接读取。服务器的相应中包含了静态文件保存的期限信息，所以浏览器知道要把它们缓存多长时间。还有，每个响应度可能包含像版本号一样的ETag（电子标签）头（被请求变量的实体值），如果浏览器观察到文件的版本ETag信息已经存在，就马上停止这个文件的传输。11、浏览器发送异步（Ajax）请求​ 在web2.0伟大精神的指引下，页面显示完成后客户仍与服务器端保持着联系。​ 以Facebook聊天功能为例，它会持续与服务器保持联系来及时更新你那写亮亮灰灰的好友状态。​ 为了更新这些头像亮着的好友状态，在浏览器中执行的javascript代码服务器发送异步请求。这个异步请求发送给特定的地址，它是一个按照程式构造的获取或发送请求。​ facebook聊天功能提供了关于ajax一个有意思的问题案例：把数据从服务器端推送到客户端，因为HTTP是一个请求-响应协议，所以聊天服务器不能把新消息发给客户。取而代之的是客户端不得不隔几秒就轮询下服务器端看自己有没有新消息。​ 这些情况发生时长轮询是个减轻服务器负载挺有趣的技术。如果当被轮询时服务器没有新消息，它就不理这个客户端。而当尚未超时的情况下收到了该客户的新消息，服务器就会找到未完成的请求，把新消息作为响应返回给客户端。​ （源自：http://www.qdfuns.com/notes/15102/a5bee6b87d22ab0ecb28101f385db2e4.html） ​ （拓展：请求url响应返回状态代码及其文本描述？（详情：D:\\notes_web_book\\HTTP协议详解.pdf））​ 状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：​ 1xx：指示信息--表示请求已接收，继续处理​ 2xx：成功--表示请求已被成功接收、理解、接受​ 3xx：重定向--要完成请求必须进行更进一步的操作​ 4xx：客户端错误--请求有语法错误或请求无法实现​ 5xx：服务器端错误--服务器未能实现合法的请求 ​ 常见状态代码、状态描述说明：​ 200 OK //客户端请求成功​ 400 Bad Request //客户端请求有语法错误，不能被服务器所理解​ 401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用​ 403 Forbidden //服务器收到请求，但是拒绝提供服务​ 404 Not Found //请求资源不存在，eg：输入了错误的 URL​ 500 Internal Server Error //服务器发生不可预期的错误​ 503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后，可能恢复正常​ eg：HTTP/1.1 200 OK 请描述下 SEO 中的 TDK？答案：在 SEO 中，所谓的 TDK 其实就是 title、description、keywords 这三个标签，title 标题标签，description 描述标签，keywords 关键词标签 严格模式与混杂模式严格模式：以浏览器支持的最高标准运行 混杂模式：页面以宽松向下兼容的方式显示，模拟老式浏览器的行为 列举 IE 与其他浏览器不一样的特性？a. IE 的排版引擎是 Trident （又称为 MSHTML） b. Trident 内核曾经几乎与 W3C 标准脱节（2005 年） c. Trident 内核的大量 Bug 等安全性问题没有得到及时解决 d. JS 方面，有很多独立的方法，例如绑定事件的 attachEvent、创建事件的 createEventObject 等 e. CSS 方面，也有自己独有的处理方式，例如设置透明，低版本 IE 中使用滤镜的方式 为什么用多个域名存储网站资源更有效？1、CDN 缓存更方便 2、突破浏览器并发限制 3、节约 cookie 带宽 4、节约主域名的连接数，优化页面响应速度 5、防止不必要的安全问题 页面可见性（Page Visibility）API 可以有哪些用途？页面可见性： 就是对于用户来说，页面是显示还是隐藏, 所谓显示的页面，就是我们正在看的页面；隐藏的页面，就是我们没有看的页面。 因为，我们一次可以打开好多标签页面来回切换着，始终只有一个页面在我们眼前，其他页面就是隐藏的，还有一种就是.........，(把浏览器最小化，所有的页面就都不可见了)。 API 很简单，document.hidden 就返回一个布尔值，如果是 true, 表示页面可见，false 则表示，页面隐藏。 不同页面之间来回切换，触发 visibilitychange 事件。 还有一个 document.visibilityState, 表示页面所处的状态，取值：visible, hidden 等四个。 1234567document.addEventListener(\"visibilitychange\", function() &#123; if (document.hidden) &#123; document.title = \"hidden\"; &#125; else &#123; document.title = \"visibile\"; &#125;&#125;); 我们打开这个页面，然后再打开另一个页面，来回点击这两个页面，当我们看到这个页面时，标题显示 visiable ,当我们看另一个页面时，标题显示 hidden; 动画，视频，音频都可以在页面显示时打开，在页面隐藏时关闭 解析：参考 Quirks(怪癖）模式是什么？它和 Standards（标准）模式有什么区别1 以 ie6 为例，如果写了 DTD，就意味着这个页面将采用对 CSS 支持更好的布局，而如果没有，则采用兼容之前的布局方式。这就是 Quirks 模式（怪癖模式，诡异模式，怪异模式）。 2 区别：总体会有布局、样式解析和脚本执行三个方面的区别。 设置一个元素的宽度和高度 给&lt;span&gt;等行内元素设置 width 和 height 用 margin:0 auto 设置水平居中 从 IE6 开始，引入了 Standards 模式，标准模式中，浏览器尝试给符合标准的文档在规范上的正确处理达到在指定浏览器中的程度。 在 IE6 之前 CSS 还不够成熟，所以 IE5 等之前的浏览器对 CSS 的支持很差， IE6 将对 CSS 提供更好的支持，然而这时的问题就来了，因为有很多页面是基于旧的布局方式写的，而如果 IE6 支持 CSS 则将令这些页面显示不正常，如何在即保证不破坏现有页面，又提供新的渲染机制呢？ 在写程序时我们也会经常遇到这样的问题，如何保证原来的接口不变，又提供更强大的功能，尤其是新功能不兼容旧功能时。遇到这种问题时的一个常见做法是增加参数和分支，即当某个参数为真时，我们就使用新功能，而如果这个参数 不为真时，就使用旧功能，这样就能不破坏原有的程序，又提供新功能。IE6 也是类似这样做的，它将 DTD（文档类型定义）当成了这个“参数”，因为以前的页面大家都不会去写 DTD，所以 IE6 就假定 如果写了 DTD，就意味着这个页面将采用对 CSS 支持更好的布局，而如果没有，则采用兼容之前的布局方式。这就是 Quirks 模式（怪癖模式，诡异模式，怪异模式）。 区别： 总体会有布局、样式解析和脚本执行三个方面的区别。 盒模型：在 W3C 标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在 Quirks 模式下，IE 的宽度和高度还包含了 padding 和 border。 设置行内元素的高宽：在 Standards 模式下，给&lt;span&gt;等行内元素设置 wdith 和 height 都不会生效，而在 quirks 模式下，则会生效。 设置百分比的高度：在 standards 模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置百分比的高度，子元素设置一个百分比的高度是无效的 用 margin:0 auto 设置水平居中：使用 margin:0 auto 在 standards 模式下可以使元素水平居中，但在 quirks 模式下却会失效。 （还有很多，答出什么不重要，关键是看他答出的这些是不是自己经验遇到的，还是说都是看文章看的，甚至完全不知道。） div+css 的布局较 table 布局有什么优点？答案：分离 方便改版 快清晰简洁 seo 1.改版的时候更方便 只要改 css 文件。 2.页面加载速度更快、结构化清晰、页面显示简洁。 3.表现与结构相分离。 4.易于优化（seo）搜索引擎更友好，排名更容易靠前。 你能描述一下渐进增强和优雅降级之间的不同吗?渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 （一开始保证最基本的功能，再改进和追加功能） 优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 （一开始就构建完整的功能，再针对低版本浏览器进行兼容。） 区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。 知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？答案：微格式（Microformats）是一种让机器可读的语义化 XHTML 词汇的集合，是结构化数据的开放标准。是为特殊应用而制定的特殊格式。 优点：将智能数据添加到网页上，让网站内容在搜索引擎结果界面可以显示额外的提示。（应用范例：豆瓣，有兴趣自行 google） webSocket 如何兼容低版本浏览器？答案：对于低端不支持 websocket 的浏览器，一般有几个解决方案 使用轮询或长连接的方式实现伪 websocket 的通信 使用 flash 或其他方法实现一个 websocket 客户端 ： 参考参考 如何在页面上实现一个圆形的可点击区域？答案：css3、js、map 加 area 一.border-radius (css3) 对于圆形，最直接的方法想到的就是 css3 的圆角属性，这个属性可以将 html 元素的形状设置为圆形，这之后你想对该圆形区域设置什么事件就设置什么事件(当然包括点击)。（这里就不做具体的 test 了） 二.纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等 通过事件坐标来实现（js），也就是通过 js 来进行一个区域判断，进而简介地的形成可点区域，以下给出主要的 js 测试代码： 1234567891011121314151617181920212223242526272829303132// 获取目标元素var box = document.getElementById(\"box\");// 对目标元素target的圆形区域进行一个点击事件绑定function bindClickOnCircleArea(target, callback) &#123; target.onclick = function(e) &#123; e = e || window.event; // target中心点的坐标 var x1 = 100; var y1 = 100; // 事件源坐标 var x2 = e.offsetX; var y2 = e.offsetY; // 校验是否在圆形点击区，在的话就执行callback回调 // 计算事件触发点与target中心的位置 var len = Math.abs(Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2))); // 通过半径进行校验 if (len &lt;= 100) &#123; callback(); &#125; else &#123; alert(\"死鬼，跑哪去啊，你老婆我是黄皮肤还是白皮肤都分不清了吗\"); &#125; &#125;;&#125;// 执行bindClickOnCircleArea(box, function() &#123; alert(\"老婆，你让我好找啊，呜呜呜\");&#125;); 三.通过 map 加 area或者svg 123456789&lt;img src=\"../imgs/test.jpg\" width=\"200\" border=\"0\" usemap=\"#Map\" /&gt;&lt;map name=\"Map\" id=\"Map\"&gt; &lt;area shape=\"circle\" coords=\"100,100,100\" href=\"http://www.baidu.com\" target=\"_blank\" /&gt;&lt;/map&gt; 参考 前端需要注意哪些 SEO 合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可 语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页 重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取 重要内容不要用 js 输出：爬虫不会执行 js 获取内容 少用 iframe：搜索引擎不会抓取 iframe 中的内容 非装饰性图片必须加 alt 提高网站速度：网站速度是搜索引擎排序的一个重要指标 解析：参考 HTML 全局属性(global attribute)有哪些 accesskey:设置快捷键，提供快速访问元素如aaa在 windows 下的 firefox 中按 alt + shift + a 可激活元素 class:为元素设置类标识，多个类名用空格分开，CSS 和 javascript 可通过 class 属性获取元素 contenteditable: 指定元素内容是否可编辑 contextmenu: 自定义鼠标右键弹出菜单内容 data-*: 为元素增加自定义属性 dir: 设置元素文本方向 draggable: 设置元素是否可拖拽 dropzone: 设置元素拖放类型： copy, move, link hidden: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果 id: 元素 id，文档内唯一 lang: 元素内容的的语言 spellcheck: 是否启动拼写和语法检查 style: 行内 css 样式 tabindex: 设置元素可以获得焦点，通过 tab 可以导航 title: 元素相关的建议信息 translate: 元素和子孙节点内容是否需要本地化 解析：参考 meta viewport 原理是什么？答案：meta viewport 标签的作用是让当前 viewport 的宽度等于设备的宽度，同时不允许用户进行手动缩放 viewportde 原理：移动端浏览器通常都会在一个比移动端屏幕更宽的虚拟窗口中渲染页面，这个虚拟窗口就是 viewport; 目的是正常展示没有做移动端适配的网页，让他们完整的展示给用户； 解析：Viewport ：字面意思为视图窗口，在移动 web 开发中使用。表示将设备浏览器宽度虚拟成一个特定的值（或计算得出），这样利于移动 web 站点跨设备显示效果基本一致。移动版的 Safari 浏览器最新引进了 viewport 这个 meta tag，让网页开发者来控制 viewport 的大小和缩放，其他手机浏览器也基本支持。 在移动端浏览器当中，存在着两种视口，一种是可见视口（也就是我们说的设备大小），另一种是视窗视口（网页的宽度是多少）。举个例子：如果我们的屏幕是 320 像素 * 480 像素的大小（iPhone4），假设在浏览器中，320 像素的屏幕宽度能够展示 980 像素宽度的内容。那么 320 像素的宽度就是可见视口的宽度，而能够显示的 980 像素的宽度就是视窗视口的宽度。 为了显示更多的内容，大多数的浏览器会把自己的视窗视口扩大，简易的理解，就是让原本 320 像素的屏幕宽度能够容下 980 像素甚至更宽的内容（将网页等比例缩小）。 Viewport 属性值 width 设置 layout viewport 的宽度，为一个正整数，或字符串\"width-device\" initial-scale 设置页面的初始缩放值，为一个数字，可以带小数 minimum-scale 允许用户的最小缩放值，为一个数字，可以带小数 maximum-scale 允许用户的最大缩放值，为一个数字，可以带小数 height 设置 layout viewport 的高度，这个属性对我们并不重要，很少使用 user-scalable 是否允许用户进行缩放，值为\"no\"或\"yes\", no 代表不允许，yes 代表允许这些属性可以同时使用，也可以单独使用或混合使用，多个属性同时使用时用逗号隔开就行了。 Canvas描述：Canvas 元素用于在网页上绘制图形，该元素标签强大之处在于可以直接在 HTML 上进行图形操作。 通过 Javascript 来绘制 2D 图形。 是逐像素进行渲染的。 在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。 SVG描述： 一种使用 XML 描述的 2D 图形的语言SVG 基于 XML 意味着，SVG DOM 中的每个元素都是可用的，可以为某个元素附加 Javascript 事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。 Canvas 和 SVG 有什么区别？Canvas 和 SVG 都允许您在浏览器中创建图形，但是它们在根本上是不同的。 Canvas 依赖分辨率 不支持事件处理器 弱的文本渲染能力 能够以 .png 或 .jpg 格式保存结果图像 最适合图像密集型的游戏，其中的许多对象会被频繁重绘 SVG 不依赖分辨率 支持事件处理器 最适合带有大型渲染区域的应用程序（比如谷歌地图） 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快） 不适合游戏应用 为什么最好把 CSS 的&lt;link&gt;标签放在&lt;head&gt;&lt;/head&gt;之间？把&lt;link&gt;标签放在&lt;head&gt;&lt;/head&gt;之间是规范要求的内容。此外，这种做法可以让页面逐步呈现，提高了用户体验。将样式表放在文档底部附近，会使许多浏览器（包括 Internet Explorer）不能逐步呈现页面。一些浏览器会阻止渲染，以避免在页面样式发生变化时，重新绘制页面中的元素。这种做法可以防止呈现给用户空白的页面或没有样式的内容。 为什么最好把 JS 的&lt;script&gt;标签恰好放在&lt;/body&gt;之前，有例外情况吗？脚本在下载和执行期间会阻止 HTML 解析。把&lt;script&gt;标签放在底部，保证 HTML 首先完成解析，将页面尽早呈现给用户。 例外情况是当你的脚本里包含document.write()时。但是现在，document.write()不推荐使用。同时，将&lt;script&gt;标签放在底部，意味着浏览器不能开始下载脚本，直到整个文档（document）被解析。也许，对此比较好的做法是，&lt;script&gt;使用defer属性，放在&lt;head&gt;中。 DOM结构 —— 两个节点之间可能存在哪些关系以及如何在节点之间任意移动。（通俗易懂的来讲讲DOM、两个节点之间可能存在哪些关系以及如何在节点之间任意移动） DOM: Document Object Module, 文档对象模型。 节点的关系：父（parent）、子（child）和同胞（sibling）等节点关系； - 在节点树中，顶端节点被称为根（root） - 每个节点都有父节点、除了根（它没有父节点） - 一个节点可拥有任意数量的子 - 同胞是拥有相同父节点的节点 DOM操作 —— 如何添加、移除、移动、复制、创建和查找节点等查找DOM：document.getElementById()和document.getElementsByTagName()，以及CSS选择器document.getElementsByClassName()；querySelector()和querySelectorAll()【低版本的IE body -> document IE 6.0: div -> body -> html -> document Mozilla 1.0: div -> body -> html -> document -> window （2）捕获型事件(event capturing)：事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)。 （3）DOM事件流：同时支持两种事件模型：捕获型事件和冒泡型事件，但是，捕获型事件先发生。两种事件流会触及DOM中的所有对象，从document对象开始，也在document对象结束。 DOM事件模型最独特的性质是，文本节点也触发事件(在IE中不会)。 XMLHttpRequest —— 这是什么、怎样完整地执行一次GET请求、怎样检测错误。（老版本IE ajax核心对象为ActiveXObject） XMLHttpRequest 对象提供了在网页加载后与服务器进行通信的方法。 获取ajax核心对象： 1234567891011121314151617181920212223var request = false; try &#123; request = new XMLHttpRequest(); &#125; catch (trymicrosoft) &#123; try &#123; request = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); &#125; catch (othermicrosoft) &#123; try &#123; request = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; catch (failed) &#123; request = false; &#125;&#125;&#125; 严格模式与混杂模式 —— 如何触发这两种模式，区分它们有何意义DOCTYPE（是Document Type文档类型的简写）是一组机器可读的规则，它们指示(X)HTML文档中允许有什么，不允许有什么，DOCTYPE正是用来告诉浏览器使用哪种DTD，三种 DTD 类型分别是严格版本、过渡版本以及基于框架的 HTML 文档。声明位于文档中的最前面的位置，处于标签之前。如果DOCTYPE声明不是页面上的第一个元素，那么IE 6会自动切换到混杂模式。 严格模式是浏览器根据web标准去解析页面，是一种要求严格的DTD，不允许使用任何表现层的语法，如。混杂模式则是一种向后兼容的解析方法，就是可以实现IE5.5以下版本浏览器的渲染模式。 总结： （1） 声明位于文档中的最前面，处于标签之前。告知浏览器的解析器，用什么文档类型规范来解析这个文档。 （2）严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。 （3）在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 （4）DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。 盒模型 —— 外边距、内边距和边框之间的关系，及IE8以下版本的浏览器中的盒模型CSS 盒子模型(Box Model) 所有HTML元素可以看作盒子，在CSS中，\"box model\"这一术语是用来设计和布局时使用。 CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。 盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。 属性：box-sizing； 属性值1：box-sizing：border-box；标准盒子模型——元素的内边距和边框不再会增加它的宽度，即元素宽度width包含了元素的内边距padding和边框宽度border-width，元素内容宽度 = width - padding - border； 属性值2：box-sizing： content-box；（默认值）IE盒子模型（怪异盒模型）——元素的内边距和边框会增加它的宽度，即元素实际宽度等于width加上元素的内边距padding和边框宽度border-width，元素内容宽度 = width；（IE8以下浏览器的盒模型中定义的元素的宽高不包括内边距和边框） 块级元素与行内元素 —— 怎么用CSS控制它们、以及如何合理的使用它们（参考链接）（1）CSS规范规定，每个元素都有display属性，比如div默认display属性值为“block”，成为“块级”元素，总是独占一行，表现为另起一行开始，而且其后的元素也必须另起一行显示；span默认display属性值为“inline”，是“行内”元素，可以和相邻的内联元素在同一行。 （2）行内元素 1a b span img input select strong··· （3）块级元素有 1div ul ol li dl dt dd h1 h2 h3 h4…p （4）知名的空元素 123&lt;br/&gt;，&lt;hr/&gt; &lt;img/&gt; &lt;input/&gt; &lt;link&gt; &lt;meta&gt;// 鲜为人知的是：&lt;area&gt; &lt;base&gt; &lt;command&gt; &lt;col&gt; &lt;embed&gt; &lt;keygen&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt; 浮动元素 —— 怎么使用它们、它们有什么问题以及怎么解决这些问题。属性：float； 属性值：left：往左浮动；right：往右浮动； 浮动元素引起的问题： 1.父元素的高度无法被撑开，影响与父元素同级的元素； 2.与浮动元素同级的非浮动元素会跟随其后； 3.若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构； 解决方法： 清浮动，使用CSS中的clear:both;属性来清除同级子元素的浮动问题 给父元素添加clearfix样式，解决父元素高度无法撑开问题： 1.clearfix:after &#123;content: &quot;&quot;; display: block; clear: both;&#125; （参考链接） HTML与XHTML —— 二者有什么区别，你觉得应该使用哪一个并说出理由主要区别：HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的置标语言； XHTML元素必须被正确地嵌套； XHTML元素必须被关闭； 标签名必须用小写字母； XHTML文档必须拥有根元素。 JSON —— 作用、用途、设计结构JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。 JSON建构于两种结构：“名称/值”对的集合（A collection of name/value pairs）。 不同的语言中，它被理解为对象（object）、纪录（record）、结构（struct）、字典（dictionary）、哈希表（hash table）、有键列表（keyed list）或者关联数组（associative array）、值的有序列表（An ordered list of values）。在大部分语言中，它被理解为数组（array）。 HTML5：离线存储参考链接：有趣的HTML5：离线存储","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://qw8.github.io/tags/HTML/"},{"name":"Web","slug":"Web","permalink":"https://qw8.github.io/tags/Web/"},{"name":"标签","slug":"标签","permalink":"https://qw8.github.io/tags/标签/"},{"name":"浏览器","slug":"浏览器","permalink":"https://qw8.github.io/tags/浏览器/"}]},{"title":"HTTP","slug":"interview/HTTP","date":"2020-07-06T09:52:49.000Z","updated":"2024-04-26T09:59:38.820Z","comments":true,"path":"/interview/http.html","link":"","permalink":"https://qw8.github.io/interview/http.html","excerpt":"","text":"超文本传输协议（HTTP）介绍超文本传输协议（HyperText Transfer Protocol，HTTP）是从服务器传输数据到客户端的传输协议。 HTTP 的主要特点 支持客户/服务器模式。 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 灵活：HTTP允许传输任意类型的数据对象。传输的类型由 Content-Type 加以标记。 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 客户端和服务器端交互的过程 客户发起连接 客户发送请求 服务器响应请求 服务器关闭连接 请求消息结构一个请求消息是由请求行、请求头字段、一个空行和消息主体构成。如 12345GET /hello.htm HTTP/1.1User-Agent: Mozilla/4.0 (compatible; MSIE5.01; Windows NT)Host: example.comAccept-Language: en-usAccept-Encoding: gzip, deflate 请求行请求消息的第一行就是请求行。它指明使用的请求方法、资源标示符、和 HTTP 版本。如 1GET /hello.htm HTTP/1.1 请求方法请求方法用来定义操作资源的方式，HTTP/1.1 协议中定义了八种请求方法： GET：读取资源数据 POST：新建资源数据 PUT：更新资源数据 DELETE：删除资源数据 HEAD：读取资源的元数据 OPTIONS：读取该资源所支持的所有请求方法 TRACE：回显服务器收到的请求，主要用于测试或诊断 CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器） 此外，除了上述方法，特定的HTTP服务器还能够扩展自定义的方法。 资源标示符URI、URL和URN是用来识别、定位和命名互联网上的资源。 因为要通过多样的方式识别资源（人的名字可能相同，然而计算机文件只能通过唯一的路径名称组合访问），所以需要标准的识别WWW资源的途径。为了满足这种需要，Tim Berners-Lee 引入了标准的识别、定位和命名的途径：URI、URL和URN。 URI：Uniform Resource Identifier，统一资源标识符 URL：Uniform Resource Locator，统一资源定位符 URN：Uniform Resource Name，统一资源名称 URL 和 URN 都属于 URI。 URI 和 URL 的区别是：URL 更具体。URI 和 URL 都定义了什么是资源。但 URL 还定义了如何获得资源。 关于 URL 的具体描述见这里。 请求头字段用来传递客户端的更多信息，以及传递解析消息主体的必要信息。如 1234User-Agent: Mozilla/4.0 (compatible; MSIE5.01; Windows NT)Host: example.comAccept-Language: en-usAccept-Encoding: gzip, deflate 常见请求头字段有 Accept: 客户端接受哪些 Mine 类型。如 Accept: text/html Accept-Encoding: 支持的编码类型。如 gzip, deflate, sdch Accept-Language: 可接受的语言。如 en-US,en;q=0.8 User-Agent:一个标识客户端的字符串。如 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_5) AppleWebKit/537.36 (KHTML，like Gecko) Chrome/38.0.2125.101 Safari/537.36 Cookie: Cookie。如 sessionid=c8422b97-98e2-4bc6-aa31-9b667d6ca4a5; theme=4; Referer: 从那个页面到的该页面。 空行指示头字段区完成，消息主体开始（如果有消息主体的话）。 消息主体消息主体是请求消息的承载数据。比如在提交POST表单，并且表单方法不是GET时，表单数据就是打包在消息主体内的。消息主体是可选的。 响应消息结构响应消息由一个状态行、响应头字段、一个空行、消息主体构成。如 123456789101112131415HTTP/1.1 200 OKDate: Mon, 27 Jul 2009 12:28:53 GMTServer: Apache/2.2.14 (Win32)Last-Modified: Wed, 22 Jul 2009 19:15:56 GMTContent-Length: 88Content-Type: text/htmlConnection: Closed&lt;html&gt; &lt;body&gt; &lt;h1&gt;Hello, World!&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 状态行由http版本、状态码、状态描述文字构成。如 1HTTP/1.1 200 OK 状态码HTTP 状态码（HTTP Status Code）是用以表示网页服务器 HTTP 响应状态的3位数字代码。 所有的状态码的第一个数字代表了响应的五种状态之一: 1xx：代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行 结束。 2xx：代表请求接收、理解并且接受。 3xx：代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目 标）在本次响应的Location域中指明。当且仅当后续的请求所使用的方法是GET或者HEAD时，用户浏览器才可以 在没有用户介入的情况下自动提交所需要的后续请求。 4xx：代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应 该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。 5xx：代表了服务器在处理请求的过程中有错误或者异常状态发生，，也有可能是服务器意识到以当前的软硬件资源 无法完成对请求的处理。 常见状态码有： 200: 请求已经成功，请求所希望的响应头或者数据体将随着此响应返回 202: 服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了 204: 服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息 304: 被请求的资源内容没有发生更改 400: 包含语法错误，无法被服务器解析 403: 服务器已经接收请求，但是拒绝执行 404: 请求失败，请求所希望得到的资源未在服务器上发现 408: 请求超时。客户端可以再次提交这一请求而无需任何修改 500: 服务器内部错误，无法处理请求 502: 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效响应 504: 作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应 响应头字段和请求消息类似，首部字段会包括服务器本身的一些信息指示、以及响应消息本身的元数据。如 123456Date: Mon, 27 Jul 2009 12:28:53 GMTServer: Apache/2.2.14 (Win32)Last-Modified: Wed, 22 Jul 2009 19:15:56 GMTContent-Length: 88Content-Type: text/htmlConnection: Closed 常见响应头有： Content-Encoding: 数据的编码类型。如 Content-Encoding: gzip Server: 服务器的名称。如 Server:thin 1.5.0 codename Knife Location: 通知客户端新的资源位置。如 Location: http://www.github.com/login Content-Type: 响应数据的类型。如 Content-Type:text/html; charset=UTF-8 Content-Encoding: 响应数据的编码格式。如 gzip。客户端会根据该值对响应内容解码。 消息主体消息主体是响应消息的承载数据。 推荐个命令行 HTTP 客户端HTTPie 类似 cURL，但其 api 相比 cURL 更友好。 HTTPie 示例 参考链接 HTTP 引入 HTTP 协议解析 URI和URL及URN的区别 HTTP协议详解 一面中，如果有笔试，考HTTP协议的可能性较大。 前言一面要讲的内容： HTTP协议的主要特点 HTTP报文的组成部分 HTTP方法 get 和 post的区别 HTTP状态码 什么是持久连接 什么是管线化 二面要讲的内容； 缓存 CSRF攻击 HTTP协议的主要特点 简单快速 灵活 无连接 无状态 通常我们要答出以上四个内容。如果实在记不住，一定要记得后面的两个：无连接、无状态。 我们分别来解释一下。 1 简单快速 简单：每个资源（比如图片、页面）都通过 url 来定位。这都是固定的，在http协议中，处理起来也比较简单，想访问什么资源，直接输入url即可。 2 灵活 http协议的头部有一个数据类型，通过http协议，就可以完成不同数据类型的传输。 3 无连接 连接一次，就会断开，不会继续保持连接。 4 无状态 客户端和服务器端是两种身份。第一次请求结束后，就断开了，第二次请求时，服务器端并没有记住之前的状态，也就是说，服务器端无法区分客户端是否为同一个人、同一个身份。 有的时候，我们访问网站时，网站能记住我们的账号，这个是通过其他的手段（比如 session）做到的，并不是http协议能做到的。 HTTP报文的组成部分 在回答此问题时，我们要按照顺序回答： 先回答的是，http报文包括：请求报文和响应报文。 再回答的是，每个报文包含什么部分。 最后回答，每个部分的内容是什么 1请求报文包括： 请求行：包括请求方法、请求的url、http协议及版本。 请求头：一大堆的键值对。 空行指的是：当服务器在解析请求头的时候，如果遇到了空行，则表明，后面的内容是请求体 请求体：数据部分。 2 响应报文包括： 状态行：http协议及版本、状态码及状态描述。 响应头 空行 响应体 HTTP方法包括： GET：获取资源 POST：传输资源 put：更新资源 DELETE：删除资源 HEAD：获得报文首部 HTTP方法有很多，但是上面这五个方法，要求在面试时全部说出来，不要漏掉。 get 和post` 比较常见。 put 和 delete 在实际应用中用的很少。况且，业务中，一般不删除服务器端的资源。 head 可能偶尔用的到。 get 和 post的区别 区别有很多，如果记不住，面试时，至少要任意答出其中的三四条。 有一点要强调，get是相对不隐私的，而post是相对隐私的。 我们大概要记住以下几点： 浏览器在回退时，get 不会重新请求，但是post会重新请求。【重要】 get请求会被浏览器主动缓存，而post不会。【重要】 get请求的参数，会报保留在浏览器的历史记录里，而post不会。做业务时要注意。为了防止CSRF攻击，很多公司把get统一改成了post。 get请求在url中传递的参数有大小限制，基本是2kb`，不同的浏览器略有不同。而post没有注意。 get的参数是直接暴露在url上的，相对不安全。而post是放在请求体中的。 http状态码http状态码有那些？分别代表是什么意思？ 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 200 OK 正常返回信息 201 Created 请求成功并且服务器创建了新的资源 202 Accepted 服务器已接受请求，但尚未处理 301 Moved Permanently 请求的网页已永久移动到新位置。 302 Found 临时性重定向。 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。 304 Not Modified 自从上次请求后，请求的网页未修改过。 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 401 Unauthorized 请求未授权。 403 Forbidden 禁止访问。 404 Not Found 找不到如何与 URI 相匹配的资源。 500 Internal Server Error 最常见的服务器端错误。 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护） http状态码分类： 常见的http状态码： 部分解释： 206的应用：range指的是请求的范围，客户端只请求某个大文件里的一部分内容。比如说，如果播放视频地址或音频地址的前面一部分，可以用到206。 301：重定向（永久）。 302：重定向（临时）。 304：我这个服务器告诉客户端，你已经有缓存了，不需要从我这里取了。 400和401用的不多,未授权。403指的是请求被拒绝。404指的是资源不存在。 HTTP 状态码100 ?Continue ?继续，一般在发送 post 请求时，已发送了 http header 之后服务端将返回此信息，表示确认，之后发送具体参数信息 200 ?OK ? 正常返回信息 201 ?Created ?请求成功并且服务器创建了新的资源 202 ?Accepted ?服务器已接受请求，但尚未处理 301 ?Moved Permanently ?请求的网页已永久移动到新位置。 302 Found ?临时性重定向。 303 See Other ?临时性重定向，且总是使用 GET 请求新的 URI。 304 ?Not Modified ?自从上次请求后，请求的网页未修改过。 400 Bad Request ?服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 401 Unauthorized ?请求未授权。 403 Forbidden ?禁止访问。 404 Not Found ?找不到如何与 URI 相匹配的资源。 500 Internal Server Error ?最常见的服务器端错误。 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 持久链接/http长连接 如果你能答出持久链接，这是面试官很想知道的一个点。 轮询：http1.0中，客户端每隔很短的时间，都会对服务器发出请求，查看是否有新的消息，只要轮询速度足够快，例如1秒，就能给人造成交互是实时进行的印象。这种做法是无奈之举，实际上对服务器、客户端双方都造成了大量的性能浪费。 长连接：HTTP1.1中，通过使用Connection:keep-alive进行长连接，。客户端只请求一次，但是服务器会将继续保持连接，当再次请求时，避免了重新建立连接。 注意，HTTP 1.1默认进行持久连接。在一次 TCP 连接中可以完成多个 HTTP 请求，但是对每个请求仍然要单独发 header，Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。 长连接中的管线化 如果能答出管线化，则属于加分项。 1 管线化的原理 长连接时，默认的请求这样的： 1请求1 --&gt; 响应1 --&gt;请求2 --&gt; 响应2 --&gt; 请求3 --&gt; 响应3 管线化就是，我把现在的请求打包，一次性发过去，你也给我一次响应回来。 2 管线化的注意事项 面试时，不会深究管线化。如果真要问你，就回答：“我没怎么研究过，准备回去看看~” http状态码有那些？分别代表是什么意思？12345678910111213141516171819简单版 [ 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 200 OK 正常返回信息 201 Created 请求成功并且服务器创建了新的资源 202 Accepted 服务器已接受请求，但尚未处理 301 Moved Permanently 请求的网页已永久移动到新位置。 302 Found 临时性重定向。 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。 304 Not Modified 自从上次请求后，请求的网页未修改过。 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 401 Unauthorized 请求未授权。 403 Forbidden 禁止访问。 404 Not Found 找不到如何与 URI 相匹配的资源。 500 Internal Server Error 最常见的服务器端错误。 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 ] 说说TCP传输的三次握手四次挥手策略 为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志：SYN和ACK 发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。 最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。 若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包 断开一个TCP连接则需要“四次握手”： 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号） 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手 TCP和UDP的区别 TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来 UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！ UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境 HTTP和HTTPS HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS 默认HTTP的端口号为80，HTTPS的端口号为443 为什么HTTPS安全因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性 关于Http 2.0 你知道多少？ HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。 HTTP/2提供更多的加密支持 HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。 它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽 GET和POST的区别，何时使用POST？ GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符 POST：一般用于修改服务器上的资源，对所发送的信息没有限制。 GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。 然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 说说网络分层里七层模型是哪七层 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS） 传输层（TCP和UDP） 网络层（IP） 物理和数据链路层（以太网） 每一层的作用如下： 物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）数据链路层：将比特组装成帧和点到点的传递（帧Frame） 网络层：负责数据包从源到宿的传递和网际互连（包PackeT） 传输层：提供端到端的可靠报文传递和错误恢复（段Segment） 会话层：建立、管理和终止会话（会话协议数据单元SPDU） 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU） 应用层：允许访问OSI环境的手段（应用协议数据单元APDU） 讲讲304缓存的原理 服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存 304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件 客户端请求一个页面（A）。 服务器返回页面A，并在给A加上一个ETag。 客户端展现该页面，并将页面连同ETag一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。 服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体 HTTP/2 与 HTTP/1.x 的关键区别 二进制协议代替文本协议，更加简洁高效 针对每个域只使用一个多路复用的连接 压缩头部信息减小开销 允许服务器主动推送应答到客户端的缓存中 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？ 01.浏览器查找域名对应的IP地址(DNS 查询：浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;ISP DNS 缓存-&gt;根域名服务器) 02.浏览器向 Web 服务器发送一个 HTTP 请求（TCP三次握手） 03.服务器 301 重定向（从 http://example.com 重定向到 http://www.example.com） 04.浏览器跟踪重定向地址，请求另一个带 www 的网址 05.服务器处理请求（通过路由读取资源） 06.服务器返回一个 HTTP 响应（报头中把 Content-type 设置为 ‘text/html’） 07.浏览器进 DOM 树构建 08.浏览器发送请求获取嵌在 HTML 中的资源（如图片、音频、视频、CSS、JS等） 09.浏览器显示完成页面 10.浏览器发送异步请求 http 无状态无连接 http 协议对于事务处理没有记忆能力 对同一个url请求没有上下文关系 每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况 服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器 人生若只如初见，请求过的资源下一次会继续进行请求 http协议无状态中的 状态 到底指的是什么？ 【状态】的含义就是：客户端和服务器在某次会话中产生的数据 那么对应的【无状态】就意味着：这些数据不会被保留 通过增加cookie和session机制，现在的网络请求其实是有状态的 在没有状态的http协议下，服务器也一定会保留你每次网络请求对数据的修改，但这跟保留每次访问的数据是不一样的，保留的只是会话产生的结果，而没有保留会话 http-cache：就是 http 缓存1. 首先得明确 http 缓存的好处 减少了冗余的数据传输，减少网费 减少服务器端的压力 Web 缓存能够减少延迟与网络阻塞，进而减少显示某个资源所用的时间 加快客户端加载网页的速度 2. 常见 http 缓存的类型 私有缓存（一般为本地浏览器缓存） 代理缓存 3. 然后谈谈本地缓存 本地缓存是指浏览器请求资源时命中了浏览器本地的缓存资源，浏览器并不会发送真正的请求给服务器了。它的执行过程是 第一次浏览器发送请求给服务器时，此时浏览器还没有本地缓存副本，服务器返回资源给浏览器，响应码是200 OK，浏览器收到资源后，把资源和对应的响应头一起缓存下来 第二次浏览器准备发送请求给服务器时候，浏览器会先检查上一次服务端返回的响应头信息中的Cache-Control，它的值是一个相对值，单位为秒，表示资源在客户端缓存的最大有效期，过期时间为第一次请求的时间减去Cache-Control的值，过期时间跟当前的请求时间比较，如果本地缓存资源没过期，那么命中缓存，不再请求服务器 如果没有命中，浏览器就会把请求发送给服务器，进入缓存协商阶段。 与本地缓存相关的头有：Cache-Control、Expires，Cache-Control有多个可选值代表不同的意义，而Expires就是一个日期格式的绝对值。 3.1 Cache-Control Cache-Control是HTPP缓存策略中最重要的头，它是HTTP/1.1中出现的，它由如下几个值 no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载 no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源 public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。 private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。 max-age：从当前请求开始，允许获取的响应被重用的最长时间（秒）。 1234# 例如：Cache-Control: public, max-age=1000 # 表示资源可以被所有用户以及代理服务器缓存，最长时间为1000秒。 3.2 Expires Expires是HTTP/1.0出现的头信息，同样是用于决定本地缓存策略的头，它是一个绝对时间，时间格式是如Mon, 10 Jun 2015 21:31:12 GMT，只要发送请求时间是在Expires之前，那么本地缓存始终有效，否则就会去服务器发送请求获取新的资源。如果同时出现Cache-Control：max-age和Expires，那么max-age优先级更高。他们可以这样组合使用 12Cache-Control: publicExpires: Wed, Jan 10 2018 00:27:04 GMT 3.3 所谓的缓存协商 当第一次请求时服务器返回的响应头中存在以下情况时 没有 Cache-Control 和 Expires Cache-Control 和 Expires 过期了 Cache-Control 的属性设置为 no-cache 时 那么浏览器第二次请求时就会与服务器进行协商，询问浏览器中的缓存资源是不是旧版本，需不需要更新，此时，服务器就会做出判断，如果缓存和服务端资源的最新版本是一致的，那么就无需再次下载该资源，服务端直接返回304 Not Modified 状态码，如果服务器发现浏览器中的缓存已经是旧版本了，那么服务器就会把最新资源的完整内容返回给浏览器，状态码就是200 Ok，那么服务端是根据什么来判断浏览器的缓存是不是最新的呢？其实是根据HTTP的另外两组头信息，分别是：Last-Modified/If-Modified-Since 与 ETag/If-None-Match。 Last-Modified 与 If-Modified-Since 浏览器第一次请求资源时，服务器会把资源的最新修改时间Last-Modified:Thu, 29 Dec 2011 18:23:55 GMT放在响应头中返回给浏览器 第二次请求时，浏览器就会把上一次服务器返回的修改时间放在请求头If-Modified-Since:Thu, 29 Dec 2011 18:23:55发送给服务器，服务器就会拿这个时间跟服务器上的资源的最新修改时间进行对比 如果两者相等或者大于服务器上的最新修改时间，那么表示浏览器的缓存是有效的，此时缓存会命中，服务器就不再返回内容给浏览器了，同时Last-Modified头也不会返回，因为资源没被修改，返回了也没什么意义。如果没命中缓存则最新修改的资源连同Last-Modified头一起返回 1234# 第一次请求返回的响应头Cache-Control:max-age=3600Expires: Fri, Jan 12 2018 00:27:04 GMTLast-Modified: Wed, Jan 10 2018 00:27:04 GMT 12# 第二次请求的请求头信息If-Modified-Since: Wed, Jan 10 2018 00:27:04 GMT 这组头信息是基于资源的修改时间来判断资源有没有更新，另一种方式就是根据资源的内容来判断，就是接下来要讨论的 ETag 与 If-None-Match ETag与If-None-Match ETag/If-None-Match与Last-Modified/If-Modified-Since的流程其实是类似的，唯一的区别是它基于资源的内容的摘要信息（比如MD5 hash）来判断 浏览器发送第二次请求时，会把第一次的响应头信息ETag的值放在If-None-Match的请求头中发送到服务器，与最新的资源的摘要信息对比，如果相等，取浏览器缓存，否则内容有更新，最新的资源连同最新的摘要信息返回。用ETag的好处是如果因为某种原因到时资源的修改时间没改变，那么用ETag就能区分资源是不是有被更新。 1234# 第一次请求返回的响应头：Cache-Control: public, max-age=31536000ETag: \"15f0fff99ed5aae4edffdd6496d7131f\" 123# 第二次请求的请求头信息：If-None-Match: \"15f0fff99ed5aae4edffdd6496d7131f\" Http2 是什么HTTP/2（超文本传输协议第 2 版，最初命名为 HTTP 2.0），是 HTTP 协议的的第二个主要版本，使用于万维网。HTTP/2 是 HTTP 协议自 1999 年 HTTP 1.1 发布后的首个更新，主要基于 SPDY 协议（是 Google 开发的基于 TCP 的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验）。 与 HTTP 1.1 相比，主要区别包括HTTP/2 采用二进制格式而非文本格式HTTP/2 是完全多路复用的，而非有序并阻塞的——只需一个连接即可实现并行使用报头压缩，HTTP/2 降低了开销HTTP/2 让服务器可以将响应主动“推送”到客户端缓存中 解析： 状态码 类别 描述 1xx Informational（信息状态码） 接受请求正在处理 2xx Success（成功状态码） 请求正常处理完毕 3xx Redirection（重定向状态码） 需要附加操作已完成请求 4xx Client Error（客户端错误状态码） 服务器无法处理请求 5xx Server Error（服务器错误状态码） 服务器处理请求出错 Http 请求的整个过程简洁版： 1.域名解析 –&gt; 2.发起 TCP 的 3 次握手 –&gt; 3.建立 TCP 连接后发起 http 请求 –&gt; 4.服务器响应 http 请求，浏览器得到 html 代码 –&gt; 5.浏览器解析 html 代码，并请求 html 代码中的资源（如 js、css、图片等） –&gt; 6.浏览器对页面进行渲染呈现给用户 http 缓存配置怎么设置前端设置 http 缓存,前端设置 html 页面缓存方法：静态的 html 页面想要设置使用缓存需要通过 HTTP 的 META 设置 expires 和 cache-control 设置如下网页元信息: 12&lt;meta http-equiv=\"Cache-Control\" content=\"max-age=7200\" /&gt;&lt;meta http-equiv=\"Expires\" content=\"Mon, 20 Jul 2013 23:00:00 GMT\" /&gt; 解答:cache-control：||no-cache||no-store||max-age 1.no-cache： 表面意为“数据内容不被缓存”，而实际数据是被缓存到本地的，只是每次请求时候直接绕过缓存这一环节直接向服务器请求最新资源，由于浏览器解释不一样， 例如 ie 中我们设置了 no-cache 之后，请求虽然不会直接使用缓存，但是还会用缓存数据与服务器数据进行一致性检测(也就是说还是有几率会用到缓存的), firefox 中则完全无视 no-cache 存在，详细解释见 no-store; 2.no-store： 指示缓存不存储此次请求的响应部分。与 no-cache 比较来说，一个是不用缓存，一个是不存储缓存;按理来说这个设置更加粗暴直接禁用缓存， 但是具体实现起来 浏览器之间差异却特别大，一般不会直接用该字段进行设置，不过 no-store 是为了防止缓存被恶意修改存储路径导致信息被泄露而设置的， 毕竟有它的用处，在 firefox 中实现缓存是通过文件另存为将缓存副本保存到本地，直接利用 no-cache 对其是无效的，如果加上 no-store 设置的话 则可以起到与 no-cache 一样的效果; 即：cache-control:no-cache,no-store;可以确保在支持 http1.1 版本中各大浏览器回车后退刷新无缓存； 再加上 Pragma: no-cache 设置兼容版本 1.0 即可(不过为了防止一致性检测时候的万一我们还是最好加上一致性检测的内容，如下所示几种方式)； 3.max-age： 例如 Cache-control: max-age=3；表示此次请求成功后 3 秒之内发送同样请求不会去服务器重新请求，而是使用本地缓存；同样我们如果设置 max-age=0 表示立即抛弃缓存直接发送请求到服务器 以下内容来自:http://www.runoob.com/tags/att-meta-http-equiv.html HTML http-equiv 属性HTML meta 标签参考手册 HTML 标签 实例每隔 30 秒刷新一次文档： 123&lt;head&gt; &lt;meta http-equiv=\"refresh\" content=\"30\" /&gt;&lt;/head&gt; 扩展： 与缓存有关的 header我们来看看每个 header 的具体含义。 Request Cache-Control: max-age=0 以秒为单位If-Modified-Since: Mon, 19 Nov 2012 08:38:01 GMT 缓存文件的最后修改时间。If-None-Match: “0693f67a67cc1:0” 缓存文件的 Etag 值Cache-Control: no-cache 不使用缓存Pragma: no-cache 不使用缓存 Response Cache-Control: public 响应被缓存，并且在多用户间共享， （公有缓存和私有缓存的区别，请看另一节）Cache-Control: private 响应只能作为私有缓存，不能在用户之间共享Cache-Control:no-cache 提醒浏览器要从服务器提取文档进行验证Cache-Control:no-store 绝对禁止缓存（用于机密，敏感文件）Cache-Control: max-age=60 60 秒之后缓存过期（相对时间）Date: Mon, 19 Nov 2012 08:39:00 GMT 当前 response 发送的时间Expires: Mon, 19 Nov 2012 08:40:01 GMT 缓存过期的时间（绝对时间）Last-Modified: Mon, 19 Nov 2012 08:38:01 GMT 服务器端文件的最后修改时间ETag: “20b1add7ec1cd1:0” 服务器端文件的 Etag 值 Accept 和 Content-TypeAccept 请求头用来告知客户端可以处理的内容类型，这种内容类型用 MIME 类型来表示。服务器使用 Content-Type 应答头通知客户端它的选择。 123Accept: text/htmlAccept: image/*Accept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8 1.Accept 属于请求头， Content-Type 属于实体头。 Http 报头分为通用报头，请求报头，响应报头和实体报头。 请求方的 http 报头结构：通用报头|请求报头|实体报头 响应方的 http 报头结构：通用报头|响应报头|实体报头 2.Accept 代表发送端（客户端）希望接受的数据类型。 比如：Accept：text/xml; 代表客户端希望接受的数据类型是 xml 类型 Content-Type 代表发送端（客户端|服务器）发送的实体数据的数据类型。 比如：Content-Type：text/html; 代表发送端发送的数据格式是 html。 二者合起来， Accept:text/xml； Content-Type:text/html 即代表希望接受的数据类型是 xml 格式，本次请求发送的数据的数据格式是 html。 http 协议缓存机制答案：参考 如何处理不让别人盗用你的图片，访问你的服务器资源 http header, 对 refer 做判断看来源是不是自己的网站，如果不是就拒绝 通过 session 校验，如果不通过特定服务生成 cookie 和 session 就不能请求得到资源 Http 与 Https 的区别 HTTP 的 URL 以 http:// 开头，而 HTTPS 的 URL 以 https:// 开头 HTTP 是不安全的，而 HTTPS 是安全的 HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443 在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 的安全传输机制工作在传输层 HTTP 无法加密，而 HTTPS 对传输的数据进行加密 HTTP 无需证书，而 HTTPS 需要 CA 机构 wosign 的颁发的 SSL 证书 解析：参考 什么是 Http 协议无状态协议?怎么解决 Http 协议无状态协议?无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息也就是说，当客户端一次 HTTP 请求完成以后，客户端再发送一次 HTTP 请求，HTTP 并不知道当前客户端是一个”老用户“。 可以使用 Cookie 来解决无状态的问题，Cookie 就相当于一个通行证，第一次访问的时候给客户端发送一个 Cookie，当客户端再次来的时候，拿着 Cookie(通行证)，那么服务器就知道这个是”老用户“。 解析：参考 常用的 HTTP 方法有哪些 GET：用于请求访问已经被 URL（统一资源标识符）识别的资源，可以通过 URL 传参给服务器。 POST：用于传输信息给服务器，主要功能与 Get 方法类似，但一般推荐 POST 方式。 PUT：传输文件，报文主体包含文件内容，保存到对应 URL 位置。 HEAD：获取报文首部，与 GET 方法类似，只是不返回报文主体，一般用于验证 URL 是否有效。 DELET：删除文件，与 PUT 方法相反，删除对应 URL 位置的文件。OPTIONS：查询相应 URL 支持的 HTTP 方法。 一次完整的 HTTP 请求所经历的 7 个步骤HTTP 通信机制是在一次完整的 HTTP 通信过程中，Web 浏览器与 Web 服务器之间将完成下列 7 个步骤： 建立 TCP 连接 在 HTTP 工作开始之前，Web 浏览器首先要通过网络与 Web 服务器建立连接，该连接是通过 TCP 来完成的，该协议与 IP 协议共同构建 Internet，即著名的 TCP/IP 协议族，因此 Internet 又被称作是 TCP/IP 网络。HTTP 是比 TCP 更高层次的应用层协议，根据规则， 只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立 TCP 连接，一般 TCP 连接的端口号是 80。 Web 浏览器向 Web 服务器发送请求行 一旦建立了 TCP 连接，Web 浏览器就会向 Web 服务器发送请求命令。例如：GET /sample/hello.jsp HTTP/1.1。 Web 浏览器发送请求头 浏览器发送其请求命令之后，还要以头信息的形式向 Web 服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。 Web 服务器应答 客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。 Web 服务器发送应答头 正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。 Web 服务器向浏览器发送数据 Web 服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以 Content-Type 应答头信息所描述的格式发送用户所请求的实际数据。 Web 服务器关闭 TCP 连接 一般情况下，一旦 Web 服务器向浏览器发送了请求数据，它就要关闭 TCP 连接，然后如果浏览器或者服务器在其头信息加入了这行代码： 1Connection:keep-alive TCP 连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。 建立 TCP 连接-&gt;发送请求行-&gt;发送请求头-&gt;（到达服务器）发送状态行-&gt;发送响应头-&gt;发送响应数据-&gt;断 TCP 连接 三次握手TCP 协议是面向连接的通信协议，即在传输数据前先在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。 在 TCP 连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手” 第一次握手，客户端向服务器端发送一个带 SYN 标志的数据包，等待服务器确认 第二次握手，服务器端向客户端回传一个带有 SYN/ACK 标志的数据包，通知客户端收到了连接请求 第三次握手，客户端再次向服务器端回传一个带 ACK 标志的数据包，确认连接，“握手”结束。 四次挥手1、客户端向服务器发送一个断开连接的请求（不早了，我该走了）； 2、服务器接到请求后发送确认收到请求的信号（知道了）； 3、服务器向客户端发送断开通知（我也该走了）； 4、客户端接到断开通知后断开连接并反馈一个确认信号（嗯，好的），服务器收到确认信号后断开连接； 解析： 第一次挥手：主动关闭方发送一个 FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在 fin 包之前发送出去的数据，如果没有收到对应的 ack 确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。 第二次挥手：被动关闭方收到 FIN 包后，发送一个 ACK 给对方，确认序号为收到序号+1（与 SYN 相同，一个 FIN 占用一个序号）。 第三次挥手：被动关闭方发送一个 FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。 第四次挥手：主动关闭方收到 FIN 后，发送一个 ACK 给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。 线程与进程的区别a. 一个程序至少有一个进程，一个进程至少有一个线程 b. 线程的划分尺度小于进程，使得多线程程序的并发性高 c. 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率 d. 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制 e. 多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配 WEB 应用从服务器主动推送 Data 到客户端有那些方式？a. html5 websoket b. WebSocket 通过 Flash c. XHR 长时间连接 d. XHR Multipart Streaming e. 不可见的 Iframe f. 标签的长时间连接(可跨域) 请简述如何在 HTML 中开启和关闭 DNS 预读取?答案： DNS 预读取 概念： 浏览器主动去执行域名解析功能。 当浏览网页时，浏览器会对网页中的域名进行解析缓存，这样当单击当前网页中的连接时就无需进行 DNS 解析，减少用户等待时间，提高用户体验。 范围： 图片、CSS、JS 或 html 上的 link 等 URL。 开关和使用： 123&lt;meta http-equiv=\"x-dns-prefetch-control\" content=\"off\" /&gt;&lt;link rel=\"dns-prefetch\" href=\"//www.spreadfirefox.com\" /&gt; 前端优化： 减少 DNS 请求次数； 进行 DNS 预获取； TCP 和 UDP 的区别TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个 TCP 连接必须要经过三次“对话”才能建立起来 UDP（User Data Protocol，用户数据报协议）是与 TCP 相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！UDP 适用于一次只传送少量数据、对可靠性要求不高的应用环境。 Web Worker 和 webSocketworker 主线程: 12345671.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个worker实例。2.通过worker.postMessage( data ) 方法来向worker发送数据。3.绑定worker.onmessage方法来接收worker发送过来的数据。4.可以使用 worker.terminate() 来终止一个worker的执行。 WebSocket 是 Web 应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个 Html5 协议，WebSocket 的连接是持久的，他通过在客户端和服务器之间保持双工连接，服务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。","categories":[{"name":"前端面试题","slug":"前端面试题","permalink":"https://qw8.github.io/categories/前端面试题/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://qw8.github.io/tags/HTTP/"},{"name":"前端通信","slug":"前端通信","permalink":"https://qw8.github.io/tags/前端通信/"}]},{"title":"JavaScript笔试题","slug":"interview/JavaScript笔试题","date":"2020-06-16T02:24:57.000Z","updated":"2024-02-18T03:25:44.000Z","comments":true,"path":"/interview/javascript-bi-shi-ti.html","link":"","permalink":"https://qw8.github.io/interview/javascript-bi-shi-ti.html","excerpt":"","text":"单选题JS基础js概念与类型检测 以下不属于 typeof 运算符返回值的是？ 1234A. \"string\"B. \"function\"C. \"object\"D. \"null\" 执行以下代码，错误的输出结果是 1234A. 输入：typeof &#123;\"x\":1&#125; 输出：\"object\" B. 输入：typeof 1 输出：\"number\" C. 输入：typeof [&#123;x:1&#125;] 输出：\"array\" D. 输入：typeof NaN 输出：\"number\" 可以用typeof来判断的基本类型有 1234A. undefinedB. nullC. arrayD. object 以下不属于JavaScript基本数据类型的是： 1234A. BooleanB. undefinedC. SymbolD. Array 以下关于JavaScript中数据类型的说法错误的是() 1234A. 数据类型分为基本数据类型和引用数据类型B. JavaScript一共有8种数据类型C. Object是引用数据类型，且只存储于堆(heap)中D. BigInt是可以表示任意精度整数的基本数据类型，存储于栈(stack)中 答案 1DCADC 逻辑判断 请选择结果为ture的表达式？ 1234A. null instanceof ObjectB. null === undefinedC. null == undefinedD. NaN == NaN 下列代码结果为 true 的是？ 1234A. Symbol.for('a') === Symbol.for('a')B. Symbol('a') === Symbol('a')C. NaN === NaND. &#123;&#125; === &#123;&#125; 根据如下变量，下列表达式中返回值为true的是 123456789var a = 1;var b = [];var c = '';var d = true; A. (a || b) === trueB. (b &amp;&amp; c) === trueC. (c &amp;&amp; d) === trueD. (d || a) === true 1==true的返回值是true，这句话是否正确？ 12A. TB. F 下面代码输出为true的是? 1234A. console.log([] === []);B. console.log(undefined == 0);C. console.log(undefined == false);D. console.log(false == ''); 浏览器环境下，以下打印结果为true的是 1234A. console.log(\"12\" === 12)B. console.log (NaN === NaN)C. console.log (typeof(null) === typeof(window))D. console.log ([1,2,3] === [1,2,3]) 注意浏览器环境与node环境的差别，比如C选项 以下表达式，正确的是 1234A. Number('a') == Number('a')B. -1 == trueC. 3 + '2' === 5D. ![] == '' 答案 1CADADCD Math 如何把 7.25 四舍五入为最接近的整数 1234A. Math.round(7.25)B. Math.ceil(7.25)C. round(7.25)D. Math.rnd(7.25) 下面哪个选项可以产生0&lt;=num&lt;=10的随机整数 1234A. Math.floor(Math.random()*6)B. Math.floor(Math.random()*10)C. Math.floor(Math.random()*11)D. Math.ceil(Math.random()*10) 以下( )表达式产生一个0~7之间(含0,7)的随机整数 123A. Math.floor(Math.random()*6)B. Math.floor(Math.random()*7)C. Math. floor(Math.random()*8) 答案 1A CD(注意D) C 字符串 split() 方法用于把一个字符串分割成字符串数组。 12A. TB. F String对象的哪个方法可以寻找子字符串并返回该子字符串位置 1234A. match()B. indexOf()C. search()D. concat() 答案 1A BC JSON 下面哪一个是JSON数据？ 1234A. ｛name:\"xiaoming\",age,\"student\"｝B. ｛\"name\":\"xiaoming\",\"age\":\"student\"｝C. ｛\"xiaoming\",\"student\"｝D. [\"xiaoming\",\"student\"] 下面分别使用 JSON.stringify 方法，返回值 res 分别是 123456789101112const fn = function()&#123;&#125;const res = JSON.stringify(fn)const num = 123const res = JSON.stringify(num)const res = JSON.stringify(NaN)const b = trueconst res = JSON.stringify(b) A. 'function'、'123'、'NaN'、'true'B. undefined、'123'、undefined、'true'C. undefined、'123'、'null'、'true'D. undefined、'123'、'null'、undefined 答案 1BC 数组 js数组中不会改变原有数组的方法是() 1234A. pushB. concatC. sortD. shift 下列哪种数组的方法不会修改数组本身 1234A. sliceB. spliceC. sortD. unshift JavaScript中需要往数组末尾处添加一个元素，应该使用以下哪个方法： 1234A. pushB. popC. shiftD. unshift 以下js操作Array的方法中不能添加元素的是： 1234A. pushB. popC. unshiftD. splice 数组以下哪个方法会影响原数组？ 1234A. concatB. spliceC. sliceD. join JavaScript中，下列哪一个Array的方法的返回值类型和其他不同 1234A. concatB. shiftC. filterD. map 如下的Array.prototype上的方法中，那个方法不会改变原有的数组？ 1234A. pushB. sliceC. spliceD. sort 对于一个数字组成的数组 nums，现在需要执行在不改动 nums 的基础上去重操作，返回一个新的无重复元素的数组，以下几段代码能完成这一操作的是() 1234567891011121314151617181920212223// (1)const newNums = Array.from(new Set(nums)) // (2)const newNums = nums.filter((n, i) =&gt; &#123; return nums.indexOf(n) === i&#125;) // (3)const newNums = nums.forEach((n, i) =&gt; &#123; return nums.indexOf(n) === i&#125;) // (4)const newNums = nums.reduce((acc, n, i) =&gt; &#123; return [].concat(acc, nums.indexOf(n) === i ? n : [])&#125;) A. (1)、(2)、(3)、(4)B. (1)、(3)、(4)C. (1)、(2)、(4)D. (1)、(4) 答案 12BAABBBBC 正则 正则表达式 ^d+[^d]+ 能匹配下列哪个字符串？ 1234A. 123B. 123aC. d123D. 123def 下面哪个不是RegExp对象的方法 1234A. testB. matchC. execD. compile 以下哪项可以去除变量str中的所有空格 1234A. str.replace(`/\\s*/g,\"\"`)B. str.replace(`/^\\s|\\s$/g,\"\"`)C. str.replace(`/^\\s*/, \"\"`)D. str.replace(`/(\\s*$)/g, \"\"`) 答案 1CBA 其他 下列函数哪个不是JavaScript的全局函数 1234A. encodeURIB. parseFloatC. roundD. eval 编写高性能JavaScript，以下描述错误的是 1234A. 遵循严格模式：\"use strict\"B. 将js脚本放在页面顶部，加快渲染页面C. 将js脚本成组打包，减少请求，尽量减少使用闭包D. 使用非阻塞方式下载js脚本，最小化重绘(repaint)和回流(reflow) 有关JavaScript中系统方法的描述，错误的是？ 1234A. parseFloat方法：该方法将一个字符串转换成对应的小数B. isNaN方法：该方法用于检测参数是否为数值型，如果是，返回true，否则，返回false。C. escape方法： 该方法返回对一个字符串编码后的结果字符串D. eval方法：该方法将某个参数字符串作为一个JavaScript执行题 下面列出的浏览器，无webkit内核的是() 1234A. chromeB. SafariC. 搜狗浏览器D. Firefox 下列代码哪个能够实现获取形式为 2017-08-01 形式的日期( )？ 123456789101112131415161718192021// Avar formatDate=getDate()// Bvar formatDate = new Date()// Cvar formatDate = function (date) &#123; var y = date.getFullYear(); var m = date.getMonth() + 1; var d = date.getDate(); return y + '-' + m + '-' + d;&#125;;// Dvar formatDate = function (date) &#123; var y = date.getFullYear(); var m = date.getMonth() + 1; m = m &lt; 10 ? '0' + m : m; var d = date.getDate(); d = d &lt; 10 ? ('0' + d) : d; return y + '-' + m + '-' + d;&#125;; 下面哪一项不能最小化重绘(repaint)和回流(reflow) 1234A. 需要对元素进行复杂的操作时，可以先隐藏(display:\"none\")，操作完成后再显示B. 需要创建多个DOM节点时，使用DocumentFragment创建完后一次性的加入documentC. 尽量避免用table布局(table元素一旦触发回流就会导致table里所有的其它元素回流)D. 尽量不要使用 css 属性简写，如：用border-width, border-style, border-color代替border 答案 1CBBDDD JS深入this 下列哪种方法不能改变this指向() 1234A. evalB. applyC. bindD. call 在JavaScript中下面选项关于this描述正确的是 1234A. 在使用new实例化对象时, this指向这个实例对象B. 将对象的方法赋值给变量A。执行A()时 该方法中的this指向这个对象。 C. 在函数定义时,this指向全局变量D. 在浏览器下的全局范围内，this指向全局对象 下面有关JavaScript中call和apply方法的描述，错误的是？ 1234A. call与apply都属于Function.prototype的一个方法，所以每个function实例都有call、apply属性B. 两者传递的参数不同，call函数第一个参数都是要传入给当前对象的对象，apply不是C. apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入D. call传入的则是直接的参数列表。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。 答案 1AAB 作用域(闭包) 内存泄漏是 javascript 代码中必须尽量避免的，以下几段代码可能会引起内存泄漏的有() 123456789101112131415161718192021222324252627// (1)function getName() &#123; name = 'javascript'&#125;getName() // (2)const elements = &#123; button: document.getElementById('button')&#125;;function removeButton() &#123; document.body.removeChild(elements.button);&#125;removeButton() // (3)let timer = setInterval(() =&gt; &#123; const node = document.querySelector('#node') if(node) &#123; clearInterval(timer) &#125;&#125;, 1000); A. (1)、(2)、(3)B. (2)、(3)C. (1)、(3)D. (1)、(2) 那个操作不会造成内存泄露 1234A. 没有清理的DOM元素引用B. 被遗忘的定时器C. 事件侦听没有移除D. 局部变量不用时，没有设为null 下列关于闭包理解错误的是 1234A. 增加一定的内存消耗B. 使用不当可能会导致内存泄漏C. 可以使用闭包模拟私有方法D. 闭包会改动对象的原型链 答案 1DDD 原型与继承 JavaScript实现继承的方式，不正确的是： 1234A. 原型链继承B. 构造函数继承C. 组合继承D. 关联继承 所有对象都有原型 12A. TB. F 以下关于原型链的描述正确的是: 1234A. 通过原型链继承的属性和对象自己定义的属性等效B. 通过原型链可以模拟对象的私有属性C. 在对象上访问不存在的属性时,会依次遍历整条原型链D. 所有 JavaScript 中的对象都是位于原型链顶端的 `Object` 的实例 答案 1DBC 其他 以下不属于前端数据存储方式的是？ 1234A. jsonpB. cookieC. localStorageD. sessionStorage 答案 1A DOM题事件流 将A元素拖拽并放置到B元素中，B元素需要做哪项操作()？ 1234A. event.preventDefault()B. event.prevent()C. event.drag()D. event.drop() 以下不支持冒泡的鼠标事件为( )？ 1234A. mouseoverB. clickC. mouseleaveD. mousemove 在javascript中，用于阻止默认事件的默认操作的方法是 1234A. stopDeafault()B. stopPropagation()C. preventDefault()D. preventDefaultEven() 事件传播的三个阶段是什么 1234目标 -&gt; 捕获 -&gt; 冒泡冒泡 -&gt; 目标 -&gt; 捕获目标 -&gt; 冒泡 -&gt; 捕获捕获 -&gt; 目标 -&gt; 冒泡 下面有关 javascript 常见事件的触发情况，描述错误的是？ 1234A. onchange：用户改变域的内容B. onkeypress：某个键盘的键被按下或按住C. onmousedown：某个鼠标按键被按下D. onblur：元素获得焦点 答案 1ACCDD DOM遍历 下列哪项不属于DOM查找节点的属性()？ 1234A. parentObj.firstChildB. parentObj.childrenC. neborNode.previousSiblingD. neborNode.siblings DOM中，给父节点添加子节点的正确方法为()？ 1234A. appendChild(parentNode,newNode);B. append(parentNode,newNode);C. parentNode.append(newNode);D. parentNode.appendChild(newNode); JavaScript中document.getElementById()返回值的类型为？ 1234A. ArrayB. ObjectC. StringD. Function DOM中，给父节点添加子节点的正确方法为()？ 1234A. appendChild(parentNode,newNode);B. append(parentNode,newNode);C. parentNode.append(newNode);D. parentNode.appendChild(newNode); 答案 1DDBD 其他 DOM元素的以下属性改变会导致重排(reflows)的是 1234outlinevisiblityfont-sizebackground-color 答案 1C BOM题 setInterval(updateClock,60)的含义是( )？ 1234A. 每隔60秒调用一次updateClock()B. 每隔60毫秒调用一次updateClock()C. 每隔60分钟调用一次updateClock()D. 每分钟调用60次updateClock() 使用方法( )可以获取到地理位置所在的经纬度？ 1234A. Geolocation.watchPosition()B. Geolocation.getCurrentPosition()C. Geolocation.getPosition()D. Geolocation.Position() setInterval(“alert(‘welcome’);”,1000);这段代码的意思是 1234A. 等待1000秒后，再弹出一个对话框B. 等待1秒钟后弹出一个对话框C. 每隔一秒钟弹出一个对话框D. 语句报错,语法有问题 答案 1BBC ES6题箭头函数 下列对js箭头函数描述错误的是() 1234A. 箭头函数没有原型属性B. 箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值C. 箭头函数可以作为构造函数，使用newD. 箭头函数不绑定arguments，取而代之用rest参数解决 关于箭头函数下列说法错误的一项是： 1234A. 函数体内this的指向是定义时所在的对象，而不是使用时所在的对象B. 箭头函数内不能使用arguments对象C. 箭头函数不能使用yield命令D. 可以使用new创建一个箭头函数的实例 答案 1CD promise 关于将 Promise.all 和 Promise.race 传入空数组的两段代码的输出结果说法正确的是： 1234567891011Promise.all([]).then((res) =&gt; &#123; console.log('all');&#125;);Promise.race([]).then((res) =&gt; &#123; console.log('race');&#125;); A. all 和 race 都会被输出B. all 和 race 都不会被输出C. all 会被输出，而 race 不会被输出D. all 不会被输出，race 会被输出 以下方案中，不是用于解决回调陷阱的的是： 1234A. PromiseB. GeneratorC. asyncD. Proxy 在 ECMAScript6 中，不属于promise的状态是: 1234A. PendingB. PauseC. FulfilledD. Rejected 答案 1CDB 解构赋值 关于ES6解构表达式,描述正确的是() 123456let [a,b, c,d, e] = \"hello\"; A. e = \"hello\";B. 其它都为undefinedC. 当中 a = \"h\", b = \"e\";D. 语法报错 答案 1C 多选题JS基础 下面哪些数组方法会改变原数组 1234A. push B. concat C. splice D. map 下面可以声明数字的js代码是 1234A. const a = 0xa1B. const a = 076C. const a = 0b21D. const a = 7e2 以下属于操作符 typeof 的返回值的是： 12345678910111213(1)function(2) object(3) null(4) array(5) NaN(6) bigint(7) regexp(8) undefined A. (1)、(2)、(3)、(4)、(5)、(6)、(7)、(8)B. (1)、(2)、(3)、(8)C. (1)、(2)、(8)D. (1)、(2)、(6)、(8) 以下()结果等于字符串string 12345A. typeof 'string'B. String('string').toString()C. 'string'.split('').sort().join('')D. (function(string)&#123;return string&#125;)('string')E. JSON.parse('&#123;\"string\":\"string\"&#125;').string 下面的等式成立的是? 1234A. parseInt(46.8) `==` parseFloat(46.8)B. NaN `!==` NaNC. isNaN('abc') `==` NaND. typeof NaN `===` 'number' 以下哪些选项可以将集合A转化为数组？ 1234A. Array.from(A)B. [].slice.apply(A)C. [...A]D. [].map.call(A, o =&gt; o) 下列结果返回 true 的是 123456A. null == undefinedB. null === undefinedC. null === nullD. NaN == nullE. NaN === NaNF. Infinity + 1 !== Infinity 答案 1AC ABD D ABDE BD ABCD AC JS深入 关于以下代码，说法正确的有哪些？ function Person() { } var person = new Person(); 1234A. 每一个原型都有一个constructor属性指向关联的构造函数。B. 每一个对象都有一个prototype属性。C. Object.getPrototypeOf(person) === Person.prototypeD. person.constructor === Person 下列在 JS 时间循环机制中属于微任务(microTask)的是？ 1234A. process.nextTickB. promiseC. setTimeoutD. setInterval 答案 1ACD AB ES6 以下关于let和const的说法中正确的是: 1234A. let声明的变量值和类型都可以改变B. const声明的常量不可以改变C. 两者都不存在变量提升，同时存在暂时性死区，只能在声明的位置后面使用D. const可以先声明再初始化，可以后赋值 下面关于Promise说法正确的是(注意“返回结果”的意思包含成功或者失败) 1234A. Promise.all在所有给定的promise都fulfilled后才返回结果B. Promise.race在给定的promise中，某个fulfilled后才返回结果C. promise.then的回调函数中，可以返回一个新的promiseD. 对于一个向后台获取数据已经产生结果的promise:p1，再次调用p1.then，不会去重新发起请求获取数据 答案 1ABC CD DOM 下列关于使用 JS 修改元素样式的代码，正确的有哪些？ 1234document.body.style.['background-color'] = '#fff'document.body.style.setProperty('background-color', '#fff')document.body.style = 'background-color: #fff'document.body.style.fontSize = '14px' 下列方法可用于阻止事件冒泡的有 1234A. event.cancelBubble = true;B. event.stopPropagation();C. event.preventDefault();D. return false; 答案 1BCD ABD 填空题类型检测 在JavaScript中，有var arr = []; typeof arr的结果为 以下使用 typeof 操作符的代码的输出结果为 123var x = typeof xvar res = typeof typeof x;console.log(x, res) [typeof null, null instanceof Object]的结果是什么 typeof typeof 0 JavaScript的typeof运算符的可能结果为array？解释为什么 下面代码的输出结果是多少？ 12var arr = [];console.log(typeof arr, Object.prototype.toString.call(arr)); console.log(Object.prototype.toString.call(undefined)) 类型转换 表达式 “2”+3+4 的值为 console.log(‘5’ + 3, 5 + ‘3’) var a=parseInt(“111办公室”);alert(a); [“0x1”, “0x2”, “0x3”].map(parseInt) 的结果 在js中执行 1+’1’的结果是？ 在js中执行 parseInt(‘77’,40)的结果是? 逻辑判断 请给出 [5&lt;6&lt;3,3&lt;2&lt;4] 代码的运行结果 (2&lt;3)||(3&lt;2) 表达式将返回值为 console.log(true||false&amp;&amp;false, true&amp;&amp;false||true)的输出结果是？ 其他 1 + - + + + - + 1 的结果是 [ ‘a’, ,’b’, ,].length 的结果是 程序题JS基础 下面两个程序的输出结果分别是？ 1234567891011121314151617181920212223242526272829303132333435// case 1function showCase(value) &#123; switch(value) &#123; case 'A': console.log('Case A'); break; case 'B': console.log('Case B'); break; case undefined: console.log('Case undefined'); break; default: console.log('Case default'); &#125;&#125;showCase(new String('A')); // case 2function showCase(value) &#123; switch(value) &#123; case 'A': console.log('Case A'); break; case 'B': console.log('Case B'); break; case undefined: console.log('Case undefined'); break; default: console.log('Case default'); &#125;&#125;showCase(String('A')); p标签的的内容会显示什么？ 12345678910&lt;html&gt; &lt;body&gt; &lt;p id=\"demo\"&gt;&lt;/p&gt; &lt;script type=\"text/javascript\"&gt; var x = 10; var y = \"10\"; document.getElementById(\"demo\").innerHTML = Boolean(x == y); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; document.write的结果会是什么？ 1234567891011function funcA(x)&#123; var temp = 4; function funcB(y)&#123; document.write( ++x + y + (temp--)); &#125; funcB(5);&#125;funcA(6) alert的结果会是多少 123456var varArr = function(i,j,str) &#123; return j == 0 ? str : varArr(i,--j,(str+= \" \" + i[j]));&#125;var arr = new Array('apple','orange','peach','lime');var str = varArr(arr,arr.length,\"\");alert(str); 下面程序的输出结果是多少？ 1234567891011function greetingMaker(greeting) &#123; function addName(name) &#123; greeting = greeting.split(' ').reverse().join(\"-\"); return greeting + \" \" + name; &#125; return addName;&#125;var daytimeGreeting = greetingMaker(\"Good Day to you\");alert(daytimeGreeting(name)); 下面程序的输出结果是多少？ 12345678String.prototype.GetNum = function() &#123; var regEx = /[^\\d]/g; return this.replace(regEx, ''); &#125;;var str = \"a1b2c3\";str = str.GetNum();alert(str); 下面程序的输出结果是多少？ 1234function sum(a, b) &#123; return a + b;&#125;sum(1, \"2\"); 下面程序的输出结果是多少？ 123var str = \"我非常喜欢编程\";str.length = 3;console.log(str); 下面程序的输出结果是多少？ 1234let number = 0;console.log(number++);console.log(++number);console.log(number); 下面程序的输出结果是多少？ 123456789function nums(a, b) &#123; if (a &gt; b) console.log('a is bigger') else console.log('b is bigger') return a + b&#125;console.log(nums(4, 2))console.log(nums(1, 2)) 下面程序输出结果是多少？ 123456789101112131415function side(arr) &#123; arr[0] = arr[2];&#125;function func1(a, b, c = 3) &#123; c = 10; side(arguments); console.log(a + b + c);&#125;function func2(a, b, c) &#123; c = 10; side(arguments); console.log(a + b + c);&#125;func1(1, 1, 1);func2(1, 1, 1); 下面代码的输出结果是什么？ 1234567var a = 3;var b = new Number(3);var c = 3;console.log(a == b);console.log(a === b);console.log(b === c); 执行下列语句后，a.length的值为？ 12345var a = [];a.push(1, 2);a.shift(3, 4);a.concat([5, 6]);a.splice(0, 1, 2); 下面这几段代码分别输出结果是多少？为什么？ 1234567891011121314var a = &#123;&#125;, b = '123', c = 123;a[b] = 'b';a[c] = 'c';console.log(a[b]);// example 2var a = &#123;&#125;, b = Symbol('123'), c = Symbol('123');a[b] = 'b';a[c] = 'c';console.log(a[b]);// example 3var a = &#123;&#125;, b = &#123;key:'123'&#125;, c = &#123;key:'456'&#125;;a[b] = 'b';a[c] = 'c';console.log(a[b]); 下面每项的返回值是什么？为什么？ 12345678910null == undefined0.1 + 0.2 == 0.3typeof NaNtypeof Functiontypeof Objecttypeof &#123;&#125;'a' + 1'a' - 1Function instanceof ObjectObject instanceof Function 下面程序的输出结果是多少？ 123456var array = []for(var i = 0; i &lt; 3; i++) &#123; array.push(() =&gt; i)&#125;var newArray = array.map(el =&gt; el())console.log(newArray) 下面程序的输出结果是多少？ 123456789 function a(m, n) &#123; var b = function (l) &#123; return l &lt;= m ? l * b(l + 1) : 1; &#125; return b(m - n + 1); &#125;console.log(a(4, 2)); 下面程序的输出结果是多少？ 12console.log(typeof undefined == typeof NULL);console.log(typeof function () &#123;&#125; == typeof class &#123;&#125;); 执行后a和b.age的值分别为 123456789var a = 10var b = &#123; age: 11&#125;function fn(x,y) &#123; --y.age; return --x;&#125;fn(a,b) 下面程序的执行结果是： 12345var number = 4;var numberFactorial = (function (number)&#123; return (number === 0)? 1: number* factorial(number-1)&#125;)(number)console.log(numberFactorial) 下面程序的输出结果是： 123456var array = []for(var i = 0; i &lt; 3; i++) &#123; array.push(() =&gt; i)&#125;var newArray = array.map(el =&gt; el())console.log(newArray) 下面程序的输出结果是： 12345function addToList(item, list) &#123; return list.push(item)&#125;const result = addToList(\"nowcoder\", [\"hello\"])console.log(result) 下面程序的输出结果是： 1234const first = () =&gt; &#123; console.log('first'); return false; &#125;const second = () =&gt; &#123; console.log('second'); return true; &#125;console.log( first() &amp;&amp; second() );console.log( second() || first() ); 下面代码的输出结果是： 12var s='12ab3cd', arr=s.split(/\\d/);console.log(arr[3],arr[4]) 下面程序的输出结果是： 12345function getAge(...args) &#123; console.log(typeof args);&#125;getAge(21); 下面程序的输出结果是: 123var arr=[1,2,3];arr.push(arr.shift())console.log(arr[1],arr[2]) JS深入this指向题目解析：this指向题目解析及扩展 下列程序的输出结果是多少？为什么？ 123456789101112var x = 1;var obj = &#123; x: 3, fun:function () &#123; var x = 5; return this.x; &#125;&#125;;var fun = obj.fun;console.log( obj.fun(), fun() ); 下列程序的输出结果是多少？你能理清楚test函数的this指向吗？ 123456789var a = 5; function test() &#123; a = 0; alert(a); alert(this.a); var a; alert(a); &#125;new test(); 下列程序的输出结果是多少？为什么？ 12345678910111213function fun () &#123; return () =&gt; &#123; return () =&gt; &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125; &#125;&#125;var f = fun.call(&#123;name: 'foo'&#125;)var t1 = f.call(&#123;name: 'bar'&#125;)()()var t2 = f().call(&#123;name: 'baz'&#125;)()var t3 = f()().call(&#123;name: 'qux'&#125;) 执行以下代码，输出结果分别是多少？ 1234567891011let obj1 = &#123; a: 1, foo: () =&gt; &#123; console.log(this.a) &#125;&#125;// log1obj1.foo()const obj2 = obj1.foo// log2obj2() 下面程序的输出结果是什么？为什么？ 1234567const Person = (name=\"wang\",age=10) =&gt; &#123;this.name = name;this.age = age;return this.name +' is '+ this.age + 'years old'&#125;let result = new Person('zhang',11)console.log(result) 请表述以下代码的执行结果和原因 12345678var person = &#123; age: 18, getAge: function() &#123; return this.age; &#125;&#125;;var getAge = person.getAgegetAge() 请按顺序写出打印结果，并说明原因。 12345678910111213141516var name = 'global';var obj = &#123; name: 'local', foo: function()&#123; this.name = 'foo'; &#125;.bind(window)&#125;;var bar = new obj.foo();setTimeout(function() &#123; console.log(window.name);&#125;, 0);console.log(bar.name); var bar3 = bar2 = bar;bar2.name = 'foo2';console.log(bar3.name); 下面程序的执行结果是： 12345678910111213var obj = &#123; name:\"zhangsan\", sayName:function()&#123; console.info(this.name); &#125;&#125;var wfunc = obj.sayName;obj.sayName();wfunc();var name = \"lisi\";obj.sayName();wfunc(); 下面程序的输出结果是： 123456789var name='test' var a = &#123; name: 'ass', getName: function() &#123; return this.name; &#125; &#125; var b = a.getName; b(); 事件循环 下列程序的输出结果分别是多少？为什么？ 12345678910111213const promiseA = Promise.resolve('a')promiseA. then((res) =&gt; &#123; console.log(res)&#125;).then((res) =&gt; &#123; console.log(res)&#125;)const promiseB = Promise.resolve('b')promiseB. then((res) =&gt; &#123; console.log(res)&#125;)promiseB. then((res) =&gt; &#123; console.log(res)&#125;) 下面程序的输出结果依次是多少？ 12345678910111213141516setTimeout(() =&gt; &#123; console.log(1)&#125;, 0)const P = new Promise((resolve, reject) =&gt; &#123; console.log(2) setTimeout(() =&gt; &#123; resolve() console.log(3) &#125;, 0)&#125;)P.then(() =&gt; &#123; console.log(4)&#125;)console.log(5) 下面程序的输出结果是 1234567891011setTimeout(function()&#123; console.log(1);&#125;, 0)new Promise(function(resolve)&#123; console.log(2); resolve(); console.log(3);&#125;).then(function()&#123; console.log(4);&#125;)console.log(5); 下面程序的输出结果是？ 123456789101112(async () =&gt; &#123; console.log(1); setTimeout(() =&gt; &#123; console.log(2);&#125;, 0);await new Promise((resolve, reject) =&gt; &#123; console.log(3);&#125;).then(() =&gt; &#123; console.log(4);&#125;); console.log(5);&#125;)(); 下面程序的输出结果是: 1234567891011new Promise((resolve) =&gt; &#123; console.log('1') resolve() console.log('2')&#125;).then(() =&gt; &#123; console.log('3')&#125;)setTimeout(() =&gt; &#123; console.log('4')&#125;)console.log('5') 下面程序的输出结果是: 123456789101112var p1 = new Promise(function(resolve, reject)&#123; resolve(\"2\")&#125;)setTimeout(function()&#123; console.log(\"1\")&#125;,10)p1.then(function(value)&#123; console.log(value)&#125;)setTimeout(function()&#123; console.log(\"3\")&#125;,0) 下面程序的输出结果是： 12345678setTimeout(function() &#123; console.log('setTimeout');&#125;, 0);Promise.resolve().then(function() &#123; console.log('promise1');&#125;).then(function() &#123; console.log('promise2');&#125;); 请表述以下代码的执行结果和原因 12345678910111213setTimeout(function() &#123; console.log(1)&#125;,0)new Promise(function executor(resolve)&#123; console.log(2) for (var i = 0; i&lt;10000; i++) &#123; i - 9999 &amp;&amp; resolve() &#125; console.log(3)&#125;).then(function() &#123; console.log(4)&#125;)console.log(5) 在网页中有两个div块，html代码如下 123&lt;div class=\"outer\"&gt; &lt;div class=\"inner\"&gt;&lt;/div&gt;&lt;/div&gt; 对应的js代码如下： 12345678910111213141516171819var outer = document.querySelector('.outer');var inner = document.querySelector('.inner');function onClick() &#123; console.log('click'); setTimeout(function() &#123; console.log('timeout'); &#125;, 0); Promise.resolve().then(function() &#123; console.log('promise'); &#125;); outer.setAttribute('data-random', Math.random());&#125;inner.addEventListener('click', onClick);outer.addEventListener('click', onClick); 当点击class为inner的div块时，控制台依次输出结果是什么？ 10. 下面程序的输出结果是？ 123456789101112(async () =&gt; &#123; console.log(1); setTimeout(() =&gt; &#123; console.log(2);&#125;, 0);await new Promise((resolve, reject) =&gt; &#123; console.log(3);&#125;).then(() =&gt; &#123; console.log(4);&#125;); console.log(5);&#125;)(); 下面程序的输出结果是： 123456789101112setTimeout(() =&gt; console.log('a'));Promise.resolve().then( () =&gt; console.log('b’); ).then( () =&gt; Promise.resolve('c').then( (data) =&gt; &#123; setTimeout(() =&gt; console.log('d')); console.log('f'); return data; &#125; ) ).then(data =&gt; console.log(data)); 下面程序的输出结果是： 12345console.log('one'); setTimeout(function() &#123; console.log('two'); &#125;, 0); Promise.resolve() .then(function() &#123; console.log('three'); &#125;) console.log('four'); 下面程序的执行结果是： 123456789101112setTimeout(function () &#123; console.log(C)&#125;,0)console.log('D')new Promise(function(resolve)&#123; console.log('E') resolve() console.log('F')&#125;).then(function() &#123; console.log('G')&#125;)console.log('H') 有一个输出函数定义如下： 12345678function log(msg, time) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(msg); resolve(); &#125;, time); &#125;);&#125; 则下面三段代码输出的结果是： 1234567891011121314151617181920// 第一段代码：(async () =&gt; &#123; for (let i = 0; i &lt; 5; i++) &#123; await log(i, 1000); &#125;&#125;)(); // 第二段代码：(async () =&gt; &#123; [ 1, 2, 3, 4 ].forEach(async (i) =&gt; &#123; await log(i, 1000); &#125;);&#125;)(); // 第三段代码：(async () =&gt; &#123; for (const i of [ 1, 2, 3, 4 ]) &#123; await log(i, 1000); &#125;&#125;)(); 原型与原型链传送门: 原型与原型链题目解析 下面程序的输出结果依次是？ 123456789101112131415function Fn1(name) &#123; if(name)&#123; this.name = name; &#125;&#125;Fn1.prototype.name=\"jack\"let a = new Fn1();console.log('a:', a.name);function Fn2(name) &#123; this.name = name;&#125;Fn2.prototype.name=\"jack\"let b = new Fn2();console.log('b:', b.name); 下面程序的输出结果是？ 123456789101112131415var Foo = (function() &#123; var x = 0; function Foo() &#123;&#125; Foo.prototype.increment = function() &#123; ++x; console.log(x); &#125;; return Foo;&#125;)(); var a = new Foo();a.increment();a.increment();var b = new Foo();a.increment(); 下面程序的输出结果是？ 12345678910var name = 'Jay'function Person(name)&#123; this.name = name; console.log(this.name)&#125;var a = Person('Tom')console.log(name)console.log(a)var b = new Person('Michael')console.log(b) 请表述以下代码的执行结果和原因 123456789class A&#123;&#125;class B extends A&#123;&#125;const a = new A()const b = new B()a.__proto__b.__proto__B. __proto__B. prototype.__proto__b.__proto__.__proto__ 请表述以下代码的执行结果和原因 12345678910111213141516171819202122232425262728293031function test() &#123; getName = function() &#123; Promise.resolve().then(() =&gt; console.log(0)); console.log(1); &#125;; return this; &#125;test.getName = function() &#123; setTimeout(() =&gt; console.log(2), 0); console.log(3); &#125;;test.prototype.getName = function() &#123; console.log(4); &#125;; var getName = function() &#123; console.log(5); &#125;;function getName() &#123; console.log(6); &#125; test.getName(); getName(); test().getName(); getName(); new test.getName();new test().getName();new new test().getName(); 请表述以下代码的执行结果和原因 123456789101112var tmp = &#123;&#125;;var A = function() &#123;&#125;;A. prototype = tmp;var a = new A();A. prototype = &#123;&#125;;var b = Object.create(tmp);b.constructor = A. constructor;console.log(a instanceof A);console.log(b instanceof A); 下面程序的执行结果是： 12345678function Foo()&#123;&#125;Foo.prototype.z = 3;var obj = new Foo();console.info(obj.z)obj.z = 10;console.info(obj.z);delete obj.z;console.info(obj.z); 下面程序的执行结果是： 123456789const Book = &#123; price: 32&#125;const book = Object.create(Book);book.type = 'Math';delete book.price;delete book.type;console.log(book.price);console.log(book.type); 作用域与预编译 下面的程序会报错吗？如果不会，输出结果分别是多少？ 1234567function sayHello() &#123; console.log(name); console.log(age); var name = \"Tom\"; let age = 18;&#125; sayHello(); 下面的程序i的打印结果分别是多少？ 1234567891011for (var i = 0; i &lt; 3; i++) &#123; setTimeout(_ =&gt; &#123; console.log(i) &#125;)&#125;for (let i = 0; i &lt; 3; i++) &#123; setTimeout(_ =&gt; &#123; console.log(i) &#125;)&#125; 下面程序的输出结果是： 1234console.log(a);var a = 'a';console.log(b);let b = 'b'; 下面程序的输出结果是： 123456var foo = \"Hello\";(function()&#123; var bar = \" World\"; alert(foo + bar);&#125;)();alert(foo + bar); 下面程序的输出结果是： 12345678var a = 10;(function () &#123; console.log(a) a = 5 console.log(window.a) var a = 20; console.log(a)&#125;)() 下面代码的输出结果是: 1234567const a = 10function runFunction() &#123; const a = 20 console.log('inside', a)&#125;runFunction()console.log('outside', a) 请描述打印结果并说明原因 1234567891011121314\"use strict\"var name = 'Jay'var person = &#123; name: 'Wang', pro: &#123; name: 'Michael', getName: function () &#123; return this.name &#125; &#125;&#125;console.log(person.pro.getName)var people = person.pro.getNameconsole.log(people()) 下面程序的结果是： 12345678910111213&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var elements = document.getElementsByTagName(\"li\");for (var i=0;i&lt;elements.length;i++)&#123; elements[i].onclick =function( )&#123; alert(i); &#125;;&#125; 下面程序的输出结果是 1234567891011compute(10,100);var compute = function(A,B) &#123; console.info(A * B) ;&#125;;function compute(A,B)&#123; console.info(A + B);&#125;function compute(A,B)&#123; console.info((A + B)*2);&#125;compute(2,10); 下面程序的执行结果是： 12345678meili()function meili() &#123; console.log(\"meili\")&#125;mogu()var mogu = function() &#123; console.log(\"mogu\")&#125; 下面两个代码片段输出结果有什么区别？为什么？ 12345678910// 片段1check('first');function check(ars)&#123; console.log(ars);&#125;// 片段2check('second');var check= function(ars)&#123; console.log(ars);&#125; ES6对象 下面代码的输出结果是？ 1234const student = &#123;name: 'ZhangSan'&#125;Object.defineProperty(student, 'age', &#123;value: 22&#125;)console.log(student)console.log(Object.keys(student)) generator 下列程序的输出结果是多少？为什么？ 123456789function * cb(x, y) &#123; for(let i = Math.ceil(x); i &lt;= y; i++) &#123; yield i; &#125;&#125;var a = cb(6, 9);console.log(a.next());console.log(a.next()); 扩展运算符 下面程序的输出结果是： 1234function fn(...args) &#123; console.log(typeof args);&#125;fn(21); promise123Promise.reject(0) .catch(e =&gt; e) .catch(e =&gt; console.log(e)) class 请写出下面ES6代码编译后所生成的ES5代码 12345678910111213class Person &#123; constructor (name) &#123; this.name = name; &#125; greet () &#123; console.log(`Hi, my name is $&#123;this.name&#125;`); &#125; greetDelay (time) &#123; setTimeout(() =&gt; &#123; console.log(`Hi, my name is $&#123;this.name&#125;`); &#125;, time); &#125;&#125; 标签模板 下面程序的输出结果是多少？ 12345678function getPersonInfo (one, two, three) &#123; console.log(one) console.log(two) console.log(three)&#125;const person = 'Lydia'const age = 21getPersonInfo `$&#123;person&#125; is $&#123;age&#125; years old` module 请写出index里面的输出结果 123456// module.jsexport default () =&gt; \"Hello world\"export const name = \"nowcoder\"// index.jsimport * as data from \"./module\"console.log(data) 有a.js和b.js两个文件，请写出b文件中代码的输出 1234567891011121314151617// a.jslet a = 1let b = &#123;&#125;setTimeout(() =&gt; &#123; a = 2 b.b = 2&#125;, 100)module.exports = &#123; a, b &#125;// b.jsconst a = require('./a')console.log(a.a)console.log(a.b)setTimeout(() =&gt; &#123; console.log(a.a) console.log(a.b)&#125;, 500) 其他 输出结果是： 1234567891011121314151617181920212223242526&lt;div id=\"box1\"&gt; &lt;div id=\"box2\"&gt; content &lt;/div&gt;&lt;/div&gt;&lt;script&gt;const $ = document.querySelector.bind(document);const box1 = $('#box1');const box2 = $('#box2');box1.addEventListener('click', () =&gt;&#123; console.log('box1 true');&#125;, true);box1.addEventListener('click', () =&gt;&#123; console.log('box1 false');&#125;, false);box2.addEventListener('click', () =&gt;&#123; console.log('box2 true');&#125;, true);box2.addEventListener('click', () =&gt;&#123; console.log('box2 false');&#125;, false);&lt;/script&gt; 输出结果是： 1234567891011121314$(function () &#123; function fn1( value ) &#123; alert( value ); &#125; function fn2( value ) &#123; fn1(\"A\"); return false; &#125; var callbacks = $.Callbacks(); callbacks.add( fn1 ); callbacks.fire( \"B\" ); callbacks.add( fn2 ); callbacks.fire( \"C\" );&#125;) 实现在p元素后添加“Hello World!”，则横线处应使用的方法为( )？ 1234567891011121314151617&lt;html&gt; &lt;head&gt; &lt;script type=\"text/javascript\" src=\"/jquery/jquery.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(document).ready(function()&#123; $(\"button\").click(function()&#123; $(\"&lt;b&gt;Hello World!&lt;/b&gt;\").______(\"p\"); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;This is a paragraph.&lt;/p&gt; &lt;p&gt;This is another paragraph.&lt;/p&gt; &lt;button&gt;在每个p元素的结尾添加内容&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 输出结果是： 12345678910111213141516171819202122&lt;div id=\"box1\"&gt; &lt;div id=\"box2\"&gt; content &lt;/div&gt;&lt;/div&gt;&lt;script&gt;const $ = document.querySelector.bind(document);const box1 = $('#box1');const box2 = $('#box2');box1.addEventListener('click', () =&gt; &#123; console.log('box1 true');&#125;, true);box1.addEventListener('click', () =&gt; &#123; console.log('box1 false');&#125;, false);box2.addEventListener('click', () =&gt; &#123; console.log('box2 true');&#125;, true);box2.addEventListener('click', () =&gt; &#123; console.log('box2 false');&#125;, false);&lt;/script&gt; 请选择下面代码输出1的次数 123456789101112131415161718var vm = new Vue(&#123; el: '#example', data: &#123; message: 'Hello' &#125;, computed: &#123; test: function () &#123; console.log(1) return this.message &#125; &#125;, created: function ()&#123; this.message = 'World' for (var i = 0; i &lt; 5; i++) &#123; console.log(this.test) &#125; &#125;&#125;)","categories":[{"name":"前端面试题","slug":"前端面试题","permalink":"https://qw8.github.io/categories/前端面试题/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qw8.github.io/tags/JavaScript/"},{"name":"BOM","slug":"BOM","permalink":"https://qw8.github.io/tags/BOM/"},{"name":"DOM","slug":"DOM","permalink":"https://qw8.github.io/tags/DOM/"}]},{"title":"JavaScript面试题","slug":"interview/JavaScript面试题","date":"2020-06-15T02:24:57.000Z","updated":"2024-02-18T06:46:10.000Z","comments":true,"path":"/interview/javascript-mian-shi-ti.html","link":"","permalink":"https://qw8.github.io/interview/javascript-mian-shi-ti.html","excerpt":"","text":"1.undefined 和 null 有什么区别？在理解undefined和null之间的差异之前，我们先来看看它们的相似类。 它们属于 JavaScript 的 7 种基本类型。 1let primitiveTypes = [&apos;string&apos;,&apos;number&apos;,&apos;null&apos;,&apos;undefined&apos;,&apos;boolean&apos;,&apos;symbol&apos;, &apos;bigint&apos;]; 它们是属于虚值，可以使用Boolean(value)或!!value将其转换为布尔值时，值为false。 12345console.log(!!null); // falseconsole.log(!!undefined); // falseconsole.log(Boolean(null)); // falseconsole.log(Boolean(undefined)); // false 接着来看看它们的区别。 undefined是未指定特定值的变量的默认值，或者没有显式返回值的函数，如：console.log(1)，还包括对象中不存在的属性，这些 JS 引擎都会为其分配 undefined 值。 1234567891011let _thisIsUndefined;const doNothing = () =&gt; &#123;&#125;;const someObj = &#123; a : &quot;ay&quot;, b : &quot;bee&quot;, c : &quot;si&quot;&#125;;console.log(_thisIsUndefined); // undefinedconsole.log(doNothing()); // undefinedconsole.log(someObj[&quot;d&quot;]); // undefined null是“不代表任何值的值”。null是已明确定义给变量的值。在此示例中，当fs.readFile方法未引发错误时，我们将获得null值。 1234567fs.readFile(&apos;path/to/file&apos;, (e,data) =&gt; &#123; console.log(e); // 当没有错误发生时，打印 null if(e)&#123; console.log(e); &#125; console.log(data); &#125;); 在比较null和undefined时，我们使用==时得到true，使用===时得到false: 12console.log(null == undefined); // trueconsole.log(null === undefined); // false 2. &amp;&amp; 运算符能做什么&amp;&amp; 也可以叫逻辑与，在其操作数中找到第一个虚值表达式并返回它，如果没有找到任何虚值表达式，则返回最后一个真值表达式。它采用短路来防止不必要的工作。 12console.log(false &amp;&amp; 1 &amp;&amp; []); // falseconsole.log(&quot; &quot; &amp;&amp; true &amp;&amp; 5); // 5 使用if语句 123456789101112const router: Router = Router();router.get(&apos;/endpoint&apos;, (req: Request, res: Response) =&gt; &#123; let conMobile: PoolConnection; try &#123; //do some db operations &#125; catch (e) &#123; if (conMobile) &#123; conMobile.release(); &#125; &#125;&#125;); 使用&amp;&amp;操作符 12345678910const router: Router = Router();router.get(&apos;/endpoint&apos;, (req: Request, res: Response) =&gt; &#123; let conMobile: PoolConnection; try &#123; //do some db operations &#125; catch (e) &#123; conMobile &amp;&amp; conMobile.release() &#125;&#125;); 3. || 运算符能做什么||也叫或逻辑或，在其操作数中找到第一个真值表达式并返回它。这也使用了短路来防止不必要的工作。在支持 ES6 默认函数参数之前，它用于初始化函数中的默认参数值。 12345678console.log(null || 1 || undefined); // 1function logName(name) &#123; var n = name || &quot;Mark&quot;; console.log(n);&#125;logName(); // &quot;Mark&quot; 4. 使用 + 或一元加运算符是将字符串转换为数字的最快方法吗？根据MDN文档，+是将字符串转换为数字的最快方法，因为如果值已经是数字，它不会执行任何操作。 5. DOM 是什么？DOM 代表文档对象模型，是 HTML 和 XML 文档的接口(API)。当浏览器第一次读取(解析)HTML文档时，它会创建一个大对象，一个基于 HTM L文档的非常大的对象，这就是DOM。它是一个从 HTML 文档中建模的树状结构。DOM 用于交互和修改DOM结构或特定元素或节点。 假设我们有这样的 HTML 结构： 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document Object Model&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt; &lt;span&gt;&lt;/span&gt; &lt;/p&gt; &lt;label&gt;&lt;/label&gt; &lt;input&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 等价的DOM是这样的： 图片](https://mmbiz.qpic.cn/mmbiz_png/LDPLltmNy57ianicNyt0G9GEGibARafiazZKV0Y332hOUmFjQYBIYcXTm37FgzYBmsCFpKKjqnY9fm9r6NMvQSib0rw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)![图片 JS 中的document对象表示DOM。它为我们提供了许多方法，我们可以使用这些方法来选择元素来更新元素内容，等等。 6. 什么是事件传播?当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。在“冒泡阶段”中，事件冒泡或向上传播至父级，祖父母，祖父母或父级，直到到达window为止；而在“捕获阶段”中，事件从window开始向下触发元素 事件或event.target。 事件传播有三个阶段： 捕获阶段–事件从 window 开始，然后向下到每个元素，直到到达目标元素。 目标阶段–事件已达到目标元素。 冒泡阶段–事件从目标元素冒泡，然后上升到每个元素，直到到达 window。 图片 7. 什么是事件冒泡？当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。在冒泡阶段，事件冒泡，或者事件发生在它的父代，祖父母，祖父母的父代，直到到达window为止。 假设有如下的 HTML 结构： 12345&lt;div class=&quot;grandparent&quot;&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;1&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 对应的 JS 代码: 1234567891011121314151617181920212223242526272829303132333435363738function addEvent(el, event, callback, isCapture = false) &#123; if (!el || !event || !callback || typeof callback !== &apos;function&apos;) return; if (typeof el === &apos;string&apos;) &#123; el = document.querySelector(el); &#125;; el.addEventListener(event, callback, isCapture);&#125;addEvent(document, &apos;DOMContentLoaded&apos;, () =&gt; &#123; const child = document.querySelector(&apos;.child&apos;); const parent = document.querySelector(&apos;.parent&apos;); const grandparent = document.querySelector(&apos;.grandparent&apos;); addEvent(child, &apos;click&apos;, function (e) &#123; console.log(&apos;child&apos;); &#125;); addEvent(parent, &apos;click&apos;, function (e) &#123; console.log(&apos;parent&apos;); &#125;); addEvent(grandparent, &apos;click&apos;, function (e) &#123; console.log(&apos;grandparent&apos;); &#125;); addEvent(document, &apos;click&apos;, function (e) &#123; console.log(&apos;document&apos;); &#125;); addEvent(&apos;html&apos;, &apos;click&apos;, function (e) &#123; console.log(&apos;html&apos;); &#125;) addEvent(window, &apos;click&apos;, function (e) &#123; console.log(&apos;window&apos;); &#125;)&#125;); addEventListener方法具有第三个可选参数useCapture，其默认值为false，事件将在冒泡阶段中发生，如果为true，则事件将在捕获阶段中发生。如果单击child元素，它将分别在控制台上记录child，parent，grandparent，html，document和window，这就是事件冒泡。 8. 什么是事件捕获？当事件发生在 DOM 元素上时，该事件并不完全发生在那个元素上。在捕获阶段，事件从window开始，一直到触发事件的元素。 假设有如下的 HTML 结构： 12345&lt;div class=&quot;grandparent&quot;&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;1&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 对应的 JS 代码: 1234567891011121314151617181920212223242526272829303132333435363738function addEvent(el, event, callback, isCapture = false) &#123; if (!el || !event || !callback || typeof callback !== &apos;function&apos;) return; if (typeof el === &apos;string&apos;) &#123; el = document.querySelector(el); &#125;; el.addEventListener(event, callback, isCapture);&#125;addEvent(document, &apos;DOMContentLoaded&apos;, () =&gt; &#123; const child = document.querySelector(&apos;.child&apos;); const parent = document.querySelector(&apos;.parent&apos;); const grandparent = document.querySelector(&apos;.grandparent&apos;); addEvent(child, &apos;click&apos;, function (e) &#123; console.log(&apos;child&apos;); &#125;); addEvent(parent, &apos;click&apos;, function (e) &#123; console.log(&apos;parent&apos;); &#125;); addEvent(grandparent, &apos;click&apos;, function (e) &#123; console.log(&apos;grandparent&apos;); &#125;); addEvent(document, &apos;click&apos;, function (e) &#123; console.log(&apos;document&apos;); &#125;); addEvent(&apos;html&apos;, &apos;click&apos;, function (e) &#123; console.log(&apos;html&apos;); &#125;) addEvent(window, &apos;click&apos;, function (e) &#123; console.log(&apos;window&apos;); &#125;)&#125;); addEventListener方法具有第三个可选参数useCapture，其默认值为false，事件将在冒泡阶段中发生，如果为true，则事件将在捕获阶段中发生。如果单击child元素，它将分别在控制台上打印window，document，html，grandparent和parent，这就是事件捕获。 9. event.preventDefault() 和 event.stopPropagation()方法之间有什么区别？event.preventDefault() 方法可防止元素的默认行为。如果在表单元素中使用，它将阻止其提交。如果在锚元素中使用，它将阻止其导航。如果在上下文菜单中使用，它将阻止其显示或显示。event.stopPropagation()方法用于阻止捕获和冒泡阶段中当前事件的进一步传播。 10. 如何知道是否在元素中使用了event.preventDefault()方法？我们可以在事件对象中使用event.defaultPrevented属性。它返回一个布尔值用来表明是否在特定元素中调用了event.preventDefault()。 11. 为什么此代码 obj.someprop.x 会引发错误?12const obj = &#123;&#125;;console.log(obj.someprop.x); 显然，由于我们尝试访问someprop属性中的x属性，而 someprop 并没有在对象中，所以值为 undefined。记住对象本身不存在的属性，并且其原型的默认值为undefined。因为undefined没有属性x，所以试图访问将会报错。 12. 什么是 event.target ？简单来说，event.target是发生事件的元素或触发事件的元素。 假设有如下的 HTML 结构： 12345678910&lt;div onclick=&quot;clickFunc(event)&quot; style=&quot;text-align: center;margin:15px;border:1px solid red;border-radius:3px;&quot;&gt; &lt;div style=&quot;margin: 25px; border:1px solid royalblue;border-radius:3px;&quot;&gt; &lt;div style=&quot;margin:25px;border:1px solid skyblue;border-radius:3px;&quot;&gt; &lt;button style=&quot;margin:10px&quot;&gt; Button &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; JS 代码如下： 123function clickFunc(event) &#123; console.log(event.target);&#125; 如果单击 button，即使我们将事件附加在最外面的div上，它也将打印 button 标签，因此我们可以得出结论event.target是触发事件的元素。 13. 什么是 event.currentTarget？？event.currentTarget是我们在其上显式附加事件处理程序的元素。 假设有如下的 HTML 结构： 12345678910&lt;div onclick=&quot;clickFunc(event)&quot; style=&quot;text-align: center;margin:15px;border:1px solid red;border-radius:3px;&quot;&gt; &lt;div style=&quot;margin: 25px; border:1px solid royalblue;border-radius:3px;&quot;&gt; &lt;div style=&quot;margin:25px;border:1px solid skyblue;border-radius:3px;&quot;&gt; &lt;button style=&quot;margin:10px&quot;&gt; Button &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; JS 代码如下： 123function clickFunc(event) &#123; console.log(event.currentTarget);&#125; 如果单击 button，即使我们单击该 button，它也会打印最外面的div标签。在此示例中，我们可以得出结论，event.currentTarget是附加事件处理程序的元素。 14. == 和 === 有什么区别？==用于一般比较，===用于严格比较，==在比较的时候可以转换数据类型，===严格比较，只要类型不匹配就返回flase。 先来看看 == 这兄弟： 强制是将值转换为另一种类型的过程。在这种情况下，==会执行隐式强制。在比较两个值之前，==需要执行一些规则。 假设我们要比较x == y的值。 如果x和y的类型相同，则 JS 会换成===操作符进行比较。 如果x为null, y为undefined，则返回true。 如果x为undefined且y为null，则返回true。 如果x的类型是number, y的类型是string，那么返回x == toNumber(y)。 如果x的类型是string, y的类型是number，那么返回toNumber(x) == y。 如果x为类型是boolean，则返回toNumber(x)== y。 如果y为类型是boolean，则返回x == toNumber(y)。 如果x是string、symbol或number，而y是object类型，则返回x == toPrimitive(y)。 如果x是object，y是string，symbol则返回toPrimitive(x) == y。 剩下的 返回 false 注意：toPrimitive首先在对象中使用valueOf方法，然后使用toString方法来获取该对象的原始值。 举个例子。 x y x == y 5 5 true 1 ‘1’ true null undefined true 0 false true ‘1,2’ [1,2] true ‘[object Object]’ {} true 这些例子都返回true。 第一个示例符合条件1，因为x和y具有相同的类型和值。 第二个示例符合条件4，在比较之前将y转换为数字。 第三个例子符合条件2。 第四个例子符合条件7，因为y是boolean类型。 第五个示例符合条件8。使用toString()方法将数组转换为字符串，该方法返回1,2。 最后一个示例符合条件8。使用toString()方法将对象转换为字符串，该方法返回[object Object]。 x y x === y 5 5 true 1 ‘1’ false null undefined false 0 false false ‘1,2’ [1,2] false ‘[object Object]’ {} false 如果使用===运算符，则第一个示例以外的所有比较将返回false，因为它们的类型不同，而第一个示例将返回true，因为两者的类型和值相同。 具体更多规则可以对参考我之前的文章： 我对 JS 中相等和全等操作符转化过程一直很迷惑，直到有了这份算法 15. 为什么在 JS 中比较两个相似的对象时返回 false？先看下面的例子： 123456let a = &#123; a: 1 &#125;;let b = &#123; a: 1 &#125;;let c = a;console.log(a === b); // 打印 false，即使它们有相同的属性console.log(a === c); // true JS 以不同的方式比较对象和基本类型。在基本类型中，JS 通过值对它们进行比较，而在对象中，JS 通过引用或存储变量的内存中的地址对它们进行比较。这就是为什么第一个console.log语句返回false，而第二个console.log语句返回true。a和c有相同的引用地址，而a和b没有。 16. !! 运算符能做什么？!!运算符可以将右侧的值强制转换为布尔值，这也是将值转换为布尔值的一种简单方法。 12345678910console.log(!!null); // falseconsole.log(!!undefined); // falseconsole.log(!!&apos;&apos;); // falseconsole.log(!!0); // falseconsole.log(!!NaN); // falseconsole.log(!!&apos; &apos;); // trueconsole.log(!!&#123;&#125;); // trueconsole.log(!![]); // trueconsole.log(!!1); // trueconsole.log(!![].length); // false 17. 如何在一行中计算多个表达式的值？可以使用逗号运算符在一行中计算多个表达式。它从左到右求值，并返回右边最后一个项目或最后一个操作数的值。 1234567let x = 5;x = (x++ , x = addFive(x), x *= 2, x -= 5, x += 10);function addFive(num) &#123; return num + 5;&#125; 上面的结果最后得到x的值为27。首先，我们将x的值增加到6，然后调用函数addFive(6)并将6作为参数传递并将结果重新分配给x，此时x的值为11。之后，将x的当前值乘以2并将其分配给x，x的更新值为22。然后，将x的当前值减去5并将结果分配给x x更新后的值为17。最后，我们将x的值增加10，然后将更新的值分配给x，最终x的值为27。 18. 什么是提升？提升是用来描述变量和函数移动到其(全局或函数)作用域顶部的术语。 为了理解提升，需要来了解一下执行上下文。执行上下文是当前正在执行的“代码环境”。执行上下文有两个阶段:编译和执行。 编译-在此阶段，JS 引荐获取所有函数声明并将其提升到其作用域的顶部，以便我们稍后可以引用它们并获取所有变量声明（使用var关键字进行声明），还会为它们提供默认值：undefined。 执行——在这个阶段中，它将值赋给之前提升的变量，并执行或调用函数(对象中的方法)。 注意:只有使用var声明的变量，或者函数声明才会被提升，相反，函数表达式或箭头函数，let和const声明的变量，这些都不会被提升。 假设在全局使用域，有如下的代码： 12345678910console.log(y);y = 1;console.log(y);console.log(greet(&quot;Mark&quot;));function greet(name)&#123; return &apos;Hello &apos; + name + &apos;!&apos;;&#125;var y; 上面分别打印：undefined,1, Hello Mark!。 上面代码在编译阶段其实是这样的： 1234567891011121314function greet(name) &#123; return &apos;Hello &apos; + name + &apos;!&apos;;&#125;var y; // 默认值 undefined// 等待“编译”阶段完成，然后开始“执行”阶段/*console.log(y);y = 1;console.log(y);console.log(greet(&quot;Mark&quot;));*/ 编译阶段完成后，它将启动执行阶段调用方法，并将值分配给变量。 123456789101112function greet(name) &#123; return &apos;Hello &apos; + name + &apos;!&apos;;&#125;var y;//start &quot;execution&quot; phaseconsole.log(y);y = 1;console.log(y);console.log(greet(&quot;Mark&quot;)); 19. 什么是作用域？JavaScript 中的作用域是我们可以有效访问变量或函数的区域。JS 有三种类型的作用域：全局作用域、函数作用域和块作用域(ES6)。 全局作用域——在全局命名空间中声明的变量或函数位于全局作用域中，因此在代码中的任何地方都可以访问它们。 123456789//global namespacevar g = &quot;global&quot;;function globalFunc()&#123; function innerFunc()&#123; console.log(g); // can access &quot;g&quot; because &quot;g&quot; is a global variable &#125; innerFunc();&#125; 函数作用域——在函数中声明的变量、函数和参数可以在函数内部访问，但不能在函数外部访问。 1234567891011function myFavoriteFunc(a) &#123; if (true) &#123; var b = &quot;Hello &quot; + a; &#125; return b;&#125;myFavoriteFunc(&quot;World&quot;);console.log(a); // Throws a ReferenceError &quot;a&quot; is not definedconsole.log(b); // does not continue here 块作用域-在块{}中声明的变量（let，const）只能在其中访问。 12345678function testBlock()&#123; if(true)&#123; let z = 5; &#125; return z; &#125;testBlock(); // Throws a ReferenceError &quot;z&quot; is not defined 作用域也是一组用于查找变量的规则。如果变量在当前作用域中不存在，它将向外部作用域中查找并搜索，如果该变量不存在，它将再次查找直到到达全局作用域，如果找到，则可以使用它，否则引发错误，这种查找过程也称为作用域链。 1234567891011121314151617181920 /* 作用域链 内部作用域-&gt;外部作用域-&gt; 全局作用域*/// 全局作用域var variable1 = &quot;Comrades&quot;; var variable2 = &quot;Sayonara&quot;;function outer()&#123;// 外部作用域 var variable1 = &quot;World&quot;; function inner()&#123; // 内部作用域 var variable2 = &quot;Hello&quot;; console.log(variable2 + &quot; &quot; + variable1); &#125; inner();&#125; outer(); // Hello World 图片 20. 什么是闭包？这可能是所有问题中最难的一个问题，因为闭包是一个有争议的话题，这里从个人角度来谈谈，如果不妥，多多海涵。 闭包就是一个函数在声明时能够记住当前作用域、父函数作用域、及父函数作用域上的变量和参数的引用，直至通过作用域链上全局作用域，基本上闭包是在声明函数时创建的作用域。 看看小例子： 12345678// 全局作用域var globalVar = &quot;abc&quot;;function a()&#123; console.log(globalVar);&#125;a(); // &quot;abc&quot; 在此示例中，当我们声明a函数时，全局作用域是a闭包的一部分。 图片 变量globalVar在图中没有值的原因是该变量的值可以根据调用函数a的位置和时间而改变。但是在上面的示例中，globalVar变量的值为abc。 来看一个更复杂的例子： 1234567891011121314var globalVar = &quot;global&quot;;var outerVar = &quot;outer&quot;function outerFunc(outerParam) &#123; function innerFunc(innerParam) &#123; console.log(globalVar, outerParam, innerParam); &#125; return innerFunc;&#125;const x = outerFunc(outerVar);outerVar = &quot;outer-2&quot;;globalVar = &quot;guess&quot;x(&quot;inner&quot;); 图片 上面打印结果是 guess outer inner。 当我们调用outerFunc函数并将返回值innerFunc函数分配给变量x时，即使我们为outerVar变量分配了新值outer-2，outerParam也继续保留outer值，因为重新分配是在调用outerFunc之后发生的，并且当我们调用outerFunc函数时，它会在作用域链中查找outerVar的值，此时的outerVar的值将为 &quot;outer&quot;。 现在，当我们调用引用了innerFunc的x变量时，innerParam将具有一个inner值，因为这是我们在调用中传递的值，而globalVar变量值为guess，因为在调用x变量之前，我们将一个新值分配给globalVar。 下面这个示例演示没有理解好闭包所犯的错误： 1234567891011const arrFuncs = [];for(var i = 0; i &lt; 5; i++)&#123; arrFuncs.push(function ()&#123; return i; &#125;);&#125;console.log(i); // i is 5for (let i = 0; i &lt; arrFuncs.length; i++) &#123; console.log(arrFuncs[i]()); // 都打印 5&#125; 由于闭包，此代码无法正常运行。var关键字创建一个全局变量，当我们 push 一个函数时，这里返回的全局变量i。因此，当我们在循环后在该数组中调用其中一个函数时，它会打印5，因为我们得到i的当前值为5，我们可以访问它，因为它是全局变量。 因为闭包在创建变量时会保留该变量的引用而不是其值。我们可以使用IIFES或使用 let 来代替 var 的声明。 21. JavaScript 中的虚值是什么？1const falsyValues = [&apos;&apos;, 0, null, undefined, NaN, false]; 简单的来说虚值就是是在转换为布尔值时变为 false 的值。 22. 如何检查值是否虚值？使用 Boolean 函数或者 !! 运算符。 23. ‘use strict’ 是干嘛用的？&quot;use strict&quot; 是 ES5 特性，它使我们的代码在函数或整个脚本中处于严格模式。严格模式帮助我们在代码的早期避免 bug，并为其添加限制。 严格模式的一些限制： 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀 0 表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性delete global[prop] eval不能在它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee 不能使用arguments.caller 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface） 设立”严格模式”的目的，主要有以下几个： 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。 24. JavaScript 中 this 值是什么？基本上，this指的是当前正在执行或调用该函数的对象的值。this值的变化取决于我们使用它的上下文和我们在哪里使用它。 12345678910const carDetails = &#123; name: &quot;Ford Mustang&quot;, yearBought: 2005, getName()&#123; return this.name; &#125;, isRegistered: true&#125;;console.log(carDetails.getName()); // Ford Mustang 这通常是我们期望结果的，因为在getName方法中我们返回this.name，在此上下文中，this指向的是carDetails对象，该对象当前是执行函数的“所有者”对象。 接下我们做些奇怪的事情： 1234var name = &quot;Ford Ranger&quot;;var getCarName = carDetails.getName;console.log(getCarName()); // Ford Ranger 上面打印Ford Ranger，这很奇怪，因为在第一个console.log语句中打印的是Ford Mustang。这样做的原因是getCarName方法有一个不同的“所有者”对象，即window对象。在全局作用域中使用var关键字声明变量会在window对象中附加与变量名称相同的属性。请记住，当没有使用“use strict”时，在全局作用域中this指的是window对象。 12console.log(getCarName === window.getCarName); // trueconsole.log(getCarName === this.getCarName); // true 本例中的this和window引用同一个对象。 解决这个问题的一种方法是在函数中使用apply和call方法。 12console.log(getCarName.apply(carDetails)); // Ford Mustangconsole.log(getCarName.call(carDetails)); // Ford Mustang apply和call方法期望第一个参数是一个对象，该对象是函数内部this的值。 IIFE或立即执行的函数表达式，在全局作用域内声明的函数，对象内部方法中的匿名函数和内部函数的this具有默认值，该值指向window对象。 12345678910111213141516171819202122232425262728(function ()&#123; console.log(this);&#125;)(); // 打印 &quot;window&quot; 对象function iHateThis()&#123; console.log(this);&#125;iHateThis(); // 打印 &quot;window&quot; 对象const myFavoriteObj = &#123; guessThis()&#123; function getName()&#123; console.log(this.name); &#125; getName(); &#125;, name: &apos;Marko Polo&apos;, thisIsAnnoying(callback)&#123; callback(); &#125;&#125;;myFavoriteObj.guessThis(); // 打印 &quot;window&quot; 对象myFavoriteObj.thisIsAnnoying(function ()&#123; console.log(this); // 打印 &quot;window&quot; 对象&#125;); 如果我们要获取myFavoriteObj对象中的name属性（即Marko Polo）的值，则有两种方法可以解决此问题。 一种是将 this 值保存在变量中。 12345678910111213const myFavoriteObj = &#123; guessThis()&#123; const self = this; // 把 this 值保存在 self 变量中 function getName()&#123; console.log(self.name); &#125; getName(); &#125;, name: &apos;Marko Polo&apos;, thisIsAnnoying(callback)&#123; callback(); &#125;&#125;; 第二种方式是使用箭头函数 123456789101112const myFavoriteObj = &#123; guessThis()&#123; const getName = () =&gt; &#123; console.log(this.name); &#125; getName(); &#125;, name: &apos;Marko Polo&apos;, thisIsAnnoying(callback)&#123; callback(); &#125;&#125;; 箭头函数没有自己的 this。它复制了这个封闭的词法作用域中this值，在这个例子中，this值在getName内部函数之外，也就是myFavoriteObj对象。 25. 对象的 prototype(原型) 是什么？简单地说，原型就是对象的蓝图。如果它存在当前对象中，则将其用作属性和方法的回退。它是在对象之间共享属性和功能的方法，这也是JavaScript实现继承的核心。 12const o = &#123;&#125;;console.log(o.toString()); // logs [object Object] 即使o对象中不存在o.toString方法，它也不会引发错误，而是返回字符串[object Object]。当对象中不存在属性时，它将查看其原型，如果仍然不存在，则将其查找到原型的原型，依此类推，直到在原型链中找到具有相同属性的属性为止。原型链的末尾是Object.prototype。 1console.log(o.toString === Object.prototype.toString); // logs true 26. 什么是 IIFE，它的用途是什么？IIFE或立即调用的函数表达式是在创建或声明后将被调用或执行的函数。创建IIFE的语法是，将function (){}包裹在在括号()内，然后再用另一个括号()调用它，如：(function(){})() 12345678910111213141516171819202122232425(function()&#123; ...&#125; ());(function () &#123; ...&#125;)();(function named(params) &#123; ...&#125;)();(() =&gt; &#123;&#125;);(function (global) &#123; ...&#125;)(window);const utility = (function () &#123; return &#123; ... &#125;&#125;) 这些示例都是有效的IIFE。倒数第二个表明我们可以将参数传递给IIFE函数。最后一个示例表明，我们可以将IIFE的结果保存到变量中，以便稍后使用。 IIFE的一个主要作用是避免与全局作用域内的其他变量命名冲突或污染全局命名空间，来个例子。 1&lt;script src=&quot;https://cdnurl.com/somelibrary.js&quot;&gt;&lt;/script&gt; 假设我们引入了一个omelibr.js的链接，它提供了一些我们在代码中使用的全局函数，但是这个库有两个方法我们没有使用：createGraph和drawGraph，因为这些方法都有bug。我们想实现自己的createGraph和drawGraph方法。 解决此问题的一种方法是直接覆盖： 123456789&lt;script src=&quot;https://cdnurl.com/somelibrary.js&quot;&gt;&lt;/script&gt;&lt;script&gt; function createGraph() &#123; // createGraph logic here &#125; function drawGraph() &#123; // drawGraph logic here &#125;&lt;/script&gt; 当我们使用这个解决方案时，我们覆盖了库提供给我们的那两个方法。 另一种方式是我们自己改名称： 123456789&lt;script src=&quot;https://cdnurl.com/somelibrary.js&quot;&gt;&lt;/script&gt;&lt;script&gt; function myCreateGraph() &#123; // createGraph logic here &#125; function myDrawGraph() &#123; // drawGraph logic here &#125;&lt;/script&gt; 当我们使用这个解决方案时，我们把那些函数调用更改为新的函数名。 还有一种方法就是使用IIFE： 123456789101112131415&lt;script src=&quot;https://cdnurl.com/somelibrary.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const graphUtility = (function () &#123; function createGraph() &#123; // createGraph logic here &#125; function drawGraph() &#123; // drawGraph logic here &#125; return &#123; createGraph, drawGraph &#125; &#125;)&lt;/script&gt; 在此解决方案中，我们要声明了graphUtility 变量，用来保存IIFE执行的结果，该函数返回一个包含两个方法createGraph和drawGraph的对象。 IIFE 还可以用来解决一个常见的面试题： 12345var li = document.querySelectorAll(&apos;.list-group &gt; li&apos;);for (var i = 0, len = li.length; i &lt; len; i++) &#123; li[i].addEventListener(&apos;click&apos;, function (e) &#123; console.log(i); &#125;) 假设我们有一个带有list-group类的ul元素，它有5个li子元素。当我们单击单个li元素时，打印对应的下标值。但在此外上述代码不起作用，这里每次点击 li 打印 i 的值都是5，这是由于闭包的原因。 闭包只是函数记住其当前作用域，父函数作用域和全局作用域的变量引用的能力。当我们在全局作用域内使用var关键字声明变量时，就创建全局变量i。因此，当我们单击li元素时，它将打印5，因为这是稍后在回调函数中引用它时i的值。 使用 IIFE 可以解决此问题： 12345678var li = document.querySelectorAll(&apos;.list-group &gt; li&apos;);for (var i = 0, len = li.length; i &lt; len; i++) &#123; (function (currentIndex) &#123; li[currentIndex].addEventListener(&apos;click&apos;, function (e) &#123; console.log(currentIndex); &#125;) &#125;)(i);&#125; 该解决方案之所以行的通，是因为IIFE会为每次迭代创建一个新的作用域，我们捕获i的值并将其传递给currentIndex参数，因此调用IIFE时，每次迭代的currentIndex值都是不同的。 27. Function.prototype.apply 方法的用途是什么？apply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。 123456789const details = &#123; message: &apos;Hello World!&apos;&#125;;function getMessage()&#123; return this.message;&#125;getMessage.apply(details); // &apos;Hello World!&apos; call()方法的作用和 apply() 方法类似，区别就是call()方法接受的是参数列表，而apply()方法接受的是一个参数数组。 123456789const person = &#123; name: &quot;Marko Polo&quot;&#125;;function greeting(greetingMessage) &#123; return `$&#123;greetingMessage&#125; $&#123;this.name&#125;`;&#125;greeting.apply(person, [&apos;Hello&apos;]); // &quot;Hello Marko Polo!&quot; 28. Function.prototype.call 方法的用途是什么？call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。 123456789const details = &#123; message: &apos;Hello World!&apos;&#125;;function getMessage()&#123; return this.message;&#125;getMessage.call(details); // &apos;Hello World!&apos; 注意：该方法的语法和作用与 apply() 方法类似，只有一个区别，就是 call() 方法接受的是一个参数列表，而 apply() 方法接受的是一个包含多个参数的数组。 123456789const person = &#123; name: &quot;Marko Polo&quot;&#125;;function greeting(greetingMessage) &#123; return `$&#123;greetingMessage&#125; $&#123;this.name&#125;`;&#125;greeting.call(person, &apos;Hello&apos;); // &quot;Hello Marko Polo!&quot; 29. Function.prototype.apply 和 Function.prototype.call 之间有什么区别？apply()方法可以在使用一个指定的 this 值和一个参数数组（或类数组对象）的前提下调用某个函数或方法。call()方法类似于apply()，不同之处仅仅是call()接受的参数是参数列表。 123456789101112131415161718const obj1 = &#123; result:0&#125;;const obj2 = &#123; result:0&#125;;function reduceAdd()&#123; let result = 0; for(let i = 0, len = arguments.length; i &lt; len; i++)&#123; result += arguments[i]; &#125; this.result = result;&#125;reduceAdd.apply(obj1, [1, 2, 3, 4, 5]); // 15reduceAdd.call(obj2, 1, 2, 3, 4, 5); // 15 30. Function.prototype.bind 的用途是什么？bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。 123456789101112131415161718192021222324252627import React from &apos;react&apos;;class MyComponent extends React.Component &#123; constructor(props)&#123; super(props); this.state = &#123; value : &quot;&quot; &#125; this.handleChange = this.handleChange.bind(this); // 将 “handleChange” 方法绑定到 “MyComponent” 组件 &#125; handleChange(e)&#123; //do something amazing here &#125; render()&#123; return ( &lt;&gt; &lt;input type=&#123;this.props.type&#125; value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/&gt; ) &#125;&#125; 31. 什么是函数式编程? JavaScript 的哪些特性使其成为函数式语言的候选语言？函数式编程（通常缩写为FP）是通过编写纯函数，避免共享状态、可变数据、副作用 来构建软件的过程。数式编程是声明式 的而不是命令式 的，应用程序的状态是通过纯函数流动的。与面向对象编程形成对比，面向对象中应用程序的状态通常与对象中的方法共享和共处。 函数式编程是一种编程范式 ，这意味着它是一种基于一些基本的定义原则（如上所列）思考软件构建的方式。当然，编程范式的其他示例也包括面向对象编程和过程编程。 函数式的代码往往比命令式或面向对象的代码更简洁，更可预测，更容易测试 - 但如果不熟悉它以及与之相关的常见模式，函数式的代码也可能看起来更密集杂乱，并且 相关文献对新人来说是不好理解的。 JavaScript支持闭包和高阶函数是函数式编程语言的特点。 32. 什么是高阶函数？高阶函数只是将函数作为参数或返回值的函数。 123function higherOrderFunction(param,callback)&#123; return callback(param);&#125; 33. 为什么函数被称为一等公民？在JavaScript中，函数不仅拥有一切传统函数的使用方式（声明和调用），而且可以做到像简单值一样赋值（var func = function(){}）、传参(function func(x,callback){callback();})、返回(function(){return function(){}})，这样的函数也称之为第一级函数（First-class Function）。不仅如此，JavaScript中的函数还充当了类的构造函数的作用，同时又是一个Function类的实例(instance)。这样的多重身份让JavaScript的函数变得非常重要。 34. 手动实现 Array.prototype.map 方法map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 123456789101112131415function map(arr, mapCallback) &#123; // 首先，检查传递的参数是否正确。 if (!Array.isArray(arr) || !arr.length || typeof mapCallback !== &apos;function&apos;) &#123; return []; &#125; else &#123; let result = []; // 每次调用此函数时，我们都会创建一个 result 数组 // 因为我们不想改变原始数组。 for (let i = 0, len = arr.length; i &lt; len; i++) &#123; result.push(mapCallback(arr[i], i, arr)); // 将 mapCallback 返回的结果 push 到 result 数组中 &#125; return result; &#125;&#125; 35. 手动实现Array.prototype.filter方法filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 12345678910111213141516171819function filter(arr, filterCallback) &#123; // 首先，检查传递的参数是否正确。 if (!Array.isArray(arr) || !arr.length || typeof filterCallback !== &apos;function&apos;) &#123; return []; &#125; else &#123; let result = []; // 每次调用此函数时，我们都会创建一个 result 数组 // 因为我们不想改变原始数组。 for (let i = 0, len = arr.length; i &lt; len; i++) &#123; // 检查 filterCallback 的返回值是否是真值 if (filterCallback(arr[i], i, arr)) &#123; // 如果条件为真，则将数组元素 push 到 result 中 result.push(arr[i]); &#125; &#125; return result; // return the result array &#125;&#125; 36. 手动实现Array.prototype.reduce方法reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。 123456789101112131415161718function reduce(arr, reduceCallback, initialValue) &#123; // 首先，检查传递的参数是否正确。 if (!Array.isArray(arr) || !arr.length || typeof reduceCallback !== &apos;function&apos;) &#123; return []; &#125; else &#123; // 如果没有将initialValue传递给该函数，我们将使用第一个数组项作为initialValue let hasInitialValue = initialValue !== undefined; let value = hasInitialValue ? initialValue : arr[0]; 、 // 如果有传递 initialValue，则索引从 1 开始，否则从 0 开始 for (let i = hasInitialValue ? 0 : 1, len = arr.length; i &lt; len; i++) &#123; value = reduceCallback(value, arr[i], i, arr); &#125; return value; &#125;&#125; 37. arguments 的对象是什么？arguments对象是函数中传递的参数值的集合。它是一个类似数组的对象，因为它有一个length属性，我们可以使用数组索引表示法arguments[1]来访问单个值，但它没有数组中的内置方法，如：forEach、reduce、filter和map。 我们可以使用Array.prototype.slice将arguments对象转换成一个数组。 123function one() &#123; return Array.prototype.slice.call(arguments);&#125; 注意:箭头函数中没有arguments对象。 12345678910111213function one() &#123; return arguments;&#125;const two = function () &#123; return arguments;&#125;const three = function three() &#123; return arguments;&#125;const four = () =&gt; arguments;four(); // Throws an error - arguments is not defined 当我们调用函数four时，它会抛出一个ReferenceError: arguments is not defined error。使用rest语法，可以解决这个问题。 1const four = (...args) =&gt; args; 这会自动将所有参数值放入数组中。 38. 如何创建一个没有 prototype(原型)的对象？我们可以使用Object.create方法创建没有原型的对象。 123456const o1 = &#123;&#125;;console.log(o1.toString()); // [object Object]const o2 = Object.create(null);console.log(o2.toString());// throws an error o2.toString is not a function 39. 为什么在调用这个函数时，代码中的b会变成一个全局变量?12345function myFunc() &#123; let a = b = 0;&#125;myFunc(); 原因是赋值运算符是从右到左的求值的。这意味着当多个赋值运算符出现在一个表达式中时，它们是从右向左求值的。所以上面代码变成了这样： 12345function myFunc() &#123; let a = (b = 0);&#125;myFunc(); 首先，表达式b = 0求值，在本例中b没有声明。因此，JS引擎在这个函数外创建了一个全局变量b，之后表达式b = 0的返回值为0，并赋给新的局部变量a。 我们可以通过在赋值之前先声明变量来解决这个问题。 12345function myFunc() &#123; let a,b; a = b = 0;&#125;myFunc(); 40. ECMAScript 是什么？ECMAScript 是编写脚本语言的标准，这意味着JavaScript遵循ECMAScript标准中的规范变化，因为它是JavaScript的蓝图。 ECMAScript 和 Javascript，本质上都跟一门语言有关，一个是语言本身的名字，一个是语言的约束条件只不过发明JavaScript的那个人（Netscape公司），把东西交给了ECMA（European Computer Manufacturers Association），这个人规定一下他的标准，因为当时有java语言了，又想强调这个东西是让ECMA这个人定的规则，所以就这样一个神奇的东西诞生了，这个东西的名称就叫做ECMAScript。 javaScript = ECMAScript + DOM + BOM（自认为是一种广义的JavaScript） ECMAScript说什么JavaScript就得做什么！ JavaScript（狭义的JavaScript）做什么都要问问ECMAScript我能不能这样干！如果不能我就错了！能我就是对的！ ——突然感觉JavaScript好没有尊严，为啥要搞个人出来约束自己， 那个人被创造出来也好委屈，自己被创造出来完全是因为要约束JavaScript。 41. ES6或ECMAScript 2015有哪些新特性？ 箭头函数 类 模板字符串 加强的对象字面量 对象解构 Promise 生成器 模块 Symbol 代理 Set 函数默认参数 rest 和展开 块作用域 42. var,let和const的区别是什么？var声明的变量会挂载在window上，而let和const声明的变量不会： 12345678var a = 100;console.log(a,window.a); // 100 100let b = 10;console.log(b,window.b); // 10 undefinedconst c = 1;console.log(c,window.c); // 1 undefined var声明变量存在变量提升，let和const不存在变量提升: 12345678console.log(a); // undefined ===&gt; a已声明还没赋值，默认得到undefined值var a = 100;console.log(b); // 报错：b is not defined ===&gt; 找不到b这个变量let b = 10;console.log(c); // 报错：c is not defined ===&gt; 找不到c这个变量const c = 10; let和const声明形成块作用域 12345678910111213141516if(1)&#123; var a = 100; let b = 10;&#125;console.log(a); // 100console.log(b) // 报错：b is not defined ===&gt; 找不到b这个变量-------------------------------------------------------------if(1)&#123; var a = 100; const c = 1;&#125;console.log(a); // 100console.log(c) // 报错：c is not defined ===&gt; 找不到c这个变量 同一作用域下let和const不能声明同名变量，而var可以 12345678910var a = 100;console.log(a); // 100var a = 10;console.log(a); // 10-------------------------------------let a = 100;let a = 10;// 控制台报错：Identifier &apos;a&apos; has already been declared ===&gt; 标识符a已经被声明了。 暂存死区 12345678var a = 100;if(1)&#123; a = 10; //在当前块作用域中存在a使用let/const声明的情况下，给a赋值10时，只会在当前作用域找变量a， // 而这时，还未到声明时候，所以控制台Error:a is not defined let a = 1;&#125; const 12345678910111213141516171819/** 1、一旦声明必须赋值,不能使用null占位。** 2、声明后不能再修改** 3、如果声明的是复合类型数据，可以修改其属性** */const a = 100; const list = [];list[0] = 10;console.log(list); // [10]const obj = &#123;a:100&#125;;obj.name = &apos;apple&apos;;obj.a = 10000;console.log(obj); // &#123;a:10000,name:&apos;apple&apos;&#125; 43. 什么是箭头函数？箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。 1234567//ES5 Versionvar getCurrentDate = function ()&#123; return new Date();&#125;//ES6 Versionconst getCurrentDate = () =&gt; new Date(); 在本例中，ES5 版本中有function(){}声明和return关键字，这两个关键字分别是创建函数和返回值所需要的。在箭头函数版本中，我们只需要()括号，不需要 return 语句，因为如果我们只有一个表达式或值需要返回，箭头函数就会有一个隐式的返回。 12345678//ES5 Versionfunction greet(name) &#123; return &apos;Hello &apos; + name + &apos;!&apos;;&#125;//ES6 Versionconst greet = (name) =&gt; `Hello $&#123;name&#125;`;const greet2 = name =&gt; `Hello $&#123;name&#125;`; 我们还可以在箭头函数中使用与函数表达式和函数声明相同的参数。如果我们在一个箭头函数中有一个参数，则可以省略括号。 123const getArgs = () =&gt; argumentsconst getArgs2 = (...rest) =&gt; rest 箭头函数不能访问arguments对象。所以调用第一个getArgs函数会抛出一个错误。相反，我们可以使用rest参数来获得在箭头函数中传递的所有参数。 1234567891011const data = &#123; result: 0, nums: [1, 2, 3, 4, 5], computeResult() &#123; // 这里的“this”指的是“data”对象 const addAll = () =&gt; &#123; return this.nums.reduce((total, cur) =&gt; total + cur, 0) &#125;; this.result = addAll(); &#125;&#125;; 箭头函数没有自己的this值。它捕获词法作用域函数的this值，在此示例中，addAll函数将复制computeResult 方法中的this值，如果我们在全局作用域声明箭头函数，则this值为 window 对象。 44. 什么是类？类(class)是在 JS 中编写构造函数的新方法。它是使用构造函数的语法糖，在底层中使用仍然是原型和基于原型的继承。 1234567891011121314151617181920212223242526272829303132333435363738394041//ES5 Versionfunction Person(firstName, lastName, age, address)&#123; this.firstName = firstName; this.lastName = lastName; this.age = age; this.address = address;&#125;Person.self = function()&#123; return this;&#125;Person.prototype.toString = function()&#123; return &quot;[object Person]&quot;;&#125;Person.prototype.getFullName = function ()&#123; return this.firstName + &quot; &quot; + this.lastName;&#125; //ES6 Versionclass Person &#123; constructor(firstName, lastName, age, address)&#123; this.lastName = lastName; this.firstName = firstName; this.age = age; this.address = address; &#125; static self() &#123; return this; &#125; toString()&#123; return &quot;[object Person]&quot;; &#125; getFullName()&#123; return `$&#123;this.firstName&#125; $&#123;this.lastName&#125;`; &#125;&#125; 重写方法并从另一个类继承。 123456789101112131415161718192021222324252627282930313233//ES5 VersionEmployee.prototype = Object.create(Person.prototype);function Employee(firstName, lastName, age, address, jobTitle, yearStarted) &#123; Person.call(this, firstName, lastName, age, address); this.jobTitle = jobTitle; this.yearStarted = yearStarted;&#125;Employee.prototype.describe = function () &#123; return `I am $&#123;this.getFullName()&#125; and I have a position of $&#123;this.jobTitle&#125; and I started at $&#123;this.yearStarted&#125;`;&#125;Employee.prototype.toString = function () &#123; return &quot;[object Employee]&quot;;&#125;//ES6 Versionclass Employee extends Person &#123; //Inherits from &quot;Person&quot; class constructor(firstName, lastName, age, address, jobTitle, yearStarted) &#123; super(firstName, lastName, age, address); this.jobTitle = jobTitle; this.yearStarted = yearStarted; &#125; describe() &#123; return `I am $&#123;this.getFullName()&#125; and I have a position of $&#123;this.jobTitle&#125; and I started at $&#123;this.yearStarted&#125;`; &#125; toString() &#123; // Overriding the &quot;toString&quot; method of &quot;Person&quot; return &quot;[object Employee]&quot;; &#125;&#125; 所以我们要怎么知道它在内部使用原型？ 12345678910111213141516class Something &#123;&#125;function AnotherSomething()&#123;&#125;const as = new AnotherSomething();const s = new Something();console.log(typeof Something); // &quot;function&quot;console.log(typeof AnotherSomething); // &quot;function&quot;console.log(as.toString()); // &quot;[object Object]&quot;console.log(as.toString()); // &quot;[object Object]&quot;console.log(as.toString === Object.prototype.toString); // trueconsole.log(s.toString === Object.prototype.toString); // true 45. 什么是模板字符串？模板字符串是在 JS 中创建字符串的一种新方法。我们可以通过使用反引号使模板字符串化。 12345//ES5 Versionvar greet = &apos;Hi I\\&apos;m Mark&apos;;//ES6 Versionlet greet = `Hi I&apos;m Mark`; 在 ES5 中我们需要使用一些转义字符来达到多行的效果，在模板字符串不需要这么麻烦： 12345678910111213//ES5 Versionvar lastWords = &apos;\\n&apos; + &apos; I \\n&apos; + &apos; Am \\n&apos; + &apos;Iron Man \\n&apos;;//ES6 Versionlet lastWords = ` I Am Iron Man `; 在ES5版本中，我们需要添加\\n以在字符串中添加新行。在模板字符串中，我们不需要这样做。 12345678910//ES5 Versionfunction greet(name) &#123; return &apos;Hello &apos; + name + &apos;!&apos;;&#125;//ES6 Versionfunction greet(name) &#123; return `Hello $&#123;name&#125; !`;&#125; 在 ES5 版本中，如果需要在字符串中添加表达式或值，则需要使用+运算符。在模板字符串s中，我们可以使用${expr}嵌入一个表达式，这使其比 ES5 版本更整洁。 46. 什么是对象解构？对象析构是从对象或数组中获取或提取值的一种新的、更简洁的方法。假设有如下的对象： 123456const employee = &#123; firstName: &quot;Marko&quot;, lastName: &quot;Polo&quot;, position: &quot;Software Developer&quot;, yearHired: 2017&#125;; 从对象获取属性，早期方法是创建一个与对象属性同名的变量。这种方法很麻烦，因为我们要为每个属性创建一个新变量。假设我们有一个大对象，它有很多属性和方法，用这种方法提取属性会很麻烦。 1234var firstName = employee.firstName;var lastName = employee.lastName;var position = employee.position;var yearHired = employee.yearHired; 使用解构方式语法就变得简洁多了： 1&#123; firstName, lastName, position, yearHired &#125; = employee; 我们还可以为属性取别名： 1let &#123; firstName: fName, lastName: lName, position, yearHired &#125; = employee; 当然如果属性值为 undefined 时，我们还可以指定默认值： 1let &#123; firstName = &quot;Mark&quot;, lastName: lName, position, yearHired &#125; = employee; 47. 什么是 ES6 模块？模块使我们能够将代码基础分割成多个文件，以获得更高的可维护性，并且避免将所有代码放在一个大文件中。在 ES6 支持模块之前，有两个流行的模块。 CommonJS-Node.js AMD（异步模块定义）-浏览器 基本上，使用模块的方式很简单，import用于从另一个文件中获取功能或几个功能或值，同时export用于从文件中公开功能或几个功能或值。 导出 使用 ES5 (CommonJS) 123456789101112// 使用 ES5 CommonJS - helpers.jsexports.isNull = function (val) &#123; return val === null;&#125;exports.isUndefined = function (val) &#123; return val === undefined;&#125;exports.isNullOrUndefined = function (val) &#123; return exports.isNull(val) || exports.isUndefined(val);&#125; 使用 ES6 模块 123456789101112// 使用 ES6 Modules - helpers.jsexport function isNull(val)&#123; return val === null;&#125;export function isUndefined(val) &#123; return val === undefined;&#125;export function isNullOrUndefined(val) &#123; return isNull(val) || isUndefined(val);&#125; 在另一个文件中导入函数 123456789101112131415161718// 使用 ES5 (CommonJS) - index.jsconst helpers = require(&apos;./helpers.js&apos;); // helpers is an objectconst isNull = helpers.isNull;const isUndefined = helpers.isUndefined;const isNullOrUndefined = helpers.isNullOrUndefined;// or if your environment supports Destructuringconst &#123; isNull, isUndefined, isNullOrUndefined &#125; = require(&apos;./helpers.js&apos;);-------------------------------------------------------// ES6 Modules - index.jsimport * as helpers from &apos;./helpers.js&apos;; // helpers is an object// or import &#123; isNull, isUndefined, isNullOrUndefined as isValid &#125; from &apos;./helpers.js&apos;;// using &quot;as&quot; for renaming named exports 在文件中导出单个功能或默认导出 使用 ES5 (CommonJS) 1234567891011121314151617// 使用 ES5 (CommonJS) - index.jsclass Helpers &#123; static isNull(val) &#123; return val === null; &#125; static isUndefined(val) &#123; return val === undefined; &#125; static isNullOrUndefined(val) &#123; return this.isNull(val) || this.isUndefined(val); &#125;&#125;module.exports = Helpers; 使用ES6 Modules 12345678910111213141516// 使用 ES6 Modules - helpers.jsclass Helpers &#123; static isNull(val) &#123; return val === null; &#125; static isUndefined(val) &#123; return val === undefined; &#125; static isNullOrUndefined(val) &#123; return this.isNull(val) || this.isUndefined(val); &#125;&#125;export default Helpers 从另一个文件导入单个功能 使用ES5 (CommonJS) 123// 使用 ES5 (CommonJS) - index.jsconst Helpers = require(&apos;./helpers.js&apos;); console.log(Helpers.isNull(null)); 使用 ES6 Modules 12import Helpers from &apos;.helpers.js&apos;console.log(Helpers.isNull(null)); 48. 什么是Set对象，它是如何工作的？Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。 我们可以使用Set构造函数创建Set实例。 12const set1 = new Set();const set2 = new Set([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;d&quot;,&quot;e&quot;]); 我们可以使用add方法向Set实例中添加一个新值，因为add方法返回Set对象，所以我们可以以链式的方式再次使用add。如果一个值已经存在于Set对象中，那么它将不再被添加。 123set2.add(&quot;f&quot;);set2.add(&quot;g&quot;).add(&quot;h&quot;).add(&quot;i&quot;).add(&quot;j&quot;).add(&quot;k&quot;).add(&quot;k&quot;);// 后一个“k”不会被添加到set对象中，因为它已经存在了 我们可以使用has方法检查Set实例中是否存在特定的值。 12set2.has(&quot;a&quot;) // trueset2.has(&quot;z&quot;) // true 我们可以使用size属性获得Set实例的长度。 1set2.size // returns 10 可以使用clear方法删除 Set 中的数据。 1set2.clear(); 我们可以使用Set对象来删除数组中重复的元素。 12const numbers = [1, 2, 3, 4, 5, 6, 6, 7, 8, 8, 5];const uniqueNums = [...new Set(numbers)]; // [1,2,3,4,5,6,7,8] 49. 什么是回调函数？回调函数是一段可执行的代码段，它作为一个参数传递给其他的代码，其作用是在需要的时候方便调用这段（回调函数）代码。 在JavaScript中函数也是对象的一种，同样对象可以作为参数传递给函数，因此函数也可以作为参数传递给另外一个函数，这个作为参数的函数就是回调函数。 12345const btnAdd = document.getElementById(&apos;btnAdd&apos;);btnAdd.addEventListener(&apos;click&apos;, function clickCallback(e) &#123; // do something useless&#125;); 在本例中，我们等待id为btnAdd的元素中的click事件，如果它被单击，则执行clickCallback函数。回调函数向某些数据或事件添加一些功能。 数组中的reduce、filter和map方法需要一个回调作为参数。回调的一个很好的类比是，当你打电话给某人，如果他们不接，你留下一条消息，你期待他们回调。调用某人或留下消息的行为是事件或数据，回调是你希望稍后发生的操作。 50. Promise 是什么？Promise 是异步编程的一种解决方案：从语法上讲，promise是一个对象，从它可以获取异步操作的消息；从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。promise有三种状态：pending(等待态)，fulfiled(成功态)，rejected(失败态)；状态一旦改变，就不会再变。创造promise实例后，它会立即执行。 123456fs.readFile(&apos;somefile.txt&apos;, function (e, data) &#123; if (e) &#123; console.log(e); &#125; console.log(data);&#125;); 如果我们在回调内部有另一个异步操作，则此方法存在问题。我们将有一个混乱且不可读的代码。此代码称为“回调地狱”。 12345678910// 回调地狱fs.readFile(&apos;somefile.txt&apos;, function (e, data) &#123; //your code here fs.readdir(&apos;directory&apos;, function (e, files) &#123; //your code here fs.mkdir(&apos;directory&apos;, function (e) &#123; //your code here &#125;) &#125;)&#125;) 如果我们在这段代码中使用promise，它将更易于阅读、理解和维护。 12345678910promReadFile(&apos;file/path&apos;) .then(data =&gt; &#123; return promReaddir(&apos;directory&apos;); &#125;) .then(data =&gt; &#123; return promMkdir(&apos;directory&apos;); &#125;) .catch(e =&gt; &#123; console.log(e); &#125;) promise有三种不同的状态： pending：初始状态，完成或失败状态的前一个状态 fulfilled：操作成功完成 rejected：操作失败 pending 状态的 Promise 对象会触发 fulfilled/rejected 状态，在其状态处理方法中可以传入参数/失败信息。当操作成功完成时，Promise 对象的 then 方法就会被调用；否则就会触发 catch。如： 123456789const myFirstPromise = new Promise((resolve, reject) =&gt; &#123; setTimeout(function()&#123; resolve(&quot;成功!&quot;); &#125;, 250);&#125;);myFirstPromise.then((data) =&gt; &#123; console.log(&quot;Yay! &quot; + data);&#125;).catch((e) =&gt; &#123;...&#125;); 51. 什么是 async/await 及其如何工作？async/await是 JS 中编写异步或非阻塞代码的新方法。它建立在Promises之上，让异步代码的可读性和简洁度都更高。 async/await是 JS 中编写异步或非阻塞代码的新方法。它建立在Promises之上，相对于 Promise 和回调，它的可读性和简洁度都更高。但是，在使用此功能之前，我们必须先学习Promises的基础知识，因为正如我之前所说，它是基于Promise构建的，这意味着幕后使用仍然是Promise。 使用 Promise 123456789function callApi() &#123; return fetch(&quot;url/to/api/endpoint&quot;) .then(resp =&gt; resp.json()) .then(data =&gt; &#123; //do something with &quot;data&quot; &#125;).catch(err =&gt; &#123; //do something with &quot;err&quot; &#125;);&#125; 使用async/await 在async/await，我们使用 tru/catch 语法来捕获异常。 123456789async function callApi() &#123; try &#123; const resp = await fetch(&quot;url/to/api/endpoint&quot;); const data = await resp.json(); //do something with &quot;data&quot; &#125; catch (e) &#123; //do something with &quot;err&quot; &#125;&#125; 注意:使用 async关键声明函数会隐式返回一个Promise。 123456const giveMeOne = async () =&gt; 1;giveMeOne() .then((num) =&gt; &#123; console.log(num); // logs 1 &#125;); 注意:await关键字只能在async function中使用。在任何非async function的函数中使用await关键字都会抛出错误。await关键字在执行下一行代码之前等待右侧表达式(可能是一个Promise)返回。 123456789101112131415161718192021222324const giveMeOne = async () =&gt; 1;function getOne() &#123; try &#123; const num = await giveMeOne(); console.log(num); &#125; catch (e) &#123; console.log(e); &#125;&#125;// Uncaught SyntaxError: await is only valid in async functionasync function getTwo() &#123; try &#123; const num1 = await giveMeOne(); // 这行会等待右侧表达式执行完成 const num2 = await giveMeOne(); return num1 + num2; &#125; catch (e) &#123; console.log(e); &#125;&#125;await getTwo(); // 2 52. 展开(spread )运算符和 剩余(Rest) 运算符有什么区别？展开运算符(spread)是三个点(...)，可以将一个数组转为用逗号分隔的参数序列。说的通俗易懂点，有点像化骨绵掌，把一个大元素给打散成一个个单独的小元素。 剩余运算符也是用三个点(...)表示，它的样子看起来和展开操作符一样，但是它是用于解构数组和对象。在某种程度上，剩余元素和展开元素相反，展开元素会“展开”数组变成多个元素，剩余元素会收集多个元素和“压缩”成一个单一的元素。 1234567function add(a, b) &#123; return a + b;&#125;;const nums = [5, 6];const sum = add(...nums);console.log(sum); 在本例中，我们在调用add函数时使用了展开操作符，对nums数组进行展开。所以参数a的值是5 ，b的值是6，所以sum 是11。 123456function add(...rest) &#123; return rest.reduce((total,current) =&gt; total + current);&#125;;console.log(add(1, 2)); // 3console.log(add(1, 2, 3, 4, 5)); // 15 在本例中，我们有一个add函数，它接受任意数量的参数，并将它们全部相加，然后返回总数。 123const [first, ...others] = [1, 2, 3, 4, 5];console.log(first); // 1console.log(others); // [2,3,4,5] 这里，我们使用剩余操作符提取所有剩余的数组值，并将它们放入除第一项之外的其他数组中。 53. 什么是默认参数？默认参数是在 JS 中定义默认变量的一种新方法，它在ES6或ECMAScript 2015版本中可用。 123456789101112//ES5 Versionfunction add(a,b)&#123; a = a || 0; b = b || 0; return a + b;&#125;//ES6 Versionfunction add(a = 0, b = 0)&#123; return a + b;&#125;add(1); // returns 1 我们还可以在默认参数中使用解构。 12345678910111213function getFirst([first, ...rest] = [0, 1]) &#123; return first;&#125;getFirst(); // 0getFirst([10,20,30]); // 10function getArr(&#123; nums &#125; = &#123; nums: [1, 2, 3, 4] &#125;)&#123; return nums;&#125;getArr(); // [1, 2, 3, 4]getArr(&#123;nums:[5,4,3,2,1]&#125;); // [5,4,3,2,1] 我们还可以使用先定义的参数再定义它们之后的参数。 1234function doSomethingWithValue(value = &quot;Hello World&quot;, callback = () =&gt; &#123; console.log(value) &#125;) &#123; callback();&#125;doSomethingWithValue(); //&quot;Hello World&quot; 54. 什么是包装对象（wrapper object）？我们现在复习一下JS的数据类型，JS数据类型被分为两大类，基本类型和引用类型。 基本类型：Undefined,Null,Boolean,Number,String,Symbol,BigInt 引用类型：Object,Array,Date,RegExp等，说白了就是对象。 其中引用类型有方法和属性，但是基本类型是没有的，但我们经常会看到下面的代码： 1234let name = &quot;marko&quot;;console.log(typeof name); // &quot;string&quot;console.log(name.toUpperCase()); // &quot;MARKO&quot; name类型是 string，属于基本类型，所以它没有属性和方法，但是在这个例子中，我们调用了一个toUpperCase()方法，它不会抛出错误，还返回了对象的变量值。 原因是基本类型的值被临时转换或强制转换为对象，因此name变量的行为类似于对象。除null和undefined之外的每个基本类型都有自己包装对象。也就是：String，Number，Boolean，Symbol和BigInt。在这种情况下，name.toUpperCase()在幕后看起来如下： 1console.log(new String(name).toUpperCase()); // &quot;MARKO&quot; 在完成访问属性或调用方法之后，新创建的对象将立即被丢弃。 55. 隐式和显式转换有什么区别）？隐式强制转换是一种将值转换为另一种类型的方法，这个过程是自动完成的，无需我们手动操作。 假设我们下面有一个例子。 123console.log(1 + &apos;6&apos;); // 16console.log(false + true); // 1console.log(6 * &apos;2&apos;); // 12 第一个console.log语句结果为16。在其他语言中，这会抛出编译时错误，但在 JS 中，1被转换成字符串，然后与+运算符连接。我们没有做任何事情，它是由 JS 自动完成。 第二个console.log语句结果为1，JS 将false转换为boolean 值为 0，,true为1，因此结果为1。 第三个console.log语句结果12，它将&#39;2&#39;转换为一个数字，然后乘以6 * 2，结果是12。 而显式强制是将值转换为另一种类型的方法，我们需要手动转换。 1console.log(1 + parseInt(&apos;6&apos;)); 在本例中，我们使用parseInt函数将&#39;6&#39;转换为number ，然后使用+运算符将1和6相加。 56. 什么是NaN？以及如何检查值是否为NaN？NaN表示“非数字”是 JS 中的一个值，该值是将数字转换或执行为非数字值的运算结果，因此结果为NaN。 12345678910let a;console.log(parseInt(&apos;abc&apos;)); // NaNconsole.log(parseInt(null)); // NaNconsole.log(parseInt(undefined)); // NaNconsole.log(parseInt(++a)); // NaNconsole.log(parseInt(&#123;&#125; * 10)); // NaNconsole.log(parseInt(&apos;abc&apos; - 2)); // NaNconsole.log(parseInt(0 / 0)); // NaNconsole.log(parseInt(&apos;10a&apos; * 10)); // NaN JS 有一个内置的isNaN方法，用于测试值是否为isNaN值，但是这个函数有一个奇怪的行为。 12345console.log(isNaN()); // trueconsole.log(isNaN(undefined)); // trueconsole.log(isNaN(&#123;&#125;)); // trueconsole.log(isNaN(String(&apos;a&apos;))); // trueconsole.log(isNaN(() =&gt; &#123; &#125;)); // true 所有这些console.log语句都返回true，即使我们传递的值不是NaN。 在ES6中，建议使用Number.isNaN方法，因为它确实会检查该值（如果确实是NaN），或者我们可以使自己的辅助函数检查此问题，因为在 JS 中，NaN是唯一的值，它不等于自己。 123function checkIfNaN(value) &#123; return value !== value;&#125; 57. 如何判断值是否为数组？我们可以使用Array.isArray方法来检查值是否为数组。当传递给它的参数是数组时，它返回true，否则返回false。 1234567console.log(Array.isArray(5)); // falseconsole.log(Array.isArray(&quot;&quot;)); // falseconsole.log(Array.isArray()); // falseconsole.log(Array.isArray(null)); // falseconsole.log(Array.isArray(&#123; length: 5 &#125;)); // falseconsole.log(Array.isArray([])); // true 如果环境不支持此方法，则可以使用polyfill实现。 123function isArray(value)&#123; return Object.prototype.toString.call(value) === &quot;[object Array]&quot;&#125; 当然还可以使用传统的方法： 123456let a = []if (a instanceof Array) &#123; console.log(&apos;是数组&apos;)&#125; else &#123; console.log(&apos;非数组&apos;)&#125; 58. 如何在不使用%模运算符的情况下检查一个数字是否是偶数？我们可以对这个问题使用按位&amp;运算符，&amp;对其操作数进行运算，并将其视为二进制值，然后执行与运算。 123456789101112131415function isEven(num) &#123; if (num &amp; 1) &#123; return false &#125; else &#123; return true &#125;&#125;0` 二进制数是 `000``1` 二进制数是 `001``2` 二进制数是 `010``3` 二进制数是 `011``4` 二进制数是 `100``5` 二进制数是 `101``6` 二进制数是 `110``7` 二进制数是 `111 以此类推… 与运算的规则如下： a b a &amp; b 0 0 0 0 1 0 1 1 1 因此，当我们执行console.log(5&amp;1)这个表达式时，结果为1。首先，&amp;运算符将两个数字都转换为二进制，因此5变为101，1变为001。 然后，它使用按位怀运算符比较每个位（0和1）。101&amp;001，从表中可以看出，如果a &amp; b为1，所以5&amp;1结果为1。 101 &amp; 001 101 001 001 首先我们比较最左边的1&amp;0，结果是0。 然后我们比较中间的0&amp;0，结果是0。 然后我们比较最后1&amp;1，结果是1。 最后，得到一个二进制数001，对应的十进制数，即1。 由此我们也可以算出console.log(4 &amp; 1) 结果为0。知道4的最后一位是0，而0 &amp; 1 将是0。如果你很难理解这一点，我们可以使用递归函数来解决此问题。 12345function isEven(num) &#123; if (num &lt; 0 || num === 1) return false; if (num == 0) return true; return isEven(num - 2);&#125; 59. 如何检查对象中是否存在某个属性？检查对象中是否存在属性有三种方法。 第一种使用 in 操作符号： 1234567const o = &#123; &quot;prop&quot; : &quot;bwahahah&quot;, &quot;prop2&quot; : &quot;hweasa&quot;&#125;;console.log(&quot;prop&quot; in o); // trueconsole.log(&quot;prop1&quot; in o); // false 第二种使用 hasOwnProperty 方法，hasOwnProperty() 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键）。 12console.log(o.hasOwnProperty(&quot;prop2&quot;)); // trueconsole.log(o.hasOwnProperty(&quot;prop1&quot;)); // false 第三种使用括号符号obj[&quot;prop&quot;]。如果属性存在，它将返回该属性的值，否则将返回undefined。 12console.log(o[&quot;prop&quot;]); // &quot;bwahahah&quot;console.log(o[&quot;prop1&quot;]); // undefined 60. AJAX 是什么？即异步的 JavaScript 和 XML，是一种用于创建快速动态网页的技术，传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。使用AJAX则不需要加载更新整个网页，实现部分内容更新 用到AJAX的技术： HTML - 网页结构 CSS - 网页的样式 JavaScript - 操作网页的行为和更新DOM XMLHttpRequest API - 用于从服务器发送和获取数据 PHP，Python，Nodejs - 某些服务器端语言 61. 如何在 JS 中创建对象？使用对象字面量： 12345678const o = &#123; name: &quot;前端小智&quot;, greeting() &#123; return `Hi, 我是$&#123;this.name&#125;`; &#125;&#125;;o.greeting(); // &quot;Hi, 我是前端小智&quot; 使用构造函数： 1234567891011function Person(name) &#123; this.name = name;&#125;Person.prototype.greeting = function () &#123; return `Hi, 我是$&#123;this.name&#125;`;&#125;const mark = new Person(&quot;前端小智&quot;);mark.greeting(); // &quot;Hi, 我是前端小智&quot; 使用 Object.create 方法： 12345678const n = &#123; greeting() &#123; return `Hi, 我是$&#123;this.name&#125;`; &#125;&#125;;const o = Object.create(n); o.name = &quot;前端小智&quot;; 62. Object.seal 和 Object.freeze 方法之间有什么区别？Object.freeze() Object.freeze() 方法可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。freeze() 返回和传入的参数相同的对象。 Object.seal() 1Object.seal()方法封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。当前属性的值只要可写就可以改变。 方法的相同点： ES5新增。 对象不可能扩展，也就是不能再添加新的属性或者方法。 对象已有属性不允许被删除。 对象属性特性不可以重新配置。 方法不同点： Object.seal方法生成的密封对象，如果属性是可写的，那么可以修改属性值。* Object.freeze方法生成的冻结对象，属性都是不可写的，也就是属性值无法更改。 63. in 运算符和 Object.hasOwnProperty 方法有什么区别？hasOwnPropert方法 hasOwnPropert()方法返回值是一个布尔值，指示对象自身属性中是否具有指定的属性，因此这个方法会忽略掉那些从原型链上继承到的属性。 看下面的例子： 12345678Object.prototype.phone= &apos;15345025546&apos;;let obj = &#123; name: &apos;前端小智&apos;, age: &apos;28&apos;&#125;console.log(obj.hasOwnProperty(&apos;phone&apos;)) // falseconsole.log(obj.hasOwnProperty(&apos;name&apos;)) // true 可以看到，如果在函数原型上定义一个变量phone，hasOwnProperty方法会直接忽略掉。 in 运算符 如果指定的属性在指定的对象或其原型链中，则in 运算符返回true。 还是用上面的例子来演示： 1console.log(&apos;phone&apos; in obj) // true 可以看到in运算符会检查它或者其原型链是否包含具有指定名称的属性。 64. 有哪些方法可以处理 JS 中的异步代码？ 回调 Promise async/await 还有一些库：async.js, bluebird, q, co 65. 函数表达式和函数声明之间有什么区别？看下面的例子： 12345678910hoistedFunc();notHoistedFunc();function hoistedFunc()&#123; console.log(&quot;注意：我会被提升&quot;);&#125;var notHoistedFunc = function()&#123; console.log(&quot;注意：我没有被提升&quot;);&#125; notHoistedFunc调用抛出异常：Uncaught TypeError: notHoistedFunc is not a function，而hoistedFunc调用不会，因为hoistedFunc会被提升到作用域的顶部，而notHoistedFunc 不会。 66. 调用函数，可以使用哪些方法？在 JS 中有4种方法可以调用函数。 作为函数调用——如果一个函数没有作为方法、构造函数、apply、call 调用时，此时 this 指向的是 window 对象（非严格模式） 123456789101112131415161718//Global Scopefunction add(a,b)&#123; console.log(this); return a + b;&#125; add(1,5); // 打印 &quot;window&quot; 对象和 6const o = &#123; method(callback)&#123; callback(); &#125;&#125;o.method(function ()&#123; console.log(this); // 打印 &quot;window&quot; 对象&#125;); 作为方法调用——如果一个对象的属性有一个函数的值，我们就称它为方法。调用该方法时，该方法的this值指向该对象。 12345678const details = &#123; name : &quot;Marko&quot;, getName()&#123; return this.name; &#125;&#125;details.getName(); // Marko 作为构造函数的调用-如果在函数之前使用new关键字调用了函数，则该函数称为构造函数。构造函数里面会默认创建一个空对象，并将this指向该对象。 1234567891011function Employee(name, position, yearHired) &#123; // 创建一个空对象 &#123;&#125; // 然后将空对象分配给“this”关键字 // this = &#123;&#125;; this.name = name; this.position = position; this.yearHired = yearHired; // 如果没有指定 return ,这里会默认返回 this&#125;;const emp = new Employee(&quot;Marko Polo&quot;, &quot;Software Developer&quot;, 2017); 使用apply和call方法调用——如果我们想显式地指定一个函数的this值，我们可以使用这些方法，这些方法对所有函数都可用。 1234567891011121314151617181920const obj1 = &#123; result:0&#125;;const obj2 = &#123; result:0&#125;;function reduceAdd()&#123; let result = 0; for(let i = 0, len = arguments.length; i &lt; len; i++)&#123; result += arguments[i]; &#125; this.result = result;&#125;reduceAdd.apply(obj1, [1, 2, 3, 4, 5]); // reduceAdd 函数中的 this 对象将是 obj1reduceAdd.call(obj2, 1, 2, 3, 4, 5); // reduceAdd 函数中的 this 对象将是 obj2 67. 什么是缓存及它有什么作用？缓存是建立一个函数的过程，这个函数能够记住之前计算的结果或值。使用缓存函数是为了避免在最后一次使用相同参数的计算中已经执行的函数的计算。这节省了时间，但也有不利的一面，即我们将消耗更多的内存来保存以前的结果。 68. 手动实现缓存方法]123456789101112131415161718192021function memoize(fn) &#123; const cache = &#123;&#125;; return function (param) &#123; if (cache[param]) &#123; console.log(&apos;cached&apos;); return cache[param]; &#125; else &#123; let result = fn(param); cache[param] = result; console.log(`not cached`); return result; &#125; &#125;&#125;const toUpper = (str =&quot;&quot;)=&gt; str.toUpperCase();const toUpperMemoized = memoize(toUpper);toUpperMemoized(&quot;abcdef&quot;);toUpperMemoized(&quot;abcdef&quot;); 这个缓存函数适用于接受一个参数。我们需要改变下，让它接受多个参数。 12345678910111213141516171819202122232425262728const slice = Array.prototype.slice;function memoize(fn) &#123; const cache = &#123;&#125;; return (...args) =&gt; &#123; const params = slice.call(args); console.log(params); if (cache[params]) &#123; console.log(&apos;cached&apos;); return cache[params]; &#125; else &#123; let result = fn(...args); cache[params] = result; console.log(`not cached`); return result; &#125; &#125;&#125;const makeFullName = (fName, lName) =&gt; `$&#123;fName&#125; $&#123;lName&#125;`;const reduceAdd = (numbers, startingValue = 0) =&gt; numbers.reduce((total, cur) =&gt; total + cur, startingValue);const memoizedMakeFullName = memoize(makeFullName);const memoizedReduceAdd = memoize(reduceAdd);memoizedMakeFullName(&quot;Marko&quot;, &quot;Polo&quot;);memoizedMakeFullName(&quot;Marko&quot;, &quot;Polo&quot;);memoizedReduceAdd([1, 2, 3, 4, 5], 5);memoizedReduceAdd([1, 2, 3, 4, 5], 5); 69. 为什么typeof null 返回 object？如何检查一个值是否为 null？typeof null == &#39;object&#39;总是返回true，因为这是自 JS 诞生以来null的实现。曾经有人提出将typeof null == &#39;object&#39;修改为typeof null == &#39;null&#39;，但是被拒绝了，因为这将导致更多的bug。 我们可以使用严格相等运算符===来检查值是否为null。 123function isNull(value)&#123; return value === null;&#125; 70. new 关键字有什么作用？new关键字与构造函数一起使用以创建对象: 1234567function Employee(name, position, yearHired) &#123; this.name = name; this.position = position; this.yearHired = yearHired;&#125;;const emp = new Employee(&quot;Marko Polo&quot;, &quot;Software Developer&quot;, 2017); new关键字做了4件事: 创建空对象 {} 将空对象分配给 this 值 将空对象的**proto**指向构造函数的prototype 如果没有使用显式return语句，则返回this 看下面事例： function Person() { this.name = ‘前端小智’} 根据上面描述的，new Person()做了： 创建一个空对象：var obj = {} 将空对象分配给 this 值：this = obj 将空对象的**proto__指向构造函数的prototype:this.__proto** = Person().prototype 返回this:return this 71. 什么时候不使用箭头函数? 说出三个或更多的例子？不应该使用箭头函数一些情况： 当想要函数被提升时(箭头函数是匿名的) 要在函数中使用this/arguments时，由于箭头函数本身不具有this/arguments，因此它们取决于外部上下文 使用命名函数(箭头函数是匿名的) 使用函数作为构造函数时(箭头函数没有构造函数) 当想在对象字面是以将函数作为属性添加并在其中使用对象时，因为咱们无法访问 this 即对象本身。 72. Object.freeze() 和 const 的区别是什么？]const和Object.freeze是两个完全不同的概念。 const 声明一个只读的变量，一旦声明，常量的值就不可改变： 1234567const person = &#123; name: &quot;Leonardo&quot;&#125;;let animal = &#123; species: &quot;snake&quot;&#125;;person = animal; // ERROR &quot;person&quot; is read-only Object.freeze适用于值，更具体地说，适用于对象值，它使对象不可变，即不能更改其属性。 123456789let person = &#123; name: &quot;Leonardo&quot;&#125;;let animal = &#123; species: &quot;snake&quot;&#125;;Object.freeze(person);person.name = &quot;Lima&quot;; //TypeError: Cannot assign to read only property &apos;name&apos; of objectconsole.log(person); 73. 如何在 JS 中“深冻结”对象？如果咱们想要确保对象被深冻结，就必须创建一个递归函数来冻结对象类型的每个属性： 没有深冻结 123456789let person = &#123; name: &quot;Leonardo&quot;, profession: &#123; name: &quot;developer&quot; &#125;&#125;;Object.freeze(person); person.profession.name = &quot;doctor&quot;;console.log(person); //output &#123; name: &apos;Leonardo&apos;, profession: &#123; name: &apos;doctor&apos; &#125; &#125; 深冻结 1234567891011121314151617function deepFreeze(object) &#123; let propNames = Object.getOwnPropertyNames(object); for (let name of propNames) &#123; let value = object[name]; object[name] = value &amp;&amp; typeof value === &quot;object&quot; ? deepFreeze(value) : value; &#125; return Object.freeze(object);&#125;let person = &#123; name: &quot;Leonardo&quot;, profession: &#123; name: &quot;developer&quot; &#125;&#125;;deepFreeze(person);person.profession.name = &quot;doctor&quot;; // TypeError: Cannot assign to read only property &apos;name&apos; of object 74. Iterator是什么，有什么作用？遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。 Iterator 的作用有三个： 为各种数据结构，提供一个统一的、简便的访问接口； 使得数据结构的成员能够按某种次序排列； ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费。 遍历过程： 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。 第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。 第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。 不断调用指针对象的next方法，直到它指向数据结构的结束位置。 每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。 123456789101112131415161718192021//obj就是可遍历的，因为它遵循了Iterator标准，且包含[Symbol.iterator]方法，方法函数也符合标准的Iterator接口规范。//obj.[Symbol.iterator]() 就是Iterator遍历器let obj = &#123; data: [ &apos;hello&apos;, &apos;world&apos; ], [Symbol.iterator]() &#123; const self = this; let index = 0; return &#123; next() &#123; if (index &lt; self.data.length) &#123; return &#123; value: self.data[index++], done: false &#125;; &#125; else &#123; return &#123; value: undefined, done: true &#125;; &#125; &#125; &#125;; &#125;&#125;; 75. Generator 函数是什么，有什么作用？如果说 JavaScrip 是 ECMAScript 标准的一种具体实现、Iterator遍历器是Iterator的具体实现，那么Generator函数可以说是Iterator接口的具体实现方式。 执行Generator函数会返回一个遍历器对象，每一次Generator函数里面的yield都相当一次遍历器对象的next()方法，并且可以通过next(value)方法传入自定义的value,来改变Generator函数的行为。 Generator函数可以通过配合Thunk 函数更轻松更优雅的实现异步编程和控制流管理。 1. new的实现原理是什么？new 的实现原理: 创建一个空对象，构造函数中的this指向这个空对象 这个新对象被执行 [[原型]] 连接 执行构造函数方法，属性和方法被添加到this引用的对象中 如果构造函数中没有返回其它对象，那么返回this，即创建的这个的新对象，否则，返回构造函数中返回的对象。 图片 2. 如何正确判断this的指向？如果用一句话说明 this 的指向，那么即是: 谁调用它，this 就指向谁。 但是仅通过这句话，我们很多时候并不能准确判断 this 的指向。因此我们需要借助一些规则去帮助自己： this 的指向可以按照以下顺序判断: 全局环境中的 this浏览器环境：无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象 window; node 环境：无论是否在严格模式下，在全局执行环境中（在任何函数体外部），this 都是空对象 {}; 是否是 new 绑定如果是 new 绑定，并且构造函数中没有返回 function 或者是 object，那么 this 指向这个新对象。如下: 构造函数返回值不是 function 或 object。 newSuper() 返回的是 this 对象。 图片 构造函数返回值是 function 或 object， newSuper()是返回的是Super种返回的对象。 图片 函数是否通过 call,apply 调用，或者使用了 bind 绑定，如果是，那么this绑定的就是指定的对象【归结为显式绑定】。 图片 这里同样需要注意一种特殊情况，如果 call,apply 或者 bind 传入的第一个参数值是 undefined或者 null，严格模式下 this 的值为传入的值 null /undefined。非严格模式下，实际应用的默认绑定规则，this 指向全局对象(node环境为global，浏览器环境为window) 图片 隐式绑定，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的隐式调用为: xxx.fn() 图片 默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用。非严格模式：node环境，执行全局对象 global，浏览器环境，执行全局对象 window。 严格模式：执行 undefined 图片 箭头函数的情况：箭头函数没有自己的this，继承外层上下文绑定的this。 图片 3. 深拷贝和浅拷贝的区别是什么？实现一个深拷贝深拷贝和浅拷贝是针对复杂数据类型来说的，浅拷贝只拷贝一层，而深拷贝是层层拷贝。 深拷贝 深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。 浅拷贝 浅拷贝是会将对象的每个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。 可以使用 forin、 Object.assign、 扩展运算符 ... 、 Array.prototype.slice()、 Array.prototype.concat() 等，例如: 图片 可以看出浅拷贝只最第一层属性进行了拷贝，当第一层的属性值是基本数据类型时，新的对象和原对象互不影响，但是如果第一层的属性值是复杂数据类型，那么新对象和原对象的属性值其指向的是同一块内存地址。 深拷贝实现 1.深拷贝最简单的实现是: JSON.parse(JSON.stringify(obj)) JSON.parse(JSON.stringify(obj)) 是最简单的实现方式，但是有一些缺陷： 对象的属性值是函数时，无法拷贝。 原型链上的属性无法拷贝 不能正确的处理 Date 类型的数据 不能处理 RegExp 会忽略 symbol 会忽略 undefined 2.实现一个 deepClone 函数 如果是基本数据类型，直接返回 如果是 RegExp 或者 Date 类型，返回对应类型 如果是复杂数据类型，递归。 考虑循环引用的问题 图片 4. call/apply 的实现原理是什么？call 和 apply 的功能相同，都是改变 this 的执行，并立即执行函数。区别在于传参方式不同。 func.call(thisArg,arg1,arg2,...)：第一个参数是 this 指向的对象，其它参数依次传入。 func.apply(thisArg,[argsArray])：第一个参数是 this 指向的对象，第二个参数是数组或类数组。 一起思考一下，如何模拟实现 call ？ 首先，我们知道，函数都可以调用 call，说明 call 是函数原型上的方法，所有的实例都可以调用。即: Function.prototype.call。 在 call 方法中获取调用 call()函数 如果第一个参数没有传入，那么默认指向 window/global(非严格模式) 传入 call 的第一个参数是 this 指向的对象，根据隐式绑定的规则，我们知道 obj.foo(), foo() 中的 this 指向 obj;因此我们可以这样调用函数 thisArgs.func(...args) 返回执行结果 图片 apply 的实现思路和 call 一致，仅参数处理略有差别。如下： 图片 5. 柯里化函数实现在开始之前，我们首先需要搞清楚函数柯里化的概念。 函数柯里化是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。 图片 图片 函数柯里化的主要作用： 参数复用 提前返回 – 返回接受余下的参数且返回结果的新函数 延迟执行 – 返回新函数，等待执行 6. 如何让 (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) 的值为true？ 利用隐式类型转换 == 操作符在左右数据类型不一致时，会先进行隐式转换。 a==1&amp;&amp;a==2&amp;&amp;a==3 的值意味着其不可能是基本数据类型。因为如果 a 是 null 或者是 undefined bool类型，都不可能返回true。 因此可以推测 a 是复杂数据类型，JS 中复杂数据类型只有 object，回忆一下，Object 转换为原始类型会调用什么方法？ 如果部署了 [Symbol.toPrimitive] 接口，那么调用此接口，若返回的不是基本数据类型，抛出错误。 如果没有部署 [Symbol.toPrimitive] 接口，那么根据要转换的类型，先调用 valueOf / toString 非Date类型对象， hint 是 default 时，调用顺序为： valueOf &gt;&gt;&gt; toString，即 valueOf 返回的不是基本数据类型，才会继续调用 valueOf，如果 toString 返回的还不是基本数据类型，那么抛出错误。 如果 hint 是 string(Date对象的hint默认是string) ，调用顺序为： toString &gt;&gt;&gt; valueOf，即 toString 返回的不是基本数据类型，才会继续调用 valueOf，如果 valueOf 返回的还不是基本数据类型，那么抛出错误。 如果 hint 是 number，调用顺序为： valueOf &gt;&gt;&gt; toString 图片 利用数据劫持(Proxy/Object.definedProperty) 图片 数组的 toString 接口默认调用数组的 join 方法，重新 join 方法 图片 7. 什么是BFC？BFC的布局规则是什么？如何创建BFC？Box 是 CSS 布局的对象和基本单位，页面是由若干个Box组成的。 元素的类型 和 display 属性，决定了这个 Box 的类型。不同类型的 Box 会参与不同的 Formatting Context。 Formatting Context Formatting Context 是页面的一块渲染区域，并且有一套渲染规则，决定了其子元素将如何定位，以及和其它元素的关系和相互作用。 Formatting Context 有 BFC (Block formatting context)，IFC (Inline formatting context)，FFC (Flex formatting context) 和 GFC (Grid formatting context)。FFC 和 GFC 为 CC3 中新增。 BFC布局规则 BFC内，盒子依次垂直排列。 BFC内，两个盒子的垂直距离由 margin 属性决定。属于同一个BFC的两个相邻Box的margin会发生重叠【符合合并原则的margin合并后是使用大的margin】 BFC内，每个盒子的左外边缘接触内部盒子的左边缘（对于从右到左的格式，右边缘接触）。即使在存在浮动的情况下也是如此。除非创建新的BFC。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算。 如何创建BFC 根元素 浮动元素（float 属性不为 none） position 为 absolute 或 fixed overflow 不为 visible 的块元素 display 为 inline-block, table-cell, table-caption BFC 的应用 防止 margin 重叠 (同一个BFC内的两个两个相邻Box的 margin 会发生重叠，触发生成两个BFC，即不会重叠) 清除内部浮动 (创建一个新的 BFC，因为根据 BFC 的规则，计算 BFC 的高度时，浮动元素也参与计算) 自适应多栏布局 (BFC的区域不会与float box重叠。因此，可以触发生成一个新的BFC) 8. 异步加载JS脚本的方式有哪些？ 标签中增加 async(html5) 或者 defer(html4) 属性,脚本就会异步加载。 1&lt;scriptsrc=&quot;../XXX.js&quot;defer&gt;&lt;/script&gt; `defer` 和 `async` 的区别在于： - `defer` 要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），在window.onload 之前执行； - `async` 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。 - 如果有多个 `defer` 脚本，会按照它们在页面出现的顺序加载 - 多个 `async` 脚本不能保证加载顺序 > 动态创建 `script` 标签 动态创建的 `script` ，设置 `src` 并不会开始下载，而是要添加到文档中，JS文件才会开始下载。 图片 > XHR 异步加载JS 图片 ### 9. ES5有几种方式可以实现继承？分别有哪些优缺点？ ES5 有 6 种方式可以实现继承，分别为： ##### 1. 原型链继承 原型链继承的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。 图片 > 缺点： 1. 通过原型来实现继承时，原型会变成另一个类型的实例，原先的实例属性变成了现在的原型属性，该原型的引用类型属性会被所有的实例共享。 2. 在创建子类型的实例时，没有办法在不影响所有对象实例的情况下给超类型的构造函数中传递参数。 ##### 2. 借用构造函数 **借用构造函数**的技术，其基本思想为: 在子类型的构造函数中调用超类型构造函数。 图片 > 优点: 1. 可以向超类传递参数 2. 解决了原型中包含引用类型值被所有实例共享的问题 > 缺点: 1. 方法都在构造函数中定义，函数复用无从谈起，另外超类型原型中定义的方法对于子类型而言都是不可见的。 ##### 3. 组合继承(原型链 + 借用构造函数) 组合继承指的是将原型链和借用构造函数技术组合到一块，从而发挥二者之长的一种继承模式。基本思路： 使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承，既通过在原型上定义方法来实现了函数复用，又保证了每个实例都有自己的属性。 图片 > 缺点: - 无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。 > 优点: - 可以向超类传递参数 - 每个实例都有自己的属性 - 实现了函数复用 ##### 4. 原型式继承 原型继承的基本思想： 借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。 图片 在 `object()` 函数内部，先穿甲一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例，从本质上讲， `object()` 对传入的对象执行了一次浅拷贝。 ECMAScript5通过新增 `Object.create()`方法规范了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象(可以覆盖原型对象上的同名属性)，在传入一个参数的情况下， `Object.create()` 和 `object()` 方法的行为相同。 图片 在没有必要创建构造函数，仅让一个对象与另一个对象保持相似的情况下，原型式继承是可以胜任的。 > 缺点: 同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。 ##### 5. 寄生式继承 寄生式继承是与原型式继承紧密相关的一种思路。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部已某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。 图片 基于 `person` 返回了一个新对象 -—— `person2`，新对象不仅具有 `person` 的所有属性和方法，而且还有自己的 `sayHi()` 方法。在考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。 > 缺点： - 使用寄生式继承来为对象添加函数，会由于不能做到函数复用而效率低下。 - 同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。 ##### 6. 寄生组合式继承 所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法，基本思路： 不必为了指定子类型的原型而调用超类型的构造函数，我们需要的仅是超类型原型的一个副本，本质上就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。寄生组合式继承的基本模式如下所示： 图片 - 第一步：创建超类型原型的一个副本 - 第二步：为创建的副本添加 `constructor` 属性 - 第三步：将新创建的对象赋值给子类型的原型 至此，我们就可以通过调用 `inheritPrototype` 来替换为子类型原型赋值的语句： 图片 > 优点: 只调用了一次超类构造函数，效率更高。避免在 `SuberType.prototype`上面创建不必要的、多余的属性，与其同时，原型链还能保持不变。 因此寄生组合继承是引用类型最理性的继承范式。 ### 10. 隐藏页面中的某个元素的方法有哪些？ > 隐藏类型 屏幕并不是唯一的输出机制，比如说屏幕上看不见的元素（隐藏的元素），其中一些依然能够被读屏软件阅读出来（因为读屏软件依赖于可访问性树来阐述）。为了消除它们之间的歧义，我们将其归为三大类： - 完全隐藏：元素从渲染树中消失，不占据空间。 - 视觉上的隐藏：屏幕中不可见，占据空间。 - 语义上的隐藏：读屏软件不可读，但正常占据空。 > 完全隐藏 ##### 1. `display` 属性 1display: none; ##### 2.hidden 属性 HTML5 新增属性，相当于 `display:none` 1&lt;div hidden&gt;&lt;/div&gt; > 视觉上的隐藏 ##### 1.利用 `position` 和 盒模型 将元素移出可视区范围 1. 设置 `posoition` 为 `absolute` 或 `fixed`，通过设置 `top`、 `left` 等值，将其移出可视区域。 1position:absolute;left: -99999px; 1. 设置 `position` 为 `relative`，通过设置 `top`、 `left` 等值，将其移出可视区域。 1position: relative;left: -99999px;height: 0 1. 设置 margin 值，将其移出可视区域范围（可视区域占位）。 1margin-left: -99999px;height: 0; ##### 2.利用 transfrom 1. 缩放 1transform: scale(0);height: 0; 1. 移动 `translateX`, `translateY` 1transform: translateX(-99999px);height: 0 1. 旋转 `rotate` 1transform: rotateY(90deg); ##### 3.设置其大小为0 1. 宽高为0，字体大小为0： 1height: 0;width: 0;font-size: 0; 1. 宽高为0，超出隐藏: 1height: 0;width: 0;overflow: hidden; ##### 4.设置透明度为0 1opacity: 0; ##### 5. `visibility`属性 1visibility: hidden; ##### 6.层级覆盖， `z-index` 属性 1position: relative;z-index: -999; 再设置一个层级较高的元素覆盖在此元素上。 ##### 7.clip-path 裁剪 1clip-path: polygon(0 0, 0 0, 0 0, 0 0); > 语义上的隐藏 ##### aria-hidden 属性 读屏软件不可读，占据空间，可见。 1&lt;div aria-hidden=&quot;true&quot;&gt;&lt;/div&gt; ### 11. let、const、var 的区别有哪些？ 图片 1.let/const 定义的变量不会出现变量提升，而 var 定义的变量会提升。 2.相同作用域中，let 和 const 不允许重复声明，var 允许重复声明。 3.const 声明变量时必须设置初始值 4.const 声明一个只读的常量，这个常量不可改变。 这里有一个非常重要的点即是：在JS中，复杂数据类型，存储在栈中的是堆内存的地址，存在栈中的这个地址是不变的，但是存在堆中的值是可以变得。有没有相当常量指针/指针常量~ 图片 一图胜万言，如下图所示，不变的是栈内存中 a 存储的 20，和 b 中存储的 0x0012ff21（瞎编的一个数字）。而 {age: 18, star: 200} 是可变的。 图片 ### 12. 说一说你对JS执行上下文栈和作用域链的理解？ 在开始说明JS上下文栈和作用域之前，我们先说明下JS上下文以及作用域的概念。 #### JS执行上下文 执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。 > 执行上下文类型分为： - 全局执行上下文 - 函数执行上下文 执行上下文创建过程中，需要做以下几件事: 1. 创建变量对象：首先初始化函数的参数arguments，提升函数声明和变量声明。 2. 创建作用域链（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。 3. 确定this的值，即 ResolveThisBinding #### 作用域 **作用域**负责收集和维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。—— 摘录自《你不知道的JavaScript》(上卷) 作用域有两种工作模型：词法作用域和动态作用域，JS采用的是**词法作用域**工作模型，词法作用域意味着作用域是由书写代码时变量和函数声明的位置决定的。( `with` 和 `eval` 能够修改词法作用域，但是不推荐使用，对此不做特别说明) > 作用域分为： - 全局作用域 - 函数作用域 - 块级作用域 #### JS执行上下文栈(后面简称执行栈) 执行栈，也叫做调用栈，具有 **LIFO** (后进先出) 结构，用于存储在代码执行期间创建的所有执行上下文。 > 规则如下： - 首次运行JavaScript代码的时候,会创建一个全局执行的上下文并Push到当前的执行栈中，每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push当前执行栈的栈顶。 - 当栈顶的函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文的控制权将移动到当前执行栈的下一个执行上下文。 以一段代码具体说明： 图片 `GlobalExecutionContext` (即全局执行上下文)首先入栈，过程如下： 图片 伪代码: 12345678//全局执行上下文首先入栈ECStack.push(globalContext);//执行fun1();ECStack.push(&lt;fun1&gt; functionContext);//fun1中又调用了fun2;ECStack.push(&lt;fun2&gt; functionContext);//fun2中又调用了fun3;ECStack.push(&lt;fun3&gt; functionContext);//fun3执行完毕ECStack.pop();//fun2执行完毕ECStack.pop();//fun1执行完毕ECStack.pop();//javascript继续顺序执行下面的代码，但ECStack底部始终有一个 全局上下文（globalContext）; #### 作用域链 作用域链就是从当前作用域开始一层一层向上寻找某个变量，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链。 如： 图片 fn2作用域链 = [fn2作用域, fn1作用域，全局作用域] 图片 ### 13. 防抖函数的作用是什么？请实现一个防抖函数 > 防抖函数的作用 防抖函数的作用就是控制函数在一定时间内的执行次数。防抖意味着N秒内函数只会被执行一次，如果N秒内再次被触发，则**重新**计算延迟时间。 **举例说明：** 小思最近在减肥，但是她非常吃吃零食。为此，与其男朋友约定好，如果10天不吃零食，就可以购买一个包(不要问为什么是包，因为**包治百病**)。但是如果中间吃了一次零食，那么就要重新计算时间，直到小思坚持10天没有吃零食，才能购买一个包。所以，管不住嘴的小思，没有机会买包(悲伤的故事)... 这就是 **防抖**。 > 防抖函数实现 1. 事件第一次触发时， `timer` 是 `null`，调用 `later()`，若 `immediate` 为 `true`，那么立即调用 `func.apply(this,params)`；如果 `immediate` 为 `false`，那么过 `wait` 之后，调用 `func.apply(this,params)` 2. 事件第二次触发时，如果 `timer` 已经重置为 `null`(即 `setTimeout` 的倒计时结束)，那么流程与第一次触发时一样，若 `timer` 不为 `null`(即 setTimeout 的倒计时未结束)，那么清空定时器，重新开始计时。 图片 `immediate` 为 true 时，表示函数在每个等待时延的开始被调用。 `immediate` 为 false 时，表示函数在每个等待时延的结束被调用。 > 防抖的应用场景 1. 搜索框输入查询，如果用户一直在输入中，没有必要不停地调用去请求服务端接口，等用户停止输入的时候，再调用，设置一个合适的时间间隔，有效减轻服务端压力。 2. 表单验证 3. 按钮提交事件。 4. 浏览器窗口缩放，resize事件(如窗口停止改变大小之后重新计算布局)等。 ### 14. 节流函数的作用是什么？有哪些应用场景，请实现一个节流函数 > 节流函数的作用 节流函数的作用是规定一个单位时间，在这个单位时间内最多只能触发一次函数执行，如果这个单位时间内多次触发函数，只能有一次生效。 > 节流函数实现 图片 禁用第一次首先执行，传递 `{leading:false}` ；想禁用最后一次执行，传递 `{trailing:false}` > 节流的应用场景 1. 按钮点击事件 2. 拖拽事件 3. onScoll 4. 计算鼠标移动的距离(mousemove) ### 15. 什么是闭包？闭包的作用是什么？ ##### 闭包的定义 《JavaScript高级程序设计》: > 闭包是指有权访问另一个函数作用域中的变量的函数 《JavaScript权威指南》： > 从技术的角度讲，所有的JavaScript函数都是闭包：它们都是对象，它们都关联到作用域链。 《你不知道的JavaScript》 > 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 ##### 创建一个闭包 图片 闭包使得函数可以继续访问定义时的词法作用域。拜 fn 所赐，在 foo() 执行后，foo 内部作用域不会被销毁。 ##### 闭包的作用 - 能够访问函数定义时所在的词法作用域(阻止其被回收)。 - 私有化变量 图片 - 模拟块级作用域 图片 - 创建模块 图片 模块模式具有两个必备的条件(来自《你不知道的JavaScript》) - 必须有外部的封闭函数，该函数必须至少被调用一次(每次调用都会创建一个新的模块实例) - 封闭函数必须返回至少**一个**内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。 ### 16. 实现 Promise.all 方法 在实现 Promise.all 方法之前，我们首先要知道 Promise.all 的功能和特点，因为在清楚了 Promise.all 功能和特点的情况下，我们才能进一步去写实现。 > Promise.all 功能 `Promise.all(iterable)` 返回一个新的 Promise 实例。此实例在 `iterable` 参数内所有的 `promise` 都 `fulfilled` 或者参数中不包含 `promise` 时，状态变成 `fulfilled`；如果参数中 `promise` 有一个失败 `rejected`，此实例回调失败，失败原因的是第一个失败 `promise` 的返回结果。 1let p = Promise.all([p1, p2, p3]); p的状态由 p1,p2,p3决定，分成以下；两种情况： （1）只有p1、p2、p3的状态都变成 `fulfilled`，p的状态才会变成 `fulfilled`，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 （2）只要p1、p2、p3之中有一个被 `rejected`，p的状态就变成 `rejected`，此时第一个被reject的实例的返回值，会传递给p的回调函数。 > Promise.all 的特点 Promise.all 的返回值是一个 promise 实例 - 如果传入的参数为空的可迭代对象， `Promise.all` 会 **同步** 返回一个已完成状态的 `promise` - 如果传入的参数中不包含任何 promise, `Promise.all` 会 **异步** 返回一个已完成状态的 `promise` - 其它情况下， `Promise.all` 返回一个 **处理中（pending）** 状态的 `promise`. > Promise.all 返回的 promise 的状态 - 如果传入的参数中的 promise 都变成完成状态， `Promise.all` 返回的 `promise` 异步地变为完成。 - 如果传入的参数中，有一个 `promise` 失败， `Promise.all` 异步地将失败的那个结果给失败状态的回调函数，而不管其它 `promise` 是否完成 - 在任何情况下， `Promise.all` 返回的 `promise` 的完成状态的结果都是一个数组 > Promise.all 实现 图片 ### 17. 请实现一个 flattenDeep 函数，把嵌套的数组扁平化 例如: 1flattenDeep([1, [2, [3, [4]], 5]]); //[1, 2, 3, 4, 5] > 利用 Array.prototype.flat ES6 为数组实例新增了 `flat` 方法，用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数组没有影响。 `flat` 默认只会 “拉平” 一层，如果想要 “拉平” 多层的嵌套数组，需要给 `flat` 传递一个整数，表示想要拉平的层数。 图片 当传递的整数大于数组嵌套的层数时，会将数组拉平为一维数组，JS能表示的最大数字为 `Math.pow(2,53)-1`，因此我们可以这样定义 `flattenDeep` 函数 图片 > 利用 reduce 和 concat 图片 > 使用 stack 无限反嵌套多层嵌套数组 图片 ### 18. 请实现一个 uniq 函数，实现数组去重 例如: 1uniq([1, 2, 3, 5, 3, 2]);//[1, 2, 3, 5] > 法1: 利用ES6新增数据类型 `Set` `Set`类似于数组，但是成员的值都是唯一的，没有重复的值。 图片 > 法2: 利用 `indexOf` 图片 > 法3: 利用 `includes` 图片 > 法4：利用 `reduce` 图片 > 法5：利用 `Map` 图片 ### 19. 可迭代对象有哪些特点 ES6 规定，默认的 `Iterator` 接口部署在数据结构的 `Symbol.iterator` 属性，换个角度，也可以认为，一个数据结构只要具有 `Symbol.iterator` 属性( `Symbol.iterator` 方法对应的是遍历器生成函数，返回的是一个遍历器对象)，那么就可以其认为是可迭代的。 #### 可迭代对象的特点 - 具有 `Symbol.iterator` 属性， `Symbol.iterator()` 返回的是一个遍历器对象 - 可以使用 `for...of` 进行循环 - 通过被 `Array.from` 转换为数组 图片 #### 原生具有 `Iterator` 接口的数据结构： - Array - Map - Set - String - TypedArray - 函数的 arguments 对象 - NodeList 对象 ### 20. JSONP 的原理是什么？ 尽管浏览器有同源策略，但是 `` 标签的 `src` 属性不会被同源策略所约束，可以获取任意服务器上的脚本并执行。 `jsonp` 通过插入 `script` 标签的方式来实现跨域，参数只能通过 `url` 传入，仅能支持 `get` 请求。 > 实现原理: - Step1: 创建 callback 方法 - Step2: 插入 script 标签 - Step3: 后台接受到请求，解析前端传过去的 callback 方法，返回该方法的调用，并且数据作为参数传入该方法 - Step4: 前端执行服务端返回的方法调用 > jsonp源码实现 图片 > 使用: 图片 > 服务端代码(node): 图片","categories":[{"name":"前端面试题","slug":"前端面试题","permalink":"https://qw8.github.io/categories/前端面试题/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qw8.github.io/tags/JavaScript/"},{"name":"BOM","slug":"BOM","permalink":"https://qw8.github.io/tags/BOM/"},{"name":"DOM","slug":"DOM","permalink":"https://qw8.github.io/tags/DOM/"}]},{"title":"JavaScript闭包","slug":"knowledges/JavaScript闭包","date":"2020-06-09T12:50:00.000Z","updated":"2023-04-14T17:01:50.000Z","comments":true,"path":"/knowledges/javascript-bi-bao.html","link":"","permalink":"https://qw8.github.io/knowledges/javascript-bi-bao.html","excerpt":"","text":"说说你对闭包的理解（什么是闭包（closure），为什么要用它？）使用闭包主要是为了设计私有的方法和变量。闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量，利用闭包可以突破作用链域。在js中，函数即闭包，只有函数才会产生作用域的概念。 闭包有三个特性： 函数内再嵌套函数 函数内部可以引用外部的参数和变量 参数和变量不会被垃圾回收机制回收 优点： 希望一个变量长期存储在内存中。 避免全局变量的污染。 私有成员的存在。 缺点： 常驻内存，会增大内存使用量。 使用不当会很容易造成内存泄露。 示例： 12345678function outer() &#123; var name = \"jack\"; function inner() &#123; console.log(name); &#125; return inner;&#125;outer()(); // jack 1234567function sayHi(name) &#123; return () =&gt; &#123; console.log(`Hi! $&#123;name&#125;`); &#125;;&#125;const test = sayHi(\"xiaoming\");test(); // Hi! xiaoming 虽然 sayHi 函数已经执行完毕，但是其活动对象也不会被销毁，因为 test 函数仍然引用着 sayHi 函数中的变量 name，这就是闭包。但也因为闭包引用着另一个函数的变量，导致另一个函数已经不使用了也无法销毁，所以闭包使用过多，会占用较多的内存，这也是一个副作用。 解析： 由于在 ECMA2015 中，只有函数才能分割作用域，函数内部可以访问当前作用域的变量，但是外部无法访问函数内部的变量，所以闭包可以理解成“定义在一个函数内部的函数，外部可以通过内部返回的函数访问内部函数的变量“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。 闭包的优缺点定义：函数A返回了一个函数B，函数B中使用了函数A的变量，且函数B在外部环境中执行，就产生了一个闭包。简单理解闭包其实就是等于一个函数+局部变量，实际使用过程中主要用来封装变量。 优点：1.可以访问到函数内部的局部变量， 2.可以避免全局变量的污染， 3.这些变量的值始终保持在内存中，不会在外层函数调用后被自动清除。 缺点：1.会增大内存使用量 2.滥用闭包会影响性能，导致内存泄漏等问题。 解决方法：在退出函数之前，将不使用的局部变量全部删除 12345678910function fn()&#123; let a=1; return function()&#123; console.log(a) &#125;&#125;var fn2=fn();fn2();fn2(); 内存泄漏：某些变量、函数等不再需要占用内存的时候，由于某些原因，内存没有被回收。 变量始终存在的原因：虽然函数A已经弹出了调用栈，JS引擎会通过逃逸分析将函数A中的变量存储在堆上，函数B访问的是堆上的变量值。 闭包（参考链接）闭包是代码块和创建该代码块的上下文中数据的结合。 闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。（红宝书P178）。 例子1： 1234567[1, 2, 3].sort(function(a, b) &#123; // 排序条件&#125;);[1, 2, 3].map(function (element) &#123; return element * 2;&#125;); // [2, 4, 6] 例子2-延迟调用： 1234567var a = 10;setTimeout(function () &#123; alert(a); // 10, after one second&#125;, 1000); 例子3-回调函数： 12345678910111213var x = 10;xmlHttpRequestObject.onreadystatechange =function() &#123;// 当数据就绪的时候，才会调用;// 这里，不论是在哪个上下文中创建// 此时变量“x”的值已经存在了 alert(x);// 10&#125;; 例子4-隐藏辅助对象： 1234567891011121314151617varfoo = &#123;&#125;;// 初始化(function(object) &#123; var x = 10; object.getX =function_getX() &#123; return x; &#125;;&#125;)(foo);alert(foo.getX());// 获得闭包 &quot;x&quot; – 10 闭包由来JavaScript 变量JavaScript 变量可以是局部变量或全局变量。 全局变量：作用域是全局性的，可应用于页面上的所有脚本，在web页面中全局变量属于 window 对象。 局部变量：在函数内部声明的变量，只在函数内部起作用，作用域是局部性的；函数的参数也是局部性的，只在函数内部起作用。 全局和局部变量即便名称相同，它们也是两个不同的变量。修改其中一个，不会影响另一个的值。私有变量可以用到闭包。 计数器困境设想下如果你想统计一些数值，且该计数器在所有函数中都是可用的。你可以使用全局变量，函数设置计数器递增： 1234567891011var counter = 0; function add() &#123; return counter += 1;&#125; add();add();add(); // 计数器现在为 3 计数器数值在执行 add() 函数时发生变化。 但问题来了，页面上的任何脚本都能改变计数器，即便没有调用 add() 函数。 如果我在函数内声明计数器，如果没有调用函数将无法修改计数器的值：12345678910function add() &#123; var counter = 0; return counter += 1;&#125; add();add();add(); // 本意是想输出 3, 但事与愿违，输出的都是 1 以上代码将无法正确输出，每次我调用 add() 函数，计数器都会设置为 1。 JavaScript 内嵌函数可以解决该问题。 JavaScript 内嵌函数所有函数都能访问全局变量。 实际上，在 JavaScript 中，所有函数都能访问它们上一层的作用域。 JavaScript 支持嵌套函数。嵌套函数可以访问上一层的函数变量。 内嵌函数 plus() 可以访问父函数的 counter 变量：123456function add() &#123; var counter = 0; function plus() &#123;counter += 1;&#125; plus(); return counter; &#125; 如果我们能在外部访问 plus() 函数，这样就能解决计数器的困境。 我们同样需要确保 counter = 0只执行一次。 我们需要闭包。 JavaScript 闭包还记得函数自我调用吗？该函数会做什么？ 12345678910var add = (function () &#123; var counter = 0; return function () &#123;return counter += 1;&#125;&#125;)(); add();add();add(); // 计数器为 3 变量 add 指定了函数自我调用的返回字值。 自我调用函数只执行一次。设置计数器为 0。并返回函数表达式。 add变量可以作为一个函数使用。非常棒的部分是它可以访问函数上一层作用域的计数器。 这个叫作 JavaScript 闭包。它使得函数拥有私有变量变成可能。 计数器受匿名函数的作用域保护，只能通过 add 方法修改。 闭包是一种保护私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不受外界干扰。直观的说就是形成一个不销毁的栈环境。","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qw8.github.io/tags/JavaScript/"},{"name":"闭包","slug":"闭包","permalink":"https://qw8.github.io/tags/闭包/"}]},{"title":"JavaScript难题","slug":"interview/JavaScript难题","date":"2020-05-29T02:41:39.000Z","updated":"2024-02-18T03:11:22.000Z","comments":true,"path":"/interview/javascript-nan-ti.html","link":"","permalink":"https://qw8.github.io/interview/javascript-nan-ti.html","excerpt":"","text":"国外某网站给出了44道JS难题，试着做了下，只做对了17道。这些题涉及面非常广，涵盖JS原型、函数细节、强制转换、闭包等知识，而且都是非常细节的东西，透过这些小细节可以折射出很多高级的JS知识点。 你可以通过传送门先去测试一下你的水平，然后回来看看我的解析。为了详细解释这些细节，我也查阅了不少资料，弥补了很多JS知识盲点。 1. parseInt 遇上 map123456[\"1\", \"2\", \"3\"].map(parseInt)// A. [\"1\", \"2\", \"3\"]// B. [1, 2, 3]// C. [0, 1, 2]// D. other 答案是D。实际上返回的结果是 [1, NaN, NaN] ，因为 parseInt 函数只需要两个参数 parseInt(value, radix) ，而 map 的回调函数需要三个参数 callback(currentValue, index, array)。MDN文档中指明 parseInt 第二个参数是一个2到36之间的整数值，用于指定转换中采用的基数。如果省略该参数或其值为0，则数字将以10为基础来解析。如果该参数小于2或者大于36，则 parseInt 返回 NaN。此外，转换失败也会返回 NaN。 现在来分析问题。parseInt(&quot;1&quot;, 0) 的结果是当作十进制来解析，返回 1；parseInt(&quot;2&quot;, 1) 的第二个参数非法，返回 NaN；parseInt(&quot;3&quot;, 2) 在二进制中，&quot;3&quot; 是非法字符，转换失败，返回 NaN。 参考资料： MDN: Array.prototype.map() MDN: parseInt 2. 神奇的null123456[typeof null, null instanceof Object]// A. [\"object\", false]// B. [null, false]// C. [\"object\", true]// D. other 答案是A。在MDN关于 null 的文档中也特别指出来了，typeof null 的结果是 &quot;object&quot;，它是ECMAScript的bug，其实应该是 &quot;null&quot;。但这个bug由来已久，在JavaScript中已经存在了将近二十年，也许永远不会修复，因为这牵扯到太多的Web系统，修复它会产生更多的bug，令许多系统无法正常工作。而 instanceof 运算符是用来测试一个对象在其原型链构造函数上是否具有 prototype 属性，null 值并不是以 Object 原型创建出来的，所以 null instanceof Object 返回 false。 参考资料： MDN：null MDN：instanceof CSDN博客：null instanceof Object 求解？ 3. 愤怒的reduce123456[ [3,2,1].reduce(Math.pow), [].reduce(Math.pow) ]// A. an error// B. [9, 0]// C. [9, NaN]// D. [9, undefined] 答案是A。MDN文档中关于 Array.prototype.reduce() 写得很清楚： 如果数组为空并且没有提供initialValue， 会抛出TypeError 。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue， 或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。 参考资料： MDN：Array.prototype.reduce() 4. 该死的优先级1234567var val = 'smtg';console.log('Value is ' + (val === 'smtg') ? 'Something' : 'Nothing');// A. Value is Something// B. Value is Nothing// C. NaN// D. other 答案是D。实际上输出 &quot;Something&quot;，因为 + 的优先级比条件运算符 condition ? val1 : val2 的优先级高。 参考资料： MDN：运算符优先级 5. 神鬼莫测之变量提升1234567891011121314var name = 'World!';(function () &#123; if (typeof name === 'undefined') &#123; var name = 'Jack'; console.log('Goodbye ' + name); &#125; else &#123; console.log('Hello ' + name); &#125;&#125;)();// A. Goodbye Jack// B. Hello Jack// C. Hello undefined// D. Hello World 答案是A。看如下MDN官方文档的解释： 在 JavaScript中， functions 和 variables 会被提升。变量提升是JavaScript将声明移至作用域 scope (全局域或者当前函数作用域) 顶部的行为。 这意味着你可以在声明一个函数或变量之前引用它，或者可以说：一个变量或函数可以在它被引用之后声明。 所以，上面的代码与下面这段代码是等价的： 12345678910var name = 'World!';(function () &#123; var name; if (typeof name === 'undefined') &#123; name = 'Jack'; console.log('Goodbye ' + name); &#125; else &#123; console.log('Hello ' + name); &#125;&#125;)(); 参考资料： MDN：变量提升 这篇博客解释的比较详细：js变量提升 6. 死循环陷阱123456789101112var END = Math.pow(2, 53);var START = END - 100;var count = 0;for (var i = START; i &lt;= END; i++) &#123; count++;&#125;console.log(count);// A. 0// B. 100// C. 101// D. other 答案是D。在JavaScript中，2^53 是最大的值，没有比这更大的值了。所以 2^53 + 1 == 2^53，所以这个循环无法终止。 7. 过滤器魔法12345678910var ary = [0,1,2];ary[10] = 10;ary.filter(function(x) &#123; return x === undefined;&#125;);// A. [undefined x 7]// B. [0, 1, 2, 10]// C. []// D. [undefined] 答案是C。看MDN官方文档的描述： filter 为数组中的每个元素调用一次 callback 函数，并利用所有使得 callback 返回 true 或 等价于 true 的值 的元素创建一个新数组。callback 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。那些没有通过 callback 测试的元素会被跳过，不会被包含在新数组中。 参考资料： MDN：Array.prototype.filter() 8. 警惕IEEE 754标准12345678910var two = 0.2;var one = 0.1;var eight = 0.8;var six = 0.6;[two - one == one, eight - six == two]// A. [true, false]// B. [false, false]// C. [true, false]// D. other 答案是C。JavaScript中采用双精度浮点数格式，即IEEE 754标准。在该格式下，有些数字无法表示出来，比如：0.1 + 0.2 = 0.30000000000000004 ，这不是JavaScript的锅，所有采用该标准的语言都有这个问题，比如：Java、Python等。 参考资料： Wiki：Double-precision floating-point format 9. 字符串陷阱123456789101112131415161718192021function showCase(value) &#123; switch(value) &#123; case 'A': console.log('Case A'); break; case 'B': console.log('Case B'); break; case undefined: console.log('undefined'); break; default: console.log('Do not know!'); &#125;&#125;showCase(new String('A'));// A. Case A// B. Case B// C. Do not know!// D. undefined 答案是C。在 switch 内部使用严格相等 === 进行判断，并且 new String(&quot;A&quot;) 返回的是一个对象，而 String(&quot;A&quot;) 则是直接返回字符串 &quot;A&quot;。你也可以参考MDN中对原始字符串和String对象的区分： Note that JavaScript distinguishes between String objects and primitive string values. (The same is true of Boolean and Numbers.) String literals (denoted by double or single quotes) and strings returned from String calls in a non-constructor context (i.e., without using the new keyword) are primitive strings. JavaScript automatically converts primitives to String objects, so that it’s possible to use String object methods for primitive strings. In contexts where a method is to be invoked on a primitive string or a property lookup occurs, JavaScript will automatically wrap the string primitive and call the method or perform the property lookup. 参考资料： MDN：String 10. 再一次的字符串陷阱123456789101112131415161718192021function showCase(value) &#123; switch(value) &#123; case 'A': console.log('Case A'); break; case 'B': console.log('Case B'); break; case undefined: console.log('undefined'); break; default: console.log('Do not know!'); &#125;&#125;showCase(String('A'));// A. Case A// B. Case B// C. Do not know!// D. undefined 答案显然是A。与上面唯一不同的是没有使用 new 关键字，所以直接返回字符串，实际上，typeof string(&quot;A&quot;) === &quot;string&quot; 的结果是 true。解释参见第9条的解释。 11. 并非都是奇偶12345678910111213141516171819function isOdd(num) &#123; return num % 2 == 1;&#125;function isEven(num) &#123; return num % 2 == 0;&#125;function isSane(num) &#123; return isEven(num) || isOdd(num);&#125;var values = [7, 4, \"13\", -9, Infinity];values.map(isSane);// A. [true, true, true, true, true]// B. [true, true, true, true, false]// C. [true, true, true, false, false]// D. [true, true, false, false, false] 答案是C。-9 % 2 = -1 以及 Infinity % 2 = NaN，求余运算符会保留符号，所以只有 isEven 的判断是可靠的。 12. parseInt小贼12345678parseInt(3, 8);parseInt(3, 2);parseInt(3, 0);// A. 3, 3, 3// B. 3, 3, NaN// C. 3, NaN, NaN// D. other 答案是D。实际结果是 3, NaN, 3，这个在第一个问题中解释的很清楚了。 13. 数组原型是数组123456Array.isArray( Array.prototype )// A. true// B. false// C. error// D. other 答案是A。一个鲜为人知的事实：其实 Array.prototype 也是一个数组。这点在MDN文档中提到过。 参考资料： MDN：Array.isArray() 14. 一言难尽的强制转换1234567891011var a = [0];if ([0]) &#123; console.log(a == true);&#125; else &#123; console.log(\"wut\");&#125;// A. true// B. false// C. \"wut\"// D. other 答案是B。这个是JavaScript中强制转换的经典案例，关于强制转换不是一两句话可以跟你说清楚的，我建议你系统性的学习一下，推荐你看看《你不知道的JavaScript-中卷》这本书，如果不舍得买书，github上有英文原版：You-Dont-Know-JS，深入理解之后你就是高手了。 好了，回到当前这个问题。当 [0] 需要被强制转成 Boolean 的时候会被认为是 true。所以进入第一个 if 语句，而 a == true 的转换规则在ES5规范的第11.9.3节中已经定义过，你可以自己详细探索下。 规范指出，== 相等中，如果有一个操作数是布尔类型，会先把他转成数字，所以比较变成了 [0] == 1；同时规范指出如果其他类型和数字比较，会尝试把这个类型转成数字再进行宽松比较，而对象（数组也是对象）会先调用它的 toString() 方法，此时 [0] 会变成 &quot;0&quot;，然后将字符串 &quot;0&quot; 转成数字 0，而 0 == 1 的结果显然是 false。 参考资料： ES5规范：11.9.3 《你不知道的JavaScript-中卷》 15. 撒旦之子“==”123456[]==[]// A. true// B. false// C. error// D. other 答案是B。ES5规范11.9.3.1-f指出：如果比较的两个对象指向的是同一个对象，就返回 true，否则就返回 false，显然，这是两个不同的数组对象。 参考资料： ES5规范：11.9.3.1 《你不知道的JavaScript-中卷》 16. 加号 VS 减号1234567'5' + 3;'5' - 3;// A. \"53\", 2// B. 8, 2// C. error// D. other 答案是A。&quot;5&quot; + 2 = &quot;52&quot; 很好理解，+ 运算符中只要有一个是字符串，就会变成字符串拼接操作。你不知道的是，- 运算符要求两个操作数都是数字，如果不是，会强制转换成数字，所以结果就变成了 5 - 2 = 3。 参考资料： 《你不知道的JavaScript-中卷》，第四章：4.4.2 字符串和数字之间的隐式强制类型转换 17. 打死那个疯子1234561 + - + + + - + 1// A. 2// B. 1// C. error// D. other 答案是A。这个只能出现在示例代码中，如果你发现哪个疯子写了这个在生产代码中，打死他就行了。你只要知道 + 1 = 1和- 1 = -1，注意符号之间的空格。两个减号抵消，所以最终结果等效于 1 + 1 = 2。或者你也可以在符号之间插入 0 来理解，即 1 + 0 - 0 + 0 + 0 + 0 - 0 + 1，这样你就一目了然了吧！千万别写这样的代码，因为可能会被打死！ 18. 淘气的map12345678910var ary = Array(3);ary[0] = 2;ary.map(function(elem) &#123; return \"1\";&#125;);// A. [2, 1, 1]// B. [\"1\", \"1\", \"1\"]// C. [2, \"1\", \"1\"]// D. other 答案是D。实际上结果是 [&quot;1&quot;, undefined x 2]，因为规范写得很清楚： map 方法会给原数组中的每个元素都按顺序调用一次 callback 函数。callback 每次执行后的返回值组合起来形成一个新数组。 callback 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 delete 删除的索引则不会被调用。 参考资料： MDN: Array.prototype.map() 19. 统统算我的12345678910111213141516function sidEffecting(ary) &#123; ary[0] = ary[2];&#125;function bar(a, b, c) &#123; c = 10; sidEffecting(arguments); return a + b + c;&#125;bar(1, 1, 1);// A. 3// B. 12// C. error// D. other 答案是D。实际上结果是 21。在JavaScript中，参数变量和 arguments 是双向绑定的。改变参数变量，arguments 中的值会立即改变；而改变 arguments 中的值，参数变量也会对应改变。 20. 损失精度的IEEE 75412345678var a = 111111111111111110000;var b = 1111;console.log(a + b);// A. 111111111111111111111// B. 111111111111111110000// C. NaN// D. Infinity 答案是B。这是IEEE 754规范的黑锅，不是JavaScript的问题。表示这么大的数占用过多位数，会丢失精度，学过计算机组成原理的应该知道是怎么回事。 参考资料： Wiki：Double-precision floating-point format 21. 反转世界1234567var x = [].reverse;x();// A. []// B. undefined// C. error// D. window 答案是D。MDN规范关于 reverse 的描述： reverse 方法颠倒数组中元素的位置，并返回该数组的引用。 而这里调用的时候没有制定数组，所以默认的 this 就是 window，所以最后结果返回的是 window。 参考资料： MDN：Array.prototype.reverse() 22. 最小的正值123456Number.MIN_VALUE &gt; 0// A. false// B. true// C. error// D. other 答案是B。看规范描述吧： MIN_VALUE属性是 JavaScript 里最接近 0 的正值，而不是最小的负值。 MIN_VALUE的值约为 5e-324。小于 MIN_VALUE (“underflow values”) 的值将会转换为 0。 因为 MIN_VALUE是 Number 的一个静态属性，因此应该直接使用： Number.MIN_VALUE，而不是作为一个创建的 Number实例的属性。 参考资料： MDN：Number.MIN_VALUE 23. 谨记优先级123456[1 &lt; 2 &lt; 3, 3 &lt; 2 &lt; 1]// A. [true, true]// B. [true, false]// C. error// D. other 答案是A。&lt;和&gt;的优先级都是从左到右，所以 1 &lt; 2 &lt; 3 会先比较 1 &lt; 2，这会得到 true，但是 &lt; 要求比较的两边都是数字，所以会发生隐式强制转换，将 true 转换成 1，所以最后就变成了比较 1 &lt; 3，结果显然为 true。同理可以分析后者。 参考资料： MDN：运算符优先级 24. 坑爹中的战斗机1234567// the most classic wtf2 == [[[2]]]// A. true// B. false// C. undefined// D. other 答案是A。根据ES5规范，如果比较的两个值中有一个是数字类型，就会尝试将另外一个值强制转换成数字，再进行比较。而数组强制转换成数字的过程会先调用它的 toString方法转成字符串，然后再转成数字。所以 [2]会被转成 &quot;2&quot;，然后递归调用，最终 [[[2]]] 会被转成数字 2。 25. 小数点魔术123456783.toString();3..toString();3...toString();// A. \"3\", error, error// B. \"3\", \"3.0\", error// C. error, \"3\", error// D. other 答案是C。点运算符会被优先识别为数字常量的一部分，然后才是对象属性访问符。所以 3.toString() 实际上被JS引擎解析成 (3.)toString()，显然会出现语法错误。但是如果你这么写 (3).toString()，人为加上括号，这就是合法的。 26. 自动提升为全局变量12345678910(function() &#123; var x = y = 1;&#125;)();console.log(y);console.log(x);// A. 1, 1// B. error, error// C. 1, error// D. other 答案是C。很经典的例子，在函数中没有用 var 声明变量 y，所以 y 会被自动创建在全局变量 window下面，所以在函数外面也可以访问得到。而 x 由于被 var 声明过，所以在函数外部是无法访问的。 27. 正则表达式实例123456789var a = /123/;var b = /123/;a == b;a === b;// A. true, true// B. true, false// C. false, false// D. other 答案是C。每个字面的正则表达式都是一个单独的实例，即使它们的内容相同。 28. 数组也爱比大小12345678910111213var a = [1, 2, 3];var b = [1, 2, 3];var c = [1, 2, 4];a == b;a === b;a &gt; c;a &lt; c;// A. false, false, false, true// B. false, false, false, false// C. true, true, false, true// D. other 答案是A。数组也是对象，ES5规范指出如果两个对象进行相等比较，只有在它们指向同一个对象的情况下才会返回 true，其他情况都返回 false。而对象进行大小比较，会调用 toString 方法转成字符串进行比较，所以结果就变成了字符串 &quot;1,2,3&quot; 和 &quot;1,2,4&quot; 按照字典序进行比较了（你若不信，可以重现两个变量的 toString 方法，进行测试）。 29. 原型把戏123456789var a = &#123;&#125;;var b = Object.prototype;[a.prototype === b, Object.getPrototypeOf(a) == b]// A. [false, true]// B. [true, true]// C. [false, false]// D. other 答案是A。对象是没有 prototype 属性的，所以 a.prototype 是 undefined，但我们可以通过 Object.getPrototypeOf 方法来获取一个对象的原型。 30. 构造函数的函数123456789function f() &#123;&#125;var a = f.prototype;var b = Object.getPrototypeOf(f);a === b;// A. true// B. false// C. null// D. other 答案是B。这个解释起来有点绕口，我们先来看另外一段代码： 1234567891011121314function Person() &#123;&#125;var p = new Person();var a = p.__proto__;var b = Object.getPrototypeOf(p);var c = Person.prototype;console.log(a === b, a === c, b === c);// true, true, truevar d = Person.__proto__;var e = Object.getPrototypeOf(Person);var f = Function.prototype;console.log(d === e, d === f, e === f);// true, true, true 首先你要明白，任何函数都是 Function 的实例，而p是函数 Person 的实例，Object.getPrototypeOf 会获取构造当前对象的原型。所以 Object.getPrototypeOf(p) === Person.prototype，而 Object.getPrototypeOf(Person) === Function.prototype，所以答案就很明显了。 我解释的不是很好，如果读者有更好的解释，欢迎评论。 31. 禁止修改函数名123456789function foo() &#123;&#125;var oldName = foo.name;foo.name = \"bar\";[oldName, foo.name];// A. error// B. [\"\", \"\"]// C. [\"foo\", \"foo\"]// D. [\"foo\", \"bar\"] 答案是C。函数名是禁止修改的，规范写的很清楚，所以这里的修改无效。 参考资料： MDN：Function.name 32. 替换陷阱123456\"1 2 3\".replace(/\\d/g, parseInt);// A. \"1 2 3\"// B. \"0 1 2\"// C. \"NaN 2 3\"// D. \"1 NaN 3\" 答案是D。如果 replace 方法第二个参数是一个函数，则会在匹配的时候多次调用，第一个参数是匹配的字符串，第二个参数是匹配字符串的下标。所以变成了调用 parseInt(1, 0)、parseInt(2, 2)和parseInt(3, 4)，结果你就懂了。 参考资料： MDN：String.prototype.replace() 33. Function的名字1234567891011function f() &#123;&#125;var parent = Object.getPrototypeOf(f);console.log(f.name);console.log(parent.name);console.log(typeof eval(f.name));console.log(typeof eval(parent.name));// A. \"f\", \"Empty\", \"function\", \"function\"// B. \"f\", undefined, \"function\", error// C. \"f\", \"Empty\", \"function\", error// D. other 答案是C。根据第30题的解释，我们知道代码中的 parent 实际上就是 Function.prototype，而它在控制台中输出为： 123function () &#123; [native code]&#125; 它的 name 属性是 &quot;&quot;，所以你 eval(&quot;&quot;)是得不到任何东西的。 34. 正则测试陷阱1234567var lowerCaseOnly = /^[a-z]+$/;[lowerCaseOnly.test(null), lowerCaseOnly.test()]// A. [true, false]// B. error// C. [true, true]// D. [false, true] 答案是C。test 方法的参数如果不是字符串，会经过抽象 ToString操作强制转成字符串，因此实际上测试的是字符串 &quot;null&quot; 和 &quot;undefined&quot;。 35. 逗号定义数组123456[,,,].join(\", \")// A. \", , , \"// B. \"undefined, undefined, undefined, undefined\"// C. \", , \"// D. \"\" 答案是C。JavaScript允许用逗号来定义数组，得到的数组是含有3个 undefined 值的数组。MDN关于 join 方法的描述： 所有的数组元素被转换成字符串，再用一个分隔符将这些字符串连接起来。如果元素是undefined 或者null， 则会转化成空字符串。 参考资料： MDN：Array.prototype.join() 36. 保留字 class1234567var a = &#123;class: \"Animal\", name: \"Fido\"&#125;;console.log(a.class);// A. \"Animal\"// B. Object// C. an error// D. other 答案是D。实际上真正的答案取决于浏览器。class 是保留字，但是在Chrome、Firefox和Opera中可以作为属性名称，在IE中是禁止的。另一方面，其实所有浏览器基本接受大部分的关键字（如：int、private、throws等）作为变量名，而class是禁止的。 37. 无效日期123456var a = new Date(\"epoch\");// A. Thu Jan 01 1970 01:00:00 GMT+0100(CET)// B. current time// C. error// D. other 答案是D。实际结果是 Invalid Date，它实际上是一个Date对象，因为 a instance Date 的结果是 true，但是它是无效的Date。Date对象内部是用一个数字来存储时间的，在这个例子中，这个数字是 NaN。 38. 神鬼莫测的函数长度12345678var a = Function.length;var b = new Function().length;console.log(a === b);// A. true// B. false// C. error// D. other 答案是B。实际上a的值是1，b的值是0。还是继续来看MDN文档关于 Function.length 的描述吧！ Function构造器的属性： Function 构造器本身也是个Function。他的 length 属性值为 1 。该属性 Writable: false, Enumerable: false, Configurable: true。 Function原型对象的属性： Function原型对象的 length 属性值为 0 。 所以，在本例中，a代表的是 Function 构造器的 length 属性，而b代表的是 Function 原型的 length 属性。 参考资料： MDN：Function.length 39. Date的面具123456789var a = Date(0);var b = new Date(0);var c = new Date();[a === b, b === c, a === c];// A. [true, true, true]// B. [false, false, false]// C. [false, true, false]// D. [true, false, false] 答案是B。先看MDN关于Date对象的注意点： 需要注意的是只能通过调用 Date 构造函数来实例化日期对象：以常规函数调用它（即不加 new 操作符）将会返回一个字符串，而不是一个日期对象。另外，不像其他JavaScript 类型，Date 对象没有字面量格式。 所以a是字符串，b和c是Date对象，并且b代表的是1970年那个初始化时间，而c代表的是当前时间。 参考资料： MDN：Date 40. min与max共舞12345678var min = Math.min();var max = Math.max();console.log(min &lt; max);// A. true// B. false// C. error// D. other 答案是B。看MDN文档，对 Math.min的描述： 如果没有参数，结果为Infinity。 对 Math.max 的描述： 如果没有参数，结果为-Infinity。 参考资料： MDN：Math.min MDN：Math.max 41. 警惕全局匹配123456789101112131415161718function captureOne(re, str) &#123; var match = re.exec(str); return match &amp;&amp; match[1];&#125;var numRe = /num=(\\d+)/ig, wordRe = /word=(\\w+)/i, a1 = captureOne(numRe, \"num=1\"), a2 = captureOne(wordRe, \"word=1\"), a3 = captureOne(numRe, \"NUM=1\"), a4 = captureOne(wordRe, \"WORD=1\");[a1 === a2, a3 === a4]// A. [true, true]// B. [false, false]// C. [true, false]// D. [false, true] 答案是C。看MDN关于 exec 方法的描述： 当正则表达式使用 “g” 标志时，可以多次执行 exec 方法来查找同一个字符串中的成功匹配。当你这样做时，查找将从正则表达式的 lastIndex 属性指定的位置开始。 所以a3的值为 null。 参考资料： MDN：RegExp.prototype.exec() 42. 最熟悉的陌生人12345678var a = new Date(\"2014-03-19\");var b = new Date(2014, 03, 19);[a.getDay() == b.getDay(), a.getMonth() == b.getMonth()]// A. [true, true]// B. [true, false]// C. [false, true]// D. [false, false] 答案是D。先看MDN关于Date的一个注意事项： 当Date作为构造函数调用并传入多个参数时，如果数值大于合理范围时（如月份为13或者分钟数为70），相邻的数值会被调整。比如 new Date(2013, 13, 1)等于new Date(2014, 1, 1)，它们都表示日期2014-02-01（注意月份是从0开始的）。其他数值也是类似，new Date(2013, 2, 1, 0, 70)等于new Date(2013, 2, 1, 1, 10)，都表示时间2013-03-01T01:10:00。 此外，getDay 返回指定日期对象的星期中的第几天（0～6），所以，你懂的。 参考资料： MDN：Date 43. 匹配隐式转换12345678910if(\"http://giftwrapped.com/picture.jpg\".match(\".gif\")) &#123; console.log(\"a gif file\");&#125; else &#123; console.log(\"not a gif file\");&#125;// A. \"a gif file\"// B. \"not a gif file\"// C. error// D. other 答案是A。看MDN对 match 方法的描述： 如果传入一个非正则表达式对象，则会隐式地使用 new RegExp(obj) 将其转换为正则表达式对象。 所以我们的字符串 &quot;.gif&quot; 会被转换成正则对象 /.gif/，会匹配到 &quot;/gif&quot;。 参考资料： MDN：String.prototype.match() 44. 重复声明变量12345678910111213141516function foo(a) &#123; var a; return a;&#125;function bar(a) &#123; var a = \"bye\"; return a;&#125;[foo(\"hello\"), bar(\"hello\")]// A. [\"hello\", \"hello\"]// B. [\"hello\", \"bye\"]// C. [\"bye\", \"bye\"]// D. other 答案是B。一个变量在同一作用域中已经声明过，会自动移除 var 声明，但是赋值操作依旧保留，结合前面提到的变量提升机制，你就明白了。 参考资料： MDN：var","categories":[{"name":"前端面试题","slug":"前端面试题","permalink":"https://qw8.github.io/categories/前端面试题/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qw8.github.io/tags/JavaScript/"},{"name":"编程题","slug":"编程题","permalink":"https://qw8.github.io/tags/编程题/"}]},{"title":"JavaScript编程题","slug":"interview/JavaScript编程题","date":"2020-05-28T02:41:39.000Z","updated":"2024-03-31T15:48:02.000Z","comments":true,"path":"/interview/javascript-bian-cheng-ti.html","link":"","permalink":"https://qw8.github.io/interview/javascript-bian-cheng-ti.html","excerpt":"","text":"常考代码题简单实现 Function.bind 函数？12345678910111213if (!Function.prototype.bind) &#123; Function.prototype.bind = function(that) &#123; var func = this, args = arguments; return function() &#123; return func.apply(that, Array.prototype.slice.call(args, 1)); &#125; &#125;&#125;// 只支持 bind 阶段的默认参数：func.bind(that, arg1, arg2)();// 不支持以下调用阶段传入的参数：func.bind(that)(arg1, arg2); 实现一个 Function.bind12345678910111213141516171819Function.prototype.bind2 = function(context) &#123; if (typeof this !== \"function\") &#123; throw new Error( \"Function.prototype.bind - what is trying to be bound is not callable\" ); &#125; var self = this; var args = Array.prototype.slice.call(arguments, 1); var fNOP = function() &#123;&#125;; var fbound = function() &#123; self.apply( this instanceof self ? this : context, args.concat(Array.prototype.slice.call(arguments)) ); &#125;; fNOP.prototype = this.prototype; fbound.prototype = new fNOP(); return fbound;&#125;; 手写一个 promise1234567891011121314var promise = new Promise((resolve, reject) =&gt; &#123; if (success) &#123; // 操作成功 resolve(value); &#125; else &#123; reject(error); &#125;&#125;);promise .then(res =&gt; console.log(res)) .catch(err =&gt; &#123; console.log(err); &#125;); 手写一个 Promise(中高级必考)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function myPromise(constructor) &#123; let self = this; self.status = \"pending\"; //定义状态改变前的初始状态 self.value = undefined; //定义状态为resolved的时候的状态 self.reason = undefined; //定义状态为rejected的时候的状态 function resolve(value) &#123; //两个===\"pending\"，保证了状态的改变是不可逆的 if (self.status === \"pending\") &#123; self.value = value; self.status = \"resolved\"; &#125; &#125; function reject(reason) &#123; //两个===\"pending\"，保证了状态的改变是不可逆的 if (self.status === \"pending\") &#123; self.reason = reason; self.status = \"rejected\"; &#125; &#125; //捕获构造异常 try &#123; constructor(resolve, reject); &#125; catch (e) &#123; reject(e); &#125;&#125;//同时，需要在 myPromise的原型上定义链式调用的 then方法：myPromise.prototype.then = function(onFullfilled, onRejected) &#123; let self = this; switch (self.status) &#123; case \"resolved\": onFullfilled(self.value); break; case \"rejected\": onRejected(self.reason); break; default: &#125;&#125;;//测试一下：var p = new myPromise(function(resolve, reject) &#123; resolve(1);&#125;);p.then(function(x) &#123; console.log(x);&#125;); 用 js 实现一个标准的排序算法一.冒泡排序1234567891011121314151617181920var bubble = function(arr)&#123; var maxIndex = arr.length - 1, temp, flag; for (var i = maxIndex; i &gt; 0; i--) &#123; flag = true for (var j = 0; j &lt; i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = false; &#125; &#125; if(! flag)&#123; break; &#125; &#125; return arr;&#125;// 调用var arr = bubble([13, 69, 28, 93, 55, 75, 34]); 123456789101112131415161718192021222324252627282930function BubbleSort(arr) &#123; for (var i = arr.length - 1; i &gt; 0; i--) &#123; //用于缩小范围 for (var j = 0; j &lt; i; j++) &#123; //在范围内进行冒泡，在此范围内最大的一个将冒到最后面 if (arr[j] &gt; arr[j + 1]) &#123;//从小到大 var temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; console.log(arr); &#125; return arr;&#125;var arr = [10, 9, 8, 7,6, 5,4, 3];var result = BubbleSort(arr);console.log(result);/*代码实际输出：[ 9, 8, 7, 6, 5, 4, 3, 10 ][ 8, 7, 6, 5, 4, 3, 9, 10 ][ 7, 6, 5, 4, 3, 8, 9, 10 ][ 6, 5, 4, 3, 7, 8, 9, 10 ][ 5, 4, 3, 6, 7, 8, 9, 10 ][ 4, 3, 5, 6, 7, 8, 9, 10 ][ 3, 4, 5, 6, 7, 8, 9, 10 ][ 3, 4, 5, 6, 7, 8, 9, 10 ]*/ 1234567891011121314// 冒泡排序var bubbleSort = function( arr) &#123; var len = arr.length; for( var i = 0; i &lt; len; i ++)&#123; for( var j = 0; i &lt; len - 1 - i; i ++)&#123; if(arr[j] &gt; arr[j + 1]) &#123; //相邻元素两两对比 var temp = arr[j + 1]; //元素交换 arr[j + 1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125; 二.选择排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function SelectionSort(array) &#123; var length = array.length; for (var i = 0; i &lt; length; i++) &#123; //缩小选择的范围 var min = array[i]; //假定范围内第一个为最小值 var index = i; //记录最小值的下标 for (var j = i + 1; j &lt; length; j++) &#123; //在范围内选取最小值 if (array[j] &lt; min) &#123; min = array[j]; index = j; &#125; &#125; if (index != i) &#123; //把范围内最小值交换到范围内第一个 var temp = array[i]; array[i] = array[index]; array[index] = temp; &#125; console.log(array); console.log(\"---------------------\"); &#125; return array;&#125;var arr = [1, 10, 100, 90, 65, 5, 4, 10, 2, 4];var result = SelectionSort(arr);console.log(result);/*[ 1, 10, 100, 90, 65, 5, 4, 10, 2, 4 ]---------------------[ 1, 2, 100, 90, 65, 5, 4, 10, 10, 4 ]---------------------[ 1, 2, 4, 90, 65, 5, 100, 10, 10, 4 ]---------------------[ 1, 2, 4, 4, 65, 5, 100, 10, 10, 90 ]---------------------[ 1, 2, 4, 4, 5, 65, 100, 10, 10, 90 ]---------------------[ 1, 2, 4, 4, 5, 10, 100, 65, 10, 90 ]---------------------[ 1, 2, 4, 4, 5, 10, 10, 65, 100, 90 ]---------------------[ 1, 2, 4, 4, 5, 10, 10, 65, 100, 90 ]---------------------[ 1, 2, 4, 4, 5, 10, 10, 65, 90, 100 ]---------------------[ 1, 2, 4, 4, 5, 10, 10, 65, 90, 100 ]---------------------[ 1, 2, 4, 4, 5, 10, 10, 65, 90, 100 ]*/ 三.插入排序123456789101112131415161718192021222324252627282930313233343536373839404142function InsertionSort(array) &#123; var length = array.length; for (var i = 0; i &lt; length - 1; i++) &#123; //i代表已经排序好的序列最后一项下标 var insert = array[i + 1]; var index = i + 1; //记录要被插入的下标 for (var j = i; j &gt;= 0; j--) &#123; if (insert &lt; array[j]) &#123; //要插入的项比它小，往后移动 array[j + 1] = array[j]; index = j; &#125; &#125; array[index] = insert; console.log(array); console.log(\"-----------------------\"); &#125; return array;&#125;var arr = [100, 90, 80, 62, 80, 8, 1, 2, 39];var result = InsertionSort(arr);console.log(result);/*[ 90, 100, 80, 62, 80, 8, 1, 2, 39 ]-----------------------[ 80, 90, 100, 62, 80, 8, 1, 2, 39 ]-----------------------[ 62, 80, 90, 100, 80, 8, 1, 2, 39 ]-----------------------[ 62, 80, 80, 90, 100, 8, 1, 2, 39 ]-----------------------[ 8, 62, 80, 80, 90, 100, 1, 2, 39 ]-----------------------[ 1, 8, 62, 80, 80, 90, 100, 2, 39 ]-----------------------[ 1, 2, 8, 62, 80, 80, 90, 100, 39 ]-----------------------[ 1, 2, 8, 39, 62, 80, 80, 90, 100 ]-----------------------[ 1, 2, 8, 39, 62, 80, 80, 90, 100 ]*/ 123456789101112131415// 插入排序var insertSort = function( arr) &#123; var len = arr.length; var preIndex, current; for( var i = 1; i &lt; len; i ++)&#123; preIndex = i - 1; current = arr[i]; while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current)&#123; arr[preIndex + 1] = arr[preIndex]; preIndex --; &#125; arr[preIndex + 1] = current; &#125; return arr;&#125; 四.希尔排序五.归并排序六.快速排序12345678910111213141516var quickSort = function( arr) &#123; if(arr.length &lt; 1) &#123; //如果数组就是一项，那么可以直接返回 return arr; &#125; var centerIndex = Math. floor(arr.length / 2); //获取数组中间的索引 var centerValue = arr[centerIndex]; //获取数组中间项 var left = [], right = []; for( var i = 0; i &lt; arr.lenght; i ++)&#123; if(arr[i] &lt; centerValue)&#123; left. push(arr[i]); &#125; else&#123; right. push(arr[i]); &#125; &#125; return quickSort(left). contanct([centerValue], quickSort(right)); //递归调用&#125; 手写数组快速排序123456789101112131415161718var quickSort = function(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; for (var i = 0, len = arr.length; i &lt; len; i++)&#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot], quickSort(right));&#125;;// 调用quickSort([9, 4, 2, 8, 1, 5, 3, 7]); 如何实现数组的随机排序？ 方法一： 1234567891011var arr = [1,2,3,4,5,6,7,8,9,10];function randSort1(arr)&#123; for(var i = 0,len = arr.length;i &lt; len; i++ )&#123; var rand = parseInt(Math.random()*len); var temp = arr[rand]; arr[rand] = arr[i]; arr[i] = temp; &#125; return arr;&#125;console.log(randSort1(arr)); 方法二： 1234567891011var arr = [1,2,3,4,5,6,7,8,9,10];function randSort2(arr)&#123; var mixedArray = []; while(arr.length &gt; 0)&#123; var randomIndex = parseInt(Math.random()*arr.length); mixedArray.push(arr[randomIndex]); arr.splice(randomIndex, 1); &#125; return mixedArray;&#125;console.log(randSort2(arr)); 方法三： 12345var arr = [1,2,3,4,5,6,7,8,9,10];arr.sort(function()&#123; return Math.random() - 0.5;&#125;)console.log(arr); 用 js 实现随机选取 10–100 之间的 10 个数字，存入一个数组，并排序。123456789var iArray = [];funtion getRandom(istart, iend)&#123;var iChoice = istart - iend +1;return Math.floor(Math.random() * iChoice + istart;&#125;for(var i=0; i&lt;10; i++)&#123;iArray.push(getRandom(10,100));&#125;iArray.sort(); 手写防抖(Debouncing)和节流(Throttling)12345678910// 防抖函数function debounce(fn, wait) &#123; let timer; return function() &#123; if (timer) clearTimeout(timer); timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments); &#125;, wait); &#125;;&#125; 123456789101112// 节流函数function throttle(fn, wait) &#123; let prev = new Date(); return function() &#123; const args = arguments; const now = new Date(); if (now - prev &gt; wait) &#123; fn.apply(this, args); prev = new Date(); &#125; &#125;;&#125; 实现防抖函数（debounce）防抖函数原理：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。 那么与节流函数的区别直接看这个动画实现即可。 手写简化版: 12345678910// 防抖函数const debounce = (fn, delay) =&gt; &#123; let timer = null; return (...args) =&gt; &#123; clearTimeout(timer); timer = setTimeout(() =&gt; &#123; fn.apply(this, args); &#125;, delay); &#125;;&#125;; 适用场景： 按钮提交场景：防止多次提交按钮，只执行最后提交的一次 服务端验证场景：表单验证需要服务端配合，只执行一段连续的输入事件的最后一次，还有搜索联想词功能类似 生存环境请用lodash.debounce 实现节流函数（throttle）防抖函数原理:规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。 // 手写简化版 123456789101112// 节流函数const throttle = (fn, delay = 500) =&gt; &#123; let flag = true; return (...args) =&gt; &#123; if (!flag) return; flag = false; setTimeout(() =&gt; &#123; fn.apply(this, args); flag = true; &#125;, delay); &#125;;&#125;; 适用场景： 拖拽场景：固定时间内只执行一次，防止超高频次触发位置变动 缩放场景：监控浏览器resize 动画场景：避免短时间内多次触发动画引起性能问题 手写一个 JS 深拷贝1234567891011121314function deepCopy(obj) &#123; //判断是否是简单数据类型， if (typeof obj == \"object\") &#123; //复杂数据类型 var result = obj.constructor == Array ? [] : &#123;&#125;; for (let i in obj) &#123; result[i] = typeof obj[i] == \"object\" ? deepCopy(obj[i]) : obj[i]; &#125; &#125; else &#123; //简单数据类型 直接 == 赋值 var result = obj; &#125; return result;&#125; 123456let o1 = &#123; a: &#123; b: 1 &#125;&#125;;let o2 = JSON.parse(JSON.stringify(o1)); 另一种方法 1234567891011function deepCopy(s) &#123; const d = &#123;&#125;; for (let k in s) &#123; if (typeof s[k] == \"object\") &#123; d[k] = deepCopy(s[k]); &#125; else &#123; d[k] = s[k]; &#125; &#125; return d;&#125; 如何封装一个 javascript 的类型判断函数？12345678910111213141516171819function getType(value) &#123; // 判断数据是 null 的情况 if (value === null) &#123; return value + \"\"; &#125; // 判断数据是引用类型的情况 if (typeof value === \"object\") &#123; let valueClass = Object.prototype.toString.call(value), type = valueClass.split(\" \")[1].split(\"\"); type.pop(); return type.join(\"\").toLowerCase(); &#125; else &#123; // 判断数据是基本数据类型的情况和函数的情况 return typeof value; &#125;&#125; 详细资料可以参考：《JavaScript 专题之类型判断(上)》 如何判断一个对象是否为空对象？123function checkNullObj(obj) &#123; return Object.keys(obj).length === 0 &amp;&amp; Object.getOwnPropertySymbols(obj).length === 0;&#125; 详细资料可以参考：《js 判断一个 object 对象是否为空》 使用闭包实现每隔一秒打印 1,2,3,412345678910111213141516// 使用闭包实现for (var i = 0; i &lt; 5; i++) &#123; (function(i) &#123; setTimeout(function() &#123; console.log(i); &#125;, i * 1000); &#125;)(i);&#125;// 使用 let 块级作用域for (let i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, i * 1000);&#125; 手写一个 jsonp1234567891011121314151617181920212223242526272829303132333435function jsonp(url, params, callback) &#123; // 判断是否含有参数 let queryString = url.indexOf(\"?\") === -1 ? \"?\" : \"&amp;\"; // 添加参数 for (var k in params) &#123; if (params.hasOwnProperty(k)) &#123; queryString += k + \"=\" + params[k] + \"&amp;\"; &#125; &#125; // 处理回调函数名 let random = Math.random() .toString() .replace(\".\", \"\"), callbackName = \"myJsonp\" + random; // 添加回调函数 queryString += \"callback=\" + callbackName; // 构建请求 let scriptNode = document.createElement(\"script\"); scriptNode.src = url + queryString; window[callbackName] = function() &#123; // 调用回调函数 callback(...arguments); // 删除这个引入的脚本 document.getElementsByTagName(\"head\")[0].removeChild(scriptNode); &#125;; // 发起请求 document.getElementsByTagName(\"head\")[0].appendChild(scriptNode);&#125; 详细资料可以参考：《原生 jsonp 具体实现》《jsonp 的原理与实现》 手写一个观察者模式？123456789101112131415161718192021222324252627282930313233343536373839404142434445var events = (function() &#123; var topics = &#123;&#125;; return &#123; // 注册监听函数 subscribe: function(topic, handler) &#123; if (!topics.hasOwnProperty(topic)) &#123; topics[topic] = []; &#125; topics[topic].push(handler); &#125;, // 发布事件，触发观察者回调事件 publish: function(topic, info) &#123; if (topics.hasOwnProperty(topic)) &#123; topics[topic].forEach(function(handler) &#123; handler(info); &#125;); &#125; &#125;, // 移除主题的一个观察者的回调事件 remove: function(topic, handler) &#123; if (!topics.hasOwnProperty(topic)) return; var handlerIndex = -1; topics[topic].forEach(function(item, index) &#123; if (item === handler) &#123; handlerIndex = index; &#125; &#125;); if (handlerIndex &gt;= 0) &#123; topics[topic].splice(handlerIndex, 1); &#125; &#125;, // 移除主题的所有观察者的回调事件 removeAll: function(topic) &#123; if (topics.hasOwnProperty(topic)) &#123; topics[topic] = []; &#125; &#125; &#125;;&#125;)(); 详细资料可以参考：《JS 事件模型》 EventEmitter 实现12345678910111213141516171819202122232425262728293031323334353637383940class EventEmitter &#123; constructor() &#123; this.events = &#123;&#125;; &#125; on(event, callback) &#123; let callbacks = this.events[event] || []; callbacks.push(callback); this.events[event] = callbacks; return this; &#125; off(event, callback) &#123; let callbacks = this.events[event]; this.events[event] = callbacks &amp;&amp; callbacks.filter(fn =&gt; fn !== callback); return this; &#125; emit(event, ...args) &#123; let callbacks = this.events[event]; callbacks.forEach(fn =&gt; &#123; fn(...args); &#125;); return this; &#125; once(event, callback) &#123; let wrapFun = (...args) =&gt; &#123; callback(...args); this.off(event, wrapFun); &#125;; this.on(event, wrapFun); return this; &#125;&#125; 一道常被人轻视的前端 JS 面试题123456789101112131415161718192021222324252627function Foo() &#123; getName = function() &#123; alert(1); &#125;; return this;&#125;Foo.getName = function() &#123; alert(2);&#125;;Foo.prototype.getName = function() &#123; alert(3);&#125;;var getName = function() &#123; alert(4);&#125;;function getName() &#123; alert(5);&#125;//请写出以下输出结果：Foo.getName(); // 2getName(); // 4Foo().getName(); // 1getName(); // 1new Foo.getName(); // 2new Foo().getName(); // 3new new Foo().getName(); // 3 详细资料可以参考：《前端程序员经常忽视的一个 JavaScript 面试题》《一道考察运算符优先级的 JavaScript 面试题》《一道常被人轻视的前端 JS 面试题》 如何查找一篇英文文章中出现频率最高的单词？123456789101112131415161718192021222324252627282930313233function findMostWord(article) &#123; // 合法性判断 if (!article) return; // 参数处理 article = article.trim().toLowerCase(); let wordList = article.match(/[a-z]+/g), visited = [], maxNum = 0, maxWord = \"\"; article = \" \" + wordList.join(\" \") + \" \"; // 遍历判断单词出现次数 wordList.forEach(function(item) &#123; if (visited.indexOf(item) &lt; 0) &#123; // 加入 visited visited.push(item); let word = new RegExp(\" \" + item + \" \", \"g\"), num = article.match(word).length; if (num &gt; maxNum) &#123; maxNum = num; maxWord = item; &#125; &#125; &#125;); return maxWord + \" \" + maxNum;&#125; 用最简单的方式，求一个数组中最大的元素，例如 arr=[5,7,9,42,18,29]123var a = [1, 2, 3, 5];alert(Math.max.apply(null, a)); //最大值alert(Math.min.apply(null, a)); //最小值 如何解决数组塌陷问题12345678910111213141516// 1 使用i--for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] === 4) &#123; arr.splice(i, 1); i--; &#125;&#125;console.log(arr);// 2 从数组的末尾一项开始遍历for (var i = arr.length; i &gt;= 0; i--) &#123; if (arr[i] === 4) &#123; arr.splice(i, 1); &#125;&#125;console.log(arr); 已知 id 的 input 输入框，希望获取这个输入框的输入值，怎么做？（不使用第三方框架）1document.getElementById(\"id\").value; 获取到页面中所有的 checkbox 怎么做？（不使用第三方框架）12345678var domList = document.getElementsByTagName(\"input\");var ckList = []; // 返回的所有的 checkboxvar len = domList.length;for (var i = 0; i &lt; len; i++) &#123; if (domList[i].type == \"checkbox\") &#123; ckList.push(domList[i]); &#125;&#125; 设置一个已知 id 的 div 的 html 内容为 xxxx，字体颜色设置为黑色（不使用第三方框架）123var dom = document.getElementById(\"id\");dom.innerHTML = \"xxxx\";dom.style.color = \"#000\"; // 'black' 已知有字符串 foo=“get-element-by-id”,写一个 function 将其转化为驼峰表示法“getElementById”1234567891011var string = \"get-element-by-id\";function combo(msg) &#123; var arr = msg.split(\"-\"); //split(\"-\")以-为分隔符截取字符串，返回数组 for (var i = 1; i &lt; arr.length; i++) &#123; arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].slice(1); &#125; msg = arr.join(\"\"); //join()返回字符串 return msg;&#125;console.log(combo(string)); 写一个 function，清除字符串前后的空格（兼容所有的浏览器）123456//重写trim方法if (!String.prototype.trim) &#123; String.prototype.trim = function() &#123; return this.replace(/^\\s+/, \"\").replace(/\\s+$/, \"\"); &#125;;&#125; 运算符面试题1234567var a = 10, b = 20, c = 30;++a;a++;e = ++a + ++b + c++ + a++;console.log(e); // 77 判断相等2 == true[] == false[] == ![] 闭包1234567891011for (var i = 1; i &lt;= 3; i++) &#123; setTimeout( (() =&gt; &#123; var j = i; return function() &#123; console.log(j); &#125;; &#125;)(), 0 );&#125; 实现一个 new 操作符12345678910111213141516function New(func) &#123; var res = &#123;&#125;; if (func.prototype !== null) &#123; res.__proto__ = func.prototype; &#125; var ret = func.apply(res, Array.prototype.slice.call(arguments, 1)); if ((typeof ret === \"object\" || typeof ret === \"function\") &amp;&amp; ret !== null) &#123; return; ret; &#125; return; res;&#125;var obj = New(A, 1, 2);// equals tovar obj = new A(1, 2); 实现一个 call 或 apply答案：call 1234567891011121314Function.prototype.call2 = function(context) &#123; var context = context || window; context.fn = this; var args = []; for (var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push(\"arguments[\" + i + \"]\"); &#125; var result = eval(\"context.fn(\" + args + \")\"); delete context.fn; return result;&#125;; apply 123456789101112131415161718Function.prototype.apply2 = function(context, arr) &#123; var context = Object(context) || window; context.fn = this; var result; if (!arr) &#123; result = context.fn(); &#125; else &#123; var args = []; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; args.push(\"arr[\" + i + \"]\"); &#125; result = eval(\"context.fn(\" + args + \")\"); &#125; delete context.fn; return result;&#125;; 原型链面试题123456789101112131415161718192021222324// 1function A() &#123;&#125;function B() &#123;&#125;B.prototype = new A();var a = new A();B.prototype = a;var b = new B();console.log(b.constructor); // 构造函数A//2console.log(Function.constructor === Function);// Function 是一个构造函数console.log(Function.__proto__.constructor === Function);// 默认原型上面的constructor属性指向了原型所在的构造函数。console.log(Object.constructor === Function);// Object本身没有constructor这个属性，那么就到它的原型链上去查找，Object.__proto__ === Function.prototype;console.log(Function.__proto__.__proto__ === Object.prototype);Function.__proto__ === Function.prototype;Function.prototype.__proto__ === Object.prototype; 12345678var o = new Object();function foo(obj) &#123; obj.name = \"腐女\"; obj = new Object(); obj.name = \"屌丝\"; //这是另一个新对象的name&#125;foo(o);console.log(o.name); //想要的是原来对象的name，所以输出腐女 实现一个继承123456789101112131415161718192021222324252627function Parent(name) &#123; this.name = name;&#125;Parent.prototype.sayName = function() &#123; console.log(\"parent name:\", this.name);&#125;;function Child(name, parentName) &#123; Parent.call(this, parentName); this.name = name;&#125;function create(proto) &#123; function F() &#123;&#125; F.prototype = proto; return new F();&#125;Child.prototype = create(Parent.prototype);Child.prototype.sayName = function() &#123; console.log(\"child name:\", this.name);&#125;;Child.prototype.constructor = Child;var parent = new Parent(\"汪某\");parent.sayName(); // parent name: 汪某var child = new Child(\"son\", \"汪某\"); 编写一个方法 求一个字符串的字节长度假设：一个英文字符占用一个字节，一个中文字符占用两个字节 123456789function GetBytes(str)&#123; var len = str.length; var bytes = len; for(var i=0; i&lt;len; i++)&#123; if (str.charCodeAt(i) &gt; 255) bytes++; &#125; return bytes; &#125;alert(GetBytes(&quot;你好,as&quot;)); 写一个通用的事件侦听器函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// event(事件)工具集，来源：github.com/markyun markyun.Event = &#123; // 页面加载完成后 readyEvent : function(fn) &#123; if (fn==null) &#123; fn=document; &#125; var oldonload = window.onload; if (typeof window.onload != &apos;function&apos;) &#123; window.onload = fn; &#125; else &#123; window.onload = function() &#123; oldonload(); fn(); &#125;; &#125; &#125;, // 视能力分别使用dom0||dom2||IE方式 来绑定事件 // 参数： 操作的元素,事件名称 ,事件处理程序 addEvent : function(element, type, handler) &#123; if (element.addEventListener) &#123; //事件类型、需要执行的函数、是否捕捉 element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent(&apos;on&apos; + type, function() &#123; handler.call(element); &#125;); &#125; else &#123; element[&apos;on&apos; + type] = handler; &#125; &#125;, // 移除事件 removeEvent : function(element, type, handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.datachEvent) &#123; element.detachEvent(&apos;on&apos; + type, handler); &#125; else &#123; element[&apos;on&apos; + type] = null; &#125; &#125;, // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获) stopPropagation : function(ev) &#123; if (ev.stopPropagation) &#123; ev.stopPropagation(); &#125; else &#123; ev.cancelBubble = true; &#125; &#125;, // 取消事件的默认行为 preventDefault : function(event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, // 获取事件目标 getTarget : function(event) &#123; return event.target || event.srcElement; &#125;, // 获取event对象的引用，取到事件的所有信息，确保随时能使用event； getEvent : function(e) &#123; var ev = e || window.event; if (!ev) &#123; var c = this.getEvent.caller; while (c) &#123; ev = c.arguments[0]; if (ev &amp;&amp; Event == ev.constructor) &#123; break; &#125; c = c.caller; &#125; &#125; return ev; &#125; &#125;; 写一个通用的事件侦听器函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// event(事件)工具集，来源：https://github.com/markyunmarkyun.Event = &#123; // 页面加载完成后 readyEvent: function(fn) &#123; if (fn == null) &#123; fn = document; &#125; var oldonload = window.onload; if (typeof window.onload != \"function\") &#123; window.onload = fn; &#125; else &#123; window.onload = function() &#123; oldonload(); fn(); &#125;; &#125; &#125;, // 视能力分别使用dom0||dom2||IE方式 来绑定事件 // 参数： 操作的元素,事件名称 ,事件处理程序 addEvent: function(element, type, handler) &#123; if (element.addEventListener) &#123; //事件类型、需要执行的函数、是否捕捉 element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent(\"on\" + type, function() &#123; handler.call(element); &#125;); &#125; else &#123; element[\"on\" + type] = handler; &#125; &#125;, // 移除事件 removeEvent: function(element, type, handler) &#123; if (element.removeEnentListener) &#123; element.removeEnentListener(type, handler, false); &#125; else if (element.datachEvent) &#123; element.detachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] = null; &#125; &#125;, // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获) stopPropagation: function(ev) &#123; if (ev.stopPropagation) &#123; ev.stopPropagation(); &#125; else &#123; ev.cancelBubble = true; &#125; &#125;, // 取消事件的默认行为 preventDefault: function(event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, // 获取事件目标 getTarget: function(event) &#123; return event.target || event.srcElement; &#125;, // 获取event对象的引用，取到事件的所有信息，确保随时能使用event； getEvent: function(e) &#123; var ev = e || window.event; if (!ev) &#123; var c = this.getEvent.caller; while (c) &#123; ev = c.arguments[0]; if (ev &amp;&amp; Event == ev.constructor) &#123; break; &#125; c = c.caller; &#125; &#125; return ev; &#125;&#125;; 手写事件侦听器，并要求兼容浏览器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869var eventUtil = &#123; getEvent: function(event) &#123; return event || window.event; &#125;, getTarget: function(event) &#123; return event.target || event.srcElement; &#125;, addListener: function(element, type, hander) &#123; if (element.addEventListener) &#123; element.addEventListener(type, hander, false); &#125; else if (element.attachEvent) &#123; element.attachEvent('on' + type, hander); &#125; else &#123; element['on' + type] = hander; &#125; &#125;, removeListener: function(element, type, hander) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, hander, false); &#125; else if (element.deattachEvent) &#123; element.detachEvent(type, hander); &#125; else &#123; element['on' + type] = null; &#125; &#125;, preventDefault: function(event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, stopPropagation: function(event) &#123; if (event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; &#125;&#125;;// 调用(function() &#123; var btn = document.getElementById(\"btn\"); var link = document.getElementsByTagName(\"a\")[0]; eventUtil.addListener(btn, \"click\", function(event) &#123; var event = eventUtil.getEvent(event); var target = eventUtil.getTarget(event); alert(event.type); alert(target); eventUtil.stopPropagation(event); &#125;); eventUtil.addListener(link, \"click\", function(event) &#123; alert(\"prevent default event\"); var event = eventUtil.getEvent(event); eventUtil.preventDefault(event); &#125;); eventUtil.addListener(document.body, \"click\", function() &#123; alert(\"click body\"); &#125;);&#125;)(); 写一个通用的事件侦听器函数。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// event(事件)工具集，来源：github.com/markyunmarkyun.Event = &#123; // 页面加载完成后 readyEvent : function(fn) &#123; if (fn==null) &#123; fn=document; &#125; var oldonload = window.onload; if (typeof window.onload != &apos;function&apos;) &#123; window.onload = fn; &#125; else &#123; window.onload = function() &#123; oldonload(); fn(); &#125;; &#125; &#125;, // 视能力分别使用dom0||dom2||IE方式 来绑定事件 // 参数： 操作的元素,事件名称 ,事件处理程序 addEvent : function(element, type, handler) &#123; if (element.addEventListener) &#123; //事件类型、需要执行的函数、是否捕捉 element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent(&apos;on&apos; + type, function() &#123; handler.call(element); &#125;); &#125; else &#123; element[&apos;on&apos; + type] = handler; &#125; &#125;, // 移除事件 removeEvent : function(element, type, handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.datachEvent) &#123; element.detachEvent(&apos;on&apos; + type, handler); &#125; else &#123; element[&apos;on&apos; + type] = null; &#125; &#125;, // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获) stopPropagation : function(ev) &#123; if (ev.stopPropagation) &#123; ev.stopPropagation(); &#125; else &#123; ev.cancelBubble = true; &#125; &#125;, // 取消事件的默认行为 preventDefault : function(event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, // 获取事件目标 getTarget : function(event) &#123; return event.target || event.srcElement; &#125;, // 获取event对象的引用，取到事件的所有信息，确保随时能使用event； getEvent : function(e) &#123; var ev = e || window.event; if (!ev) &#123; var c = this.getEvent.caller; while (c) &#123; ev = c.arguments[0]; if (ev &amp;&amp; Event == ev.constructor) &#123; break; &#125; c = c.caller; &#125; &#125; return ev; &#125;&#125;; 手写事件模型1234567891011121314151617181920212223242526272829303132333435363738394041424344var Event = (function () &#123; var list = &#123;&#125;, bind, trigger, remove; bind = function (key, fn) &#123; if (!list[key]) &#123; list[key] = []; &#125; list[key].push(fn); &#125;; trigger = function () &#123; var key = Array.prototype.shift.call(arguments); var fns = list[key]; if (!fns || fns.length === 0) &#123; return false; &#125; for (var i = 0, fn; fn = fns[i++];) &#123; fn.apply(this, arguments); &#125; &#125;; remove = function (key, fn) &#123; var fns = list[key]; if (!fns) &#123; return false; &#125; if (!fn) &#123; fns &amp; (fns.length = 0); &#125; else &#123; for (var i = fns.length - 1; i &gt;= 0; i--) &#123; var _fn = fns[i]; if (_fn === fn) &#123; fns.splice(i, 1); &#125; &#125; &#125; &#125;; return &#123; bind: bind, trigger: trigger, remove: remove &#125;&#125;)();// 调用Event.bind('Hit', function()&#123; console.log('bind event'); &#125;); // 绑定事件Event.trigger(\"Hit\", function()&#123; console.log('trigger event'); &#125;); // 触发事件 手写事件代理，并要求兼容浏览器12345678910111213141516171819202122232425262728293031323334353637function delegateEvent(parentEl, selector, type, fn) &#123; var handler = function(e)&#123; var e = e || window.event; var target = e.target || e.srcElement; if (matchSelector(target, selector)) &#123; if(fn) &#123; fn.call(target, e); &#125; &#125; &#125;; if(parentEl.addEventListener)&#123; parentEl.addEventListener(type, handler); &#125;else&#123; parentEl.attachEvent(\"on\" + type, handler); &#125;&#125;/** * support #id, tagName, .className */function matchSelector(ele, selector) &#123; // if use id if (selector.charAt(0) === \"#\") &#123; return ele.id === selector.slice(1); &#125; // if use class if (selector.charAt(0) === \".\") &#123; return (\" \" + ele.className + \" \").indexOf(\" \" + selector.slice(1) + \" \") != -1; &#125; // if use tagName return ele.tagName.toLowerCase() === selector.toLowerCase();&#125;// 调用var box = document.getElementById(\"box\");delegateEvent(box, \"a\", \"click\", function()&#123; console.log(this.href);&#125;) 手写事件触发器，并要求兼容浏览器12345678910var fireEvent = function(element, event)&#123; if (document.createEventObject)&#123; var mockEvent = document.createEventObject(); return element.fireEvent('on' + event, mockEvent) &#125;else&#123; var mockEvent = document.createEvent('HTMLEvents'); mockEvent.initEvent(event, true, true); return element.dispatchEvent(mockEvent); &#125;&#125; 手写 Function.bind 函数123456789101112131415161718192021222324252627282930313233if (!Function.prototype.bind) &#123; Function.prototype.bind = function (oThis) &#123; if (typeof this !== \"function\") &#123; throw new TypeError(\"'this' is not function\"); &#125; // bind's default arguments, array without first element // first part arguments for the function var aBindArgs = Array.prototype.slice.call(arguments, 1); var fToBind = this; // the function will be binding var fNOP = function () &#123;&#125;; var fBound = function () &#123; // target this will be binding var oThis = this instanceof fNOP ? this : oThis || this; // last part arguments for the function var aCallArgs = Array.prototype.slice.call(arguments); // complete arguments for the function var aFuncArgs = aBindArgs.concat(aCallArgs); return fToBind.apply(oThis, aFuncArgs); &#125;; // fBound extends fToBind fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; &#125;;&#125;// 调用var add = function(a, b, c)&#123; return a + b + c;&#125;;var newAdd = add.bind(null, 1, 2);var result = newAdd(3); JS实现数组去重方法总结(六种方法)方法一：双层循环，外层循环元素，内层循环时比较值 如果有相同的值则跳过，不相同则push进数组 123456789101112131415161718Array.prototype.distinct = function()&#123; var arr = this, result = [], i, j, len = arr.length; for(i = 0; i &lt; len; i++)&#123; for(j = i + 1; j &lt; len; j++)&#123; if(arr[i] === arr[j])&#123; j = ++i; &#125; &#125; result.push(arr[i]); &#125; return result;&#125;var arra = [1,2,3,4,4,1,1,2,1,1,1];arra.distinct(); //返回[3,4,2,1] 方法二：利用splice直接在原数组进行操作双层循环，外层循环元素，内层循环时比较值 值相同时，则删去这个值 注意点:删除元素之后，需要将数组的长度也减1. 12345678910111213141516171819Array.prototype.distinct = function ()&#123; var arr = this, i, j, len = arr.length; for(i = 0; i &lt; len; i++)&#123; for(j = i + 1; j &lt; len; j++)&#123; if(arr[i] == arr[j])&#123; arr.splice(j,1); len--; j--; &#125; &#125; &#125; return arr;&#125;;var a = [1,2,3,4,5,6,5,3,2,4,56,4,1,2,1,1,1,1,1,1,];var b = a.distinct();console.log(b.toString()); //1,2,3,4,5,6,56 优点：简单易懂 缺点：占用内存高，速度慢 方法三：利用对象的属性不能相同的特点进行去重1234567891011121314151617Array.prototype.distinct = function ()&#123; var arr = this, i, obj = &#123;&#125;, result = [], len = arr.length; for(i = 0; i&lt; arr.length; i++)&#123; if(!obj[arr[i]])&#123; //如果能查找到，证明数组元素重复了 obj[arr[i]] = 1; result.push(arr[i]); &#125; &#125; return result;&#125;;var a = [1,2,3,4,5,6,5,3,2,4,56,4,1,2,1,1,1,1,1,1,];var b = a.distinct();console.log(b.toString()); //1,2,3,4,5,6,56 方法四：数组递归去重运用递归的思想 先排序，然后从最后开始比较，遇到相同，则删除 1234567891011121314151617181920Array.prototype.distinct = function ()&#123; var arr = this, len = arr.length; arr.sort(function(a,b)&#123; //对数组进行排序才能方便比较 return a - b; &#125;) function loop(index)&#123; if(index &gt;= 1)&#123; if(arr[index] === arr[index-1])&#123; arr.splice(index,1); &#125; loop(index - 1); //递归loop函数进行去重 &#125; &#125; loop(len-1); return arr;&#125;;var a = [1,2,3,4,5,6,5,3,2,4,56,4,1,2,1,1,1,1,1,1,56,45,56];var b = a.distinct();console.log(b.toString()); //1,2,3,4,5,6,45,56 方法五：利用indexOf以及forEach123456789101112131415Array.prototype.distinct = function ()&#123; var arr = this, result = [], len = arr.length; arr.forEach(function(v, i ,arr)&#123; //这里利用map，filter方法也可以实现 var bool = arr.indexOf(v,i+1); //从传入参数的下一个索引值开始寻找是否存在重复 if(bool === -1)&#123; result.push(v); &#125; &#125;) return result;&#125;;var a = [1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,3,3,3,3,3,3,3,2,3,3,2,2,1,23,1,23,2,3,2,3,2,3];var b = a.distinct();console.log(b.toString()); //1,23,2,3 方法六：利用ES6的setSet数据结构，它类似于数组，其成员的值都是唯一的。 利用Array.from将Set结构转换成数组 1234function dedupe(array)&#123; return Array.from(new Set(array));&#125;dedupe([1,1,2,3]) //[1,2,3] 拓展运算符(…)内部使用for…of循环 123let arr = [1,2,3,3];let resultarr = [...new Set(arr)]; console.log(resultarr); //[1,2,3] 合并数组并去重的方法一、concat()方法思路：concat() 方法将传入的数组或非数组值与原数组合并,组成一个新的数组并返回。该方法会产生一个新的数组。 12345function concatArr(arr1, arr2)&#123; var arr = arr1.concat(arr2); arr = unique1(arr);//再引用上面的任意一个去重方法 return arr;&#125; 二、Array.prototype.push.apply()思路：该方法优点是不会产生一个新的数组。 12345678910var a = [1, 2, 3];var b = [4, 5, 6];Array.prototype.push.apply(a, b);//a=[1,2,3,4,5,6]//等效于:a.push.apply(a, b);//也等效于[].push.apply(a, b); function concatArray(arr1,arr2)&#123; Array.prototype.push.apply(arr1, arr2); arr1 = unique1(arr1); return arr1;&#125; 手写数组去重12345678910111213141516var arr = [1, 2, 3, 3, 4, 4, 5, 5, 6, 1, 9, 3, 25, 4];function deRepeat() &#123; var newArr = []; var obj = &#123;&#125;; var index = 0; var l = arr.length; for (var i = 0; i &lt; l; i++) &#123; if (obj[arr[i]] == undefined) &#123; obj[arr[i]] = 1; newArr[index++] = arr[i]; &#125; else if (obj[arr[i]] == 1) continue; &#125; return newArr;&#125;var newArr2 = deRepeat(arr);alert(newArr2); //输出1,2,3,4,5,6,9,25 12345678910111213141516171819202122232425262728293031323334353637383940414243Array.prototype.unique = function() &#123; return [...new Set(this)];&#125;;// 调用[1, 2, 3, 3, 2, 1].unique();function unique1(arr)&#123; var hash = &#123;&#125;, result = []; for(var i=0, len=arr.length; i&lt;len; i++)&#123; if(! hash[arr[i]])&#123; result.push(arr[i]); hash[arr[i]] = true; &#125; &#125; return result;&#125;// 调用unique1([1, 2, 3, 3, 2, 1]);Array.prototype.unique2 = function()&#123; this.sort(); var result = [this[0]]; var len = this.length; for(var i = 0; i &lt; len; i++)&#123; if(this[i] !== result[result.length - 1])&#123; result.push(this[i]); &#125; &#125; return result;&#125;// 调用[1, 2, 3, 3, 2, 1].unique2();function unique3(arr)&#123; var result = []; for(var i=0; i&lt;arr.length; i++)&#123; if(result.indexOf(arr[i]) == -1)&#123; result.push(arr[i]); &#125; &#125; return result;&#125;// 调用unique3([1, 2, 3, 3, 2, 1]); 1234567891011121314151617//数组去重:Array.prototype. myUnique = function myUnique()&#123; //this是当前要操作的数组 var obj = &#123;&#125;; for( var i = 0; i &lt; this.length; i ++)&#123; var cur = this[i]; if (obj[cur] == cur)&#123; this[i] = this[ this.length - 1]; this.length --; i --; //防止数组塌陷 continue; &#125; obj[cur] = cur; &#125; obj = null; return this; //为了实现链式写法&#125;; 将url的查询参数解析成字典对象12345678910111213function parseQuery(url) &#123; url = url == null ? window.location.href : url; var search = url.substring(url.lastIndexOf(\"?\") + 1); var hash = &#123;&#125;; var reg = /([^?&amp;=]+)=([^?&amp;=]*)/g; search.replace(reg, function (match, $1, $2) &#123; var name = decodeURIComponent($1); var val = decodeURIComponent($2); hash[name] = String(val); return match; &#125;); return hash;&#125; 封装函数节流函数12345678910111213141516171819202122var throttle = function(fn, delay, mustRunDelay)&#123; var timer = null; var t_start; return function()&#123; var context = this, args = arguments, t_curr = +new Date(); clearTimeout(timer); if(!t_start)&#123; t_start = t_curr; &#125; if(t_curr - t_start &gt;= mustRunDelay)&#123; fn.apply(context, args); t_start = t_curr; &#125; else &#123; timer = setTimeout(function()&#123; fn.apply(context, args); &#125;, delay); &#125; &#125;;&#125;;// 调用（两次间隔50ms内连续触发不执行，但每累计100ms至少执行一次window.onresize = throttle(myFunc, 50, 100); 用JS实现千位分隔符12345678910111213141516171819function test1(num)&#123; var str = (+ num) + ''; var len = str.length; if(len &lt;= 3) return str; num = ''; while(len &gt; 3)&#123; len -= 3; num = ',' + str.substr(len, 3) + num; &#125; return str.substr(0, len) + num;&#125;function test2(num)&#123; // ?= 正向匹配:匹配位置 // ?! 正向不匹配:排除位置 var str = (+num).toString(); var reg = /(?=(?!\\b)(\\d&#123;3&#125;)+$)/g; return str.replace(reg, ',');&#125; 深克隆（deepclone）简单版： 1const newObj = JSON.parse(JSON.stringify(oldObj)); 局限性： 他无法实现对函数 、RegExp等特殊对象的克隆 会抛弃对象的constructor,所有的构造函数会指向Object 对象有循环引用,会报错 面试版: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * deep clone * @param &#123;[type]&#125; parent object 需要进行克隆的对象 * @return &#123;[type]&#125; 深克隆后的对象 */const clone = parent =&gt; &#123; // 判断类型 const isType = (obj, type) =&gt; &#123; if (typeof obj !== &quot;object&quot;) return false; const typeString = Object.prototype.toString.call(obj); let flag; switch (type) &#123; case &quot;Array&quot;: flag = typeString === &quot;[object Array]&quot;; break; case &quot;Date&quot;: flag = typeString === &quot;[object Date]&quot;; break; case &quot;RegExp&quot;: flag = typeString === &quot;[object RegExp]&quot;; break; default: flag = false; &#125; return flag; &#125;; // 处理正则 const getRegExp = re =&gt; &#123; var flags = &quot;&quot;; if (re.global) flags += &quot;g&quot;; if (re.ignoreCase) flags += &quot;i&quot;; if (re.multiline) flags += &quot;m&quot;; return flags; &#125;; // 维护两个储存循环引用的数组 const parents = []; const children = []; const _clone = parent =&gt; &#123; if (parent === null) return null; if (typeof parent !== &quot;object&quot;) return parent; let child, proto; if (isType(parent, &quot;Array&quot;)) &#123; // 对数组做特殊处理 child = []; &#125; else if (isType(parent, &quot;RegExp&quot;)) &#123; // 对正则对象做特殊处理 child = new RegExp(parent.source, getRegExp(parent)); if (parent.lastIndex) child.lastIndex = parent.lastIndex; &#125; else if (isType(parent, &quot;Date&quot;)) &#123; // 对Date对象做特殊处理 child = new Date(parent.getTime()); &#125; else &#123; // 处理对象原型 proto = Object.getPrototypeOf(parent); // 利用Object.create切断原型链 child = Object.create(proto); &#125; // 处理循环引用 const index = parents.indexOf(parent); if (index != -1) &#123; // 如果父数组存在本对象,说明之前已经被引用过,直接返回此对象 return children[index]; &#125; parents.push(parent); children.push(child); for (let i in parent) &#123; // 递归 child[i] = _clone(parent[i]); &#125; return child; &#125;; return _clone(parent);&#125;; 局限性: 一些特殊情况没有处理: 例如Buffer对象、Promise、Set、Map 另外对于确保没有循环引用的对象，我们可以省去对循环引用的特殊处理，因为这很消耗时间 原理详解实现深克隆 实现Event(event bus)event bus既是node中各个模块的基石，又是前端组件通信的依赖手段之一，同时涉及了订阅-发布设计模式，是非常重要的基础。 简单版： 12345678910111213141516171819202122232425262728class EventEmeitter &#123; constructor() &#123; this._events = this._events || new Map(); // 储存事件/回调键值对 this._maxListeners = this._maxListeners || 10; // 设立监听上限 &#125;&#125;// 触发名为type的事件EventEmeitter.prototype.emit = function(type, ...args) &#123; let handler; // 从储存事件键值对的this._events中获取对应事件回调函数 handler = this._events.get(type); if (args.length &gt; 0) &#123; handler.apply(this, args); &#125; else &#123; handler.call(this); &#125; return true;&#125;;// 监听名为type的事件EventEmeitter.prototype.addListener = function(type, fn) &#123; // 将type事件以及对应的fn函数放入this._events中储存 if (!this._events.get(type)) &#123; this._events.set(type, fn); &#125;&#125;; 面试版： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495class EventEmeitter &#123; constructor() &#123; this._events = this._events || new Map(); // 储存事件/回调键值对 this._maxListeners = this._maxListeners || 10; // 设立监听上限 &#125;&#125;// 触发名为type的事件EventEmeitter.prototype.emit = function(type, ...args) &#123; let handler; // 从储存事件键值对的this._events中获取对应事件回调函数 handler = this._events.get(type); if (args.length &gt; 0) &#123; handler.apply(this, args); &#125; else &#123; handler.call(this); &#125; return true;&#125;;// 监听名为type的事件EventEmeitter.prototype.addListener = function(type, fn) &#123; // 将type事件以及对应的fn函数放入this._events中储存 if (!this._events.get(type)) &#123; this._events.set(type, fn); &#125;&#125;;// 触发名为type的事件EventEmeitter.prototype.emit = function(type, ...args) &#123; let handler; handler = this._events.get(type); if (Array.isArray(handler)) &#123; // 如果是一个数组说明有多个监听者,需要依次此触发里面的函数 for (let i = 0; i &lt; handler.length; i++) &#123; if (args.length &gt; 0) &#123; handler[i].apply(this, args); &#125; else &#123; handler[i].call(this); &#125; &#125; &#125; else &#123; // 单个函数的情况我们直接触发即可 if (args.length &gt; 0) &#123; handler.apply(this, args); &#125; else &#123; handler.call(this); &#125; &#125; return true;&#125;;// 监听名为type的事件EventEmeitter.prototype.addListener = function(type, fn) &#123; const handler = this._events.get(type); // 获取对应事件名称的函数清单 if (!handler) &#123; this._events.set(type, fn); &#125; else if (handler &amp;&amp; typeof handler === &quot;function&quot;) &#123; // 如果handler是函数说明只有一个监听者 this._events.set(type, [handler, fn]); // 多个监听者我们需要用数组储存 &#125; else &#123; handler.push(fn); // 已经有多个监听者,那么直接往数组里push函数即可 &#125;&#125;;EventEmeitter.prototype.removeListener = function(type, fn) &#123; const handler = this._events.get(type); // 获取对应事件名称的函数清单 // 如果是函数,说明只被监听了一次 if (handler &amp;&amp; typeof handler === &quot;function&quot;) &#123; this._events.delete(type, fn); &#125; else &#123; let postion; // 如果handler是数组,说明被监听多次要找到对应的函数 for (let i = 0; i &lt; handler.length; i++) &#123; if (handler[i] === fn) &#123; postion = i; &#125; else &#123; postion = -1; &#125; &#125; // 如果找到匹配的函数,从数组中清除 if (postion !== -1) &#123; // 找到数组对应的位置,直接清除此回调 handler.splice(postion, 1); // 如果清除后只有一个函数,那么取消数组,以函数形式保存 if (handler.length === 1) &#123; this._events.set(type, handler[0]); &#125; &#125; else &#123; return this; &#125; &#125;&#125;; 实现instanceOf12345678910111213// 模拟 instanceoffunction instance_of(L, R) &#123; //L 表示左表达式，R 表示右表达式 var O = R.prototype; // 取 R 的显示原型 L = L.__proto__; // 取 L 的隐式原型 while (true) &#123; if (L === null) return false; if (O === L) // 这里重点：当 O 严格等于 L 时，返回 true return true; L = L.__proto__; &#125;&#125; 实现一个callcall做了什么: 将函数设为对象的属性 执行&amp;删除这个函数 指定this到函数并传入给定参数执行函数 如果不传入参数，默认指向为 window 1234567891011121314// 模拟 call bar.mycall(null);//实现一个call方法：Function.prototype.myCall = function(context) &#123; //此处没有考虑context非object情况 context.fn = this; let args = []; for (let i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push(arguments[i]); &#125; context.fn(...args); let result = context.fn(...args); delete context.fn; return result;&#125;; 具体实现参考JavaScript深入之call和apply的模拟实现 实现apply方法apply原理与call很相似，不多赘述 12345678910111213141516171819// 模拟 applyFunction.prototype.myapply = function(context, arr) &#123; var context = Object(context) || window; context.fn = this; var result; if (!arr) &#123; result = context.fn(); &#125; else &#123; var args = []; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; args.push(&quot;arr[&quot; + i + &quot;]&quot;); &#125; result = eval(&quot;context.fn(&quot; + args + &quot;)&quot;); &#125; delete context.fn; return result;&#125;; 实现bind实现bind要做什么 返回一个函数，绑定this，传递预置参数 bind返回的函数可以作为构造函数使用。故作为构造函数时应使得this失效，但是传入的参数依然有效 123456789101112131415161718192021222324252627282930313233// mdn的实现if (!Function.prototype.bind) &#123; Function.prototype.bind = function(oThis) &#123; if (typeof this !== &apos;function&apos;) &#123; // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError(&apos;Function.prototype.bind - what is trying to be bound is not callable&apos;); &#125; var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function() &#123;&#125;, fBound = function() &#123; // this instanceof fBound === true时,说明返回的fBound被当做new的构造函数调用 return fToBind.apply(this instanceof fBound ? this : oThis, // 获取调用时(fBound)的传参.bind 返回的函数入参往往是这么传递的 aArgs.concat(Array.prototype.slice.call(arguments))); &#125;; // 维护原型关系 if (this.prototype) &#123; // Function.prototype doesn&apos;t have a prototype property fNOP.prototype = this.prototype; &#125; // 下行的代码使fBound.prototype是fNOP的实例,因此 // 返回的fBound若作为new的构造函数,new生成的新对象作为this传入fBound,新对象的__proto__就是fNOP的实例 fBound.prototype = new fNOP(); return fBound; &#125;;&#125; 详解请移步JavaScript深入之bind的模拟实现 #12 模拟Object.createObject.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。 12345678// 模拟 Object.createfunction create(proto) &#123; function F() &#123;&#125; F.prototype = proto; return new F();&#125; 实现类的继承类的继承在几年前是重点内容，有n种继承方式各有优劣，es6普及后越来越不重要，那么多种写法有点『回字有四样写法』的意思，如果还想深入理解的去看红宝书即可，我们目前只实现一种最理想的继承方式。 123456789101112131415161718192021222324252627282930function Parent(name) &#123; this.parent = name&#125;Parent.prototype.say = function() &#123; console.log(`$&#123;this.parent&#125;: 你打篮球的样子像kunkun`)&#125;function Child(name, parent) &#123; // 将父类的构造函数绑定在子类上 Parent.call(this, parent) this.child = name&#125;/** 1. 这一步不用Child.prototype =Parent.prototype的原因是怕共享内存，修改父类原型对象就会影响子类 2. 不用Child.prototype = new Parent()的原因是会调用2次父类的构造方法（另一次是call），会存在一份多余的父类实例属性3. Object.create是创建了父类原型的副本，与父类原型完全隔离*/Child.prototype = Object.create(Parent.prototype);Child.prototype.say = function() &#123; console.log(`$&#123;this.parent&#125;好，我是练习时长两年半的$&#123;this.child&#125;`);&#125;// 注意记得把子类的构造指向子类本身Child.prototype.constructor = Child;var parent = new Parent(&apos;father&apos;);parent.say() // father: 你打篮球的样子像kunkunvar child = new Child(&apos;cxk&apos;, &apos;father&apos;);child.say() // father好，我是练习时长两年半的cxk 实现JSON.parse12var json = &apos;&#123;&quot;name&quot;:&quot;cxk&quot;, &quot;age&quot;:25&#125;&apos;;var obj = eval(&quot;(&quot; + json + &quot;)&quot;); 此方法属于黑魔法，极易容易被xss攻击，还有一种new Function大同小异。 简单的教程看这个半小时实现一个 JSON 解析器 实现Promise 我很早之前实现过一版，而且注释很多，但是居然找不到了,这是在网络上找了一版带注释的，目测没有大问题，具体过程可以看这篇史上最易读懂的 Promise/A+ 完全实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174var PromisePolyfill = (function () &#123; // 和reject不同的是resolve需要尝试展开thenable对象 function tryToResolve (value) &#123; if (this === value) &#123; // 主要是防止下面这种情况 // let y = new Promise(res =&gt; setTimeout(res(y))) throw TypeError(&apos;Chaining cycle detected for promise!&apos;) &#125; // 根据规范2.32以及2.33 对对象或者函数尝试展开 // 保证S6之前的 polyfill 也能和ES6的原生promise混用 if (value !== null &amp;&amp; (typeof value === &apos;object&apos; || typeof value === &apos;function&apos;)) &#123; try &#123; // 这里记录这次then的值同时要被try包裹 // 主要原因是 then 可能是一个getter, 也也就是说 // 1. value.then可能报错 // 2. value.then可能产生副作用(例如多次执行可能结果不同) var then = value.then // 另一方面, 由于无法保证 then 确实会像预期的那样只调用一个onFullfilled / onRejected // 所以增加了一个flag来防止resolveOrReject被多次调用 var thenAlreadyCalledOrThrow = false if (typeof then === &apos;function&apos;) &#123; // 是thenable 那么尝试展开 // 并且在该thenable状态改变之前this对象的状态不变 then.bind(value)( // onFullfilled function (value2) &#123; if (thenAlreadyCalledOrThrow) return thenAlreadyCalledOrThrow = true tryToResolve.bind(this, value2)() &#125;.bind(this), // onRejected function (reason2) &#123; if (thenAlreadyCalledOrThrow) return thenAlreadyCalledOrThrow = true resolveOrReject.bind(this, &apos;rejected&apos;, reason2)() &#125;.bind(this) ) &#125; else &#123; // 拥有then 但是then不是一个函数 所以也不是thenable resolveOrReject.bind(this, &apos;resolved&apos;, value)() &#125; &#125; catch (e) &#123; if (thenAlreadyCalledOrThrow) return thenAlreadyCalledOrThrow = true resolveOrReject.bind(this, &apos;rejected&apos;, e)() &#125; &#125; else &#123; // 基本类型 直接返回 resolveOrReject.bind(this, &apos;resolved&apos;, value)() &#125; &#125; function resolveOrReject (status, data) &#123; if (this.status !== &apos;pending&apos;) return this.status = status this.data = data if (status === &apos;resolved&apos;) &#123; for (var i = 0; i &lt; this.resolveList.length; ++i) &#123; this.resolveList[i]() &#125; &#125; else &#123; for (i = 0; i &lt; this.rejectList.length; ++i) &#123; this.rejectList[i]() &#125; &#125; &#125; function Promise (executor) &#123; if (!(this instanceof Promise)) &#123; throw Error(&apos;Promise can not be called without new !&apos;) &#125; if (typeof executor !== &apos;function&apos;) &#123; // 非标准 但与Chrome谷歌保持一致 throw TypeError(&apos;Promise resolver &apos; + executor + &apos; is not a function&apos;) &#125; this.status = &apos;pending&apos; this.resolveList = [] this.rejectList = [] try &#123; executor(tryToResolve.bind(this), resolveOrReject.bind(this, &apos;rejected&apos;)) &#125; catch (e) &#123; resolveOrReject.bind(this, &apos;rejected&apos;, e)() &#125; &#125; Promise.prototype.then = function (onFullfilled, onRejected) &#123; // 返回值穿透以及错误穿透, 注意错误穿透用的是throw而不是return，否则的话 // 这个then返回的promise状态将变成resolved即接下来的then中的onFullfilled // 会被调用, 然而我们想要调用的是onRejected if (typeof onFullfilled !== &apos;function&apos;) &#123; onFullfilled = function (data) &#123; return data &#125; &#125; if (typeof onRejected !== &apos;function&apos;) &#123; onRejected = function (reason) &#123; throw reason &#125; &#125; var executor = function (resolve, reject) &#123; setTimeout(function () &#123; try &#123; // 拿到对应的handle函数处理this.data // 并以此为依据解析这个新的Promise var value = this.status === &apos;resolved&apos; ? onFullfilled(this.data) : onRejected(this.data) resolve(value) &#125; catch (e) &#123; reject(e) &#125; &#125;.bind(this)) &#125; // then 接受两个函数返回一个新的Promise // then 自身的执行永远异步与onFullfilled/onRejected的执行 if (this.status !== &apos;pending&apos;) &#123; return new Promise(executor.bind(this)) &#125; else &#123; // pending return new Promise(function (resolve, reject) &#123; this.resolveList.push(executor.bind(this, resolve, reject)) this.rejectList.push(executor.bind(this, resolve, reject)) &#125;.bind(this)) &#125; &#125; // for prmise A+ test Promise.deferred = Promise.defer = function () &#123; var dfd = &#123;&#125; dfd.promise = new Promise(function (resolve, reject) &#123; dfd.resolve = resolve dfd.reject = reject &#125;) return dfd &#125; // for prmise A+ test if (typeof module !== &apos;undefined&apos;) &#123; module.exports = Promise &#125; return Promise&#125;)()PromisePolyfill.all = function (promises) &#123; return new Promise((resolve, reject) =&gt; &#123; const result = [] let cnt = 0 for (let i = 0; i &lt; promises.length; ++i) &#123; promises[i].then(value =&gt; &#123; cnt++ result[i] = value if (cnt === promises.length) resolve(result) &#125;, reject) &#125; &#125;)&#125;PromisePolyfill.race = function (promises) &#123; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; promises.length; ++i) &#123; promises[i].then(resolve, reject) &#125; &#125;)&#125; 解析 URL Params 为对象1234567891011121314151617181920212223242526272829303132let url = &apos;http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled&apos;;parseParam(url)/* 结果&#123; user: &apos;anonymous&apos;, id: [ 123, 456 ], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型 city: &apos;北京&apos;, // 中文需解码 enabled: true, // 未指定值得 key 约定为 true&#125;*/function parseParam(url) &#123; const paramsStr = /.+\\?(.+)$/.exec(url)[1]; // 将 ? 后面的字符串取出来 const paramsArr = paramsStr.split(&apos;&amp;&apos;); // 将字符串以 &amp; 分割后存到数组中 let paramsObj = &#123;&#125;; // 将 params 存到对象中 paramsArr.forEach(param =&gt; &#123; if (/=/.test(param)) &#123; // 处理有 value 的参数 let [key, val] = param.split(&apos;=&apos;); // 分割 key 和 value val = decodeURIComponent(val); // 解码 val = /^\\d+$/.test(val) ? parseFloat(val) : val; // 判断是否转为数字 if (paramsObj.hasOwnProperty(key)) &#123; // 如果对象有 key，则添加一个值 paramsObj[key] = [].concat(paramsObj[key], val); &#125; else &#123; // 如果对象没有这个 key，创建 key 并设置值 paramsObj[key] = val; &#125; &#125; else &#123; // 处理没有 value 的参数 paramsObj[param] = true; &#125; &#125;) return paramsObj;&#125; 模板引擎实现123456789101112131415let template = &apos;我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;&apos;;let data = &#123; name: &apos;姓名&apos;, age: 18&#125;render(template, data); // 我是姓名，年龄18，性别undefinedfunction render(template, data) &#123; const reg = /\\&#123;\\&#123;(\\w+)\\&#125;\\&#125;/; // 模板字符串正则 if (reg.test(template)) &#123; // 判断模板里是否有模板字符串 const name = reg.exec(template)[1]; // 查找当前模板里第一个模板字符串的字段 template = template.replace(reg, data[name]); // 将第一个模板字符串渲染 return render(template, data); // 递归的渲染并返回渲染后的结构 &#125; return template; // 如果模板没有模板字符串直接返回&#125; 转化为驼峰命名12345678var s1 = &quot;get-element-by-id&quot;// 转化为 getElementByIdvar f = function(s) &#123; return s.replace(/-\\w/g, function(x) &#123; return x.slice(1).toUpperCase(); &#125;)&#125; 查找字符串中出现最多的字符和个数例: abbcccddddd -&gt; 字符最多的是d，出现了5次 1234567891011121314151617let str = &quot;abcabcabcbbccccc&quot;;let num = 0;let char = &apos;&apos;; // 使其按照一定的次序排列str = str.split(&apos;&apos;).sort().join(&apos;&apos;);// &quot;aaabbbbbcccccccc&quot;// 定义正则表达式let re = /(\\w)\\1+/g;str.replace(re,($0,$1) =&gt; &#123; if(num &lt; $0.length)&#123; num = $0.length; char = $1; &#125;&#125;);console.log(`字符最多的是$&#123;char&#125;，出现了$&#123;num&#125;次`); 字符串查找请使用最基本的遍历来实现判断字符串 a 是否被包含在字符串 b 中，并返回第一次出现的位置（找不到返回 -1）。 1234567891011121314151617181920a=&apos;34&apos;;b=&apos;1234567&apos;; // 返回 2a=&apos;35&apos;;b=&apos;1234567&apos;; // 返回 -1a=&apos;355&apos;;b=&apos;12354355&apos;; // 返回 5isContain(a,b);function isContain(a, b) &#123; for (let i in b) &#123; if (a[0] === b[i]) &#123; let tmp = true; for (let j in a) &#123; if (a[j] !== b[~~i + ~~j]) &#123; tmp = false; &#125; &#125; if (tmp) &#123; return i; &#125; &#125; &#125; return -1;&#125; 实现千位分隔符12345678910// 保留三位小数parseToMoney(1234.56); // return &apos;1,234.56&apos;parseToMoney(123456789); // return &apos;123,456,789&apos;parseToMoney(1087654.321); // return &apos;1,087,654.321&apos;function parseToMoney(num) &#123; num = parseFloat(num.toFixed(3)); let [integer, decimal] = String.prototype.split.call(num, &apos;.&apos;); integer = integer.replace(/\\d(?=(\\d&#123;3&#125;)+$)/g, &apos;$&amp;,&apos;); return integer + &apos;.&apos; + (decimal ? decimal : &apos;&apos;);&#125; 正则表达式(运用了正则的前向声明和反前向声明): 12345function parseToMoney(str)&#123; // 仅仅对位置进行匹配 let re = /(?=(?!\\b)(\\d&#123;3&#125;)+$)/g; return str.replace(re,&apos;,&apos;); &#125; ES6箭头函数问题答案： 第 1 题 在使用=&gt;定义函数的时候，this 的指向是定义时所在的对象，而不是使用时所在的对象； 12345678910111213class Animal &#123; constructor() &#123; this.type = \"animal\"; &#125; say(val) &#123; setTimeout(function() &#123; console.log(this); //window console.log(this.type + \" says \" + val); &#125;, 1000); &#125;&#125;var animal = new Animal();animal.say(\"hi\"); //undefined says hi 12345678910111213class Animal &#123; constructor() &#123; this.type = \"animal\"; &#125; say(val) &#123; setTimeout(() =&gt; &#123; console.log(this); //Animal console.log(this.type + \" says \" + val); &#125;, 1000); &#125;&#125;var animal = new Animal();animal.say(\"hi\"); //animal says hi 第二题： 箭头函数里面根本没有自己的 this，而是引用外层的 this 123456789101112131415// ES6function foo() &#123; setTimeout(() =&gt; &#123; console.log(\"id:\", this.id); &#125;, 100);&#125;// 转成ES5function foo() &#123; var _this = this; setTimeout(function() &#123; console.log(\"id:\", _this.id); &#125;, 100);&#125; this 面试题123456this指向了谁？看函数在执行的时候是如何调用的，1 如果这个函数是用普通函数调用模式来进行调用，它内部的this指向了window2如果一个函数在调用的时候是通过对象方法模式来进行调用，则它内部的this就是我们的对象3 如果一个函数在调用的时候通过构造函数模式调用，则它内部的this指向了生成的实例4 如果这个函数是通过方法借用模式调用，则这个函数内部的this就是我们手动指定this。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183//第1题function Fn() &#123; console.log(this);&#125;Fn(); //window 普通函数调用模式new Fn(); //&#123;&#125; 构造函数调用模式Fn.apply(Fn); // Fn的函数体 方法借用模式//第2题var o = &#123; f: function() &#123; console.log(this); &#125;, 2: function() &#123; console.log(this); console.log(this.__proto__ === o[2].prototype); &#125;&#125;;o.f(); //o 对象调用模式o[2](); //o 对象调用模式new o[2](); //存疑，存在着优先级的问题 &#123;&#125; 通过构造函数模式进行调用o.f.call([1, 2]); //[1,2] call方法进行方法借用。o[2].call([1, 2, 3, 4]); // [1,2,3,4] call方法进行方法借用//第3题var name = \"out\";var obj = &#123; name: \"in\", prop: &#123; name: \"inside\", getName: function() &#123; return this.name; &#125; &#125;&#125;;console.log(obj.prop.getName()); //对象调用模式来进行调用 obj.prop.name 'inside'var test = obj.prop.getName; // 把test这个变量指向了obj.prop.getName所在的内存地址。console.log(test()); //普通函数模式来进行调用 window 'out'console.log(obj.prop.getName.apply(window)); //方法借用模式 'out'console.log(obj.prop.getName.apply(this)); //方法借用模式 'out'console.log(this === window); //true//第4题var length = 10;function fn() &#123; console.log(this.length);&#125;var obj = &#123; length: 5, method: function(f) &#123; console.log(this); f(); // f在调用的时候是什么调用模式？普通函数调用模式 window.length 10 arguments[0](); // 通过什么模式来进行调用的。执行之前有[]和.就是对象调用模式。 //arguments是一个类数组，也就是一个对象，就是通过arguments来进行调用的 //arguments.length实参的数量。实参长度是1 //通过arguments对象进行调用，因此函数内部的this是 arguments // 如果一个函数在调用的时候它前面有call和apply那么就肯定是方法借用模式调用 arguments[0].call(this); // 调用method方法是通过obj.method 因此在这里的this就是 obj //通过call方法把fn内的this指向了obj // 输出obj.length 5 &#125;&#125;;obj.method(fn);//第5题function Foo() &#123; getName = function() &#123; console.log(1); &#125;; return this;&#125;Foo.getName = function() &#123; console.log(2);&#125;;Foo.prototype.getName = function() &#123; console.log(3);&#125;;var getName = function() &#123; console.log(4);&#125;;function getName() &#123; console.log(5);&#125;//请写出以下输出结果：Foo.getName(); //2getName(); //4Foo().getName(); //1getName(); //1new Foo.getName(); //2new Foo().getName(); //3new new Foo().getName(); //3// new Foo()创建了一个构造函数，然后这个函数再去访问getName这个函数，//对它进行调用/*console.log(new Foo().getName)*//*var o = new new Foo().getName(); // console.log(o.__proto__===Foo.prototype.getName.prototype)*///用new Foo创建出来了一个实例，然后这个实例去访问 (new Foo().getName)/*console.log(new new Foo().getName()) console.log(new Foo().getName())*//*function Foo() &#123; getName = function () &#123; console.log(1); &#125;; return this; &#125; var getName; Foo.getName = function () &#123; console.log(2); &#125;; Foo.prototype.getName = function () &#123; console.log(3); &#125;; getName = function () &#123; console.log(4); &#125;; //请写出以下输出结果： Foo.getName();// 2 getName();//4/!* Foo().getName();//!*!/ window.getName()//1 getName();//1 /!* var o = new Foo.getName();//2 console.log(o);// &#123;&#125; console.log(o.__proto__===Foo.getName.prototype)//true*!/ new Foo.getName();// 2 new Foo().getName();// new new Foo().getName();*///第6题var obj = &#123; fn: function() &#123; console.log(this); &#125;&#125;;obj.fn(); //objvar f = obj.fn;f(); //windowconsole.log(f === obj.fn); // true// f和obj.fn是同一个函数，但是他们在调用的时候使用的函数调用模式不同，因此，它们内部的this指向也就不同。// #7题var arr = [ function() &#123; console.log(this); &#125;];arr[0](); //数组本身//数组也是一个复杂数据类型，也是一个对象，那用数组去调用函数，使用的模式就是对象方法调用模式。function f() &#123; console.log(this);&#125;function fn() &#123; console.log(arguments); // 类数组，也是就一个对象 [0:function f()&#123;&#125;] console.log(this); // window arguments[0](); console.log(arguments[0]); //内部的this就是arguments // 通过arguments对f这个方法进行调用，使用的是对象方法调用模式。&#125;fn(f);// #8题function SuperClass() &#123; this.name = \"women\"; this.bra = [\"a\", \"b\"];&#125;SuperClass.prototype.sayWhat = function() &#123; console.log(\"hello\");&#125;;function SubClass() &#123; this.subname = \"you sister\"; SuperClass.call(this);&#125;var sub = new SubClass();console.log(sub.sayWhat()); 把以下代码使用两种方法，依次输出 0-9答案： 123456789var funcs = [];for (var i = 0; i &lt; 10; i++) &#123; funcs.push(function() &#123; console.log(i); &#125;);&#125;funcs.forEach(function(func) &#123; func(); //输出十个10&#125;); 解决办法： 方法一：使用立即执行函数 12345678910111213var funcs = [];for (var i = 0; i &lt; 10; i++) &#123; funcs.push( (function(value) &#123; return function() &#123; console.log(value); &#125;; &#125;)(i) );&#125;funcs.forEach(function(func) &#123; func(); //依次输出0-9&#125;); 方法二：使用闭包 123456789101112function show(i) &#123; return function() &#123; console.log(i); &#125;;&#125;var funcs = [];for (var i = 0; i &lt; 10; i++) &#123; funcs.push(show(i));&#125;funcs.forEach(function(func) &#123; func(); //0 1 2 3 4 5 6 7 8 9&#125;); 方法三：使用 let 123456789var funcs = [];for (let i = 0; i &lt; 10; i++) &#123; funcs.push(function() &#123; console.log(i); &#125;);&#125;funcs.forEach(function(func) &#123; func(); //依次输出0-9&#125;); 怎么解决回调函数里面回调另一个函数，另一个函数的参数需要依赖这个回调函数。需要被解决的代码如下：12345678910111213141516171819202122$http.get(url).success(function (res) &#123; if (success != undefined) &#123; success(res); &#125;&#125;).error(function (res) &#123; if (error != undefined) &#123; error(res); &#125;&#125;);function success(data) &#123; if（ data.id != 0） &#123; var url = \"getdata/data?id=\" + data.id + \"\"; $http.get(url).success(function (res) &#123; showData(res); &#125;).error(function (res) &#123; if (error != undefined) &#123; error(res); &#125; &#125;); &#125;&#125; 答案：使用 Promise/async/await 解决 解析： 12345678910111213141516171819function awaitMethod(num) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(2 * num); // 此处模拟接口的请求 &#125;, 2000); &#125;);&#125;// 打个比方，await是学生，async是校车，必须等人齐了再开车async function test() &#123; let result = await awaitMethod(30); // await 这个关键字只能在使用async定义的函数里面使用 console.log(result); // 2秒钟之后控制台输出60 ; 后面利用 result 继续调用函数 let next = await awaitMethod(result); console.log(next); // 4秒钟之后控制台输出120 return next;&#125;// 在async里，必须要将结果return回来，不然的话.then .catch获取不到值test() .then(success =&gt; console.log(\"成功\", success)) .catch(error =&gt; console.log(\"失败\", error)); jQuery 的 ajax 返回的是 promise 对象吗？jquery 的 ajax 返回的是 deferred 对象，通过 promise 的 resolve()方法将其转换为 promise 对象。 var jsPromise = Promise.resolve($.ajax(‘/whatever.json’)); promise 只有 2 个状态，成功和失败，怎么让一个函数无论成功还是失败都能被调用？123456789101112使用promise.all()Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。Promise.all方法接受一个数组作为参数，数组里的元素都是Promise对象的实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例。）示例：var p =Promise.all([p1,p2,p3]);p的状态由p1、p2、p3决定，分为两种情况。当该数组里的所有Promise实例都进入Fulfilled状态：Promise.all**返回的实例才会变成Fulfilled状态。并将Promise实例数组的所有返回值组成一个数组，传递给Promise.all返回实例的回调函数**。当该数组里的某个Promise实例都进入Rejected状态：Promise.all返回的实例会立即变成Rejected状态。并将第一个rejected的实例返回值传递给Promise.all返回实例的回调函数。 以下代码依次输出的内容是？12345678910111213setTimeout(function() &#123; console.log(1);&#125;, 0);new Promise(function executor(resolve) &#123; console.log(2); for (var i = 0; i &lt; 10000; i++) &#123; i == 9999 &amp;&amp; resolve(); &#125; console.log(3);&#125;).then(function() &#123; console.log(4);&#125;);console.log(5); 答案：打印顺序 2 3 5 4 1 解析： 首先先碰到一个 setTimeout，于是会先设置一个定时，在定时结束后将传递这个函数放到任务队列里面，因此开始肯定不会输出 1 。 然后是一个 Promise，里面的函数是直接执行的，因此应该直接输出 2 3 。 然后，Promise 的 then 应当会放到当前 tick 的最后，但是还是在当前 tick 中。 因此，应当先输出 5，然后再输出 4 ， 最后在到下一个 tick，就是 1 。 参考 Promise 编程题答案： 第 1 题 123456789const promise = new Promise((resolve, reject) =&gt; &#123; console.log(1); resolve(); console.log(2);&#125;);promise.then(() =&gt; &#123; console.log(3);&#125;);console.log(4); 1234567运行结果及原因运行结果：1 2 4 3原因：Promise 构造函数是同步执行的，promise.then 中的函数是异步执行的。 第 2 题 12345678910111213141516const promise1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(\"success\"); &#125;, 1000);&#125;);const promise2 = promise1.then(() =&gt; &#123; throw new Error(\"error!!!\");&#125;);console.log(\"promise1\", promise1);console.log(\"promise2\", promise2);setTimeout(() =&gt; &#123; console.log(\"promise1\", promise1); console.log(\"promise2\", promise2);&#125;, 2000); 运行结果及原因 12345678910111213运行结果：promise1 Promise &#123; &lt;pending&gt; &#125;promise2 Promise &#123; &lt;pending&gt; &#125;Uncaught (in promise) Error: error!!!promise1 Promise &#123; &apos;success&apos; &#125;promise2 Promise &#123; &lt;rejected&gt; Error: error!!! at promise.then (...) at &lt;anonymous&gt; &#125;原因：promise 有 3 种状态：pending（进行中）、fulfilled（已完成，又称为Resolved） 或 rejected（已失败）。状态改变只能是 pending-&gt;fulfilled 或者 pending-&gt;rejected，状态一旦改变则不能再变。上面 promise2 并不是 promise1，而是返回的一个新的 Promise 实例。 第 3 题 12345678910111213const promise = new Promise((resolve, reject) =&gt; &#123; resolve(\"success1\"); reject(\"error\"); resolve(\"success2\");&#125;);promise .then(res =&gt; &#123; console.log(\"then: \", res); &#125;) .catch(err =&gt; &#123; console.log(\"catch: \", err); &#125;); 1234567运行结果及原因运行结果：then：success1原因：构造函数中的 resolve 或 reject 只有第一次执行有效，多次调用没有任何作用，呼应代码二结论：promise 状态一旦改变则不能再变。 第 4 题 1234567891011Promise.resolve(1) .then(res =&gt; &#123; console.log(res); // 打印1 return 2; &#125;) .catch(err =&gt; &#123; return 3; &#125;) .then(res =&gt; &#123; console.log(res); // 打印2 &#125;); 运行结果：1 2 原因：promise 可以链式调用。提起链式调用我们通常会想到通过 return this 实现，不过 Promise 并不是这样实现的。promise 每次调用 .then 或者 .catch 都会返回一个新的 promise，从而实现了链式调用。 第 5 题 12345678910Promise.resolve() .then(() =&gt; &#123; return new Error(\"error!!!\"); &#125;) .then(res =&gt; &#123; console.log(\"then: \", res); &#125;) .catch(err =&gt; &#123; console.log(\"catch: \", err); &#125;); 1234567891011运行结果then: Error: error!!! at Promise.resolve.then (...) at ...原因.then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获，需要改成其中一种：return Promise.reject(new Error(&apos;error!!!&apos;))throw new Error(&apos;error!!!&apos;)因为返回任意一个非 promise 的值都会被包裹成 promise 对象，即 return new Error(&apos;error!!!&apos;) 等价于 return Promise.resolve(new Error(&apos;error!!!&apos;))。 第 6 题 1234567891011121314const promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(\"once\"); resolve(\"success\"); &#125;, 1000);&#125;);const start = Date.now();promise.then(res =&gt; &#123; console.log(res, Date.now() - start);&#125;);promise.then(res =&gt; &#123; console.log(res, Date.now() - start);&#125;); 12345678运行结果：oncesuccess 1001success 1001注：1001不是准确数值，也可能是998、999、1000、1002 等原因：promise 的 .then 或者 .catch 可以被调用多次，但这里 Promise 构造函数只执行一次。或者说 promise 内部状态一经改变，并且有了一个值，那么后续每次调用 .then 或者 .catch 都会直接拿到该值。 第 7 题 1234const promise = Promise.resolve().then(() =&gt; &#123; return promise;&#125;);promise.catch(console.error); 12345运行结果TypeError: Chaining cycle detected for promise #&lt;Promise&gt;...原因.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。 第 8 题 1234Promise.resolve(1) .then(2) .then(Promise.resolve(3)) .then(console.log); 12345运行结果1原因.then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透。 第 9 题 123456789101112Promise.resolve() .then( function success(res) &#123; throw new Error(\"error\"); &#125;, function fail1(e) &#123; console.error(\"fail1: \", e); &#125; ) .catch(function fail2(e) &#123; console.error(\"fail2: \", e); &#125;); 1234567运行结果fail2: Error: error at success (...) at ...原因.then 可以接收两个参数，第一个是处理成功的函数，第二个是处理错误的函数。.catch 是 .then 第二个参数的简便写法，但是它们用法上有一点需要注意：.then 的第二个处理错误的函数捕获不了第一个处理成功的函数抛出的错误，而后续的 .catch 可以捕获之前的错误。 第 10 题 12345678910process.nextTick(() =&gt; &#123; console.log(\"nextTick\");&#125;);Promise.resolve().then(() =&gt; &#123; console.log(\"then\");&#125;);setImmediate(() =&gt; &#123; console.log(\"setImmediate\");&#125;);console.log(\"end\"); 12345678运行结果endnextTickthensetImmediate原因process.nextTick 和 promise.then 都属于 microtask，而 setImmediate 属于 macrotask，在事件循环的 check 阶段执行。事件循环的每个阶段（macrotask）之间都会执行 microtask，事件循环的开始会先执行一次 microtask。 不常考代码题变量提升123456789// 1console.log(tt);tt = \"dd\";console.log(tt);// 变量提升之后的代码：var tt;console.log(tt); //undefinedtt = \"dd\";console.log(tt); //'dd' 123456789101112// 2if (!a) &#123; var a = 2;&#125;console.log(a);// 变量提升之后的代码：var a; //undefinedif (!a) &#123; //true a = 2;&#125;console.log(a); //2 函数提升1234567891011121314151617// 1if (false) &#123; function fn() &#123; console.log(1); &#125;&#125;console.log(fn);fn();// 变量提升之后的代码：var fn; //undefinedif (false) &#123; function fn() &#123; console.log(1); &#125;&#125;console.log(fn); //undefinedfn(); // fn is not a function 1234567891011121314// 2function fn() &#123; foo(); return; function foo() &#123;&#125;&#125;fn();// 变量提升之后的代码：function fn() &#123; function foo() &#123;&#125; foo(); // 没有输出也不会报一个错误，因为foo是一个函数 return;&#125;fn(); 123456789101112131415// 3function bar() &#123; console.log(foo); return; var foo = function() &#123;&#125;;&#125;bar();// 变量提升之后的代码：function bar() &#123; var foo; console.log(foo); // undefined return; // 函数return之后的代码依旧会发生变量提升 foo = function() &#123;&#125;;&#125;bar(); 1234567891011// 4console.log(f1);console.log(f2);function f1() &#123;&#125;var f2 = function() &#123;&#125;;// 变量提升之后的代码：function f1() &#123;&#125; // 函数提升，整个代码块提升到文件的最开始var f2;console.log(f1); // function f1() &#123;&#125;console.log(f2); // undefinedf2 = function() &#123;&#125;; 函数和变量同时提升123456789101112131415161718192021// 1console.log(fn);var fn = function() &#123; console.log(1);&#125;;console.log(fn);function fn() &#123; console.log(2);&#125;console.log(fn);// 变量提升之后的代码：var fn;function fn() &#123; console.log(2);&#125;console.log(fn); // 2fn = function() &#123; console.log(1);&#125;;console.log(fn); // 1console.log(fn); // 1 123456789101112131415// 2console.log(f1());console.log(f2);function f1() &#123; console.log(\"aa\");&#125;var f2 = function() &#123;&#125;;// 变量提升之后的代码：var f2function f1() &#123; console.log(\"aa\"); // \"aa\"&#125;f2 = function() &#123;&#125;;console.log(f1()); // undefinedconsole.log(f2); // ƒ () &#123;&#125; 12345678// 3(function() &#123; console.log(a); a = \"aaa\"; var a = \"bbb\"; console.log(a);&#125;)();// 变量提升之后的代码： 12345678910111213// 4console.log(a);var a = 1;console.log(a);function a() &#123;&#125;console.log(a);// 变量提升之后的代码： 函数的提升后的位置是在变量提升后的位置之后的var a;function a() &#123;&#125;console.log(a); // a()a = 1;console.log(a); // 1console.log(a); // 1 123456789101112131415161718192021222324// 5console.log(a);var a = 1;console.log(a);function a() &#123;&#125;console.log(a);console.log(b);var b = 2;console.log(b);function b() &#123;&#125;console.log(b);// 变量提升之后的代码：var a;var b;function a() &#123;&#125;function b() &#123;&#125;console.log(a); // a()a = 1;console.log(a); // 1console.log(a); // 1console.log(b); // b()b = 2;console.log(b); // 2console.log(b); // 2 1234567// 6console.log(a);console.log(b); // 报错 隐式全局变量不会提升b = \"aaa\";var a = \"bbb\";console.log(a);console.log(b); 你如何获取浏览器 URL 中查询字符串中的参数？答案： 方法一：(基础版) 1234567891011121314151617function getQueryString() &#123; var sHref = window.location.href; var args = sHref.split(\"?\"); if (args[0] == sHref) &#123; // 没有参数，直接返回空即可 return \"\"; &#125; var arr = args[1].split(\"&amp;\"); var obj = &#123;&#125;; for (var i = 0; i &lt; arr.length; i++) &#123; var arg = arr[i].split(\"=\"); obj[arg[0]] = arg[1]; &#125; return obj;&#125;var href = getQueryString();console.log(href[\"categoryId\"]); 方法二：(正则版,URL 存在#则不适用) 1234567function getQueryString(name) &#123; var reg = new RegExp(\"(^|&amp;)\" + name + \"=([^&amp;]*)(&amp;|$)\"); var r = window.location.search.substr(1).match(reg); if (r != null) return unescape(r[2]); return null;&#125;console.log(getQueryString(\"categoryId\")); 方法三：(正则升级版) 123456789101112131415161718function getQueryString(name) &#123; // 未传参，返回空 if (!name) return null; // 查询参数：先通过search取值，如果取不到就通过hash来取 var after = window.location.search; after = after.substr(1) || window.location.hash.split(\"?\")[1]; // 地址栏URL没有查询参数，返回空 if (!after) return null; // 如果查询参数中没有\"name\"，返回空 if (after.indexOf(name) === -1) return null; var reg = new RegExp(\"(^|&amp;)\" + name + \"=([^&amp;]*)(&amp;|$)\"); // 当地址栏参数存在中文时，需要解码，不然会乱码 var r = decodeURI(after).match(reg); // 如果url中\"name\"没有值，返回空 if (!r) return null; return r[2];&#125;console.log(getQueryString(\"categoryId\")); js 实现一个打点计时器1、从 start 到 end（包含 start 和 end），每隔 100 毫秒 console.log 一个数字，每次数字增幅 12、返回的对象中需要包含一个 cancel 方法，用于停止定时操作3、第一个数需要立即输出 123456789101112131415161718192021222324252627282930313233// 实现法一（setTimeout()方法）：function count(start, end) &#123; if (start &lt;= end) &#123; console.log(start++); st = setTimeout(function() &#123; count(start, end); &#125;, 100); &#125; return &#123; cancel: function() &#123; clearTimeout(st); &#125; &#125;;&#125;count(1, 10);// 实现法二（setInterval()方法）：function count(start, end) &#123; console.log(start++); var timer = setInterval(function() &#123; if (start &lt;= end) &#123; console.log(start++); &#125; &#125;, 100); return &#123; cancel: function() &#123; clearInterval(timer); &#125; &#125;;&#125;count(1, 10); 知识点：setTimeout()方法用于在指定的毫秒数后调用函数或计算表达式。语法：setTimeout(code, millisec)注意：setTimeout() 只执行 code 一次。如果要多次调用，请使用 setInterval() 或者让 code 自身再次调用 setTimeout()。 setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。语法：setInterval(code ,millisec[,”lang”])setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。 正则表达式，验证手机号码，验证规则：11 位数字，以 1 位开头123456789101112131415161718192021222324252627checkphonenumber(number) &#123; if (number == null || number.length != 11) &#123; return false &#125; else &#123; // 移动号段正则表达式 var pat1 = '^((13[4-9])|(147)|(15[0-2,7-9])|(178)|(18[2-4,7-8]))\\\\d&#123;8&#125;|(1705)\\\\d&#123;7&#125;$'; // 联通号段正则表达式 var pat2 = '^((13[0-2])|(145)|(15[5-6])|(176)|(18[5,6]))\\\\d&#123;8&#125;|(1709)\\\\d&#123;7&#125;$'; // 电信号段正则表达式 var pat3 = '^((133)|(153)|(177)|(18[0,1,9])|(149))\\\\d&#123;8&#125;$'; // 虚拟运营商正则表达式 var pat4 = '^((170))\\\\d&#123;8&#125;|(1718)|(1719)\\\\d&#123;7&#125;$'; if (!part1.test(number)) &#123; return false &#125; if (!part2.test(number)) &#123; return false &#125; if (!part3.test(number)) &#123; return false &#125; if (!part4.test(number)) &#123; return false &#125; &#125; return true&#125; 请给 Array 本地对象增加一个原型方法，他的用途是删除数组中重复的条目并按升序排序，最后返回新数组。1234567891011121314Array.prototype.distinct = function() &#123; var ret = []; for (var i = 0; i &lt; this.length; i++) &#123; for (var j = i + 1; j &lt; this.length; ) &#123; if (this[i] === this[j]) &#123; ret.push(this.splice(j, 1)[0]); &#125; else &#123; j++; &#125; &#125; &#125; return ret;&#125;;console.log([\"a\", \"b\", \"c\", \"d\", \"b\", \"a\", \"e\"].distinct()); // [\"a\", \"b\"] 为字符串扩展一个 rewrite 函数，接收一个正则 pattern 和一个字符串 result,如果该字符串符合 pattern， 则以 result 对结果进行转义输出。123\"/foo\".rewrite(/^\\/foo/, \"/bar\");\"u1234\".rewrite(/^\\/u(\\d+)/, \"/user/$1\");\"/i\".rewrite(/^\\o/, \"/ooo\"); 实现一个 js 对象序列化函数，将 js 对象序列化为可反序列化的代码，要求 1.尽量和 json 兼容，2.支持不可序列化的值，如 undefined/NaN/Infinify-Infinity，3. 支持特殊对象，如正则、Date 等1234serialize(&#123;&#125;);serialize(&#123; a: \"b\" &#125;);serialize(&#123; a: 0 / 0 &#125;);serialize(&#123; a: /foo/ &#125;); 设计一道 JavaScript 的 range 算法如下： range(1, 10, 3) 返回 [1, 4, 7, 10];range(‘A’, ‘F’, 2) 返回 [‘A’, ‘C’, ‘E’]// 请使用 JavaScript 语言实现该功能（可以使用 ES6） 头条的视频网站上支持了弹幕，假设一个视频有很多弹幕，弹幕的数据是一个数组，格式定义如下：123456789101112[ &#123; time: Number, content: String &#125;, &#123; time: Number, content: String &#125;...](其中 time 表示时间，content表示弹幕内容)，那么如何快速定位到某个时间点的弹幕，请编码实现（不使用数组的 sort 方法） 尝试实现注释部分的 JavaScript 代码， 可在其他任何地方添加更多代码。123456789var Obj = function(msg) &#123; this.msg = msg; this.shout = function () &#123; alert(this.msg) &#125; this.waitAndShout = function() &#123; // 隔五秒钟后执行上面的 shout 方法 &#125;&#125; 请编写一个 JavaScript 函数 parseQuerySting, 它的用途是把 URL 参数解析为一个对象123var url = &quot;http://www.58.com/index.aspx?key0=0&amp;key1=1&amp;key2=2...&quot;var obj = parseQuerySting(url);alert(obj.key0) // 输出 0 判断一个字符串中出现次数最多的字符，统计这个次数123456789101112131415161718var str = \"asdfssaaasasasasaa\";var json = &#123;&#125;;for (var i = 0; i &lt; str.length; i++) &#123; if (!json[str.charAt(i)]) &#123; json[str.charAt(i)] = 1; &#125; else &#123; json[str.charAt(i)]++; &#125;&#125;var iMax = 0;var iIndex = \"\";for (var i in json) &#123; if (json[i] &gt; iMax) &#123; iMax = json[i]; iIndex = i; &#125;&#125;alert(\"出现次数最多的是:\" + iIndex + \"出现\" + iMax + \"次\"); 写一个获取非行间样式的函数1234567891011function getStyle(obj, attr, value) &#123; if (!value) &#123; if (obj.currentStyle) &#123; return obj.currentStyle(attr); &#125; else &#123; obj.getComputedStyle(attr, false); &#125; &#125; else &#123; obj.style[attr] = value; &#125;&#125; 字符串反转，如将 ‘12345678’ 变成 ‘87654321’123456//思路：先将字符串转换为数组 split()，利用数组的反序函数 reverse()颠倒数组，再利用 jion() 转换为字符串var str = \"12345678\";str = str .split(\"\") .reverse() .join(\"\"); 将数字 12345678 转化成 RMB 形式 如： 12,345,678123456789//个人方法；//思路：先将数字转为字符， str= str + '' ;//利用反转函数，每三位字符加一个 ','最后一位不加； re()是自定义的反转函数，最后再反转回去！for (var i = 1; i &lt;= re(str).length; i++) &#123; tmp += re(str)[i - 1]; if (i % 3 == 0 &amp;&amp; i != re(str).length) &#123; tmp += \",\"; &#125;&#125; 生成 5 个不同的随机数12345678910//思路：5个不同的数，每生成一次就和前面的所有数字相比较，如果有相同的，则放弃当前生成的数字！var num1 = [];for (var i = 0; i &lt; 5; i++) &#123; num1[i] = Math.floor(Math.random() * 10) + 1; //范围是 [1, 10] for (var j = 0; j &lt; i; j++) &#123; if (num1[i] == num1[j]) &#123; i--; &#125; &#125;&#125; 去掉数组中重复的数字方法一 12345678910111213141516//思路：每遍历一次就和之前的所有做比较，不相等则放入新的数组中！//这里用的原型 个人做法；Array.prototype.unique = function() &#123; var len = this.length, newArr = [], flag = 1; for (var i = 0; i &lt; len; i++, flag = 1) &#123; for (var j = 0; j &lt; i; j++) &#123; if (this[i] == this[j]) &#123; flag = 0; //找到相同的数字后，不执行添加数据 &#125; &#125; flag ? newArr.push(this[i]) : \"\"; &#125; return newArr;&#125;; 方法二 1234567891011121314(function(arr) &#123; var len = arr.length, newArr = [], flag; for (var i = 0; i &lt; len; i += 1, flag = 1) &#123; for (var j = 0; j &lt; i; j++) &#123; if (arr[i] == arr[j]) &#123; flag = 0; &#125; &#125; flag ? newArr.push(arr[i]) : \"\"; &#125; alert(newArr);&#125;)([1, 1, 22, 3, 4, 55, 66]); 阶乘函数12345678910//原型方法Number.prototype.N = function() &#123; var re = 1; for (var i = 1; i &lt;= this; i++) &#123; re *= i; &#125; return re;&#125;;var num = 5;alert(num.N()); 看题做答123456789 function f1()&#123; var tmp = 1; this.x = 3; console.log(tmp); //A console.log(this.x)； //B&#125;var obj = new f1(); //1console.log(obj.x) //2console.log(f1()); //3 解析： 这道题让我重新认识了对象和函数，首先看代码（1），这里实例话化了 f1 这个类。相当于执行了 f1 函数。所以这个时候 A 会输出 1， 而 B 这个时候的 this 代表的是 实例化的当前对象 obj B 输出 3.。 代码（2）毋庸置疑会输出 3， 重点 代码（3）首先这里将不再是一个类，它只是一个函数。那么 A 输出 1， B 呢？这里的 this 代表的其实就是 window 对象，那么 this.x 就是一个全局变量 相当于在外部 的一个全局变量。所以 B 输出 3。最后代码由于 f 没有返回值那么一个函数如果没返回值的话，将会返回 underfined ，所以答案就是 ： 1， 3， 3， 1， 3， underfined 。 下面输出多少？1234var o1 = new Object();var o2 = o1;o2.name = \"CSSer\";console.log(o1.name); 解析： 如果不看答案，你回答真确了的话，那么说明你对 javascript 的数据类型了解的还是比较清楚了。js 中有两种数据类型，分别是：基本数据类型和引用数据类型（object Array）。对于保存基本类型值的变量，变量是按值访问的，因为我们操作的是变量实际保存的值。对于保存引用类型值的变量，变量是按引用访问的，我们操作的是变量值所引用（指向）的对象。答案就清楚了： //CSSer; 下面输出多少？12345678function changeObjectProperty(o) &#123; o.siteUrl = \"http://www.csser.com/\"; o = new Object(); o.siteUrl = \"http://www.popcg.com/\";&#125;var CSSer = new Object();changeObjectProperty(CSSer);console.log(CSSer.siteUrl); // 解析： 如果 CSSer 参数是按引用传递的，那么结果应该是”http://www.popcg.com/&quot;，但实际结果却仍是&quot;http://www.csser.com/&quot;。事实是这样的：在函数内部修改了引用类型值的参数，该参数值的原始引用保持不变。我们可以把参数想象成局部变量，当参数被重写时，这个变量引用的就是一个局部变量，局部变量的生存期仅限于函数执行的过程中，函数执行完毕，局部变量即被销毁以释放内存。 （补充：内部环境可以通过作用域链访问所有的外部环境中的变量对象，但外部环境无法访问内部环境。每个环境都可以向上搜索作用域链，以查询变量和函数名，反之向下则不能。） 输出多少？123456var a = 6;setTimeout(function() &#123; var a = 666; alert(a); // 输出666，&#125;, 1000);a = 66; 因为 var a = 666;定义了局部变量 a，并且赋值为 666，根据变量作用域链，全局变量处在作用域末端，优先访问了局部变量，从而覆盖了全局变量 。 123456var a = 6;setTimeout(function() &#123; alert(a); // 输出undefined var a = 666;&#125;, 1000);a = 66; 因为 var a = 666;定义了局部变量 a，同样覆盖了全局变量，但是在 alert(a);之前a 并未赋值，所以输出 undefined。 12345678var a = 6;setTimeout(function() &#123; alert(a); var a = 66;&#125;, 1000);a = 666;alert(a);// 666, undefined; 记住： 异步处理，一切 OK 声明提前 JS 的继承性？123456789window.color = \"red\";var o = &#123; color: \"blue\" &#125;;function sayColor() &#123; alert(this.color);&#125;sayColor(); //redsayColor.call(this); //red this-window对象sayColor.call(window); //redsayColor.call(o); //blue 精度问题: JS 精度不能精确到 0.1 所以 。。。。同时存在于值和差值中1234567var n = 0.3, m = 0.2, i = 0.2, j = 0.1;alert(n - m == i - j); //falsealert(n - m == 0.1); //falsealert(i - j == 0.1); //true 加减运算1234alert(\"5\" + 3); //53 stringalert(\"5\" + \"3\"); //53 stringalert(\"5\" - 3); //2 numberalert(\"5\" - \"3\"); //2 number 结果是什么？123456789101112131415161718192021222324function foo() &#123; foo.a = function() &#123; alert(1); &#125;; this.a = function() &#123; alert(2); &#125;; a = function() &#123; alert(3); &#125;; var a = function() &#123; alert(4); &#125;;&#125;foo.prototype.a = function() &#123; alert(5);&#125;;foo.a = function() &#123; alert(6);&#125;;foo.a(); //6var obj = new foo();obj.a(); //2foo.a(); //1 输出结果12345678910var a = 5;function test() &#123; a = 0; alert(a); alert(this.a); //没有定义 a这个属性 var a; alert(a);&#125;test(); // 0, 5, 0new test(); // 0, undefined, 0 //由于类它自身没有属性a， 所以是undefined 计算字符串字节数12345678910new (function(s) &#123; if (!arguments.length || !s) return null; if (\"\" == s) return 0; var l = 0; for (var i = 0; i &lt; s.length; i++) &#123; if (s.charCodeAt(i) &gt; 255) l += 2; else l += 1; //charCodeAt()得到的是unCode码 &#125; //汉字的unCode码大于 255bit 就是两个字节 alert(l);&#125;)(\"hello world!\"); 结果是var bool = !!2; alert(bool)；//true;双向非操作可以把字符串和数字转换为布尔值 声明对象，添加属性，输出属性1234567var obj = &#123; name: \"leipeng\", showName: function() &#123; alert(this.name); &#125;&#125;;obj.showName(); 匹配输入的字符：第一个必须是字母或下划线开头，长度 5-20123456789var reg = /^[a-zA-Z][a-zA-Z0-9_]&#123;5,20&#125;/, name1 = \"leipeng\", name2 = \"0leipeng\", name3 = \"你好leipeng\", name4 = \"hi\";alert(reg.test(name1));alert(reg.test(name2));alert(reg.test(name3));alert(reg.test(name4)); 检测变量类型1234function checkStr(str) &#123; typeof str == \"string\" ? alert(\"true\") : alert(\"false\");&#125;checkStr(\"leipeng\"); 如何在 HTML 中添加事件，几种方法？12341、标签之中直接添加 onclick=&quot;fun()&quot;;2、JS 添加 Eobj.onclick = method;3、现代事件 IE： obj.attachEvent(&apos;onclick&apos;, method)； FF: obj.addEventListener(&apos;click&apos;, method, false); 请问代码实现 outerHTML123456//说明：outerHTML其实就是innerHTML再加上本身；Object.prototype.outerHTML = function() &#123; var innerCon = this.innerHTML, //获得里面的内容 outerCon = this.appendChild(innerCon); //添加到里面 alert(outerCon);&#125;; 演示代码： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"outer\"&gt; hello &lt;/div&gt; &lt;script&gt; Object.prototype.outerHTML = function() &#123; var innerCon = this.innerHTML, //获得里面的内容 outerCon = this.appendChild(innerCon); //添加到里面 alert(outerCon); &#125;; function $(id) &#123; return document.getElementById(id); &#125; alert($(\"outer\").innerHTML); alert($(\"outer\").outerHTML); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; JS 中的简单继承 call 方法！123456789101112131415161718//顶一个父母类，注意：类名都是首字母大写的哦！function Parent(name, money) &#123; this.name = name; this.money = money; this.info = function() &#123; alert(\"姓名： \" + this.name + \" 钱： \" + this.money); &#125;;&#125; //定义孩子类function Children(name) &#123; Parent.call(this, name); //继承 姓名属性，不要钱。 this.info = function() &#123; alert(\"姓名： \" + this.name); &#125;;&#125; //实例化类var per = new Parent(\"parent\", 800000000000);var chi = new Children(\"child\");per.info();chi.info(); 解析 URL 成一个对象？1234567891011121314String.prototype.urlQueryString = function() &#123; var url = this.split(\"?\")[1].split(\"&amp;\"), len = url.length; this.url = &#123;&#125;; for (var i = 0; i &lt; len; i += 1) &#123; var cell = url[i].split(\"=\"), key = cell[0], val = cell[1]; this.url[\"\" + key + \"\"] = val; &#125; return this.url;&#125;;var url = \"?name=12&amp;age=23\";console.log(url.urlQueryString().age); 看下列代码输出什么？1234var foo = \"11\" + 2 - \"1\";console.log(foo);console.log(typeof foo);// 执行完后foo的值为111，foo的类型为Number。 看下列代码,输出什么？123456var a = new Object();a.value = 1;b = a;b.value = 2;alert(a.value);// 执行完后输出结果为2 已知数组 var stringArray = [“This”, “is”, “Baidu”, “Campus”]，Alert 出”This is Baidu Campus”。alert(stringArray.join(“”)) 请描述出下列代码运行的结果1234function d() &#123; console.log(this);&#125;d(); 需要将变量 e 的值修改为“a+b+c+d”,请写出对应的代码var e=”abcd”; 下面这个 ul，如何点击每一列的时候 alert 其 index?（闭包）12345&lt;ul id=\"”test”\"&gt; &lt;li&gt;这是第一条&lt;/li&gt; &lt;li&gt;这是第二条&lt;/li&gt; &lt;li&gt;这是第三条&lt;/li&gt;&lt;/ul&gt; 答案： 123456789101112131415161718// 方法一：var lis = document.getElementById(\"2223\").getElementsByTagName(\"li\");for (var i = 0; i &lt; 3; i++) &#123; lis[i].index = i; lis[i].onclick = function() &#123; alert(this.index); &#125;;&#125;//方法二：var lis = document.getElementById(\"2223\").getElementsByTagName(\"li\");for (var i = 0; i &lt; 3; i++) &#123; lis[i].index = i; lis[i].onclick = (function(a) &#123; return function() &#123; alert(a); &#125;; &#125;)(i);&#125; 小贤是一条可爱的小狗(Dog)，它的叫声很好听(wow)，每次看到主人的时候就会乖乖叫一声(yelp)。从这段描述可以得到以下对象：12345678 function Dog() &#123; this.wow = function() &#123; alert(’Wow’); &#125; this.yelp = function() &#123; this.wow(); &#125;&#125; 小芒和小贤一样，原来也是一条可爱的小狗，可是突然有一天疯了(MadDog)，一看到人就会每隔半秒叫一声(wow)地不停叫唤(yelp)。请根据描述，按示例的形式用代码来实。（继承，原型，setInterval） 1234567891011121314function MadDog() &#123; this.yelp = function() &#123; var self = this; setInterval(function() &#123; self.wow(); &#125;, 500); &#125;;&#125;MadDog.prototype = new Dog();//for testvar dog = new Dog();dog.yelp();var madDog = new MadDog();madDog.yelp(); 实现一个函数 clone，可以对 JavaScript 中的 5 种主要的数据类型（包括 Number、String、Object、Array、Boolean）进行值复制 考察点 1：对于基本数据类型和引用数据类型在内存中存放的是值还是指针这一区别是否清楚 考察点 2：是否知道如何判断一个变量是什么类型的 考察点 3：递归算法的设计 1234567891011121314151617181920212223242526272829303132333435// 方法一：Object.prototype.clone = function() &#123; var o = this.constructor === Array ? [] : &#123;&#125;; for (var e in this) &#123; o[e] = typeof this[e] === \"object\" ? this[e].clone() : this[e]; &#125; return o;&#125;;/** * 克隆一个对象 * @param Obj * @returns *///方法二：function clone(Obj) &#123; var buf; if (Obj instanceof Array) &#123; buf = []; //创建一个空的数组 var i = Obj.length; while (i--) &#123; buf[i] = clone(Obj[i]); &#125; return buf; &#125; else if (Obj instanceof Object) &#123; buf = &#123;&#125;; //创建一个空对象 for (var k in Obj) &#123; //为这个对象添加新的属性 buf[k] = clone(Obj[k]); &#125; return buf; &#125; else &#123; //普通变量直接赋值 return Obj; &#125;&#125; 输出今天的日期，以 YYYY-MM-DD 的方式，比如今天是 2014 年 9 月 26 日，则输出 2014-09-261234567891011var d = new Date();// 获取年，getFullYear()返回4位的数字var year = d.getFullYear();// 获取月，月份比较特殊，0是1月，11是12月var month = d.getMonth() + 1;// 变成两位month = month &lt; 10 ? \"0\" + month : month;// 获取日var day = d.getDate();day = day &lt; 10 ? \"0\" + day : day;alert(year + \"-\" + month + \"-\" + day); 写出函数 DateDemo 的返回结果，系统时间假定为今天123456789function DateDemo() &#123; var d, s = \"今天日期是：\"; d = new Date(); s += d.getMonth() + \"/\"; s += d.getDate() + \"/\"; s += d.getYear(); return s;&#125; 答案：今天日期是：7/17/2010 只允许使用 + - _ / 和 Math._ ，求一个函数 y = f(x, a, b);当 x &gt; 100 时返回 a 的值，否则返回 b 的值，不能使用 if else 等条件语句，也不能使用|,?:,数组。12345function f(x, a, b) &#123; var temp = Math.ceil(Math.min(Math.max(x - 100, 0), 1)); return a * temp + b * (1 - temp);&#125;console.log(f(-10, 1, 2)); 看代码，写结果看题算结果123456789101112131415var tasks = []; // 这里存放异步操作的 Promisevar output = i =&gt; new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(new Date(), i); resolve(); &#125;, 1000 * i); &#125;);// 生成全部的异步操作for (var i = 0; i &lt; 5; i++) &#123; tasks.push(output(i));&#125;console.log(new Date, i); 答案： 1234567Mon Aug 12 2019 09:37:36 GMT+0800 (中国标准时间) 5Mon Aug 12 2019 09:33:55 GMT+0800 (中国标准时间) 0然后每隔1s打印Mon Aug 12 2019 09:33:56 GMT+0800 (中国标准时间) 1Mon Aug 12 2019 09:33:57 GMT+0800 (中国标准时间) 2Mon Aug 12 2019 09:33:58 GMT+0800 (中国标准时间) 3Mon Aug 12 2019 09:33:59 GMT+0800 (中国标准时间) 4 解析：参考 看题算结果12345678910111213141516// 模拟其他语言中的 sleep，实际上可以是任何异步操作const sleep = timeountMS =&gt; new Promise(resolve =&gt; &#123; setTimeout(resolve, timeountMS); &#125;);(async () =&gt; &#123; // 声明即执行的 async 函数表达式 for (var i = 0; i &lt; 5; i++) &#123; await sleep(1000); console.log(new Date(), i); &#125; await sleep(1000); console.log(new Date(), i);&#125;)(); 答案：每隔1s打印 123456Mon Aug 12 2019 09:39:02 GMT+0800 (中国标准时间) 0Mon Aug 12 2019 09:39:03 GMT+0800 (中国标准时间) 1Mon Aug 12 2019 09:39:04 GMT+0800 (中国标准时间) 2Mon Aug 12 2019 09:39:05 GMT+0800 (中国标准时间) 3Mon Aug 12 2019 09:39:06 GMT+0800 (中国标准时间) 4Mon Aug 12 2019 09:39:07 GMT+0800 (中国标准时间) 5 解析：参考 请写出以下代码的执行结果12345678910(function() &#123; fn(); var fn = function() &#123; alert(1); &#125; fn(); function fn() &#123; alert(2) &#125;&#125;)() 请说明以下各种情况的执行结果，并注明产生对应结果的理由1234567function doSomething() &#123; alert(this);&#125;a) element.onclick = doSomething, 点击 element 元素后b) element.onclick = function() doSomething()&#123;&#125;, 点击 element 元素后c) 直接执行 doSomething() 请写出以下代码的执行结果1234567891011var obj = &#123;&#125;;var events = &#123; m1: &quot;clicked&quot;, m2: &quot;changed&quot;&#125;;for(e in events) &#123; obj[e] = function() &#123; alert(events[e]) &#125;&#125;alert(obj.m1 == obj.m2);obj.m1();obj.m2(); 以下代码输出多少1234567891011121314151617181920212223var name = \"world\";(function () &#123; if (typeof name === \"undefined\") &#123; var name = \"jack\"; console.log(\"Hi!\" + name); &#125; else &#123; console.log(\"Hello,\" + name) &#125;&#125;)()==&gt; Hi!jackvar name = \"world\";(function (name) &#123; if (typeof name === \"undefined\") &#123; var name = \"jack\"; console.log(\"Hi!\" + name); &#125; else &#123; console.log(\"Hello,\" + name) &#125;&#125;)(name)==&gt; Hello,world 计算打印结果123456789101112131415161718192021222324function fun(n, o) &#123; console.log(o); return &#123; fun: function(m) &#123; return fun(m, n); &#125; &#125;;&#125;// var a = fun(0);// a.fun(1)// a.fun(2)// a.fun(3)// 打印// undefined 0 0 0// var b = fun(0).fun(1).fun(2).fun(3)// 打印 undefined 0 1 2var c = fun(0).fun(1);c.fun(2);c.fun(3);// 打印// undefined 0 1 1 看下面代码，给出输出结果1234for (var i = 1; i &lt;= 3; i++) &#123; console.log(i);&#125;// 1 2 3 但是 1234567for (var i = 1; i &lt;= 3; i++) &#123; setTimeout(() =&gt; &#123; // setTimout在for里面是异步执行的，在延迟输出的时候，i的值已经是4了 console.log(i); &#125;, 0);&#125;// 4 4 4 如何输出 1 2 3 答案： 立即执行函数 12345678for (var i = 1; i &lt;= 3; i++) &#123; setTimeout( (i =&gt; &#123; console.log(i); &#125;)(i), 0 );&#125; 看下面代码，给出输出结果(考察闭包及++运算符)123456789101112function Foo() &#123; var i = 0; return function() &#123; console.log(i++); &#125;;&#125;var f1 = Foo(), f2 = Foo();f1(); // 0f1(); // 1f2(); // 0 12345678910function fn() &#123; var a = 1; return function() &#123; a++; console.log(a); &#125;;&#125;var b = fn();console.log(b());// 2 123456789function fn() &#123; var a = 1; return function() &#123; console.log(a++); &#125;;&#125;var b = fn();console.log(b());// 1 看下面代码，给出输出结果(考察时间戳)123456789101112//总结：第一个setTimeout，时间间隔&lt;1000的话，输出1000多，&gt;1000的话，输出间隔值多// 第二个setTimeout，是1000+时间间隔var dateNum = new Date();setTimeout(function() &#123; console.log(new Date() - dateNum);&#125;, 1200); //1200多while (new Date() - dateNum &lt; 1000) &#123; var a = 1;&#125;setTimeout(function() &#123; console.log(new Date() - dateNum);&#125;, 1500); // 2500左右 看题写结果1234567891011var output = function(i) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000);&#125;;for (var i = 0; i &lt; 5; i++) &#123; output(i); // 这里传过去的 i 值被复制了&#125;console.log(i); 答案： 501234 解析：参考 第 16 题 12345678910function test() &#123; console.log(\"test函数\");&#125;setTimeout(function() &#123; console.log(\"定时器回调函数\");&#125;, 0);test();function foo() &#123; var name = \"hello\";&#125; 下列 JavaScript 代码执行后，依次 alert 的结果是1234567891011var obj = &#123; proto: &#123; a: 1, b: 2 &#125; &#125;;function F() &#123;&#125;F.prototype = obj.proto;var f = new F();obj.proto.c = 3;obj.proto = &#123; a: -1, b: -2 &#125;;alert(f.a);alert(f.c);delete F.prototype[\"a\"];alert(f.a);alert(obj.proto.a); 下列 JavaScript 代码执行后，运行的结果是1&lt;button id=\"btn\"&gt;点击我&lt;/button&gt; 12345678var btn = document.getElementById(\"btn\");var handler = &#123; id: \"_eventHandler\", exec: function() &#123; alert(this.id); &#125;&#125;;btn.addEventListener(\"click\", handler.exec.false); 输出结果是多少？1） 12345678var a; // undefinedvar b = a * 0; // NaNif (b == b) &#123; // false console.log(b * 2 + \"2\" - 0 + 4);&#125; else &#123; console.log(!b * 2 + \"2\" - 0 + 4); // 22 + 4 = 26&#125; 答案：26 2） 123456789101112&lt;script&gt; var a = 1;&lt;/script&gt;&lt;script&gt;var a;var b = a * 0;if (b == b) &#123; // true console.log(b * 2 + \"2\" - 0 + 4); // 6&#125; else &#123; console.log(!b * 2 + \"2\" - 0 + 4);&#125;&lt;/script&gt; 答案：6 3） 123456var t = 10;function test(t) &#123; var t = t++;&#125;test(t);console.log(t); // 外部不能访问函数内的变量 答案：10 4） 123456var t = 10;function test(test) &#123; var t = test++;&#125;test(t);console.log(t); 答案：10 6） 1234567var t = 10;function test(test) &#123; t = test++; console.log(t);&#125;test(t);console.log(t); 答案：10 7） 12345678var t = 10;function test(test) &#123; t = t + test; console.log(t); var t = 3;&#125;test(t);console.log(t); 答案：NaN 10 8） 1234567var a;var b = a / 0;if (b == b) &#123; console.log(b * 2 + \"2\" - 0 + 4);&#125; else &#123; console.log(!b * 2 + \"2\" - 0 + 4);&#125; 答案：26 9） 123456789101112&lt;script&gt; var a = 1;&lt;/script&gt;&lt;script&gt; var a; var b = a / 0; if (b == b) &#123; console.log(b * 2 + \"2\" + 4); &#125; else &#123; console.log(!b * 2 + \"2\" + 4); &#125;&lt;/script&gt; 答案：Infinity24 下列 JavaScript 代码执行后，iNum 的值是12345678var iNum = 0;for (var i = 1; i &lt; 10; i++) &#123; if (i % 5 == 0) &#123; continue; &#125; iNum++;&#125;console.log(iNum); 答案：8 下列 JavaScript 代码执行后，依次打印的结果是1234567(function test() &#123; var a = (b = 5); console.log(typeof a); console.log(typeof b);&#125;)();console.log(typeof a);console.log(typeof b); 答案： 1234numbernumberundefinednumber console.log( 8 | 1 ); 输出值是多少？9 请写出三种以上的 Firefox 有但 InternetExplorer 没有的属性和函数1、在 IE 下可通过document.frames[&quot;id&quot;];得到该 IFRAME 对象， 而在火狐下则是通过document.getElementById(&quot;content_panel_if&quot;).contentWindow; 2、IE 的写法： _tbody=_table.childNodes[0]在 FF 中，firefox 会在子节点中包含空白则第一个子节点为空白””， 而 ie 不会返回空白可以通过if(&quot;&quot; != node.nodeName)过滤掉空白子对象 3、模拟点击事件 123456789if (document.all) &#123; //ie下 document.getElementById(\"a3\").click();&#125; else &#123; //非IE var evt = document.createEvent(\"MouseEvents\"); evt.initEvent(\"click\", true, true); document.getElementById(\"a3\").dispatchEvent(evt);&#125; 4、事件注册 12345if (isIE) &#123; window.attachEvent(\"onload\", init);&#125; else &#123; window.addEventListener(\"load\", init, false);&#125; 编写一个快速方法将 html 的 sup 提取转换为一个数组1234// 编写一个快速方法将html的sup提取转换为一个数组，如：let str = \"气量(10&lt;sup&gt;8&lt;/sup&gt;m&lt;sup&gt;3&lt;/sup&gt;)\";// 输出结果// ['气量(10',8,'m',3,')'] 答案： 1234// 方法1str.split(/\\&lt;\\/?sup\\&gt;/);// 方法2str.split(/&lt;[^&gt;]+&gt;/); 求 num 的值123456789101112131415161718192021222324252627282930313233// 面试题1var num = 123;function f1() &#123; console.log(num); // 123&#125;function f2() &#123; var num = 456; f1();&#125;f2();//面试题1 变式var num = 123;function f1(num) &#123; console.log(num); // 456&#125;function f2() &#123; var num = 456; f1(num);&#125;f2();//面试题1 变式var num = 123;function f1() &#123; console.log(num); // 456&#125;f2();function f2() &#123; num = 456; //这里是全局变量 f1();&#125;console.log(num); // 456 有一个函数，参数是一个函数，返回值也是一个函数，返回的函数功能和入参的函数相似，但这个函数只能执行 3 次，再次执行无效，如何实现这个题目是考察闭包的使用 答案： 12345678910111213141516171819function sayHi() &#123; console.log(\"hi\");&#125;function threeTimes(fn) &#123; let times = 0; return () =&gt; &#123; if (times++ &lt; 3) &#123; fn(); &#125; &#125;;&#125;const newFn = threeTimes(sayHi);newFn();newFn();newFn();newFn();newFn(); // 后面两次执行都无任何反应 通过闭包变量 times 来控制函数的执行 实现 add 函数,让 add(a)(b)和 add(a,b)两种调用结果相同123456789function add(a, b) &#123; if (b === undefined) &#123; return function(x) &#123; return a + x; &#125;; &#125; return a + b;&#125; 格式化金钱，每千分位加逗号123456789101112function format(str) &#123; let s = \"\"; let count = 0; for (let i = str.length - 1; i &gt;= 0; i--) &#123; s = str[i] + s; count++; if (count % 3 == 0 &amp;&amp; i != 0) &#123; s = \",\" + s; &#125; &#125; return s;&#125; 123function format(str) &#123; return str.replace(/(\\d)(?=(?:\\d&#123;3&#125;)+$)/g, \"$1,\");&#125; 反转数组要求 input: I am a student output: student a am I 输入是数组 输出也是数组不允许用 split splice reverse 答案： 解法一 12345678910111213141516171819function reverseArry(arry) &#123; const str = arry.join(\" \"); const result = []; let word = \"\"; for (let i = 0, len = str.length; i &lt; len; i++) &#123; if (str[i] != \" \") &#123; word += str[i]; &#125; else &#123; result.unshift(word); word = \"\"; &#125; &#125; result.unshift(word); return result;&#125;console.log(reverseArry([\"I\", \"am\", \"a\", \"student\"]));// [\"student\", \"a\", \"am\", \"I\"] 解法二 123456789function reverseArry(arry) &#123; const result = []; const distance = arry.length - 1; for (let i = distance; i &gt;= 0; i--) &#123; result[distance - i] = arry[i]; &#125; return result;&#125; 说出以下函数的作用是？空白区域应该填写什么？123456789101112131415161718//define(function(window) &#123; function fn(str) &#123; this.str = str; &#125; fn.prototype.format = function() &#123; var arg = ______; return this.str.replace(_____, function(a, b) &#123; return arg[b] || \"\"; &#125;); &#125;; window.fn = fn;&#125;)(window);//use(function() &#123; var t = new fn('&lt;p&gt;&lt;a href=\"&#123;0&#125;\"&gt;&#123;1&#125;&lt;/a&gt;&lt;span&gt;&#123;2&#125;&lt;/span&gt;&lt;/p&gt;'); console.log(t.format(\"http://www.alibaba.com\", \"Alibaba\", \"Welcome\"));&#125;)(); 答案：访函数的作用是使用 format 函数将函数的参数替换掉{0}这样的内容，返回一个格式化后的结果：第一个空是：arguments第二个空是：/{(\\d+)}/ig 原生 JS 的 window.onload 与 Jquery 的$(document).ready(function(){})有什么不同？如何用原生 JS 实现 Jq 的 ready 方法？window.onload()方法是必须等到页面内包括图片的所有元素加载完毕后才能执行。$(document).ready()是 DOM 结构绘制完毕后就执行，不必等到加载完毕。 1234567891011121314151617181920212223242526272829303132333435/* * 传递函数给whenReady() * 当文档解析完毕且为操作准备就绪时，函数作为document的方法调用 */var whenReady = (function() &#123; //这个函数返回whenReady()函数 var funcs = []; //当获得事件时，要运行的函数 var ready = false; //当触发事件处理程序时,切换为true //当文档就绪时,调用事件处理程序 function handler(e) &#123; if (ready) return; //确保事件处理程序只完整运行一次 //如果发生onreadystatechange事件，但其状态不是complete的话,那么文档尚未准备好 if (e.type === \"onreadystatechange\" &amp;&amp; document.readyState !== \"complete\") &#123; return; &#125; //运行所有注册函数 //注意每次都要计算funcs.length //以防这些函数的调用可能会导致注册更多的函数 for (var i = 0; i &lt; funcs.length; i++) &#123; funcs[i].call(document); &#125; //事件处理函数完整执行,切换ready状态, 并移除所有函数 ready = true; funcs = null; &#125; //为接收到的任何事件注册处理程序 if (document.addEventListener) &#123; document.addEventListener(\"DOMContentLoaded\", handler, false); document.addEventListener(\"readystatechange\", handler, false); //IE9+ window.addEventListener(\"load\", handler, false); &#125; else if (document.attachEvent) &#123; document.attachEvent(\"onreadystatechange\", handler); window.attachEvent(\"onload\", handler); &#125; //返回whenReady()函数 return function whenReady(fn) &#123; if (ready) &#123; fn.call(document); &#125; else &#123; funcs.push(fn); &#125; &#125;;&#125;)(); 如果上述代码十分难懂，下面这个简化版： 1234567891011121314151617181920212223242526function ready(fn) &#123; if (document.addEventListener) &#123; //标准浏览器 document.addEventListener( \"DOMContentLoaded\", function() &#123; //注销事件, 避免反复触发 document.removeEventListener( \"DOMContentLoaded\", arguments.callee, false ); fn(); //执行函数 &#125;, false ); &#125; else if (document.attachEvent) &#123; //IE document.attachEvent(\"onreadystatechange\", function() &#123; if (document.readyState == \"complete\") &#123; document.detachEvent(\"onreadystatechange\", arguments.callee); fn(); //函数执行 &#125; &#125;); &#125;&#125; 对作用域上下文和 this 的理解，看下列代码：123456789var User = &#123; count: 1, getCount: function() &#123; return this.count; &#125;&#125;;console.log(User.getCount()); // what?var func = User.getCount;console.log(func()); // what? 问两处 console 输出什么？为什么？ 答案：1 和 undefined。func 是在 winodw 的上下文中被执行的，所以会访问不到 count 属性。 解析： 继续追问，那么如何确保 Uesr 总是能访问到 func 的上下文，即正确返回 1。正确的方法是使用 Function.prototype.bind。兼容各个浏览器完整代码如下： 12345678910Function.prototype.bind = Function.prototype.bind || function(context) &#123; var self = this; return function() &#123; return self.apply(context, arguments); &#125;; &#125;;var func = User.getCount.bind(User);console.log(func()); 在 Javascript 中什么是伪数组？如何将伪数组转化为标准数组？伪数组（类数组）：无法直接调用数组方法或期望 length 属性有什么特殊的行为，但仍可以对真正数组遍历方法来遍历它们。典型的是函数的 argument 参数，还有像调用 getElementsByTagName,document.childNodes 之类的,它们都返回 NodeList 对象都属于伪数组。可以使用 Array.prototype.slice.call(fakeArray)将数组转化为真正的 Array 对象。 假设我们要给每个 log 方法添加一个”(app)”前缀，比如’hello world!’ -&gt;’(app)hello world!’。方法如下： 12345function log() &#123; var args = Array.prototype.slice.call(arguments); //为了使用unshift数组方法，将argument转化为真正的数组 args.unshift(\"(app)\"); console.log.apply(console, args);&#125; 定义一个 log 方法，让它可以代理 console.log 的方法。可行的方法一： 1234function log(msg) &#123; console.log(msg);&#125;log(\"hello world!\"); // hello world! 如果要传入多个参数呢？显然上面的方法不能满足要求，所以更好的方法是： 123function log() &#123; console.log.apply(console, arguments);&#125; 到此，追问 apply 和 call 方法的异同。 对于 apply 和 call 两者在作用上是相同的，即是调用一个对象的一个方法，以另一个对象替换当前对象。将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。 但两者在参数上有区别的。对于第一个参数意义都一样，但对第二个参数： apply 传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而 call 则作为 call 的参数传入（从第二个参数开始）。 如 func.call(func1,var1,var2,var3)对应的 apply 写法为：func.apply(func1,[var1,var2,var3]) 。 给 String 对象添加一个方法，传入一个 string 类型的参数，然后将 string 的每个字符间价格空格返回，例如：addSpace(“hello world”) // -&gt; ‘h e l l o w o r l d’123String.prototype.spacify = function() &#123; return this.split(\"\").join(\" \");&#125;; 接着上述问题答案提问，1）直接在对象的原型上添加方法是否安全？尤其是在 Object 对象上。(这个我没能答出？希望知道的说一下。) 2）函数声明与函数表达式的区别？答案：在 js 中，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非是一视同仁的，解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问），至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行。 请评价以下代码并给出改进意见1234567891011if (window.addEventListener) &#123; var addListener = function(el, type, listener, useCapture) &#123; el.addEventListener(type, listener, useCapture); &#125;;&#125; else if (document.all) &#123; addListener = function(el, type, listener) &#123; el.attachEvent(\"on\" + type, function() &#123; listener.apply(el); &#125;); &#125;;&#125; 不应该在 if 和 else 语句中声明 addListener 函数，应该先声明； 不需要使用 window.addEventListener 或 document.all 来进行检测浏览器，应该使用能力检测； * 由于 attachEvent 在 IE 中有 this 指向问题，所以调用它时需要处理一下 改进如下： 12345678910111213function addEvent(elem, type, handler) &#123; if (elem.addEventListener) &#123; elem.addEventListener(type, handler, false); &#125; else if (elem.attachEvent) &#123; elem[\"temp\" + type + handler] = handler; elem[type + handler] = function() &#123; elem[\"temp\" + type + handler].apply(elem); &#125;; elem.attachEvent(\"on\" + type, elem[type + handler]); &#125; else &#123; elem[\"on\" + type] = handler; &#125;&#125; 编写一个 JavaScript 函数，输入指定类型的选择器(仅需支持 id，class，tagName 三种简单 CSS 选择器，无需兼容组合选择器)可以返回匹配的 DOM 节点，需考虑浏览器兼容性和性能。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*** @param selector &#123;String&#125; 传入的CSS选择器。* @return &#123;Array&#125;*/var query = function(selector) &#123; var reg = /^(#)?(\\.)?(\\w+)$/gim; var regResult = reg.exec(selector); var result = []; //如果是id选择器 if (regResult[1]) &#123; if (regResult[3]) &#123; if (typeof document.querySelector === \"function\") &#123; result.push(document.querySelector(regResult[3])); &#125; else &#123; result.push(document.getElementById(regResult[3])); &#125; &#125; &#125; //如果是class选择器 else if (regResult[2]) &#123; if (regResult[3]) &#123; if (typeof document.getElementsByClassName === \"function\") &#123; var doms = document.getElementsByClassName(regResult[3]); if (doms) &#123; result = converToArray(doms); &#125; &#125; //如果不支持getElementsByClassName函数 else &#123; var allDoms = document.getElementsByTagName(\"*\"); for (var i = 0, len = allDoms.length; i &lt; len; i++) &#123; if (allDoms[i].className.search(new RegExp(regResult[2])) &gt; -1) &#123; result.push(allDoms[i]); &#125; &#125; &#125; &#125; &#125; //如果是标签选择器 else if (regResult[3]) &#123; var doms = document.getElementsByTagName(regResult[3].toLowerCase()); if (doms) &#123; result = converToArray(doms); &#125; &#125; return result;&#125;;function converToArray(nodes) &#123; var array = null; try &#123; array = Array.prototype.slice.call(nodes, 0); //针对非IE浏览器 &#125; catch (ex) &#123; array = new Array(); for (var i = 0, len = nodes.length; i &lt; len; i++) &#123; array.push(nodes[i]); &#125; &#125; return array;&#125; 下列控制台都输出什么第 1 题： 12345function setName() &#123; name = \"张三\";&#125;setName();console.log(name); 答案：”张三” 第 2 题： 1234567//考点：1、变量声明提升 2、变量搜索机制var a = 1;function test() &#123; console.log(a); var a = 1;&#125;test(); 答案：undefined 第 3 题： 123456var b = 2;function test2() &#123; window.b = 3; console.log(b);&#125;test2(); 答案：3 第 4 题： 12345678c = 5; //声明一个全局变量cfunction test3() &#123; window.c = 3; console.log(c); //答案：undefined，原因：由于此时的c是一个局部变量c，并且没有被赋值 var c; console.log(window.c); //答案：3，原因：这里的c就是一个全局变量c&#125;test3(); 第 5 题： 123456var arr = [];arr[0] = \"a\";arr[1] = \"b\";arr[10] = \"c\";alert(arr.length); //答案：11console.log(arr[5]); //答案：undefined 第 6 题： 123var a = 1;console.log(a++); //答案：1console.log(++a); //答案：3 第 7 题： 123console.log(null == undefined); //答案：trueconsole.log(\"1\" == 1); //答案：true，因为会将数字1先转换为字符串1console.log(\"1\" === 1); //答案：false，因为数据类型不一致 第 8 题： 123456789101112131415typeof 1;(\"number\");typeof \"hello\";(\"string\");typeof /[0-9]/;(\"object\");typeof &#123;&#125;;(\"object\");typeof null;(\"object\");typeof undefined;(\"undefined\");typeof [1, 2, 3];(\"object\");typeof function() &#123;&#125;; //\"function\" 第 9 题： 1234parseInt(3.14); //3parseFloat(\"3asdf\"); //3parseInt(\"1.23abc456\");parseInt(true); //\"true\" NaN 第 10 题： 12345678//考点：函数声明提前function bar() &#123; return foo; foo = 10; function foo() &#123;&#125; //var foo = 11;&#125;alert(typeof bar()); //\"function\" 第 11 题：考点：函数声明提前 12345678var foo = 1;function bar() &#123; foo = 10; return; function foo() &#123;&#125;&#125;bar();alert(foo); //答案：1 第 12 题： 1234console.log(a); //是一个函数var a = 3;function a() &#123;&#125;console.log(a); ////3 第 13 题： 1234567891011//考点：对arguments的操作function foo(a) &#123; arguments[0] = 2; alert(a);//答案：2，因为：a、arguments是对实参的访问，b、通过arguments[i]可以修改指定实参的值&#125;foo(1);265、第14题：function foo(a) &#123; alert(arguments.length);//答案：3，因为arguments是对实参的访问&#125;foo(1, 2, 3); 第 15 题 12345678910bar(); //报错var foo = function bar(name) &#123; console.log(\"hello\" + name); console.log(bar);&#125;;//alert(typeof bar);foo(\"world\"); //\"hello\"console.log(bar); //undefinedconsole.log(foo.toString());bar(); //报错 下面程序输出的结果是什么？123456789101112function sayHi() &#123; console.log(name); console.log(age); var name = &quot;Lydia&quot;; let age = 21;&#125;sayHi();A: Lydia 和 undefinedB: Lydia 和 ReferenceErrorC: ReferenceError 和 21D: undefined 和 ReferenceError 参考答案 在函数中，我们首先使用var关键字声明了name变量。 这意味着变量在创建阶段会被提升（JavaScript会在创建变量创建阶段为其分配内存空间），默认值为undefined，直到我们实际执行到使用该变量的行。 我们还没有为name变量赋值，所以它仍然保持undefined的值。 使用let关键字（和const）声明的变量也会存在变量提升，但与var不同，初始化没有被提升。 在我们声明（初始化）它们之前，它们是不可访问的。 这被称为“暂时死区”。 当我们在声明变量之前尝试访问变量时，JavaScript会抛出一个ReferenceError。 关于let的是否存在变量提升，我们何以用下面的例子来验证： 12345let name = &apos;ConardLi&apos;&#123; console.log(name) // Uncaught ReferenceError: name is not defined let name = &apos;code秘密花园&apos;&#125; let变量如果不存在变量提升，console.log(name)就会输出ConardLi，结果却抛出了ReferenceError，那么这很好的说明了，let也存在变量提升，但是它存在一个“暂时死区”，在变量未初始化或赋值前不允许访问。 变量的赋值可以分为三个阶段： 创建变量，在内存中开辟空间初始化变量，将变量初始化为undefined真正赋值关于let、var和function： let的「创建」过程被提升了，但是初始化没有提升。var的「创建」和「初始化」都被提升了。function的「创建」「初始化」和「赋值」都被提升了。 下面代码输出什么12345678var a = 10;(function () &#123; console.log(a) a = 5 console.log(window.a) var a = 20; console.log(a)&#125;)() 依次输出：undefined -&gt; 10 -&gt; 20 在立即执行函数中，var a = 20; 语句定义了一个局部变量 a，由于js的变量声明提升机制，局部变量a的声明会被提升至立即执行函数的函数体最上方，且由于这样的提升并不包括赋值，因此第一条打印语句会打印undefined，最后一条语句会打印20。 由于变量声明提升，a = 5; 这条语句执行时，局部的变量a已经声明，因此它产生的效果是对局部的变量a赋值，此时window.a 依旧是最开始赋值的10， 下面的输出结果是什么？123456789101112class Chameleon &#123; static colorChange(newColor) &#123; this.newColor = newColor; &#125; constructor(&#123; newColor = &quot;green&quot; &#125; = &#123;&#125;) &#123; this.newColor = newColor; &#125;&#125;const freddie = new Chameleon(&#123; newColor: &quot;purple&quot; &#125;);freddie.colorChange(&quot;orange&quot;); A: orangeB: purpleC: greenD: TypeError答案: D colorChange方法是静态的。 静态方法仅在创建它们的构造函数中存在，并且不能传递给任何子级。 由于freddie是一个子级对象，函数不会传递，所以在freddie实例上不存在freddie方法：抛出TypeError。 下面代码中什么时候会输出1？1234var a = ?;if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3)&#123; conso.log(1);&#125; 因为==会进行隐式类型转换 所以我们重写toString方法就可以了 12345678910var a = &#123; i: 1, toString() &#123; return a.i++; &#125;&#125;if( a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3 ) &#123; console.log(1);&#125; 下面的输出结果是什么？12345678910var obj = &#123; &apos;2&apos;: 3, &apos;3&apos;: 4, &apos;length&apos;: 2, &apos;splice&apos;: Array.prototype.splice, &apos;push&apos;: Array.prototype.push&#125;obj.push(1)obj.push(2)console.log(obj) 参考答案 1.使用第一次push，obj对象的push方法设置 obj[2]=1;obj.length+=12.使用第二次push，obj对象的push方法设置 obj[3]=2;obj.length+=13.使用console.log输出的时候，因为obj具有 length 属性和 splice 方法，故将其作为数组进行打印4.打印时因为数组未设置下标为 0 1 处的值，故打印为empty，主动 obj[0] 获取为 undefined 下面代码输出的结果是什么？123456var a = &#123;n: 1&#125;;var b = a;a.x = a = &#123;n: 2&#125;;console.log(a.x) console.log(b.x) 参考答案 undefined{n:2} 首先，a和b同时引用了{n:2}对象，接着执行到a.x = a = {n：2}语句，尽管赋值是从右到左的没错，但是.的优先级比=要高，所以这里首先执行a.x，相当于为a（或者b）所指向的{n:1}对象新增了一个属性x，即此时对象将变为{n:1;x:undefined}。之后按正常情况，从右到左进行赋值，此时执行a ={n:2}的时候，a的引用改变，指向了新对象{n：2},而b依然指向的是旧对象。之后执行a.x = {n：2}的时候，并不会重新解析一遍a，而是沿用最初解析a.x时候的a，也即旧对象，故此时旧对象的x的值为{n：2}，旧对象为 {n:1;x:{n：2}}，它被b引用着。后面输出a.x的时候，又要解析a了，此时的a是指向新对象的a，而这个新对象是没有x属性的，故访问时输出undefined；而访问b.x的时候，将输出旧对象的x的值，即{n:2}。 下面代码的输出是什么?1234567891011function checkAge(data) &#123; if (data === &#123; age: 18 &#125;) &#123; console.log(&quot;You are an adult!&quot;); &#125; else if (data == &#123; age: 18 &#125;) &#123; console.log(&quot;You are still an adult.&quot;); &#125; else &#123; console.log(`Hmm.. You don&apos;t have an age I guess`); &#125;&#125;checkAge(&#123; age: 18 &#125;); 参考答案 Hmm.. You don’t have an age I guess在比较相等性，原始类型通过它们的值进行比较，而对象通过它们的引用进行比较。JavaScript检查对象是否具有对内存中相同位置的引用。 我们作为参数传递的对象和我们用于检查相等性的对象在内存中位于不同位置，所以它们的引用是不同的。 这就是为什么{ age: 18 } === { age: 18 }和 { age: 18 } == { age: 18 }返回 false的原因。 下面代码的输出是什么?1234567const obj = &#123; 1: &quot;a&quot;, 2: &quot;b&quot;, 3: &quot;c&quot; &#125;;const set = new Set([1, 2, 3, 4, 5]);obj.hasOwnProperty(&quot;1&quot;);obj.hasOwnProperty(1);set.has(&quot;1&quot;);set.has(1); 参考答案 true true false true所有对象键（不包括Symbols）都会被存储为字符串，即使你没有给定字符串类型的键。 这就是为什么obj.hasOwnProperty（’1’）也返回true。 上面的说法不适用于Set。 在我们的Set中没有“1”：set.has（’1’）返回false。 它有数字类型1，set.has（1）返回true。 下面代码的输出是什么?1234567891011121314151617// example 1var a=&#123;&#125;, b=&apos;123&apos;, c=123; a[b]=&apos;b&apos;;a[c]=&apos;c&apos;; console.log(a[b]);// example 2var a=&#123;&#125;, b=Symbol(&apos;123&apos;), c=Symbol(&apos;123&apos;); a[b]=&apos;b&apos;;a[c]=&apos;c&apos;; console.log(a[b]);// example 3var a=&#123;&#125;, b=&#123;key:&apos;123&apos;&#125;, c=&#123;key:&apos;456&apos;&#125;; a[b]=&apos;b&apos;;a[c]=&apos;c&apos;; console.log(a[b]); 参考答案 这题考察的是对象的键名的转换。 对象的键名只能是字符串和 Symbol 类型。其他类型的键名会被转换成字符串类型。对象转字符串默认会调用 toString 方法。 12345678910111213141516171819202122232425262728// example 1var a=&#123;&#125;, b=&apos;123&apos;, c=123;a[b]=&apos;b&apos;;// c 的键名会被转换成字符串&apos;123&apos;，这里会把 b 覆盖掉。a[c]=&apos;c&apos;; // 输出 cconsole.log(a[b]);// example 2var a=&#123;&#125;, b=Symbol(&apos;123&apos;), c=Symbol(&apos;123&apos;); // b 是 Symbol 类型，不需要转换。a[b]=&apos;b&apos;;// c 是 Symbol 类型，不需要转换。任何一个 Symbol 类型的值都是不相等的，所以不会覆盖掉 b。a[c]=&apos;c&apos;;// 输出 bconsole.log(a[b]);// example 3var a=&#123;&#125;, b=&#123;key:&apos;123&apos;&#125;, c=&#123;key:&apos;456&apos;&#125;; // b 不是字符串也不是 Symbol 类型，需要转换成字符串。// 对象类型会调用 toString 方法转换成字符串 [object Object]。a[b]=&apos;b&apos;;// c 不是字符串也不是 Symbol 类型，需要转换成字符串。// 对象类型会调用 toString 方法转换成字符串 [object Object]。这里会把 b 覆盖掉。a[c]=&apos;c&apos;; // 输出 cconsole.log(a[b]); 下面代码的输出是什么?1234567891011(() =&gt; &#123; let x, y; try &#123; throw new Error(); &#125; catch (x) &#123; (x = 1), (y = 2); console.log(x); &#125; console.log(x); console.log(y);&#125;)(); 参考答案 1 undefined 2catch块接收参数x。当我们传递参数时，这与变量的x不同。这个变量x是属于catch作用域的。 之后，我们将这个块级作用域的变量设置为1，并设置变量y的值。 现在，我们打印块级作用域的变量x，它等于1。 在catch块之外，x仍然是undefined，而y是2。 当我们想在catch块之外的console.log(x)时，它返回undefined，而y返回2。 下面代码的输出结果是什么？123456789101112131415161718function Foo() &#123; Foo.a = function() &#123; console.log(1) &#125; this.a = function() &#123; console.log(2) &#125;&#125;Foo.prototype.a = function() &#123; console.log(3)&#125;Foo.a = function() &#123; console.log(4)&#125;Foo.a();let obj = new Foo();obj.a();Foo.a(); 参考答案 输出顺序是 4 2 1 1234567891011121314151617181920212223function Foo() &#123; Foo.a = function() &#123; console.log(1) &#125; this.a = function() &#123; console.log(2) &#125;&#125;// 以上只是 Foo 的构建方法，没有产生实例，此刻也没有执行Foo.prototype.a = function() &#123; console.log(3)&#125;// 现在在 Foo 上挂载了原型方法 a ，方法输出值为 3Foo.a = function() &#123; console.log(4)&#125;// 现在在 Foo 上挂载了直接方法 a ，输出值为 4Foo.a();// 立刻执行了 Foo 上的 a 方法，也就是刚刚定义的，所以// # 输出 4 原文链接：https://blog.csdn.net/sinat_37903468/article/details/100887223 笔试经验面试中的写代码的过程,一定不能紧张,要沉住气慢慢来.只要不是系统自动检查结果,只要是面试官看着你写,就有很大的表现的机会,哪怕最后做不出来。 可以肯定的是,面试官不会只根据是否能运行成功来评价应聘者. 所以,只需要顺着正确思路稳稳地做就好了,不要怕最后运行不成功. 如果实在做不出,也一定要和面试官说清你当前的进展和思路,而不是一句”我不会”就想结束问题. 关于这篇文章,有几点我想先说清楚,方便读者更顺利的学习. 这篇文章不适合前端小白阅读,需要对JS和ES6有一定了解,否则遇到一些写法可能不太看得懂 因为精力有限,我只加了较为粗略但足以帮助读者理解的注释,因为多数题也只有几行代码而已. 如果遇到还不懂的地方,我认为读者完全可以自己去查询文档来了解为什么这么做,为什么使用这个函数. 或者,先查询该问题通常的解决思路,再回来参考我的实现 代码大量使用了ES6的语法 学习手撕代码,不只是理解的过程,更是实践的过程 我在完全掌握(可以默写出每段代码,并讲清楚每一行的作用)以下代码的过程中,做了以下几件事 参考别人的实现,结合自己的思路,写出一个自己的版本 不断对代码进行优化 当你尝试去优化一段代码的时候,对它的理解和记忆会异常深刻 不看之前的实现,重新自己实现一次 再和之前的实现做对比,检查错误 反复阅读和默写,直到可以完全正确的默写为之 作为一个专业的程序员,除了工作中的编码,额外的无实际产出的练习(反复练习解决一个问题,反复默写同一段代码),也是必不可少的. 这就像歌手不可能到了舞台上才去练习自己的声音.他一定会在平时大量去练声. 这就是我强调要反复敲代码的原因.别想着平时只要理解,工作中再去熟能生巧. 工作不是给你练习的地方,工作是你的舞台. 下文中几乎每一段代码,都是我反复优化后的结果,希望可以带给读者新的启发. 我把代码大致分成了几个专题,一共包含了大致30个问题的解决方案 除了文章中的问题,还有些我没有提到的,都是频率较低的问题 关于算法题,除了排序和查找我也基本没有写.因为算法问题千变万化,需要的是解决问题的思维,而不是固定的实现 重要性与顺序无关 目录DOM 事件代理 数组 对象 扁平化 去重 - unique() 拷贝 浅拷贝 深拷贝（copy()函数实现、JSON.stringify） 字符串 去除空格 - trim() 字符串全排列 广度优先实现 深度优先实现 排序和查找 插入排序 归并排序 快速排序 二分查找 找出出现次数最多的元素 - getMostItem() 功能函数实现 setTimeout实现setInterval 函数柯里化 防抖 节流 数据结构 单链表 设计模式 发布订阅模式 JS原生API实现 bind() call() apply() InstanceOf new reduce() forEach() Promise HTTP请求 AJAX封装 JSONP DOM事件代理12345678document.getElementById(&quot;father-id&quot;).onclick=function(event)&#123; event=event||window.event let target=event.target||event.srcElement //可以自己打印一下event.target.nodeName,看看是什么 if (target.nodeName.toLowerCase()===&apos;xxx&apos;)&#123; //事件内容 &#125;&#125; 数组 对象扁平化1234567891011function flatten(arr) &#123; let result=[] for (let i=0,len=arr.length;i&lt;len;i++) &#123; if (Array.isArray(arr[i])) &#123; result=result.concat(flatten(arr[i])) &#125; else &#123; result.push(arr[i]) &#125; &#125; return result&#125; 去重 - unique()12345678910111213function unique(arr) &#123; let appeard=new Set() return arr.filter(item=&gt;&#123; //创建一个可以唯一标识对象的字符串id let id=item+JSON.stringify(item) if (appeard.has(id)) &#123; return false &#125; else &#123; appeard.add(id) return true &#125; &#125;)&#125; 拷贝浅拷贝1234567function copy(obj) &#123; let result=Array.isArray(obj)?[]:&#123;&#125; Object.keys(obj).forEach(key=&gt;result[key]=obj[key]) return result&#125;otherStar=&#123;...star&#125;Object.assign(&#123;&#125;,star) 深拷贝copy()函数实现处理了循环引用和key为symbol类型的情况 12345678910111213function copy(obj,appeard=new Map()) &#123; if (!(obj instanceof Object)) return obj//如果是原始数据类型 if (appeard.has(obj)) return appeard.get(obj)//如果已经出现过 let result=Array.isArray(obj)?[]:&#123;&#125; appeard.set(obj,result)//将新对象放入map //遍历所有属性进行递归拷贝 ;[...Object.keys(obj),...Object.getOwnPropertySymbols(obj)] .forEach(key=&gt;result[key]=copy(obj[key],appeard)) return result&#125; JSON.stringify 只能处理纯JSON数据 有几种情况会发生错误 包含不能转成 JSON 格式的数据 循环引用 undefined,NaN, -Infinity, Infinity 都会被转化成null RegExp/函数不会拷贝 new Date()会被转成字符串 1new=JSON.parse(JSON.stringify(old)) 字符串去除空格 - trim()123456789101112131415161718192021function myTrim(str) &#123; return str.replace(/(^\\s+)|(\\s+$)/g,&apos;&apos;)//将前空格和后空格替换为空&#125;function myTrim(str) &#123;//记录前后空格的个数,最后对字符串进行截取 let first=0,last=str.length for (let i in str) &#123; if (str[i]===&apos; &apos;) &#123; first++ &#125; else &#123; break &#125; &#125; for (let i=last;i&gt;first;i--) &#123; if (str[i]===&apos; &apos;) &#123; last-- &#125; else &#123; break &#125; &#125; return str.substr(first,last-first)&#125; 字符串全排列广度优先实现1234567891011function combine(str) &#123;//抽出一个字符s,对其余的进行排列,将s放在每种排列开头 if (str.length===1) return [str] let results=[] for (let i in str) &#123; for (let s of combine(str.slice(0,i)+str.slice(1+(+i)))) &#123; results.push(str[i]+s) &#125; &#125; //可能会出现类似&quot;aa&quot;=&gt;[aa,aa,aa,aa]的情况,需要去重 return [...new Set(results)]&#125; 深度优先实现1234567891011function combine(str) &#123;//记录已经使用过的字符,深度优先访问所有方案 let result=[] ;(function _combine(str,path=&apos;&apos;)&#123; if (str.length===0) return result.push(path) for (let i in str) &#123; _combine(str.slice(0,i)+str.slice((+i)+1,str.length),path+str[i]) &#125; &#125;)(str) //可能会出现类似&quot;aa&quot;=&gt;[aa,aa,aa,aa]的情况,需要去重 return [...new Set(result)]&#125; 排序和查找插入排序12345678function sort(arr) &#123;//原地 for (let i in arr) &#123;//选一个元素 while (i&gt;0&amp;&amp;arr[i]&lt;arr[i-1]) &#123;//向前移动到合适的位置 [arr[i],arr[i-1]]=[arr[i-1],arr[i]] i-- &#125; &#125;&#125; 归并排序12345678910111213function sort(arr) &#123; if (arr.length===1) return arr //分成两部分 let mid=Math.floor(arr.length/2) let [part1,part2]=[sort(arr.slice(0,mid)),sort(arr.slice(mid))] //对比+合并 let result=[] while (part1.length&gt;0&amp;&amp;part2.length&gt;0) result.push((part1[0]&lt;part2[0]?part1:part2).shift()) return [...result,...part1,...part2]&#125; 快速排序1234567891011121314function sort(arr) &#123; if (arr.length&lt;=1) return arr //选基准值 let mid_pos=arr.length&gt;&gt;1 let mid=arr.splice(mid_pos,1)[0] let left=[],right=[] //和基准值比较,分别插入left,right数组 arr.forEach(item=&gt;(item&lt;=mid?left:right).push(item)) return [...sort(left),mid,...sort(right)]//递归调用排序&#125; 二分查找1234567891011121314151617function search(arr,target) &#123;//循环写法,不断移动左右指针,缩小范围 let left=0,right=arr.length-1 while (left&lt;=right) &#123; const mid_pos=Math.floor((left+right)/2) const mid_val=arr[mid_pos] if (target===mid_val) &#123; return mid_pos &#125; else if (target&gt;mid_val) &#123; left=mid_pos+1 &#125; else &#123; right=mid_pos-1 &#125; &#125; return -1&#125; 找出出现次数最多的元素 - getMostItem()12345678910111213141516171819202122232425function getMost(arr) &#123; //计数 let map=new Map() arr.forEach(item=&gt;&#123; if (map.has(item)) &#123; map.set(item,map.get(item)+1) &#125; else &#123; map.set(item,1) &#125; &#125;) //找出出现最多 let [max_vals,max_num]=[[arr[0]],map.get(arr[0])] map.forEach((count,item)=&gt;&#123; if (count&gt;max_num)&#123; max_vals=[item] max_num=count &#125; else &#123; max_vals.push(item) &#125; &#125;) return max_vals&#125;console.log(getMost([&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;3&apos;, &apos;55&apos;, &apos;3&apos;, &apos;55&apos;, &apos;55&apos;])) 功能函数实现setTimeout实现setInterval12345678910function myInterval(fn,interval,...args) &#123; let context=this setTimeout(()=&gt;&#123; fn.apply(context,args) myInterval(fn,interval,...args)//别忘了为它传入参数 &#125;,interval)&#125;myInterval((num)=&gt;console.log(num),500,10) 函数柯里化123456function sum(...args1)&#123; return function (...args2) &#123; return [...args1,...args2].reduce((p,n)=&gt;p+n) &#125;&#125;console.log(sum(1, 2, 2)(7)) 防抖 节流实现了两个加工方法,返回一个加工后的防抖/节流函数 防抖1234567function debounce(fn,delay) &#123; let timer=null return function ()&#123; if (timer) clearTimeout(timer) timer=setTimeout(()=&gt;fn.call(...arguments),delay)//别忘了为它传入参数 &#125;&#125; 节流123456789101112function throttle(fn,delay) &#123; let flag=true return function() &#123; if (!flag) return flag=false setTimeout(()=&gt;&#123; fn(...arguments)//别忘了为它传入参数 flag=true &#125;,delay) &#125;&#125; 数据结构单链表12345678910111213141516171819202122232425262728293031323334353637function Node(element) &#123;//结点类 [this.element,this.next]=[element,null]&#125;class LinkList &#123;//链表类 constructor() &#123; this.length=0 this.head=new Node() this.tail=new Node() this.head.next=this.tail &#125; get_all() &#123; let result=[] let now=this.head while (now.next!==this.tail) &#123; now=now.next result.push(now.element) &#125; return result &#125; unshift(element) &#123;//开头添加 let node=new Node(element) node.next=this.head.next this.head.next=node &#125; shift()&#123;//开头删除 let node=this.head.next this.head.next=this.head.next.next return node.element &#125;&#125;let list=new LinkList()list.unshift(15)list.unshift(16)list.unshift(17)console.log(list.shift())//17console.log(list.get_all())//[ 16, 15 ] 设计模式发布订阅模式1234567891011121314151617181920class Observer &#123; constructor() &#123; this.events=&#123;&#125;//事件中心 &#125; publish(eventName,...args) &#123;//发布=&gt;调用事件中心中对应的函数 if (this.events[eventName]) this.events[eventName].forEach(cb=&gt;cb.apply(this,args)) &#125; subscribe(eventName,callback) &#123;//订阅=&gt;向事件中心中添加事件 if (this.events[eventName]) &#123; this.events[eventName].push(callback) &#125; else &#123; this.events[eventName]=[callback] &#125; &#125; unSubscribe(eventName,callback) &#123;//取消订阅 if (events[eventName]) events[eventName]=events[eventName].filter(cb=&gt;cb!==callback) &#125;&#125; JS原生API实现bind() call() apply()apply()123456Function.prototype.myApply=function(context,args) &#123; context.fn=this//为context设置函数属性 let result=context.fn(...args)//调用函数 delete context.fn//删除context的函数属性 return result&#125; call()12345678//除了...args//和apply都一样Function.prototype.myCall=function(context,...args) &#123; context.fn=this let result=context.fn(...args) delete context.fn return result&#125; bind()123Function.prototype.myBind=function(context,args1) &#123;//使用[闭包+apply]实现 return (...args2)=&gt;this.apply(context,[...args1,...args2]);&#125; InstanceOf123456789function myInstanceOf(son,father) &#123;//沿着父亲的原型链向上查找是否有儿子的原型 while (true) &#123; son=son.__proto__ if (!son) return false if (son===father.prototype) return true &#125;&#125;myInstanceOf([], Array) // true new1234567891011121314151617181920function myNew(constructor_fn,...args) &#123; //构造新的空对象 let new_obj=&#123;&#125; new_obj.__proto__=constructor_fn.prototype let result=constructor_fn.apply(new_obj,args) //如果构造函数没有返回一个对象,则返回新创建的对象 //如果构造函数返回了一个对象,则返回那个对象 //如果构造函数返回原始值,则当作没有返回对象 return result instanceof Object?result:new_obj&#125;function Animal(name) &#123; this.name = name;&#125;let animal = myNew(Animal, &apos;dog&apos;);console.log(animal.name) // dog reduce() forEach()reduce()api用法: 1arr.reduce(function(prev, cur, index, arr)&#123;&#125;, initialValue) 实现: 123456789Array.prototype.myReduce=function(fn,init_val)&#123; let [val,idx]=init_val?[init_val,0]:[this[0],1]//设置初始值 for (let i=idx,len=this.length;i&lt;len;i++) &#123; val=fn(val,this[i],i,this)//循环并迭代结果 &#125; return val&#125;console.log([1,2,3,4,5].reduce((pre,item)=&gt;pre+item,0)) // 15 forEach()api用法: 123[1,3,5,7,9].myForEach(function(item,index,arr) &#123; console.log(this)&#125;,15) 实现: 12345Array.prototype.myForEach=function(fn,temp_this) &#123; for (let i=0,len=this.length;i&lt;len;i++)&#123; fn.call(temp_this,this[i],i,this)//循环数组元素,为回调函数传入参数 &#125;&#125; PromisePromise.all()12345678910111213Promise.prototype.all=function(promiseList) &#123; return new Promise((resolve,reject)=&gt;&#123; if (promiseList.length===0) return resolve([]) let result=[],count=0 promiseList.forEach((promise,index)=&gt;&#123; Promise.resolve(promise).then(value=&gt;&#123; result[index]=value if (++count===promiseList.length) resolve(result) &#125;,reason=&gt;reject(reason)) &#125;) &#125;)&#125; ES6所有API完整实现通过Promise/A+ test测试 实现细节过多,还请参照Promise/A+规范阅读 也可以直接参考我关于promise的笔记 深入理解promise https://blog.csdn.net/weixin_43758603/article/details/109641486 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207class Promise &#123; constructor(task) &#123; this.status=&quot;pending&quot; this.value=undefined this.reason=undefined this.fulfilled_callbacks=[] this.rejected_callbacks=[] try &#123; task(this._resolve,this._reject) &#125; catch (error) &#123; this._reject(error) &#125; &#125; then(onFulfilled,onRejected)&#123; if (this.status===&apos;fulfilled&apos;) &#123; let promise2=new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; try &#123; if (!this._isFunction(onFulfilled)) &#123; resolve(this.value) &#125; else &#123; this._resolvePromise(promise2,onFulfilled(this.value)) &#125; &#125; catch (error) &#123; reject(error) &#125; &#125;,0) &#125;) return promise2 &#125; else if (this.status===&apos;rejected&apos;) &#123; let promise2=new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; try &#123; if (!this._isFunction(onRejected)) &#123; reject(this.reason) &#125; else &#123; this._resolvePromise(promise2,onRejected(this.reason)) &#125; &#125; catch (error) &#123; reject(error) &#125; &#125;,0) &#125;) return promise2 &#125; else if (this.status===&apos;pending&apos;) &#123; let promise2=new Promise((resolve,reject)=&gt;&#123; this.fulfilled_callbacks.push(()=&gt;&#123; try &#123; if (!this._isFunction(onFulfilled)) &#123; resolve(this.value) &#125; else &#123; this._resolvePromise(promise2,onFulfilled(this.value)) &#125; &#125; catch (error) &#123; reject(error) &#125; &#125;) this.rejected_callbacks.push(()=&gt;&#123; try &#123; if (!this._isFunction(onRejected)) &#123; reject(this.reason) &#125; else &#123; this._resolvePromise(promise2,onRejected(this.reason)) &#125; &#125; catch (error) &#123; reject(error) &#125; &#125;) &#125;) return promise2 &#125; &#125; catch=onRejected=&gt;this.then(null,onRejected) finally=onFinished=&gt;this.then(onFinished,onFinished) static deferred()&#123; let deferred=&#123;&#125; deferred.promise=new Promise((resolve,reject)=&gt;&#123; deferred.resolve=resolve deferred.reject=reject &#125;) return deferred &#125; static resolve(value) &#123; if (value instanceof Promise) return value return new Promise(resolve=&gt;resolve(value)) &#125; static reject=reason=&gt;&#123;return new Promise((resolve, reject)=&gt;reject(reason))&#125; static all(promiseList) &#123; return new Promise((resolve,reject)=&gt;&#123; if (promiseList.length===0) return resolve([]) let result=[],count=0 promiseList.forEach((promise,index)=&gt;&#123; Promise.resolve(promise).then(value=&gt;&#123; result[index]=value if (++count===promiseList.length) resolve(result) &#125;,reason=&gt;reject(reason)) &#125;) &#125;) &#125; static race(promiseList) &#123; return new Promise((resolve,reject)=&gt;&#123; if (promiseList.length===0) return resolve() promiseList.forEach(promise=&gt;&#123; Promise.resolve(promise) .then(value=&gt;resolve(value),reason=&gt;reject(reason)) &#125;) &#125;) &#125; static allSettled(promiseList) &#123; return new Promise(resolve=&gt;&#123; let result=[],count=0 if (len===0) return resolve(result) promiseList.forEach((promise,i)=&gt;&#123; Promise.resolve(promise).then(value=&gt;&#123; result[i]=&#123; status:&apos;fulfilled&apos;, value:value &#125; if (++count===promiseList.length) resolve(result) &#125;,reason=&gt;&#123; result[i]=&#123; status:&apos;rejected&apos;, reason:reason &#125; if (++count===promiseList.length) resolve(result) &#125;) &#125;) &#125;) &#125; _resolve=value=&gt;&#123; if (this.status!==&apos;pending&apos;) return setTimeout(()=&gt;&#123; this.status =&apos;fulfilled&apos; this.value = value this.fulfilled_callbacks.forEach(cb=&gt;cb(this.value)) &#125;,0) &#125; _reject=reason=&gt;&#123; if (this.status!==&apos;pending&apos;) return setTimeout(()=&gt;&#123; this.reason = reason this.status =&apos;rejected&apos; this.rejected_callbacks.forEach(cb=&gt;cb(this.reason)) &#125;,0) &#125; _isFunction=f=&gt;Object.prototype.toString.call(f).toLocaleLowerCase()===&apos;[object function]&apos; _isObject=o=&gt;Object.prototype.toString.call(o).toLocaleLowerCase()===&apos;[object object]&apos; _resolvePromise(promise,x)&#123; if (promise===x) &#123; promise._reject(new TypeError(&apos;cant be the same&apos;)) return &#125; if (x instanceof Promise) &#123; if (x.status===&apos;fulfilled&apos;) &#123; promise._resolve(x.value) &#125; else if (x.status===&apos;rejected&apos;) &#123; promise._reject(x.reason) &#125; else if (x.status===&apos;pending&apos;) &#123; x.then(value=&gt;&#123; this._resolvePromise(promise,value) &#125;,reason=&gt;&#123; promise._reject(reason) &#125;) &#125; return &#125; if (this._isObject(x)||this._isFunction(x)) &#123; let then try &#123; then=x.then &#125; catch (error) &#123; promise._reject(error) return &#125; if (this._isFunction(then)) &#123; let called=false try &#123; then.call(x,value=&gt;&#123; if (called) return called=true this._resolvePromise(promise,value) &#125;,reason=&gt;&#123; if (called) return called=true promise._reject(reason) &#125;) &#125; catch (error) &#123; if (called) return promise._reject(error) &#125; &#125; else &#123; promise._resolve(x) &#125; &#125; else &#123; promise._resolve(x) &#125; &#125;&#125;module.exports = Promise HTTP请求AJAX封装1234567891011121314151617181920212223242526272829303132333435function ajax(method,url,params,callback) &#123; //对参数进行处理 method=method.toUpperCase() let post_params=null let get_params=&apos;&apos; if (method===&apos;GET&apos;) &#123; if (typeof params===&apos;object&apos;) &#123; let tempArr=[] for (let key in params) &#123; tempArr.push(`$&#123;key&#125;=$&#123;params[key]&#125;`) &#125; params=tempArr.join(&apos;&amp;&apos;) &#125; get_params=`?$&#123;params&#125;` &#125; else &#123; post_params=params &#125; //发请求 let xhr=new XMLHttpRequest() xhr.onreadystatechange=function()&#123; if (xhr.readyState!==4) return callback(xhr.responseText) &#125; xhr.open(method,url+get_params,false) if (method===&apos;POST&apos;) xhr.setRequestHeader(&apos;Content-Type&apos;,&apos;application/x-www-form-urlencoded&apos;) xhr.send(post_params) &#125;ajax(&apos;get&apos;,&apos;https://www.baidu.com&apos;,&#123;id:15&#125;,data=&gt;console.log(data)) JSONP12345678910111213141516171819202122232425262728293031function jsonp(url, params_obj, callback) &#123; //创建一个供后端返回数据调用的函数名 let funcName = &apos;jsonp_&apos; + Data.now() + Math.random().toString().substr(2, 5) //将参数拼接成字符串 if (typeof params===&apos;object&apos;) &#123; let temp=[] for (let key in params) &#123; temp.push(`$&#123;key&#125;=$&#123;params[key]&#125;`) &#125; params=temp.join(&apos;&amp;&apos;) &#125; //在html中插入&lt;script&gt;资源请求标签 let script=document.createElement(&apos;script&apos;) script.src=`$&#123;url&#125;?$&#123;params&#125;&amp;callback=$&#123;funcName&#125;` document.body.appendChild(script) //在本地设置供后端返回数据时调用的函数 window[funcName]=data=&gt;&#123; callback(data) delete window[funcName] document.body.removeChild(script) &#125;&#125;//使用方法jsonp(&apos;http://xxxxxxxx&apos;,&#123;id:123&#125;,data=&gt;&#123; //获取数据后的操作&#125;) js插入html中标签的内容 1&lt;script src=&quot;https://www.liuzhuocheng.com?callback=funcName&quot;&gt;&lt;/script&gt; 后端返回的&lt;script&gt;资源的内容 123&lt;script src=&quot;https://www.liuzhuocheng.com?callback=funcName&quot;&gt; funcName(&apos;datadatadatadatadatadatadatadata&apos;)&lt;/script&gt; 面试代码题解释12345678var a = 10;(function () &#123; console.log(a) a = 5 console.log(window.a) var a = 20; console.log(a)&#125;)() 这段代码的输出结果为： 第一个 console.log(a) 输出 10 ，因为在外部定义了变量 a 并赋值为 10 。 第二个 console.log(window.a) 输出 10 ，这里通过 window.a 访问全局变量 a ，其值仍为 10 。 第三个 console.log(a) 输出 20 ，这是在函数内部重新声明的局部变量 a 的值。 这段代码主要考察了以下几个方面： 作用域：展示了全局作用域和函数内部作用域的区别。 变量声明：不同位置声明变量的可见性和生命周期。 在函数内部重新声明了变量 a ，这会形成一个局部作用域，覆盖了外部的全局变量 a 。在函数内部对 a 进行赋值操作只会影响局部变量，而不会改变全局变量的值。 12345678910const p = Promise.resolve();(async () =&gt; &#123; await p; console.log(&apos;await end&apos;);&#125;)();p.then(() =&gt; &#123; console.log(&apos;then 1&apos;);&#125;).then(() =&gt; &#123; console.log(&apos;then 2&apos;);&#125;); 好的，下面是一个更通俗易懂的解释： 首先， Promise.resolve() 创建了一个已经完成的 Promise 对象 p 。 然后，在 async 函数中使用 await p ，这意味着程序会在这里暂停，等待 p 完成。 由于 p 已经完成了，所以 await p 不会阻塞，会直接继续执行后面的代码，输出 await end 。 而 p.then() 里的回调函数，它们会在 p 完成后被调用。但在这个例子中，程序在 await p 后就已经继续执行了，不会再回到 then 里的回调函数。 所以，最后只会输出 await end 。 1[&apos;2.1.2&apos;, &apos;0.402.1&apos;, &apos;3.20.1&apos;, &apos;0.1.8&apos;, &apos;5.1.2&apos;, &apos;1.3.4.5&apos;] 你可以使用 JavaScript 的 sort() 方法对数组进行排序，以下是一个示例代码： 123const arr = [&apos;2.1.2&apos;, &apos;0.402.1&apos;, &apos;3.20.1&apos;, &apos;0.1.8&apos;, &apos;5.1.2&apos;, &apos;1.3.4.5&apos;];arr.sort();console.log(arr); 执行上面的代码后，将会对数组进行排序，并将排序后的结果输出到控制台。","categories":[{"name":"前端面试题","slug":"前端面试题","permalink":"https://qw8.github.io/categories/前端面试题/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qw8.github.io/tags/JavaScript/"},{"name":"编程题","slug":"编程题","permalink":"https://qw8.github.io/tags/编程题/"},{"name":"算法","slug":"算法","permalink":"https://qw8.github.io/tags/算法/"}]},{"title":"JavaScript不常考","slug":"interview/JavaScript不常考","date":"2020-05-18T12:41:19.000Z","updated":"2023-12-19T02:01:34.000Z","comments":true,"path":"/interview/javascript-bu-chang-kao.html","link":"","permalink":"https://qw8.github.io/interview/javascript-bu-chang-kao.html","excerpt":"","text":"如何测试前端代码? 知道 BDD, TDD, Unit Test 么? 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)了解 BDD 行为驱动开发与 TDD 测试驱动开发已经单元测试相关概念 检测浏览器版本版本有哪些方式？ 根据 navigator.userAgent // UA.toLowerCase().indexOf(‘chrome’) 根据 window 对象的成员 // ‘ActiveXObject’ in window 作用域-编译期执行期以及全局局部作用域问题js 执行主要的两个阶段：预解析和执行期 target 和 currentTarget 区别 event.target返回触发事件的元素 event.currentTarget返回绑定事件的元素 自动分号有时 JavaScript 会自动为代码行补上缺失的分号，即自动分号插入（Automatic SemicolonInsertion，ASI）。因为如果缺失了必要的 ; ，代码将无法运行，语言的容错性也会降低。ASI 能让我们忽略那些不必要的 ; 。请注意，ASI 只在换行符处起作用，而不会在代码行的中间插入分号。如果 JavaScript 解析器发现代码行可能因为缺失分号而导致错误，那么它就会自动补上分号。并且，只有在代码行末尾与换行符之间除了空格和注释之外没有别的内容时，它才会这样做。 浮点数精度参考 自执行函数?用于什么场景？好处?自执行函数:1、声明一个匿名函数 2、马上调用这个匿名函数。作用：创建一个独立的作用域。 好处：防止变量弥散到全局，以免各种 js 库冲突。隔离作用域避免污染，或者截断作用域链，避免闭包造成引用变量无法释放。利用立即执行特性，返回需要的业务函数或对象，避免每次通过条件判断来处理 场景：一般用于框架、插件等场景 css 动画和 js 动画的差异 代码复杂度，js 动画代码相对复杂一些 动画运行时，对动画的控制程度上，js 能够让动画，暂停，取消，终止，css 动画不能添加事件 动画性能看，js 动画多了一个 js 解析的过程，性能不如 css 动画好 解析：参考 如何实现文件断点续传断点续传最核心的内容就是把文件“切片”然后再一片一片的传给服务器，但是这看似简单的上传过程却有着无数的坑。 首先是文件的识别，一个文件被分成了若干份之后如何告诉服务器你切了多少块，以及最终服务器应该如何把你上传上去的文件进行合并，这都是要考虑的。 因此在文件开始上传之前，我们和服务器要有一个“握手”的过程，告诉服务器文件信息，然后和服务器约定切片的大小，当和服务器达成共识之后就可以开始后续的文件传输了。 前台要把每一块的文件传给后台，成功之后前端和后端都要标识一下，以便后续的断点。 当文件传输中断之后用户再次选择文件就可以通过标识来判断文件是否已经上传了一部分，如果是的话，那么我们可以接着上次的进度继续传文件，以达到续传的功能。有了 HTML5 的 File api 之后切割文件比想想的要简单的多的多。 只要用 slice 方法就可以了 1var packet = file.slice(start, end); 参数 start 是开始切片的位置，end 是切片结束的位置 单位都是字节。通过控制 start 和 end 就可以是实现文件的分块 如 1234file.slice(0,1000);file.slice(1000,2000);file.slice(2000,3000);// ...... 在把文件切成片之后，接下来要做的事情就是把这些碎片传到服务器上。如果中间掉线了，下次再传的时候就得先从服务器获取上一次上传文件的位置，然后以这个位置开始上传接下来的文件内容。 解析：参考 JavaScript 以下哪条语句会产生运行错误A. var obj = (); B. var obj = []; C. var obj = {}; D. var obj = //; 答案：AD 以下哪些是 javascript 的全局函数：123456A. escape 函数可对字符串进行编码，这样就可以在所有的计算机上读取该字符串。ECMAScript v3 反对使用该方法，应用使用 decodeURI() 和 decodeURIComponent() 替代它。B. parseFloat parseFloat() 函数可解析一个字符串，并返回一个浮点数。该函数指定字符串中的首个字符是否是数字。如果是，则对字符串进行解析，直到到达数字的末端为止，然后以数字返回该数字，而不是作为字符串。C. eval 函数可计算某个字符串，并执行其中的的 JavaScript 代码。D. setTimeoutE. alert 答案：ABC 关于 IE 的 window 对象表述正确的有：1234A. window.opener属性本身就是指向window对象B. window.reload()方法可以用来刷新当前页面 应该是location.reload或者window.location.reloadC. window.location=”a.html”和window.location.href=”a.html”的作用都是把当前页面替换成a.html页面D. 定义了全局变量g；可以用window.g的方式来存取该变量 答案：ACD 描述错误的是1234A：HTTP状态码302表示暂时性转移B:domContentLoaded事件早于onload事件C: IE678不支持事件捕获D:localStorage 存储的数据在电脑重启后丢失 答案：D 解析： HTTP状态码302表示被请求的资源暂时转移(Moved temporatily)，然后会给出一个转移后的URL，而浏览器在处理服务器返回的302错误时，原则上会重新建立一个TCP连接，然后再取重定向后的URL的页面；但是如果页面存在于缓存中，则不重新获取； onload事件触发时，页面上所有的DOM，样式表，脚本，图片，flash都已经加载完成了，domContentLoaded事件触发时，仅当DOM加载完成，不包括样式表，图片，flash。 C正确，故选D 下面正确的是1234A: 跨域问题能通过JsonP方案解决B：不同子域名间仅能通过修改window.name解决跨域 还可以通过script标签src jsonp等h5 Java split等C：只有在IE中可通过iframe嵌套跨域D：MediaQuery属性是进行视频格式检测的属性是做响应式的 答案：A 谈一下 JS 中的递归函数，并且用递归简单实现阶乘递归即是程序在执行过程中不断调用自身的编程技巧，当然也必须要有一个明确的结束条件，不然就会陷入死循环。 JavaScript alert(0.4*0.2);结果是多少？和你预期的一样吗？如果不一样该如何处理？有误差，应该比准确结果偏大。 一般我会将小数变为整数来处理。当前之前遇到这个问题时也上网查询发现有人用 try catch return 写了一个函数，当然原理也是一致先转为整数再计算。看起来挺麻烦的，我没用过。 请写一个正则表达式：要求最短 6 位数，最长 20 位，阿拉伯数和英文字母（不区分大小写）组成^(?=._\\d)(?=._[a-z])(?=.\\*[A-Z])[a-zA-Z\\d]{6,20}$ 如何将字符串转化为数字，例如’12.3b’? parseFloat(‘12.3b’); 正则表达式，’12.3b’.match(/(\\d)+(.)?(\\d)+/g)[0] * 1, 但是这个不太靠谱，提供一种思路而已 如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为『12,000,000.11』?1234567function commafy(num)&#123; return num &amp;&amp; num .toString() .replace(/(\\d)(?=(\\d&#123;3&#125;)+\\.)/g, function($1, $2)&#123; return $2 + &apos;,&apos;; &#125;);&#125; [“1”, “2”, “3”].map(parseInt) 答案是多少？ parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)，其中 radix 表示要解析的数字的基数 12345function parseInt(str, radix) &#123; return str+&apos;-&apos;+radix;&#125;;var a=[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;];a.map(parseInt); // [&quot;1-0&quot;, &quot;2-1&quot;, &quot;3-2&quot;] 不能大于radix 因为二进制里面，没有数字3,导致出现超范围的radix赋值和不合法的进制解析，才会返回NaN 所以[“1”, “2”, “3”].map(parseInt) 答案也就是：[1, NaN, NaN] 解释一下这段代码的意思吗？123[].forEach.call($$(\"*\"), function(el)&#123; el.style.outline = \"1px solid #\" + (~~(Math.random()*(1&lt;&lt;24))).toString(16);&#125;) 解释：获取页面所有的元素，遍历这些元素，为它们添加1像素随机颜色的轮廓(outline) $$(sel) // $$函数被许多现代浏览器命令行支持，等价于 document.querySelectorAll(sel) [].forEach.call(NodeLists) // 使用 call 函数将数组遍历函数 forEach 应到节点元素列表 el.style.outline = &quot;1px solid #333&quot; // 样式 outline 位于盒模型之外，不影响元素布局位置 (1&lt;&lt;24) // parseInt(“ffffff”, 16) == 16777215 == 2^24 - 1 // 1&lt;&lt;24 == 2^24 == 16777216 Math.random()*(1&lt;&lt;24) // 表示一个位于 0 到 16777216 之间的随机浮点数 ~~Math.random()*(1&lt;&lt;24) // ~~ 作用相当于 parseInt 取整 (~~(Math.random()*(1&lt;&lt;24))).toString(16) // 转换为一个十六进制- 知道什么是webkit么? 知道怎么用浏览器的各种工具来调试和debug代码么? Chrome,Safari浏览器内核 检测浏览器版本版本有哪些方式？ 功能检测、userAgent特征检测 比如：navigator.userAgent 12//&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36&quot; What is a Polyfill? polyfill 是“在旧版浏览器上复制标准 API 的 JavaScript 补充”,可以动态地加载 JavaScript 代码或库，在不支持这些标准 API 的浏览器中模拟它们 例如，geolocation（地理位置）polyfill 可以在 navigator 对象上添加全局的 geolocation 对象，还能添加 getCurrentPosition 函数以及“坐标”回调对象 所有这些都是 W3C 地理位置 API 定义的对象和函数。因为 polyfill 模拟标准 API，所以能够以一种面向所有浏览器未来的方式针对这些 API 进行开发 一旦对这些 API 的支持变成绝对大多数，则可以方便地去掉 polyfill，无需做任何额外工作。 做的项目中，有没有用过或自己实现一些 polyfill 方案（兼容性处理方案）？ 比如： html5shiv、Geolocation、Placeholder 使用JS实现获取文件扩展名？ 123function getFileExtension(filename) &#123; return filename.slice((filename.lastIndexOf(&quot;.&quot;) - 1 &gt;&gt;&gt; 0) + 2);&#125; String.lastIndexOf() 方法返回指定值（本例中的’.’）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。对于’filename’和’.hiddenfile’，lastIndexOf的返回值分别为0和-1无符号右移操作符(»&gt;) 将-1转换为4294967295，将-2转换为4294967294，这个方法可以保证边缘情况时文件名不变 String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为”” 遍历所有文档树所有节点(考察递归)的方法参考链接： https://blog.csdn.net/jjaze3344/article/details/7280321 https://blog.csdn.net/sinat_27346451/article/details/77073938 sort排序相关(注意ASCII这个坑)（参考链接）默认情况下，sort函数是按照ASCII字符排序。在ASCII字符排序中，是对应位相比较。18和5相比，实际上就是1和5相比，因为5只有一位数，所以只比较第一位。因为1&lt;5，所以就会出现错误的答案。 错误如： 123var a = [5,41,7,18]a.sort();alert(a); //18，41，5，7 解决方案： 如果省略参数，将默认为ASCII字符排序，简而言之，就是有了参数，就不是默认为ASCII字符排序了。 即： 12345var a=[5,41,7,18];a.sort(function (m, n)&#123; return m-n;&#125;);alert(a); //5,7,18,41 移动端开发相关参考链接： https://juejin.im/post/5a77d6086fb9a0634417bfd3 http://www.restran.net/2015/05/14/mobile-web-front-end-collections/ for in 和 for offor in 一般用于遍历对象的可枚举属性。以及对象从构造函数原型中继承的属性。对于每个不同的属性，语句都会被执行。 不建议使用 for in 遍历数组，因为输出的顺序是不固定的。 如果迭代的对象的变量值是 null 或者 undefined, for in 不执行循环体，建议在使用 for in 循环之前，先检查该对象的值是不是 null 或者 undefined for of for…of 语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句 解析： 1234567891011121314151617var s = &#123; a: 1, b: 2, c: 3&#125;;var s1 = Object.create(s);for (var prop in s1) &#123; console.log(prop); //a b c console.log(s1[prop]); //1 2 3&#125;for (let prop of s1) &#123; console.log(prop); //报错如下 Uncaught TypeError: s1 is not iterable&#125;for (let prop of Object.keys(s1)) &#123; console.log(prop); // a b c console.log(s1[prop]); //1 2 3&#125; for in、Object.keys 和 Object.getOwnPropertyNames 对属性遍历有什么区别？ for in 会遍历自身及原型链上的可枚举属性 Object.keys 会将对象自身的可枚举属性的 key 输出 会将自身所有的属性的 key 输出 解析： ECMAScript 将对象的属性分为两种：数据属性和访问器属性。 12345678910111213141516171819202122232425var parent = Object.create(Object.prototype, &#123; a: &#123; value: 123, writable: true, enumerable: true, configurable: true &#125;&#125;);// parent继承自Object.prototype，有一个可枚举的属性a（enumerable:true）。var child = Object.create(parent, &#123; b: &#123; value: 2, writable: true, enumerable: true, configurable: true &#125;, c: &#123; value: 3, writable: true, enumerable: false, configurable: true &#125;&#125;);//child 继承自 parent ，b可枚举，c不可枚举 for in123456for (var key in child) &#123; console.log(key);&#125;// b// a// for in 会遍历自身及原型链上的可枚举属性 如果只想输出自身的可枚举属性，可使用 hasOwnProperty 进行判断(数组与对象都可以，此处用数组做例子) 12345678910let arr = [1, 2, 3];Array.prototype.xxx = 1231235;for (let i in arr) &#123; if (arr.hasOwnProperty(i)) &#123; console.log(arr[i]); &#125;&#125;// 1// 2// 3 Object.keys123console.log(Object.keys(child));// [\"b\"]// Object.keys 会将对象自身的可枚举属性的key输出 Object.getOwnPropertyNames123console.log(Object.getOwnPropertyNames(child));// [\"b\",\"c\"]// 会将自身所有的属性的key输出 iframe 跨域通信和不跨域通信不跨域通信 主页面 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;iframe name=\"myIframe\" id=\"iframe\" class=\"\" src=\"flexible.html\" width=\"500px\" height=\"500px\" &gt; &lt;/iframe&gt; &lt;/body&gt; &lt;script type=\"text/javascript\" charset=\"utf-8\"&gt; function fullscreen() &#123; alert(1111); &#125; &lt;/script&gt;&lt;/html&gt; 子页面 flexible.html 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 我是子页面 &lt;/body&gt; &lt;script type=\"text/javascript\" charset=\"utf-8\"&gt; // window.parent.fullScreens() function showalert() &#123; alert(222); &#125; &lt;/script&gt;&lt;/html&gt; 1、主页面要是想要调取子页面的 showalert 方法 1myIframe.window.showalert(); 2、子页面要掉主页面的 fullscreen 方法 1window.parent.fullScreens(); 3、js 在 iframe 子页面获取父页面元素: 1window.parent.document.getElementById(\"元素id\"); 4、js 在父页面获取 iframe 子页面元素代码如下: 1window.frames[\"iframe_ID\"].document.getElementById(\"元素id\"); 跨域通信 使用postMessage(官方用法） 子页面 1window.parent.postMessage(\"hello\", \"http://127.0.0.1:8089\"); 父页面接收 123window.addEventListener(\"message\", function(event) &#123; alert(123);&#125;); 解析：参考 H5 与 Native 如何交互jsBridge 解析：参考 &lt;script&gt; 标签的 defer 和 asnyc 属性的作用以及二者的区别？ 1、defer 和 async 的网络加载过程是一致的，都是异步执行。 2、区别在于加载完成之后什么时候执行，可以看出 defer 是文档所有元素解析完成之后才执行的。 3、如果存在多个 defer 脚本，那么它们是按照顺序执行脚本的，而 async，无论声明顺序如何，只要加载完成就立刻执行 解析： 无论&lt;script&gt;标签是嵌入代码还是引用外部文件，只要不包含 defer 属性和 async 属性（这两个属性只对外部文件有效），浏览器会按照&lt;script&gt;的出现顺序对他们依次进行解析，也就是说，只有在第一个&lt;script&gt;中的代码执行完成之后，浏览器才会执行第二个&lt;script&gt;中的代码，并且在解析时，页面的处理会暂时停止。 嵌入代码的解析=执行外部文件的解析=下载+执行 script 标签存在两个属性，defer 和 async，这两个属性只对外部文件有效 只有一个脚本的情况 1&lt;script src=\"a.js\" /&gt; 没有 defer 或 async 属性，浏览器会立即下载并执行相应的脚本，并且在下载和执行时页面的处理会停止。 1&lt;script defer src=\"a.js\" /&gt; 有了 defer 属性，浏览器会立即下载相应的脚本，在下载的过程中页面的处理不会停止，等到文档解析完成脚本才会执行。 1&lt;script async src=\"a.js\" /&gt; 有了 async 属性，浏览器会立即下载相应的脚本，在下载的过程中页面的处理不会停止，下载完成后立即执行，执行过程中页面处理会停止。 1&lt;script defer async src=\"a.js\" /&gt; 如果同时指定了两个属性,则会遵从 async 属性而忽略 defer 属性。 下图可以直观的看出三者之间的区别: 其中蓝色代表 js 脚本网络下载时间，红色代表 js 脚本执行，绿色代表 html 解析。 多个脚本的情况 这里只列举两个脚本的情况： 12&lt;script src=\"a.js\"&gt;&lt;/script&gt;&lt;script src=\"b.js\"&gt;&lt;/script&gt; 没有 defer 或 async 属性，浏览器会立即下载并执行脚本 a.js，在 a.js 脚本执行完成后才会下载并执行脚本 b.js，在脚本下载和执行时页面的处理会停止。 12&lt;script defer src=\"a.js\"&gt;&lt;/script&gt;&lt;script defer src=\"b.js\"&gt;&lt;/script&gt; 有了 defer 属性，浏览器会立即下载相应的脚本 a.js 和 b.js，在下载的过程中页面的处理不会停止，等到文档解析完成才会执行这两个脚本。HTML5 规范要求脚本按照它们出现的先后顺序执行，因此第一个延迟脚本会先于第二个延迟脚本执行，而这两个脚本会先于 DOMContentLoaded 事件执行。在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在 DOMContentLoaded 事件触发前执行，因此最好只包含一个延迟脚本。 12&lt;script async src=\"a.js\"&gt;&lt;/script&gt;&lt;script async src=\"b.js\"&gt;&lt;/script&gt; 有了 async 属性，浏览器会立即下载相应的脚本 a.js 和 b.js，在下载的过程中页面的处理不会停止，a.js 和 b.js 哪个先下载完成哪个就立即执行，执行过程中页面处理会停止，但是其他脚本的下载不会停止。标记为 async 的脚本并不保证按照制定它们的先后顺序执行。异步脚本一定会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 事件触发之前或之后执行。 参考 Object.prototype.toString.call() 和 instanceOf 和 Array.isArray() 区别好坏 Object.prototype.toString.call() 优点：这种方法对于所有基本的数据类型都能进行判断，即使是 null 和 undefined 。 缺点：不能精准判断自定义对象，对于自定义对象只会返回[object Object] instanceOf 优点：instanceof 可以弥补 Object.prototype.toString.call()不能判断自定义实例化对象的缺点。 缺点： instanceof 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true，且不同于其他两种方法的是它不能检测出 iframes。 Array.isArray() 优点：当检测 Array 实例时，Array.isArray 优于 instanceof ，因为 Array.isArray 可以检测出 iframes 缺点：只能判别数组解析： Object.prototype.toString.call() 每一个继承 Object 的对象都有 toString 方法，如果 toString 方法没有重写的话，会返回 [Object type]，其中 type 为对象的类型。但当除了 Object 类型的对象外，其他类型直接使用 toString 方法时，会直接返回都是内容的字符串，所以我们需要使用 call 或者 apply 方法来改变 toString 方法的执行上下文。 123const an = [\"Hello\", \"An\"];an.toString(); // \"Hello,An\"Object.prototype.toString.call(an); // \"[object Array]\" 这种方法对于所有基本的数据类型都能进行判断，即使是 null 和 undefined 。 1234567Object.prototype.toString.call(\"An\"); // \"[object String]\"Object.prototype.toString.call(1); // \"[object Number]\"Object.prototype.toString.call(Symbol(1)); // \"[object Symbol]\"Object.prototype.toString.call(null); // \"[object Null]\"Object.prototype.toString.call(undefined); // \"[object Undefined]\"Object.prototype.toString.call(function() &#123;&#125;); // \"[object Function]\"Object.prototype.toString.call(&#123; name: \"An\" &#125;); // \"[object Object]\" 缺点：不能精准判断自定义对象，对于自定义对象只会返回[object Object] 1234567function f(name) &#123; this.name = name;&#125;var f1 = new f(\"martin\");console.log(Object.prototype.toString.call(f1)); //[object Object]Object.prototype.toString.call(); // 常用于判断浏览器内置对象。 Array.isArray() 功能：用来判断对象是否为数组 instanceof 与 isArray 当检测 Array 实例时，Array.isArray 优于 instanceof ，因为 Array.isArray 可以检测出 iframes 12345678910var iframe = document.createElement(\"iframe\");document.body.appendChild(iframe);xArray = window.frames[window.frames.length - 1].Array;var arr = new xArray(1, 2, 3); // [1,2,3]// Correctly checking for ArrayArray.isArray(arr); // trueObject.prototype.toString.call(arr); // true// Considered harmful, because doesn't work though iframesarr instanceof Array; // false 缺点：只能判别数组 Array.isArray() 与 Object.prototype.toString.call() Array.isArray()是 ES5 新增的方法，当不存在 Array.isArray() ，可以用 Object.prototype.toString.call() 实现。 12345if (!Array.isArray) &#123; Array.isArray = function(arg) &#123; return Object.prototype.toString.call(arg) === \"[object Array]\"; &#125;;&#125; 参考 你对松散类型的理解JavaScript 中的变量为松散类型，所谓松散类型就是指当一个变量被申明出来就可以保存任意类型的值，就是不像 SQL 一样申明某个键值为 int 就只能保存整型数值，申明 varchar 只能保存字符串。一个变量所保存值的类型也可以改变，这在 JavaScript 中是完全有效的，只是不推荐。相比较于将变量理解为“盒子“，《JavaScript 编程精解》中提到应该将变量理解为“触手”，它不保存值，而是抓取值。这一点在当变量保存引用类型值时更加明显。 JavaScript 中变量可能包含两种不同的数据类型的值：基本类型和引用类型。基本类型是指简单的数据段，而引用类型指那些可能包含多个值的对象。 JS 严格模式和正常模式严格模式使用”use strict”; 作用： 消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的 Javascript 做好铺垫。 表现： 严格模式下, delete 运算符后跟随非法标识符(即 delete 不存在的标识符)，会抛出语法错误； 非严格模式下，会静默失败并返回 false 严格模式中，对象直接量中定义同名属性会抛出语法错误； 非严格模式不会报错 严格模式中，函数形参存在同名的，抛出错误； 非严格模式不会 严格模式不允许八进制整数直接量（如：023） 严格模式中，arguments 对象是传入函数内实参列表的静态副本；非严格模式下，arguments 对象里的元素和对应的实参是指向同一个值的引用 严格模式中 eval 和 arguments 当做关键字，它们不能被赋值和用作变量声明 严格模式会限制对调用栈的检测能力，访问 arguments.callee.caller 会抛出异常 严格模式 变量必须先声明，直接给变量赋值，不会隐式创建全局变量，不能用 with, 严格模式中 call apply 传入 null undefined 保持原样不被转换为 window 解析： 一、概述 除了正常运行模式，ECMAscript 5 添加了第二种运行模式：”严格模式”（strict mode）。顾名思义，这种模式使得 Javascript 在更严格的条件下运行。 设立”严格模式”的目的，主要有以下几个： 消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的 Javascript 做好铺垫。 “严格模式”体现了 Javascript 更合理、更安全、更严谨的发展方向，包括 IE 10 在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。 另一方面，同样的代码，在”严格模式”中，可能会有不一样的运行结果；一些在”正常模式”下可以运行的语句，在”严格模式”下将不能运行。掌握这些内容，有助于更细致深入地理解 Javascript，让你变成一个更好的程序员。 本文将对”严格模式”做详细介绍。 二、进入标志 进入”严格模式”的标志，是下面这行语句： “use strict”; 老版本的浏览器会把它当作一行普通字符串，加以忽略。 三、如何调用 “严格模式”有两种调用方法，适用于不同的场合。 3.1 针对整个脚本文件 将”use strict”放在脚本文件的第一行，则整个脚本都将以”严格模式”运行。如果这行语句不在第一行，则无效，整个脚本以”正常模式”运行。如果不同模式的代码文件合并成一个文件，这一点需要特别注意。 (严格地说，只要前面不是产生实际运行结果的语句，”use strict”可以不在第一行，比如直接跟在一个空的分号后面。) 12345678 &lt;script&gt; \"use strict\"; console.log(\"这是严格模式。\"); &lt;/script&gt; &lt;script&gt; console.log(\"这是正常模式。\");kly, it's almost 2 years ago now. I can admit it now - I run it on my school's network that has about 50 computers. &lt;/script&gt; 上面的代码表示，一个网页中依次有两段 Javascript 代码。前一个 script 标签是严格模式，后一个不是。 3.2 针对单个函数 将”use strict”放在函数体的第一行，则整个函数以”严格模式”运行。 12345678function strict() &#123; \"use strict\"; return \"这是严格模式。\";&#125;function notStrict() &#123; return \"这是正常模式。\";&#125; 3.3 脚本文件的变通写法 因为第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中。 1234(function() &#123; \"use strict\"; // some code here&#125;)(); 四、语法和行为改变 严格模式对 Javascript 的语法和行为，都做了一些改变。 4.1 全局变量显式声明 在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。 1234567\"use strict\";v = 1; // 报错，v未声明for (i = 0; i &lt; 2; i++) &#123; // 报错，i未声明&#125; 因此，严格模式下，变量都必须先用 var 命令声明，然后再使用。 4.2 静态绑定 Javascript 语言的一个特点，就是允许”动态绑定”，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。 严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外。 具体来说，涉及以下几个方面。 （1）禁止使用 with 语句 因为 with 语句无法在编译时就确定，属性到底归属哪个对象。 1234567 \"use strict\"; var v = 1; with (o)&#123; // 语法错误 v = 2; &#125; （2）创设 eval 作用域 正常模式下，Javascript 语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：eval 作用域。 正常模式下，eval 语句的作用域，取决于它处于全局作用域，还是处于函数作用域。严格模式下，eval 语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于 eval 内部。 1234567\"use strict\";var x = 2;console.info(eval(\"var x = 5; x\")); // 5console.info(x); // 2 4.3 增强的安全措施 （1）禁止 this 关键字指向全局对象 1234567function f() &#123; return !this;&#125; // 返回false，因为\"this\"指向全局对象，\"!this\"就是falsefunction f() &#123; \"use strict\"; return !this;&#125; // 返回true，因为严格模式下，this的值为undefined，所以\"!this\"为true。 因此，使用构造函数时，如果忘了加 new，this 不再指向全局对象，而是报错。 1234567function f() &#123; \"use strict\"; this.a = 1;&#125;f(); // 报错，this未定义 （2）禁止在函数内部遍历调用栈 123456789function f1() &#123; \"use strict\"; f1.caller; // 报错 f1.arguments; // 报错&#125;f1(); 4.4 禁止删除变量 严格模式下无法删除变量。只有 configurable 设置为 true 的对象属性，才能被删除。 123456789101112 \"use strict\"; var x; delete x; // 语法错误 var o = Object.create(null, &#123;'x': &#123; value: 1, configurable: true &#125;&#125;); delete o.x; // 删除成功 4.5 显式报错 正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。 1234567\"use strict\";var o = &#123;&#125;;Object.defineProperty(o, \"v\", &#123; value: 1, writable: false &#125;);o.v = 2; // 报错 严格模式下，对一个使用 getter 方法读取的属性进行赋值，会报错。 123456789\"use strict\";var o = &#123; get v() &#123; return 1; &#125;&#125;;o.v = 2; // 报错 严格模式下，对禁止扩展的对象添加新属性，会报错。 1234567\"use strict\";var o = &#123;&#125;;Object.preventExtensions(o);o.v = 1; // 报错 严格模式下，删除一个不可删除的属性，会报错。 123\"use strict\";delete Object.prototype; // 报错 4.6 重名错误 严格模式新增了一些语法错误。 （1）对象不能有重名的属性 正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。 123456\"use strict\";var o = &#123; p: 1, p: 2&#125;; // 语法错误 （2）函数不能有重名的参数 正常模式下，如果函数有多个重名的参数，可以用 arguments[i]读取。严格模式下，这属于语法错误。 1234567 \"use strict\"; function f(a, a, b) &#123; // 语法错误 return ; &#125; 4.7 禁止八进制表示法 正常模式下，整数的第一位如果是 0，表示这是八进制数，比如 0100 等于十进制的 64。严格模式禁止这种表示法，整数第一位为 0，将报错。 123 \"use strict\"; var n = 0100; // 语法错误 4.8 arguments 对象的限制 arguments 是函数的参数对象，严格模式对它的使用做了限制。 （1）不允许对 arguments 赋值 1234567891011 \"use strict\"; arguments++; // 语法错误 var obj = &#123; set p(arguments) &#123; &#125; &#125;; // 语法错误 try &#123; &#125; catch (arguments) &#123; &#125; // 语法错误 function arguments() &#123; &#125; // 语法错误 var f = new Function(\"arguments\", \"'use strict'; return 17;\"); // 语法错误 （2）arguments 不再追踪参数的变化 1234567891011121314151617function f(a) &#123; a = 2; return [a, arguments[0]];&#125;f(1); // 正常模式为[2,2]function f(a) &#123; \"use strict\"; a = 2; return [a, arguments[0]];&#125;f(1); // 严格模式为[2,1] （3）禁止使用 arguments.callee 这意味着，你无法在匿名函数内部调用自身了。 1234567\"use strict\";var f = function() &#123; return arguments.callee;&#125;;f(); // 报错 4.9 函数必须声明在顶层 将来 Javascript 的新版本会引入”块级作用域”。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。 123456789\"use strict\";if (true) &#123; function f() &#123;&#125; // 语法错误&#125;for (var i = 0; i &lt; 5; i++) &#123; function f2() &#123;&#125; // 语法错误&#125; 4.10 保留字 为了向将来 Javascript 的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。 使用这些词作为变量名将会报错。 1234567 function package(protected) &#123; // 语法错误 \"use strict\"; var implements; // 语法错误 &#125; 此外，ECMAscript 第五版本身还规定了另一些保留字（class, enum, export, extends, import, super），以及各大浏览器自行增加的 const 保留字，也是不能作为变量名的。 参考 移动端 click 事件、touch 事件、tap 事件的区别 click 事件在移动端会有 200-300ms ms 的延迟，主要原因是苹果手机在设计时，考虑到用户在浏览网页时需要放大，所以，在用户点击的 200-300ms 之后，才触发 click，如果 200-300ms 之内还有 click，就会进行放大缩小。 touch 事件是针对触屏手机上的触摸事件。现今大多数触屏手机 webkit 内核提供了 touch 事件的监听，让开发者可以获取用户触摸屏幕时的一些信息。其中包括：touchstart,touchmove,touchend,touchcancel 这四个事件，touchstart touchmove touchend 事件可以类比于 mousedown mouseover mouseup 的触发 tap 事件在移动端，代替 click 作为点击事件，tap 事件被很多框架（如 zepto）封装，来减少这延迟问题， tap 事件不是原生的，所以是封装的，那么具体是如何实现的呢？ 12345678910111213141516171819202122232425262728293031323334&lt;script&gt; function tap(ele, callback) &#123; // 记录开始时间 var startTime = 0, // 控制允许延迟的时间 delayTime = 200, // 记录是否移动，如果移动，则不触发tap事件 isMove = false; // 在touchstart时记录开始的时间 ele.addEventListener('touchstart', function (e) &#123; startTime = Date.now(); &#125;); // 如果touchmove事件被触发，则isMove为true ele.addEventListener('touchmove', function (e) &#123; isMove = true; &#125;); // 如果touchmove事件触发或者中间时间超过了延迟时间，则返回，否则，调用回调函数。 ele.addEventListener('touchend', function (e) &#123; if (isMove || (Date.now() - startTime &gt; delayTime)) &#123; return; &#125; else &#123; callback(e); &#125; &#125;) &#125; var btn = document.getElementById('btn'); tap(btn, function () &#123; alert('taped'); &#125;);&lt;/script&gt; 拓展： 正则表达式构造函数 var reg = new RegExp(‘xxx’)与正则表达字面量 var reg = // 有什么不同？使用正则表达字面量的效率更高 解析：下面的示例代码演示了两种可用于创建正则表达式以匹配反斜杠的方法： 123456789//正则表达字面量var re = /\\\\/gm;//正则构造函数var reg = new RegExp(\"\\\\\\\\\", \"gm\");var foo = \"abc\\\\123\"; // foo的值为\"abc\\123\"console.log(re.test(foo)); //trueconsole.log(reg.test(foo)); //true 如上面的代码中可以看到，使用正则表达式字面量表示法时式子显得更加简短，而且不用按照类似类（class-like）的构造函数方式思考。 其次，在当使用构造函数的时候，在这里要使用四个反斜杠才能匹配单个反斜杠。这使得正则表达式模式显得更长，更加难以阅读和修改。正确来说，当使用 RegExp()构造函数的时候，不仅需要转义引号（即&quot;表示”），并且通常还需要双反斜杠（即\\表示一个\\）。 使用 new RegExp()的原因之一在于，某些场景中无法事先确定模式，而只能在运行时以字符串方式创建。 参考 js 中 callee 与 caller 的作用 caller 返回一个调用当前函数的引用 如果是由顶层调用的话 则返回 null （举个栗子哈 caller 给你打电话的人 谁给你打电话了 谁调用了你 很显然是下面 a 函数的执行 只有在打电话的时候你才能知道打电话的人是谁 所以对于函数来说 只有 caller 在函数执行的时候才存在） 12345678var callerTest = function() &#123; console.log(callerTest.caller);&#125;;function a() &#123; callerTest();&#125;a(); //输出function a() &#123;callerTest();&#125;callerTest(); //输出null callee 返回一个正在被执行函数的引用 （这里常用来递归匿名函数本身 但是在严格模式下不可行） callee 是 arguments 对象的一个成员 表示对函数对象本身的引用 它有个 length 属性（代表形参的长度） 1234var c = function(x, y) &#123; console.log(arguments.length, arguments.callee.length, arguments.callee);&#125;;c(1, 2, 3); //输出3 2 function(x,y) &#123;console.log(arguments.length,arguments.callee.length,arguments.callee)&#125; 异步加载 js 的方法方案一：&lt;script&gt;标签的 async=”async”属性（详细参见：script 标签的 async 属性） 点评：HTML5 中新增的属性，Chrome、FF、IE9&amp;IE9+均支持（IE6~8 不支持）。此外，这种方法不能保证脚本按顺序执行。 方案二：&lt;script&gt;标签的 defer=”defer”属性 点评：兼容所有浏览器。此外，这种方法可以确保所有设置 defer 属性的脚本按顺序执行。 方案三：动态创建&lt;script&gt;标签 示例： 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script type=\"text/javascript\"&gt; (function() &#123; var s = document.createElement_x(\"script\"); s.type = \"text/javascript\"; s.src = \"http://code.jquery.com/jquery-1.7.2.min.js\"; var tmp = document.getElementsByTagName_r(\"script\")[0]; tmp.parentNode.insertBefore(s, tmp); &#125;)(); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=\"http://xybtv.com/uploads/allimg/100601/48-100601162913.jpg\" /&gt; &lt;/body&gt;&lt;/html&gt; 点评：兼容所有浏览器。 方案四：AJAX eval（使用 AJAX 得到脚本内容，然后通过 eval_r(xmlhttp.responseText)来运行脚本） 点评：兼容所有浏览器。 方案五：iframe 方式（这里可以参照：iframe 异步加载技术及性能 中关于 Meboo 的部分） 点评：兼容所有浏览器。 JS 中 文档碎片的理解和使用 1、什么是文档碎片？ document.createDocumentFragment(); // 一个容器，用于暂时存放创建的dom元素 2、文档碎片有什么用？ // 将需要添加的大量元素,先添加到文档碎片中，再将文档碎片添加到需要插入的位置，大大 减少dom操作，提高性能（IE和火狐比较明显） 解析： 1234567891011121314// 普通方式：（操作了100次dom）for (var i = 100; i &gt; 0; i--) &#123; var elem = document.createElement(\"div\"); document.body.appendChild(elem); //放到body中&#125;// 文档碎片：(操作1次dom)var df = document.createDocumentFragment();for (var i = 100; i &gt; 0; i--) &#123; var elem = document.createElement(\"div\"); df.appendChild(elem);&#125;//最后放入到页面上document.body.appendChild(df); 点透问题如果我们在移动端所有的 click 都替换为了 tap 事件，还是会触发点透问题的，因为实质是： 在同一个 z 轴上，z-index 不同的两个元素，上面的元素是一个绑定了 tap 事件的，下面是一个 a 标签，一旦 tap 触发，这个元素就会 display: none，而从上面的 tap 可以看出，有 touchstart、touchend，所以会 300ms 之后触发 click 事件，而 z-index 已经消失了，所以，触发了下面的 a 的 click 事件，注意： 我们认为 a 标签默认是绑定了 click 事件的。而这种现象不是我们所期待的。 解决方案： （1）使用 fastclick。 （2）添加一个延迟。 （1）直接引入 fastclick 库。 1234567window.addEventListener( \"load\", function() &#123; FastClick.attach(document.body); &#125;, false); 这样，就可以成功解决问题了。 （2）对于上一个 tap 做延迟。 12345tap(ele, function() &#123; setTimeout(function() &#123; ele.style.display = \"none\"; &#125;, 300);&#125;); 这样，过了 300ms，那么 click 事件就不会触发在下面的 a 标签上了。 JS 单线程还是多线程，如何显示异步操作JS 本身是单线程的，他是依靠浏览器完成的异步操作。 解析： 具体步骤， 1、主线程 执行 js 中所有的代码。 2、主线程 在执行过程中发现了需要异步的任务任务后扔给浏览器（浏览器创建多个线程执行），并在 callback queque 中创建对应的回调函数（回调函数是一个对象，包含该函数是否执行完毕等）。 3、主线程 已经执行完毕所有同步代码。开始监听 callback queque 一旦 浏览器 中某个线程任务完成将会改变回调函数的状态。主线程查看到某个函数的状态为已完成，就会执行该函数。","categories":[{"name":"前端面试题","slug":"前端面试题","permalink":"https://qw8.github.io/categories/前端面试题/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qw8.github.io/tags/JavaScript/"},{"name":"BOM","slug":"BOM","permalink":"https://qw8.github.io/tags/BOM/"},{"name":"DOM","slug":"DOM","permalink":"https://qw8.github.io/tags/DOM/"}]},{"title":"面向对象","slug":"knowledges/面向对象","date":"2020-04-19T04:18:49.000Z","updated":"2024-04-03T16:54:30.000Z","comments":true,"path":"/knowledges/mian-xiang-dui-xiang.html","link":"","permalink":"https://qw8.github.io/knowledges/mian-xiang-dui-xiang.html","excerpt":"","text":"面向对象的程序设计什么是面向对象？谈谈对面向对象的理解？面向对象。它是指把数据与数据的操作方法放在一起，作为一个相互依赖的 整体，即对象。对同类对象抽象出其共性，及类，类中的大多数数据，只能被本类进行处理。站在抽象的角度，例如人，特征，行为。 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。 面向过程。它是以事件为中心的开发方法，逐步有序执行。 面向对象和面向过程的异同 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。 面向对象的三大特性1.封装：封装是指将客观事物抽象成类。每个类对自身的数据和方法实行保护。类可以把自己的数据和方法只让可信的类或者对象操作。对不可信的隐藏。 2.继承：继承是一种联结类的层次模型，并且允许和鼓励类的重用，提供了一种明确表述共性的方法。对象可以从现有的类中派生。这个过程叫做类的继承。 2.多态：多态是指允许不同类的对象对同一方法（消息）作出响应，实际执行逻辑不同。需要 继承、方法重写、父类指向子类对象 三条件。但是父类无法调用子类中特有的功能。 面向对象开发的优点：1、较高的开发效率。2、保证软件的鲁棒性。3、保证软件的高可维护性。 其实有时间可以看向面向对象的语言 比如JAVA 推荐 《First Head Java》，有可能的话还是希望你先学习的是强类型的语言。 简介 面向对象的语言有一个标志，那就是他们都有类的概念（es6也有类了奥 不过是语法糖），而通过类可以创建任意多个具有相同属性和方法的对象。 可惜的是ECMAScript中没有类的概念，因此它的对象也与基于累的语言中的对象有所不同。 ECMA-262把对象定义为 无序属性的集合，其属性可以包含基本值、对象或者函数。严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。 正因为这样，我们可以把ECMAScript的对象想象成散列表。 无非就是一组名值对，其中值可以是数据或函数。 每个对象都是基于一个引用类型创建的，这个引用类型可以是原生类型，也可以是开发人员定义的类型。 理解对象 创建自定义对象的最简单方式就是创建一个Object的实例，然后再为它添加属性和方法。 12345678var person = new Person();person.name = 'Nicholas';person.age = 29;person.job = \"Software Engineer\";person.sayName = function()&#123; alert( this.name )&#125; 后来，对象字面量成为创建对象的首选模式 12345678var person = &#123; name: 'Nicholas', age: 29, job: \"Software Engineer\", sayName: function()&#123; alert( this.name ) &#125;&#125; 属性类型 ECMA-262第5版在定义只有内部采用的特性（attribute）时，描述了属性（property）的各种特征。 定义这些特性是为了实现JS引擎用的，因此在JS中不能直接访问他们。 为了表示特性是内部属性值，该规范把他们放在了两对儿方括号中， 例如[[Enumerable]]。 数据属性 数据属性包含一个数据值的位置。在这个位置可以读取和写入值。 [[Configurable]]: 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，他们的这个特性默认值是true。 [[Enumerable]]: 表示能否通过for-in循环返回属性。像前面那样直接在对象上定义的属性，他们的这个特性默认值是true。 [[Writable]]: 表示能否修改属性的值。向前面例子中那样直接在对象上定义的属性，他们的这个特性默认是是true。 [[Value]]: 包含这个属性的数据值。读取属性值的时候，从这个位置读。写入属性值的时候，把新值保存在这个位置。这个特性的默认值是undefined。1234var person = &#123; name: 'Nicholas'&#125;;// 它的[[Configurable]]、 [[Enumerable]]、 [[Writable]] 特性都被设置为true， 而 [[Value]] 被设置成了指定的值。 Object.defineProperty() 要修改如上属性默认的特性的方法。 这个方法接收三个参数： 属性所在的对象、属性的名字和一个描述符对象。 描述符（descriptor）对象的属性必须是： configurable、 enumerable、 writable和value。设置其中的一或多个值，可以修改对应的特性值。 12345678var person = &#123;&#125;;Object.defineProperty( person, 'name', &#123; writable: false, value: 'Nicholas'&#125;);// 在费严格模式下，赋值操作将被忽略； 严格模式下，赋值操作将会抛出错误。person.name = 'Greg';alert( person.name ); // Nicholas 把configurable设置成false，表示不能从对象中删除属性。如果对这个属性调用delete，在诶严格模式下什么也不会发生，而再严格模式下会导致错误。而且，一旦把属性定义为不可配置的就不能再把它变回可配置了。此时，再调用Obejct.defineProperty()方法修改除writable之外的特性，都会导致错误。 在调用Object.defineProperty()方法时，如果不指定，configurable、enumerable和writable特性的默认值都是false。 访问器属性 访问器属性不包含数据值。 他们包含一对儿getter和setter函数（这两个函数都不是必须的）。 在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值。 在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。 访问器的4个属性 [[Configurable]]: 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为true。 [[Enumerable]]: 能否通过for-in循环返回属性。对于直接在对象上定义的属性，这个特性的默认值是true。 [[Get]]: 在读取属性时调用的函数， 默认值为undefined [[Set]]: 在写入属性时调用的函数， 默认值为undefined 访问器属性不能直接定义，必须使用Object.defineProperty()来定义。 1234567891011121314151617var book = &#123; _year: 2004, edition: 1&#125;;Object.defineProperty( book, 'year', &#123; get: function()&#123; return this._year &#125;, set: function()&#123; if( newValue &gt; 2004 )&#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;);book.year = 2005;console.log( book.edition ) // 2 不一定非要同时指定getter和setter。只指定getter意味着属性时不能写，尝试写入属性会被忽略。在严格模式下，尝试写入只指定了getter函数的属性会抛出错误。 只指定setter函数的属性也不能读，否则在非严格模式下会返回undefined，严格模式下会抛出错误。 Object.defineProperty()的向下兼容 支持ECMAScript5的这个方法的浏览器有IE9+(IE8只是部分实现)、Firefox 4+、 Opera 12+、 Chrome。 在这个方法之前要创建访问器属性，一般使用两个非标准方法： __defineGetter__()和__defineSetter__()。这两个方法最初是由Firefox引入的，后来Safari 3、Chrome 1和Opera 9.5也给出了相同的实现。 1234567891011121314151617// 重现上述方法var book = &#123; _year: 2004, edition: 1&#125;;// 定义访问器的旧有方法book.__defineGetter__( 'year', function()&#123; return this._year&#125; );book.__defineSetter__( 'year', function()&#123; if( newValue &gt; 2004 )&#123; this._year = newValue; this.edition += newValue - 2004; &#125;&#125; );book.year = 2005;alert( book.edition ); // 12 在不支持Object.defineProperty()方法的浏览器中不能修改[[Configurable]]和[[Enumerable]]。 定义多个属性 由于未对象定义多个属性的可能性很大，ECMAScript5又定义了一个 Object.defineProperties()方法。 利用这个方法可以通过描述符一次定义多个属性。 该方法接收两个对象参数： 第一个对象是要添加和修改其属性的对象，第二个对象的属性和第一个对象中要添加或修改的属性一一对应。 1234567891011121314151617181920var book = &#123;&#125;;Object.defineProperties( book, &#123; _year: &#123; value: 2004 &#125;, edition: &#123; value: 1 &#125;, year: &#123; get: function()&#123; return this._year &#125; &#125;, set: function( newValue )&#123; if( newValue &gt; 2004 )&#123; this._year = newValue; this.edition += newValue - 2004 &#125; &#125;&#125; ) 兼容性： IE9+、Firefox 4+、Safari 5+、Opera 12+、Chrome 读取属性的特性 使用ECMAScript5的Object.getOwnPropertyDescriptor()方法，可以取得给定属性描述符 参数1： 属性所在的对象 参数2： 要读取其描述符的属性名称。 返回值是一个对象。如果是访问其属性，这个对象有configurable、 enumerable、 get、 set；如果是数据属性，这个对象的属性有configurable、 enumerable、writable和value。 1234567891011121314151617181920212223var book = &#123;&#125;;Object.defineProperties( book, &#123; _year: &#123; value: 2004 &#125;, edition: &#123; value: 1 &#125;, year: &#123; get: function()&#123; return this._year; &#125;, set: function( newValue )&#123; if( newValue &gt; 2004 )&#123; this._year = newValue; this.edition += newValue - 2004 &#125; &#125; &#125;&#125; );var descriptor = Object.getOwnPropertyDescriptor( book, \"_year\" );alert( descriptor.value ) // 2004alert( descriptor.configurable ) // false 对于数据属性_year，value等于最初的值，configurable是false，而get等于undefined。对于访问器属性year，value等于undefined，enumerable是false，而get是一个指向setter函数的指针。 在JS中，可以针对任何对象——包括DOM和BOM对象，使用Object.getOwnPropertyDescriptor()方法。 兼容性和Object.defineproperty()相同。 创建对象工厂模式 虽然Object够咱函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用一个接口创建很多对象，会产生大量的重复代码。 工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程。 考虑到在ECMAScript中无法创建类，开发人员发明了一种函数，用函数来封装以特定接口创建对象的细节。 1234567891011function createPerson( name, age, job )&#123; var o = new Object(); o.name = name; o.job = job; o.sayName = function()&#123; alert( this.name ) &#125;; return o&#125;;var person1 = createPerson( \"Nicholas\", 29, \"Software Engineer\" );var person2 = createPerson( \"Greg\", 27, \"Doctor\" ); 优点： 解决了多个相似对象的问题。 缺点： 没有解决对象是别的问题（即怎样知道一个对象的类型）。 构造函数模式 ECMAScript中的构造函数可用来创建特定类型的对象。像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中。 也可以创建自定义的构造函数，从而定义自定义独享类型的属性和方法。 12345678910function Person( name, age, job )&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; alert( this.name ) &#125;&#125;;var person1 = new Person( \"Nicholas\", 29, \"Sofatware Engineer\" );var person2 = new Person( \"Greg\", 27, \"Doctor\" ) 没有显式地创建对象 直接将属性和方法赋给了this对象 没有return语句 函数名Peroson使用的是大写字母P。 按照惯例，够咱函数始终都应该以一个大写字母开头。而非构造函数则应该以一个小写字母开头。这个做法借鉴其他OO语言，主要是为了区别于ECMAScript中的其他函数。因为够咱函数本身也是函数，只不过可以用来创建对象而已。 new操作符 面试常考点 创建一个新对象。 将构造函数的作用域赋值给新对象（ 因此this就指向了这个新对象 ）。 执行构造函数中的代码（ 为这个新对象添加属性 ）。 返回新对象。 ok接着上面的构造函数 在前面的栗子中，person1和person2分别保存着Person的一个不同的实例。这两个对象都有一个constructor(构造函数)属性，该属性指向Person 12person1.constructor == Person // trueperson2.constructor == Person // true 对象的constructor属性最初是用来标识对象类型的。但是还是instanceof检测对象类型更靠谱。 1234person1 instanceof Object =&gt; trueperson1 instanceof Person =&gt; trueperson2 instanceof Object =&gt; trueperson2 instanceof Person =&gt; true 创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型，这正是构造函数模式胜过工厂模式的点。 这个栗子中，person1和person2之所以同时是Object实例，是因为所有对象均继承自Object 造函数当做函数 构造函数和其他函数的唯一区别，就在于调用它们的方式不同。 不过，构造函数毕竟也是函数，不存在定义构造函数的特殊语法。 任何函数，只要通过new操作符来调用，那他就可以作为构造函数 而任何函数，如果不通过new操作符来调用，那他跟普通函数也不会有什么两样。123456789101112131415// 当做构造函数使用var person = new Person( \"Nicholas\", 29, \"Soft Engineer\" );prson.sayName(); // \"NicholasPerson( \"Greg\", 27, \"Doctor\" ); // 添加到window// 当在全局作用域中调用一个函数时，this对象总是指向window/Global对象window.sayName() // \"Greg\"// 在另一个对象的作用域中调用var o = new Object();// 使用call apply 在某个特殊对象的作用域中调用Person()函数。// 这里在对象o的作用域中调用的，因此调用后o就拥有了Person的所有属性和sayName（）方法// 通俗的讲（我自己理解的） 就是Person在o的作用域中调用的，Person的this指向了oPerson.call( o, \"Kristen\", 25, \"Nurse\" );o.sayName(); // \"Kristen\" 构造函数的问题以及将方法转移到外部的思路 每个方法都要在每个实例上重新创建一遍。 在前面的例子中，person1和person2都有一个名为sayName()的方法，但那两个方法不是同一个Function的实例。不要忘了ECMAScript中的函数是对象，因此没定义一个函数，也就是实例化了一个对象。从逻辑讲，此时的构造函数也可以这样定义。 123456function Person( name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = new Function( \"alert(this.name)\" ); // 与声明函数在逻辑上是等价的&#125; 从这角度上来看构造函数，更容易明白每个Person实例都包含一个不同的Function实例（以显示name属性）的本质。说明白些，以这种方式创建函数，会导致不同的作用域链和标识符解析，单创建Function新实例的机制仍然是相同的。因此，不同实例上的同名函数是不相等的。 12person1.sayName = preson2.sayName; // false// 吃饭去了嘿嘿 然而，创建两个完成同样任务的Function实例的确没有必要，况且有this对象在，根本不用在执行代码前就把函数绑定到特定对象上面。于是就有了把函数定义转移到构造函数外部来解决这个问题。 12345678910111213function Person( name, age, job )&#123; this.name = name; this.age = age; this.job = job; this.sayName = sayName;&#125;function sayName()&#123; alert( this.name )&#125;;var person1 = new Person( \"Nicholas\", 29, \"Software Engineer\" );var person2 = new Person( \"Greg\", 27, \"Doctor\" ) 在全局作用域中定义的函数实际上只能被某个对象调用，折让全局作用域有点名不副实。 如果对象需要定义很多方法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。 原型模式 我们创建的每个函数都有一个prototype(原型)属性，这个属性是一个指针、指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。 如果按照字面意思来理解，那么prototype就是通过调用构造函数而创建的那个对象实例的原型对象。 使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。 换句话说，不必再构造函数中定义对象实例的信息，而可以将这些信息直接添加到原型对象中。 12345678910111213function Person()&#123;&#125;;person.prototype.name = 'Nicholas';person.prototype.age = 29;person.prototype.job = \"Software Engineer\";person.prototype.sayName = function()&#123; alert( this.name )&#125;;var person1 = new Person();person1.sayName(); // 'Nicholas'var person2 = new Person();person2.sayName(); // 'Nicholas'person1.sayName == person2.sayName ; // true 构造函数变成了空函数。 即便如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法。 但与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。 理解原型对象 无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。 在默认情况下，所有原型对象都会自动获得一个constructor(构造函数)属性，这个属性包含一个指向prototype属性所在函数的指针。就拿前面例子来说，Person.prototype.constructor指向Person。通过这个构造函数，我们还可以继续为原型对象添加其他属性和方法。 创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从Object继承而来的。 当调用构造函数创建一个新实例后，该市里的内部将包含一个指针（内部属性），指构造函数的原型对象。ECMA-262第5版中管这个指针叫[[Prototype]]。虽然在脚本中没有标准的方式访问[[Prototype]]，但Firefox、 Safari和Chrome在每个对象上都支持一个属性__proto__;而在其他实现中，这个属性对脚本则是完全不可见的。 要真正的明确一点的就是，这个链接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。 虽然实例不包含属性和方法，但我们却可以通过查找独享属性的过程来实现调用原型对象的方法。 isPrototypeOf() 虽然在所有视线中都无法访问到[[Prototype]], 但可以通过isPrototypeOf()方法来确定对象之间是否存在这种关系。 从本质上讲，如果[[Prototype]]指向调用isPrototypeOf()方法的对象(Person.prototype)，那么这个方法就返回true。123// 这里，我们用原型对象的isPrototypeOf()方法测试了person1和person2.因为他们内部都有一个指向Person.prototype的指针，因此都返回了truePerson.prototype.isPrototypeOf( person1 ) // truePerson.prototype.isPrototypeOf( person2 ) // true Object.getPrototypeOf() 这个方法返回[Prototype]的值。 1234// 确定Object.getProtyotypeOf()返回的对象实际就是这个对象的原型Object.getPrototypeOf( person1 ) == Person.prototype // true// 取得原型对象中name属性的值Object.getPrototypeof( person1 ).name // \"Nicholas\" 使用Object.getPrototypeOf()可以方便的取得一个对象的原型，而这在利用原型实现继承的情况下是非常重要的。 支持这个方法的浏览器有IE9+/ Firefox 3.5+/ Safari 5+/ Opera 12+/ Chrome。 多个对象实例共享原型所保存的属性和方法的基本原理 当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。 搜索首先从对象实例本身开始。 如果在实例中找到了具有给定名字的属性，则返回该属性的值 如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。 原型最初只包含constructor属性，而该属性也是共享的，因此可以通过对象实例访问。 虽然可以通过对象实例访问保存在原型链中的值，但却不能通过对象实例重写原型中的值。 如果我们在实例中添加了一个属性，而该属性与实力原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。 12345678910111213141516171819function Person()&#123;&#125;;Person.prototype = &#123; constructor: Person, name: 'Nicholas', age: 29, job: 'Softa Engineer', sayName: function()&#123; alert( this.name ) &#125;&#125;;var person1 = new Person();var person2 = new Person();person1.name = 'Greg';console.log( person1.name ) // 'Greg' —— 来自实例console.log( person2.name ) // 'Nicholas' —— 来自原型 当为对象添加一个实例属性时，这个属性就会屏蔽原型对象中保存的同名属性；换句话说，添加这个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。即使将这个属性设置为null，也只会在实例中设置这个属性，而不会恢复其指向原型的链接。 使用delete操作符可以完全删除实例属性，从而让我们能够重新访问原型中的属性。 12345678910111213141516171819202122function Person()&#123;&#125;;Person.prototype = &#123; constructor: Person, name: 'Nicholas', age: 29, job: 'Softa Engineer', sayName: function()&#123; alert( this.name ) &#125;&#125;;var person1 = new Person();var person2 = new Person();person1.name = 'Greg';console.log( person1.name ) // 'Greg' —— 来自实例console.log( person2.name ) // 'Nicholas' —— 来自原型delete person1.name;console.log( person1.name ) // 'Nicholas' —— 来自原型 hasOwnProperty() 使用hasOwnProperty()方法可以检测一个属性是否存在与实例中，还是存在于原型中。 这个方法( 不要忘了它是从Object继承来的 )只在给定属性存在于对象实例中时，才会返回true。 实例 —— true; 原型 —— false 12345678910111213141516171819202122function Person()&#123;&#125;;Person.prototype = &#123; constructor: Person, name: 'Nicholas', age: 29, job: 'Softa Engineer', sayName: function()&#123; alert( this.name ) &#125;&#125;;var person1 = new Person();var person2 = new Person();person1.name = 'Greg';console.log( person1.name ) // 'Greg' —— 来自实例console.log( person2.name ) // 'Nicholas' —— 来自原型person1.hasOwnProperty( 'name' ) // trueperson2.hasOwnProperty( 'name' ) // false ECMAScript5的Object.getOwnPropertyDescriptor()方法只能用于实例属性，要取得原型属性的描述符，必须直接在原型对象上调用Object.getOwnPropertyDescriptor()方法 原型与in操作符 有两种方式使用in操作符，单独使用和for-in循环中使用。 在单独使用时，in操作符会在通过对象能够访问给定属性时，返回true，无论该属性存在于实例中还是原型中。 123456789101112131415161718192021222324252627282930function Person()&#123;&#125;;Person.prototype = &#123; constructor: Person, name: 'Nicholas', age: 29, job: 'Softa Engineer', sayName: function()&#123; alert( this.name ) &#125;&#125;;var person1 = new Person();var person2 = new Person();person1.name = 'Greg';console.log( person1.name ) // 'Greg' —— 来自实例console.log( person2.name ) // 'Nicholas' —— 来自原型person1.hasOwnProperty( 'name' ) // trueperson2.hasOwnProperty( 'name' ) // false'name' in person1 // true'name' in person2 // true// 注意这两种区别 person1.xxx = null;if( 'xxx' in person1 )&#123; console.log( true ) &#125; // trueif( person1.xxx )&#123; console.log( true ) &#125; // 同时使用hasOwnProperty()方法和in操作符就可以确定该属性是否存在且是在对象中还是在原型中。 123function hasPrototypeProperty( object, name )&#123; return !object.hasOwnProperty( name ) &amp;&amp; ( name in object );&#125; for-in 在使用for-in循环时，返回的是所有能够通过对象访问的、可枚举的(enumerated)的属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性 屏蔽了原型中不可枚举的属性( [[Enumerable]]标记为false的属性 )的实例属性（就是新定义的和原型属性同名的实例属性）也会在for-in循环中返回，因为根据规定，所有开发人员定义的属性都是可枚举的——只有在IE8及更早版本中例外。 IE8早期版本的实现中存在一个bug，即屏蔽不可枚举属性的实例属性不会出现在for-in循环中。 该bug会影响默认不可枚举的所有属性和方法。包括hasOwnProperty()/ peropertyIsEnumerable()/ toLocaleString()/ toString()/ valueOf ECMAScript5也将constructor和prototype属性的[[Enumerable]]特性设置为false，但并不是所有得浏览器都照此实现。 Object.keys() 取得该对象上所有可枚举的实例属性。 接收一个对象作为参数，返回一个包含自身所有可枚举属性的字符串数组。123456789101112131415161718function Person()&#123;&#125;;Person.prototype = &#123; constructor: Person, name: 'Nicholas', age: 29, sayName: function()&#123; alert( this.name ) &#125;&#125;;var keys = Object.keys( Person.prototype );console.log( keys ); // 'name, age, job, sayName'var person1 = new Person();person1.name = 'Rob';person1.age = 31;var person1Keys = Object.keys( person1 );// 只返回了自身 并没有往原型对象里面去找console.log( person1Keys ) // ['name', 'age'] Object.getOwnPropertyNames() 如果你想得到所有实例属性，无论它是否可枚举，就用这个方法吧。123var keys = Object.getOwnPropertyNames( Person.prototype );// 结果包含了不可枚举的constructoralert( keys ) // 'constructor, name, age, job, sayName' 更简单的原型语法 为了减少不必要的输入 为了从视觉上更好的封装原型功能 更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象。 12345function Person()&#123;&#125;;Person.prototype = &#123; name: 'Nicholas' // ...&#125; 在上面的代码中，我们将Person.prototype设置为等于一个以对象字面量形式创建的新对象。最终结果相同，但有一个例外：constructor属性不再指向Person了。前面曾经介绍过，每创建一个函数，就会同时创建它的prototype对象，整个对象也会自动获得constructor属性。而我们在这里使用的语法，本质上完全重写了默认的prototype对象，因此constructor属性也就变成了新对象的constructor属性（指向Object构造函数），不再指向Person函数。此时，尽管instaceof操作符还能返回正确的结果，单通过constructor已经无法确定对象的类型了。 12345var friend = new Person();friend instanceof Object //truefriend instanceof Person // truefriend.constructor == Person // falsefrined.constructor == Object // true 所以我们要这样写 123456function Person()&#123;&#125;;Person.prototype = &#123; constructor: Person, name: 'Nicholas' // ...&#125; 以上代码特意包含了一个constructor属性，并将它的值设置为Person，从而确保了通过该属性能够访问到适当的值。 问题来了，以这种方式重设constructor属性会导致他的[[Enumerable]]特性被设置为true。默认情况下，原生的constructor属性是不可枚举的。因此如果你兼容ECMAScript5的JS引擎，可以试一试Object.defineProperty() 12345678910function Person()&#123;&#125;;Person.prototype = &#123; name: 'Nicholas', // ...&#125;;// 重设构造函数，只适用于ECMA5+Object.defineProperty( Person.prototype, 'constructor', &#123; enumerable: false, value: Person&#125; ) 原型的动态性 由于原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来——即使是县创建了实例后修改原型也照样如此。 12345var friend = new Person();Person.prototype.sayHi = function()&#123; alert('hi')&#125;;friend.sayHi(); // 'hi' 当我们调用person.sayHi()时，首先会在实例中搜索名为sayHi的属性，没找到的情况下，会继续搜索原型。 因为实例与原型之间的链接只不过是一个指针而非一个副本，因此就可以在原型中找到新的sayHi属性并返回保存在那里的函数。 如果是重写整个原型对象，那么情况就不一样了！！！ 我们知道，调用构造函数时会为实例添加衣蛾指向最初原型的[[Prototype]]指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。 实例中的指针仅指向原型，而不指向构造函数 原生对象的原型 原生模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是猜中这种模式创建的。 所有原生引用类型（ Object， Array， String ……）都在其构造函数的原型上定义了方法。 12typeof Array.prototype.sort // 'function'typeof String.prototype.substring // 'function' 通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法。 可以像修改自定义对象的远行一样修改原生对象的原型，因此可以随时添加方法。 12345String.prototype.startsWidth = function( text )&#123; return this.indexOf( text ) === 0;&#125;;var msg = 'Hello world!';alert( msg.startsWith( 'hello' ) ); // true 尽管可以这样做，但我们不推荐在产品化的程序中修改原生对象的原型。如果因某个实现中缺少某个方法，就在原生对象的原型中添加这个方法，那么当在另一个支持该方法的视线中运行代码时，就可能会导致命名冲突。而且，这样做也可能会以外的重写原生方法。 原型对象的问题 它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。 最大的问题是由其共享的本性所导致的 原型中所有属性是被很多实例共享的，这种共享对函数非常合适，对于那些包含基本值的属性也说得过去，毕竟通过在实例上添加一个同名属性，可以隐藏原型中的对应属性。但是，对于包含引用类型值的属性来讲，问题比较突出1234567891011121314151617181920212223function Person()&#123;&#125;;Person.prototype = &#123; constructor: Person, name: 'Nicholas', job: 'Software Enginerr', friends: ['Shelby', 'Court'], sayName: function()&#123; alert( this.name ) &#125;&#125;;var person1 = new Person();var person2 = new Person();person1.friends.push( 'Van' );person1.friends // 'Shelby, Court, Van'person2.friends // 'Shelby, Court, Van'person1.friends === person2.friends // true/** * Person.prototype对象有一个名为friends的属性，该属性包含一个字符串数组。然后，创建了Person的两个实例。接着，修改了person1.frineds引用的数组，箱数组中添加了一个字符串。 * 由于friends数组存在于Person.prototpe而非person1中，所以刚刚提到的修改也会通过person2.friends( person1.friends指向同一个数组 )反映出来。假如我们的初衷就是像这样在所有实例中共享一个数组，那么对这个结果我无话可说。可是，实例一般都是要有属于自己的全部属性的。这个问题就是我们很少看到有人单独使用原型模式的原因所在。*/ 组合使用构造函数模式和原型模式 创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。 构造函数模式用于定义实例属性。 而原型模式用于定义方法和共享的属性。 结果，每个实例都会有自己的一份实例属性的副本。 但同时有共享着对方法的引用，最大限度地节省了内存。 这种混成模式还支持向构造函数传递参数。 集两种模式之长。 123456789101112131415161718192021function Person( name, age, job )&#123; this.name = name; this.age = age; this.job = job; this.friends = [ 'Shelby', 'Court' ];&#125;Person.prototype = &#123; constructor: Person, sayName: function()&#123; alert( this.name ) &#125;&#125;var person1 = new Person( 'Nicholas', 29, 'Software Engineer' );var person2 = new Person( 'Greg', 27, 'Doctor' );person1.friends.push('Van');person1.friends // 'Shelby, Count, Van'person2.frineds // 'Shelby, Count'preson1.friends === person2.friends // falseperson1.sayName === person2.sayName // true 这个例子中，实例属性都是在构造函数中定义的，而由所有实例共享的属性constructor和方法sayName()则是在原型中定义的。 而修改了person1.friends并不会影响到prson2.friends，因为他们分别引用了不同的数组。 这种构造函数与原型混成的模式，是目前在ECMAScript中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。 动态原型模式 有其他OO语言经验的开发人员在看奥独立的构造函数和原型时，很可能会感到非常困惑。 动态原型模式正事致力于解决这个问题的一个方案，它把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（ 仅在必要的情况下 ），又保持了同时使用构造函数和原型的有点。 换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。 12345678910111213function Person( name, age, job )&#123; this.name = name; this.age = age; this.job = job;&#125;;// 方法if( typeof this.sayName != 'function' )&#123; Person.prototype.sayName = function()&#123; alert( this.name ) &#125;&#125;;var friend = new Person( 'Nicholas', 29, 'Software Engineer' );friend.sayName(); 注意构造函数代码中加粗的部分，这里只有在sayName方法不存在的情况下，才会将它添加到原型中。这段代码只会在初次调用构造函数时才会执行。此后，原型已经被完成初始化，不要再做什么修改了。 不过记住，这里对原型所做的修改，能够立即在所有实例中得到反映。 其中，if语句检查的可以是初始化之后应该存在的任何属性或方法——不必用一大堆if语句检查每个属性和方法，只要检查其中一个即可。 对于采用这种模式创建的对象，还可以使用instanceof操作符确定它的类型。 动态原型模式时，不能使用对象字面量重写原型。如果在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系。 寄生构造函数模式 在前述的几种模式都不适用的情况下，可以使用寄生（parasitic）构造函数模式。 这种模式基本思想是创建一个函数，该函数的作用仅仅是分装创建对象的代码，然后返回新创建的对象 但从表面上看，这个函数又很像是典型的构造函数。 123456789101112function Person( name, age, job )&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert( this.name ) &#125;; return o&#125;;var friend = new Person( 'Nicholas', 29, 'Software Engineer' );friend.sayName(); // 'Nicholas' 在这个栗子中，Person函数创建了一个新对象，并以相应的属性和方法初始化该对象，然后又返回了这个对象。 除了使用new操作符并把使用的包装函数叫做构造函数外，这个模式跟工厂模式其实是一模一样的。 构造函数在不返回值的情况下，默认会返回新对象实例。 而通过在构造函数的末未添加一个return语句，可以重写调用构造函数时返回的值。 寄生构造函数使用场景 这个模式可以在特殊的情况下用来为对象创建构造函数。 假设我们想创建衣蛾具有额外方法的特殊数组，由于不能直接修改Array构造函数，因此可以使用这个模式。 12345678910111213function SpecialArray()&#123; var values = new Array(); // 添加值 values.push.apply( values, arguments ); // 添加方法 values.toPipedString = function()&#123; return this.join('|') &#125;; return values;&#125;var colors = new SpecialArray( 'red', 'blue', 'green' );console.log( colors.toPipedString() ) // 'red|blue|green' 首先，返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说， 构造函数返回的对象与在构造函数外部创建的对象没有什么不同。 为此，不能依赖instanceof操作符来确定对象类型。所以能适用其他模式的情况下，不建议使用此模式。 稳妥构造函数模式 道格拉斯·克洛克福特发明了JS中的稳妥对象这个概念。 所谓稳妥对象，指的是没有公共属性，而且其犯法也不引用this对象。 稳妥对象最适合在一些按全的环境中（这些环境会禁止使用this和new），或者在防止数据被其他应用程序改动时使用。 稳妥构造函数遵循与寄生构造函数类似的模式。但有两点不同 新创建对象额实例方法不引用this 不使用new操作符调用构造函数。 123456789101112131415function Person(name, age, job)&#123; // 创建要返回的对象 var o = new Object(); // 定义私有变量和函数 // 添加方法 o.sayName = function()&#123; alert( name ) &#125;; // 返回对象 return o&#125;var friend = Person( 'Nicholas', 29, 'Software Engineer' );friend.sayName(); // 'Nicholas' 在以这种模式创建的对象中，除了使用sayName()方法外，没有其他办法访问name值 与寄生构造函数模式类似，使用稳妥构造函数模式创建的独享与构造函数之间没有什么关系，因此instaceof操作符对这货在哪个对象也没意义。 继承简介 继承是OO语言中的一个最为人津津乐道的概念。许多OO语言都支持两种继承方式——接口继承和实现继承。 接口继承值继承方法签名 实现继承则继承实际的方法 由于函数没有签名，在ECMAScript中无法实现接口继承。 ECMAScript只支持实现继承，而且其实现继承主要是依靠原型链来实现的。 原型链 ECMAScript中描述了原型链的概念，并将原型链作为实现继承的主要方法。 其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。 简单回顾一下构造函数、原型和实例的关系： 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针 那么，假如我们让原型对象等于另一个类型的实例，结果会怎样呢？ 显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。 假如另一个原型有事另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。 这就是所谓的原型链的基本概念。 原型链的基本模式 1234567891011121314151617181920function SuperType()&#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function()&#123; return this.property;&#125;function SubType()&#123; this.subproperty = false;&#125;SubType.prototype = new SuperType();SubType.prototype.getSubValue = function()&#123; return this.subproperty;&#125;var instance = new SubType();alert( instance.getSuperValue() ); // true 以上代码定义了两个类型： SuperType 和 SubType。每个类型分别有一个属性和一个方法。他们的主要区别是 SubType 继承了 SuperType， 而继承是通过创建SuperType的实例，并将该实例赋给SubType.prototype实现的。 实现的本质是重写原型对象，代之以一个新类型的实例。 换句话说，原来存在于 SuperType 的实例中的所有属性和方法，现在也存在于 SubType.prototype 中了。 在确立了继承关系之后，我们给 SubType.prototype 添加了一个方法，这样就在继承了 SuperType 的属性和方法的基础上有添加了一个新方法。 要注意 SubType.prototype.constructor === instance.constructor 而且 instance.constructor现在指向的是SuperType 遵循原型链搜索原则 调用instance.getSuperValue()会经历三个搜索步骤 搜索实例 搜索 SubType.prototype 搜索 SuperType.prototype 最后一步才会找到该方法 在找不到属性或方法的情况下，搜索过程总是要一环一环的前行到原型链末端才会停下来 别忘记默认原型 所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。 所有函数的默认原型都是Object实例 因此默认原型都会包含一个内部指针，指向Object.prototype 这也正是所有自定义类型都会继承toString()、 valueof()等默认方法的根本原因。 确定原型和实例的关系 使用instanceof操作符 只要用这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回true。 1234// 由于原型链的关系，我们可以说instance是Object、SuperType或SubTYpe中任何一个类型的实例。instance instanceof Object // trueinstance instanceof SuperType // trueinstance instanceof SubType // true 使用isPrototypeOf()方法。同样，只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型。 123Object.prototype.isPrototypeOf( instance ) // trueSuperType.prototype.isPrototypeOf( instance ) // trueSubType.prototype.isPrototypeOf( instance ) 谨慎地定义方法 子类型有时需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法 但不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后 1234567891011121314151617181920212223242526function SuperType()&#123; this.property = true&#125;SuperType.prototype.getSuperValue = function()&#123; return this.property&#125;function SubType()&#123; this.subproperty = false&#125;// 继承了SuperTYpeSubType.prototype = new SuperType();// 添加新方法SubType.prototype.getSubValue = function()&#123; return this.subproperty&#125;// 重写超类型中的方法SubType.prototype.getSuperValue = function()&#123; return false;&#125;var instance = new SubType();alert( instance.getSuperValue() ); // false// 重写超类中的方法会屏蔽超类中的原方法 通过原型链实现继承时，不能使用对象字面量创建原型方法，这样会重写原型链 1234567891011121314151617181920212223242526function SuperType()&#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function()&#123; return this.property&#125;function SubType()&#123; this.subproperty = false&#125;// 继承了SuperTypeSubType.prototype = new SuperType();// 使用字面量添加新方法，会导致上一行代码无效SubType.prototype = &#123; getSubVale: function()&#123; return this.subproperty &#125;, someOtherMethod: function()&#123; return false; &#125;&#125;var instance = new SubType();// 由于现在原型包含的是一个Object的实例，而非SuperType的实例，因此我们设想中的原型链已经被切断。alert( instance.getSuperValue() ) // error 原型链的问题 问题1: 原型链虽然强大，可以用它来实现继承，但它也存在一些问题。最主要的问题来自包含引用类型值的原型。 在通过原型来实现继承时，圆形实际上会变成另一个类型的实例。 于是，原先的实例属性也就顺理成章的变成了现在的原型属性了。 123456789101112131415function SuperType()&#123; this.colors = [ 'red', 'blue', 'green' ]&#125;function SubType()&#123;&#125;// 继承了SuperTypeSubType.prototype = new SuperType();var instancel = new SubType();instancel.colors.push('black');alert( instancel.colors ) // 'red, blue, green, black'var instance2 = new SubType(); alert( instance2.colors ) // 'red, blue, green, black' 问题2： 在创建子类型的实例时，不能向超类型的构造函数中传递参数。 实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。 有鉴于此，再加上前面刚刚讨论过的由于原型中包含引用类型值所带来的问题，实践中很少会单独使用原型链。 借用构造函数 借用构造函数的技术有时也称伪造对象或经典继承。 基本思想想当简单，即在子类型构造函数的内部调用超类型构造函数。 别忘了，函数只不过是在特定环境中执行代码的对象，因此通过使用call() apply()方法亦可以在（将来）新创建的对象上执行构造函数。 123456789101112131415function SuperType()&#123; this.colors = ['red', 'blue', 'green']&#125;function SubType()&#123; // 继承了 SuperType // 这行代码借调了超类型的构造函数 // 通过使用call()或apply()方法，我们实际上是在（未来将要）新创建的SubType实例的环境下调用了SuperType构造函数 // 这样一来，就会在新SubType对象上执行SuperType()函数中定义的所有对象初始化代码 // 结果，SubType的每个实例就都会具有自己的colors属性的副本了 SuperType.call( this )&#125;var instance1 = new SubType();instance1.colors.push( 'blcak' ); // 'red, blue, green, black'var instace2 = new SubType(); // 'red, blue, green' 传递参数 相对于原型链而言，借用构造函数有一个很大的优势，就是可以再子类型构造函数中向超类型构造函数传递参数 12345678910111213function SuperType(name)&#123; this.name = name&#125;function SubType()&#123; // 继承了SuperType 同时还传递了参数 SuperType.call( this, 'Nicholas' ) // 实例属性 this.age = 29&#125;var instance = new SubType();instace.name // 'Nicholas'instance.age // 29 为了确保SuperType构造函数不会重写子类型的水性，可以再调用超类型构造函数后，再添加应该在子类型中定义的属性 借用构造函数的问题 如果仅仅是借用构造函数， 那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定义，因此函数复用就无从谈起了 而且在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式 考虑到这些问题，借用构造函数的技术也是很少单独使用的。 组合继承 组合继承，有时候也叫伪经典继承，指的是将原型链和借用构造函数的技术组合到一块， 从而发挥二者之长的一种继承模式。 其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。 这样，既通过在圆心上定义方法实现了函数复用，又能保证每个实例都有它自己的属性。 1234567891011121314151617181920212223242526272829function SuperType(name)&#123; this.name = name; this.colors = ['red', 'blue', 'green']；&#125;SuperType.prototype.sayName = function()&#123; alert( this.name )&#125;function SubType(name, age)&#123; SuperType.call( this, name ) this.age = age&#125;SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function()&#123; alert( this.name )&#125;var instance1 = new SubType( 'Nicholas', 29 );instance1.colors.push( 'black' );alert( instance1.colors ) // 'red, blue, green, black'instance1.sayName(); // 'Nicholas'instance1.sayAge(); // 29var instace2 = new SubType('greg', 27)alert( instance2.colors ) // 'red, blue, green'instance2.sayAge() // 27instance2.sayName() // 'greg' 组合继承避免了原型链和借用构造函数的缺陷，融合了他们的优点，成为JS中最常用的继承模式。而且，instanceof和isPrototypeOf()也能狗用于识别基于组合继承创建的对象。 原型式继承 道格拉斯克罗克福发明的。 这种方法并没有使用严格意义上的构造函数 他的想法是借助原型可以基于已有的对象创建新对象，同事还不比因此创建自定义类型。 12345function object(o)&#123; function F()&#123;&#125;; F.prototype = o; return new F();&#125; 在object()函数内部，县创建爱你了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。 从本质上讲， object对传入其中的对象执行了一次浅复制。 12345678910111213var person = &#123; name: 'Nicholas', friends: ['Shelby', 'Court', 'Van']&#125;;var anotherPerson = Object( person );anotherPerson.name = 'Greg';anotherPerson.friends.push( ' Rob ' );var yetAnotherPerson = Object( person );anotherPerson.name = 'Linda';anotherPerson.friends.push( 'Barbie' );alert( person.friends ) // 'Shelby, Court, Van, Rob, Barbie' 克罗克福德主张的这种原型继承，要求你必须有一个对象可以作为另一个对象的基础。 如果有这么一个对象的话，可以把它传递给Object()函数，然后再根据具体需求对得到的对象加以修改即可。 Object.create() ECMAScript5通过新增Object.create()方法规范化了原型式继承。 参数1： 一个用作新对象原型的对象 参数2： 一个为新对象定义额外属性的对象 在传入一个参数的情况下， Object.create和object方法的行为相同 1234567891011121314var person = &#123; name: 'Nicholas', friends: ['Shelby', 'Court', 'Van']&#125;;var anotherPerson = Object.create( person );anotherPerson.name = 'Greg';anotherPerson.friends.push( 'Rob' );var yetAnotherPerson = Object.create( person );yetAnotherPerson.name = 'Linda';yetAnotherPerson.friends.push( 'Barbie' );alert( person.friends ) // 'shelby, court, van, rob, Barbie' Object.create()方法的第二个参数与Object.definePropertyies()方法的第二个参数格式相同 每个属性欧式通过自己的描述符定义的。 以这种方式指定的任何属性都会覆盖原型对象上的同名属性 123456789var person = &#123; name: 'Nicholas'&#125;;var anotherPerson = Object.create( person, &#123; name: &#123; value: 'Greg' &#125;&#125; )alert( anotherPerson.name ) // 'Greg' 兼容 IE9+ Firefox 4+ Safari 5+ Opera 12+ Chrome 在没有必要兴师动众的创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的 不过别忘了，包含引用类型值的属性始终都会共享相应值，就像使用原型模式一样。 寄生式继承 寄生式继承是与原型式继承紧密相关的一种思路，并且同样也是由克罗克福德推广的 寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数 该函数在内部以某种方式来增强对象，最后再像真的它做了所有工作一样返回对象 12345678910function crateAnother( original )&#123; // 通过调用函数创建一个新对象 var clone = object( original ); // 以某种方式来增强这个对象 clone.sayHi = function()&#123; alert('hi') &#125;; // 返回这个对象 return clone&#125; 在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。 前面示范继承模式时用的object函数不是必须的 任何能够返回新对象的函数都适用于此模式 寄生组合式继承 组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数： 一次是在创建子类型原型的时候 另一次是在子类型构造函数内部 子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子类型构造函数时重写这些属性。 12345678910111213141516171819202122function SuperType(name)&#123; this.name = name; this.colors = ['red', 'blue', 'green']&#125;;SuperType.prototype.sayName = function()&#123; alert( this.name )&#125;;function SubType( name, age )&#123; // 第二次调用 SuperType(); SuperType.call( this, name )&#125;;// 第一次调用SuperTypeSubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function()&#123; alert( this.age )&#125;/** * 在第一次调用SuperType构造函数时，SubType.prototype会得到两个属性： name和cloors；他们都是SuperType的实例属性，只不过现在位于SubType的原型中 * 当调用SubType构造函数时，优惠调用一次SuperType构造函数，这一次又在新都向上创建了实例属性name和colors * 于是 这两个属性就屏蔽了原型中的两个同名属性*/ 什么是寄生组合继承 所谓寄生组合继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。 其背后的思路是： 不必为了制定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。 本质上，就是使用寄生式继承来继承超类型原型，然后再将结果指定给子类型的原型 123456789101112131415function inheritPrototype( subType, superType )&#123; // 创建对象 var prototype = object( superType.prototype ); // 增强对象 prototype.constructor = subType; // 指定对象 subType.prototype = prototype;&#125;/* * 这个示例中的 inheritPrototype()函数时间了寄生组合式继承的最简单形式。 * 这个函数接受两个参数： 子类型构造函数和超类型构造函数。 * 在函数内部，第一步是创建超类型原型的一个副本。 * 第二步为创建的副本添加`constructor`属性，从而弥补因重写原型而失去的默认的constructor属性。 * 最后一步，将新创建的对象（即副本）赋值给予类型的原则。*/ 看下面例子 123456789101112131415function SuperType(name)&#123; this.name = name; this.colors = [\"red\", \"blue\", \"green\"];&#125;SuperType.prototype.sayName = function()&#123; alert( this.name )&#125;function SubType(name, age)&#123; SuperType.call( this, name ) this.age = age;&#125;inheritPrototype( SubType, SuperType );SubType.prototype.sayAge = function()&#123; alert( this.age ) &#125;","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qw8.github.io/tags/JavaScript/"},{"name":"类","slug":"类","permalink":"https://qw8.github.io/tags/类/"},{"name":"对象","slug":"对象","permalink":"https://qw8.github.io/tags/对象/"}]},{"title":"JavaScript对象","slug":"knowledges/JavaScript对象","date":"2020-04-18T14:10:40.000Z","updated":"2024-04-11T07:13:02.000Z","comments":true,"path":"/knowledges/javascript-dui-xiang.html","link":"","permalink":"https://qw8.github.io/knowledges/javascript-dui-xiang.html","excerpt":"","text":"JavaScript如何实现一个类（类的定义），怎么实例化这个类？构造函数法（this + prototype） – 用 new 关键字 生成实例对象缺点：用到了 this 和 prototype，编写复杂，可读性差 123456789function Mobile(name, price)&#123; this.name = name;//通过this，表明这是一个构造函数 this.price = price; &#125; Mobile.prototype.sell = function()&#123; alert(this.name + \"，售价 $\" + this.price); &#125; var iPhone7 = new Mobile(\"iPhone7\", 1000); iPhone7.sell(); Object.create 法 – 用 Object.create() 生成实例对象缺点：不能实现私有属性和私有方法，实例对象之间也不能共享数据 1234567891011121314151617181920var Person = &#123; firstname: \"Mark\", lastname: \"Yun\", age: 25, introduce: function()&#123; alert('I am ' + Person.firstname + ' ' + Person.lastname); &#125;&#125;;var person = Object.create(Person);person.introduce();// Object.create 要求 IE9+，低版本浏览器可以自行部署：if (!Object.create) &#123; Object.create = function (o) &#123; function F() &#123;&#125; F.prototype = o; return new F(); &#125;; &#125; 极简主义法（消除 this 和 prototype） – 调用 createNew() 得到实例对象优点：容易理解，结构清晰优雅，符合传统的”面向对象编程”的构造 12345678910111213141516171819var Cat = &#123; age: 3, // 共享数据 -- 定义在类对象内，createNew() 外 createNew: function () &#123; var cat = &#123;&#125;; // var cat = Animal.createNew(); // 继承 Animal 类 cat.name = \"小咪\"; var sound = \"喵喵喵\"; // 私有属性--定义在 createNew() 内，输出对象外 cat.makeSound = function () &#123; alert(sound); // 暴露私有属性 &#125;; cat.changeAge = function(num)&#123; Cat.age = num; // 修改共享数据 &#125;; return cat; // 输出对象 &#125;&#125;;var cat = Cat.createNew();cat.makeSound(); ES6 语法糖 class – 用 new 关键字 生成实例对象类的实例化很简单，直接 new 出来即可。函数可以作为构造函数来使用，通过 new 来实例化，其实函数本身也是一个对象。 1234567891011 class Point &#123; constructor(x, y) &#123; this.x = x;//可以在构造函数里写属性 this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125; &#125;var point = new Point(2, 3); 谈谈This对象的理解 this总是指向函数的直接调用者（而非间接调用者），指向调用上下文； 如果有new关键字，this指向new出来的那个对象； 在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent（触发事件）中的this总是指向全局对象Window this相关(注意箭头函数的this指向问题)ES6中箭头函数的this问题： ES6 允许使用“箭头”（=&gt;）定义函数， 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 this对象的指向是可变的，但是在箭头函数中，它是固定的，箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。 所以箭头函数不能做构造函数， 也不能用call()、apply()、bind()这些方法去改变this的指向。 对象 对象是引用数据类型，是属性的无序集合 对象的组成：属性和方法 创建对象 隐式创建 123var obj = &#123; ：&#125; 实例化构造函数 123var obj = new Object(&#123; ：&#125;); 实例化自定义函数 1234function Animal()&#123; this .&#125;var obj = new Animal() 实例化类 1234class Ani&#123; this.&#125;var obj = new Ani&#123;&#125;; 对象的增删改查 增 声明的同时赋值 12345678910111213141516171819202122232425//1.隐式var cup=&#123; color:'red', size:'1000ml', price:588 &#125; console.log(cup);//2.实例化构造函数var cat = new Object(&#123; age:2, weight:'10kg',&#125;)console.log(cat); //3.实例化自定义构造函数function Person()&#123; this.name='常博'; this.sex='男'; this.age=25; this.eat = (function()&#123; return 'bread' &#125;)()&#125;var $chang = new Person();console.log($chang); 先声明后赋值 1234567891011 //对象.属性名=方法//1.隐式var flower =&#123;&#125;;flower.color=\"red\";flower.type='玫瑰';flower.price='1元'console.log(flower);flower.total=function()&#123; return 999;&#125;console.log(flower); 查 访问属性 12345//对象的访问// 对象.属性名console.log(flower.type);//对象[\"属性名\"]console.log(flower['type']); 访问方法 1234//属性名.方法()console.log(flower.total());//属性名[\"方法\"]()console.log(flower['total']()); 改 修改属性 12345678// 对象.属性名=新的属性值flower.color=\"pink\";flower['price'] = \"2元\"console.log(flower.color);console.log(flower['price']);console.log(flower); 修改方法 12345678910//对象.方法=新的方法flower.total=function()&#123; return 10&#125;console.log(flower.total());flower['total'] = function()&#123; return 99&#125;console.log(flower[\"total\"]()); 删 删除属性 123delete flower.type;delete flower['price'];console.log(flower); 删除方法 12delete flower.total;console.log(flower); 销毁对象 12flower =null;console.log(flower); 对象遍历 for … in 1234567891011121314151617// Object.keys(obj) 返回一个给定对象自身可枚举属性组成的数组。Object.keys(obj).lengthvar changbo = &#123; name:\"常博\", age:\"3岁\", sex:\"未知\", eat:\"面\", play : function()&#123; return \"王者\" &#125;&#125;for ( var i in changbo)&#123; console.log(changbo[i]);&#125; 对象拷贝 浅拷贝：直接拷贝对象的内存地址，如果原地址中的对象被改变，浅拷贝拷贝出来的对象会相应改变 只是增加了一个指针指向已存在的内存地址； 直接赋值 Object.assign(obj) 深拷贝：在内存中新开辟一块内存，将对象中的所有属性值全部赋值，深拷贝出来的对象不会影响之前的对象 增加了一个指针并且申请了一个新的内存，使这个指向新的内存。 Object.assign({}，obj) 不兼容低版本 ES6的内容只有 一层的时候就是深拷贝 如果第二层有引用类型的话则是浅拷贝 JSON.stringify() 将对象转换为字符串然后采用 JSON.parse转换成对象 注意：如果对象中存在函数/方法，那么该方法会丢失 1234var obj=&#123; name:\"张三\"&#125;var obj2=JSON.parse(JSON.stringify(obj)) ; 采用递归遍历，逐层拷贝 12345678910111213141516171819202122232425function fun(o)&#123; let s; //检测是否是一个数组 //o instanceof Array //Array.isArray(o) if(o instanceof Array)&#123; s = []; &#125;else if(typeof o == 'object')&#123; s =&#123;&#125; &#125;else&#123; return o; &#125; //遍历 判断是否对象中存在对象 有对象就递归函数 没有就直接赋值 for(var i in o)&#123; if(typeof o[i] == 'object')&#123; debugger //调试 s[i] = fun(o[i]) &#125;else&#123; console.log(7789); s[i] = o[i]; &#125; &#125; return s &#125;console.log(fun(chang)); 补充： let str = JSON.stringify(obj)将对象转换成字符串 let obj=JSON.parse(str) 将字符串转换成对象 对象特性封装 工厂函数（不建议使用） 123456789101112//工厂函数 不建议使用function person()&#123; var obj=&#123; name:\"张三\", age:'50岁', play:function()&#123; return 1 &#125; &#125; return obj &#125;console.log(person()); 构造函数 12345678//构造函数 大写function Fruit()&#123; this.name='西瓜'; this.size='15斤'; this.price='15块'&#125;var watermelon = new Fruit();console.log(watermelon); 继承 在一个对象的基础上，创建一个新的对象，并且这个新对象可以访问原对象的属性和方法，这就是继承 继承方式构造函数构造的对象 new Child() 对象 的原型链proto指向构造函数的原型prototype proto是对象的属性 prototype原型：函数 原型继承 123456789101112function Father()&#123; this.lastName=\"雷\";&#125;function Daughter()&#123; this.name=\"婷\"&#125;//Daughter继承Father 同时实例化FatherDaughter.prototype=new Father();let $daughter=new Daughter();console.log($daughter);console.log($daughter.lastName+$daughter.name); call()继承 立即执行 1234567891011//继承的方式有两种//1.继承的单个方法（继承的是实例化之后的），参数是一逗号隔开实例化被继承的对象.方法.call(谁来继承实例化之后的对象，参数1，参数2....)//2.继承整个构造函数（继承的是构造函数）被继承的构造函数.call（谁来继承实例化之后的对象）this的指向：call：里面是谁来继承this就指向谁 1234567891011121314151617181920function Father()&#123; this.lastName=\"老王\"; this.work=function(num)&#123; console.log('军人'); console.log(num); return '999' &#125;&#125;function Son()&#123; this.name=\"小白\"&#125;//实例化Father Sonlet $father = new Father();let $son = new Son()//继承单个方法 //call()会立即执行 并且输出$father.work.call($son,995);//继承整个 对象Father.call($son)console.log($son.work(995));console.log($son.lastName); apply() 继承 立即执行 1234567891011//继承的方式有两种//1.继承的单个方法（继承的是实例化之后的），参数是一逗号隔开实例化被继承的对象.方法.apply(谁来继承实例化之后的对象，[参数1，参数2....])//2.继承整个构造函数（继承的是构造函数）被继承的构造函数.apply（谁来继承实例化之后的对象）this的指向：apply：里面是谁来继承this就指向谁 123456789101112131415161718192021function Father()&#123; this.lastName=\"老王\"; this.work=function(num)&#123; console.log('军人'); console.log(num); return '999' &#125;&#125;function Son()&#123; this.name=\"小白\"&#125;//实例化Father Sonlet $father = new Father();let $son = new Son()//继承单个方法 //apply()会立即执行 并且输出$father.work.apply($son,[995]);//继承整个 对象Father.apply($son)console.log($son.work(995));console.log($son.lastName); bind() 继承 不会立即执行 需要手动调用 如果要立即输出在后面加个括号bind(谁来继承实例化之后的对象，参数1，参数2….)(); 1234567891011//继承的方式有两种//1.继承的单个方法（继承的是实例化之后的），参数是一逗号隔开实例化被继承的对象.方法.bind(谁来继承实例化之后的对象，参数1，参数2....)()//2.继承整个构造函数（继承的是构造函数）被继承的构造函数.bind（谁来继承：实例化之后的对象）()this的指向：bind：里面是谁来继承this就指向谁 12345678910111213141516171819202122function Father()&#123; this.lastName=\"老王\"; this.work=function(num)&#123; console.log('军人'); console.log(num); return '999' &#125;&#125;function Son()&#123; this.name=\"小白\"&#125;//实例化Father Sonlet $father = new Father();let $son = new Son()//继承单个方法 //bind()会立即执行 并且输出// $father.work.bind($son,995)();//继承整个 对象 切记括号Father.bind($son)();console.log($son.work(995));console.log($son.lastName); Function上的方法 函数原型上的方法 函数名.call() 函数原型的方法 call() apply() bind() 所有的函数都有这三个方法 函数原型上的方法 修改上下文 修改this 指向 call()和apply()的区别 面试问题 123call传递参数是通过逗号隔开依次跟在后面apply传参数是将所有参数放在一个数组中，哪怕只有一个参数call和apply继承的方法都是立即执行 call()和bind()的区别 面试问题 1call是立即执行函数。bind会将方法先继承，需要的时候在调用 ES6类继承：通过extends关键字实现类与类之间的继承，然后实例化子类，来实现继承 应用——修改函数中 this 指向 ——JavaScript中某些方法 Math.min.apply(null,arr) 原型 当我们在创建对象的时候会发现一些对象有一些共享的方法和属性，这些方法在每次创建的时候都会在内存进行保存，内存浪费非常严重，为了解决这个问题，我们使用原型，所谓原型，就是用于存储公共属性和方法的对象 javaScript规定，每个函数都有一个prototype属性，指向一个对象 原型链 当访问对象的属性或方法，该属性或方法会在对象本身调用，对象本身没有，那么去对象本身的构造函数调用 ，本身构造函数没有，那么去父类的构造函数调用、父类的原型…以此类推，直到寻找到Object、以及Object的原型null.最后属性不存在时会得到undefined,方法不存在会报错。 this 被自动定义在所有函数的作用域，总是会指向一个对象 this的指向在函数定义的时候确定不了，只有函数执行的时候才能确定this到底指向谁，实际上this 的最终执行的是那个调用它的对象 在事件中，this指向事件源 在构造函数中this指向构造函数的实例对象 在js里面this指向window 如果在事件中调用另一个函数，那么另一个函数this指向的是window,因为另一个函数是定义在window下面的 如果事件直接等于另一个函数，则另一个函数里面的this指向的是该事件的事件源 es6箭头函数this指向不会改变 定时器可以阻断this的传播 可以使用 let that=this； this绑定方式 call():谁来继承this就指向谁； apply():谁来继承this就指向谁； bind():谁来继承this就指向谁； null，undefined 的区别？null 表示一个对象是“没有值”的值，也就是值为“空”； null的类型(typeof)是object； Javascript从来不会将变量设为null。它是用来让程序员表明某个用var声明的变量时没有值的 undefined 表示一个变量声明了没有初始化(赋值)； undefined不是一个有效的JSON，而null是； undefined的类型(typeof)是undefined； Javascript将未赋值的变量默认值设为undefined； typeof undefined 是一个表示”无”的原始值或者说表示”缺少值”，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined； 例如变量被声明了，但没有赋值时，就等于undefined typeof null //“object” null : 是一个对象(空对象, 没有任何属性和方法)； 例如作为函数的参数，表示该函数的参数不是对象； 注意：在验证null时，一定要使用 === ，因为 == 无法分别 null 和undefined null == undefined // true null === undefined // false 介绍js有哪些内置对象？ Object 是 JavaScript 中所有对象的父对象 数据封装类对象：Object、Array、Boolean、Number 和 String 其他对象：Function、Arguments、Math、Date、RegExp、Error ES6新增对象：Symbol、Map、Set、Promises、Proxy、Reflect 列举一下JavaScript对象有哪些原生方法？ object.hasOwnProperty(prop); object.propertyIsEnumerable(prop); object.valueOf(); object.toString(); object.toLocaleString(); Class.prototype.isPropertyOf(object); Object.hasOwnProperty( ) 检查属性是否被继承 Object.isPrototypeOf( ) 一个对象是否是另一个对象的原型 Object.propertyIsEnumerable( ) 是否可以通过 for/in 循环看到属性 Object.toLocaleString( ) 返回对象的本地字符串表示 Object.toString( ) 定义一个对象的字符串表示 Object.valueOf( ) 指定对象的原始值 对象浅拷贝和深拷贝有什么区别在 JS 中，除了基本数据类型，还存在对象、数组这种引用类型。基本数据类型，拷贝是直接拷贝变量的值，而引用类型拷贝的其实是变量的地址。 12let o1 = &#123;a: 1&#125;let o2 = o1 在这种情况下，如果改变 o1 或 o2 其中一个值的话，另一个也会变，因为它们都指向同一个地址。 12o2.a = 3console.log(o1.a) // 3 而浅拷贝和深拷贝就是在这个基础之上做的区分 如果在拷贝这个对象的时候，只对基本数据类型进行了拷贝，而对引用数据类型只是进行了引用的传递，而没有重新创建一个新的对象，则认为是浅拷贝。 反之，在对引用数据类型进行拷贝的时候，创建了一个新的对象，并且复制其内的成员变量，则认为是深拷贝。 如何判断一个对象是否属于某个类？1234// 使用instanceof （待完善） if(a instanceof Person)&#123; alert(&apos;yes&apos;); &#125; javascript 的本地对象，内置对象和宿主对象 本地对象ECMA-262 把本地对象（native object）定义为“独立于宿主环境的 ECMAScript 实现提供的对象”。简单来说，本地对象就是 ECMA-262 定义的类（引用类型）。它们包括：Object、Function、Array、String、Boolean、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError 内置对象JS中内置了17个对象，常用的是Array对象、Date对象、正则表达式对象、string对象、Global对象 宿主对象由ECMAScript实现的宿主环境提供的对象，可以理解为：浏览器提供的对象。所有的BOM和DOM都是宿主对象。 原型的constructor属性问题：已知A继承了B，B继承了C。怎么判断 a 是由A直接生成的实例，还是B直接生成的实例呢？还是C直接生成的实例呢？ 分析：这就要用到原型的constructor属性了。 foo.__proto__.constructor === M的结果为true，但是 foo.__proto__.constructor === Object的结果为false。 所以，用 consturctor判断就比用 instanceof判断，更为严谨。 对象的几种创建方式 javascript创建对象简单的说,无非就是用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用 第一种：内置对象Object 创建1234567var wcDog =new Object(); wcDog.name=&quot;旺财&quot;; wcDog.age=3; wcDog.work=function()&#123; alert(&quot;我是&quot;+wcDog.name+&quot;,汪汪汪......&quot;); &#125; wcDog.work(); 123var Person = new Object();Person.name = \"Nike\";Person.age = 29; 这行代码创建了 Object 引用类型的一个新实例，然后把实例保存在变量 Person 中。 第二种：使用对象字面量表示法12345var Person = &#123;&#125;; //相当于 var Person = new Object();var Person = &#123; name: 'Nike'; age: 29;&#125; 对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。也就是说，第一种和第二种方式创建对象的方法其实都是一样的，只是写法上的区别不同 在介绍第三种的创建方法之前，我们应该要明白为什么还要用别的方法来创建对象，也就是第一种，第二种方法的缺点所在：它们都是用了同一个接口创建很多对象，会产生大量的重复代码，就是如果你有 100 个对象，那你要输入 100 次很多相同的代码。那我们有什么方法来避免过多的重复代码呢，就是把创建对象的过程封装在函数体内，通过函数的调用直接生成对象。 第三种：使用工厂模式创建对象123456789101112function createPerson(name, age, job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function() &#123; alert(this.name); &#125;; return o;&#125;var person1 = createPerson(\"Nike\", 29, \"teacher\");var person2 = createPerson(\"Arvin\", 20, \"student\"); 在使用工厂模式创建对象的时候，我们都可以注意到，在 createPerson 函数中，返回的是一个对象。那么我们就无法判断返回的对象究竟是一个什么样的类型。于是就出现了第四种创建对象的模式。 第四种:使用构造函数创建对象12345678910function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; alert(this.name); &#125;;&#125;var person1 = new Person(\"Nike\", 29, \"teacher\");var person2 = new Person(\"Arvin\", 20, \"student\"); 对比工厂模式，我们可以发现以下区别： 1.没有显示地创建对象 2.直接将属性和方法赋给了 this 对象 3.没有 return 语句 4.终于可以识别的对象的类型。对于检测对象类型，我们应该使用 instanceof 操作符，我们来进行自主检测： 1234567alert(person1 instanceof Object); //turealert(person1 instanceof Person); //turealert(person2 instanceof Object); //turealert(person2 instanceof Object); //ture 同时我们也应该明白，按照惯例，构造函数始终要应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。 那么构造函数确实挺好用的，但是它也有它的缺点： 就是每个方法都要在每个实例上重新创建一遍，方法指的就是我们在对象里面定义的函数。如果方法的数量很多，就会占用很多不必要的内存。于是出现了第五种创建对象的方法 第五种：原型创建对象模式1234567function Dog()&#123;&#125;Dog.prototype.name=&quot;旺财&quot;;Dog.prototype.eat=function()&#123; alert(this.name+&quot;是个吃货&quot;);&#125;var wangcai =new Dog();wangcai.eat(); 123456789function Person() &#123;&#125;Person.prototype.name = \"Nike\";Person.prototype.age = 20;Person.prototype.jbo = \"teacher\";Person.prototype.sayName = function() &#123; alert(this.name);&#125;;var person1 = new Person();person1.sayName(); 使用原型创建对象的方式，可以让所有对象实例共享它所包含的属性和方法。 如果是使用原型创建对象模式，请看下面代码： 123456789101112function Person() &#123;&#125;Person.prototype.name = \"Nike\";Person.prototype.age = 20;Person.prototype.jbo = \"teacher\";Person.prototype.sayName = function() &#123; alert(this.name);&#125;;var person1 = new Person();var person2 = new Person();person1.name = \"Greg\";alert(person1.name); //'Greg' --来自实例alert(person2.name); //'Nike' --来自原型 当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性。 这时候我们就可以使用构造函数模式与原型模式结合的方式，构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性 第六种：组合使用构造函数模式和原型模式123456789101112function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job;&#125;Person.prototype = &#123; constructor: Person, sayName: function() &#123; alert(this.name); &#125;;&#125;var person1 = new Person('Nike', 20, 'teacher'); 123456789function Car(name,price)&#123; this.name=name; this.price=price; &#125; Car.prototype.sell=function()&#123; alert(&quot;我是&quot;+this.name+&quot;，我现在卖&quot;+this.price+&quot;万元&quot;); &#125; var camry =new Car(&quot;凯美瑞&quot;,27); camry.sell(); 用function来模拟无参的构造函数 123456789 function Person()&#123;&#125; //定义一个function，如果使用new&quot;实例化&quot;,该function可以看作是一个Class var person=new Person(); person.name=&quot;Mark&quot;; person.age=&quot;25&quot;; person.work=function()&#123; alert(person.name+&quot; hello...&quot;); &#125;person.work(); 用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性） 12345678910function Pet(name,age,hobby)&#123; this.name=name;//this作用域：当前对象 this.age=age; this.hobby=hobby; this.eat=function()&#123; alert(&quot;我叫&quot;+this.name+&quot;,我喜欢&quot;+this.hobby+&quot;,是个程序员&quot;); &#125; &#125; var maidou =new Pet(&quot;麦兜&quot;,25,&quot;coding&quot;);//实例化、创建对象 maidou.eat();//调用eat方法 javascript创建对象的几种方式？javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用 1、对象字面量的方式 person={firstname:&quot;Mark&quot;,lastname:&quot;Yun&quot;,age:25,eyecolor:&quot;black&quot;}; 2、用function来模拟无参的构造函数 123456789function Person()&#123;&#125;//定义一个function，如果使用new&quot;实例化&quot;,该function可以看作是一个Classperson.name=&quot;Mark&quot;;var person=new Person();person.age=&quot;25&quot;;person.work=function()&#123;alert(person.name+&quot; hello...&quot;);&#125;person.work(); 3、用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性） 12345678910function Pet(name,age,hobby)&#123; this.name=name;//this作用域：当前对象 this.age=age; this.hobby=hobby; this.eat=function()&#123; alert(&quot;我叫&quot;+this.name+&quot;,我喜欢&quot;+this.hobby+&quot;,是个程序员&quot;); &#125;&#125;var maidou =new Pet(&quot;麦兜&quot;,25,&quot;coding&quot;);//实例化、创建对象maidou.eat();//调用eat方法 4、用工厂方式来创建（内置对象） 1234567var wcDog =new Object(); wcDog.name=&quot;旺财&quot;; wcDog.age=3; wcDog.work=function()&#123; alert(&quot;我是&quot;+wcDog.name+&quot;,汪汪汪......&quot;); &#125; wcDog.work(); 5、用原型方式来创建 123456789function Dog()&#123; &#125; Dog.prototype.name=&quot;旺财&quot;; Dog.prototype.eat=function()&#123; alert(this.name+&quot;是个吃货&quot;); &#125; var wangcai =new Dog(); wangcai.eat(); 6、用混合方式来创建 123456789function Car(name,price)&#123; this.name=name; this.price=price;&#125; Car.prototype.sell=function()&#123; alert(&quot;我是&quot;+this.name+&quot;，我现在卖&quot;+this.price+&quot;万元&quot;); &#125;var camry =new Car(&quot;凯美瑞&quot;,27);camry.sell(); JavaScript Object对象的方法总结( ES5 与 ES6 )ES5中的方法Object 对象的静态方法所谓“静态方法”，是指部署在Object对象自身的方法 —（此句话摘自 阮一峰博客） Object.keys()方法与Object.getOwnPropertyNames方法很相似，一般用来遍历对象的（属性名，索引），并返回一个数组，该数组成员都是对象自身的（不是继承的），区别在于Object.keys方法只返回可枚举的属性，Object.getOwnPropertyNames方法还能返回不可枚举的属性名 1.Object.keys 12345678910111213141516171819202122232425// 定义一个 Array 对象let arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];// 定义一个 Object 对象let obj = &#123; foo: &quot;bar&quot;, baz: 42 &#125;；// 定义一个 类数组 对象 let ArrayLike = &#123; 0 : &quot;a&quot;, 1 : &quot;b&quot;, 2 : &quot;c&quot;&#125;;// 类数组 对象, 随机 key 排序 let anObj = &#123; 100: &apos;a&apos;, 2: &apos;b&apos;, 7: &apos;c&apos; &#125;; /* getFoo 是个不可枚举的属性 */ var my_obj = Object.create(&#123;&#125;, &#123; getFoo : &#123; value : function () &#123; return this.foo &#125; &#125; &#125;);my_obj.foo = 1;// 打印结果console.log(Object.keys(arr)); // [&apos;0&apos;, &apos;1&apos;, &apos;2&apos;]console.log(Object.keys(obj)); // [&quot;foo&quot;,&quot;baz&quot;]console.log(Object.keys(ArrayLike)); // [&apos;0&apos;, &apos;1&apos;, &apos;2&apos;]console.log(Object.keys(anObj)); // [&apos;2&apos;, &apos;7&apos;, &apos;100&apos;]console.log(Object.keys(my_obj)); // [&apos;foo&apos;] [ 复制代码](https://common.cnblogs.com/images/copycode.gif) 返回数组中的排序与for..in是一致的，区别在于for..in循环还可以枚举原型链上的属性 ``2.Object.getOwnPropertyNames 12345678910111213141516171819// 定义一个数组var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];// 定义一个 类数组对象var obj = &#123; 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;&#125;;//定义一个 不可枚举属性var my_obj = Object.create(&#123;&#125;, &#123; getFoo: &#123; value: function() &#123; return this.foo; &#125;, enumerable: false &#125;&#125;);my_obj.foo = 1;// 打印结果console.log(Object.getOwnPropertyNames(arr).sort()); // [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;length&quot;]console.log(Object.getOwnPropertyNames(obj).sort()); // [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]console.log(Object.getOwnPropertyNames(my_obj).sort()); // [&quot;foo&quot;, &quot;getFoo&quot;] 3.对象属性相关的方法 1// 看此方法之前，我觉得应该先了解一下，对象的属性分为哪两种，插句题外话，O(∩_∩)O哈哈~ 对象里目前存在的属性描述符有两种主要形式：数据描述符 和 存取描述符\\。 数据描述符: 是一个具有值的属性，该值可能是可写的，也可能不是可写的。 访问器描述符: 是由getter-setter函数对描述的属性。描述符必须是这两种形式之一；不能同时是两者。 数据描述符和存取描述符均具有以下可选键值： configurable: 当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。 enumerable: 当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false。 value: 该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。 writable: 当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。 getter: 一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。该方法返回值被用作属性值。默认为 undefined。 setter: 一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认为 undefined。 注意：如果一个描述符同时设置value,writable,get和set关键字，它将被认为是一个数据描述符。如果一个描述符同时有value或writable和get或set关键字，将产生异常。 记住，这些选项不一定是自身属性，如果是继承来的也要考虑。为了确认保留这些默认值，你可能要在这之前冻结 Object.prototype，明确指定所有的选项，或者将 __proto__属性指向null。 a).Object.getOwnPropertyDescriptor( obj, prop) 返回一个指定对象上的自有属性对应的属性描述 （自由属性指，直接赋值的属性，不需要从原型上查找的属性） 参数: obj 需要查找的目标对象 prop 目标对象内的属性名称 12345678910111213141516let o = &#123; get foo() &#123; return 17; &#125; &#125;;let d = Object.getOwnPropertyDescriptor(o, &quot;foo&quot;);let o1 = &#123; bar: 42 &#125;;let d1 = Object.getOwnPropertyDescriptor(o1, &quot;bar&quot;);let o2 = &#123;&#125;;Object.defineProperty(o2, &quot;baz&quot;, &#123; value: 8675309, writable: false, enumerable: false&#125;);let d2 = Object.getOwnPropertyDescriptor(o2, &quot;baz&quot;);console.log(d)// &#123;configurable: true, enumerable: true, get: [Function: get foo],set: undefined&#125;console.log(d1)//&#123;configurable: true, enumerable: true, value: 42, writable: true&#125;console.log(d2)// &#123;value: 8675309, writable: false, enumerable: false, configurable: false&#125; 注意事项：ES5第一个参数不是对象，就会产生TypeError, ES2015第一个参数不是对象的话，就会被强制转换成对象 b).Object.defineProperty( obj, prop, decriptor) 直接在一个对象上定义一个新属性，或修改一个对象的现有属性，并返回这个对象，默认情况下使用此方法添加的属性值是不能被修改的 参数： obj 要在其上定义属性的对象 prop 要定义或修改的属性名称 decriptor 将被定义或修改的属性描述符 123456789101112131415161718192021222324252627282930313233343536var o = &#123;&#125;; // 创建一个新对象// 在对象中添加一个属性与数据描述符的示例Object.defineProperty(o, &quot;a&quot;, &#123; value : 37, writable : true, enumerable : true, configurable : true&#125;);// 对象o拥有了属性a，值为37// 在对象中添加一个属性与存取描述符的示例var bValue;Object.defineProperty(o, &quot;b&quot;, &#123; get : function()&#123; return bValue; &#125;, set : function(newValue)&#123; bValue = newValue; &#125;, enumerable : true, configurable : true&#125;);o.b = 38;// 对象o拥有了属性b，值为38// o.b的值现在总是与bValue相同，除非重新定义o.b// 数据描述符和存取描述符不能混合使用Object.defineProperty(o, &quot;conflict&quot;, &#123; value: 0x9f91102, get: function() &#123; return 0xdeadbeef; &#125;&#125;);// TypeError: Invalid property descriptor. Cannot both specify accessors and a value or writable attribute(无效的属性描述符,不能同时指定访问器和值或可写属性) c).Object.defineProperties() d).Object.getOwnPropertyNames() 4.控制对象状态的方法 a).Object.preventExtensions() 防止对象扩展 b).Object.isExtensible() 判断对象是否可扩展 c).Object.seal() 禁止对象配置 d).Object.isSealed() 判断一个对象是否可配置 e).Object.freeze() 冻结一个对象 f).Object.isFrozen() 判断一个对象是否被冻结 5.原型链相关方法 a).Object.creat() 可以指定原型对象和属性，返回一个新的对象 b).Object.getPrototypeOf() 获取对的的Prototype对象 Object对象的实例方法除了Object对象本身的方法，还有不少方法是部署在Object.prototype对象上的，所有Object的实例对象都继承了这些方法。Object实例对象的方法，主要有以下六个。（此句摘自 –阮一峰 博客） a). valueOf()返回当前对象对应的值 b). toString()返回当前对象对应的字符串形式,用来判断一个值的类型 c). toLocaleString()返回当前对象对应的本地字符串形式 d). hasOwnProperty()判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性 e). isPrototypeOf()判断当前对象是否为另一个对象的原型 f). propertyIsEnumerable()判断某个属性是否可枚举 ES6新增方法(摘自 阮一峰ECMAScript 6 入门 ) 1.属性的简洁写法 ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。 属性简写 12345678function f(x, y) &#123; return &#123;x, y&#125;;&#125;// 等同于function f(x, y) &#123; return &#123;x: x, y: y&#125;;&#125;f(1, 2) // Object &#123;x: 1, y: 2&#125; 方法名简写 1234567891011const o = &#123; method() &#123; return &quot;Hello!&quot;; &#125;&#125;;// 等同于const o = &#123; method: function() &#123; return &quot;Hello!&quot;; &#125;&#125;; 属性简写与方法名简写，例： 12345678let birth = &apos;2000/01/01&apos;;const Person = &#123; name: &apos;张三&apos;, //等同于birth: birth birth, // 等同于hello: function ()... hello() &#123; console.log(&apos;我的名字是&apos;, this.name); &#125;&#125;; CommonJS 模块输出一组变量，就非常合适使用简洁写法 12345678910111213let ms = &#123;&#125;;function getItem (key) &#123; return key in ms ? ms[key] : null;&#125;function setItem (key, value) &#123; ms[key] = value;&#125;module.exports = &#123; getItem, setItem &#125;;// 等同于module.exports = &#123; getItem: getItem, setItem: setItem&#125;; 属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法 123456789101112const cart = &#123; _wheels: 4, get wheels () &#123; return this._wheels; &#125;, set wheels (value) &#123; if (value &lt; this._wheels) &#123; throw new Error(&apos;数值太小了！&apos;); &#125; this._wheels = value; &#125;&#125; 2.属性名表达式 方法一，是直接用标识符作为属性名 方法二，是用表达式作为属性名，这时要将表达式放在方括号之内。 1234// 方法一obj.foo = true;// 方法二obj[&apos;a&apos; + &apos;bc&apos;] = 123; 表达式还可以用做方法名 123456let obj = &#123; [&apos;h&apos; + &apos;ello&apos;]() &#123; return &apos;hi&apos;; &#125;&#125;;obj.hello() // hi 注意，属性名表达式与简洁表示法，不能同时使用，会报错。 12345678// 报错const foo = &apos;bar&apos;;const bar = &apos;abc&apos;;const baz = &#123; [foo] &#125;;// 正确const foo = &apos;bar&apos;;const baz = &#123; [foo]: &apos;abc&apos;&#125;; 注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。 123456789const keyA = &#123;a: 1&#125;;const keyB = &#123;b: 2&#125;;const myObject = &#123; [keyA]: &apos;valueA&apos;, [keyB]: &apos;valueB&apos;&#125;;myObject // Object &#123;[object Object]: &quot;valueB&quot;&#125; 上面代码中，[keyA]和[keyB]得到的都是[object Object]，所以[keyB]会把[keyA]覆盖掉，而myObject最后只有一个[object Object]属性。 3.方法的 name 属性 如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。 4.Object.is() 它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致 ES5 比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。 1234Object.is(&apos;foo&apos;, &apos;foo&apos;)// trueObject.is(&#123;&#125;, &#123;&#125;)// false 不同之处只有两个：一是+0不等于-0，二是NaN等于自身。 12345+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // true ES5 可以通过下面的代码，部署Object.is。 12345678910111213Object.defineProperty(Object, &apos;is&apos;, &#123; value: function(x, y) &#123; if (x === y) &#123; // 针对+0 不等于 -0的情况 return x !== 0 || 1 / x === 1 / y; &#125; // 针对NaN的情况 return x !== x &amp;&amp; y !== y; &#125;, configurable: true, enumerable: false, writable: true&#125;); 5.Object.assign( target, source, source1 ) 方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false） 参数 target 目标对象 source 源对象 1234567const target = &#123; a: 1, b: 1 &#125;;const source1 = &#123; b: 2, c: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; 注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。 123let obj = &#123;a: 1&#125;;Object.assign(obj, undefined) === obj // trueObject.assign(obj, null) === obj / 如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果undefined和null不在首参数，就不会报错。 注意： **a). Object.assign**方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。 1234567const obj1 = &#123;a: &#123;b: 1&#125;&#125;;const obj2 = Object.assign(&#123;&#125;, obj1);obj1.a.b = 2;console.log(obj2.a.b) //2obj2.a.b = 3console.log(obj1.a.b) //3 上面代码中，源对象obj1的a属性的值是一个对象，Object.assign拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。 b). 数组的处理 1Object.assign([1, 2, 3], [4, 5])// [4, 5, 3] 上面代码中，Object.assign把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性4覆盖了目标数组的 0 号属性1。 常见用途 a). 为对象添加属性 12345class Point &#123; constructor(x, y) &#123; Object.assign(this, &#123;x, y&#125;); &#125;&#125; 上面方法通过Object.assign方法，将x属性和y属性添加到Point类的对象实例。 b). 为对象添加方法 12345678910111213141516Object.assign(SomeClass.prototype, &#123; someMethod(arg1, arg2) &#123; ··· &#125;, anotherMethod() &#123; ··· &#125;&#125;);// 等同于下面的写法SomeClass.prototype.someMethod = function (arg1, arg2) &#123; ···&#125;;SomeClass.prototype.anotherMethod = function () &#123; ···&#125;; 上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用assign方法添加到SomeClass.prototype之中。 c). 克隆对象 123function clone(origin) &#123; return Object.assign(&#123;&#125;, origin);&#125; 上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。 不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。 1234function clone(origin) &#123; let originProto = Object.getPrototypeOf(origin); return Object.assign(Object.create(originProto), origin);&#125; d). 合并多个对象，将多个对象合并到某个对象。 12345const merge = (target, ...sources) =&gt; Object.assign(target,...sources);//如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。const merge =(...sources) =&gt; Object.assign(&#123;&#125;, ...sources); e). 为属性指定默认值 6.属性的可枚举和可遍历 可枚举性 对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。 a). Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。 123let obj = &#123; foo: 123 &#125;;Object.getOwnPropertyDescriptor(obj, &apos;foo&apos;)// &#123; value: 123, writable: true, enumerable: true, configurable: true &#125; 目前，有四个操作会忽略enumerable为false的属性。 for...in循环：只遍历对象自身的和继承的可枚举的属性。 Object.keys()：返回对象自身的所有可枚举的属性的键名。 JSON.stringify()：只串行化对象自身的可枚举的属性。 Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。 ES6 规定，所有 Class 的原型的方法都是不可枚举的。 属性的遍历一共有5种： for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。 Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。 Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。 Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。 Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。 JS操作对象属性（获取、添加、删除、修改对象属性）属性也称为名值对，包括属性名和属性值。属性名可以是包含空字符串在内的任意字符串，一个对象中不能存在两个同名的属性。属性值可以是任意类型的数据。 定义属性1. 直接量定义在对象直接量中，属性名与属性值之间通过冒号分隔，冒号左侧是属性名，右侧是属性值，名值对（属性）之间通过逗号分隔。 示例1在下面示例中，使用直接量方法定义对象 obj，然后添加了两个成员，一个是属性，另一个是方法。 123456var obj = &#123; x : 1, y : function () &#123; return this.x + this.x; &#125;&#125; 2. 点语法定义示例2通过点语法，可以在构造函数内或者对象外添加属性。 12345var obj = &#123;&#125;;obj.x = 1;obj.y = function () &#123; return this.x + this.x;&#125; 3. 使用 Object.defineProperty使用 Object.defineProperty() 函数可以为对象添加属性，或者修改现有属性。如果指定的属性名在对象中不存在，则执行添加操作；如果在对象中存在同名属性，则执行修改操作。 具体用法如下： Object.defineProperty(object, propertyname, descriptor); 参数说明如下： object：指定要添加或修改属性的对象，可以是 JavaScript 对象或者 DOM 对象。 propertyname：表示属性名的字符串。 descriptor：定义属性的描述符，包括对数据属性或访问器属性。 Object.defineProperty 返回值为已修改的对象。 示例3下面示例先定义一个对象直接量 obj，然后使用 Object.defineProperty() 函数为 obj 对象定义属性，属性名为 x，值为 1，可写、可枚举、可修改特性。 12345678var obj = &#123;&#125;;Object.defineProperty(obj, &quot;x&quot;, &#123; value : 1, writable : true, enumerable : true, configurable : true&#125;);console.log(obj.x); //1 4. 使用 Object.defineProperties使用 Object.defineProperties() 函数可以一次定义多个属性。具体用法如下： object.defineProperties(object, descriptors); 参数说明如下： object：对其添加或修改属性的对象，可以是本地对象或 DOM 对象。 descriptors：包含一个或多个描述符对象，每个描述符对象描述一个数据属性或访问器属性。 示例4在下面示例中，使用 Object.defineProperties() 函数将数据属性和访问器属性添加到对象 obj 上。 1234567891011121314151617var obj = &#123;&#125;;Object.defineProperties(obj, &#123; x : &#123; //定义属性x value : 1, writable : true, //可写 &#125;, y : &#123; //定义属性y set : function (x) &#123; //设置访问器属性 this.x = x; //改写obj对象的x属性的值 &#125;, get : function () &#123; //设置访问器 return this.x; &#125;, &#125;&#125;);obj.y = 10;console.log(obj.x); //10 读写属性1. 使用点语法使用点语法可以快速读写对象属性，点语法左侧是引用对象的变量，右侧是属性名。 示例1下面示例定义对象 obj，包含属性 x，然后使用点语法读取属性 x 的值。 123456var obj = &#123; //定义对象 x : 1&#125;console.log(obj.x); //访问对象属性x，返回1obj.x = 2; //重写属性值console.log(obj.x); //访问对象属性x，返回2 2. 使用中括号语法从结构上分析，对象与数组相似，因此可以使用中括号来读写对象属性。 示例2针对上面示例，可以使用中括号来读写对象属性。 123console.log(obj[&quot;x&quot;]); //2obj[&quot;x&quot;] = 3; //重写属性值console.log(obj[&quot;x&quot;]); //3 【注意事项】 在中括号语法中，必须以字符串形式指定属性名，不能使用标识符。 中括号内可以使用字符串，也可以使用字符型表达式，即只要表达式的值为字符串即可。 示例3下面示例使用 for/in 遍历对象的可枚举属性，并读取它们的值，然后重写属性值。 12345for (var i in obj) &#123; console.log(obj[i]); obj[i] = obj[i] + obj[i]; console.log(obj[i]);&#125; 在上面代码中，中括号中的表达式 i 是一个变量，其返回值为 for/in 遍历对象时枚举的每个属性名。 3. 使用 Object.getOwnPropertyNames使用 Object.getOwnPropertyNames() 函数能够返回指定对象私有属性的名称。私有属性是指用户在本地定义的属性，而不是继承的原型属性。具体用法如下： Object.getOwnPropertyNames(object); 参数 object 表示一个对象，返回值为一个数组，其中包含所有私有属性的名称。其中包括可枚举的和不可枚举的属性和方法的名称。如果仅返回可枚举的属性和方法的名称，应该使用 Object.keys() 函数。 示例4在下面示例中定义一个对象，该对象包含三个属性，然后使用 getOwnPropertyNames 获取该对象的私有属性名称。 123var obj = &#123;x : 1, y : 2, z : 3&#125;;var arr = Object.getOwnPropertyNames(obj);console.log(arr); //返回属性名：x,yz 4. 使用 Object.keys使用 Object.keys() 函数仅能获取可枚举的私有属性名称。具体用法如下： Object.keys(object); 参数 object 表示指定的对象，可以是 JavaScript 对象或 DOM 对象。返回值是一个数组，其中包含对象的可枚举属性名称。 5. Object.getOwnPropertyDescriptor使用 Object.getOwnPropertyDescriptor() 函数能够获取对象属性的描述符。具体用法如下： Object.getOwnPropertyDescriptor(object, propertyname); 参数 object 表示指定的对象，propertyname 表示属性的名称。返回值为属性的描述符对象。 示例5在下面示例中定义一个对象 obj，包含 3 个属性，然后使用 Object.getOwnPropertyDescriptor() 函数获取属性 x 的数据属性描述符，并使用该描述符将属性 x 设置为只读。最后，调用 Object.defineProperty() 函数，使用数据属性描述符修改属性 x 的特性。遍历修改后的对象，可以发现只读属性 writable 为 false。 123456789101112var obj = &#123;x : 1, y : 2, z : 3&#125;; //定义对象var des = Object.getOwnPropertyDescriptor(obj, &quot;x&quot;); //获取属性x的数据属性描述符for (var prop in des) &#123; //遍历属性描述符对象 console.log(prop + &apos;:&apos; + des[prop]); //显示特性值&#125;des.writable = false; //重写特性，不允许修改属性des.value = 100; //重写属性值Object.defineProperty(obj, &quot;x&quot;, des); //使用修改后的数据属性描述符覆盖属性xvar des = Object.getOwnPropertyDescriptor(obj, &quot;x&quot;); //重新获取属性x的数据属性描述符for (var prop in des) &#123; //遍历属性描述符对象 console.log(prop + &apos;:&apos; + des[prop]); //显示特性值&#125; 一旦为未命名的属性赋值后，对象就会自动定义该属性的名称，在任何时候和位置为该属性赋值，都不需要定义属性，而只会重新设置它的值。如果读取未定义的属性，则返回值都是 undefined。 删除属性使用 delete 运算符可以删除对象的属性。 示例下面示例使用 delete 运算符删除指定属性。 123var obj = &#123;x : 1&#125;; //定义对象delete obj.x; //删除对象的属性xconsole.log(obj.x); //返回undefined 当删除对象属性之后，不是将该属性值设置为 undefined，而是从对象中彻底清除属性。如果使用 for/in 语句枚举对象属性，只能枚举属性值为 undefined 的属性，但不会枚举已删除属性。 使用方法方法也是函数，当函数被赋值给对象的属性，就被称为方法。方法的使用与函数是相同的，唯一的不同点是在方法内常用 this 引用调用对象，其实在普通函数内也有 this，只不过不常用。 使用点语法或中括号可以访问方法，使用小括号可以激活方法。 示例1与普通函数用法一样，可以在调用方法时传递参数，也可以设计返回值。 123456var obj = &#123;&#125;;obj.f = function (n) &#123; //定义对象的方法 return 10 * n;&#125;var n = obj.f(5); //调用方法，设置参数为5console.log(n); //返回值50 示例2在方法内 this 总是指向当前调用对象。在下面示例中，当在不同运行环境中调用对象 obj 的方法 f() 时，该方法的 this 指向时不同的。 12345678var obj = &#123; //定义对象 f : function () &#123; //定义对象的方法 console.log(this); //访问当前对象 &#125;&#125;obj.f(); //此时this指向对象objvar f1 = obj.f; //引用对象obj的方法ff1(); //此时this指向对象window JavaScript中?. 和??分别是什么详解在项目中我们往往要做很多很多的空值判断进行容错处理,往往伴随着三目运算、与或、if else来使用,下面这篇文章主要给大家介绍了关于JavaScript中?. 和??分别是什么 ?.和 ?? 是 JavaScript 中的两个新操作符，分别是可选链操作符（optional chaining operator）和空值合并操作符（nullish coalescing operator）。 ?. 操作符（可选链运算符） ?. 表示：可选链操作符( ?. )允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每 个引用是否有效。操作符的功能类似于 . 链式操作符，不同之处在于，在引用为空(null 或者 undefined) 的情况下不会引起错误，该表达式短路返回值 判断对象的某个属性是否存在，如果存在那么就返回整个属性的值，否则返回undefined 在javascript中如果一个值为null、undefined，直接访问下面的属性，会报 Uncaught TypeError: Cannot read properties of undefined 异常错误。 ?. 可选链操作符用于访问可能为空或未定义的属性或方法，它允许我们安全地访问嵌套对象的属性，如果中间的属性为空或未定义，则不会抛出错误，而是返回 undefined。例如： 1`const obj = &#123;`` ``foo: &#123;`` ``bar: 123`` ``&#125;``&#125;;` `// 普通访问属性的方式``const x = obj.foo.bar; ``// x = 123` `// 使用可选链操作符``const y = obj?.foo?.bar; ``// y = 123` `// 如果对象未定义，则返回 undefined``const z = undefined?.foo?.bar; ``// z = undefined` ?? 操作符（空值合并运算符）??表示：只有左侧的值为 null 或 undefined 的时候才返回右侧的值 ?? 双问号后面是默认值（可常量、可变量）。 在 ?? 前面没有值的时候会默认 ?? 后边的值（类似于三目运算符中的:后面赋值） img ?? 空值合并操作符用于检查一个变量是否为 null 或 undefined，如果是，则返回一个默认值，否则返回该变量的值。与传统的逻辑运算符 || 不同，?? 只会在左侧的值为 null 或 undefined 时返回右侧的默认值，对于其他假值（如空字符串、0、false 等）并不会返回默认值，而是会返回它本身。例如： 1`const x = undefined ?? ``&apos;default&apos;``; ``// x = &apos;default&apos;``const y = ``null` `?? ``&apos;default&apos;``; ``// y = &apos;default&apos;``const z = ``&apos;value&apos;` `?? ``&apos;default&apos;``; ``// z = &apos;value&apos;``const a = ``&apos;&apos;` `?? ``&apos;default&apos;``; ``// a = &apos;&apos;``const b = ``&apos;&apos;` `|| ``&apos;default&apos;``; ``// b = &apos;default&apos;` 需要注意的是，?? 操作符需要在 ES11 及以上的版本才能使用。 和||运算符的区别： || 只会在左边的值为假值时返回右边的值 (0, ‘’, undefined, null, false 等都为假值) ?? 是在左边的值为undefined或者null时才会返回右边的值 img ??=（空值赋值运算符）意思是只有当??=左侧的值为undefined、null时，才会把右侧的值赋给左侧，否则左侧不会被赋值 12345let a;let b = &apos;123&apos;;let c = &apos;qwer&apos;a ??= b;// &apos;123&apos;b ??= c;// &apos;123&apos; 举个🌰: (1)这个时候存在detail然后去detail下查找cat属性，因为obj定义了cat所以返回huahua 12345678const obj = &#123; name: &apos;ceshi&apos;, detail: &#123;&#125;&#125;const name = obj.dog ?. name;console.log(name) // undefinedconst cat = obj.detail ?. cat ?? &apos;default name&apos;console.log(cat) // default name (2)查找obj中detail属性下面name属性，但是对象中没有定义所以值是undefined，这个时候？？左侧是undefied那么久使用右侧的数据所以最终返回default name 12345678910const obj = &#123; name: &apos;ceshi&apos;, detail: &#123; cat: &apos;huahua&apos; &#125; &#125;const name = obj.dog ?. name;console.log(name) // undefinedconst cat = obj.detail ?. cat ?? &apos;default name&apos;console.log(cat) // huahua","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qw8.github.io/tags/JavaScript/"},{"name":"类","slug":"类","permalink":"https://qw8.github.io/tags/类/"},{"name":"对象","slug":"对象","permalink":"https://qw8.github.io/tags/对象/"}]},{"title":"JavaScript函数","slug":"knowledges/JavaScript函数","date":"2020-04-05T13:10:40.000Z","updated":"2024-03-28T16:36:44.000Z","comments":true,"path":"/knowledges/javascript-han-shu.html","link":"","permalink":"https://qw8.github.io/knowledges/javascript-han-shu.html","excerpt":"","text":"内置函数(原生函数) String Number Boolean Object Function Array Date RegExp Error Symbol 简述创建函数的几种方式123456789101112//第一种（函数声明）：function sum1(num1,num2)&#123; return num1+num2;&#125;//第二种（函数表达式）：var sum2 = function(num1,num2)&#123; return num1+num2;&#125;//第三种（函数对象方式）：var sum3 = new Function(&quot;num1&quot;,&quot;num2&quot;,&quot;return num1+num2&quot;); JavaScript 中，调用函数有哪几种方式？ 方法调用模式 Foo.foo(arg1, arg2); 函数调用模式 foo(arg1, arg2); 构造器调用模式 (new Foo())(arg1, arg2); call/applay调用模式 Foo.foo.call(that, arg1, arg2); bind调用模式 Foo.foo.bind(that)(arg1, arg2)(); 什么是函数节流？介绍一下应用场景和原理？ 函数节流(throttle)是指阻止一个函数在很短时间间隔内连续调用。只有当上一次函数执行后达到规定的时间间隔，才能进行下一次调用。但要保证一个累计最小调用间隔（否则拖拽类的节流都将无连续效果） 函数节流用于 onresize, onscroll 等短时间内会多次触发的事件 函数节流的原理：使用定时器做时间节流。当触发一个事件时，先用 setTimout 让这个事件延迟一小段时间再执行。如果在这个时间间隔内又触发了事件，就 clearTimeout 原来的定时器，再 setTimeout 一个新的定时器重复以上流程。 函数节流简单实现： 12345678910function throttle(method, context) &#123; clearTimeout(methor.tId); method.tId = setTimeout(function()&#123; method.call(context); &#125;， 100); // 两次调用至少间隔 100ms&#125;// 调用window.onresize = function()&#123; throttle(myFunc, window);&#125; setTimeout、setInterval和requestAnimationFrame；（参考链接）（requestAnimationFrame）基本用法与区别 setTimeout(code, millseconds) 用于延时执行参数指定的代码，如果在指定的延迟时间之前，你想取消这个执行，那么直接用clearTimeout(timeoutId)来清除任务，timeoutID 是 setTimeout 时返回的； setInterval(code, millseconds)用于每隔一段时间执行指定的代码，永无停歇，除非你反悔了，想清除它，可以使用 clearInterval(intervalId)，这样从调用 clearInterval 开始，就不会在有重复执行的任务，intervalId 是 setInterval 时返回的； requestAnimationFrame(code)，一般用于动画，与 setTimeout 方法类似，区别是 setTimeout 是用户指定的，而 requestAnimationFrame 是浏览器刷新频率决定的，一般遵循 W3C 标准，它在浏览器每次刷新页面之前执行。 分析 [‘1’, ‘2’, ‘3’].map(parseInt) 答案是多少？ 答案:[1, NaN, NaN] parseInt(string, radix) 第2个参数 radix 表示进制。省略 radix 或 radix = 0，则数字将以十进制解析，因为 parseInt 需要两个参数 (val, radix)，其中 radix 表示解析时用的基数。 map 每次为 parseInt 传3个参数(elem, index, array)，其中 index 为数组索引 因此，map 遍历 [“1”, “2”, “3”]，相应 parseInt 接收参数如下 123parseInt(&apos;1&apos;, 0); // 1parseInt(&apos;2&apos;, 1); // NaNparseInt(&apos;3&apos;, 2); // NaN 所以，parseInt 参数 radix 不合法，导致返回值为 NaN解析失败。 使用构造函数的注意点1 一般情况下构造函数的首字母需要大写，因为我们在看到一个函数首字母 大写的情况，就认定这是一个构造函数，需要跟new关键字进行搭配使用，创建一个新的 实例（对象） 2 构造函数在被调用的时候需要跟new关键字搭配使用。 3 在构造函数内部通过this+属性名的形式为实例添加一些属性和方法。 4 构造函数一般不需要返回值，如果有返回值 如果返回值是一个基本数据类型，那么调用构造函数，返回值仍旧是那么创建出来的对象。 如果返回值是一个复杂数据类型，那么调用构造函数的时候，返回值就是这个return之后的那个复杂数据类型。 定时器 setInterval 有一个有名函数 fn1，setInterval（fn1,500）与 setInterval（fn1(),500）有什么区别？第一个是重复执行每 500 毫秒执行一次，后面一个只执行一次。 Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？HasOwnProperty window.location.search() 返回的是什么？查询(参数)部分。除了给动态语言赋值以外，我们同样可以给静态页面,并使用 javascript 来获得相信应的参数值返回值：?ver=1.0&amp;id=timlq 也就是问号后面的！ window.location.hash 返回的是什么？锚点 ， 返回值：#love ； apply/call/bind 自我实现 call/apply/bind 日常编码中被开发者用来实现 “对象冒充”，也即 “显示绑定 this“。 https://github.com/ZengLingYong/Blog/issues/30 面试题：“call/apply/bind源码实现”，事实上是对 JavaScript 基础知识的一个综合考核。 相关知识点： 作用域； this 指向； 函数柯里化； 原型与原型链； 思路初探123456789101112131415161718192021Function.prototype.myCall = function(context) &#123; // 原型中 this 指向的是实例对象，所以这里指向 [Function: bar] console.log(this); // [Function: bar] // 在传入的上下文对象中，创建一个属性，值指向方法 bar context.fn = this; // foo.fn = [Function: bar] // 调用这个方法，此时调用者是 foo，this 指向 foo context.fn(); // 执行后删除它，仅使用一次，避免该属性被其它地方使用（遍历） delete context.fn;&#125;;let foo = &#123; value: 2&#125;;function bar() &#123; console.log(this.value);&#125;// bar 函数的声明等同于：var bar = new Function(&quot;console.log(this.value)&quot;);bar.call(foo); // 2; call 的源码实现初步思路有个大概，剩下的就是完善代码。 12345678910111213141516171819202122232425262728293031323334// ES6 版本Function.prototype.myCall = function(context, ...params) &#123; // ES6 函数 Rest 参数，使其可指定一个对象，接收函数的剩余参数，合成数组 if (typeof context === &apos;object&apos;) &#123; context = context || window; &#125; else &#123; context = Object.create(null); &#125; // 用 Symbol 来作属性 key 值，保持唯一性，避免冲突 let fn = Symbol(); context[fn] = this; // 将参数数组展开，作为多个参数传入 const result = context[fn](...params); // 删除避免永久存在 delete(context[fn]); // 函数可以有返回值 return result;&#125;// 测试var mine = &#123; name: &apos;以乐之名&apos;&#125;var person = &#123; name: &apos;无名氏&apos;, sayHi: function(msg) &#123; console.log(&apos;我的名字：&apos; + this.name + &apos;，&apos;, msg); &#125;&#125;person.sayHi.myCall(mine, &apos;很高兴认识你！&apos;);// 我的名字：以乐之名，很高兴认识你！ 知识点补充： ES6 新的原始数据类型 Symbol，表示独一无二的值; Object.create(null) 创建一个空对象 12345678910// 创建一个空对象的方式// eg.Alet emptyObj = &#123;&#125;;// eg.Blet emptyObj = new Object();// eg.Clet emptyObj = Object.create(null); 使用 Object.create(null) 创建的空对象，不会受到原型链的干扰。原型链终端指向 null，不会有构造函数，也不会有 toString、 hasOwnProperty、valueOf 等属性，这些属性来自 Object.prototype。有原型链基础的伙伴们，应该都知道，所有普通对象的原型链都会指向 Object.prototype。 所以 Object.create(null) 创建的空对象比其它两种方式，更干净，不会有 Object 原型链上的属性。 ES5 版本： 自行处理参数； 自实现 Symobo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// ES5 版本// 模拟Symbolfunction getSymbol(obj) &#123; var uniqAttr = &apos;00&apos; + Math.random(); if (obj.hasOwnProperty(uniqAttr)) &#123; // 如果已存在，则递归自调用函数 arguments.callee(obj); &#125; else &#123; return uniqAttr; &#125;&#125;Function.prototype.myCall = function() &#123; var args = arguments; if (!args.length) return; var context = [].shift.apply(args); context = context || window; var fn = getSymbol(context); context[fn] = this; // 无其它参数传入 if (!arguments.length) &#123; return context[fn]; &#125; var param = args[i]; // 类型判断，不然 eval 运行会出错 var paramType = typeof param; switch(paramType) &#123; case &apos;string&apos;: param = &apos;&quot;&apos; + param + &apos;&quot;&apos; break; case &apos;object&apos;: param = JSON.stringify(param); break; &#125; fnStr += i == args.length - 1 ? param : param + &apos;,&apos;; // 借助 eval 执行 var result = eval(fnStr); delete context[fn]; return result;&#125;// 测试var mine = &#123; name: &apos;以乐之名&apos;&#125;var person = &#123; name: &apos;无名氏&apos;, sayHi: function(msg) &#123; console.log(&apos;我的名字：&apos; + this.name + &apos;，&apos;, msg); &#125;&#125;person.sayHi.myCall(mine, &apos;很高兴认识你！&apos;);// 我的名字：以乐之名，很高兴认识！ apply 的源码实现call 的源码实现，那么 apply 就简单，两者只是传递参数方式不同而已。 1234567891011121314Function.prototype.myApply = function(context, params) &#123; // apply 与 call 的区别，第二个参数是数组，且不会有第三个参数 if (typeof context === &apos;object&apos;) &#123; context = context || window; &#125; else &#123; context = Object.create(null); &#125; let fn = Symbol(); context[fn] = this; const result context[fn](...params); delete context[fn]; return result;&#125; bind 的源码实现 bind 与 call/apply 的区别就是返回的是一个待执行的函数，而不是函数的执行结果; bind 返回的函数作为构造函数与 new 一起使用，绑定的 this 需要被忽略; 调用绑定函数时作为this参数传递给目标函数的值。如果使用new运算符构造绑定函数，则忽略该值。—— MDN 123456789101112131415Function.prototype.bind = function(context, ...initArgs) &#123; // bind 调用的方法一定要是一个函数 if (typeof this !== &apos;function&apos;) &#123; throw new TypeError(&apos;not a function&apos;); &#125; let self = this; let F = function() &#123;&#125;; F.prototype = this.prototype; let bound = function(...finnalyArgs) &#123; // 将前后参数合并传入 return self.call(this instanceof F ? this : context || this, ...initArgs, ...finnalyArgs); &#125; bound.prototype = new F(); return bound;&#125; 不少伙伴还会遇到这样的追问，不使用 call/apply，如何实现 bind ？ 骚年先别慌，不用 call/apply，不就是相当于把 call/apply 换成对应的自我实现方法，算是偷懒取个巧吧。 本篇 call/apply/bind 源码实现，算是对之前文章系列知识点的一次加深巩固。 “心中有码，前路莫慌。” 参考文档： MDN - Function.prototype.bind() 不用call和apply方法模拟实现ES5的bind方法 参考链接 JS中switch方法JavaScript switch 语句是一种根据不同条件在代码中做出决策的方法。它比使用 if-else 语句更有条理、更简洁。switch 语句通过计算给定的表达式（可以是变量或值），并将其与几种可能的情况进行比较。如果表达式的值与其中一种情况匹配，则执行关联的代码块（一组指令）。如果未找到匹配项，则可以执行可选的默认情况作为后备，这意味着它会在其他情况都不适用时运行。 通过掌握 switch 语句，我们可以编写更干净、更高效、组织更好的 JavaScript 代码，最终提高我们的整体编程技能。 switch 基础介绍switch 语句以关键字 switch 开头，后跟括号中的表达式。该表达式与包含在 switch 块中的一系列 case 标签进行比较。每个 case 标签代表一个不同的值，当表达式与 case 标签的值匹配时，执行 case 后面的代码块。语句break通常用于在执行匹配的 case 后退出 switch 块，确保仅运行预期的代码块，并防止跳到下一个 case。同时还可以包含默认情况，以便在没有任何情况标签与表达式匹配时提供后备操作，从而确保对未知值的响应。 使用语法： 12345678910switch(expression) &#123; case &#123;value1&#125;: // 要执行的代码 break case &#123;value2&#125;: // 要执行的代码 break default: // 默认情况&#125; case判断条件，case的条件相当于===，即全等条件下才成立。 default当没有其他情况与提供的表达式匹配时，将执行 switch 语句中的默认情况。它可以作为处理意外或未知值的后备措施，确保即使没有匹配的情况也能提供响应。 breakbreak关键字用在 switch 语句中，一旦找到并执行匹配的 case 就退出 switch 块。它阻止代码继续执行剩余的情况，确保只生成正确的输出。 一个 case 在 switch 语句中不能有多个条件。要在一种情况下合并多个条件，可以在case中省略break，从而允许代码执行继续到下一个 case，直到遇到下一个break或到达 switch 块的末尾。当多个条件共享相同的输出或操作时，这可能很有用。 1234567891011switch (day) &#123; case &quot;Monday&quot;: case &quot;Tuesday&quot;: case &quot;Wednesday&quot;: case &quot;Thursday&quot;: case &quot;Friday&quot;: console.log(&quot;工作日&quot;); break; default: console.log(&quot;周末&quot;);&#125; switch 与 if-else当需要处理多个条件时，switch 语句是使用 if-else 语句的替代方法。虽然 if-else 语句适合检查一系列可以表示为 true 或 false 的条件，但 switch 语句在处理可以采用多个不同值的单个表达式时更有效。从本质上讲，当我们有多个相关条件需要管理时，switch 语句可以使我们的代码更干净、更有组织性并且更易于阅读。 例如，以下是一个 if-else 结构的例子： 123456789if (color === &quot;red&quot;) &#123; console.log(&quot;The color is red&quot;);&#125; else if (color === &quot;blue&quot;) &#123; console.log(&quot;The color is blue&quot;);&#125; else if (color === &quot;green&quot;) &#123; console.log(&quot;The color is green&quot;);&#125; else &#123; console.log(&quot;Unknown color&quot;);&#125; 使用switch语法： 12345678910111213switch (color) &#123; case &quot;red&quot;: console.log(&quot;The color is red&quot;); break; case &quot;blue&quot;: console.log(&quot;The color is blue&quot;); break; case &quot;green&quot;: console.log(&quot;The color is green&quot;); break; default: console.log(&quot;Unknown color&quot;);&#125; 在处理大量条件的情况下，switch 语句提供了一种更有组织性和可读性的方式来处理多个条件。在 switch 语句中，括号内的变量或值（在本例中为变量color）是需要计算的表达式。 什么时候使用switch 大量单变量条件：当需要处理大量条件时，switch 语句通常比 if-else 链更有组织性且更易于阅读。 单变量评估：如果我们的条件是基于具有多个不同值的单个变量或表达式，则 switch 语句可以提供比 if-else 模式更高效、更清晰的结构。 更快的代码执行速度：在某些情况下，JavaScript 引擎可以优化 switch 语句，与一系列 if-else 语句相比，可以实现更快的代码执行速度。 更容易维护： switch 语句可以使添加、删除或修改条件变得更加容易，因为每个条件在 switch 块中都是独立的。相反，当需要更改时，if-else 链可能需要更广泛的修改。 默认回退： switch 语句提供可选的默认情况，当其他情况都不与给定表达式匹配时可以执行该默认情况。此功能允许以一种干净的方式处理意外或未知值。 什么时候使用if-else 复杂条件：如果我们的条件涉及复杂逻辑、多个变量或关系和逻辑运算符，则 if-else 模式提供了更大的灵活性，并且比 switch 语句更适合这些情况。 基于范围的条件：当我们需要检查一系列非离散值或条件时，if-else 模式提供了更好的解决方案，因为 switch 语句是为比较离散值而设计的。 条件数量少：如果只有几个简单的条件需要检查，则使用 if-else 模式比 switch 语句更直接、更容易编写。非常量： switch 语句需要 case 标签为常量值，这意味着它们不能是在运行时更改的表达式。如果我们需要判断非常量值的条件，则 if-else 模式是合适的选择。 判断true或false值：当我们需要检查值是真值还是假值时，If-else 模式适用。switch 语句不是为这种类型的评估而设计的，并且需要更详细的代码才能完成相同的结果。 提前退出条件：如果我们有提前退出条件，一旦满足特定条件就不需要进一步判断，则 if-else 模式可能会更有效。使用 switch 语句，即使发现早期匹配，也会判断所有情况（除非我们使用了break语句）。 常见问题1.多个case执行（忘记使用该break语句）使用 switch 语句时的一个常见错误是在每个 case 后面都没有包含break语句。此错误会导致执行所有的case. 2.不正确的比较值和类型switch 语句使用严格比较，这在比较不同数据类型时可能会导致意外结果。在下面的示例中，字符串”2”不等于数字2。 123456789const num = &apos;2&apos;;switch (num) &#123; case 2: console.log(2); break; default: console.log(&apos;不是数字2&apos;);&#125;// 输出 不是数字2 3.范围界定问题switch 语句中的一个常见错误是声明了没有块作用域或不正确作用域的变量，导致它们在其他情况下可以访问，或者产生语法错误。 范围界定问题switch 语句中的一个常见错误是声明了没有块作用域或不正确作用域的变量，导致它们在其他情况下可以访问，或者产生语法错误。 switch一般写法不过本文的主角是 switch。大家都了解 switch 的写法一般来说是 switch 变量或表达式，case 常量。嗯，比如说，一个百分制成绩，90 及 90 分以上算优秀，80 及以上 90 以下算良好，60 及以上 80 以下算合格，60 以下为不合格，用 switch 大概会这么写： 12345678910111213function calcGrade(score) &#123; const line = score / 10 | 0; switch (line) &#123; case 10: case 9: return &quot;优秀&quot;; case 8: return &quot;良好&quot;; case 7: case 6: return &quot;合格&quot;; default: return &quot;不合格&quot;; &#125;&#125; 代码中 score / 10 | 0 和 Math.floor(score / 10) 是一样的效果，就是除以 10 取商的整数部分。 这段 switch 用得中规中矩，用取整的办法来避免使用一长串 if … else 分支也算是取了巧。 但是现在规则改了，将合格和良好的分隔点从 80 分降到 75 分，该怎么办？ 按上面取整的办法依然可以，不过这次除数不再是 10，而是 5。相应地，case 也多了很多： 18、19、20 是优秀 15、16、17 是良好 12、13、14 是合格 剩下的是不合格 写 9 个 case，真不如用 if … else 算了。 switch简单写法是吗？其实用 switch 也有简单一些的写法： 123456789101112function calcGrade(score) &#123; switch (true) &#123; case score &gt;= 90: return &quot;优秀&quot;; case score &gt;= 75: return &quot;良好&quot;; case score &gt;= 60: return &quot;合格&quot;; default: return &quot;不合格&quot;; &#125;&#125; 是不是感觉有些奇怪？这完全不是习惯了的 switch 表达式 case 常量，而是正好相反，switch 常量 case 表达式！如果你拿这段程序去跑一下，会发现一点问题都没有。因为——switch 和 case 是按 === 来匹配的，它并不在乎是表达式还是常量，或者说，switch 和 case 后面都可以接表达式！ 个税计算12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 var income = 10000; // 税前月薪 var personSocialRatio = 0.105; // 个人社保比例 var personFundRatio = 0.12; // 个人公积金比例 var tax = 0 // 个税 // 首次加载 init() // 初始化 function init() &#123; taxCompute() console.log(&apos;个税&apos;, tax); &#125;/* 个税计算方法，先判断年收入等级：x =（【含税月收入】-个人月公积金 - 个人月社保）* 12 ①x &lt; 36000 个税 =（【含税月收入】-个人月社保 - 个人月公积金 - 5000）* 12 * 3 % ②36000 &lt; x &lt; 144000 个税 =（【含税月收入】-个人月社保 - 个人月公积金 - 5000）* 12 * 10 % -2520 ③144000 &lt; x &lt; 300000 个税 =（【含税月收入】-个人月社保 - 个人月公积金 - 5000）* 12 * 20 % -16920 ④300000 &lt; x &lt; 420000 个税 =（【含税月收入】-个人月社保 - 个人月公积金 - 5000）* 12 * 25 % -31920 ⑤420000 &lt; x &lt; 660000 个税 =（【含税月收入】-个人月社保 - 个人月公积金 - 5000）* 12 * 30 % -52920 ⑥660000 &lt; x &lt; 960000 个税 =（【含税月收入】-个人月社保 - 个人月公积金 - 5000）* 12 * 35 % -85920 ⑥x &gt; 960000 个税 =（【含税月收入】-个人月社保 - 个人月公积金 - 5000）* 12 * 45 % -181920 */ function taxCompute(list) &#123; // 月收入 var month = income * (1 - personSocialRatio - personFundRatio) // 年收入 var x = month * 12 console.log(month, x); switch (true) &#123; case x &gt; 960000: console.log(7); tax = (month - 5000) * 12 * 0.45 - 181920 break; case x &gt; 660000: console.log(6); tax = (month - 5000) * 12 * 0.35 - 85920 break; case x &gt; 420000: console.log(5); tax = (month - 5000) * 12 * 0.30 - 52920 break; case x &gt; 300000: console.log(4); tax = (month - 5000) * 12 * 0.25 - 31920 break; case x &gt; 144000: console.log(3); tax = (month - 5000) * 12 * 0.20 - 16920 break; case x &gt; 36000: console.log(2); tax = (month - 5000) * 12 * 0.1 - 2520 break; case x &gt; 0: console.log(1); tax = (month - 5000) * 12 * 0.03 break; default: break; &#125; &#125;","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qw8.github.io/tags/JavaScript/"},{"name":"函数","slug":"函数","permalink":"https://qw8.github.io/tags/函数/"}]},{"title":"JavaScript类、对象和继承","slug":"knowledges/JavaScript类、对象和继承","date":"2020-03-25T13:10:40.000Z","updated":"2024-04-03T16:51:58.000Z","comments":true,"path":"/knowledges/javascript-lei-dui-xiang-he-ji-cheng.html","link":"","permalink":"https://qw8.github.io/knowledges/javascript-lei-dui-xiang-he-ji-cheng.html","excerpt":"","text":"Javascript如何实现继承？继承的本质就是原型链。（这些问题必问的，其实就是考察你对原型链的掌握程度。） 构造函数绑定：使用 call 或 apply 方法，将父对象的构造函数绑定在子对象上 12345function Cat(name,color)&#123; Animal.apply(this, arguments); this.name = name; this.color = color;&#125; 实例继承：将子对象的 prototype 指向父对象的一个实例 12Cat.prototype = new Animal();Cat.prototype.constructor = Cat; 拷贝继承：如果把父对象的所有属性和方法，拷贝进子对象 12345678function extend(Child, Parent) &#123; var p = Parent.prototype; var c = Child.prototype; for (var i in p) &#123; c[i] = p[i]; &#125; c.uber = p; &#125; 原型继承：将子对象的 prototype 指向父对象的 prototype 1234567function extend(Child, Parent) &#123; var F = function()&#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child; Child.uber = Parent.prototype;&#125; ES6 语法糖 extends：class ColorPoint extends Point {} 123456789class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y) this.color = color; &#125; toString() &#123; return this.color + ' ' + super.toString(); // 调用父类的toString() &#125;&#125; 原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式 12345678910111213function Parent()&#123; this.name = &apos;wang&apos;; &#125; function Child()&#123; this.age = 28; &#125; Child.prototype = new Parent();//继承了Parent，通过原型 var demo = new Child(); alert(demo.age); alert(demo.name);//得到被继承的属性 &#125; 类和继承（es5实现方法 + es6实现方法）继承机制 ES6创建类的基本语法和继承实现原理 ES5和ES6中对于继承的实现方法 JavaScript 继承方式和优缺点原型链继承1234567891011121314151617function Parent () &#123; this.name = 'kevin';&#125;Parent.prototype.getName = function () &#123; console.log(this.name);&#125;function Child () &#123;&#125;Child.prototype = new Parent();var child1 = new Child();console.log(child1.getName()) // kevin 缺点： 1.引用类型的属性被所有实例共享，举个例子： 12345678910111213141516171819function Parent () &#123; this.names = ['kevin', 'daisy'];&#125;function Child () &#123;&#125;Child.prototype = new Parent();var child1 = new Child();child1.names.push('yayu');console.log(child1.names); // [\"kevin\", \"daisy\", \"yayu\"]var child2 = new Child();console.log(child2.names); // [\"kevin\", \"daisy\", \"yayu\"] 2.在创建 Child 的实例时，不能向Parent传参 3.字面量重写原型会中断关系，使用引用类型的原型 借用构造函数(经典继承)1234567891011121314151617function Parent () &#123; this.names = ['kevin', 'daisy'];&#125;function Child () &#123; Parent.call(this);&#125;var child1 = new Child();child1.names.push('yayu');console.log(child1.names); // [\"kevin\", \"daisy\", \"yayu\"]var child2 = new Child();console.log(child2.names); // [\"kevin\", \"daisy\"] 优点： 1.避免了引用类型的属性被所有实例共享 2.可以在 Child 中向 Parent 传参 举个例子： 123456789101112131415function Parent (name) &#123; this.name = name;&#125;function Child (name) &#123; Parent.call(this, name);&#125;var child1 = new Child('kevin');console.log(child1.name); // kevinvar child2 = new Child('daisy');console.log(child2.name); // daisy 缺点： 方法都在构造函数中定义，每次创建实例都会创建一遍方法。 没有原型，则复用无从谈起。 组合继承原型链继承和经典继承双剑合璧。 1234567891011121314151617181920212223242526272829303132function Parent (name) &#123; this.name = name; this.colors = ['red', 'blue', 'green'];&#125;Parent.prototype.getName = function () &#123; console.log(this.name)&#125;function Child (name, age) &#123; Parent.call(this, name); this.age = age;&#125;Child.prototype = new Parent();var child1 = new Child('kevin', '18');child1.colors.push('black');console.log(child1.name); // kevinconsole.log(child1.age); // 18console.log(child1.colors); // [\"red\", \"blue\", \"green\", \"black\"]var child2 = new Child('daisy', '20');console.log(child2.name); // daisyconsole.log(child2.age); // 20console.log(child2.colors); // [\"red\", \"blue\", \"green\"] 优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。 其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。 原型式继承12345function createObj(o) &#123; function F()&#123;&#125; F.prototype = o; return new F();&#125; 就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。 缺点： 包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。 12345678910111213var person = &#123; name: 'kevin', friends: ['daisy', 'kelly']&#125;var person1 = createObj(person);var person2 = createObj(person);person1.name = 'person1';console.log(person2.name); // kevinperson1.firends.push('taylor');console.log(person2.friends); // [\"daisy\", \"kelly\", \"taylor\"] 注意：修改person1.name的值，person2.name的值并未发生改变，并不是因为person1和person2有独立的 name 值，而是因为person1.name = &#39;person1&#39;，给person1添加了 name 值，并非修改了原型上的 name 值。 寄生式继承创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。 1234567function createObj (o) &#123; var clone = object.create(o); clone.sayName = function () &#123; console.log('hi'); &#125; return clone;&#125; 缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。 寄生组合式继承为了方便大家阅读，在这里重复一下组合继承的代码： 12345678910111213141516171819function Parent (name) &#123; this.name = name; this.colors = ['red', 'blue', 'green'];&#125;Parent.prototype.getName = function () &#123; console.log(this.name)&#125;function Child (name, age) &#123; Parent.call(this, name); this.age = age;&#125;Child.prototype = new Parent();var child1 = new Child('kevin', '18');console.log(child1) 组合继承最大的缺点是会调用两次父构造函数。 一次是设置子类型实例的原型的时候： 1Child.prototype = new Parent(); 一次在创建子类型实例的时候： 1var child1 = new Child('kevin', '18'); 回想下 new 的模拟实现，其实在这句中，我们会执行： 1Parent.call(this, name); 在这里，我们又会调用了一次 Parent 构造函数。 所以，在这个例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为colors，属性值为[&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;]。 那么我们该如何精益求精，避免这一次重复调用呢？ 如果我们不使用 Child.prototype = new Parent() ，而是间接的让 Child.prototype 访问到 Parent.prototype 呢？ 看看如何实现： 12345678910111213141516171819202122232425function Parent (name) &#123; this.name = name; this.colors = ['red', 'blue', 'green'];&#125;Parent.prototype.getName = function () &#123; console.log(this.name)&#125;function Child (name, age) &#123; Parent.call(this, name); this.age = age;&#125;// 关键的三步var F = function () &#123;&#125;;F.prototype = Parent.prototype;Child.prototype = new F();var child1 = new Child('kevin', '18');console.log(child1); 最后我们封装一下这个继承方法： 1234567891011121314function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;function prototype(child, parent) &#123; var prototype = object(parent.prototype); prototype.constructor = child; child.prototype = prototype;&#125;// 当我们使用的时候：prototype(Child, Parent); 优点：引用《JavaScript高级程序设计》中对寄生组合式继承的夸赞就是： 1.这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。 2.与此同时，原型链还能保持不变； 3.因此，还能够正常使用 instanceof 和 isPrototypeOf。 开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。 如何避免原型链上面的对象共享避免对象共享可以参考经典的 extend()函数，很多前端框架都有封装的，就是用一个空函数当做中间变量 javascript 中 this 的指向问题 全局环境、普通函数（非严格模式）指向 window 普通函数（严格模式）指向 undefined 函数作为对象方法及原型链指向的就是上一级的对象 构造函数指向构造的对象 DOM 事件中指向触发事件的元素 箭头函数… 1、全局环境全局环境下，this 始终指向全局对象（window），无论是否严格模式； 12345// 在浏览器中，全局对象为 window 对象：console.log(this === window); // truethis.a = 37;console.log(window.a); // 37 2、函数上下文调用2.1 普通函数 普通函数内部的 this 分两种情况，严格模式和非严格模式。 （1）非严格模式下，没有被上一级的对象所调用,this 默认指向全局对象 window。 1234function f1() &#123; return this;&#125;f1() === window; // true （2）严格模式下，this 指向 undefined。 12345function f2() &#123; \"use strict\"; // 这里是严格模式 return this;&#125;f2() === undefined; // true 2.2 函数作为对象的方法 （1）函数有被上一级的对象所调用，那么 this 指向的就是上一级的对象。 （2）多层嵌套的对象，内部方法的 this 指向离被调用函数最近的对象（window 也是对象，其内部对象调用方法的 this 指向内部对象， 而非 window）。 1234567891011121314151617181920212223//方式1var o = &#123; prop: 37, f: function() &#123; return this.prop; &#125;&#125;;//当 o.f()被调用时，函数内的this将绑定到o对象。console.log(o.f()); // logs 37//方式2var o = &#123; prop: 37 &#125;;function independent() &#123; return this.prop;&#125;//函数f作为o的成员方法调用o.f = independent;console.log(o.f()); // logs 37//方式3//this 的绑定只受最靠近的成员引用的影响o.b = &#123; g: independent, prop: 42 &#125;;console.log(o.b.g()); // 42 特殊例子 1234567891011121314151617181920212223242526// 例子1var o = &#123; a: 10, b: &#123; // a:12, fn: function() &#123; console.log(this.a); //undefined console.log(this); //&#123;fn: ƒ&#125; &#125; &#125;&#125;;o.b.fn();// 例子2var o = &#123; a: 10, b: &#123; a: 12, fn: function() &#123; console.log(this.a); //undefined console.log(this); //window &#125; &#125;&#125;;var j = o.b.fn;j();// this永远指向的是最后调用它的对象，也就是看它执行的时候是谁调用的，例子2中虽然函数fn是被对象b所引用，但是在将fn赋值给变量j的时候并没有执行所以最终指向的是window，这和例子1是不一样的，例子1是直接执行了fn 2.3 原型链中的 this （1）如果该方法存在于一个对象的原型链上，那么 this 指向的是调用这个方法的对象，就像该方法在对象上一样。 12345678910var o = &#123; f: function() &#123; return this.a + this.b; &#125;&#125;;var p = Object.create(o);p.a = 1;p.b = 4;console.log(p.f()); // 5 上述例子中，对象 p 没有属于它自己的 f 属性，它的 f 属性继承自它的原型。当执行 p.f()时，会查找 p 的原型链，找到 f 函数并执行。因为 f 是作为 p 的方法调用的，所以函数中的 this 指向 p。 （2）相同的概念也适用于当函数在一个 getter 或者 setter 中被调用。用作 getter 或 setter 的函数都会把 this 绑定到设置或获取属性的对象。 （3）call()和 apply()方法：当函数通过 Function 对象的原型中继承的方法 call() 和 apply() 方法调用时， 其函数内部的 this 值可绑定到 call() &amp; apply() 方法指定的第一个对象上， 如果第一个参数不是对象，JavaScript 内部会尝试将其转换成对象然后指向它。 1234567891011121314function add(c, d) &#123; return this.a + this.b + c + d;&#125;var o = &#123; a: 1, b: 3 &#125;;add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34function tt() &#123; console.log(this);&#125;// 第一个参数不是对象，JavaScript内部会尝试将其转换成对象然后指向它。tt.call(5); // 内部转成 Number &#123;[[PrimitiveValue]]: 5&#125;tt.call(\"asd\"); // 内部转成 String &#123;0: \"a\", 1: \"s\", 2: \"d\", length: 3, [[PrimitiveValue]]: \"asd\"&#125; （4）bind()方法：由 ES5 引入， 在 Function 的原型链上， Function.prototype.bind。通过 bind 方法绑定后， 函数将被永远绑定在其第一个参数对象上， 而无论其在什么情况下被调用。 123456789function f() &#123; return this.a;&#125;var g = f.bind(&#123; a: \"azerty\" &#125;);console.log(g()); // azertyvar o = &#123; a: 37, f: f, g: g &#125;;console.log(o.f(), o.g()); // 37, azerty 2.4 构造函数中的 this 当一个函数用作构造函数时（使用 new 关键字），它的 this 被绑定到正在构造的新对象。 构造器返回的默认值是 this 所指的那个对象，也可以手动返回其他的对象。 123456789101112131415function C() &#123; this.a = 37;&#125;var o = new C();console.log(o.a); // 37// 为什么this会指向o？首先new关键字会创建一个空的对象，然后会自动调用一个函数apply方法，将this指向这个空对象，这样的话函数内部的this就会被这个空的对象替代。function C2() &#123; this.a = 37; return &#123; a: 38 &#125;; // 手动设置返回&#123;a:38&#125;对象&#125;o = new C2();console.log(o.a); // 38 特殊例子 当 this 碰到 return 时 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 例子1function fn() &#123; this.user = \"追梦子\"; return &#123;&#125;;&#125;var a = new fn();console.log(a.user); //undefined// 例子2function fn() &#123; this.user = \"追梦子\"; return function() &#123;&#125;;&#125;var a = new fn();console.log(a.user); //undefined// 例子3function fn() &#123; this.user = \"追梦子\"; return 1;&#125;var a = new fn();console.log(a.user); //追梦子// 例子4function fn() &#123; this.user = \"追梦子\"; return undefined;&#125;var a = new fn();console.log(a.user); //追梦子// 例子5function fn() &#123; this.user = \"追梦子\"; return undefined;&#125;var a = new fn();console.log(a); //fn &#123;user: \"追梦子\"&#125;// 例子6// 虽然null也是对象，但是在这里this还是指向那个函数的实例，因为null比较特殊function fn() &#123; this.user = \"追梦子\"; return null;&#125;var a = new fn();console.log(a.user); //追梦子// 总结：如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。 2.5 setTimeout &amp; setInterval （1）对于延时函数内部的回调函数的 this 指向全局对象 window； （2）可以通过 bind()方法改变内部函数 this 指向。 1234567891011121314151617181920//默认情况下代码function Person() &#123; this.age = 0; setTimeout(function() &#123; console.log(this); &#125;, 3000);&#125;var p = new Person(); //3秒后返回 window 对象//通过bind绑定function Person() &#123; this.age = 0; setTimeout( function() &#123; console.log(this); &#125;.bind(this), 3000 );&#125;var p = new Person(); //3秒后返回构造函数新生成的对象 Person&#123;...&#125; 3、在 DOM 事件中3.1 作为一个 DOM 事件处理函数 当函数被用作事件处理函数时，它的 this 指向触发事件的元素（针对 addEventListener 事件）。 12345678910111213141516// 被调用时，将关联的元素变成蓝色function bluify(e) &#123; //this指向所点击元素 console.log(\"this === e.currentTarget\", this === e.currentTarget); // 总是 true // 当 currentTarget 和 target 是同一个对象时为 true console.log(\"this === e.target\", this === e.target); this.style.backgroundColor = \"#A5D9F3\";&#125;// 获取文档中的所有元素的列表var elements = document.getElementsByTagName(\"*\");// 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色for (var i = 0; i &lt; elements.length; i++) &#123; elements[i].addEventListener(\"click\", bluify, false);&#125; 3.2 作为一个内联事件处理函数 （1）当代码被内联处理函数调用时，它的 this 指向监听器所在的 DOM 元素； （2）当代码被包括在函数内部执行时，其 this 指向等同于 普通函数直接调用的情况，即在非严格模式指向全局对象 window，在严格模式指向 undefined： 12345&lt;button onclick=\"console.log(this)\"&gt;show me&lt;/button&gt;&lt;button onclick=\"(function () &#123;console.log(this)&#125;)()\"&gt;show inner this&lt;/button&gt;&lt;button onclick=\"(function () &#123;'use strict'; console.log(this)&#125;)()\"&gt; use strict&lt;/button&gt; 1234// 控制台打印&lt;button onclick=&quot;console.log(this)&quot;&gt;show me&lt;/button&gt;Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …&#125;undefined 4.1 全局环境中在全局代码中，箭头函数被设置为全局对象： 123var globalObject = this;var foo = () =&gt; this;console.log(foo() === globalObject); // true 4.2 this 捕获上下文 箭头函数没有自己的 this，而是使用箭头函数所在的作用域的 this，即指向箭头函数定义时（而不是运行时）所在的作用域。 123456789101112131415161718//1、箭头函数在函数内部，以非方法的方法使用function Person() &#123; this.age = 0; setInterval(() =&gt; &#123; this.age++; &#125;, 3000);&#125;var p = new Person(); //Person&#123;age: 0&#125;//普通函数作为内部函数function Person() &#123; this.age = 0; setInterval(function() &#123; console.log(this); this.age++; &#125;, 3000);&#125;var p = new Person(); //Window&#123;...&#125; 4.2 this 捕获上下文 箭头函数没有自己的 this，而是使用箭头函数所在的作用域的 this，即指向箭头函数定义时（而不是运行时）所在的作用域。 12345678910111213141516171819//1、箭头函数在函数内部，以非方法的方法使用function Person() &#123; this.age = 0; setInterval(() =&gt; &#123; console.log(this); this.age++; &#125;, 3000);&#125;var p = new Person(); //Person&#123;age: 0&#125;//普通函数作为内部函数function Person() &#123; this.age = 0; setInterval(function() &#123; console.log(this); this.age++; &#125;, 3000);&#125;var p = new Person(); //Window&#123;...&#125; 在 setTimeout 中的 this 指向了构造函数新生成的对象，而普通函数指向了全局 window 对象。 4.3 箭头函数作为对象的方法使用 箭头函数作为对象的方法使用，指向全局 window 对象；而普通函数作为对象的方法使用，则指向调用的对象。 123456789var obj = &#123; i: 10, b: () =&gt; console.log(this.i, this), c: function() &#123; console.log(this.i, this); &#125;&#125;;obj.b(); // undefined window&#123;...&#125;obj.c(); // 10 Object &#123;...&#125; 4.4 箭头函数中，call()、apply()、bind()方法无效 12345678910111213141516171819202122232425262728var adder = &#123; base: 1, //对象的方法内部定义箭头函数，this是箭头函数所在的作用域的this， //而方法add的this指向adder对象，所以箭头函数的this也指向adder对象。 add: function(a) &#123; var f = v =&gt; v + this.base; return f(a); &#125;, //普通函数f1的this指向window add1: function() &#123; var f1 = function() &#123; console.log(this); &#125;; return f1(); &#125;, addThruCall: function inFun(a) &#123; var f = v =&gt; v + this.base; var b = &#123; base: 2 &#125;; return f.call(b, a); &#125;&#125;;console.log(adder.add(1)); // 输出 2adder.add1(); //输出全局对象 window&#123;...&#125;console.log(adder.addThruCall(1)); // 仍然输出 2（而不是3，其内部的this并没有因为call() 而改变，其this值仍然为函数inFun的this值，指向对象adder 4.5 this 指向固定化 箭头函数可以让 this 指向固定化，这种特性很有利于封装回调函数 123456789101112131415var handler = &#123; id: \"123456\", init: function() &#123; document.addEventListener( \"click\", event =&gt; this.doSomething(event.type), false ); &#125;, doSomething: function(type) &#123; console.log(\"Handling \" + type + \" for \" + this.id); &#125;&#125;; 上面代码的 init 方法中，使用了箭头函数，这导致这个箭头函数里面的 this，总是指向 handler 对象。如果不使用箭头函数则指向全局 document 对象。 4.6 箭头函数不适用场景 （1）箭头函数不适合定义对象的方法（方法内有 this），因为此时指向 window； （2）需要动态 this 的时候，也不应使用箭头函数。 12345678910111213//例1，this指向定义箭头函数所在的作用域，它位于对象cat内，但cat不能构成一个作用域，所以指向全局window，改成普通函数后this指向cat对象。const cat = &#123; lives: 9, jumps: () =&gt; &#123; this.lives--; &#125;&#125;;//例2，此时this也是指向window，不能动态监听button，改成普通函数后this指向按钮对象。var button = document.getElementById(\"press\");button.addEventListener(\"click\", () =&gt; &#123; this.classList.toggle(\"on\");&#125;);","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qw8.github.io/tags/JavaScript/"},{"name":"继承","slug":"继承","permalink":"https://qw8.github.io/tags/继承/"}]},{"title":"JavaScript事件","slug":"knowledges/JavaScript事件","date":"2020-03-07T13:10:40.000Z","updated":"2024-03-31T12:16:14.000Z","comments":true,"path":"/knowledges/javascript-shi-jian.html","link":"","permalink":"https://qw8.github.io/knowledges/javascript-shi-jian.html","excerpt":"","text":"简介 JS和HTML之间的交互是通过事件实现的。事件，就是文档或浏览器窗口中发生的一些特定的交互瞬间。可以使用侦听器（或处理程序）来预定事件，以便事件发生时执行相应的代码，这种在传统工程中被称为观察员模式的模型，支持页面的行为（JS）与页面（CSSHTML）之间的松散耦合 IE8是最后一个仍然使用其专有事件系统的主要浏览器 事件流事件流描述的是从而绵中接收事件的顺序，但是IE与Netscape开发团队提出的是差不多完全相反的事件流概念，IE事件流是冒泡，而NC事件流是捕获 冒泡 IE的事件流叫做事件冒泡，即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档） IE5.5及更早版本冒泡会跳过html元素（从body直接跳到docuemnt）IE9+别的浏览器则将事件一直冒泡到window对象 捕获 NC定义，事件捕获的思想是不太具体的节点应该更糟接收到事件，而最具体的节点英爱最后接收到事件，事件捕获的用意在于在事件打到预定目标之前捕获它 IE9+ 部分老浏览器从window开始 规范要求从docuemnt对象开始 DOM事件流 dom2级事件规定的事件流包括三个阶段： 事件捕获阶段、处于目标阶段和事件冒泡阶段 首先发生的是事件捕获，为截获事件提供了机会 然后是实际的目标接收到事件 最后是冒泡阶段，可以再找个阶段对事件做出响应 在DOM事件流中，实际的目标（div元素）在捕获阶段不会接收到事件，这意味着在捕获阶段，事件从document到html再到body后就停止了 下一个阶段是处于目标阶段，于是事件在div上发生，并在事件处理中被看成冒泡阶段的一部分，然后，冒泡阶段发生，事件有传播回文档 即时DOM2级事件规范名曲要求捕获阶段不会涉及事件目标，但IE9等更高版本浏览器都会在捕获阶段触发事件对象上的事件 IE8及更早版本不支持事件流 事件冒泡与事件捕获事件冒泡：由最具体的元素（目标元素）向外传播到最不具体的元素 事件捕获：由最不确定的元素到目标元素 事件绑定的方式 嵌入 dom 1&lt;button onclick=\"func()\"&gt;按钮&lt;/button&gt; 直接绑定 1btn.onclick = function() &#123;&#125;; 事件监听 1btn.addEventListener(\"click\", function() &#123;&#125;); 事件委托是什么利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行！ 解析： 1、那什么样的事件可以用事件委托，什么样的事件不可以用呢？ 适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。 值得注意的是，mouseover 和 mouseout 虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。 不适合的就有很多了，举个例子，mousemove，每次都要计算它的位置，非常不好把控，在不如说 focus，blur 之类的，本身就没用冒泡的特性，自然就不用事件委托了。 2、为什么要用事件委托 提高性能 1234567891011121314151617181920&lt;ul&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;凤梨&lt;/li&gt;&lt;/ul&gt;// gooddocument.querySelector(&apos;ul&apos;).onclick = (event) =&gt; &#123; let target = event.target if (target.nodeName === &apos;LI&apos;) &#123; console.log(target.innerHTML) &#125;&#125;// baddocument.querySelectorAll(&apos;li&apos;).forEach((e) =&gt; &#123; e.onclick = function() &#123; console.log(this.innerHTML) &#125;&#125;) 新添加的元素还会有之前的事件。 3、事件冒泡与事件委托的对比 事件冒泡：box 内部无论是什么元素，点击后都会触发 box 的点击事件 事件委托：可以对 box 内部的元素进行筛选 4、事件委托怎么取索引？ 1234567891011121314151617181920212223&lt;ul id=\"ul\"&gt; &lt;li&gt;aaaaaaaa&lt;/li&gt; &lt;li&gt;事件委托了 点击当前，如何获取 这个点击的下标&lt;/li&gt; &lt;li&gt;cccccccc&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; window.onload = function () &#123; var oUl = document.getElementById(\"ul\"); var aLi = oUl.getElementsByTagName(\"li\"); oUl.onclick = function (ev) &#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if (target.nodeName.toLowerCase() == \"li\") &#123; var that = target; var index; for (var i = 0; i &lt; aLi.length; i++) if (aLi[i] === target) index = i; if (index &gt;= 0) alert('我的下标是第' + index + '个'); target.style.background = \"red\"; &#125; &#125; &#125;&lt;/script&gt; 拓展： 键盘事件：keydown keypress keyup 鼠标事件：mousedown mouseup mousemove mouseout mouseover 参考 事件绑定与普通事件有什么区别 用普通事件添加相同事件，下面会覆盖上面的，而事件绑定不会 普通事件是针对非 dom 元素，事件绑定是针对 dom 元素的事件 IE 和 DOM 事件流的区别1.事件流的区别 IE 采用冒泡型事件 Netscape 使用捕获型事件 DOM 使用先捕获后冒泡型事件示例： 复制代码代码如下: 12345&lt;body&gt; &lt;div&gt; &lt;button&gt;点击这里&lt;/button&gt; &lt;/div&gt;&lt;/body&gt; 冒泡型事件模型： button-&gt;div-&gt;body (IE 事件流) 捕获型事件模型： body-&gt;div-&gt;button (Netscape 事件流) DOM 事件模型： body-&gt;div-&gt;button-&gt;button-&gt;div-&gt;body (先捕获后冒泡) 2.事件侦听函数的区别 IE 使用: 12[Object].attachEvent(\"name_of_event_handler\", fnHandler); //绑定函数[Object].detachEvent(\"name_of_event_handler\", fnHandler); //移除绑定 DOM 使用： 12[Object].addEventListener(\"name_of_event\", fnHandler, bCapture); //绑定函数[Object].removeEventListener(\"name_of_event\", fnHandler, bCapture); //移除绑定 bCapture 参数用于设置事件绑定的阶段，true 为捕获阶段，false 为冒泡阶段。 如何阻止事件冒泡和默认事件？阻止浏览器的默认行为window.event?window.event.returnValue=false:e.preventDefault(); 停止事件冒泡window.event?window.event.cancelBubble=true:e.stopPropagation();原生 JavaScript 中，return false;只阻止默认行为，不阻止冒泡，jQuery 中的 return false;既阻止默认行为，又阻止冒泡 事件、IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？ 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为 事件处理机制：IE 是事件冒泡、firefox 同时支持两种事件模型，也就是：捕获型事件和冒泡型事件 ev.stopPropagation();注意旧 ie 的方法：ev.cancelBubble = true; 如何阻止冒泡与默认行为 阻止冒泡行为：非 IE 浏览器 stopPropagation()，IE 浏览器 window.event.cancelBubble = true 阻止默认行为：非 IE 浏览器 preventDefault()，IE 浏览器 window.event.returnValue = false 解析： 当需要阻止冒泡行为时，可以使用 12345678function stopBubble(e) &#123; //如果提供了事件对象，则这是一个非IE浏览器 if (e &amp;&amp; e.stopPropagation) //因此它支持W3C的stopPropagation()方法 e.stopPropagation(); //否则，我们需要使用IE的方式来取消事件冒泡 else window.event.cancelBubble = true;&#125; 当需要阻止默认行为时，可以使用 12345678//阻止浏览器的默认行为function stopDefault(e) &#123; //阻止默认浏览器动作(W3C) if (e &amp;&amp; e.preventDefault) e.preventDefault(); //IE中阻止函数器默认动作的方式 else window.event.returnValue = false; return false;&#125; 事件处理程序事件就是用户或浏览器自身执行的某种操作。而响应某个事件的函数就叫做事件处理程序或事件侦听器。事件处理程序的名字以on开头 HTML事件处理程序 某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的HTML特性来指定。这个特性的值应该是能够执行的JS代码 不能使用未经转移的HTML语法字符串 例如&amp; “” &lt; &gt; 1&lt;input onclick=\"alert(&amp;quot;clicked&amp;quot;)\"&gt; 也可以这样 12345&lt;script type=\"text/javascript\"&gt; function showMessage()&#123; alert(\"Hellow World!\") &#125;&lt;/script&gt; 事件处理程序中的代码在执行时，有权访问全局作用域中的任何代码 这样指定事件处理程序具有一些独到之处，首先，这样会创建一个封装这元素属性值的函数。这个函数中有一个局部变量event也就是事件对象。 12345678910&lt;input type=\"button\" value=\"Click me\" onclick = \"alert(event.type)\" &gt;function()&#123; with(document)&#123; with(this.form)&#123; with(this)&#123; //元素属性值 &#125; &#125; &#125; &#125; 在HTML中之指定事件处理程序由两个缺点。 时差问题。因为用户可能在HTML元素一出现在页面上就触发相应的事件，当当时的事件处理程序可能尚不具备执行条件，因此 很多的HTML事件处理程序都会被封装在一个try-catch块中 这样扩展事件处理程序的作用域链在不同浏览器中会导致不同结果。不同JS引擎遵循的标识符解析规则略有差异，很可能会在访问非限定对象成员时出错 这样抒写过于紧密耦合，如果要更换事件处理程序就要更改两个地方HTML代码和JS代码。这正是开发人员掘弃HTML事件处理程序转而使用JS指定事件处理程序的原因所在。 DOM0级事件处理程序 通过JS指定事件处理程序的传统方式，就是讲一个函数赋值给一个事件处理程序属性。这个中为事件处理程序复制的方法是在第四代Web浏览器中出现的，而且至今冉根为所有现代浏览器所支持。原因1是简单，而是具有跨浏览器的又是。 要使用JS指定事件处理程序，首先要取得一个要操作的UI想的引用 每个元素都有自己的事件处理程序属性，这些属性通常全部小写。将这种属性的值设置为一个函数，就可以指定事件处理程序 这些代码运行以前不会指定事件处理程序，因此如果这些代码在页面中位于按钮后面，就可能在一段时间内怎么点击都没有反应 使用DOM0级方法指定的事件处理程序被认为是元素的方法，因此这时候的事件处理程序是在元素的作用域中运行，换句话说，程序中的this引用当前元素； 1234var btn = document.getElementById(\"myBtn\");btn.onclick = function()&#123; alert(this.id)&#125; 以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理 也可以删除通过DOM0级的方法指定的事件处理程序 1btn.onclick = null 如果你是HTML指定事件处理程序，那么onclick属性的值就是一个包含着在同名HTML特性中指定的代码的函数。而将响应的属性设置为null也可以删除以这种方式指定的事件处理程序 DOM2级事件处理程序 DOM2级事件定义了两个方法，用于处理指定和删除事件处理程序的操作 addEventListener（）和removeEventListener() 所有的DOM节点中都包含这两个方法，并且他们都接受3个参数： 要处理的事件名、 作为事件处理程序的函数 和 一个布尔值，最后的布尔值参数如果是true，表示在捕获阶段调用事件处理程序，如果是false表示在冒泡阶段处理程序 1234var btn = docuemnt.getElementById(\"myBtn\");btn.addEventListener( \"click\", function()&#123; alert(this.id)&#125;, false ) 使用DOM2级的方法可以添加多个事件处理程序 1234567var btn = docuemnt.getElementById(\"myBtn\");btn.addEventListener( \"click\", function()&#123; alert(this.id)&#125;, false )btn.addEventListener(\"click\", function()&#123; alert(\"hello\")&#125;, false) 通过 addEventListener添加的事件只能通过removeEventListener来移除 移除时传入的参数与添加处理程序时使用的参数相同。这也意味着通过addEventListener添加的匿名函数无法移除 12345678var btn = docuemnt.getElementById(\"myBtn\");btn.addEventListener(\"click\", function()&#123; alert(this.id)&#125;, false)// 没有用btn.removeEventListener(\"click\", function()&#123; alert(this.id)&#125;, false) 这个例子则可以 123456var btn = docuemnt.getElementById(\"myBtn\");var handler = function()&#123; alert(this.id)&#125;btn.addEventListener( \"click\", handler, false );btn.removeEventListener( \"click\", handler, false ); 大部分情况下都是将事件处理程序添加到事件流的冒泡阶段，这样可以大限度的兼容各种浏览器。 最好只在需要在事件到达目标之前截获它的时候将事件处理程序天基调捕获阶段，不建议添加到捕获阶段 IE9+ IE事件处理程序 IE实现了与DOM中类似的两个方法： attachEvent()和detechEvent()。 这两个方法接受相同的两个参数： 事件处理程序名称与时间处理程序的函数。 由于IE8-只支持事件冒泡，所以通过attachEvent添加的事件处理程序都会被添加到冒泡阶段 1234var btn = doucment.getElementById(\"myBtn\");btn.attachEvent(\"onclick\", function()&#123; alert(\"clicked\")&#125;) 注意第一个参数是onclick而非DOM的addEventListener方法中的click 在IE中使用attachEvent()与使用DOM0级方法的主要区别在于事件处理程序的作用域。 在使用DOM0级的方法的情况下，事件处理程序会在其所属元素的作用域内运行。 在使用attachEvent()方法的情况下，事件处理程序会在全局作用域中运行，因此this等于window 1234var btn = document.getElementById(\"myBtn\");btn.attachEvent(\"onclick\", function()&#123; alert(this === window) // true&#125;) attachEvent方法也可以用来为一个元素添加多个事件处理程序， 与DOM方法不同的是，这些事件处理程序不是以添加他们的顺序执行，而是以相反的顺序触发。 使用attachEvent添加的事件可以通过detachEvent来移除，条件是必须提供相同的参数，所以匿名函数不能被移除。不过，只要能够将对相同函数的引用传给detachEvent就可以移除相应的事件处理程序 123456var btn = document.getElementById(\"myBtn\");var handler = function()&#123; alert(\"Clicked\")&#125;btn.attachEvent(\"onclick\", hanlder);btn.detachEvent(\"onclick\", hanlder) 跨浏览器的事件处理程序要保证处理事件的代码能再大多数浏览器下一致的运行，只需要关注冒泡阶段。 addHandler() 第一个要创建的方法是addHandler, 它的职责是视情况分别使用DOM0级方法、DOM2级方法或IE方法来添加事件。这个方法属于一个名叫EventUtil的对象。 addHandler方法接受三个参数： 要操作的元素、事件名称和事件处理程序函数。 1234567891011121314151617181920var EventUtil = &#123; addHandler: function(element, type, handler)&#123; if( element.addEventListener )&#123; element.addEventListener(type, handler, false) &#125; else if ( element.attachEvent )&#123; element.attachEvent( \"on\" + type, handler ) &#125; else &#123; element[ \"on\" + type ] = handler &#125; &#125;, removeHandler: function(element, type, handler)&#123; if( element.removeEventListener )&#123; element.removeEventListener( type, handler, false ) &#125; else if( element.detachEvent )&#123; element.detachEvent( \"on\" + type, handler ) &#125; else &#123; element[\"on\" + type] = null; &#125; &#125;&#125; 并没有考虑到所有的浏览器问题， 比如IE中的作用域问题，不过，使用它们移除和添加事件处理程序还是足够的 DOM0级对每个事件只支持一个事件处理程序。 事件对象 —— event在触发DOM上的某个事件时，会产生一个事件对象Event，这个对象中包含着所有与事件有关的信息 DOM中的事件对象兼容DOM的浏览器会将一个event独享传入到事件处理程序中，无论指定事件处理程序时使用什么方法（DOM0 DOM2），都会传入event对象 1234567var btn = doucment.getElementById(\"myBtn\");btn.onclick = function(event)&#123; alert(event.type)&#125;btn.addEventListener(\"click\", function(event)&#123; alert(event.type)&#125;, false) 1&lt;input type=\"button\" value=\"click me\" onclick=\"alert(event.type)\" &gt; 属性和方法 MDN-Event bubbles Boolean 只读 表明事件是否冒泡 cancelable Boolean 只读 表明事件是否可以取消事件的默认行为 currentTarget Element 只读 其事件处理程序当前正在处理事件的那个元素 defaultPrevented Boolean 只读 为true表示已经调用了preventDefault() detail Integer 只读 与事件相关的细节信息 eventPhase Integer 只读 调用事件处理程序的阶段： 1. 捕获阶段 2. 处于目标 3. 冒泡阶段 preventDefault Function 只读 取消事件的默认行为，如果cancelable是true 则可以使用这个方法 stopImmediatePropagation Function 只读 取消事件的进一步捕获或冒泡，同时阻止任何事件处理程序被调用（DOM3级事件中新增） stopPropagation Function 只读 取消世间的进一步捕获或冒泡，如果bubbles是true 可以使用这个方法 target Element 只读 事件的目标 trusted Boolean 只读 为true表示事件是浏览器生成的 为false 表示事件是由开发人员通过JS创建的 type String 只读 被触发的事件类型 view AbstractView 只读 与实践关联的抽象视图 等同于发生事件的window对象 在事件处理程序内部，对象this始终等于currentTarget的值，而target啧只包含事件的实际目标。 如果直接将事件处理程序指定给了目标元素，则 this currentTarget 和 target包含相同的值 12345var btn = document.getElementById(\"myBtn\");btn.onclick = function(event)&#123; alert(event.currentTarget === this); // true alert( event.target === this ); // true&#125; 如果事件处理程序存在于按钮的父节点中(例如docuemnt.body)，那么这些值是不同的 12345678910document.body.onclick = function(event)&#123; alert( event.currentTarget === document.body ) // true alert( this = document.body ) // true alert( event.target === document.getElementById(\"myBtn\") ) // true&#125;/*点击这个例子中的按钮时，this和currentTarget都等于document.body，因为事件处理是注册到这个元素上的而target元素却等于按钮元素，因为他是click事件真正的目标由于按钮上并没有注册事件处理程序，结果click事件就冒泡到了document.body在那里事件才得到了处理*/ 在需要通过一个函数处理多个事件时，可以使用type属性 阻止默认事件可以使用event.preventDefault(),不过cancelable属性必须是true 阻止进一步的事件捕获或冒泡 可以使用event.stopPropagation() eventPhase属性确定事件当前正位于事件流的哪个阶段 12345678910var btn = document.getElementById(\"myBtn\");btn.onclick = function(event)&#123; alert(event.eventPhase) // 2&#125;document.body.addEventListener(\"click\", function(event)&#123; alert(event.eventPhase) //1&#125;, true)document.body.onclick = function(event)&#123; alert(event.eventPhase) // 3 &#125; IE中的事件对象在使用DOM0级方法添加事件处理程序时，event对象作为window对象的一个属性存在。 12345var btn = document.getElementById(\"myBtn\");btn.onclick = function()&#123; var event = window.event; alert(event.type)&#125; 在此，我们通过window.event取到了event对象，并检测了被触发事件的类型（IE中额type属性与DOM中的type属性是相同的） 可是，如果事件处理程序是使用attachEvent添加的，那么就会有一个event对象作为参数被传入事件处理程序函数中 1234var btn = document.getElementById(\"myBtn\");btn.attachEvent(\"onclick\", function(event)&#123; alert(event.type)&#125;) 在 attachEvent的情况下，也可以通过window对象来访问Event对象 如果是通过HTML特性置地当的事件处理程序，那么还可以通过一个名叫event的变量来访问event对象，与DOM中的事件模型相同 1&lt;input type=\"button\" value=\"Click Me\" onclick = \"alert(event.type)\"&gt; IE的event对象同样也包含与创建它的时间相关的属性和方法，其中很多属性和方法都有对应的或者相关的DOM属性和方法。与DOM的event对象一样，这些属性和方法也会因为事件类型的不同而不同，但所有时间对象都会包含下列的属性和方法 cancelBubble Boolean 读/写 默认为false 将其设置为true可以取消事件冒泡（与DOM中的stopPropagation方法的作用相同） returnValue Boolean 读/写 默认true 但将其设置为false就可以取消事件的默认行为（与DOM中的preventDefault()方法的作用相同） srcElement Element 只读 时间的目标（与DOM中的target属性相同） type String 只读 被触发的事件的类型 因为事件处理程序的作用域是根据指定它的方式来确定的，所以不能认为this会始终等于事件目标。故而，还是使用event.srcElement比较保险 1234567var btn = document.getElementById(\"myBtn\");btn.onclick = function()&#123; alert( window.event.srcElement === this ); // true&#125;btn.attachEvent(\"onclick\", function(event)&#123; alert(event.srcElement === this) // false&#125;) returnValue 相当于DOM中的preventDefault方法，它的作用都是取消给定事件的默认行为。只要将returnValue设置为false，就可以阻止默认行为 1234var link = document.getElementById(\"myLink\");link.onclick = function()&#123; window.event.returnValue = false;&#125; 跨浏览器的事件对象12345678910111213141516171819202122232425262728var EventUtil = &#123; addHandler: function( element, type, handler )&#123; // &#125;, getEvent: function( event )&#123; return event ? event : window.event; &#125;, getTarget: function( event )&#123; return event.target || event.srcElement; &#125;, preventDefault: function( event )&#123; if( event.preventDefault )&#123; event.preventDefault() &#125; else &#123; event.returnValue = false; &#125; &#125;, removeHandler: function( element, type, handler )&#123; &#125;, stopPropagation: function( event )&#123; if( event.stopPropagation )&#123; event.stopPropagation() &#125; else &#123; event.cancelBubble = true; &#125; &#125;&#125; 事件类型DOM3级事件 规定了以下几类事件 UI（User Interface）事件，当用户与页面上的元素交互时触发。 焦点事件，当用户通过鼠标在页面上执行操作时触发 鼠标事件，当用户通过鼠标在页面上 滚轮事件 文本事件 键盘事件 合成事件 IME（Input Method Editor 输入法编辑器） 变动（mutation）事件， 当底层DOM结构发生变化时 变动名称事件 已被遗弃 鼠标与滚轮事件客户区坐标位置 鼠标事件都是在浏览器视口中的特定位置上发生的，这个位置信息保存在事件对象的clientX和clientY属性中 他们表示事件发生时，鼠标指针在视口中的水平和垂直坐标 页面坐标位置 页面坐标通过事件对象的pageX和pageY属性来告诉你事件是在页面中的什么位置发生的。 换句话说，这两个属性表示鼠标光标在页面中的位置，因此做标书hi从页面本身而非视口的左边和顶边计算的。 在页面没有滚动的情况下，pageX和pageY的值与clientX和clientY的值相等 兼容IE8的写法 IE8及更早版本不支持时间对象上的页面坐标，不过使用客户区坐标和滚动信息可以计算出来。 123456789101112var div = document.getElementById(\"myDiv\");EventUtil.addHandler( div, \"click\", function(event)&#123; event = EventUtil.getEvent(event); var pageX = event.pageX, pageY = event.pageY; if( pageX === undefined )&#123; pageX = event.clientX + ( document.body.scrollLeft || document.documentElement.scrollLeft ); &#125; if( pageY === undefined )&#123; pageY = event.clientY + ( document.body.scrollTop || document.documentElement.scrollTop ) &#125;&#125; ) 屏幕坐标位置 鼠标事件发生时，不仅会有相对于浏览器窗口的位置，还有一个相对于整个电脑屏幕的位置。 通过screenX和screenY属性就可以确定鼠标事件发生时鼠标指针相对于整个屏幕的坐标信息 修改键 shift =&gt; shiftKey ctrl =&gt; ctrlKey Alt =&gt; altKey Meta =&gt; metaKey 都是布尔值 触发了就是true IE8之前不支持 相关元素 发生mouseover 和mouseout事件时，这两个事件都会涉及把鼠标指针从一个元素的边界之内移动到另一个元素的边界之内 对mouseover事件而言，事件的主目标是获得光标的元素，而相关元素就是那个失去光标的元素 对mouseout事件而言，事件的主目标是失去光标的元素，而相关元素则是获得光标的元素 DOM通过event对象的relatedTarget属性提供了相关元素的信息，这个属性只对于mouseover和mouseout事件才包含值，对于其他事件，这个属性的值是null IE8之前不支持reletedTargt属性，但提供了保存着同样信息的不同属性 在mouseover事件触发前，IE的fromElement属性中保存了相关元素 在mouseout事件触发时，IE的toElement属性中保存着相关元素 12345678910111213var EventUtil = &#123; getRelatedTarget: function( event )&#123; if( event.relatedTarget )&#123; return event.relatedTarget; &#125; else if ( event.toElement )&#123; return event.toElement &#125; else if ( event.fromElement )&#123; return event.fromElement &#125; else &#123; return null &#125; &#125;&#125; 鼠标按钮在主鼠标按钮被单击的情况下才会触发click事件，因此检测按钮的信息并不是必要的 但对于mousedown和mouseup事件来说，则在其event独享存在一个button属性 DOM的button属性可能有如下三个值： 0 主鼠标按钮 1 中间鼠标按钮 2次鼠标按钮 主鼠标按钮一般是左键 IE8之前也提供了button属性 但是与DOM的butotn属性有差异 0——没有按下 1——按下了主鼠标按钮 2——按下了次鼠标按钮 3——同时按下了主次鼠标按钮 4——按下了中间鼠标按钮 5——同时按下了主鼠标按钮和中间的鼠标按钮 6——同时按下了次鼠标按钮和中间的鼠标按钮 为了兼容只要将IE的其它选项分别转换成如同按下这三个键中的一个即可（同时将转牛作为优先选取的对象） 由于单独使用能力检测无法确定差异，一次必须另辟蹊径。支持DOM版鼠标事件的浏览器可以通过hasFearture()方法来检测 123456789101112131415161718192021var EventUtil = &#123; getButton: function()&#123; if( document.implementation.hasFeature( \"MouseEvents\", \"2.0\" ) )&#123; reutrn event.button &#125; else &#123; switch( event.button )&#123; case 0: case 1: case 3: case 5: case 7: return 0; case 2: case 6: return 2; case 4: return 1 &#125; &#125; &#125;&#125; 更多的事件信息event.detail 对于鼠标事件来说，detail中包含了一个数值，表示在给定位置上发生了多少次单击。 在同一个元素上相继的发生一次mousedown和mouseup算作一次单击。 detail属性从1开始计数，每次单击后多厚激增。 如果鼠标在mosuedown和mouseup之间移动了位置，则detail会被重置为0 IE也通过下列属性为鼠标事件提供了更多信息 altLeft 表示是否按下了Alt键。如果altLeft的值为true，啧altKey的值也为true ctrlLeft 表示是否按下了Ctrl键 如果ctrlLeft的值为true 则ctrlKey的值也为true offsetX 光标相对于目标元素边界的X坐标 offsetY 光标相对于目标元素边界的y坐标 shiftLeft 是否按下了shift键，如果shiftLeft的值为ture 则shiftKey的值也为true 鼠标滚轮事件 IE6首先实现了mousewheel事件。 当用户通过鼠标滚轮与页面交互、在垂直方向上滚动页面时（无论向上还是向下），就会触发mousewheel事件 这个事件可以在任何元素上面触发，最终会冒泡到document(IE8)或window(IE9+)对象 与mousewheel事件对应的event对象除包含鼠标事件的所有标准信息外，还包含一个特殊的wheelDelta属性。当用户向前滚动鼠标滚轮时，wheelDelta是120的倍数；当用户向后滚动时，wheelDelta是-120的倍数。 而在早期的Opera版本，就需要使用浏览器检测技术来确定实际的值，因为在Opera 9.5之前的版本总，wheelDelta值的正负号是颠倒的 1234EventUtil.addHandler( document, \"mousewheel\", function()&#123; event = EventUtil.getEvent(event); var delta = ( client.engins.opera &amp;&amp; client.engine.opera &lt; 9.5 ? -event.wheelDelta : event.wheelDelta )&#125; ) Firefox支持一个名为DOMMouseScroll的类似事件，也被视为鼠标事件，因而包含于鼠标事件有关的所有属性。 而有关detail的值，向前是-3的倍数，向后是3的倍数 DOMMouseScroll事件可以添加到页面中的任何元素，而该事件会冒泡到window对象 1234EventUtil.addHandler( window, \"DOMMouseScroll\", function(event)&#123; event = EventUtil.getEvent(event); alert(event.detail)&#125; ) 跨浏览器代码 123456789var EventUtil = &#123; getWheelDelta: function(event)&#123; if( event.wheelDelta )&#123; return ( client.engine.opera &amp;&amp; client.engine.opera &lt; 9.5 ? -event.wheelDelta : event.wheelDelta ) &#125; else &#123; return -event.detail * 40 &#125; &#125;&#125; 触摸设备 不支持dbclick事件 双击会放大 （现在不一定了） 轻击可单击元素会触发mousemove事件。如果此操作会导致内容变化，将不再有其他事件发生；如果屏幕没有因此变化，那么会一次发生mousedown mouseup和click事件。轻击不可单机的元素不会触发任何事件。可单击的元素是指那些单击可产生默认操作的元素如链接或者那些已经被指定了onclick事件处理程序的元素 mousemove事件也会触发mouseover和mosueout事件 连个手指放在屏幕上切页面随手之移动而滚动时会触发mousewheel和scroll事件 无障碍设备 不建议使用click之外的其他鼠标事件来展示功能或引发代码执行 使用click事件执行代码。在屏幕阅读器中，由于无法触发mousedown事件结果会造成代码无法执行 不要使用onmouseover向用户显示新的选项。屏幕阅读器无法触发这个事件 不要使用dbclick执行重要的操作 键盘与文本事件对键盘事件的支持主要遵循的是DOM0级 keydown当用户按下键盘上的任意键时触发，而且如果按住不放的话，会重复触发此事件 keypress当用户按下键盘上的字符键时触发，而且如果按住不放的话，会重复触发此事件。按下Esc键也会触发这个事件。Safari3.1之前的版本也会在用户按下非字符键时触发keypress keyup当用户释放键盘上的键时触发 所有元素都支持，但是一般文本框最常用到 textInput。这个事件是对keypress的补充，用意是在将文本显示给用户之前更容易拦截文本。在文本插入文本框之前会触发textInput事件 当用户按了一下键盘上的字符键时，首先会触发keydown事件，然后是keypress事件，最后触发keyup事件 keydown和keypress都是在文本框发生变化之前被触发的 keyup是变化之后触发的 如果用户按下了一个字符键不放，就会重复触发keydown和keypress事件，直到松开为止。 非字符键就没有keypress了 键码 event.keyCode IE会有些不一致 字符编码 event.charCode IE8及之前版本和Opera则是在keyCode中保存字符的ASCII编码 123456789var EventUtil = &#123; getCharCode: function(event)&#123; if( typeof event.charCode == \"number\" )&#123; return event.charCode &#125; else &#123; return event.keyCode &#125; &#125;&#125; DOM3级变化key char keyIdentifier DOM3级中的键盘事件，不再包含charCode属性，而是包含两个新属性： key和char key属性是为了取代keyCode而新增的，它的值是一个字符串。在按下某个字符键时，key的值就是响应的文本字符（如k或m）。在按下非字符键时，key的值是相应键的命（如Shift或Down） 而char属性在按下字符键时的行为与key相同，单在按下非字符键时值为null IE支持key不支持char属性 safari5和Chrome支持名为keyIndentifier的属性，非字符键返回的与key相同，字符键keyIdentifier返回一个类似“U+0000”的字符串，表示Unicode的值 1event.key || event.keyIdentifier 由于浏览器为题 不推荐使用key keyIdentifier或char location 按下了什么位置的键 存在兼容问题 getModifierState 接收一个参数，表示要检测的修改键 如果指定的修改键是按下状态，返回true IE9 火狐 谷歌 支持 textInput 只有可编辑区域才会触发textInput事件。 只会在用户按下能够输入实际字符串的键时才会触发 它的event对象中还包含一个data属性，这个属性的值就是用户输入的字符串（非编码字符串） 1234EventUtil.addHandler( textbox, \"textInput\", function(event)&#123; event = EventUtil.getEvent(event); alert(event.data)&#125; ) event对象上还有一个属性，叫inputMethod，表示把文本输入到文本框中的方式 0 —— 浏览器不确定 1 —— 键盘输入的 2 —— 粘贴进来的 3 —— 拖放进来的 4 —— IME输入的 5 —— 表单中选择某项输入的 6 —— 手写输入的（例如手写笔） 7 —— 语音输入的 8 —— 几种方法组合输入的 9 —— 脚本输入的 书上说IE9+ Safari和Chrome 支持 只有IE支持inputMethod属性 有待考证 书本信息比较老了 设备中键盘事件复合事件 复合事件是DOM3级事件中新添加的一类事件，用于处理IME的输入序列。 IME可以让用户输入在无力键盘上找不到的字符 compositionstart 在IME的文本符合系统打开时触发，表示要开始输入了 compositionupdate 在向输入字段中插入新字符时触发 compositionend 在IME的文本复合系统关闭时触发，表示返回正常键盘输入状态 复合事件的data 如果在compostionstart事件发生时访问，包含正在编辑的文本 如果在compositionupdate事件发生时访问，包含此次输入绘画中插入的所有字符 如果在compositionend事件发生时访问，包含此次输入绘画中插入的所有字符 变动事件 DOM2级的变动事件能再DOM中的某一部分发生变化时给出提示。变动事件视为XML或HTML DOM设计的，并不特定于某种语言。 DOMSubtreeModified 在DOM结构中发生任何变化时触发。这个事件在其他任何事件触发后都会触发 DOMNodeInserted 在一个节点作为子节点被插入到另一个节点中时触发 DOMNodeInsertedIntoDocument 在一个节点北直街插入文档或通过子树间接插入文档之后触发，这个事件在DOMNodeInserted之后触发 DOMNodeRemoveFromDocument 在一个节点被直接从文档中移除或通过子树间接从文档中移除之前触发。这个事件在DOMRemoved之后触发 DOMAttrModified在特性被修改后触发 DOMCharacterDataModified在文本节点的值发生变化时触发 浏览器是否支持 1var isSupported = document.implementation.hasFeature(\"MutationEvents\", \"2.0\"); IE8及更早不支持 HTML5事件contextmenu 用以表示合适应该显示上下文菜单，以便开发人员取消默认的上下文菜单而提供自定义的菜单。 由于contextmenu事件是冒泡的，因此可以为document指定一个事件处理程序，用意处理页面中发生的所有此类事件。 这个事件的目标是发生用户操作的元素。 在所有浏览器中都可以取消这个事件，在兼容DOM的浏览器中：event.preventDefault()，IE中，将event.returnValue的值设置为false 123456789101112131415EventUtil.addHandler( window, 'load', function(event)&#123; var div = document.getElementById(\"myDiv\"); EventUtil.addHandler( div, \"contextmenu\", function(event)&#123; event = EventUtil.getEvent(event); EventUtil.preventDefault(event); var menu = document.getElementById(\"myMenu\"); menu.style.left = event.clientX + 'px'; menu.style.top = event.clientY + 'px'; menu.style.visibility = \"visible\" &#125; ) EventUtil.addHandler( document, \"click\", function(event)&#123; document.getElementById(\"myMenu\").style.visibility = \"hidden\"; &#125; )&#125;) beforeunload 询问用户是否确认关闭 event.returnValue的值是提示用户的信息 123456EventUtil.addHandler( window, \"beforeunload\", function(event)&#123; event = EventUtil.getEvent( event ); var message = \"close\"; event.returnValue = message; return message&#125; ) DOMContentLoaded 当DOM加载完就触发，不想onload要等待图像JSCSS触发 123EventUtil.addHandler( docuemnt, \"DOMContentLoaded\", function(event)&#123; alert(\"content loaded\")&#125; ) 不支持这个事件的 可以写个0毫秒的延迟调用 readystatechange提供与文档或元素的加载状态有关的信息 支持readystatechange事件的每个对象都有一个 readyState属性 uninitialized 对象存在但未初始化 loading 对象正在加载数据 loaded 对象加载数据完成 interactive 可以操作对象了但还没有完全加载 complete 对象已经加载完成 如果某个阶段不适用于某个对象，则该对象完全可能跳过该阶段，并没有规定哪个阶段适用于哪个对象。这就意味着事件经常会少于4次而且readyState属性的值也不总是连续的 readystatechange可以十分近似的模拟DOMContentLoaded事件，但他们本制度上还是不同的。在不同页面种，load事件与readystaechange事件并不鞥保证以相同的顺序触发 pageshow 和 pagehidepageshow会在页面显示时触发，无论该页面是否来自bfcache，在重新加载的页面种，pageshow会在load事件触发后触发，对于bfcache中的页面，pageshow会在页面轧辊太完全恢复的那一刻触发 虽然这个事件的目标是document，但必须将事件处理程序加到window event.persisted pageshow 页面从bfcache中健在，那么persisted的值会为true pagehide事件，如果页面写在会后会被保存在bfcache中，那么persisted的值为true，因此，第一次触发pageshow时，persisted的值一定是false，地产一触发pagehide时，persisted就会变成true hashchange 添加给window对象，url参数列表只要发生变化时 event.oldURL event.newURL 能力检测 1var isSupported = ( \"onhashchange\" in window ) &amp;&amp; ( document.documentMode === undefined || document.documentMode &gt; 7 )","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qw8.github.io/tags/JavaScript/"},{"name":"事件","slug":"事件","permalink":"https://qw8.github.io/tags/事件/"}]},{"title":"JavaScript数据处理","slug":"knowledges/JavaScript数据处理","date":"2020-02-14T10:24:00.000Z","updated":"2023-04-14T17:01:50.000Z","comments":true,"path":"/knowledges/javascript-shu-ju-chu-li.html","link":"","permalink":"https://qw8.github.io/knowledges/javascript-shu-ju-chu-li.html","excerpt":"","text":"字符串转换成对象12var obj = JSON.parse(data);console.log(JSON.stringify(data.data)); 说明：①php中json_encode()转换返回给前端页面时，用“.”读取不到，是因为返回的是字符串格式，就是最外层带了引号的json数据格式，可以用var obj = JSON.parse(data);转换成对象，也可以用tp框架中的$this-&gt;ajaxReturn();②另外在vue中，有时候打印对象或者数组时，可能会出现看不懂其数据结构，可以用console.log(JSON.stringify(data.data));打印出来，再复制出来，格式化结构。 判断一个单词是否是回文回文是指把相同的词汇或句子，在下文中调换位置或颠倒过来，产生首尾回环的情趣，叫做回文。例如 12345654321 abcdedbcba 等。 1234//利用reverse 进行字符串反转，然后和原字符串对比是否相等function isPalindrom(str) &#123; return str == str.split(&apos;&apos;).reverse().join(&apos;&apos;);&#125; 统计一个字符串出现最多的字母12345678910111213141516171819202122//统计每个字母出现的次数，然后存起来，然后进行比较function maxTimesChar(str) &#123; if(str.length == 1) &#123; return str; &#125; let charObj = &#123;&#125;; for(let i=0;i&lt;str.length;i++) &#123; if(!charObj[str.charAt(i)]) &#123; charObj[str.charAt(i)] = 1; &#125;else&#123; charObj[str.charAt(i)] += 1; &#125; &#125; let maxChar = &apos;&apos;, maxValue = 1; for(var k in charObj) &#123; if(charObj[k] &gt;= maxValue) &#123; maxChar = k; maxValue = charObj[k]; &#125; &#125; return maxChar;&#125; 转义与反转义兼容写法12345678910111213141516//反转义function HTMLDecode(text) &#123; var temp = document.createElement(&quot;div&quot;); temp.innerHTML = text; var output = temp.innerText || temp.textContent; temp = null; return output;&#125;//转义function HTMLEncode(html) &#123; var temp = document.createElement (&quot;div&quot;); (temp.textContent != null) ? (temp.textContent = html) : (temp.innerText = html); var output = temp.innerHTML; temp = null; return output;&#125; 说明：前端相关朋友说这么写是兼容性写法，我这里就不深究了，亲测可用。 数组中添加元素代码：arr.push();说明：可以用arr.push()，在添加元素之前先确认变量arr是一个数组。可以自己定义var arr = []，并可以在数组中添加对象，例如arr.push({“aa”:”bb”})。 读取对象或这数组中的元素123var test = [&#123;&quot;a&quot;:&quot;a&quot;&#125;,&#123;&quot;b&quot;,&quot;b&quot;&#125;];console.log(test[1].b);console.log(test[1].[&apos;b&apos;]); //不能用test.1.b 当键名是数字时，不能用“.”点拼接，只能用[] 当两个数组要根据各自某一个字段进行排序举个例子，表格的表头和表中的值，分为了两个数组(如下)，表头和表中值要一一对应。另外，在Element的表格组件中，不用排序，其组件已做了排序的工作。 表头1 表头2 表头31 2 3… … …数组示例：数组1和数组2要根据key字段一一对应，可以根据这个字段先对两个数组进行排序，然后一一匹配，如冒泡排序等。 123456789101112131415161718192021222324252627282930313233343536373839404142434445[ &#123; &quot;tabelHeader&quot;:&quot;表头1&quot;, &quot;key&quot;:&quot;1&quot; &#125;, &#123; &quot;tabelHeader&quot;:&quot;表头2&quot;, &quot;key&quot;:&quot;2&quot; &#125;, &#123; &quot;tabelHeader&quot;:&quot;表头3&quot;, &quot;key&quot;:&quot;3&quot; &#125;][ &#123; &quot;value&quot;:&quot;2&quot;, &quot;key&quot;:&quot;2&quot; &#125;, &#123; &quot;value&quot;:&quot;1&quot;, &quot;key&quot;:&quot;1&quot; &#125;, &#123; &quot;value&quot;:&quot;3&quot;, &quot;key&quot;:&quot;3&quot; &#125;]//根据数组中某个键的值冒泡排序，还有其他更优排序方式，这里不一一示例，可以搜索相关算法排序方式。function bubbleSort(arr,sortKey) &#123; //console.time(&apos;2.快速排序耗时&apos;); var len = arr.length; for (var i = 0; i &lt; len; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j][sortKey] &gt; arr[j+1][sortKey] ) &#123; //相邻元素两两对比 var temp = arr[j+1]; //元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; //console.timeEnd(&apos;222222.快速排序耗时&apos;); return arr;&#125; 剔除数组中的某些元素目前只找到循环剔除，把需要的元素用push添加到新的数组中。使用splice在循环中有问题，个人猜测是键名原因，未做深究，但我个人觉得肯定有更好方式，因为参照其他语言，都有更为简单的方式，知道的朋友请告知下，谢谢。–更新–今天看到前端人员剔除数组中一些元素时，用到了filter函数，挺好用的。 将数组中字符串转换成整型12345var arr = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;];arr = arr.map(function (data) &#123; return +data;&#125;);//此时arr变成[1,2,3]map是个好方法，我个人对map理解不深，对其使用有些别扭。 js判断数组中对象里的某一个值是否存在1234567891011function isInArray(arr,value)&#123; for(var i = 0; i &lt; arr.length; i++)&#123; if(value === arr[i][&apos;id&apos;])&#123; return true; &#125; &#125; return false;&#125;var arr = [&#123;id: &quot;ccjl1&quot;&#125;,&#123;id: &quot;ccjl2&quot;&#125;,&#123;id: &quot;ccjl3&quot;&#125;];var test = isInArray(arr,&apos;ccjl1&apos;);console.log(test); 根据属性来更新一个数组中的对象1const arr = [ &#123;id: 1, score: 1&#125;, &#123;id: 2, score: 2&#125;, &#123;id: 3, score: 4&#125;];//更新的值const newValue = &#123;id: 3, score: 3&#125; 更新数组中id为3的score值。 Es6 装逼写法如下： 12const result = initial.map(x =&gt; x.id === newValue.id ? newValue : x); //是不是很装B？？console.log(updated) // =&gt; [ &#123; id: 1, score: 1 &#125;, &#123; id: 2, score: 2 &#125;, &#123; id: 3, score: 3 &#125; ] 首先数组是利用数组map方法去遍历arr的每一个值，然后进行于newValue的id进行对比，不同返回原来的项，相同返回newValue. 不装逼清晰点写法： 1234const updated = arr.map(function(item)&#123; return item.id == newValue.id ? newValue : item ;&#125;);console.log(updated) // =&gt; [ &#123; id: 1, score: 1 &#125;, &#123; id: 2, score: 2 &#125;, &#123; id: 3, score: 3 &#125; ] 数组去重方案 A 123456789101112// 遍历数组，建立新数组，利用indexOf判断是否存在于新数组中，不存在则push到新数组，最后返回新数组 function unique(ar) &#123; var ret = []; for (var i = 0, j = ar.length; i &lt; j; i++) &#123; if (ret.indexOf(ar[i]) === -1) &#123; ret.push(ar[i]); &#125; &#125; return ret;&#125; 方案B 1234567891011121314//遍历数组，利用object对象保存数组值，判断数组值是否已经保存在object中，未保存则push到新数组并用object[arrayItem]=1的方式记录保存,这个效率比A高function unique(ar) &#123; var tmp = &#123;&#125;, ret = []; for (var i = 0, j = ar.length; i &lt; j; i++) &#123; if (!tmp[ar[i]]) &#123; tmp[ar[i]] = 1; ret.push(ar[i]); &#125; &#125; return ret;&#125; 方案C 1234//ES6const numbers = [1, 2, 1, 1, 2, 1, 3, 4, 1 ];const uniq = [...new Set(numbers)] // =&gt; [ 1, 2, 3, 4 ];const uniq2 = Array.from(new Set(numbers)) // =&gt; [ 1, 2, 3, 4 ]; 方案D 1234//filter function unique (arr) &#123; var res = arr.filter(function (item, index, array) &#123; return array.indexOf(item) === index; //array.indexOf(item) === index 说明这个元素第一次出现，后面这个item再出现他的item肯定不是index了&#125;) return res; &#125; 根据属性删除数组中的一个对象12345// 根据属性删除数组中的对象,利用filter进行过滤数组中id相同的项const initial = [ &#123;id: 1, score: 1&#125;, &#123;id: 2, score: 2&#125;, &#123;id: 3, score: 4&#125;];const removeId = 3;const without3 = initial.filter(x =&gt; x.id !== removeId);console.log(without3) // =&gt; [ &#123; id: 1, score: 1 &#125;, &#123; id: 2, score: 2 &#125; ] 数组中是否存在某个值数组自带方法 12345678var arr = [1, 2, 4, 3, 5, 6]console.log(arr.includes(4))console.log(arr.some(item =&gt; item === 4))console.log(arr.find(item =&gt; item === 4))console.log(arr.findIndex(item =&gt; item === 4))console.log(arr.indexOf(4) !== -1)console.log(arr.filter(item =&gt; item === 4))// for 循环，略 其他各种”神奇”的算法 先排序，然后二分法查找 set 解法，利用 set 的唯一性，将目标值添加进 set，如果 set 长度没变的话，这个值就是存在的 12345var arr = [1,2,3,4,5,6]var arrSet = new Set(arr)let prevSetLen = arrSet.sizearrSet.add(5)console.log(prevSetLen===arrSet.length) 利用数组的 join 方法，把所有数字用逗号拼起来，然后正则匹配，或是调 includes 方法 找出两个数组中的交集常规蠢办法 for 循环 123456789101112var arr1 = [1, 2, 3]var arr2 = [3, 4, 5, 6]var commonArr = []for (var i = 0; i &lt; arr1.length; i++) &#123; var _item = arr1[i] for (var j = 0; j &lt; arr2.length; j++) &#123; if (_item === arr2[j]) &#123; commonArr.push(_item) &#125; &#125;&#125; ES6 的 filter 结合 includes 方法 1234var arr1 = [1, 2, 3]var arr2 = [3, 4, 5, 6]arr1.filter(item=&gt;arr2.includes(item)) 一个数组转对象，一个数组遍历看对象是否存在对应值 1234567891011var arr1 = [1, 2, 3]var arr2 = [3, 4, 5, 6]var _obj = &#123;&#125;let _tempArr = arr1.length &gt; arr2.length ? arr2 : arr1_tempArr.forEach(item =&gt; &#123; _obj[item] = item&#125;)let commonArr = arr2.filter(item =&gt; _obj[item])console.log(commonArr)_obj = null_tempArr = null 这里先判断数组长度，选一个短的数组，使得新创建的临时对象尽可能小。 如果不考虑单个数组里有重复项的话，可以先合并数组，然后再遍历合并后的数组，进行计次，大于2则是重叠的。 1234567891011var arr1 = [1, 2, 3]var arr2 = [3, 4, 5, 6]var _tempArr = arr1.concat(arr2).sort()var result = []_tempArr.reduce((prev, now) =&gt; &#123; if (prev === now) &#123; result.push(now) &#125; return now&#125;) set 的使用，主要利用不可重复设置，判断长度是否有变化，而得出是否是重复了；或者直接用 has 方法 1234567var arr1 = [1, 2, 3]var arr2 = [3, 4, 5, 6]var set = new Set(arr1)var result = []result = arr2.filter(item =&gt; arr1.has(item))console.log(result) “神奇”的算法 排序后，两个数组下标移动，两两比较 1234567891011121314151617181920212223242526var arr1 = [1, 2, 8, 3 ]var arr2 = [5, 6, 2, 3, 4]arr1.sort() // [1,2,3]arr2.sort() // [2,3,4,5,6]var result = []let arr1Index = 0let arr2Index = 0let runTimes = 0while (arr1Index &lt; arr1.length &amp;&amp; arr2Index &lt; arr2.length) &#123; runTimes++ let arr1Item = arr1[arr1Index] let arr2Item = arr2[arr2Index] if (arr1Item &gt; arr2Item) &#123; arr2Index++ &#125; else if (arr1Item &lt; arr2Item) &#123; arr1Index++ &#125; else &#123; result.push(arr1Item) arr1Index++ arr2Index++ &#125;&#125;console.log(result)console.log(runTimes) 两个数组的并集 set 1234var arr1 = [1, 2, 3]var arr2 = [4, 5, 3, 6]var result = [...new Set(arr1.concat(arr2))]// var result = [...new Set([...arr1, ...arr2])] reduce 1234567891011var arr1 = [1, 2, 3]var arr2 = [4, 5, 3, 6]var tempArr = [...arr1, ...arr2].sort()var result = []tempArr.reduce((prev, now) =&gt; &#123; if (prev !== now) &#123; result.push(now) &#125; return now&#125;, null)console.log(result) 转 json 对象 1234567var arr1 = [1, 2, 3]var arr2 = [4, 5, 3, 6] var obj = &#123;&#125;arr1.forEach(item =&gt; (obj[item] = item))arr2.forEach(item =&gt; (obj[item] = item))var result = Object.values(obj)console.log(result) 数组去重效率上讲，转 obj 的方式 &gt; set &gt; reduce &gt; includes/indexOf &gt; 双重for循环 双重for循环 123456789101112131415var arr1 = [1, 2, 3, 3, 4, 5, 6, 8]var result = []for (var i = 0; i &lt; arr1.length; i++) &#123; let _hasItem = false for (var j = 0; j &lt; result.length; j++) &#123; if (arr1[i] === result[j]) &#123; _hasItem = true break &#125; &#125; if (!_hasItem) &#123; result.push(arr1[i]) &#125;&#125;console.log(result) includes/indexOf 1234567var arr1 = [1, 2, 3, 3, 4, 5, 6, 8]var result = []arr1.forEach(item =&gt; &#123; if (!result.includes(item)) &#123; result.push(item) &#125;&#125;) reduce 123456789var arr1 = [1, 2, 4, 5, 3, 3, 3, 6, 8]arr1.sort()var result = []arr1.reduce((prev, now) =&gt; &#123; if (now !== prev) &#123; result.push(now) &#125; return now&#125;, null) set 12var arr1 = [1, 2, 4, 5, 3, 3, 3, 6, 8]var result = [...new Set(arr1)] 转对象方式 1234var arr1 = [1, 2, 4, 5, 3, 3, 3, 6, 8]var obj = &#123;&#125;arr1.forEach(item =&gt; (obj[item] = item))var result = Object.values(obj) 数组排序自带 sort 1234var arr = [2,3,1,4,6]arr.sort(); // [1,2,3,4,6]arr.sort((a,b)=&gt;a-b); // [1,2,3,4,6]arr.sort((a,b)=&gt;b-a); // [6,4,3,2,1] 选择排序 每一次选择遍历选择一个最小值，确定一个位置 12345678910111213141516171819var times = 0function selectSort(arr) &#123; // 没遍历一轮,将确定一个位置 for (var i = 0; i &lt; arr.length; i++) &#123; // 假定当前项是剩余未排中最小的 let minIndex = i // 从已经确定的位置之后一位开始遍历 for (var j = i + 1; j &lt; arr.length; j++) &#123; // 假如找到比 min 还小的,更新最小值 if (arr[j] &lt; arr[minIndex]) &#123; minIndex = j &#125; &#125; // 得到最小值,第i位确定 let temp = arr[i] arr[i] = arr[minIndex] arr[minIndex] = temp &#125;&#125; 冒泡排序 核心为两两按大小规则交换 12345678910111213function bubbSort(arr) &#123; for (var i = 0; i &lt; arr.length; i++) &#123; // 74 for (var j = i + 1; j &lt; arr.length; j++) &#123; // 如果后面一个大于前面一个,那么换位置 if (arr[j] &lt; arr[i]) &#123; var temp = arr[j] arr[j] = arr[i] arr[i] = temp &#125; &#125; &#125;&#125; 快速排序 先随机选一个数(可选中间值) 以这个数分组，小的放左边，大的放右边 同理，在左边和右边的分组执行相同的操作，直到分组只剩一个元素 1234567891011121314151617181920212223var arr = [74, 28, 60, 41, 29, 90, 52, 40]function quickSort(arr)&#123; // 递归出口 if(arr.length&lt;=1)&#123; return arr &#125; // 1. 选中值 var basicNum = arr[Math.floor((arr.length - 1) / 2)] // 2. 左右分组 var left = [] var right = [] arr.forEach(item=&gt;&#123; if(item&gt;basicNum)&#123; right.push(item) &#125; else&#123; left.push(item) &#125; &#125;) // 3.递归执行左边和右边数组,并且合并结果 return quickSort(left).concat(basicNum, quickSort(right))&#125; 数组方法charAt()方法可返回指定位置的字符 JavaScript String 对象 例:stringObject.charAt(index)index:表示字符串中某个位置的数字,即字符在字符串中的下标. 1234&lt;script type=&quot;text/javascript&quot;&gt; var str = &quot;Hello worle!&quot; document.write(str.charAt(1)) // e&lt;/script&gt; toUpperCase()方法用于把字符串转换成大写 JavaScript String 对象例:stringObjice.toUpperCase() 1234&lt;script type=&quot;text/javascript&quot;&gt; var str=&quot;Hello World!&quot; document.write(str.toUpperCase())&lt;/script&gt; slice()方法可从已有的数组中返回选定的元素 JavaScript Array 对象arrayObject.slice(start,end)start 必需，规定从何处开始选取。自己算end 可选, 规定从何处结束选取。 结束不算 12345&lt;script type=&quot;text/javascript&quot;&gt; var arr = [&quot;George&quot;,&quot;John&quot;,&quot;Thomas&quot;] document.write(arr.slice(1,)) // John,Thomas document.write(arr.slice(1,2)) // John&lt;/script&gt; toString()方法可把一个逻辑值转换为字符串,并返回结果。booleanObject.toString() 1234&lt;script type=&quot;text/javascript&quot;&gt; var boo = new Boolean(true) console.log(boo.toString()) // true&lt;/script&gt; delete 操作符用于删除对象的某个属性；返回值是 true,false 123456789delete object.property object 对象的名称 或计算结果为对象的表达式 delete object[&apos;property&apos;] property 要删除的属性 var Employee = &#123; age:28, name:&apos;abc&apos;, designation:&apos;developer&apos; &#125; console.log(delete Employee.age) console.log(Employee) js 判断一个 object 对象是否为空123456if (JSON.stringify(data) === &apos;&#123;&#125;&apos;) &#123; return false // 如果为空,返回false，数组可以用同样的判断方式&#125;if (Object.keys(object).length === 0) &#123; return false // 如果为空,返回false，Object.keys(object)会返回一个空数组[]&#125; 判断对象或数组中元素是否存在typeof data.archiveRecordPage !== undefined一搬如果typeof后边是表达式，就要用括号括起来，否则不用括起来。另外一般要判断该层级之前的层级也要存在—-更新： hasOwnProperty也可以对象某对象是否存在 删除一个对象上的属性（key）123//利用es6的 ...运算符将其他属性和ａ属性分开来，这波操作很亮眼 ！const obj = &#123;a: 1, b: 2, c: 3&#125;;const &#123;a, ...newObj&#125; = obj;console.log(newObj) // =&gt; &#123;b: 2, c: 3&#125;; 两个Set对象相减1234//利用filter对s1进行过滤 ，去掉s2中存在的数字const s1 = [ 1, 2, 3, 4, 5 ]; const s2 = [ 2, 4 ]; const subtracted = s1.filter(x =&gt; s2.indexOf(x) &lt; 0); console.log(subtracted);//[1,3,5] 同理这样是可以去出一个数组中指定的元素 12345//去掉s3中的2和4 const s3 = [ 1, 2, 3, 4, 5, 4, 5, 6, 2, 2, 4 ]; const s2 = [ 2, 4 ]; const subtracted1 = s3.filter(x =&gt; s2.indexOf(x) &lt; 0); console.log(subtracted1); // [1, 3, 5, 5, 6] 将时间戳转换为时间格式在网上找的一个示例，如果是php写的接口，一般是需要在返回的时间戳字段上乘以1000的，java写的接口一般不需要，这个与精确度有关。一个是精确到秒，一个是精确到毫秒。当然，在框架VUE中另有其他写法，这里暂时不做深究。 12345678910formatDate(timestamp) &#123; var date = new Date(timestamp);//时间戳为10位需*1000，时间戳为13位的话不需乘1000 var Y = date.getFullYear() + &apos;-&apos;; var M = (date.getMonth()+1 &lt; 10 ? &apos;0&apos;+(date.getMonth()+1) : date.getMonth()+1) + &apos;-&apos;; var D = (date.getDate() &lt; 10 ? &apos;0&apos;+(date.getDate()) : date.getDate()) + &apos; &apos;; var h = (date.getHours() &lt; 10 ? &apos;0&apos;+(date.getHours()) : date.getHours()) + &apos;:&apos;; var m = (date.getMinutes() &lt; 10 ? &apos;0&apos;+(date.getMinutes()) : date.getMinutes()) + &apos;:&apos;; var s = (date.getSeconds() &lt; 10 ? &apos;0&apos;+(date.getSeconds()) : date.getSeconds()); return Y+M+D+h+m+s;&#125;","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qw8.github.io/tags/JavaScript/"},{"name":"对象","slug":"对象","permalink":"https://qw8.github.io/tags/对象/"},{"name":"字符串","slug":"字符串","permalink":"https://qw8.github.io/tags/字符串/"},{"name":"数组","slug":"数组","permalink":"https://qw8.github.io/tags/数组/"}]},{"title":"JavaScript数组","slug":"knowledges/JavaScript数组","date":"2020-02-06T13:10:40.000Z","updated":"2024-02-18T08:09:28.000Z","comments":true,"path":"/knowledges/javascript-shu-zu.html","link":"","permalink":"https://qw8.github.io/knowledges/javascript-shu-zu.html","excerpt":"","text":"数组方法 Array.length：数组的大小 join()：用指定的分隔符将数组每一项拼接为字符串 push() ：向数组的末尾添加新元素，返回值为添加完后的数组的长度 pop()：删除数组的最后一项，返回值是删除的元素 shift()：删除数组的第一项， 返回值是删除的元素 unshift()：向数组首位添加新元素，返回值是添加完后的数组的长度 slice()：按照条件查找出其中的部分元素 splice()：对数组进行增删改 fill(): 方法能使用特定值填充数组中的一个或多个元素 filter():“过滤”功能 concat()：用于连接两个或多个数组 indexOf()：检测当前值在数组中第一次出现的位置索引 lastIndexOf()：检测当前值在数组中最后一次出现的位置索引 every()：判断数组中每一项都是否满足条件 some()：判断数组中是否存在满足条件的项 includes()：判断一个数组是否包含一个指定的值 sort()：对数组的元素进行排序 reverse()：对数组进行倒序 forEach()：ES5 及以下循环遍历数组每一项 map()：ES6 循环遍历数组每一项 copyWithin():用于从数组的指定位置拷贝元素到数组的另一个指定位置中 find():返回匹配的值 findIndex():返回匹配位置的索引 Array.toLocaleString()：把数组转换成局部字符串 Array.toString()：将数组转换成一个字符串 flat()、flatMap()：扁平化数组 entries() 、keys() 、values():遍历数组 22个超详细的 JS 数组方法 数组的常用方法1.Array.map()此方法是将数组中的每个元素调用一个提供的函数，结果作为一个新的数组返回，并没有改变原来的数组。 map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。 map() 方法按照原始数组元素顺序依次处理元素。 注意： map() 不会对空数组进行检测。 注意： map() 不会改变原始数组。 字符串数组转数字数组 .map(Number)1234var strArr = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;];var newArr = strArr.map(Number);console.log(newArr);//控制台打印结果 [1,2,3] 数字数组转字符串数组 .map(String)1234var numberArr = [1,2,3];var newArr = numberArr.map(String);console.log(newArr);//控制台打印结果 [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;] map内部函数更改数组内部数据12345//将数组中每个元素乘2返回一个新的数组let arr = [1, 2, 3, 4, 5];let newArr = arr.map(x =&gt; x * 2);//arr= [1, 2, 3, 4, 5] 原数组保持不变//newArr = [2, 4, 6, 8, 10] 返回新数组 2.Array.forEach()此方法是将数组中的每个元素执行传进提供的函数，没有返回值，直接改变原数组，注意和 map 方法区分 123let arr = [1, 2, 3, 4, 5];num.forEach(x =&gt; x * 2);// arr = [2, 4, 6, 8, 10] 数组改变,注意和map区分 3.Array.filter()此方法是将所有元素进行判断，将满足条件的元素作为一个新的数组返回 1234let arr = [1, 2, 3, 4, 5] const isBigEnough =&gt; value =&gt; value &gt;= 3 let newArr = arr.filter(isBigEnough ) //newNum = [3, 4, 5] 满足条件的元素返回为一个新的数组 4.Array.every()此方法是将所有元素进行判断返回一个布尔值，如果所有元素都满足判断条件，则返回 true，否则为 false： 12345let arr = [1, 2, 3, 4, 5] const isLessThan4 =&gt; value =&gt; value &lt; 4 const isLessThan6 =&gt; value =&gt; value &lt; 6 arr.every(isLessThan4 ) //false arr.every(isLessThan6 ) //true 语法:array.every( function ( item, index,arr) {} ) 第一个参数: item,必须,当前元素的值 第二个参数 : index,可选,当前元素在数组中的索引值 第三个参数 : arr,当前元素所处的数组对象 every方法特点(1)循环次数 !== 数组长度 (2)函数内部的return return true : 循环继续 当前元素满足条件,继续判断,如果循环执行完毕还是true,则every的返回值就是true return false : 循环结束,当前元素不满足条件,every的返回值也是false (3)every方法的返回值 return true : 全部元素都满足条件 return false : 有元素不满足条件 注意点: every()方法不会对空数组进行检测 every()方法不会改变原始数组 应用场景 : 开关思想,购物车全选5.Array.some()此方法是将所有元素进行判断返回一个布尔值，如果存在元素都满足判断条件，则返回 true，若所有元素都不满足判断条件，则返回 false： 12345let arr= [1, 2, 3, 4, 5] const isLessThan4 =&gt; value =&gt; value &lt; 4 const isLessThan6 =&gt; value =&gt; value &gt; 6 arr.some(isLessThan4 ) //true arr.some(isLessThan6 ) //false 6.Array.reduce()此方法是所有元素调用返回函数，返回值为最后结果,传入的值必须是函数类型： 1234let arr = [1, 2, 3, 4, 5];const add = (a, b) =&gt; a + b;let sum = arr.reduce(add);//sum = 15 相当于累加的效果 与之相对应的还有一个 Array.reduceRight() 方法，区别是这个是从右向左操作的 7.Array.push()此方法是在数组的后面添加新加元素，此方法改变了数组的长度： 8.Array.pop()此方法在数组后面删除最后一个元素，并返回数组，此方法改变了数组的长度： 1234let arr = [1, 2, 3, 4, 5];arr.pop();console.log(arr); //[1, 2, 3, 4]console.log(arr.length); //4 9.Array.shift()此方法在数组后面删除第一个元素，并返回数组，此方法改变了数组的长度： 1234let arr = [1, 2, 3, 4, 5];arr.shift();console.log(arr); //[2, 3, 4, 5]console.log(arr.length); //4 10.Array.unshift()此方法是将一个或多个元素添加到数组的开头，并返回新数组的长度： 1234let arr = [1, 2, 3, 4, 5];arr.unshift(6, 7);console.log(arr); //[6, 7, 2, 3, 4, 5]console.log(arr.length); //7 11.Array.isArray()判断一个对象是不是数组，返回的是布尔值 12.Array.concat()此方法是一个可以将多个数组拼接成一个数组： 1234let arr1 = [1, 2, 3] arr2 = [4, 5] let arr = arr1.concat(arr2) console.log(arr)//[1, 2, 3, 4, 5] 13.Array.toString() 此方法将数组转化为字符串： 123let arr = [1, 2, 3, 4, 5]; let str = arr.toString() console.log(str)// 1,2,3,4,5 14.Array.join()此方法也是将数组转化为字符串： 1234567let arr = [1, 2, 3, 4, 5]; let str1 = arr.toString() let str2 = arr.toString(',') let str3 = arr.toString('##') console.log(str1)// 12345 console.log(str2)// 1,2,3,4,5 console.log(str3)// 1##2##3##4##5 通过例子可以看出和 toString 的区别，可以设置元素之间的间隔~ 15.Array.splice(开始位置， 删除的个数，元素)万能方法，可以实现增删改： 1234567let arr = [1, 2, 3, 4, 5]; let arr1 = arr.splice(2, 0 'haha') let arr2 = arr.splice(2, 3) let arr1 = arr.splice(2, 1 'haha') console.log(arr1) //[1, 2, 'haha', 3, 4, 5]新增一个元素 console.log(arr2) //[1, 2] 删除三个元素 console.log(arr3) //[1, 2, 'haha', 4, 5] 替换一个元素 分别阐述join()、split()、slice()、splice() join() 用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串。所带的参数为分割字符串的分隔符，默认是以逗号分开。归属于 Array split() 用于把一个字符串通过指定的分隔符进行分隔成数组 slice() 方法可从已有的数组中返回选定的元素。该方法并不会修改数组，而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法 Array.splice() splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。返回的是含有被删除的元素的数组。 判断是否是一个数组四种方法： 1.使用 ECMAScript 5 新增的Array.isArray(); 判断变量有没有数组的某个方法 12345function isArray（val）&#123; if（typeof(val).push ===&apos;undefined&apos;)&#123; return fa &#125;&#125; 2.判断基本类型，使用使用 Object.prototype 上的原生 toString()方法判断 12345Object.prototype.toString.call(null); // &quot;[object Null]&quot;Object.prototype.toString.call(undefined); // &quot;[object Undefined]&quot;Object.prototype.toString.call(“abc”);// &quot;[object String]&quot;Object.prototype.toString.call(123);// &quot;[object Number]&quot;Object.prototype.toString.call(true);// &quot;[object Boolean]&quot; 3.[].constructor 4.使用 instanceof 操作符。 求数组的最大值Math.max.apply(null, 数组) 123var a = [1, 2, 3, 5];alert(Math.max.apply(null, a)); //最大值alert(Math.min.apply(null, a)); //最小值 Array.slice() 与 Array.splice() 的区别？slice – “读取”数组指定的元素，不会对原数组进行修改 语法：arr.slice(start, end) start 指定选取开始位置（含） end 指定选取结束位置（不含） splice “操作”数组指定的元素，会修改原数组，返回被删除的元素 语法：arr.splice(index, count, [insert Elements]) index 是操作的起始位置 count = 0 插入元素，count &gt; 0 删除元素 [insert Elements] 向数组新插入的元素 js删除数组中的元素在JavaScript中，可以通过以下几种方法删除数组中的元素： 使用splice()方法：1234let arr = [1, 2, 3, 4, 5];let index = 2; // 要删除的元素的索引arr.splice(index, 1);console.log(arr); // 输出: [1, 2, 4, 5] 使用splice()方法，可以指定要删除的元素的索引和数量。在上面的例子中，我们删除了索引为2的元素。 使用delete关键字：1234let arr = [1, 2, 3, 4, 5];let index = 2; // 要删除的元素的索引delete arr[index];console.log(arr); // 输出: [1, 2, empty, 4, 5] 使用delete关键字可以删除指定索引处的元素，但是会将该位置的元素设置为undefined，并且不会改变数组的长度。 使用filter()方法：1234let arr = [1, 2, 3, 4, 5];let index = 2; // 要删除的元素的索引arr = arr.filter((value, idx) =&gt; idx !== index);console.log(arr); // 输出: [1, 2, 4, 5] 使用filter()方法，可以通过筛选出不需要删除的元素，重新生成一个新的数组来删除指定索引处的元素。 使用pop()或shift()方法：12345678910let arr = [1, 2, 3, 4, 5];let index = 2; // 要删除的元素的索引if (index === 0) &#123; arr.shift();&#125; else if (index === arr.length - 1) &#123; arr.pop();&#125; else &#123; arr = arr.slice(0, index).concat(arr.slice(index + 1));&#125;console.log(arr); // 输出: [1, 2, 4, 5] 在上面的例子中，如果要删除的元素处于数组的首位，我们使用shift()方法删除该元素；如果要删除的元素处于数组的末尾，我们使用pop()方法删除该元素；否则，我们使用slice()方法删除指定索引处的元素，并将前半部分和后半部分重新拼接成一个新的数组。 请注意，以上代码只是展示了如何删除数组中的元素，实际应用中需要考虑到数组的长度变化以及是否需要保留原数组等因素。 数组去重的方法（参考链接）1、先将原数组进行排序，使重复元素在相邻位置，创建新数组，并赋值元数组的第一项，检查原数组中的第i个元素与新数组中的最后一个元素是否相同，如果不相同，则将该元素存入新数组中。 12345678910function unique(arr)&#123; arr.sort(); //先排序 ，这里不需要参数 var res = [arr[0]]; for (var i = 1; i &lt; arr.length; i++) &#123; if (arr[i] !== res[res.length - 1]) &#123; res.push(this[i]); &#125; &#125; return res;&#125; 2、创建一个空对象和一个空数组，将数组的数值以对象属性的形式保存，并赋值1，push到新数组中，后续遍历数组时通过数组的值以属性的方式访问对象，从而达到验证重复的目的。（较推荐） 1234567891011function unique(arr) &#123; var res = [];var hash = &#123;&#125;;for (var i = 0; i &lt; arr.length; i++) &#123; if (!hash[arr[i]]) &#123; res.push(arr[i]); hash[arr[i]] = 1; &#125; &#125; return res;&#125; 3.扩展运算符和 Set 结构相结合，就可以去除数组的重复成员 123// 去除数组的重复成员[...new Set([1, 2, 2, 3, 4, 5, 5])];// [1, 2, 3, 4, 5] 4.使用set去重 12345678function removeRepeatArr(arr) &#123; return Array.from(new Set(arr));&#125;const arr = [1, 2, 1, 2, 3, 3, 4, 5];console.log(removeRepeatArr(arr));// [ 1, 2, 3, 4, 5 ] 5.ES5 123456789function unique(arry) &#123; const temp = []; arry.forEach(e =&gt; &#123; if (temp.indexOf(e) == -1) &#123; temp.push(e); &#125; &#125;); return temp;&#125; 6.ES6 123function unique(arr) &#123; return Array.from(new Set(arr));&#125; 7.双重for循环依次比较 将结果函数中的元素与原数组中的元素依次比较，重复的元素舍弃，不重复的元素添加仅结果函数。 12345678910111213141516171819202122function removeRepeatArr(arr) &#123; const result = []; for (let i = 0, len = arr.length; i &lt; len; i++) &#123; let isRepeat = false; for (let j = 0, _len = result.length; j &lt; _len; j++) &#123; if (result[j] === arr[i]) &#123; isRepeat = true; break; &#125; &#125; if (!isRepeat) &#123; result.push(arr[i]); &#125; &#125; return result;&#125;const arr = [1, 2, 1, 2, 3, 3, 4, 5];console.log(removeRepeatArr(arr));// [ 1, 2, 3, 4, 5 ] 8.使用hashtable 使用for循环创建hash表 1234567891011121314151617function removeRepeatArr(arr) &#123; const result = []; const hash = &#123;&#125;; for (let i = 0, len = arr.length; i &lt; len; i++) &#123; if (!hash[arr[i]]) &#123; hash[arr[i]] = true; result.push(arr[i]); &#125; &#125; return result;&#125;const arr = [1, 2, 1, 2, 3, 3, 4, 5];console.log(removeRepeatArr(arr));// [ 1, 2, 3, 4, 5 ] 当然也可以用forEach代替for循环 1234567891011121314151617function removeRepeatArr(arr) &#123; const result = []; const hash = &#123;&#125;; arr.forEach((item) =&gt; &#123; if (!hash[item]) &#123; result.push(item); hash[item] = true; &#125; &#125;); return result;&#125;const arr = [1, 2, 1, 2, 3, 3, 4, 5];console.log(removeRepeatArr(arr));// [ 1, 2, 3, 4, 5 ] 方法一： 双层循环，外层循环元素，内层循环时比较值 如果有相同的值则跳过，不相同则push进数组 123456789101112131415161718Array.prototype.distinct = function()&#123; var arr = this, result = [], i, j, len = arr.length; for(i = 0; i &lt; len; i++)&#123; for(j = i + 1; j &lt; len; j++)&#123; if(arr[i] === arr[j])&#123; j = ++i; &#125; &#125; result.push(arr[i]); &#125; return result;&#125;var arra = [1,2,3,4,4,1,1,2,1,1,1];arra.distinct(); //返回[3,4,2,1] 方法二：利用splice直接在原数组进行操作 双层循环，外层循环元素，内层循环时比较值 值相同时，则删去这个值 注意点:删除元素之后，需要将数组的长度也减1. 12345678910111213141516171819Array.prototype.distinct = function ()&#123; var arr = this, i, j, len = arr.length; for(i = 0; i &lt; len; i++)&#123; for(j = i + 1; j &lt; len; j++)&#123; if(arr[i] == arr[j])&#123; arr.splice(j,1); len--; j--; &#125; &#125; &#125; return arr;&#125;;var a = [1,2,3,4,5,6,5,3,2,4,56,4,1,2,1,1,1,1,1,1,];var b = a.distinct();console.log(b.toString()); //1,2,3,4,5,6,56 优点：简单易懂 缺点：占用内存高，速度慢 方法三：利用对象的属性不能相同的特点进行去重 1234567891011121314151617Array.prototype.distinct = function ()&#123; var arr = this, i, obj = &#123;&#125;, result = [], len = arr.length; for(i = 0; i&lt; arr.length; i++)&#123; if(!obj[arr[i]])&#123; //如果能查找到，证明数组元素重复了 obj[arr[i]] = 1; result.push(arr[i]); &#125; &#125; return result;&#125;;var a = [1,2,3,4,5,6,5,3,2,4,56,4,1,2,1,1,1,1,1,1,];var b = a.distinct();console.log(b.toString()); //1,2,3,4,5,6,56 方法四：数组递归去重 运用递归的思想 先排序，然后从最后开始比较，遇到相同，则删除 1234567891011121314151617181920Array.prototype.distinct = function ()&#123; var arr = this, len = arr.length; arr.sort(function(a,b)&#123; //对数组进行排序才能方便比较 return a - b; &#125;) function loop(index)&#123; if(index &gt;= 1)&#123; if(arr[index] === arr[index-1])&#123; arr.splice(index,1); &#125; loop(index - 1); //递归loop函数进行去重 &#125; &#125; loop(len-1); return arr;&#125;;var a = [1,2,3,4,5,6,5,3,2,4,56,4,1,2,1,1,1,1,1,1,56,45,56];var b = a.distinct();console.log(b.toString()); //1,2,3,4,5,6,45,56 方法五：利用indexOf以及forEach 123456789101112131415Array.prototype.distinct = function ()&#123; var arr = this, result = [], len = arr.length; arr.forEach(function(v, i ,arr)&#123; //这里利用map，filter方法也可以实现 var bool = arr.indexOf(v,i+1); //从传入参数的下一个索引值开始寻找是否存在重复 if(bool === -1)&#123; result.push(v); &#125; &#125;) return result;&#125;;var a = [1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,3,3,3,3,3,3,3,2,3,3,2,2,1,23,1,23,2,3,2,3,2,3];var b = a.distinct();console.log(b.toString()); //1,23,2,3 方法六：利用ES6的set Set数据结构，它类似于数组，其成员的值都是唯一的。 利用Array.from将Set结构转换成数组 1234function dedupe(array)&#123; return Array.from(new Set(array));&#125;dedupe([1,1,2,3]) //[1,2,3] 拓展运算符(…)内部使用for…of循环 123let arr = [1,2,3,3];let resultarr = [...new Set(arr)]; console.log(resultarr); //[1,2,3] 下面给大家补充介绍合并数组并去重的方法 一、concat()方法 思路：concat() 方法将传入的数组或非数组值与原数组合并,组成一个新的数组并返回。该方法会产生一个新的数组。 12345function concatArr(arr1, arr2)&#123; var arr = arr1.concat(arr2); arr = unique1(arr);//再引用上面的任意一个去重方法 return arr;&#125; 二、Array.prototype.push.apply() 思路：该方法优点是不会产生一个新的数组。 12345678910var a = [1, 2, 3];var b = [4, 5, 6];Array.prototype.push.apply(a, b);//a=[1,2,3,4,5,6]//等效于:a.push.apply(a, b);//也等效于[].push.apply(a, b); function concatArray(arr1,arr2)&#123; Array.prototype.push.apply(arr1, arr2); arr1 = unique1(arr1); return arr1;&#125; JavaScript 数组的函数 map/forEach/reduce/filter map 12345678910// map//作用：对数组进行遍历//返回值：新的数组//是否改变：否var arr = [2, 5, 3, 4];var ret = arr.map(function(value) &#123; return value + 1;&#125;);console.log(ret); //[3,6,4,5]console.log(arr); //[2,5,3,4] forEach 12345678910// forEach 方法// 作用：遍历数组的每一项// 返回值：undefined// 是否改变：否var arr = [2, 5, 3, 4];var ret = arr.forEach(function(value) &#123; console.log(value); // 2, 5, 3, 4&#125;);console.log(ret); //undefinedconsole.log(arr); //[2,5,3,4] reduce 12345678910// reduce 方法// 作用：对数组进行迭代，然后两两进行操作，最后返回一个值// 返回值：return出来的结果// 是否改变：不会var arr = [1, 2, 3, 4];var ret = arr.reduce(function(a, b) &#123; return a * b;&#125;);console.log(ret); // 24console.log(arr); // [1, 2, 3, 4] filter 1234567891011// filter 过滤// 作用： 筛选一部分元素// 返回值： 一个满足筛选条件的新数组// 是否改变原有数组：不会var arr = [2, 5, 3, 4];var ret = arr.filter(function(value) &#123; return value &gt; 3;&#125;);console.log(ret); //[5,4]console.log(arr); //[2,5,3,4] sort 排序原理冒泡排序法 解析： 冒泡排序法的原理： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 示例： 12345var arr = [1, 5, 4, 2];// sort()方法的比较逻辑为：// 第一轮：1和5比，1和4比，1和2比// 第二轮：5和4比，5和2比// 第三轮：4和2比 1234567891011121314151617181920212223// 一.sort排序规则 return大于0则交换数组相邻2个元素的位置// 二.arr.sort(function (a,b) &#123;&#125;)中// a --&gt;代表每一次执行匿名函时候，找到的数组中的当前项；// b --&gt;代表当前项的后一项；// 1.升序var apple = [45, 42, 10, 147, 7, 65, -74];// ①默认法,缺点:只根据首位排序console.log(apple.sort());// ②指定排序规则法,return可返回任何值console.log( apple.sort(function(a, b) &#123; return a - b; //若return返回值大于0(即a＞b),则a,b交换位置 &#125;));//2.降序var arr = [45, 42, 10, 111, 7, 65, -74];console.log( apple.sort(function(a, b) &#123; return b - a; //若return返回值大于零(即b＞a),则a,b交换位置 &#125;)); 原文：https://blog.csdn.net/soraru/article/details/82255616https://www.cnblogs.com/huoxiao/p/10239284.html","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qw8.github.io/tags/JavaScript/"},{"name":"数组","slug":"数组","permalink":"https://qw8.github.io/tags/数组/"}]},{"title":"JavaScript原型链","slug":"knowledges/JavaScript原型链","date":"2020-01-31T07:10:08.000Z","updated":"2023-04-14T17:01:50.000Z","comments":true,"path":"/knowledges/javascript-yuan-xing-lian.html","link":"","permalink":"https://qw8.github.io/knowledges/javascript-yuan-xing-lian.html","excerpt":"","text":"面向对象原理：​ 1）目标：实现封装、继承、多态等面向对象的基本功能。 ​ 2）原理：原型链是面向对象的基础,使用prototype、function 、new、this模拟面向对象的类。 ​ JavaScript是面向对象语言，但不使用类（根本不存在类）。JavaScript的面向对象是基于prototype和function的，而不是基于类的。 介绍JavaScript的原型，原型链？有什么特点？原型： JavaScript的所有对象中都包含了一个 [proto] 内部属性，这个属性所对应的就是该对象的原型。 JavaScript的函数对象，除了原型 [proto] 之外，还预置了 prototype 属性。 当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型 [proto]。 原型链： 原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链。 当一个对象调用的属性/方法自身不存在时，就会去自己 [proto] 关联的前辈 prototype 对象上去找。 如果没找到，就会去该 prototype 原型 [proto] 关联的前辈 prototype 去找。依次类推，直到找到属性/方法（一直检索到 Object 内建对象）或 undefined 为止。从而形成了所谓的“原型链” 关系：instance.constructor.prototype = instance.__proto__ 原型特点： JavaScript对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变 原型链的基本原理： 任何一个实例，通过原型链，找到它上面的原型，该原型对象中的方法和属性，可以被所有的原型实例共享。 原型可以起到继承的作用，原型里的方法都可以被不同的实例共享。 其他理解： 通过一个对象的proto可以找到它的原型对象，原型对象也是一个对象，就可以通过原型对象的proto，最后找到了我们的 Object.prototype，Object是原型链的顶端。从实例的原型对象开始一直到 Object.prototype 就是我们的原型链。 每个对象都有一个私有属性（称之为 [[Prototype]]），它指向它的原型对象（prototype）。该 prototype 对象又具有一个自己的 prototype ，层层向上直到一个对象的原型为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。 当查找一个对象的属性时，JavaScript 会向上遍历原型链，直到找到给定名称的属性为止，到查找到达原型链的顶部 - 也就是 Object.prototype - 但是仍然没有找到指定的属性，就会返回 undefined 12345678910function Func()&#123;&#125;Func.prototype.name = &quot;Sean&quot;;Func.prototype.getInfo = function() &#123; return this.name;&#125;var person = new Func();//现在可以参考var person = Object.create(oldObject);console.log(person.getInfo());//它拥有了Func的属性和方法//&quot;Sean&quot;console.log(Func.prototype);// Func &#123; name=&quot;Sean&quot;, getInfo=function()&#125; js001 原型、构造函数、实例三者之间的关系 PS：任何一个函数，如果在前面加了new，那就是构造函数。 构造函数通过 new 生成实例 构造函数也是函数，构造函数的prototype指向原型。（所有的函数有prototype属性，但实例没有 prototype属性） 原型对象中有 constructor，指向该原型的构造函数。 上面的三行，代码演示： 12345var Foo = function (name) &#123; this.name = name;&#125;;var fn = new Foo('smyhvae'); 上面的代码中，Foo.prototype.constructor === Foo的结果是true： 实例的__proto__指向原型。也就是说，Foo.__proto__ === M.prototype。 声明：所有的引用类型（数组、对象、函数）都有__proto__这个属性。 Foo.__proto__ === Function.prototype的结果为true，说明Foo这个普通的函数，是Function构造函数的一个实例。 prototype 和proto的关系是什么？所有的对象都拥有proto属性，它指向对象构造函数的 prototype 属性 12345let obj = &#123;&#125;obj.__proto__ === Object.prototype // truefunction Test()&#123;&#125;test.__proto__ == Test.prototype // true 所有的函数都同时拥有proto和 protytpe 属性函数的proto指向自己的函数实现 函数的 protytpe 是一个对象 所以函数的 prototype 也有proto属性 指向 Object.prototype 12function func() &#123;&#125;func.prototype.__proto__ === Object.prototype // true Object.prototype.proto指向 null 1Object.prototype.__proto__ // null 执行时对象查找时，永远不会去查找原型的一个函数是？ javaScript中hasOwnProperty函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员 使用方法： object.hasOwnProperty(proName) 其中参数object是必选项。一个对象的实例。 proName是必选项。一个属性名称的字符串值。 如果 object 具有指定名称的属性，那么JavaScript中hasOwnProperty函数方法返回 true，反之则返回 false。 instanceof的原理 instanceof的作用：用于判断实例属于哪个构造函数。 instanceof的原理：判断实例对象的__proto__属性，和构造函数的prototype属性，是否为同一个引用（是否指向同一个地址）。 注意1：虽然说，实例是由构造函数 new 出来的，但是实例的__proto__属性引用的是构造函数的prototype。也就是说，实例的__proto__属性与构造函数本身无关。 注意2：在原型链上，原型的上面可能还会有原型，以此类推往上走，继续找__proto__属性。这条链上如果能找到， instanceof 的返回结果也是 true。 比如说： foo instance of Foo的结果为true，因为foo.__proto__ === M.prototype为true。 foo instance of Objecet的结果也为true，为Foo.prototype.__proto__ === Object.prototype为true。 instanceof 的内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。 使用 instanceof 判断一个对象是否为数组，instanceof 会判断这个对象的原型链上是否会找到对应的 Array 的原型，找到返回 true，否则返回 false。 1[] instanceof Array; // true 但 instanceof 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true。 1[] instanceof Object; // true 优点：instanceof 可以弥补 Object.prototype.toString.call()不能判断自定义实例化对象的缺点。 缺点：instanceof 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true，且不同于其他两种方法的是它不能检测出 iframes。 12345function f(name) &#123; this.name = name;&#125;var f1 = new f(\"martin\");console.log(f1 instanceof f); //true 推荐阅读: https://www.cnblogs.com/zhoulujun/p/9667651.html","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qw8.github.io/tags/JavaScript/"},{"name":"原型","slug":"原型","permalink":"https://qw8.github.io/tags/原型/"},{"name":"原型链","slug":"原型链","permalink":"https://qw8.github.io/tags/原型链/"},{"name":"instanceof","slug":"instanceof","permalink":"https://qw8.github.io/tags/instanceof/"}]},{"title":"JavaScript知识点","slug":"knowledges/JavaScript知识点","date":"2020-01-18T02:24:57.000Z","updated":"2024-03-28T16:40:44.000Z","comments":true,"path":"/knowledges/javascript-zhi-shi-dian.html","link":"","permalink":"https://qw8.github.io/knowledges/javascript-zhi-shi-dian.html","excerpt":"","text":"[TOC] 概述js一门运行在浏览器语言 js能做什么： 动画效果 页面交互效果 表单提交 与后台进行数据获取/传输 操作页面dom 操作浏览器 nodejs 封装插件 游戏/h5 ….. js诞生记 布兰登 . 艾奇 10天 函数式编程+ 面向对象编程 1995年 js一门弱类型的轻量级解释型（即时编译型）语言 JavaScript的组成 组成 描述 ECMAscript js基本语法 BOM 浏览器对象模型 操作浏览器 DOM 文档对象模型 操作页面/html ECMAScript（核心）：JavaScript 语言基础 DOM（文档对象模型）：规定了访问HTML和XML的接口 BOM（浏览器对象模型）：提供了浏览器窗口之间进行交互的对象和方法 DOM 和 BOM 有什么区别文档对象模型（Document Object Model） DOM 是为了操作文档出现的 API，document 是其的一个对象 DOM 和文档有关，这里的文档指的是网页，也就是 html 文档。DOM 和浏览器无关，他关注的是网页本身的内容。 浏览器对象模型（Browser Object Model） BOM 是为了操作浏览器出现的 API，window 是其的一个对象 window 对象既为 javascript 访问浏览器提供 API，同时在 ECMAScript 中充当 Global 对象 BOM 常用对象 1234561、window对象 ，是JS的最顶层对象，其他的BOM对象都是window对象的属性；2、document对象，文档对象；3、location对象，浏览器当前URL信息；4、navigator对象，浏览器本身信息；5、screen对象，客户端屏幕信息；6、history对象，浏览器访问历史信息； 列举 window 对象的常用方法至少 5 个方法：Alert() confirm() prompt() open() close() 什么是 Window 对象? 什么是 Document 对象? Window 对象表示当前浏览器的窗口，是JavaScript的顶级对象。 我们创建的所有对象、函数、变量都是 Window 对象的成员。 Window 对象的方法和属性是在全局范围内有效的。 Document 对象是 HTML 文档的根节点与所有其他节点（元素节点，文本节点，属性节点, 注释节点），可以使我们可以通过脚本对 HTML 页面中的所有元素进行访问 Document 对象是 Window 对象的一个属性，可通过 window.document 属性对其进行访问 Document对象是Documentd对象（HTML 文档对象）的一个只读引用 js特点 弱类型 解释性/即时编译型 基于对象：一切皆对象 事件驱动：鼠标事件，键盘事件等等 单线程/异步 js引入方式文件后缀： .js 嵌入式 123&lt;script&gt; alert(1);&lt;/script&gt; 外部引入 1&lt;script src=\"js路径\"&gt;&lt;/script&gt; js注释 单行文本注释 1// 单行注释 ctrl + / 多行文本注释 1234/* 多行文本注释*/shift + alt + a 输入输出工具 方法 描述 示例 document.write() 输出内容到body页面 document.write(&quot;hello, world&quot;) prompt() 输入框 prompt(&quot;请输入您的姓名&quot;) alert() 弹出框 alert(22222) console.log() 输出内容到浏览器控制台 console.log(&quot;js真好&quot;) 变量 采用var 声明变量 声明变量规则： image-20200820095245168 严格区分大小写 可以使用字母，_ 或者 $ 开头，不可以使用中文 js命名习惯 驼峰命名法 getElementById 首字母大写： Object 命名要有意义 声明一个变量： var num; 声明多个变量： var a, b, c; 初始化： 先声明再初始化 12var num;num = 1; 声明的同时初始化 12var num = 2;var a = 0, b=1, c; 运算符算术运算符： 加(+)、减(-)、乘()、除(/)、取余(%)、自增(++)、自减(–)、求幂(*) null 和 false 转换成数字是 0 true 转换成数字是 1 undefined 转换不了是 NaN 可以转换成数字的转换成数字进行运算，转换不了就转换成 NaN 所有与字符串进行相加都属于字符串拼接 字符串除了+运算以外，进行其他运算的时候可以转换成数字就转换成数字进行运算， 不可以转换的就是NaN ++n 先运算在输出， n++ 先输出在运算 —n 先运算在输出， n– 先输出在运算 关系(比较)运算符：大于(&gt;)、小于(&lt;)、大于等于(&gt;=)、小于等于(&lt;=)、值相等(==)、值不等(!=)、全等(===)、不全等(!==) 可以转换成数字的转换成数字进行比较，转换不了都是false 字符串和字符串进行比较，对照着ASCII码表一个字符一个字符进行比较 == 代表值相等， === 值相等以及数据类型也相等 赋值运算符：=、+=、-=、=、/=、%=、*= 逻辑运算符：与(&amp;&amp;)、或(||)、非(!) &amp;&amp; 与： 只要有一个是假，结果就是假 || 或 ： 只要有一个是真，结果就是真 ！非 ： 取反 短路原则：&amp;&amp;左边为假右边不执行，||左边为真右边不执行 一元运算符：typeof、new、delete、instanceof等 三元运算符 12条件表达式 ? 表达式为真执行 : 表达式为假执行typeof null == 'object' ? alert(1) : console.log(\"不等\") 特殊运算符： , 逗号， 括号() 123456789101112// 逗号运算符：多个表达式可以用逗号分开，其中用逗号分开的表达式的值分别结算，但整个表达式的值是最后一个表达式的值。var i=0,j=0; for(;j&lt;6,i&lt;10;i++,j++)&#123; k = i+j; &#125; console.log(k);var i=0,j=0;for(;i&lt;10,j&lt;6;i++,j++)&#123; k = i+j; &#125;console.log(k); 流程控制 ​ 流程：代码的执行顺序 机构 描述 顺序结构 代码按照从上到下的顺序执行 选择结构 根据不同的条件来执行不同的代码块 循环结构 代码按照一定的顺序反复执行 选择结构if分支 单路分支 123if(条件)&#123; //条件成立执行&#125; 双路分支 12345if(条件)&#123; //条件成立执行&#125;else&#123; //条件不成立执行&#125; 多路分支 123456789if(条件1)&#123; //条件1成立执行&#125;else if(条件2)&#123; //条件1不成立；条件2成立执行&#125;else if(条件3)&#123; //条件1，条件2不成立；条件3成立执行&#125;else&#123; //条件1，条件2，条件3都不成立&#125; 嵌套分支 12345678910111213if(条件1)&#123; //条件1成立执行 if(条件2)&#123; //条件1成立并且条件2成立执行 &#125;else if(条件3)&#123; //条件1成立并且条件3条件 //条件2不成立 &#125;else&#123; // 条件1成立，条件2/3都不成立执行 &#125;&#125;else&#123; //条件1不成立&#125; switch 分支 12345678910111213switch(需要判断的值)&#123; case 值1： 当需要判断的值==值1，执行代码 break; case 值2： 当需要判断的值==值2，执行代码 break; case 值3： 当需要判断的值==值3，执行代码 break; default: 默认执行&#125; 循环结构 for 循环 123456789101112for (初始值;条件;步进值)&#123; //循环体&#125; 奇数之和var sum = 0;for(i=1;i&lt;100;i++)&#123; if (i%2==1)&#123; sum +=i; continue &#125; &#125;console.log(sum); break 终止循环 continue 跳出当前循环 如果有两个终止条件，以逗号隔开，是逗号运算符，以最后一个终止条件截止 while 循环 123456789while(条件表达式)&#123; //循环体&#125;var i=1;do&#123; document.write(\"&lt;div style='width:40px;height:40px;border- radius:50%;background:red;float:left; text-align: center;line-height: 40px;'&gt;\"+i+\"&lt;/div&gt;\"); i++; &#125;while(i&lt;=100) do while 循环 12345var i=1; do&#123; document.write(\"&lt;div style='width:40px;height:40px;border-radius:50%;border:10px solid red;float:left; text-align: center;line-height: 40px;'&gt;\"+i+\"&lt;/div&gt;\"); i++;&#125;while(i&lt;=100) for和while选择1.存在一直循环次数情况下使用for循环 while循环次数可以不确定 2.使用时优先考虑for循环，当无法写出循环条件的起始结束步进值时考虑用while循环 while和do…while的选择- do while循环的循环体至少执行一次- 当循环的判断条件所需的值来自于循环体时，可以使用do while 循环 函数函数：将包含某一特定的功能的代码封装起来，并且可以重复使用 方便代码重复使用 可以传入不同的参数返回不同的结果 代码更加简洁 函数声明 具名函数 12345678function 函数名称()&#123; 函数体&#125;//例如function fn()&#123; console.log(\"具名函数\")&#125;//函数名称 都是一般都是英文开头 也可以是_开头 不能是是数字 中文 匿名函数 12345678var 变量名=function()&#123; 函数体&#125;//例如var fun = function()&#123; console.log(\"匿名函数\")&#125;//函数名称 都是一般都是英文开头 也可以是_开头 不能是是数字 中文 实例化构造函数 12345var 变量名 = new Function();//例如var b = new Function( console.log(\"实例化构造函数\")); 函数调用 通过括号()调用 12函数名称(); //具名函数调用：fn()变量名(); //匿名函数调用：fun() | b() 自调用 1234567891011121314//第一种(function()&#123; 函数体&#125;)();//第二种(function()&#123; 函数体&#125;());//第三种!function()&#123; 函数体&#125;(); 通过事件方式调用 1&lt;div onclick = \"函数名()\"&gt;&lt;/divs&gt; 注意事项 具名函数可以在函数前后都可以调用匿名函数只能在后面调用前面调用会报错 如果具名函数或者匿名函数函数名或者变量名相同的情况下，后面的函数会将前面的函数替换掉， 在不同的script代码块，不管是具名函数还是匿名函数只能在后面的代码块中调用，前面的代码块中调用会报错。 参数函数根据不同的参数返回不同的结果 类型： 实参：(函数调用时传入的参数) 形参：(函数声明时接收的参数) 1234567//输出1-nfunction fn(n)&#123; //n是形参 for(var i=1;i&lt;=n;i++ ) &#123; document.write(i); &#125;&#125;fn(100);//100是实参 注意事项参数可以是任意类型的数据 参数命名 参数的个数 实参和形参的个数都是一一对应的 1234function fn(num,str)&#123; //num =100;str=\"abc\";&#125;fn(100,\"abc\"); 形参的个数 大于 实参的个数是，多余的形参的值为undefined 1234function fn(num,str,flag)&#123; //num =100;str=\"abc\" flag=undefined;&#125;fn(100,\"abc\"); 形参 小于 实参的情况下,函数在声明的同时会隐式创建arguments对象，多余的实参可以通过arguments这个对象获取 这个arguments只能在函数内部使用 123456789//arguments 只能在函数内部使用function fn(num)&#123; //num =100; console.log(arguments); console.log(arguments.length); //形参的个数 console.log(arguments[1]); //\"abc\" console.log(arguments[2]); //true&#125;fn(100,\"abc\"，true); 函数返回值 需要将函数的结果进行操作，通过return进行函数返回 返回值可以是任意类型的值 终止当前函数 每个函数都有返回值，如果没有返回值，默认返回值是undefined 函数只能返回一个值，如果写多个返回值，返回的是最后一个值 12345function fn()&#123; return 1,true,'abc';&#125;var str = fn();conlose.log(str); //'abc' 简介基本类型和引用类型 摘自《高程3》版本 朋友推荐《高性能JS》这部分讲的比较细致 变量类型 JavaScript 是变量松散类型，不存在定义某个变量必须要保存何种数据类型规则，变量的值及其数据类型可以在脚本的生命周期内改变。 基本类型 引用类型 在将一个值赋值给变量时，解析器必须确定这个值是基本类型值还是引用类型值。 基本类型值 Undefined Null Boolean Number String 引用类型值 引用类型值是保存在内存中的对象，与其他语言不同，JS不允许直接访问内存中的位置，也就是不能直接操作对象的内存空间。 在操作对象时，实际上是在操作对象的引用而不是实际的对象，为此，引用类型的值是按引用访问的。 动态的属性 定义基本类型值和引用类型值的方式是类似的： 创建一个变量并为该变量赋值。 对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。 复制变量值 除了保存的方式不同外，再从一个变量向另一个变量赋值基本类型值和引用类型值时，也不同。 基本类型 如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到心变量分配的位置上。 引用类型 当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为心变量分配的空间中。 不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。 传递参数 所有函数的参数都是按值传递的，但是会根据值的类型——基本类型值、引用类型值产生两种复制方式。 在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。 在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数，或者用ECMAScript的概念来说，就是arguments对象中的一个元素）。 假如将对象obj作为参数传递给函数，当在函数内部重写obj时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。 在向参数传递基本类型的值时，被传递的值会复制给一个局部变量（即命名参数，或者用ECMAScrip的概念来说，就是arguments对象中的一个元素）。 在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量。 类型检测 基本类型使用 typeof 引用类型使用 instanceof 执行环境和作用域概念 执行环境（有时也称环境）。 执行环境定义了变量和函数有权访问的其他数据，决定了他们各自的行为。 每个执行环境都有一个与之关联的变量对象（ varibale object ） 环境中定义的所有变量和函数都保存在这个对象中。 我们编写的代码无法访问这个对象，但是解析器在处理数据时会在后台使用它。 全局执行环境 全局执行环境是最外围的一个执行环境。根据ECMAScript实现所在的宿主环境不用，表示执行环境的对象也不一样。 在Web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。 某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。 全局执行华景知道引用程序退出： 例如关闭网页或浏览器时才会被销毁。 作用域链 当代码在一个环境中执行时，会创建变量对象的一个作用域链。 作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。 作用域链的前端，始终都是当前执行的代码所在环境的变量对象。 如果这个环境是函数，则将其活动对象作为变量对象。 活动对象在最开始时，只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的） 作用域链中的下一个变量对象来自包含（外部）环境，而在下一个变量对象则来自下一个包含环境。这样，一直延续到全局环境。 全局执行环境的变量对象始终都是作用域链中的最后一个对象。 标识解析 沿着作用域链一级一级地搜索标识符的过程。 搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止。 如果找不到标识符，通常会发生错误。 延长作用域链 执行环境的类型总共有两种——全局和局部（函数）。 有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。 try-catch的catch块、 with catch和with 这两个语句都谁在作用域链的前端添加一个变量对象。 对with语句来说，会将指定对象添加到作用域链中。 对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。 在&lt;=IE8版本的JS实现中，存在一个与标准不一致的地方，在catch语句中捕获的错误对象会被添加到执行环境的变量对象，而不是catch语句的变量对象中 没有块级作用域 花括号在JS中并不是一个块级作用域(es6是了)。 声明变量 使用var申明的变量会自动被添加到最接近的环境中。 如果初始化变量时，没有使用var声明，该变量会自动被添加到全局环境。 不声明而直接初始化变量是一个常见的错误做法，在严格模式下，初始化未经声明的变量会导致错误。 查询标识符 当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。 搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。 如果再局部环境中找到了该标识符，搜索过程停止，变量就绪。 如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。 搜索过程将一直追溯到全局环境的变量对象。 如果在全局环境中也没有找到这个标识符，这意味着该变量尚未声明。 作用域 作用域就是一般代码的作用范围 环境： 宿主环境：浏览器 执行环境： 全局环境、全局变量 局部环境/函数环境 eval() 全局环境：在全局环境使用var 声明的变量属于全局变量 局部环境：在函数内部的叫局部环境 12345function fn()&#123; var num =1; console.log(num); //1&#125;console.log(num); //报错num is not defined 作用域链：在函数内部嵌套多个函数，全局环境与多个函数环境进行嵌套，变量会在当前环境中找，如果当前环境中没有则去上一个环境找，直到找到全局环境为止，如果变量在当前环境中找到了，并且在声明变量之前，则该变量是undefined，如果是声明变量之后，则是函数内部变量的值。如果全局环境都没有找到，则报错。 变量提升：js在编译过程中，解释器会把所有声明“移动”，到所在作用域的最上面，而赋值其他逻辑会留在原地，这就是变量提升。 回调函数 将一个函数作为另一个函数的参数，这个函数就叫做回调函数。 1234567function foo(callback)&#123; callback(); console.log(\"主函数\");&#125;foo(function&#123; console.log(\"回调函数\")&#125;) 递归函数使用递归实现一些常用的应用： 递归实现阶乘阶乘是数学上一个常见的算法，类似于上面求和，只是把运算符改为乘法。 11*2*3*4*5*... 12345678function multi(n) &#123; if(n == 1)&#123; return n; &#125; return n*multi(n-1);&#125;console.log(multi(10));//3628800 斐波纳契数列斐波纳契数列，又称黄金分割数列，指的是这样一个数列：1、1、2、3、5、8、13、21、…… 12345678function fibonacci(n) &#123; if (n == 1 || n == 2) &#123; return 1; &#125; return fibonacci(n-1)+fibonacci(n-2); &#125;console.log(fibonacci(10));//55 汉诺塔问题古代有一个梵塔，塔内有三个座A、B、C，A座上有64个盘子，盘子大小不等，大的在下，小的在上。 有一个和尚想把这64个盘子从A座移到C座，但每次只能允许移动一个盘子，并且在移动过程中，3个座上的盘子始终保持大盘在下，小盘在上。在移动过程中可以利用B座。要求输入层数，运算后输出每步是如何移动的。 1234567891011121314function moveDish(level, from, inter, to) &#123; if (level == 1) &#123; console.log(\"从\" + from + \" 移动盘子\" + level + \" 号到\" + to); &#125; else &#123; // 递归调用：将level-1个盘子从from移到inter(不是一次性移动，每次只能移动一个盘子,其中to用于周转) moveDish(level - 1, from, to, inter); // 递归调用，缩小问题的规模 // 将第level个盘子从A座移到C座 console.log(\"从\" + from + \" 移动盘子\" + level + \" 号到\" + to); // 递归调用：将level-1个盘子从inter移到to,from 用于周转 moveDish(level - 1, inter, from, to); // 递归调用，缩小问题的规模 &#125;&#125;moveDish(10,'A','B','C'); 二叉树问题二叉树是一个类似 一分二，二分四，四分为八的树状模型，二叉树的每个节点都有左右两个子节点。 二叉树的第n层有几个节点，这个问题比较简单，它的每层节点树是一个有规律的数列，类似1 2 4 8 16 32 …，使用递归很容易求值。 1234567function tree(n) &#123; if(n==1)&#123; return n; &#125; return 2*tree(n-1);&#125;console.log(tree(10));//512 二叉树深度遍历问题，二叉树的深度可以通过三种方法遍历，前序，中序和后序遍历。 123456789101112131415161718192021222324252627282930313233343536373839function preorderTraversal(root) &#123;//前序 let result = [] let preorder = (root) =&gt; &#123; if (root) &#123; result.push(root.value) preorderTraversal(root.left) preorderTraversal(root.right) &#125; &#125; return result&#125;;function inorder(root) &#123;//中序 let result = [] let inorder = (node) =&gt; &#123; if (!node) &#123; return &#125; inorder(node.left); result.push(node.value); inorder(node.right); &#125; inorder(root) return result&#125;;function postorder(root) &#123;//后序 let result = [] let postorder = (node) =&gt; &#123; if (!node) &#123; return &#125; postorder(node.left) postorder(node.right) result.push(node.value) &#125; postorder(root) return result&#125;; 闭包函数 闭包（closure）是定义在一个外部函数内部，并且能够访问外部函数中变量的函数。 闭包函数的原理是作用链 在函数内部 返回另一个函数 避免全局变量被污染 1234567function fun()&#123; return function()&#123; retrun 1; &#125;&#125;fun()(); 调用到内部的function() 闭包特点： 函数嵌套函数 函数内部可以引用外部的参数和变量 参数和变量不会被垃圾回收机制回收 闭包缺点：常驻内存，会增大内存使用量，使用不当容易造成内存泄漏。 闭包优点： 希望一个局部变量长期驻扎在内存中 避免全局变量的污染 私有成员的存在 1234567function fu(n)&#123; return function(m)&#123; return n*m &#125;&#125;console.log(fu(2)(3)); //6 内置顶层函数 ECMAscript自带的函数 顶层：函数的作用范围，作用范围为全局 - Number() 任意类型数据转化为数字- parselnt() 任意类型数据转化为整数- parseFloat() 任意类型数据转化为浮点数- String0 任意类型数据转化为字符串- Boolean() 任意类型数据转化为布尔值- isNaN) 判断一个数据能否转换为数值，如果能转换成数值返回false，不能返回为true- eval()；将传入的字符串当做 JavaScript 代码进行执行 12eval(\"2+3”)； //6eval(\"alert(1)\")； //弹出1 Number.isFinite()用来检查一个值是否为有限的。Number.isNaN(用来检查一个值是否是NaN。Number.islnteger()用来判断一个值是否为整数。 函数重载后面的函数会将前面的函数覆盖 可以通过argument.length 获取参数的长度 数组 存放一系列相关数据的容器，为了解决大量数据存储 创建数组 隐式创建 内部调用实例化构造函数 1var arr = []; 实例化构造函数 1var arr = new Array(); 数组赋值 创建的同时赋值 123var arr = [1,2,3,4,5,6];var arr = new Array('a','b','c','d'); 创建之后再赋值 数组按照一定的序号进行赋值，这个序号叫下标 数组的下标是从0开始的，数组的长度是：数组名.length 赋值语句：数组名[下标] 123456789101112var arr=[];arr[0]='a';arr[1]='b';arr[3]='d';console.log(arr);//['a','b','c']var arr = new Array();arr[0] =1;arr[1] =2;arr[3] =3;console.log(arr);//[1,2,3]console.log(arr.length); //数组的长度是4 数组访问 通过下标进行访问:数组名[下标] 123var arr =[1,2,3];console.log(arr[0]); //1console.log(arr[2]); //3 通过数组长度访问:数组名.length 数组最后一个数据的下标是数组名.length-1 123var arr=[1,2,3]console.log(arr.length); //3console.log(arr[arr.length-1]); //3 数组遍历 for 1234567var arr[1,2,3];for(var i=0;i&lt;arr.length;i++)&#123; //i 下标 console.log(i); //0 1 2 // arr[i] 下标对于的值 console.log(arr[i]); // 1 2 3&#125; for … in 1234567var arr[1,2,3];for(var i in arr)&#123; //i 下标 console.log(i) //0 1 2 // arr[i] 下标对于的值 console.log(arr[i]); // 1 2 3&#125; image-20200928091108077 image-20200928091123458 12345678910111213141516171819202122232425//数组去重//方法一：var arr =[1,2,3,4,5,6,5,4,3,2,1，1，2];var srr = []for(var i in arr)&#123; if(srr.includes(arr[i]))&#123; continue &#125;else&#123; srr[srr.length]=arr[i] &#125;&#125;console.log(srr);//方法二 for(var i=0;i&lt;arr.length;i++)&#123; for(var j=i+1; j&lt;arr.length;j++)&#123; if(arr[i]==arr[j])&#123; arr.splice(j,1); j--; &#125;else&#123; continue &#125; &#125; &#125; forEach for of 遍历 Math对象Math上的属性 属性 属性描述 PI 返回圆周率（约等于3.14159）。 E 返回算术常量 e，即自然对数的底数（约等于2.718）。 LN2 返回 2 的自然对数（约等于0.693）。 LN10 返回 10 的自然对数（约等于2.302）。31 LOG2E 返回以 2 为底的 e 的对数（约等于 1.414）。 LOG10E 返回以 10 为底的 e 的对数（约等于0.434）。 SQRT1_2 返回返回 2 的平方根的倒数（约等于 0.707）。 SQRT2 返回 2 的平方根（约等于 1.414）。 Math的常用方法​ 加粗表示常用方法 方法 方法描述 Math.abs(x) 返回x的绝对值。 Math.round(x) 返回x四舍五入之后的整数值 Math.ceil(x) 返回x的近似值，向上取整 Math.floor(x) 返回x的近似值，向下取整 Math.max(x,y) 返回x,y中的最大值 Math.min(x,y) 返回x,y中的最小值 Math.random() 返回一个0~1之间的数字 Math.trunc(x) 将x的小数部分去除，返回整数部分(ie不能使用) Math.pow(x,y) 取x的y次幂 Math.sqrt(x) 返回x的平方根 Math.sin(x) 返回x的正弦值 Math.cos(x) 返回x的余弦值 Math.tan(x) 返回x的正切值 Math.asin(x) 返回x的反正弦值 Math.acos(x) 返回x的反余弦值 Math.atan(x) 返回x的反正切值 NumberObject.toFixed(num) 可把 Number 四舍五入为指定小数位数的数字 toFixed() 方法 toFixed() 方法可把 Number 四舍五入为指定小数位数的数字。 12//语法NumberObject.toFixed(num) 参数 描述 num 必需。规定小数的位数，是 0 ~ 20 之间的值，包括 0 和 20，有些实现可以支持更大的数值范围。如果省略了该参数，将用 0 代替。 小技巧 取x的y次方根 1Math.pow(x,1/y) 查找数组中最大和最小的数字 123var arr=[23,4,651,461,1231,411];var maxArr=Math.max(...arr); // arr数组中的最大值var minArr=Math.min(...arr); // arr数组中的最小值 取x-y的随机数、随机整数 12Math.floor( Math.random() * (y - x) + x ) // 包含x不包含yMath.floor( Math.random() * (y - x + 1) + x ) // 包含x包含y 注：取随机整数必须使用Math.floor取整， Math.ceil和Math.round会导致两端的值取到几率变小 生成一个1000到10000之间的随机整数 1let state = Math.ceil(Math.random() * 9000) + 1000 Math.random()函数会生成一个0到1之间的随机小数。然后乘以9000，结果的范围就变成了0到9000。然后使用Math.ceil()函数对结果进行向上取整，确保不会有小数部分。最后再加上1000，结果的范围就变成了1000到10000之间的整数。 字符串(String) 单引号和双引号的区别 在js中单引号和双引号没有区别，都可以表示字符或字符串。 json格式的文件必须使用双引号 属性length :字符串的长度 方法1str.slice(起始下标，结束下标) //返回值是截取的字符串 BOM BOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性，由于BOM主要用于管理窗口与窗口之间的通讯，因此其核心对象是window； window对象window对象属性 属性 描述 可读写性 兼容性 innerWidth 浏览器窗口宽度 只读 &gt;ie8 innerHeight 浏览器窗口高度 只读 &gt;ie8 screen.width 屏幕宽度(分辨率) 只读 全部 screen.height 屏幕高度(分辨率) 只读 全部 top 返回窗口体系中的最顶层窗口的引用 只读 全部 window对象方法 属性 参数 返回值 功能 兼容性 alert string undefined 弹出带有一段消息和一个确认按钮的警告框 全部 confirm string boolean 弹出带有一段消息以及确认按钮和取消按钮的对话框 全部 prompt string undefined 弹出可提示用户输入的对话框 全部 open url 新窗口的window对象引用 通过脚本打开新的窗口 全部 close 无 undefined 关闭当前浏览器窗口 全部 scrollBy xpos,ypos undefined 在窗口中按指定的偏移量滚动文档 全部 scrollTo xpos,ypos undefined 在窗口中将文档滚动到指定位置 全部 定时器 属性 参数 返回值 功能 兼容性 setInterval callback,time(ms)[,param] 该时间函数的id值，可用于取消执行 按照指定时间间隔执行回调函数 一直执行，直到清除 全部(IE9及一下版本不支持该第三个参数) clearInterval name undefined 清除指定时间函数进程 全部 setTimeout callback,time(ms)[,param] 该时间函数的id值，可用于取消执行 在指定的时间后执行回调函数 只执行一次 全部 clearTimeout name undefined 清除指定的延时函数进程 全部 setInterval 与 clearTimeout参数分别是 callback： 必填。 函数，代表指定时间后执行该段代码 time： 必填。 时间间隔，以毫秒计，不写单位 param： 可选。传给执行函数的其他参数，多个参数以,隔开(IE9 及其更早版本不支持该参数) console对象console对象方法 属性 参数 返回值 功能 兼容性 log msg undefined 向 Web 控制台输出一条消息 全部 dir object undefined 打印出对象的所有属性和属性值 &gt;ie8 error msg undefined 向 Web 控制台输出一条错误消息 &gt;ie7 warn msg undefined 向 Web 控制台输出一条警告信息 &gt;ie7 time timerName undefined 启动一个计时器（timer）来跟踪某一个操作的占用时长 &gt;ie10 timeEnd timerName undefined 停止一个通过 console.time() 启动的计时器 &gt;ie10 location 对象 一个完整的url 包括9个部分 协议://用户名：密码@域名：端口/路径；参数？查询#片段 不过几乎没有哪个url包含这些所有组件，最重要的三部分是协议，域名和路径。 location 对象属性1http://www.baidu.com:80/javascript/?file=001/BOM/README.md/#location对象 属性 描述 可读写性 结果 href 包含整个URL的一个字符串 读写 http://www.baidu.com:80/javascript/001/BOM/?file=README.md#location对象 origin 包含页面来源的域名的标准形式字符串 只读 http://www.baidu.com:80 protocol 包含URL对应协议的字符串，最后有一个”:” 只读 http: host 包含了域名和端口号的字符串，如没有端口号则只有域名 只读 www.baidu.com:80 hostname 包含URL域名的字符串 只读 www.baidu.com port 包含端口号的字符串 只读 80 pathname 包含URL中路径部分的字符串，开头有一个”/“ 只读 /javascript/001/BOM/ search 包含URL参数（查询字符串）的字符串，开头有一个“?” 只读 ?file=README.md hash 包含块标识符的字符串，开头有一个”#” 只读 #location对象片段 location 对象方法 属性 参数 返回值 功能 兼容性 assign url undefined 加载给定URL的内容资源 全部 reload Boolean undefined 重新加载来自当前 URL的资源(刷新本页) 全部 replace url undefined 用给定的URL替换掉当前的资源 全部 toString 无 包含整个URL的字符串 获取本窗口的url(只能获取，无法修改，读取效果与location.href相同) 全部 location.reload 的参数： false或未写参数：检测服务器上的文档是否已改变。如果文档已改变，reload() 会再次下载该文档。如果文档未改变，则该方法将从缓存中装载文档。这与用户单击浏览器的刷新按钮的效果是完全一样的。 true：那么无论文档的最后修改日期是什么，它都会绕过缓存，从服务器上重新下载该文档。这与用户在单击浏览器的刷新按钮时按住 Shift 健的效果是完全一样。 history 对象history 对象属性 属性 描述 可读写性 兼容性 length 包含当前页面在内的历史记录个数 只读 全部 history 对象方法 属性 参数 返回值 功能 兼容性 back 无 undefined 加载 history 列表中的前一个 URL(等价于history.go(-1)) 全部 forward 无 undefined 加载 history 列表中的下一个 URL(等价于history.go(1)) 全部 go number undefined 通过当前页面的相对位置从浏览器历史记录加载页面 全部 js刷新本页面方法汇总： history.go(0) location.reload() js跳转页面方法汇总： window.open(url) 1.点击某一个链接之后跳转到新页面显示 1window.open('http://www.baidu.com','_blank'); 2.需要刷新当前页面或者覆盖当前页面 1window.open('http://www.baidu.com','_self'); location.href = “” location.assign(url) Navigator 对象Navigator的属性 属性 描述 值 language 返回当前浏览器的语言 “zh-CN”、”en”等 cookieEnabled 返回指明浏览器中是否启用 cookie 的布尔值 true,false onLine 返回指明系统是否处于联网状态的布尔值 true,false platform 返回运行浏览器的操作系统平台。 “Win32”, “Linux i686”, “MacPPC”, “MacIntel”, 等 userAgent 返回由客户机发送服务器的 user-agent 头部的值 userAgent: “Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36” var与let的区别 let是es6里面的声明变量 用var声明的变量会进行变量提升 123456&#123; let a=1; var b=2;&#125;a//报错b//2 使用let声明的变量不存在变量提升，作用域为块级作用域 1234567891011//使用letfor(let i=0;i&lt;5;i++)&#123; console.log(i); // 0 1 2 3 4&#125;console.log(i) //报错：i is not defined//使用varfor(let i=0;i&lt;5;i++)&#123; console.log(i);//0 1 2 3 4&#125; console.log(i);//5 let不允许在相同作用域内，重复声明同一个变量,var声明的变量后面的会把前面的覆盖掉。 123456&#123; let num=10; let num=20; comsole.log(num); //报错 'num' has already been declared&#125; 常见问题： 1234567891011121314151617//使用varfor(vari=0;i&lt;10;i++)&#123; setTimeout(function()&#123; //执行此代码时，同步代码for循环已经执行完成，结果为10 console。log(i); &#125;，0)&#125;// 使用letfor(let i=0;i&lt;10;i++)&#123; setTimeout(function() &#123; //i是循环体内局部作用域，不受外界影响 console.log(i); &#125;, 0);&#125;//输出结果0 1 2 3 4 5 6 7 8 9 事件基础鼠标事件 事件 描述 onclick 点击 ondblclick 双击 onmousedown 按下 onmouseup 抬起 onmousemove 移动 onmouseover 移入 onmouseout 移出 onmouseenter 鼠标指针移动到元素上时触发(不支持冒泡) onmouseleave 鼠标指针移出元素上时触发(不支持冒泡) oncontextmenu 右键 键盘事件 事件 描述 onkeydown 按下 onkeyup 抬起 onkeypress 按下(只能触发数字字母符号) 表单事件 事件 描述 onfocus 获得焦点 onblur 失去焦点 onchange 失去焦点并内容改变 onsubmit 提交事件（form标签事件） onreset 重置事件（form标签事件） oninput 表单输入 其他事件 事件 描述 onscroll 滚动条事件(滚动条位置改变) onwheel 鼠标滚轮事件 onresize 页面尺寸改变 onload 页面加载完成之后执行该事件 DOMContentLoaded 页面结构加载完成执行该事件 事件高级绑定事件的方式 标签绑定事件 123456&lt;button onclick=\"click_fn()\"&gt;click&lt;/button&gt;&lt;script&gt; function click_fn()&#123; console.log(this); &#125;&lt;/script&gt; Document对象来绑定事件 注意：重复监听某一事件，后者会覆盖前者，而不会两者先后触发 1234567891011&lt;button&gt;click&lt;/button&gt;&lt;script&gt; var button1 = document.querySelector('button') button1.onclick=function()&#123; console.log(\"第一个点击事件的方法\"); &#125; var button2 = document.querySelector('button') button2.onclick=function()&#123; console.log(\"第二个点击事件的方法\"); &#125; //第二个点击事件的方法会覆盖第一个方法,所以点击只会触发第二次的点击事件方法 &lt;/script&gt; 事件监听 为一个事件添加多个事件处理程序，解决了上面两种方法不能添加多个方法 更精细的控制事件监听器的触发阶段 1234567891011121314151617181920212223242526272829303132dom元素.addEventListener(event,callback,bool);//事件监听的语法 dom元素.addEventListener(event,callback,bool);//参数 事件没有On 函数， 布尔类型//布尔类型 true 捕获阶段， false 冒泡阶段。//兼容性问题标签.addEventListener(\"事件名称\",function()&#123;&#125;,false); //兼容到IE9及其以上标签.attachEvent(\"事件名称\",function()&#123;&#125;) // ie8及以下//处理ie8兼容性问题// $box.attachEvent('onclick',fun); // 添加// $box.detachEvent('onclick',fun); //移除//移除事件dom元素.removeEventListener(event,callback,bool);//例子&lt;button id=\"myBtn\"&gt;&lt;/button&gt;&lt;script type=\"text/javascript\"&gt; var btn=document.getElementById('myBtn'); function handle()&#123; console.log(this); &#125; //兼容到IE9及其以上 btn.addEventListener('click',handle,false); //添加事件处理程序 btn.removeEventListener('click',handle,false); //移除事件处理程序 // ie8及以下 btn.attachEvent('onclick',handle); // 添加 btn.detachEvent('onclick',handle); // 移除&lt;/script&gt; 事件对象 在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的信息。所有浏览器都支持event对象，但支持方式不同。 12345678910111213141516171819202122&lt;div class=\"bos\"&gt;&lt;/div&gt;&lt;script&gt; let $bos = document.querySelector(\".bos\") let $body = $bos.parentElement; console.log($body); $body.onclick=function(event)&#123; //鼠标 距离浏览器窗口的横向距离和纵向距离 // console.log(event.clientX); // console.log(event.clientY); //鼠标 距离事件源的位置 事件源输出事件源 事件源是body所有的元素 console.log(event.target); console.log(event.offsetX); // console.log(event.offsetY); //当鼠标事件发生的时候，鼠标相对于浏览器X轴的位置，包含页面横向滚动距离 // 当鼠标事件发生的时候，鼠标相对于浏览器X轴的位置，包含页面纵向滚动距离 // console.log(event.pageX); // console.log(event.pageY); &#125; // document.onkeydown=function(event)&#123; // console.log(event.ctrlKey); // &#125;&lt;/script&gt; 兼容性写法 12345678&lt;div id=\"box\" style=\"height:30px;width:200px;background:pink;\"&gt;&lt;/div&gt;&lt;script&gt;var oBox = document.getElementById('box');oBox.onclick = function(e)&#123; e = e || event; box.innerHTML = e;&#125;&lt;/script&gt; 事件对象常用的方法和属性鼠标事件相关 属性 含义 clientX 当鼠标事件发生的时候，鼠标相对于浏览器X轴的位置 clientY 当鼠标事件发生的时候，鼠标相对于浏览器Y轴的位置 offsetX 当鼠标事件发生的时候，鼠标相对于事件源X轴的位置 offsetY 当鼠标事件发生的时候，鼠标相对于事件源Y轴的位置 pageX 当鼠标事件发生的时候，鼠标相对于浏览器X轴的位置，包含页面横向滚动距离 pageY 当鼠标事件发生的时候，鼠标相对于浏览器X轴的位置，包含页面纵向滚动距离 滚轮事件相关 属性 含义 wheelDelta 滚动量 123e.wheelDelta上： 120 240下：-120 -240 键盘事件相关 属性 含义 key 获取当前所按键的名称 keyCode 获取当前所按键的键盘码 ctrlKey 判断当前ctrl键是否按下的状态 shiftKey 判断当前shift键是否按下的状态 altKey 判断当前alt键是否按下的状态 其他属性和方法 属性 含义 preventDefault() 阻止浏览器默认行为 stopPropagation() 阻止事件流的传播 currentTarget 指向被绑定事件的元素 target 指向事件触发的对象，当事件是处在冒泡或者捕获阶段调用的时候，指向最先触发事件的事件源 type 返回当前所触发事件的事件名称 事件流 事件发生时会在元素节点与根节点之间按照特定的顺序传播，路径所经过的所有节点都会收到该事件，这个传播过程即DOM事件流。 事件传播的顺序对应浏览器的两种事件流模型：捕获型事件流和冒泡型事件流。 冒泡型事件流：事件的传播是从最特定的事件目标到最不特定的事件目标。 捕获型事件流：事件的传播是从最不特定的事件目标到最特定的事件目标。 DOM事件流DOM标准规定事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。eventPhase属性返回一个整数值，表示事件目前所处的事件流阶段:0表示事件没有发生，1表示捕获阶段，2表示目标阶段，3表示冒泡阶段 事件捕获阶段：实际目标在捕获阶段不会接收事件。也就是在捕获阶段，事件从document到再到&lt;html&gt;就停止了。 处于目标阶段：事件在&lt;div&gt;上发生并处理。但是事件处理会被看成是冒泡阶段的一部分。 冒泡阶段：事件又传播回文档。 所有的事件都要经过捕获阶段和处于目标阶段，但是有些事件会跳过冒泡阶段：如，获得输入焦点的focus事件和失去输入焦点的blur事件。 事件委派 事件委派的原理用到的就是事件冒泡和目标元素，把事件处理器添加到父元素，等待子元素事件冒泡，并且父元素能够通过target（IE为srcElement）判断是哪个子元素，从而做相应处理。 e.target获取到目标源 用法 子元素的事件加到父元素上 触发事件时判断 触发该事件的元素是什么（e.target） 判断内容 innerHTML innerText 标签名 nodeName (判断的时候，标签名需要大写) 属性 e.target.hasAttribute(“属性名”); 有则是true 无则是false 类名 ID e.target.classList.contains(“类名”)； 有则是true 无则是false 在判断成功中写对应的处理函数 应用场合 需要给大量元素添加同一事件处理程序的时候，提高代码运行的效率 在页面加载完成后新创建的元素， 比如通过ajax异步加载生成dom对象 Ajax 为什么使用ajax 以前通过使用form表单来提交或者请求数据，由于表单必须是在response请求返回成功之后继续执行，那么在请求数据的同时用户是不能在页面进行操作的，所以2005年才正式被大众使用 ajax是什么 一种用于创建快速动态网页的技术，在不刷新整个页面的情况下对页面的某一部分进行更新。 a——异步 j——-jacascript a——and x——xml(1、svg格式，2、存储数据) 作用有哪些 发送数据：在不重新加载页面的情况下发送数据请求 接收数据：接收并使用从服务器发来的数据 应用场景：增删改查，数据验证 步骤 创建XMLHttpRequest()实例 调用xhr.open() ‘方式’ ‘地址 ’‘ 发送HTTP请求：调用xhr.send() get发送 时在地址上 xhr.responseType=”json | text | xml” 设置响应数据的格式 监视 xhr.onreadystatechange 判断是否与服务器响应成功 xhr.readystate==4 响应成功数据是否成功 xhr.status 更新网页数据 使用方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;script&gt; // 创建ajax XMLHttpRequest实例化对象 var xhr=new XMLHttpRequest();// 告诉xhr去哪儿拿/怎么去，// 请求方式/* 1.get 获取数据 发送数据字符串的时候是将Url+date进行拼接 2.put 修改数据 3.delete 删除数据 4.post 提交数据 直接调用对象 5.options 等待 */// 请求地址：没有服务器，可以使用json 数据来代替//xhr.open(\"请求方式\"，\"请求地址\",\"同步false还是异步true\")xhr.open('get','demo.json',true)// 出发/发送xhr.send();// 时刻监视数据动向xhr.onreadystatechange=()&gt;=&#123; /* xhr.readyState 返回整数： 0 send方法还没有调用 1 send方法已经调用，正在发送请求 2 send方法发送成功，已经接受响应内容 3.正在解析内容 4.响应完成，可以在客户端使用了 */ // 响应成功 if(xhr.readyState == 4)&#123; /* xhr.status 返回状态码： 200 表示成功 304 代表有缓存文件 401 代表未授权 403 代表禁止访问 404 代表未找到服务器 500 服务器内部错误 */ if(xhr.status == 200)&#123; //数据成功返回 document.write(\"大功告成\") &#125;else&#123; //数据返回失败 document.write(\"惨不忍睹\") &#125; &#125;else&#123; //正在请求数据&#125;&#125;&lt;/script&gt; get 和 post的区别 发送数据的方式不同：get携带在地址栏上，post实在调用的send方法的时候携带 功能：get是从服务器上获取数据（查询），post是像服务器上传递数据（增加/提交） 数据量：get的地址不可过长，ie浏览器对字节有限制2083字节，post传送的数据量大，不受限制 安全性：get请求的数据会被缓存起来，可以在历史记录中读取，post相对安全性能高 123456789//get 形式传参数xhr.open('get','./test.json?username=aa&amp;password=123456',true)xhr.send()//post形式传参数xhr.post('post','./test.json',true);//post请求设置头信息xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded;charset=utf-8');xhr.send(传递的数据); 属性描述 属性 描述 response 响应返回的数据题，数据类型有responseType来决定 responseType 该值能够改变响应数据类型 responseText 响应数据文本 responseXML 响应数据返回document对象 ajax其他方法 事件 含义 onabort 当发生中止事件时触发的事件 onerror 当发生加载错误是触发的事件 onload 当加载结束后触发的事件，不论成功与否 onloadend 加载结束后触发的事件 onloadstart 当加载开始时触发的事件 onprogress 在加载过程中不断触发的事件 ontimeout 加载超时后执行的事件 实例化XMLHttpRequest()兼容性 1var xhr = window.XMLHttpRequest?new XMLHttpRequest():new ActiveXObject(\"Miscrosoft.XMLHTTP\") 跨域 同源 源是指协议、域名、端口，若地址里面的协议、域名、端口号均相同则属于同源，三者有一个不同则代表着不同源 同源策略 同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源 跨域的解决方式 jsonp 第三方代理、例如nginx 后台设置允许跨域 123456789图片改变时显示当前图片function filechange(c)&#123; var fr = new FileReader(); //创建NEW FileRaader()对象 var imgobj=c.files[0]; //获取图片 fr.readAsDataURL(imgobj);//将图片读取为DataURL fr.onload=function()&#123; $(\"editDialog img\")[0].src=this.result; &#125;&#125; image-20201014174826954 image-20201014174841351 history 对象详解 我们浏览一个网页时可能不太会注意网页前进后退这些操作，但是在开发时你是否想过页面之间的跳转经历了什么，浏览器时怎么保存的页面信息，重新返回上一个页面的时候是否需要重新加载页面呢，会有很对疑问，要想解决这些问题，首先需要知道浏览器中的window下的history对象，本文来详细总结一下该对象的相关知识点。 history 对象表示当前窗口首次使用以来用户的导航历史记录。因为 history 是 window 的属性，所以每个 window 都有自己的 history 对象。出于安全考虑，这个对象不会暴露用户访问过的 URL，但可以通过它在不知道实际 URL 的情况下前进和后退。 1、路由导航 history.go() 方法可以在用户历史记录中沿任何方向导航，可以前进也可以后退。这个方法只接收一个参数，这个参数可以是一个整数，表示前进或后退多少步。 123456history.go(-1);// 后退一页history.go(1);// 前进一页history.go(2);// 前进两页// go() 有两个简写方法： back() 和 forward() 。history.back();// 后退一页history.forward();// 前进一页 history 对象还有一个 length 属性，history.length == 1表示这是用户窗口中的第一个页面 histroy的go方法，back方法、forword方法以及用户在浏览器手动的前进后退按钮都会导致页面刷新后跳转。 2、历史状态管理API （1）hashchange 事件 hashchange：history 对象的一个新特性是hashchange，会在页面 URL 的散列变化时被触发，开发者可以在此时执行某些操作。当URL的片段标识符更改时，将触发hashchange事件 (跟在＃符号后面的URL部分，包括＃符号)。而状态管理API 则可以让开发者改变浏览器 URL 而不会加载新页面。比如：pushState和replaceState方法，页面并不会刷新，但是路由会发生改变。 （2）popstate 事件 当活动历史记录条目更改时，将触发popstate事件。如果被激活的历史记录条目是通过对history.pushState（）的调用创建的，或者受到对history.replaceState（）的调用的影响，popstate事件的state属性包含历史条目的状态对象的副本。需要注意的是调用history.pushState()或history.replaceState()不会触发popstate事件。只有在做出浏览器动作时，才会触发该事件，如用户点击浏览器的回退按钮（或者在Javascript代码中调用history.back()或者history.forward()方法） （3）history.pushState() 方法 pushState() 方法向当前浏览器会话的历史堆栈中添加一个状态（state）。这个方法接收 3 个参数：一个 state 对象、一个新状态的标题和一个（可选的）相对 URL。pushState() 方法执行后，状态信息就会被推到历史记录中，浏览器地址栏也会改变以反映新的相对 URL。URL栏显示新地址, 但是不会加载 页面，甚至不会检查页面是否存在，该方法会增加history.length （4）history.replaceState()方法 replaceState()方法修改当前历史记录实体。这个方法接收 3 个参数：一个 state 对象、一个新状态的标题和一个（可选的）相对 URL。replaceState() 方法执行后，将会更新当前的state对象或者当前历史实体的URL来响应用户的的动作,URL栏显示新地址, 但是不会加载 页面，甚至不会检查页面是否存在。该方法不会增加history.length。 1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;button onclick=&quot;handleNext()&quot;&gt;点我到下一页&lt;/button&gt;&lt;br&gt; &lt;button onclick=&quot;handleLast()&quot;&gt;点我到上一页&lt;/button&gt;&lt;br&gt; &lt;script&gt; window.onload = function () &#123; console.log(window.history); &#125; window.addEventListener(&apos;hashchange&apos;, function () &#123; console.log(&apos;The hash has changed!&apos;) &#125;, false); window.addEventListener(&apos;popstate&apos;, (event) =&gt; &#123; console.log(&quot;location: &quot; + document.location + &quot;, state: &quot; + JSON.stringify(event.state)); &#125;); function handleNext() &#123; const state = &#123; userId: &quot;1234&quot;, page: &quot;2&quot; &#125; const title = &apos;二&apos; const url = &apos;page2.html&apos; window.history.pushState(state, title, url) console.log(window.history); &#125; function handleLast() &#123; const state = &#123; userId: &quot;1234&quot;, page: &quot;21&quot; &#125; const title = &apos;一&apos; const url = &apos;page21.html&apos; window.history.replaceState(state, title, url) console.log(window.history); &#125; &lt;/script&gt;&lt;/body&gt; 运行结果如下： img 3、补充：URL的hash URL的hash也就是锚点(#), 本质上是改变window.location的href属性，我们可以通过直接赋值location.hash来改变href, 但是页面不发生刷新,如下图所示： img https://www.cnblogs.com/zaishiyu/p/15513220.html 兼容性问题 document.body与document.docunmentElement 12//例如document.body.scrollTop=document.documentElement.scrollTop=0; 1234567//兼容到IE9及其以上 btn.addEventListener('click',handle,false); //添加事件处理程序 btn.removeEventListener('click',handle,false); //移除事件处理程序// ie8及以下btn.attachEvent('onclick',handle); // 添加btn.detachEvent('onclick',handle); // 移除 实例化XMLHttpRequest()兼容性 1var xhr = window.XMLHttpRequest?new XMLHttpRequest():new ActiveXObject(\"Miscrosoft.XMLHTTP\") cdn.js在线地址 http://www.bootcdn.cn/jquery/ https://code.jquery.com/ http://cdn.code.baidu.com/ console.log(‘距离顶部高度’,this.$refs.view.getBoundingClientRect().top);","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qw8.github.io/tags/JavaScript/"}]},{"title":"JavaScript作用域","slug":"knowledges/JavaScript作用域","date":"2020-01-07T13:10:40.000Z","updated":"2023-04-14T17:01:50.000Z","comments":true,"path":"/knowledges/javascript-zuo-yong-yu.html","link":"","permalink":"https://qw8.github.io/knowledges/javascript-zuo-yong-yu.html","excerpt":"","text":"作用域的概念及作用概念： 对变量起保护作用的一块区域，一个函数可以访问其他函数中的变量。 在Java、C等语言中，作用域为for语句、if语句或{}内的一块区域，称为作用域； 而在 JavaScript 中，作用域为function(){}内的区域，称为函数作用域。 作用： 作用域外部无法获取到作用域内部声明的变量，作用域内部能够获取到作用域外界声明的变量。 分类：块作用域、词法作用域、动态作用域 1 块作用域 花括号 {} 2 词法作用域（js 属于词法作用域）作用域只跟在何处被创建有关系，跟在何处被调用没有关系 3 动态作用域作用域只跟在何处被调用有关系，跟在何处被创建没有关系 说说你对作用域链的理解全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节 当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，直至全局函数，这种组织形式就是作用域链 作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到 window 对象即被终止，作用域链向下访问变量是不被允许的。 什么是闭包（closure），为什么要用它？闭包是指有权访问另一个函数作用域中变量的函数。定义一个函数就开辟了一个局部作用域，整个 js 执行环境有一个全局作用域（闭包是一个受保护的变量空间） 创建闭包的最常见的方式：就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。 闭包的特性： 函数内再嵌套函数 内部函数可以引用外层的参数和变量 参数和变量不会被垃圾回收机制回收 1234567891011121314151617//li节点的onclick事件都能正确的弹出当前被点击的li索引 &lt;ul id=&quot;testUL&quot;&gt; &lt;li&gt; index = 0&lt;/li&gt; &lt;li&gt; index = 1&lt;/li&gt; &lt;li&gt; index = 2&lt;/li&gt; &lt;li&gt; index = 3&lt;/li&gt;&lt;/ul&gt;&lt;script type=&quot;text/javascript&quot;&gt; var nodes = document.getElementsByTagName(&quot;li&quot;); for(i = 0;i&lt;nodes.length;i+= 1)&#123; nodes[i].onclick = (function(i)&#123; return function() &#123; console.log(i); &#125; //不用闭包的话，值每次都是4 &#125;)(i); &#125;&lt;/script&gt; 执行say667()后,say667()闭包内部变量会存在,而闭包内部函数的内部变量不会存在 使得Javascript的垃圾回收机制GC不会收回say667()所占用的资源 因为say667()的内部函数的执行需要依赖say667()中的变量 这是对闭包作用的非常直白的描述 123456789101112function say667() &#123; // Local variable that ends up within closure var num = 666; var sayAlert = function() &#123; alert(num); &#125; num++; return sayAlert;&#125; var sayAlert = say667(); sayAlert()//执行结果应该弹出的667 123456789var f = (function fn() &#123; var name = 1; return function () &#123; name++; console.log(name) &#125;&#125;)()==&gt;undefined 有疑问 JavaScript变量声明提升 在JavaScript中，函数声明与变量声明经常被JavaScript引擎隐式地提升到当前作用域的顶部。 声明语句中的赋值部分并不会被提升，只有名称被提升 函数声明的优先级高于变量，如果变量名跟函数名相同且未赋值，则函数声明会覆盖变量声明 如果函数有多个同名参数，那么最后一个参数（即使没有定义）会覆盖前面的同名参数 解释 JavaScript 中的作用域与变量声明提升？ 我对作用域的理解是只会对某个范围产生作用，而不会对外产生影响的封闭空间。在这样的一些空间里，外部不能访问内部变量，但内部可以访问外部变量。 所有申明都会被提升到作用域的最顶上 同一个变量申明只进行一次，并且因此其他申明都会被忽略 函数声明的优先级优于变量申明，且函数声明会连带定义一起被提升 使用 let、var 和 const 创建变量有什么区别用 var 声明的变量的作用域是它当前的执行上下文，它可以是嵌套的函数，也可以是声明在任何函数外的变量。let 和 const 是块级作用域，意味着它们只能在最近的一组花括号（function、if-else 代码块或 for 循环中）中访问。 1234567891011121314function foo() &#123; // 所有变量在函数中都可访问 var bar = \"bar\"; let baz = \"baz\"; const qux = \"qux\"; console.log(bar); // bar console.log(baz); // baz console.log(qux); // qux&#125;console.log(bar); // ReferenceError: bar is not definedconsole.log(baz); // ReferenceError: baz is not definedconsole.log(qux); // ReferenceError: qux is not defined 1234567891011if (true) &#123; var bar = \"bar\"; let baz = \"baz\"; const qux = \"qux\";&#125;// 用 var 声明的变量在函数作用域上都可访问console.log(bar); // bar// let 和 const 定义的变量在它们被定义的语句块之外不可访问console.log(baz); // ReferenceError: baz is not definedconsole.log(qux); // ReferenceError: qux is not defined var 会使变量提升，这意味着变量可以在声明之前使用。let 和 const 不会使变量提升，提前使用会报错。 1234567891011console.log(foo); // undefinedvar foo = \"foo\";console.log(baz); // ReferenceError: can't access lexical declaration 'baz' before initializationlet baz = \"baz\";console.log(bar); // ReferenceError: can't access lexical declaration 'bar' before initializationconst bar = \"bar\"; 用 var 重复声明不会报错，但 let 和 const 会。 123456var foo = \"foo\";var foo = \"bar\";console.log(foo); // \"bar\"let baz = \"baz\";let baz = \"qux\"; // Uncaught SyntaxError: Identifier 'baz' has already been declared let 和 const 的区别在于：let 允许多次赋值，而 const 只允许一次。 1234567// 这样不会报错。let foo = \"foo\";foo = \"bar\";// 这样会报错。const baz = \"baz\";baz = \"qux\"; 解析：参考 变量声明提升js 代码在运行前都会进行 AST 解析，函数申明默认会提到当前作用域最前面，变量申明也会进行提升。 但赋值不会得到提升。关于 AST 解析，这里也可以说是形成词法作用域的主要原因 js 属于哪种作用域词法作用域（函数作用域） 解析： 12345678910111213141516171819202122232425262728293031323334353637// 块作用域/*&#123; var num =123; &#125; console.log(num);*/// 如果js属于块作用域，那么在花括号外部就无法访问到花括号内部的声明的num变量。// 如果js不属于块级作用域，那么花括号外部就能够访问到花括号内部声明的num变量// 能够输出num变量，也就说明js不属于块级作用。// 在ES6 之前的版本js是不存在块级作用域的。//js属于词法作用域还是动态作用域// js中函数可以帮我们去形成一个作用域/* function fn()&#123; var num =123; &#125; fn(); //在函数外界能否访问到num这样一个变量 console.log(num)*/ //Uncaught ReferenceError: num is not defined// 如果函数能够生成一个作用域，那么在函数外界就无法访问到函数内部声明的变量。// js中的函数能够生成一个作用。 函数作用域 。// 词法作用域：作用的外界只跟作用域在何处创建有关系，跟作用域在何处被调用没有关系var num = 123;function f1() &#123; console.log(num); //&#125;function f2() &#123; var num = 456; f1(); //f1在f2被调用的时候会被执行 。&#125;f2();//如果js是词法作用域，那么就会输出f1被创建的时候外部的num变量 123//如果js是动态作用域，那么f1执行的时候就会输出f1被调用时外部环境中的num 456 变量提升A、js 代码执行的过程 1 变量提升 2 代码从上到下依次执行 var 关键字和 function 关键字声明的变量会进行变量提升 B、变量提升发生的环境：发生在代码所处的当前作用域。 变量提升 1 var 关键字进行的变量提升，会把变量提前声明，但是不会提前赋值 。 2 function 关键字对变量进行变量提升，既会把变量提前声明，又会把变量提前赋值，也就是把整个函数体提升到代码的顶部 3 有一些代码是不会执行的但是仍旧会发生变量提升,规则适用于 1,2 3.1 return 之后的代码依旧会发生变量提升，规则适用于 1，2 3.2 代码报错之后的代码依旧会发生变量提升，规则适用于 1，2 3.3 break 之后的代码依旧会发生变量提升，规则适用于 1,2 4 有一些代码是不会执行但是仍旧会发生变量提升，但是规则要发生变化 4.1 if 判断语句 if 判断语句中 var 关键字以及 function 关键字声明的变量只会发生提前声明，不会发生提前赋值,也就是不会吧函数体整体提升到当前作用域顶部。规则跟 1,2 不适用 4.2 switch case 规则跟 1,2 不适用 4.3 do while 规则跟 1,2 不适用 4.4 try catch catch 中声明的变量只会发生提前声明，不会发生提前赋值。 Ps:在条件判断语句和 try catch 中的声明的变量不管是否能够执行，都只会发生提前 声明，不会发生提前赋值。 解析： 123456// 如果一个变量声明了但是未赋值，那么输出这个变量就会输出 undefinedvar num;console.log(num);// 如果一个变量没有声明也没有赋值，那么就会报一个错：console.log(num); // 输出一个不存在的变量 Uncaught ReferenceError: num is not defined 1234567891011121314// var 关键字进行的变量提升console.log(num);var num = 123;console.log(num);var num = 456;console.log(num);// 变量提升之后的代码：var num;console.log(num);num = 123;console.log(num);num = 456;console.log(num); 1234567891011// function 关键字的变量提升console.log(fn);function fn() &#123; console.log(1);&#125;// 变量提升之后的代码：function fn() &#123; console.log(1);&#125;console.log(fn); // 输出fn的函数体 12345678910111213141516171819202122232425262728293031// 3.1 return 之后的代码依旧会发生变量提升 规则适用于1，2function fn() &#123; console.log(num); return; var num = 123;&#125;fn();// 变量提升之后的代码：function fn() &#123; var num; console.log(num); return; num = 123;&#125;fn(); // undefinedfunction fn() &#123; console.log(fo); return; function fo() &#123;&#125;&#125;fn();// 变量提升之后的代码：function fn() &#123; function fo() &#123;&#125; console.log(fo); return;&#125;fn(); //输出fo的函数体 123456789101112//3.2 代码报错之后的代码依旧会进行变量提升，规则适用于1,2console.log(num);xsasfgdsfqdfsdf; //报一个错var num = 123;console.log(num);// 变量提升之后的代码：var num;console.log(num); //输出 undefineddsagdsqghdwfh; // 报一个错误 ，错误之后的代码不会被执行num = 123;console.log(num); 1234567891011//function 关键字console.log(fn);sasgfdhwhsdqg;function fn() &#123;&#125;console.log(fn);// 变量提升之后的代码：function fn() &#123;&#125;console.log(fn); // 输出 fn 的函数体asdgsdgdfgfdg; // 报一个错误，报错之后的代码不会被执行console.log(fn); 12345678910111213141516171819202122232425262728293031//4 代码不执行，但是会进行变量提升，不过规则不适用于1,2//4.1 if判断语句console.log(num);if (false) &#123; var num = 123;&#125;console.log(num)// 变量提升之后的代码：var num;console.log(num); //undefinedif (false) &#123; num = 123;&#125;console.log(num) //undefinedconsole.log(fn);if (false) &#123; function fn() &#123;&#125;&#125;console.log(fn);// 变量提升之后的代码：var fn;function fn;console.log(fn) //undefinedif (false) &#123; function fn() &#123;&#125;&#125;console.log(fn) //undefined/*function fn//Uncaught SyntaxError: Unexpected end of input*/ 123456789101112131415161718192021222324252627282930// try catchtry &#123; console.log(num);&#125; catch (e) &#123; var num = 123;&#125;console.log(num);var num;try &#123; console.log(num); // undefined&#125; catch (e) &#123; num = 123;&#125;console.log(num); // undefinedtry &#123; console.log(fn);&#125; catch (e) &#123; function fn() &#123;&#125;&#125;console.log(fn);var fn;try &#123; console.log(fn); // undefined&#125; catch (e) &#123; num = 123;&#125;console.log(fn); // undefined 对应面试题","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qw8.github.io/tags/JavaScript/"},{"name":"作用域","slug":"作用域","permalink":"https://qw8.github.io/tags/作用域/"}]},{"title":"JQuery","slug":"knowledges/jQuery","date":"2019-12-22T10:22:11.000Z","updated":"2023-12-08T09:03:22.000Z","comments":true,"path":"/knowledges/jquery.html","link":"","permalink":"https://qw8.github.io/knowledges/jquery.html","excerpt":"","text":"jquery的一些基本用法jquery的一些基本用法 jQuery的详细解析以及用法 jQuery隐藏和显示12345678910// 左侧栏隐藏 $(&quot;.close&quot;).click(function () &#123; $(&quot;.ask&quot;).hide(); $(&quot;.ask-hidden&quot;).show(); &#125;); // 左侧栏显示 $(&quot;.ask-hidden&quot;).click(function () &#123; $(&quot;.ask&quot;).show(); $(&quot;.ask-hidden&quot;).hide(); &#125;); jQuery实现不同按钮的切换选中效果123456function tagClick(value) &#123; $(&quot;.tag&quot;).click(function () &#123; $(&quot;.tag&quot;).removeClass(&quot;active&quot;); // 清除已经选中了的按钮的样式 $(this).addClass(&quot;active&quot;); // 重新给新选中的按钮添加选中样式 &#125;); &#125; 或者 1$(this).addClass(&apos;selected&apos;).siblings().removeClass(&apos;selected&apos;); 回车键按下触发搜索123456// 回车键按下触发搜索 $(document).keydown(function (event) &#123; if (event.keyCode == 13) &#123; filter(); &#125; &#125;); 给动态添加的html绑定点击事件第一种是在动态添加的html代码中添加oclick事件，然后传递一个唯一的参数来判断点击的是哪个，然后做相应的操作。 123456789101112var timestamp = parseInt((new Date()).valueOf()); //唯一的标识 console.log(timestamp); document.getElementById(&quot;joblist&quot;).innerhtml += `&lt;div id=&quot;job` + timestamp + `&quot; class=&quot;job&quot;&gt; &lt;input name=&quot;CompanyName&quot; type=&quot;text&quot; value=&quot;公司` + timestamp + `&quot; /&gt; &lt;button onclick=&quot;DelJob(` + timestamp + `)&quot;&gt;删除&lt;/button&gt; &lt;/div&gt;`; &#125; // 删除工作经历 function DelJob(timestamp) &#123; document.getElementById(&quot;job&quot; + timestamp).remove(); &#125; 第二种是通过事件委托的原理进行处理，事件委托将一个 事件监听器实际上绑定到整个容器，然后每个列表项被点击就可以访问，这样效率更高。 jQuery怎么根据不同条件动态加载js文件要根据不同条件动态加载js文件，可以使用jQuery的$.getScript()方法。该方法可以通过异步加载外部的js文件并执行。 以下是根据不同条件动态加载js文件的示例代码： 12345678910111213141516if (condition1) &#123; $.getScript(&quot;script1.js&quot;, function() &#123; // script1.js文件加载完成后执行的回调函数 // 在这里可以编写需要执行的代码 &#125;);&#125; else if (condition2) &#123; $.getScript(&quot;script2.js&quot;, function() &#123; // script2.js文件加载完成后执行的回调函数 // 在这里可以编写需要执行的代码 &#125;);&#125; else &#123; $.getScript(&quot;defaultScript.js&quot;, function() &#123; // defaultScript.js文件加载完成后执行的回调函数 // 在这里可以编写需要执行的代码 &#125;);&#125; 根据不同域名加载js1234567891011121314151617var hostname = window.location.hostname // 测试数据 // hostname = &apos;www.sxjayu.cn&apos; // hostname = &apos;xiuchuan.52dingfang.cn&apos; // hostname = &apos;car-test.xiuchuan.com&apos; // hostname = &apos;carxiuchuan.manshang.com&apos; var arr1 = hostname.split(&apos;.&apos;); arr1.shift(); domain1 = arr1.join(&apos;.&apos;); // 除这两个域名都用智齿 if (domain1 === &apos;sxjayu.cn&apos; || domain1 === &apos;52dingfang.cn&apos;) &#123; document.write(&quot;&lt;script src=&apos;https://scripts.easyliao.com/js/easyliao.js&apos;&gt;&lt;\\/script&gt;&quot;); document.write(&quot;&lt;script src=&apos;https://scripts.easyliao.com/34415/112627.js&apos;&gt;&lt;\\/script&gt;&quot;); &#125; else &#123; // 初始化智齿客服 initZhichi() &#125; 如何使用jQuery清空Input的值一、从jQuery获取Input的输入值要清空Input的值，首先需要获取当前Input中的值。可以使用jQuery的.val()函数获取输入框的值。例如： 1$(&apos;input:text&apos;).val(); 代码中，通过选择器选中所有的Input输入框，然后使用.val()函数获取其值。这个函数对于所有类型的Input都适用：text, password, checkbox, radio, 等等。 二、jQuery如何修改Input的value值如果需要修改一个Input的值，可以通过.val()函数设置新的值。例如： 1$(&apos;input:text&apos;).val(&apos;新的值&apos;); 代码中，使用val()函数设置新值“新的值”到所有被选中的文本Input中。 三、jQuery取Input的值与.val()函数相反，如果需要获取Input的value值，可以使用jQuery的.attr()函数。例如： 1$(&apos;input:text&apos;).attr(&apos;value&apos;); 代码中，通过选择器选中所有文本Input，然后用.attr()函数获取它们的值。这个函数的快捷方式是使用.val()函数，但是在一些情况下（例如，checkbox或radio）使用.attr()函数可以获得更准确的值。 四、jQuery获取Input的value值如果要获取所有选中的Input的值，可以使用jQuery的serialize()函数。这个函数可以通过序列化表单值的方式将它们组成一个字符串。例如： 1$(&apos;form&apos;).serialize(); 代码中，通过选择器选中所有的form元素，然后使用.serialize()函数获取值。 五、jQuery设置Input的值如果要为所有被选中的Input元素设置相同的值，可以使用如下代码： 1$(&apos;input:text&apos;).val(&apos;新值&apos;); 代码中，使用.val()函数替换所有文本Input元素的值为“新值”。 六、jQuery通过name获取Input的值如果不想使用选择器，可以通过给Input元素设置name属性获取它的值。例如： 1$(&apos;form input[name=&quot;username&quot;]&apos;).val(); 代码中，通过选择器选中form元素中name属性为“username”的Input元素，然后使用.val()函数获取它的值。 七、jQuery获取Input输入框的值要获取一个Input输入框的值，可以使用如下代码： 1$(&apos;input:text&apos;).val(); 代码中，使用选择器选取所有文本Input，然后使用.val()函数获取它们的值。 八、JS怎么清空Input的值如果不想使用jQuery库，可以使用JavaScript直接清空一个Input元素的值。例如： 1document.getElementById(&quot;myInput&quot;).value = &quot;&quot;; 代码中，使用JavaScript的原生方法获取Input元素，然后将它的值设置为空字符串即可清除它的值。 九、jQuery清空文本框的值使用jQuery清空文本框的值非常简单。只需要给文本框的value属性设置为空字符串即可。例如： 1$(&apos;input:text&apos;).val(&apos;&apos;); 代码中，使用选择器选取所有文本Input，然后使用.val()函数将它们的值设置为空字符串。这样即可清空文本框中的值。 jQuery 的实现原理？ (function(window, undefined) {})(window); jQuery 利用 JS 函数作用域的特性，采用立即调用表达式包裹了自身，解决命名空间和变量污染问题 window.jQuery = window.$ = jQuery; 在闭包当中将 jQuery 和 $ 绑定到 window 上，从而将 jQuery 和 $ 暴露为全局变量 你觉得jQuery或zepto源码有哪些写的好的地方 jquery源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当jquery中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入undefined参数，可以缩短查找undefined时的作用域链 12345678910111213(function( window, undefined ) &#123; //用一个函数域包起来，就是所谓的沙箱 //在这里边var定义的变量，属于这个函数域内的局部变量，避免污染全局 //把当前沙箱需要的外部变量通过函数参数引入进来 //只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数 window.jQuery = window.$ = jQuery; &#125;)( window ); jquery将一些原型属性和方法封装在了jquery.prototype中，为了缩短名称，又赋值给了jquery.fn，这是很形象的写法 有一些数组或对象的方法经常能使用到，jQuery将其保存为局部变量以提高访问速度 jquery实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率 jQuery 和 Zepto 的区别？ 各自的使用场景？ jQuery 主要目标是PC的网页中，兼容全部主流浏览器。在移动设备方面，单独推出 jQuery Mobile Zepto 从一开始就定位移动设备，相对更轻量级。它的 API 基本兼容 jQuery，但对PC浏览器兼容不理想 jquery.extend 与 jquery.fn.extend的区别？ jquery.extend 为jquery类添加类方法，可以理解为添加静态方法 jquery.fn.extend:源码中jquery.fn = jquery.prototype，所以对jquery.fn的扩展，就是为jquery类添加成员函数使用： jquery.extend扩展，需要通过jquery类来调用，而jquery.fn.extend扩展，所有jquery实例都可以直接调用 jQuery UI 如何自定义组件？ 通过向 $.widget() 传递组件名称和一个原型对象来完成 $.widget(&quot;ns.widgetName&quot;, [baseWidget], widgetPrototype); jQuery 与 jQuery UI、jQuery Mobile 区别？ jQuery 是 JS 库，兼容各种PC浏览器，主要用作更方便地处理 DOM、事件、动画、AJAX，主要提供的功能是选择器，属性修改和事件绑定等等 jQuery UI 是建立在 jQuery 库上，利用jQuery的扩展性设计的插件，一组用户界面交互、特效、小部件及主题。供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等 jQuery Mobile 以 jQuery 为基础，用于创建“移动Web应用”的框架 jQuery 一个对象可以同时绑定多个事件，这是如何实现的？jQuery可以给一个对象同时绑定多个事件，低层实现方式是使用addEventListner或attachEvent兼容不同的浏览器实现事件的绑定，这样可以给同一个对象注册多个事件。 jQuery 的 slideUp 动画，当鼠标快速连续触发, 动画会滞后反复执行，该如何处理呢? 在触发元素上的事件设置为延迟处理：使用 JS 原生 setTimeout 方法 在触发元素的事件时预先停止所有的动画，再执行相应的动画事件：$(‘.tab’).stop().slideUp(); 如何判断当前脚本运行在浏览器还是node环境中？（阿里） this === window ? ‘browser’ : ‘node’; 通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中 jQuery 的 slideUp动画 ，如果目标元素是被外部事件驱动, 当鼠标快速地连续触发外部元素事件, 动画会滞后的反复执行，该如何处理呢? jquery stop(): 如：$(“#div”).stop().animate({width:”100px”},100); 那些操作会造成内存泄漏？ 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环) JQuery一个对象可以同时绑定多个事件，这是如何实现的？ 多个事件同一个函数：$(&quot;div&quot;).on(&quot;click mouseover&quot;, function(){}); 多个事件不同函数 1234$(&quot;div&quot;).on(&#123; click: function()&#123;&#125;, mouseover: function()&#123;&#125;&#125;); 1234567$(\"#btn\").on(\"mouseover mouseout\", func);$(\"#btn\").on(&#123; mouseover: func1, mouseout: func2, click: func3&#125;); jQuery.fn 的 init 方法返回的 this 指的是什么对象？ 为什么要返回 this？ jQuery.fn 的 init 方法 返回的 this 就是 jQuery 对象 用户使用 jQuery() 或 $() 即可初始化 jQuery 对象，不需要动态的去调用 init 方法 jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？ 浅拷贝（只复制一份原始对象的引用）var newObject = $.extend({}, oldObject); 深拷贝（对原始对象属性所引用的对象进行进行递归拷贝）var newObject = $.extend(true, {}, oldObject); jQuery 中的 bind(), live(), delegate(), on()的区别？ bind 直接绑定在目标元素上 live 通过冒泡传播事件，默认document上，支持动态数据 delegate 更精确的小范围使用事件代理，性能优于 live on 是最新的1.9版本整合了之前的三种方式的新事件绑定机制 是否知道自定义事件？ jQuery 里的 fire 函数是什么意思，什么时候用？ 事件即“发布/订阅”模式，自定义事件即“消息发布”，事件的监听即“订阅订阅” JS 原生支持自定义事件，示例： 1234document.createEvent(type); // 创建事件event.initEvent(eventType, canBubble, prevent); // 初始化事件target.addEventListener('dataavailable', handler, false); // 监听事件target.dispatchEvent(e); // 触发事件 jQuery 里的 fire 函数用于调用 jQuery 自定义事件列表中的事件 jQuery 通过哪个方法和 Sizzle 选择器结合的？ Sizzle 选择器采取 Right To Left 的匹配模式，先搜寻所有匹配标签，再判断它的父节点 jQuery 通过 $(selecter).find(selecter); 和 Sizzle 选择器结合 jQuery 中如何将数组转化为 JSON 字符串，然后再转化回来？12345678910111213// 通过原生 JSON.stringify/JSON.parse 扩展 jQuery 实现 $.array2json = function(array) &#123; return JSON.stringify(array); &#125; $.json2array = function(array) &#123; // $.parseJSON(array); // 3.0 开始，已过时 return JSON.parse(array); &#125; // 调用 var json = $.array2json(['a', 'b', 'c']); var array = $.json2array(json); 谈一下 Jquery 中的 bind(),live(),delegate(),on()的区别？ bind： 绑定事件，对新添加的事件不起作用，方法用于将一个处理程序附加到每个匹配元素的事件上并返回 jQuery 对象。 live： 方法将一个事件处理程序附加到与当前选择器匹配的所有元素（包含现有的或将来添加的）的指定事件上并返回 jQuery 对象。 delegate： 方法基于一组特定的根元素将处理程序附加到匹配选择器的所有元素（现有的或将来的）的一个或多个事件上。 jQuery.extend 与 jQuery.fn.extend 的区别？ $.fn.extend() 和 $.extend() 是 jQuery 为扩展插件提拱了两个方法 $.extend(object); // 为jQuery添加“静态方法”（工具方法） 123456$.extend(&#123; min: function(a, b) &#123; return a &lt; b ? a : b; &#125;, max: function(a, b) &#123; return a &gt; b ? a : b; &#125;&#125;);$.min(2,3); // 2$.max(4,5); // 5 $.extend([true,] targetObject, object1[, object2]); // 对targt对象进行扩展 1234var settings = &#123;validate:false, limit:5&#125;;var options = &#123;validate:true, name:&quot;bar&quot;&#125;;$.extend(settings, options); // 注意：不支持第一个参数传 false// settings == &#123;validate:true, limit:5, name:&quot;bar&quot;&#125; $.fn.extend(json); // 为jQuery添加“成员函数”（实例方法） 123456789$.fn.extend(&#123; alertValue: function() &#123; $(this).click(function()&#123; alert($(this).val()); &#125;); &#125;&#125;);$(&quot;#email&quot;).alertValue(); jQuery 的队列是如何实现的？队列可以用在哪些地方？ jQuery 核心中有一组队列控制方法，由 queue()/dequeue()/clearQueue() 三个方法组成。 主要应用于 animate()，ajax，其他要按时间顺序执行的事件中 12345678910111213141516171819202122var func1 = function()&#123;alert('事件1');&#125;var func2 = function()&#123;alert('事件2');&#125;var func3 = function()&#123;alert('事件3');&#125;var func4 = function()&#123;alert('事件4');&#125;// 入栈队列事件$('#box').queue(\"queue1\", func1); // push func1 to queue1$('#box').queue(\"queue1\", func2); // push func2 to queue1// 替换队列事件$('#box').queue(\"queue1\", []); // delete queue1 with empty array$('#box').queue(\"queue1\", [func3, func4]); // replace queue1// 获取队列事件（返回一个函数数组）$('#box').queue(\"queue1\"); // [func3(), func4()]// 出栈队列事件并执行$('#box').dequeue(\"queue1\"); // return func3 and do func3$('#box').dequeue(\"queue1\"); // return func4 and do func4// 清空整个队列$('#box').clearQueue(\"queue1\"); // delete queue1 with clearQueue jquery 中如何将数组转化为json字符串，然后再转化回来？ jQuery中没有提供这个功能，所以你需要先编写两个jQuery的扩展： 12345678910$.fn.stringifyArray = function(array) &#123; return JSON.stringify(array)&#125;$.fn.parseArray = function(array) &#123; return JSON.parse(array)&#125;然后调用：$(&quot;&quot;).stringifyArray(array) 针对 jQuery 的优化方法？ 尽量使用id选择器代替class选择器。基于Class的选择性的性能相对于Id选择器开销很大，因为需遍历所有DOM元素。 频繁操作的DOM，先缓存起来再操作。用Jquery的链式调用更好 比如：var str=$(“a”).attr(“href”); for (var i = size; i &lt; arr.length; i++) {} for 循环每一次循环都查找了数组 (arr) 的.length 属性，在开始循环的时候设置一个变量来存储这个数字，可以让循环跑得更快： for (var i = size, length = arr.length; i &lt; length; i++) {} 总是从#id选择器来继承 尽量使用链式操作 使用时间委托 on 绑定事件 采用jQuery的内部函数data()来存储数据 使用最新版本的 jQuery Zepto的点透问题如何解决？点透主要是由于两个 div 重合，例如：一个 div 调用 show()，一个 div 调用 hide()；这个时候当点击上面的 div 的时候就会影响到下面的那个 div；解决办法主要有 2 种： github 上有一个叫做 fastclick 的库，它也能规避移动设备上 click 事件的延迟响应，https://github.com/ftlabs/fastclick将它用 script 标签引入页面（该库支持 AMD，于是你也可以按照 AMD 规范，用诸如 require.js 的模块加载器引入），并且在 dom ready 时初始化在 body 上， 根据分析，如果不引入其它类库，也不想自己按照上述 fastclcik 的思路再开发一套东西，需要 1.一个优先于下面的“divClickUnder”捕获的事件；2.并且通过这个事件阻止掉默认行为（下面的“divClickUnder”对 click 事件的捕获，在 ios 的 safari，click 的捕获被认为和滚屏、点击输入框弹起键盘等一样，是一种浏览器默认行为，即可以被 event.preventDefault()阻止的行为）。","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"JQuery","slug":"JQuery","permalink":"https://qw8.github.io/tags/JQuery/"},{"name":"jQuery UI","slug":"jQuery-UI","permalink":"https://qw8.github.io/tags/jQuery-UI/"},{"name":"Zepto","slug":"Zepto","permalink":"https://qw8.github.io/tags/Zepto/"}]},{"title":"Node","slug":"knowledges/Node","date":"2019-12-08T11:25:55.000Z","updated":"2024-03-31T12:15:30.000Z","comments":true,"path":"/knowledges/node.html","link":"","permalink":"https://qw8.github.io/knowledges/node.html","excerpt":"","text":"对 Node 的优点和缺点提出了自己的看法？优点： 因为 Node 是基于事件驱动和无阻塞的，所以非常适合处理并发请求，因此构建在 Node 上的代理服务器相比其他技术实现（如 Ruby）的服务器表现要好得多。 与 Node 代理服务器交互的客户端代码是由 javascript 语言编写的，因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。 擅长处理高并发，适合I/O密集型应用。 事件驱动，通过闭包很容易实现客户端的生命活期。 不用担心多线程，锁，并行计算的问题。 V8 引擎速度非常快。 对于游戏来说，写一遍游戏逻辑代码，前端后端通用。 缺点： Node 是一个相对新的开源项目，所以不太稳定，它总是一直在变。nodejs 更新很快，可能会出现版本兼容；还不算成熟，还没有大制作； nodejs 不像其他的服务器，对于不同的链接，不支持进程和线程操作 不适合CPU密集运算；不能充分利用多核CPU；可靠性低，某个环节出错会导致整个系统崩溃 Node 的应用场景 RESTFUL API 工具类应用：前端部署(npm, gulp) 实时应用：如实时在线聊天，图文直播，实时通知推送等等（如 socket.io） 客户端逻辑强大的单页 APP：本地化的在线音乐应用，本地化的在线搜索应用，本地化的在线 APP 等。 分布式应用：通过高效的并行 I/O 使用已有的数据 工具类应用：海量的工具，小到前端压缩部署（如 grunt），大到桌面图形界面应用程序 游戏类应用：游戏领域对实时和并发有很高的要求（如网易的 pomelo 框架） 利用稳定接口提升 Web 渲染能力 前后端编程语言环境统一：前端开发人员可以非常快速地切入到服务器端的开发（如著名的纯 Javascript 全栈式 MEAN 架构） 参考 node有哪些特征，与其他服务器端对比 特征：单线程、事件驱动、非阻塞I/O node 无法直接渲染静态页面，提供静态服务 node 没有根目录的概念 node 必须通过路由程序指定文件才能渲染文件 node 比其他服务端性能更好，速度更快 CommonJS中require/exports和ES6中import/export区别 CommonJS模块的重要特性是加载时执行，及脚本代码在require的时候，就会全部执行。一旦出现某个模块被“循环加载”就只输出已经执行的部分，还没有执行的部分是不输出的 ES6模块是动态引用，如果使用import从一个模块加载变量，那些变量不会缓存，而是成为一个指向被加载模块的引用,impor/export最终都是编译为require/exports来执行的 使用NPM有哪些好处？通过NPM，你可以安装和管理项目的依赖，并且能够指明依赖项的具体版本号。 对于Node应用开发而言，你可以通过package.json文件来管理项目信息，配置脚本，以及指明依赖的具体版本 AMD CMD规范的区别 CommonJS和AMD都是JavaScript模块化规范 CMD依赖就近，而AMD依赖前置 CMD是延迟执行的，而AMD是提前执行的 AMD的API默认是一个当多个用，CMD的API严格区分，推崇职责单一 如何判断当前脚本运行在浏览器还是node环境中 通过判断 Global 对象是否为 window ，如果不为window ，当前脚本没有运行在浏览器中 简述同步和异步的区别，如何避免回调地狱 同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为 异步方法调用一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而异步方法通常会在另外一个线程中，整个过程，不会阻碍调用者的工作 避免回调地狱： 1）Promise 2）async/await 3）generator 4）事件发布/监听模式 几种常见模块化规范的简介 CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的 AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难 CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行（依赖SPM 打包，模块的加载逻辑偏重） ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案 app.use和app.get区别 app.use(path,callback)中的callback既可以是router(路由)对象又可以是函数 app.get(path,callback)中的callback只能是函数 node怎么跟MongoDB建立连接 1）引入mongoose 2）使用mongoose.connect()方法连接到MongoDB数据库 3）监听连接是否成功 4）然后通过node，书写接口，对数据库进行增删改查 node 和 前端项目怎么解决跨域的通过在node服务器端设置 12345678910111213141516171819202122232425//解决跨域问题app.use(async(ctx, next) =&gt; &#123; //指定服务器端允许进行跨域资源访问的来源域。可以用通配符*表示允许任何域的JavaScript访问资源，但是在响应一个携带身份信息(Credential)的HTTP请求时，必需指定具体的域，不能用通配符 ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); //可选。它的值是一个布尔值，表示是否允许客户端跨域请求时携带身份信息(Cookie或者HTTP认证信息)。默认情况下，Cookie不包括在CORS请求之中。当设置成允许请求携带cookie时，需要保证&quot;Access-Control-Allow-Origin&quot;是服务器有的域名，而不能是&quot;*&quot;;如果没有设置这个值，浏览器会忽略此次响应。 ctx.set(&quot;Access-Control-Allow-Credentials&quot;, true); //指定服务器允许进行跨域资源访问的请求方法列表，一般用在响应预检请求上 ctx.set(&quot;Access-Control-Allow-Methods&quot;, &quot;OPTIONS, GET, PUT, POST, DELETE&quot;); //必需。指定服务器允许进行跨域资源访问的请求头列表，一般用在响应预检请求上 ctx.set(&quot;Access-Control-Allow-Headers&quot;, &quot;x-requested-with, accept, origin, content-type&quot;); // ctx.set(&quot;X-Powered-By&quot;, &apos; 3.2.1&apos;); //告诉客户端返回数据的MIME的类型，这只是一个标识信息,并不是真正的数据文件的一部分 ctx.set(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;); //如果不设置mode，直接设置content-type为application/json，则fetch会默认这是跨域模式（mode:&apos;cors&apos;），在跨域POST之前，客户端会先发一条OPTIONS请求来”探探路”，如果服务器允许，再继续POST数据。对于这种OPTIONS请求，需要在服务器配置允许接受OPTIONS请求，这样写就是直接允许了所有的OPTIONS请求，也可以按照需求来判断OPTIONS请求中更详细的信息 if (ctx.request.method == &quot;OPTIONS&quot;) &#123; ctx.response.status = 200 &#125; await next();&#125;); 什么是 error-first callback ？答案：error-first callback 用来传递错误和数据。第一个参数永远是一个错误对象（error-object），回调函数必须检查它。余下的参数用不过来传递数据。 解析： 123456fs.readFile(filePath, function(err, data) &#123; if (err) &#123; //处理出现错误的情况 &#125; //处理数据&#125;); 考察面试者对于 Node 异步操作基本知识的见解 Node 程序如何监听 80 端口？答案：脑筋急转弯！你不应该直接使用 Node 监听 80 端口（在*nix 系统中），这样做需要 root 权限，对于运行程序来说这不是一个好主意。 不过，你可以使 Node 监听 1024 以上的端口，然后在 Node 前面部署 nginx 反向代理。 解析：参考 使用什么工具检查代码风格？答案： JSLint by Douglas Crockford JSHint ESLint JSCS开发团队项目时，强制指定代码风格和使用静态分析，捕捉常见的错误，这些工具都非常有用。 操作错误和程序错误的区别是什么？答案：操作错误不是 bug，是系统的问题，例如超时或者硬件故障。另一方面，程序错误（programmer errors）是实际的错误。 为什么 npmshrinkwarp 非常有用？答案：这个命令在部署 Node.js 应用时是非常有用的——它可以保证所部属的版本就是依赖的版本。 解析：参考 什么是 stub？说出它的用途？举个使用场景？stub是用于模拟一个组件行为或模块的函数或程序。 Stubs 提供已知的答案来调用函数，另外你还可以断言哪个 stubs 被调用 在测试用例中，简单的说，你可以用stub去模拟一个方法，从而避免调用真实的方法，使用stub你还可以返回虚构的结果。你可以配合断言使用stub。 举个例子，在一个读取文件的场景中，当你不想读取一个真正的文件时： 123456var fs = require(&apos;fs&apos;);var readFileStub = sinon.stub(fs, &apos;readFile&apos;, function (path, cb) &#123; return cb(null, &apos;filecontent&apos;); &#125;);expect(readFileStub).to.be.called;readFileStub.restore(); 在单元测试中：Stub是完全模拟一个外部依赖，而Mock常用来判断测试通过还是失败 什么是测试金字塔？在做 HTTP API 的时候要怎么实现？答案：测试金字塔意思是在写测试时应该编写的底层但愿测试要多于高级的端到端测试。对于 HTTP APIs，应该归结为： 对你的模型多很多单元测试 在你的模型与其他交互时更少的集成测试 更少的验收测试，在 HTTP 端 你最喜欢的 HTTP 框架，并说明原因？答案：LiteHttp 好多的优点单线程 灵活的架构 轻量级 多文件上传 自动重定向 禁用一种或多种网络 解析：参考 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？答案：至少给出自己的思路（url-hash,可以使用已有的一些框架 history.js 等） 为什么用Nodejs,它有哪些缺点？ 事件驱动，通过闭包很容易实现客户端的生命活期。 不用担心多线程，锁，并行计算的问题 V8引擎速度非常快 对于游戏来说，写一遍游戏逻辑代码，前端后端通用 当然Nodejs也有一些缺点： nodejs更新很快，可能会出现版本兼容 nodejs还不算成熟，还没有大制作 nodejs不像其他的服务器，对于不同的链接，不支持进程和线程操作 什么是错误优先的回调函数？错误优先(Error-first)的回调函数（Error-First Callback）用于同时返回错误和数据。第一个参数返回错误，并且验证它是否出错；其他参数返回数据。 123456789fs.readFile(filePath, function(err, data)&#123; if (err) &#123; // 处理错误 return console.log(err); &#125; console.log(data);&#125;); 如何避免回调地狱？以下方式避免回调地狱 模块化：将回调函数转换为独立的函数 使用流程控制库，例如[aync] 使用Promise 使用aync/await 什么是Promise?Promise可以帮助我们更好地处理异步操作。下面的实例中，100ms后会打印result字符串。catch用于错误处理。多个Promise可以链接起来。 123456789new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&apos;result&apos;); &#125;, 100) &#125;) .then(console.log) .catch(console.error); 用什么工具保证一致的代码风格？为什么要这样？ 团队协作时，保证一致的代码风格是非常重要的，这样团队成员才可以更快地修改代码，而不需要每次去适应新的风格。这些工具可以帮助我们： [ESLint] (http://eslint.org/) [Standard] (https://standardjs.com/) JSLint JSHint ESLint JSCS推荐 什么是stub？举例说明stub用于模块的行为。测试时，stub可以为函数调用返回模拟的结果。比如说，我们写文件时，实际上并不需要真正去写。 1234567var fs = require(&apos;fs&apos;);var writeFileStub = sinon.stub(fs, &apos;writeFile&apos;, function(path, data, cb)&#123; return cb(null);&#125;);expect(writeFileStub).to.be.called;writeFileStub.restore(); 什么是测试金字塔？举例说明测试金字塔反应了需要写的单元测试，集成测试以及端到端测试的比例： img 测试HTTP接口时应该是这样的： 很多单元测试，分别测试各个模块(依赖需要stub) 较少的集成测试，测试各个模块之间的交互(依赖不能stub) 少量端到端测试，去调用真正地接口(依赖不能stub) 如何用Node监听80端口 这题有陷阱！在类Unix系统中你不应该去监听80端口，因为这需要超级用户权限。因此不推荐让你的应用直接监听这个端口。 目前，如果你一定要让你的应用80端口的话，你可以有通过在Node应用的前方再添加一层反向代理（例如nginx）来实现，如下图。否则，建议你直接监听大于1024的端口 方向代理指的是以代理服务器来接收Internet上的连接请求，然后将请求转发给内部网络上的服务器， 并且将服务器返回的结果发送给客户端。 NodeJS 的工作原理答案：事件循环 什么是事件循环（event loop）？答案：至少从开发者的角度来看，Node.js 是单线程运行的。底层使用 libuv 使用多线程。每一个 I/O 操作都需要一个回调，一旦操作完成会被事件循环执行 解析：参考 什么是事件循环Node采用的是单线程的处理机制(所有的I/O请求都采用非阻塞的工作方式)，至少从Node.js开发者的角度是这样的。而在底层，Node.js借助libuv来作为抽象封装层，从而屏蔽不同操作系统的差异，Node可以借助livuv来实现线程。下图表示Node和libuv的关系 img Libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个事件循环，以异步的方式将任务的执行结果返回给V8引擎。可以简单用下面这张图来表示 img 每一个I/O都需要一个回调函数————一旦执行完便堆到事件循环上用于执行 运算错误与程序员错误的区别运算错误并不是bug，这是和系统相关的问题，例如请求超时或者硬件故障。而程序员错误就是所谓的bug 1、Node模块机制1.1 请介绍一下node里的模块是什么Node中，每个文件模块都是一个对象，它的定义如下： 123456789101112function Module(id, parent) &#123; this.id = id; this.exports = &#123;&#125;; this.parent = parent; this.filename = null; this.loaded = false; this.children = [];&#125; module.exports = Module; var module = new Module(filename, parent); 所有的模块都是 Module 的实例。可以看到，当前模块（module.js）也是 Module 的一个实例。 1.2 请介绍一下require的模块加载机制这道题基本上就可以了解到面试者对Node模块机制的了解程度基本上面试提到 1、先计算模块路径 2、如果模块在缓存里面，取出缓存 3、加载模块 4、的输出模块的exports属性即可 123456789101112131415161718192021222324252627282930313233343536// require 其实内部调用 Module._load 方法Module._load = function(request, parent, isMain) &#123; // 计算绝对路径 var filename = Module._resolveFilename(request, parent); // 第一步：如果有缓存，取出缓存 var cachedModule = Module._cache[filename]; if (cachedModule) &#123; return cachedModule.exports; // 第二步：是否为内置模块 if (NativeModule.exists(filename)) &#123; return NativeModule.require(filename); &#125; /********************************这里注意了**************************/ // 第三步：生成模块实例，存入缓存 // 这里的Module就是我们上面的1.1定义的Module var module = new Module(filename, parent); Module._cache[filename] = module; /********************************这里注意了**************************/ // 第四步：加载模块 // 下面的module.load实际上是Module原型上有一个方法叫Module.prototype.load try &#123; module.load(filename); hadException = false; &#125; finally &#123; if (hadException) &#123; delete Module._cache[filename]; &#125; &#125; // 第五步：输出模块的exports属性 return module.exports;&#125;; 接着上一题继续发问 1.3 加载模块时，为什么每个模块都有dirname,filename属性呢，new Module的时候我们看到1.1部分没有这两个属性的，那么这两个属性是从哪里来的1234567891011// 上面(1.2部分)的第四步module.load(filename)// 这一步，module模块相当于被包装了，包装形式如下// 加载js模块，相当于下面的代码（加载node模块和json模块逻辑不一样）(function (exports, require, module, __filename, __dirname) &#123; // 模块源码 // 假如模块代码如下 var math = require(&apos;math&apos;); exports.area = function(radius)&#123; return Math.PI * radius * radius &#125;&#125;); 也就是说，每个module里面都会传入__filename, __dirname参数，这两个参数并不是module本身就有的，是外界传入的 1.4 我们知道node导出模块有两种方式，一种是exports.xxx=xxx和Module.exports={}有什么区别吗 exports其实就是module.exports 其实1.3问题的代码已经说明问题了，接着我引用廖雪峰大神的讲解，希望能讲的更清楚 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091module.exports vs exports很多时候，你会看到，在Node环境中，有两种方法可以在一个模块中输出变量：方法一：对module.exports赋值：// hello.jsfunction hello() &#123; console.log(&apos;Hello, world!&apos;);&#125;function greet(name) &#123; console.log(&apos;Hello, &apos; + name + &apos;!&apos;);&#125;module.exports = &#123; hello: hello, greet: greet&#125;;方法二：直接使用exports：// hello.jsfunction hello() &#123; console.log(&apos;Hello, world!&apos;);&#125;function greet(name) &#123; console.log(&apos;Hello, &apos; + name + &apos;!&apos;);&#125;function hello() &#123; console.log(&apos;Hello, world!&apos;);&#125;exports.hello = hello;exports.greet = greet;但是你不可以直接对exports赋值：// 代码可以执行，但是模块并没有输出任何变量:exports = &#123; hello: hello, greet: greet&#125;;如果你对上面的写法感到十分困惑，不要着急，我们来分析Node的加载机制：首先，Node会把整个待加载的hello.js文件放入一个包装函数load中执行。在执行这个load()函数前，Node准备好了module变量：var module = &#123; id: &apos;hello&apos;, exports: &#123;&#125;&#125;;load()函数最终返回module.exports：var load = function (exports, module) &#123; // hello.js的文件内容 ... // load函数返回: return module.exports;&#125;;var exported = load(module.exports, module);也就是说，默认情况下，Node准备的exports变量和module.exports变量实际上是同一个变量，并且初始化为空对象&#123;&#125;，于是，我们可以写：exports.foo = function () &#123; return &apos;foo&apos;; &#125;;exports.bar = function () &#123; return &apos;bar&apos;; &#125;;也可以写：module.exports.foo = function () &#123; return &apos;foo&apos;; &#125;;module.exports.bar = function () &#123; return &apos;bar&apos;; &#125;;换句话说，Node默认给你准备了一个空对象&#123;&#125;，这样你可以直接往里面加东西。但是，如果我们要输出的是一个函数或数组，那么，只能给module.exports赋值：module.exports = function () &#123; return &apos;foo&apos;; &#125;;给exports赋值是无效的，因为赋值后，module.exports仍然是空对象&#123;&#125;。结论如果要输出一个键值对象&#123;&#125;，可以利用exports这个已存在的空对象&#123;&#125;，并继续在上面添加新的键值；如果要输出一个函数或数组，必须直接对module.exports对象赋值。所以我们可以得出结论：直接对module.exports赋值，可以应对任何情况：module.exports = &#123; foo: function () &#123; return &apos;foo&apos;; &#125;&#125;;或者：module.exports = function () &#123; return &apos;foo&apos;; &#125;;最终，我们强烈建议使用module.exports = xxx的方式来输出模块变量，这样，你只需要记忆一种方法。 2、Node的异步I/O本章的答题思路大多借鉴于朴灵大神的《深入浅出的NodeJS》 2.1 请介绍一下Node事件循环的流程 在进程启动时，Node便会创建一个类似于while(true)的循环，每执行一次循环体的过程我们成为Tick。 每个Tick的过程就是查看是否有事件待处理。如果有就取出事件及其相关的回调函数。然后进入下一个循环，如果不再有事件处理，就退出进程。 img 2.2 在每个tick的过程中，如何判断是否有事件需要处理呢？ 每个事件循环中有一个或者多个观察者，而判断是否有事件需要处理的过程就是向这些观察者询问是否有要处理的事件。 在Node中，事件主要来源于网络请求、文件的I/O等，这些事件对应的观察者有文件I/O观察者，网络I/O的观察者。 事件循环是一个典型的生产者/消费者模型。异步I/O，网络请求等则是事件的生产者，源源不断为Node提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。 在windows下，这个循环基于IOCP创建，在*nix下则基于多线程创建 2.3 请描述一下整个异步I/O的流程 img 3、V8的垃圾回收机制3.1 如何查看V8的内存使用情况使用process.memoryUsage(),返回如下 123456&#123; rss: 4935680, heapTotal: 1826816, heapUsed: 650472, external: 49879&#125; heapTotal和heapUsed代表V8的内存使用情况。external代表V8管理的，绑定到Javascript的C++对象的内存使用情况。rss, 驻留集大小, 是给这个进程分配了多少物理内存(占总分配内存的一部分) 这些物理内存中包含堆，栈，和代码段。 3.2 V8的内存限制是多少，为什么V8这样设计64位系统下是1.4GB， 32位系统下是0.7GB。因为1.5GB的垃圾回收堆内存，V8需要花费50毫秒以上，做一次非增量式的垃圾回收甚至要1秒以上。这是垃圾回收中引起Javascript线程暂停执行的事件，在这样的花销下，应用的性能和影响力都会直线下降。 3.3 V8的内存分代和回收算法请简单讲一讲在V8中，主要将内存分为新生代和老生代两代。新生代中的对象存活时间较短的对象，老生代中的对象存活时间较长，或常驻内存的对象。 img 3.3.1 新生代 新生代中的对象主要通过Scavenge算法进行垃圾回收。这是一种采用复制的方式实现的垃圾回收算法。它将堆内存一份为二，每一部分空间成为semispace。在这两个semispace空间中，只有一个处于使用中，另一个处于闲置状态。处于使用状态的semispace空间称为From空间，处于闲置状态的空间称为To空间。 img 当开始垃圾回收的时候，会检查From空间中的存活对象，这些存活对象将被复制到To空间中，而非存活对象占用的空间将会被释放。完成复制后，From空间和To空间发生角色对换。 应为新生代中对象的生命周期比较短，就比较适合这个算法。 当一个对象经过多次复制依然存活，它将会被认为是生命周期较长的对象。这种新生代中生命周期较长的对象随后会被移到老生代中。 3.3.2 老生代 老生代主要采取的是标记清除的垃圾回收算法。与Scavenge复制活着的对象不同，标记清除算法在标记阶段遍历堆中的所有对象，并标记活着的对象，只清理死亡对象。活对象在新生代中只占叫小部分，死对象在老生代中只占较小部分，这是为什么采用标记清除算法的原因。 3.3.3 标记清楚算法的问题 主要问题是每一次进行标记清除回收后，内存空间会出现不连续的状态 img 这种内存碎片会对后续内存分配造成问题，很可能出现需要分配一个大对象的情况，这时所有的碎片空间都无法完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。 为了解决碎片问题，标记整理被提出来。就是在对象被标记死亡后，在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。 3.3.4 哪些情况会造成V8无法立即回收内存 闭包和全局变量 3.3.5 请谈一下内存泄漏是什么，以及常见内存泄漏的原因，和排查的方法 什么是内存泄漏 内存泄漏(Memory Leak)指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。 如果内存泄漏的位置比较关键，那么随着处理的进行可能持有越来越多的无用内存，这些无用的内存变多会引起服务器响应速度变慢。 严重的情况下导致内存达到某个极限(可能是进程的上限，如 v8 的上限;也可能是系统可提供的内存上限)会使得应用程序崩溃。常见内存泄漏的原因内存泄漏的几种情况: 一、全局变量12345a = 10; //未声明对象。 global.b = 11; //全局变量引用 这种比较简单的原因，全局变量直接挂在 root 对象上，不会被清除掉。 二、闭包123456function out() &#123; const bigData = new Buffer(100); inner = function () &#123; &#125; &#125; 闭包会引用到父级函数中的变量，如果闭包未释放，就会导致内存泄漏。上面例子是 inner 直接挂在了 root 上，那么每次执行 out 函数所产生的 bigData 都不会释放，从而导致内存泄漏。 需要注意的是，这里举得例子只是简单的将引用挂在全局对象上，实际的业务情况可能是挂在某个可以从 root 追溯到的对象上导致的。 三、事件监听Node.js 的事件监听也可能出现的内存泄漏。例如对同一个事件重复监听，忘记移除(removeListener)，将造成内存泄漏。这种情况很容易在复用对象上添加事件时出现，所以事件重复监听可能收到如下警告： 1emitter.setMaxListeners() to increase limit 例如，Node.js 中 Agent 的 keepAlive 为 true 时，可能造成的内存泄漏。当 Agent keepAlive 为 true 的时候，将会复用之前使用过的 socket，如果在 socket 上添加事件监听，忘记清除的话，因为 socket 的复用，将导致事件重复监听从而产生内存泄漏。 原理上与前一个添加事件监听的时候忘了清除是一样的。在使用 Node.js 的 http 模块时，不通过 keepAlive 复用是没有问题的，复用了以后就会可能产生内存泄漏。所以，你需要了解添加事件监听的对象的生命周期，并注意自行移除。 排查方法 想要定位内存泄漏，通常会有两种情况： 对于只要正常使用就可以重现的内存泄漏，这是很简单的情况只要在测试环境模拟就可以排查了。 对于偶然的内存泄漏，一般会与特殊的输入有关系。想稳定重现这种输入是很耗时的过程。如果不能通过代码的日志定位到这个特殊的输入，那么推荐去生产环境打印内存快照了。 需要注意的是，打印内存快照是很耗 CPU 的操作，可能会对线上业务造成影响。快照工具推荐使用 heapdump 用来保存内存快照，使用 devtool 来查看内存快照。 使用 heapdump 保存内存快照时，只会有 Node.js 环境中的对象，不会受到干扰(如果使用 node-inspector 的话，快照中会有前端的变量干扰)。 PS：安装 heapdump 在某些 Node.js 版本上可能出错，建议使用 npm install heapdump -target=Node.js 版本来安装。 4、Buffer模块4.1 新建Buffer会占用V8分配的内存吗不会，Buffer属于堆外内存，不是V8分配的。 4.2 Buffer.alloc和Buffer.allocUnsafe的区别Buffer.allocUnsafe创建的 Buffer 实例的底层内存是未初始化的。 新创建的 Buffer 的内容是未知的，可能包含敏感数据。 使用 Buffer.alloc() 可以创建以零初始化的 Buffer 实例。 4.3 Buffer的内存分配机制为了高效的使用申请来的内存，Node采用了slab分配机制。slab是一种动态的内存管理机制。Node以8kb为界限来来区分Buffer为大对象还是小对象，如果是小于8kb就是小Buffer，大于8kb就是大Buffer。 例如第一次分配一个1024字节的Buffer，Buffer.alloc(1024),那么这次分配就会用到一个slab，接着如果继续Buffer.alloc(1024),那么上一次用的slab的空间还没有用完，因为总共是8kb，1024+1024 = 2048个字节，没有8kb，所以就继续用这个slab给Buffer分配空间。 如果超过8bk，那么直接用C++底层地宫的SlowBuffer来给Buffer对象提供空间。 4.4 Buffer乱码问题例如一个份文件test.md里的内容如下： 1床前明月光，疑是地上霜，举头望明月，低头思故乡 我们这样读取就会出现乱码： 12var rs = require(&apos;fs&apos;).createReadStream(&apos;test.md&apos;, &#123;highWaterMark: 11&#125;);// 床前明???光，疑???地上霜，举头???明月，???头思故乡 一般情况下，只需要设置rs.setEncoding(‘utf8’)即可解决乱码问题 5、webSocket5.1 webSocket与传统的http有什么优势 客户端与服务器只需要一个TCP连接，比http长轮询使用更少的连接 webSocket服务端可以推送数据到客户端 更轻量的协议头，减少数据传输量 5.2 webSocket协议升级时什么，能简述一下吗？首先，WebSocket连接必须由浏览器发起，因为请求协议是一个标准的HTTP请求，格式如下： 1234567GET ws://localhost:3000/ws/chat HTTP/1.1Host: localhostUpgrade: websocketConnection: UpgradeOrigin: http://localhost:3000Sec-WebSocket-Key: client-random-stringSec-WebSocket-Version: 13 该请求和普通的HTTP请求有几点不同： GET请求的地址不是类似/path/，而是以ws://开头的地址； 请求头Upgrade: websocket和Connection: Upgrade表示这个连接将要被转换为WebSocket连接； Sec-WebSocket-Key是用于标识这个连接，并非用于加密数据； Sec-WebSocket-Version指定了WebSocket的协议版本。 随后，服务器如果接受该请求，就会返回如下响应： 1234HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: server-random-string 该响应代码101表示本次连接的HTTP协议即将被更改，更改后的协议就是Upgrade: websocket指定的WebSocket协议。 6、https6.1 https用哪些端口进行通信，这些端口分别有什么用 443端口用来验证服务器端和客户端的身份，比如验证证书的合法性 80端口用来传输数据（在验证身份合法的情况下，用来数据传输） 6.2 身份验证过程中会涉及到密钥， 对称加密，非对称加密，摘要的概念，请解释一下 密钥：密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥，分别应用在对称加密和非对称加密上。 对称加密：对称加密又叫做私钥加密，即信息的发送方和接收方使用同一个密钥去加密和解密数据。对称加密的特点是算法公开、加密和解密速度快，适合于对大数据量进行加密，常见的对称加密算法有DES、3DES、TDEA、Blowfish、RC5和IDEA。 非对称加密：非对称加密也叫做公钥加密。非对称加密与对称加密相比，其安全性更好。对称加密的通信双方使用相同的密钥，如果一方的密钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对密钥，即公钥和私钥，且二者成对出现。私钥被自己保存，不能对外泄露。公钥指的是公共的密钥，任何人都可以获得该密钥。用公钥或私钥中的任何一个进行加密，用另一个进行解密。 摘要： 摘要算法又称哈希/散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）。算法不可逆。 6.3 为什么需要CA机构对证书签名如果不签名会存在中间人攻击的风险，签名之后保证了证书里的信息，比如公钥、服务器信息、企业信息等不被篡改，能够验证客户端和服务器端的“合法性”。 6.4 https验证身份也就是TSL/SSL身份验证的过程简要图解如下 img 7、进程通信7.1 请简述一下node的多进程架构面对node单线程对多核CPU使用不足的情况，Node提供了child_process模块，来实现进程的复制，node的多进程架构是主从模式，如下所示： img 12345var fork = require(&apos;child_process&apos;).fork;var cpus = require(&apos;os&apos;).cpus();for(var i = 0; i &lt; cpus.length; i++)&#123; fork(&apos;./worker.js&apos;);&#125; 在linux中，我们通过ps aux | grep worker.js查看进程 img 这就是著名的主从模式，Master-Worker 7.2 请问创建子进程的方法有哪些，简单说一下它们的区别创建子进程的方法大致有： spawn()： 启动一个子进程来执行命令 exec(): 启动一个子进程来执行命令，与spawn()不同的是其接口不同，它有一个回调函数获知子进程的状况 execFlie(): 启动一个子进程来执行可执行文件 fork(): 与spawn()类似，不同电在于它创建Node子进程需要执行js文件 spawn()与exec()、execFile()不同的是，后两者创建时可以指定timeout属性设置超时时间，一旦创建的进程超过设定的时间就会被杀死 exec()与execFile()不同的是，exec()适合执行已有命令，execFile()适合执行文件。 7.3 请问你知道spawn在创建子进程的时候，第三个参数有一个stdio选项吗，这个选项的作用是什么，默认的值是什么。 选项用于配置在父进程和子进程之间建立的管道。 默认情况下，子进程的 stdin、 stdout 和 stderr 会被重定向到 ChildProcess 对象上相应的 subprocess.stdin、subprocess.stdout 和 subprocess.stderr 流。 这相当于将 options.stdio 设置为 [‘pipe’, ‘pipe’, ‘pipe’]。 7.4 请问实现一个node子进程被杀死，然后自动重启代码的思路在创建子进程的时候就让子进程监听exit事件，如果被杀死就重新fork一下 12345678var createWorker = function()&#123; var worker = fork(__dirname + &apos;worker.js&apos;) worker.on(&apos;exit&apos;, function()&#123; console.log(&apos;Worker&apos; + worker.pid + &apos;exited&apos;); // 如果退出就创建新的worker createWorker() &#125;)&#125; 7.5 在7.4的基础上，实现限量重启，比如我最多让其在1分钟内重启5次，超过了就报警给运维 思路大概是在创建worker的时候，就判断创建的这个worker是否在1分钟内重启次数超过5次 所以每一次创建worker的时候都要记录这个worker 创建时间，放入一个数组队列里面，每次创建worker都去取队列里前5条记录 如果这5条记录的时间间隔小于1分钟，就说明到了报警的时候了 7.6 如何实现进程间的状态共享，或者数据共享我自己没用过Kafka这类消息队列工具，问了java,可以用类似工具来实现进程间通信，更好的方法欢迎留言 8、中间件8.1 如果使用过koa、egg这两个Node框架，请简述其中的中间件原理，最好用代码表示一下 img 上面是在网上找的一个示意图，就是说中间件执行就像洋葱一样，最早use的中间件，就放在最外层。处理顺序从左到右，左边接收一个request，右边输出返回response 一般的中间件都会执行两次，调用next之前为第一次，调用next时把控制传递给下游的下一个中间件。当下游不再有中间件或者没有执行next函数时，就将依次恢复上游中间件的行为，让上游中间件执行next之后的代码 例如下面这段代码 123456789101112const Koa = require(&apos;koa&apos;)const app = new Koa()app.use((ctx, next) =&gt; &#123; console.log(1) next() console.log(3)&#125;)app.use((ctx) =&gt; &#123; console.log(2)&#125;)app.listen(3001)执行结果是1=&gt;2=&gt;3 koa中间件实现源码大致思路如下： 1234567891011121314151617181920212223242526272829303132333435363738394041// 注意其中的compose函数，这个函数是实现中间件洋葱模型的关键// 场景模拟// 异步 promise 模拟const delay = async () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(); &#125;, 2000); &#125;);&#125;// 中间间模拟const fn1 = async (ctx, next) =&gt; &#123; console.log(1); await next(); console.log(2);&#125;const fn2 = async (ctx, next) =&gt; &#123; console.log(3); await delay(); await next(); console.log(4);&#125;const fn3 = async (ctx, next) =&gt; &#123; console.log(5);&#125;const middlewares = [fn1, fn2, fn3];// compose 实现洋葱模型const compose = (middlewares, ctx) =&gt; &#123; const dispatch = (i) =&gt; &#123; let fn = middlewares[i]; if(!fn)&#123; return Promise.resolve() &#125; return Promise.resolve(fn(ctx, () =&gt; &#123; return dispatch(i+1); &#125;)); &#125; return dispatch(0);&#125;compose(middlewares, 1); 9、其它现在在重新过一遍node 12版本的主要API，有很多新发现，比如说 fs.watch这个模块，事件的回调函数有一个参数是触发的事件名称，但是呢，无论我增删改，都是触发rename事件（如果更改是update事件，删除delete事件，重命名是rename事件，这样语义明晰该多好）。后来网上找到一个node-watch模块，此模块增删改都有对应的事件， 并且还高效的支持递归watch 文件。 util模块有个promisify方法，可以让一个遵循异常优先的回调风格的函数，即 (err, value) =&gt; … 回调函数是最后一个参数，返回一个返回值是一个 promise 版本的函数。 123456789const util = require(&apos;util&apos;);const fs = require(&apos;fs&apos;);const stat = util.promisify(fs.stat);stat(&apos;.&apos;).then((stats) =&gt; &#123; // 处理 `stats`。&#125;).catch((error) =&gt; &#123; // 处理错误。&#125;); 10、杂想 crypto模块，可以考察基础的加密学知识，比如摘要算法有哪些（md5, sha1, sha256，加盐的md5,sha256等等）,接着可以问如何用md5自己模拟一个加盐的md5算法， 接着可以问加密算法（crypto.createCiphe）中的aes,eds算法的区别，分组加密模式有哪些（比如ECB,CBC,为什么ECB不推荐），node里的分组加密模式是哪种（CMM），这些加密算法里的填充和向量是什么意思，接着可以问数字签名和https的流程（为什么需要CA，为什么要对称加密来加密公钥等等） tcp/ip，可以问很多基础问题，比如链路层通过什么协议根据IP地址获取物理地址（arp），网关是什么，ip里的ICMP协议有什么用，tcp的三次握手，四次分手的过程是什么，tcp如何控制重发，网络堵塞TCP会怎么办等等，udp和tcp的区别，udp里的广播和组播是什么，组播在node里通过什么模块实现。 os，操作系统相关基础，io的流程是什么（从硬盘里读取数据到内核的内存中，然后内核的内存将数据传入到调用io的应用程序的进程内存中），冯诺依曼体系是什么，进程和线程的区别等等（我最近在看马哥linux教程，因为自己不是科班出身，听了很多基础的计算机知识，受益匪浅，建议去bilibili看） linux相关操作知识（node涉及到后台，虽然是做中台，不涉及数据库，但是基本的linux操作还是要会的） node性能监控（自己也正在学习中） 测试，因为用的egg框架，有很完善的学习单元测试的文档，省略这部分 数据库可以问一些比如事务的等级有哪些，mysql默认的事务等级是什么，会产生什么问题，然后考一些mysql查询的笔试题。。。和常用优化技巧，node的mysql的orm工具使用过没有。。。（比如我自己是看的尚硅谷mysql初级+高级视频，书是看的mysql必知必会，我自己出于爱好学习一下。。。没有实战过） 第1题, 什么是nodejs？我们在哪里使用它？Nodejs是服务器端的一门技术。它是基于Google V8 JavaScript引擎而开发的。用来开发可扩展的服务端程序。 第2题，为什么要使用node js？nodejs会让我们的编程工作变得简单，它主要包含如下几点几个好处: 执行快速。 永远不会阻滞。 JavaScript是通用的编程语言。 异步处理机制。 避免并行所带来的问题。 第3题，nodejs有哪些特点？是单线程的，但是有很高的可扩展性，使用JavaScript作为主流编程语言。使用的是异步处理机制和事件驱动。处理高效。 第4题， Set immediate和set time out 区别在哪里?Set immediate就是马上执行的意思。Set time out, 时间参数传为0，也想获得同样的功能。只不过前者要快一些。 第5题，如何更新nodejs的版本?npm install npm -g 第6题，为什么nodejs是单线程的？Nodejs使用的是单线程没错，但是通过异步处理的方式，可以处理大量的数据吞吐量，从而有更好的性能和扩可扩展性。 第7题，什么是回调函数？回调函数是指用一个函数作为参数传入另一个函数，这个函数会被在某个时机调用。 第8题, 什么叫做回调地狱?回调地狱是由嵌套的回调函数导致的。这样的机制会导致有些函数无法到达，并且很难维护。 第9题，如何阻止回调地狱?有三种方法， 对每个错误都要处理到， 保证代码的贯通， 程序代码模块化。 第10题，解释一下repl的作用?Read evaluate print loop， 用于测试，调试和实验用。 第11题，API函数的类型有哪些?有两种， 一种是阻滞型函数。阻滞型函数会等待操作完成以后再进行下一步。 另外一种是非阻滞型函数。这种函数使用回调函数来处理当前函数获取的结果。 第12题，回调函数的第1个参数是什么?通常是错误对象。如果这个参数为空，表示没有错误。 第13题，NPM的作用是什么?Node package manager, 主要有两个功能。 它是一个网端模块的存储介质。 它的另一个作用是安装程序依赖和版本管理。 第14题，nodejs和ajax的区别是什么？Nodejs和ajax也就是asynchronous JavaScript and xml，都是通过JavaScript来表现的，但是他们的目的截然不同。 Ajax是设计用来动态的更新页面的某个区域，从而不需要更新整个页面。 Nodejs是用来开发客户服务器类型应用的。 第15题，解释一下nodejs中chaining.Chaining是指从一个数据流到另一个数据流的链接，从而实现多个流操作。 第16题，什么是streams？解释一下有哪些类型?流的概念是不间断的，它可以不间断的从某个地方读取数据，或者向某个地方写入数据。 有4种类型的流数据。可读，可写。既可读，又可写，转化。 第17题，退出代码是什么？有哪些退出代码?退出代码是指中断nodejs运行时返回的代码。 有这么几种unused, uncaught fatal exception, fatal error, non function internal exception handler, internal exception handler run time failure,internal JavaScript evaluation failure. 第18题, 什么是globals?有三个global的关键字。 Global代表的是最上层的命名空间,用来管理所有其他的全局对象。 Process 是一个全局对象，可以把异步函数转化成异步回调, 它可以在任何地方被访问，它主要是用来返回系统的应用信息和环境信息. Buffer, 是用来处理二进制数据的类. 第19题， Angular js和node js的区别是什么?Angular js是网络应用开发框架，而nodejs是一个实时系统。 第20题, 为什么统一的风格儿非常重要，有什么工具可以保证这一点?统一的风格可以让所有的组成员按照一种规矩来写代码。工具有Standard和eslint. 第21题, 用什么方法来处理没有被处理的异常?在应用和node js之间使用domain来处理这样的异常。 第22题, Node js是如何支持多处理器平台的?Cluster模块是用来支持这方面的。它可以允许多个nodejs工作进程运行在相同的端口上。 第23题, 如何配置开发模式和生产模式的环境?首先有一个配置文件，然后通过环境变量参数来获取对应的配置内容。 第24题, nodejs中跟时间相关的函数有哪些?Set time out, clear time out. Set interval, clear interval. Set immediate, clear immediate. Process.nextTick. 第25题, 解释一下什么是reactor pattern。Reactor pattern主要是非阻滞的i/o操作。提供一个回调函数来关联io操作。io请求完成以后会不会提交给demultiplexer, 这是一个通知接口用来处理并发性的非阻滞的io操作，这个功能是通过查询一个event loop来实现的. 第26题，lts版本是什么意思？也就是long term support版本。至少会被支持18个月。使用的是偶数来标识。这种版本有稳定性和安全性的保证。 第27题，你为什么需要把express APP和server分开？分开以后方便维护以及测试，在测试某个模块的时候，尤其是APP模块的时候，你不需要去对网络方面的连接配置做工作。 第28题，next tick和setImmediate的区别是什么？Next tick会等待当前的event执行完成或者下一轮儿事件循环到达再执行。 Set immediate, 会在下一轮的事件循环中，执行回调并且返回当前的循环来做读写操作.","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://qw8.github.io/tags/Node/"}]},{"title":"npm","slug":"knowledges/npm","date":"2019-11-24T03:10:20.000Z","updated":"2024-05-21T10:30:29.591Z","comments":true,"path":"/knowledges/npm.html","link":"","permalink":"https://qw8.github.io/knowledges/npm.html","excerpt":"","text":"NPM介绍NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种： 允许用户从NPM服务器下载别人编写的第三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 1234567//检测是否安装成功npm -v//使用npm命令安装模块npm install &lt;Module Name&gt;// 缩写npm i &lt;Module Name&gt; 全局安装与本地安装1npm i koa //本地安装 将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。 可以通过 require() 来引入本地安装的包。 1npm i koa -g //全局安装 将安装包放在 /usr/local 下或者你 node 的安装目录。 可以直接在命令行里使用。 npm install -save moduleName # -save 的意思是将模块安装到项目目录下，并在package文件的dependencies节点写入依赖。 npm install -save-dev moduleName # -save-dev 的意思是将模块安装到项目目录下，并在package文件的devDependencies节点写入依赖。 查看安装信息查看所有全局安装的模块 1npm list -g 如果要查看某个模块的版本号，可以使用命令如下： 1npm list koa -g 使用 package.jsonpackage.json 位于模块的目录下，用于定义包的属性。 Package.json 属性说明 name - 包名。 version - 包的版本号。 description - 包的描述。 homepage - 包的官网 url 。 author - 包的作者姓名。 contributors - 包的其他贡献者姓名。 dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。 repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。 main - main 字段指定了程序的主入口文件，require(‘moduleName’) 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。 keywords - 关键字 卸载模块我们可以使用以下命令来卸载 Node.js 模块。 1npm uninstall koa 卸载后，你可以到 /node_modules/ 目录下查看包是否还存在，或者使用以下命令查看： 1npm ls 更新模块1npm update koa 搜索模块1npm search express 创建模块创建模块，package.json 文件是必不可少的。我们可以使用 NPM 生成 package.json 文件，生成的文件包含了基本的结果。 123npm init快速创建npm init -y 在 npm 资源库中注册用户（使用邮箱注册）：12345npm adduserUsername: &quot;用户名&quot;Password: &quot;密码&quot;Email: (this IS public) &quot;邮箱&quot; 发布模块1npm publish 容易混乱的几个安装 123456789101112131415161718192021npm install moduleName 命令1. 安装模块到项目node_modules目录下。2. 不会将模块依赖写入devDependencies或dependencies 节点。3. 运行 npm install 初始化项目时不会下载模块。npm install -g moduleName 命令1. 安装模块到全局，不会在项目node_modules目录中保存模块包。2. 不会将模块依赖写入devDependencies或dependencies 节点。3. 运行 npm install 初始化项目时不会下载模块。npm install -save moduleName 命令1. 安装模块到项目node_modules目录下。2. 会将模块依赖写入dependencies 节点。3. 运行 npm install 初始化项目时，会将模块下载到项目目录下。4. 运行npm install --production或者注明NODE_ENV变量值为production时，会自动下载模块到node_modules目录中。npm install -save-dev moduleName 命令1. 安装模块到项目node_modules目录下。2. 会将模块依赖写入devDependencies 节点。3. 运行 npm install 初始化项目时，会将模块下载到项目目录下。4. 运行npm install --production或者注明NODE_ENV变量值为production时，不会自动下载模块到node_modules目录中。 总结devDependencies 节点下的模块是我们在开发时需要用的，比如项目中使用的 gulp ，压缩css、js的模块。这些模块在我们的项目部署后是不需要的，所以我们可以使用 -save-dev 的形式安装。像 express 这些模块是项目运行必备的，应该安装在 dependencies 节点下，所以我们应该使用 -save 的形式安装。 npm的镜像源npm镜像源是npm软件包管理器的服务器地址，用于下载和安装npm包。常见的npm镜像源有以下几种： 官方源 npm官方提供的默认源，地址是https://registry.npmjs.org/，但由于位于国外，速度较慢。 npm中国镜像站地址 https://registry.npmmirror.com cnpm源 另一个由淘宝团队提供的镜像源，地址是http://r.cnpmjs.org/，同样是国内服务器，速度较快。 阿里源 由阿里巴巴提供的镜像源，地址是https://npm.aliyun.com/，同样是国内服务器，速度较快。 腾讯云 NPM 镜像： https://mirrors.cloud.tencent.com/npm/ 淘宝源（日前已禁用） 由淘宝团队提供的镜像源，地址是https://registry.npm.taobao.org/，是国内服务器，因此速度较快。 npm查看镜像源在npm中查看配置的镜像源（registry），可以使用以下命令： 1npm get registry 这将输出当前配置的npm包仓库地址。 如果想要查看所有的npm配置，可以使用： 1npm config list 这将列出npm的所有配置信息，包括镜像源。 切换镜像源使用镜像源可以加快npm包的下载和安装速度，尤其是在国内网络环境下。你可以通过设置npm的配置来切换镜像源。例如，要使用淘宝源，可以执行以下命令： npm config set registry https://registry.npm.taobao.org/ 切换镜像源后，再使用npm安装包时，npm将会从对应的镜像源下载和安装包。 特定包使用特定源1yarn add vue-draggable-plus --registry https://registry.npmjs.org 缓存问题如果你之前使用过其他的镜像源，并且现在想要切换到另一个，可能需要先清除 yarn 的缓存。 你可以使用yarn cache clean命令来做到这一点。 问题不同包使用不同源临时更改你可以在运行 npm 命令时指定 --registry 标志来临时更改 registry。例如： 1npm install vue-draggable-plus --registry https://registry.npmjs.org 这条命令会告诉 npm 使用 https://registry.npmjs.org 来安装 vue-draggable-plus。 永久更改如果你想永久更改 registry，你可以更新 .npmrc 文件。你可以按照以下步骤进行： 找到你的 .npmrc 文件。这个文件通常位于你的用户主目录下，或者在项目的根目录中（如果你在项目级别设置了 registry）。 使用文本编辑器打开 .npmrc 文件。 修改或添加 registry 行来指向 https://registry.npmjs.org。例如： 1registry=https://registry.npmjs.org/ 保存文件并关闭文本编辑器。 现在，当你运行 npm install 命令时，npm 将默认使用新的 registry。 项目级别的 .npmrc如果你只想在特定的项目中更改 registry，而不是全局地更改，你可以在该项目的根目录中创建一个 .npmrc 文件，并只在该文件中指定 registry。这样，当你在该项目的上下文中运行 npm 命令时，它会使用这个 .npmrc 文件中的设置。 注意事项 更改 registry 后，确保你的网络可以访问新的 registry，并且该 registry 包含了你要安装的软件包。 如果你正在使用一个公司或组织的私有 registry，请确保更改 registry 后不会影响你的其他依赖项的安装。 在切换回原来的 registry 之前，请确保你已经记录了原始的 registry 地址，以便日后需要时可以恢复。 通过以上方法，你应该能够灵活地管理 npm 的 registry，从而使用不同的源来安装你的依赖项。 不影响自动化构建目前项目的.npmrc文件指定了registry=http://npm.boundless-tech.com.cn/如果我想使用https://registry.npmjs.org这个源来安装vue-draggable-plus且不影响自动化构建时其他包的安装，我应该怎么处理 如果你希望在不修改全局 .npmrc 文件的情况下，仅为 vue-draggable-plus 这个包使用 https://registry.npmjs.org 这个源，你可以通过在执行安装命令时指定 --registry 参数来实现。这样做不会影响自动化构建时其他包的安装，因为其他包仍然会使用 .npmrc 文件中指定的源。 具体做法如下： 1npm install vue-draggable-plus --registry=https://registry.npmjs.org 这条命令会只针对 vue-draggable-plus 这个包使用 https://registry.npmjs.org 这个源，而不会影响其他包的安装源。 在自动化构建脚本中，你可以确保只有安装 vue-draggable-plus 的命令包含了 --registry 参数，其他包的安装命令则保持原样，这样就可以确保只有 vue-draggable-plus 会从 https://registry.npmjs.org 安装，而其他包仍然从 .npmrc 文件中指定的源安装。 例如，如果你的自动化构建脚本中原本有类似这样的命令： 1npm install 你可以修改为： 12npm install --ignore-scripts # 首先安装其他所有依赖，忽略可能的脚本执行 npm install vue-draggable-plus --registry=https://registry.npmjs.org # 然后单独安装 vue-draggable-plus 注意：--ignore-scripts 参数是可选的，用于防止在全局安装依赖时执行任何 npm 脚本，这通常是为了提高构建速度和安全性。如果你的构建过程不需要执行这些脚本，那么可以加上这个参数。如果你的项目依赖于某些安装脚本（如 postinstall 脚本），则不应使用此参数。 同时使用两个源地址删了yarn.lock文件，然后命令行运行下面这两个代码yarnyarn add vue-draggable-plus –registry https://registry.npmjs.org npm全局安装与本地安装、开发依赖和生产依赖npm(Node Package Manager)是 JavaScript 世界的包管理工具,并且是 Node.js 平台的默认包管理工具。通过 npm 可以安装、共享、分发代码,管理项目依赖关系。（与其有同样功能的另一个包管理工具yarn，速度用体验比旧版本的npm好，但npm最近的新版本也做出很大努力，与yarn速度和体验差距越来越小，有兴趣可以了解下）。 npm这几年可以说是前端猿日常离不开的工具了，刚开始学习使用node、npm来进行前端项目构建的时候，有很多概念需要理解，各种命令行、各种新js语法、各种环境依赖…就问你怕吗？： 图片描述 讲真，刚开学时我怕。废话不多扯，现在我们进入主题，聊聊npm 全局安装与本地安装、开发依赖和生产依赖，先抛几个常见疑惑： 什么是全局安装、什么是本地安装(或叫局部安装，下文统一叫本地安装) ？ 为什么要全局安装？为什么又要本地安装？全局安装和本地安装有什么区别？ 什么叫开发依赖、生产依赖？什么又是开发环境、生产环境？ 全局安装与本地安装一、全局安装：1npm install &lt;pageName&gt; -g//（这里-g是-global的简写） 通过上面的命令行（带-g修饰符）安装某个包，就叫全局安装。通常全局包安装在node目录下的node_modules文件夹。可以通过执行下面几条命令查看node、npm的安装目录和全局包的安装目录。 1234which node // 查看node的安装目录which npm // 查看npm的安装目录npm root -g // 查看全局包的安装目录npm list -g --depth 0 //查看全局安装过的包 二、本地安装:1npm install &lt;pageName&gt; (后面可以加几种修饰符，主要有两种--save-dev和--save) 通过上面的命令行安装某个包，就叫本地安装。包安装在你当前项目文件夹下的node_modules文件夹中。 三、全局安装的作用:全局安装的包可提供直接执行的命令(例：gulp -h可以查看gulp定义了什么命令)。 比如gulp全局安装后，可以在命令行上直接执行gulp -v、gulp -h等（原理：全局安装的gulp会将其package.json中的bin命令注入到了全局环境，使得你可以全局执行：gulp xxx命令，这另一个话题了，不深入）。倘若只在本地安装了gulp，未在全局安装gulp，直接执行这些命令会报错。你想要执行相应的命令则可能需要例如：node ./node_modules/gulp/bin/gulp.js -v(查看版本) 这样用一大串命令来执行。因此全局安装就发挥到他的好处了，一个gulp -v就搞定 当然，不是每个包都必须要全局安装的，一般在项目中需要用到该包定义的命令才需要全局安装。比如gulp 执行gulp任务…等，所以是否需要全局安装取决于我们如何使用这个包。全局安装的就像全局变量有点粗糙，但在某些情况下也是必要的，全局包很重要，但如果不需要，最好避免使用。 四、可以全局安装，那么直接全局安装到处使用就行了，干嘛还需要本地安装？ 如果只是全局安装了而没本地安装，就得require(‘‘) 例：引入一个全局的包可能就是requirt(‘/usr/local/….’)通过全局包的路径引入，这样显然十分的不灵活。如果安装了本地包，那么就可以直接require(‘‘)引入使用。 一个包通常会在不同的项目上会重复用到，如果只全局安装，那么当某个项目需要该包更新版本时，更新后可能就会影响到其他同样引用该包的项目，因此本地安装可以更灵活地在不同的项目使用不同版本的包，并避免全局包污染的问题， 一个经验法则：要用到该包的命令执行任务的就需要全局安装，要通过require引入使用的就需要本地安装（ 但实际开发过程中，我们也不怎么需要考虑某个包是全局安装还是本地安装，因为这一点在该包的官网上一般会明确指出，以上是为了理解全局安装和本地安装） 开发依赖和生产依赖顺着上面讲到的本地安装，本地安装有两种主要的安装方式： 保存到开发依赖(devDependencies): npm install –save-dev 保存到生产依赖(dependencies): npm install –save “开发依赖”顾名思义在开发环境中用到的依赖，”生产依赖”在生产环境中用到的依赖。那么这里又延伸出个问题什么是开发环境、什么是生产环境？ 一、开发环境和生产环境【开发环境】：指的是你的项目尚且在编码阶段时的环境。你在代码可能还有各种console.log()、注释、格式化等。【生产环境】：指的是你的项目已经完成编码，并发布上线可供用户浏览的阶段时的环境。代码可能经过了压缩、优化等处理。 这些概念其实并没有一个很明确的定义，接下来我们举例个场景，将”开发环境”、”生产环境”和上面的”开发依赖”、”生产依赖”联系起来就会比较容易理解的了。假如我们在开发过程中使用jQuery。在以往，可能就是把jQuery这个插件下载的本地，再通引入html中。但这有个不方便的地方，我们每次进行一个项目的时候就得手动复制这个jQuery文件到我们的项目中，如果想要换个版本又得官网上下载、随着项目越来越多。用到的插件、库也随之越繁杂...这样会造成自家用的插件管理繁琐的问题。因此就出现了npm(包管理工具)你需要用到什么，直接通过一条命令行就可以将想要的插件下载下来，并直接引入到项目中，目前几乎所有的js插件都能在npm上直接下载。 二、生产依赖回到环境和依赖话题，我们下载的jQuery，在开发时参与源码编写，在发布上线的生产环境中也是需要它的。不仅在开发环境编写代码时要依赖它、线上环境也要依赖它，因此将它归类为\"生产依赖\"，安装时执行npm install jquery --save，它就会被记录在package.json的dependencies。当进行代码打包时，会将这里的jQuery打包入我们的项目代码中。 三、开发依赖接着，假如我们用gulp对html进行压缩，我们通常会用到一个插件gulp-htmlmin。我们只希望它把html压缩完就ok了，并不希望它融入我们的项目代码中，即只存在于开发环境，因此把他归类为\"开发依赖\"。安装时执行npm install gulp-htmlmin --save-dev它就会被记录在package.json的devependencies下，当进行代码打包时，不会将这里的gulp-htmlmin插件源码打包入我们的项目代码中 devDependencies只会在开发环境下使用，生产环境不会被打入包内；而dependencies不仅在开发环境中要使用，生产环境也需要使用到。根据以上规则，我们就很容易区分哪些插件是用--save-dev模式安装，哪些用--save模式安装。 NPM语义版本号在 npm 的官方文档中建议库的版本号的发布规则如下 ： 场景 阶段 规则 例子 首次发布 新产品 从 1.0.0 开始 1.0.0 向后兼容的bug修复 发布补丁 第三位数字值递增 1.0.1 向后兼容的新特性 小版本更新 第二位数字递增且将第三位数字重置为0 1.1.0 破坏向后兼容的修改 大版本更新 第一位数字递增且将第二、三为数字重置为0 2.0.0 你想使用什么版本？回看文章开头我使用 create-react-app 新建的项目里 package.json 里的 1&quot;react-scripts&quot;: &quot;4.0.1&quot; 这边非常明确地指定了使用 react-scripts 的 4.0.1 版本。 所有依赖库都使用这样明确的版本声明不好吗？—— 是的，这可能不是最佳的做法。 设想，你的项目里依赖的某个库有个性能问题，作者最近发布了修复补丁，如果你不是经常关注该库的 changelog，你可能根本不知道，你的项目也享受不到这个性能提升了。 再设想，你的项目里依赖的某个库最近被作者更新了，提供了几个十分有用的小功能，同样的，使用精确的版本号不能让你及时体验到这些新特性。 那么有办法设置一个模糊的版本号范围吗？ —— 有的！下面使用例子来更好地说明 1） 及时帮我安装最新补丁 例子1： 123&quot;some-lib&quot;: &quot;1.0&quot; 或 &quot;some-lib&quot;: &quot;1.0.x&quot; 说明1： npm install 的时候，请帮我安装 1.0 的小版本以及最新的补丁版本，如 1.0.2 , 1.0.6 等 例子2: 1&quot;some-lib&quot;： ”~1.0.4“ 说明2: npm install 的时候，请帮我安装 1.0 的小版本 以及 1.0.4 以上的最新补丁版本， 如 1.0.6 等（但不会安装 1.0.2 因为它低于 1.0.4 ） 2）及时帮我安装最新小版本和最新补丁 例子3: 123&quot;some-lib&quot;: &quot;1&quot; 或 &quot;some-lib&quot;: &quot;1.x&quot; 说明3: npm install 的时候，请帮我安装 1 的大版本以及最新的小版本以及补丁版本，如 1.0.6 , 1.1.6 , 1.2.3 , 1.3.0 等 例子4: 1&quot;some-lib&quot;: &quot;^1.1.4&quot; 说明4: npm install 的时候，请帮我安装 1 的大版本以及 1.1.4 以上 最新的小版本以及补丁版本，如 1.1.6 , 1.2.3 , 1.3.0 等 （但不会安装 1.0.6 因为它低于 1.1.4 ） 3) 及时帮我安装最新的版本 例子5: 123&quot;some-lib&quot;: &quot;*&quot; 或 &quot;some-lib&quot;: &quot;x&quot; 说明5: npm install 的时候, 都给我安装最最最新的版本！我不在乎兼容性！项目上线崩盘了我也无所谓！ —— 这是最浮夸的一种写法，当然也是基本不可能出现在实际生产环境代码中的写法。 （以上都是以项目中没有 package-lock.json 为前提假设，后面的章节会谈到 package-lock.json） 官方提供了一个实验平台网站可以尝试以上这些写法 npm semantic version calculator package-lock.json作用其实用一句话来概括很简单，就是锁定安装时的包的版本号，并且需要上传到git，以保证其他人在npm install时大家的依赖能保证一致。 引用知乎@周载南的回答 根据官方文档，这个package-lock.json 是在 npm install时候生成一份文件，用以记录当前状态下实际安装的各个npm package的具体来源和版本号。 它有什么用呢？因为npm是一个用于管理package之间依赖关系的管理器，它允许开发者在pacakge.json中间标出自己项目对npm各库包的依赖。你可以选择以如下方式来标明自己所需要库包的版本 这里举个例子： \"dependencies\": {\"@types/node\": \"^8.0.33\",}, 这里面的 向上标号^是定义了向后（新）兼容依赖，指如果 types/node的版本是超过8.0.33，并在大版本号（8）上相同，就允许下载最新版本的 types/node库包，例如实际上可能运行npm install时候下载的具体版本是8.0.35。波浪号 大多数情况这种向新兼容依赖下载最新库包的时候都没有问题，可是因为npm是开源世界，各库包的版本语义可能并不相同，有的库包开发者并不遵守严格这一原则：相同大版本号的同一个库包，其接口符合兼容要求。这时候用户就很头疼了：在完全相同的一个nodejs的代码库，在不同时间或者不同npm下载源之下，下到的各依赖库包版本可能有所不同，因此其依赖库包行为特征也不同有时候甚至完全不兼容。 因此npm最新的版本就开始提供自动生成package-lock.json功能，为的是让开发者知道只要你保存了源文件，到一个新的机器上、或者新的下载源，只要按照这个package-lock.json所标示的具体版本下载依赖库包，就能确保所有库包与你上次安装的完全一样。 原来package.json文件只能锁定大版本，也就是版本号的第一位，并不能锁定后面的小版本，你每次npm install都是拉取的该大版本下的最新的版本，为了稳定性考虑我们几乎是不敢随意升级依赖包的，这将导致多出来很多工作量，测试/适配等，所以package-lock.json文件出来了，当你每次安装一个依赖的时候就锁定在你安装的这个版本。 那如果我们安装时的包有bug，后面需要更新怎么办？ 在以前可能就是直接改package.json里面的版本，然后再npm install了，但是5版本后就不支持这样做了，因为版本已经锁定在package-lock.json里了，所以我们只能npm install xxx@x.x.x 这样去更新我们的依赖，然后package-lock.json也能随之更新。 假如我已经安装了jquery 2.1.4这个版本，从git更新了package.json和package-lock.json，我npm install能覆盖掉node_modules里面的依赖吗? 其实我也有这个疑问，所以做了测试，在直接更新package.json和package-loc.json这两个文件后，npm install是可以直接覆盖掉原先的版本的，所以在协作开发时，这两个文件如果有更新，你的开发环境应该npm install一下才对。 package-lock.json 放进版本控制系统（以Git为例）的目的和好处package.json 里声明的版本支持以上的模糊写法，那么在 npm install 的时候，我怎么知道到底安装了具体哪个版本呢？ 答案就在 package-lock.json 里 package-lock.json 还有一个很重要的作用 —— 当 npm install 时发现本地有 package-lock.json，就会严格按照 package-lock.json 的版本来安装。 package-lock.json 完整描述了当前项目的依赖树，保证了其他地方运行npm install 时都能安装一模一样的依赖库版本 无需把 node_modules 上传到Git就能达到上面第一点提到的效果 如果package-lock.json更新并上传新版本到 Git，利用 Git 的 Diff 功能可以清楚地了解发生了哪些变化 可以让 Npm install 时跳过对一些依赖库的元数据的请求，优化了性能 从 npm v7 版本开始，package-lock.json 的信息已经包含了 package.json 关于依赖树的的所有内容，因此无需再解析 package.json，大大提高了性能 发布一个UI组件库1.在本地创建项目目录 2.在 GitHub 上创建仓库，并在本地关联远程仓库，用于保存项目。 3.添加开源许可证 - 如何选择开源许可证？ 在 GitHub 对应的仓库根目录下新增文件，输入 LICENSE ，出现增加许可证的选项，点击后选择对应许可证即可： 4.本地项目目录下运行 npm init - 创建 package.json 5.本地项目目录下运行 npm i vue - 添加 vue 6.写自己的组件。。。。略 7.设置入口文件 在 package.json 中添加入口文件 \"main\": \"index.js\",，在入口文件中引入并导出需要打包发布的组件： 12345import Button from &apos;./src/Button.vue&apos;import ButtonGroup from &apos;./src/buttonGroup.vue&apos;import Icon from &apos;./src/Icon.vue&apos;export &#123;Button,ButtonGroup,Icon&#125; 8.发布到npm 在 npmjs注册一个账号并在邮箱中确认注册信息在项目根目录的命令行中输入 npm adduser，根据提示填入账号密码邮箱使用命令 npm publish 发布注意：如果错误提示里面含有 https://registry.npm.taobao.org 则说明你的 npm 源目前为淘宝源，需要更换为 npm 官方源 可以直接安装 nrm 对 npm源 进行管理: npm install -g nrm 输入 nrm ls 可以看到目前的 npm 源；输入 nrm use npm 切换到 npm 源。 参考 参考element-ui源码 1， 首先是安装命令 12345678910//全局安装npm install 模块名 -g//本地安装npm install 模块名//一次性安装多个npm install 模块1 模块2 模块3 //安装开发时依赖包npm install 模块名 --save-dev//安装运行时依赖包npm install 模块名 --save 2， 查看安装的目录 1234//查看项目中模块所在的目录npm root//查看全局安装的模块所在目录npm root -g 3， 查看npm的所有命令命令 1npm help 4，查看某个包的各种属性 12//查看某个包对于各种包的依赖关系 npm view 模块名 dependencies 5，查看包的源文件地址 12//查看包的源文件地址npm view 模块名 repository.url 6 查看当前模块依赖的node最低版本号 1npm view 模块名 engines 查看模块的当前版本号 1234npm view 模块名 version//需要注意的是查看到的模块版本是该模块再远程仓库的版本号，并不是当前项目中所依赖的版本号。//查看当前项目中应用的某个模块的版本号的命令为npm list 模块名 version 查看模块的历史版本和当前版本 1npm view 模块名 versions 查看一个模块的所有信息 1npm view 模块名 7，查看npm使用的所有文件夹 1npm help folders 8，用于更改包内容后进行重建 1npm rebuild 模块名 9，检查包是否已经过时 12//此命令会列出所有已经过时的包，可以及时进行包的更新npm outdated 10，更新node模块 1234567npm update 模块名//当然你也可以update 该模块到指定版本npm update 模块名 @版本号//如果安装到最新版本可以使用以下命令npm install 模块名@latest //如果当前的版本号为2.5.1，是没办法进行npm update 模块名 @2.3.1 将模块版本号变为2.3.1的，当然，你可以先uninstall，然后进行install @2.3.1 11，卸载node模块 1npm uninstall 模块名 12，访问package.json的字段文档 1npm help json 13，发布一个npm包的时候，需要检验某个包名是否已经存在 1npm search 模块名 14，npm init：引导你创建一个package.json文件，包括名称、版本、作者这些信息 清除npm的缓存 12npm cache clean//慎重使用改命令 15, npm root 查看当前包的安装路径，npm root -g 查看全局的包的安装路径 16，npm -v 查看npm的版本 17，查看某个模块的bugs列表界面 12npm bugs 模块名//例如运行npm bugs chai则会打开vue仓库的issue，效果如下图 npm bugs 18，打开某个模块的仓库界面 12npm repo 模块名//例如运行npm repo vue则会打开vue线上仓库，效果如下图 npm bugs 打开某个模块的文档 12npm docs 模块名//例如运行npm docs vue则会打开vue的readme.md文档 打开某个模块的主页 12npm home 模块名//例如运行npm home vue则会打开vue模块的主页 查看当前已经安装的模块 123npm list//当然我们也可以限制输入的模块层级，例如npm list --depth=0 npm list 清除未被使用到的模块 12//有时在我们使用npm list的时候，可能会碰到一些问题，就是有些模块并没有被项目引用使用，我们还是安装了这些模块，那么我们可以一键清除这些没有使用到的模块npm prune 版本控制我们使用node开发时，经常需要依赖一些模块，我们进行了下载之后，便一直在该版本的模块环境下进行开发，但是线上的服务器一般都是根据依赖来配置文件，重新下载各个模块，但是保不齐某个模块的版本已经更新了，这时线上的包会更新到最新的版本，但你的代码还是依据老版本来写的，这时可能会产生一些不知名的Bug, 首先看npm包的版本号的格式X.Y.Z,版本好的格式遵循semver 2.0规范，其中X为主版本号，只有更新了不向下兼容的API时进行修改主版本号，Y为次版本号，当模块增加了向下兼容的功能时进行修改，Z为修订版本号，当模块进行了向下兼容的bug修改后进行修改,这就是“语义化的版本控制”。 默认情况下，当用--save或者--save-dev安装一个模块时，npm通过脱字符(^)来限定所安装模块的主版本号，而该脱字符对于不同的版本号有不同的更新机制 ^1.2.1 代表的更新版本范围为 >=1.2.1 && < 2.0.0 ^0.2.1 代表的更新版本范围为 >=0.2.1 && < 0.3.0 ^0.0.2 代表的更新版本范围为 0.0.2（相当于锁定为了0.0.2版本） ##### 对于上述字符的版本控制，我们可以来进行一个尝试:首先可以看到package.json中对于vuex的版本依赖为^2.3.1 version1 然后查看以下项目中安装的vuex模块的版本号 version2 果然没错，改版本号为2.3.1，接下来我们看一下vuex的历史版本（npm view vuex versions） version3 可以看到2.3.1-2.5.0之后到了3.0.0，接下来运行npm update vuex,查看以下更新后的版本 version3 现在我们看到更新后的vuex版本号为2.5.0 < 3.0.0,可以验证第一条规范。 我们再来验证下主版本号为0的版本控制情况，先将当前项目依赖的vuex版本改为@0.6.1版本. 1234npm uninstall vuex//卸载vuex成功npm install vuex@0.6.1 --save//安装vuex0.6.1版本成功 version5 然后更新当前项目中的vuex版本，执行代码 npm update vuex version5 可以通过npm view vuex versions看到vuex的版本历程，在0.6.3之上为0.7.0，所以当使用脱字符(^)来控制版本号时，当主版本号为0，即代表该模块在快速构建中时，更新项目时的版本范围只能更新修订版本号Z。 对于第三种情况，当主版本和此版本都为0时，代表着该模块处于一个极其不稳定的状态，在执行update时并不会进行版本更新。 波浪号(~)是限定模块的次要版本，（以下规则测试方法同上，便不一 一测试） ~1.5.1允许安装版本号大于1.5.1但小于1.6.0版本的模块 ~0.5.1允许安装版本号为0.6.0 当主版本号/次版本号/修订版本号为X or x or *时，那么update或install是会下载该分支最新的版本号 (*)跟新或安装模块时会安装>=0.0.0的最新版本 1.x 表示的更新范围为>=1.0.0&&< 2.0.0 1.2.x 表示的更新范围为>=1.2.0&&< 1.3.0 更多版本规范 1，当然我们也可以把项目依赖的包固定在某一个版本，强制大家安装相同的依赖树，如下所示： 12npm install react --save -E//此命令会将react的版本号进行固定，但是该方式只能控制项目中直接依赖的包的版本，无法控制项目模块中依赖的包的版本号，所以这种方式也无法让不同的使用者得到相同的依赖树。 2，此外我们还可以使用npm shrinkwrap,可以将项目中的模块版本进行精确锁定： 这时候只需要运行命令 npm shrinkwrap,便会产生一个npm-shrinkwrap.json文件，这个文件保存了所有当前使用的依赖模块的版本：把该文件提交到git仓库中，这样其他人在clone你的项目的时候，执行npm install命令时，npm检测到该文件中的信息会完整的还原出完全相同的依赖树，具体的使用方法如下： 123npm install --save-dev react //安装reactnpm prune //清除未被使用的模块npm shrinkwrap 但是使用这种方法，安装一个模块包的方式比较繁琐。 3，使用yarn我们也可以得到模块包精确控制的结果 yarn是一个与npm兼容的node包管理器，使用它安装npm包，会自动在项目目录创建一个yarn.lock文件，该文件包含了当前项目中所安装的依赖包的版本信息，其他人在使用yarn安装项目的依赖包时就可以通过该文件创建一个完全相同的依赖环境。 使用方法如下： 123yarn init //使用yarn创建一个项目yarn add 模块名 //使用yarn 安装一个包//还有很多yarn命令 此外，yarn除了可以自动帮我们锁定依赖包的版本，yarn还在本地缓存已经安装过的包，当再次安装时，直接从本地读取即可。安装速度得到大大提升。但yarn的使用需要整个团队都去使用，还是有一定的成本的。 综上所述，目前大多数项目中较为简单的使用规范，在项目中依赖各个模块时，对于主版本号和次版本号都为0的不稳定的项目，我们可以使用精确版本（exact）,对于主版本号为0次版本号不为0的模块和主版本号不为0的模块，使用caret Range即脱字符(^)来控制版本。当然，我们也可以对项目依赖模块的版本进行精确锁定。 SemVer(Semantic Versioning) 2.0.0SemVer是一个对npm包版本进行规范的模块，它对于npm包的版本号有着一系列的规则，以下为摘抄自SemVer 2.0.0中的规则： 在版本控制环节我们已经说过了，模块的版本号采用X.Y.Z的格式，且都必须为非负的正整数，依次为主版本号、次版本号，修改版本号。 当规定版本的模块进行发布之后，对于该模块的任何修改，都必须发布新版本。 主版本号为0.X.Y的模块处于开发阶段，模块并不稳定。 主版本号在有不向下兼容的API发布时必须修改，在主版本号递增时，次版本号和修订版本号必须重新归零。 次版本号再有向下兼容的API发布时进行递增修改，在模块中有API被弃用时也必须递增次版本号，当此版本号递增改变时，修订版本号Z必须归零。 版本的优先级就是各个版本的排序规则，判断版本优先级时，必须把版本号从左至右分为主版本号、此版本号、修订版本号、以及先行版本号来进行比较","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://qw8.github.io/tags/npm/"},{"name":"node","slug":"node","permalink":"https://qw8.github.io/tags/node/"}]},{"title":"React","slug":"knowledges/React","date":"2019-11-15T09:11:07.000Z","updated":"2023-04-14T17:01:50.000Z","comments":true,"path":"/knowledges/react.html","link":"","permalink":"https://qw8.github.io/knowledges/react.html","excerpt":"","text":"React 是什么？React 不是 MV* 框架，用于构建用户界面的 JavaScript 库，侧重于 View 层 React 主要的原理： 虚拟 DOM + diff 算法 -&gt; 不直接操作 DOM 对象 Components 组件 -&gt; Virtual DOM 的节点 State 触发视图的渲染 -&gt; 单向数据绑定 React 解决方案：React + Redux + react-router + Fetch + webpack React 组件生命周期组件的生命周期可分成三个状态： Mounting(挂载)：已插入真实 DOM Updating(更新)：正在被重新渲染 Unmounting(卸载)：已移出真实 DOM 挂载当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下： constructor(): 在 React 组件挂载之前，会调用它的构造函数。 getDerivedStateFromProps(): 在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。 render(): render() 方法是 class 组件中唯一必须实现的方法。 componentDidMount(): 在组件挂载后（插入 DOM 树中）立即调用。 render() 方法是 class 组件中唯一必须实现的方法，其他方法可以根据自己的需要来实现。 更新每当组件的 state 或 props 发生变化时，组件就会更新。 当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下： getDerivedStateFromProps(): 在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。根据 shouldComponentUpdate() 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。 shouldComponentUpdate():当 props 或 state 发生变化时，shouldComponentUpdate() 会在渲染执行之前被调用。 render(): render() 方法是 class 组件中唯一必须实现的方法。 getSnapshotBeforeUpdate(): 在最近一次渲染输出（提交到 DOM 节点）之前调用。 componentDidUpdate(): 在更新后会被立即调用。 render() 方法是 class 组件中唯一必须实现的方法，其他方法可以根据自己的需要来实现。 卸载当组件从 DOM 中移除时会调用如下方法： componentWillUnmount(): 在组件卸载及销毁之前直接调用。 为啥要用Hook1.Hook是React16.8的新增特性，它可以让我们在不编写class的情况下使用state以及其他的React特性（比如生命周期）。2.class相比函数式组件的优势：class组件内部可以定义自己的state，用来保存组件自己内部的状态；函数式组件不可以，因为函数每次调用都会产生新的临时变量。class组件有自己的生命周期，可以在对应的生命周期中完成自己的逻辑；比如在componentDidMount中发送网络请求，并且该生命周期函数只会执行一次；函数式组件在学习hooks之前，如果在函数中发送网络请求，意味着每次重新渲染都会重新发送一次网络请求。class组件可以在状态改变时只重新执行render函数以及我们希望重新调用的生命周期函数componentDidUpdate等；函数式组件在重新渲染时，整个函数都会被执行，似乎没有什么地方可以只让它们调用一次；在Hook之前，以上情况通常都用class。 3.Class组件存在的问题：复杂组件变得难以理解： 最初编写class组件时，往往逻辑比较简单，但是业务增多，class组件就会越来越复杂；比如componentDidMount中，可能就会有大量逻辑代码，包括网络请求，一些事件的监听（还需要在componentWillUnmount中移除）；而对于这样的class实际上很难拆分，因为这些逻辑往往混在一起，强行拆分反而会造成过度设计，增加代码的复杂度。难以理解的class： ES6中class相当于React的一个障碍；在class中，我们必须搞清楚this的指向到底是谁，所以需要花很多的精力去学习this； 虽然掌握this是必要，但是处理起来依然很麻烦组件复用状态很难： 在之前为了一些状态的复用，我们需要通过高阶组件或render props；像redux中connect或者react-route中的withRouter，这些高阶组件设计的目的就是为了状态的复用。或者类似于Provider，Consumer来共享一些状态，但是多次使用Consumer时，就会有很多嵌套； Hook优点可以让我们在不编写class的情况下使用state以及其他的React特性；也可以延伸很多用法解决上述问题。 Hook使用场景： Hook的出现基本可以替代class组件（除了个别场景）；若项目比较旧，并不需要直接将所有代码重构为Hooks，因为它完全向下兼容，可以渐进式地来使用；Hook只能在函数组件中使用，不能在类组件，或者函数组件之外的地方使用； React 中setState更新state何时同步何时异步？React中constructor是唯一可以初始化state的地方，也可以把它理解成一个钩子函数，该函数最先执行且只执行一次。 更新状态不要直接修改this.state。虽然状态可以改变，但不会触发组件的更新。 应当使用this.setState()，该方法接收两种参数：对象或函数。 对象：即想要修改的state 函数：接收两个函数，第一个函数接受两个参数，第一个是当前state，第二个是当前props，该函数返回一个对象，和直接传递对象参数是一样的，就是要修改的state；第二个函数参数是state改变后触发的回调。 回到主题，setState可能是异步的。对此官方有这样一段描述：setState() does not always immediately update the component. It may batch or defer the update until later. This makes reading this.state right after calling setState()a potential pitfall. 关键词：batch、defer、may。 要探究setState为什么可能是异步的，先了解setState执行后会发生什么？事实上setState内部执行过程是很复杂的，大致过程包括更新state，创建新的VNode，再经过diff算法比对差异，决定渲染哪一部分以及怎么渲染，最终形成最新的UI。这一过程包含组件的四个生命周期函数。 shouleComponentUpdate componentWillUpdate render componentDidUpdate 需要注意的是如果子组件的数据依赖于父组件，还会执行一个钩子函数componentWillReceiveProps。 假如setState是同步更新的，每更新一次，这个过程都要完整执行一次，无疑会造成性能问题。事实上这些生命周期为纯函数，对性能还好，但是diff比较、更新DOM总消耗时间和性能吧。 此外为了批次和效能，多个setState有可能在执行过程中还会被合并，所以setState延时异步更新是很合理的。 setState何时同步何时异步？由React控制的事件处理程序，以及生命周期函数调用setState不会同步更新state 。 React控制之外的事件中调用setState是同步更新的。比如原生js绑定的事件，setTimeout/setInterval等。 大部分开发中用到的都是React封装的事件，比如onChange、onClick、onTouchMove等，这些事件处理程序中的setState都是异步处理的。 看以下case： 123456789101112131415161718192021constructor() &#123; this.state = &#123; count: 10 &#125; this.handleClickOne = this.handleClickOne.bind(this) this.handleClickTwo = this.handleClickTwo.bind(this)&#125;render() &#123; return ( &lt;button onClick=&#123;this.hanldeClickOne&#125;&gt;clickOne&lt;/button&gt; &lt;button onClick=&#123;this.hanldeClickTwo&#125;&gt;clickTwo&lt;/button&gt; &lt;button id=\"btn\"&gt;clickTwo&lt;/button&gt; )&#125;handleClickOne() &#123; this.setState(&#123; count: this.state.count + 1&#125;) console.log(this.state.count)&#125; 输出：10 由此可以看出该事件处理程序中的setState是异步更新state的。 123456componentDidMount() &#123; document.getElementById('btn').addEventListener('clcik', () =&gt; &#123; this.setState(&#123; count: this.state.count + 1&#125;) console.log(this.state.count) &#125;)&#125; 输出： 11 123456handleClickTwo() &#123; setTimeout(() =&gt; &#123; this.setState(&#123; count: this.state.count + 1&#125;) console.log(this.state.count) &#125;, 10) &#125; 输出： 11 以上两种方式绕过React，通过js的事件绑定程序 addEventListener 和使用setTimeout/setInterval 等 React 无法掌控的 APIs情况下，setState是同步更新state。 React是怎样控制异步和同步的呢？在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到队列中延时更新，而 isBatchingUpdates 默认是 false，表示 setState 会同步更新 this.state；但是，有一个函数 batchedUpdates，该函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会先调用这个 batchedUpdates将isBatchingUpdates修改为true，这样由 React 控制的事件处理过程 setState 不会同步更新 this.state。 img 多个setState调用会合并处理1234567render() &#123; console.log('render')&#125;hanldeClick() &#123; this.setState(&#123; name: 'jack' &#125;) this.setState(&#123; age: 12 &#125;)&#125; 在hanldeClick处理程序中调用了两次setState，但是render只执行了一次。因为React会将多个this.setState产生的修改放在一个队列里进行批延时处理。 参数为函数的setState用法先看以下case： 12345handleClick() &#123; this.setState(&#123; count: this.state.count + 1 &#125;)&#125; 以上操作存在潜在的陷阱，不应该依靠它们的值来计算下一个状态。 1234567891011handleClick() &#123; this.setState(&#123; count: this.state.count + 1 &#125;) this.setState(&#123; count: this.state.count + 1 &#125;) this.setState(&#123; count: this.state.count + 1 &#125;)&#125; 最终的结果只加了1 因为调用this.setState时，并没有立即更改this.state，所以this.setState只是在反复设置同一个值而已，上面的代码等同于这样 12345678910111213handleClick() &#123; const count = this.state.count this.setState(&#123; count: count + 1 &#125;) this.setState(&#123; count: count + 1 &#125;) this.setState(&#123; count: count + 1 &#125;)&#125; count相当于一个快照，所以不管重复多少次，结果都是加1。 此外假如setState更新state后我希望做一些事情，而setState可能是异步的，那我怎么知道它什么时候执行完成。所以setState提供了函数式用法，接收两个函数参数，第一个函数调用更新state，第二个函数是更新完之后的回调。 第一个函数接收先前的状态作为第一个参数，将此次更新被应用时的props做为第二个参数。 1234567891011increment(state, props) &#123; return &#123; count: state.count + 1 &#125;&#125;handleClick() &#123; this.setState(this.increment) this.setState(this.increment) this.setState(this.increment)&#125; 结果: 13 对于多次调用函数式setState的情况，React会保证调用每次increment时，state都已经合并了之前的状态修改结果。 也就是说，第一次调用this.setState(increment)，传给increment的state参数的count是10，第二调用是11，第三次调用是12，最终handleClick执行完成后的结果就是this.state.count变成了13。 值得注意的是：在increment函数被调用时，this.state并没有被改变，依然要等到render函数被重新执行时（或者shouldComponentUpdate函数返回false之后）才被改变，因为render只执行一次。 让setState接受一个函数的API的设计是相当棒的！不仅符合函数式编程的思想，让开发者写出没有副作用的函数，而且我们并不去修改组件状态，只是把要改变的状态和结果返回给React，维护状态的活完全交给React去做。正是把流程的控制权交给了React，所以React才能协调多个setState调用的关系。 在同一个事件处理程序中不要混用case: 1234567891011increment(state, props) &#123; return &#123; count: state.count + 1 &#125;&#125;handleClick() &#123; this.setState(this.increment) this.setState(&#123; count: this.state.count + 1 &#125;) this.setState(this.increment)&#125; 结果： 12 第一次执行setState，count为11，第二次执行，this.state仍然是没有更新的状态，所以this.state.count又打回了原形为10，加1以后变成11，最后再执行setState，所以最终count的结果是12。（render依然只执行一次） setState的第二个回调参数会在更新state，重新触发render后执行。 react-router 路由系统的实现原理？ 实现原理：location 与 components 之间的同步 路由的职责是保证 UI 和 URL 的同步 在 react-router 中，URL 对应 Location 对象，UI 由 react components 决定 因此，路由在 react-router 中就转变成 location 与 components 之间的同步 React 中 keys 的作用是什么？ Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识 在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性 传入 setState 函数的第二个参数的作用是什么？ 该函数会在setState函数调用完成并且组件开始重渲染的时候被调用，我们可以用该函数来监听渲染是否完成： 1234this.setState( &#123; username: &apos;tylermcginnis33&apos; &#125;, () =&gt; console.log(&apos;setState has finished and the component has re-rendered.&apos;)) 12345this.setState((prevState, props) =&gt; &#123; return &#123; streak: prevState.streak + props.count &#125;&#125;) React 中 refs 的作用是什么 Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄 可以为元素添加ref属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回 在生命周期中的哪一步你应该发起 AJAX 请求 我们应当将AJAX 请求放到 componentDidMount 函数中执行，主要原因有下 React 下一代调和算法 Fiber 会通过开始或停止渲染的方式优化应用性能，其会影响到 componentWillMount 的触发次数。对于 componentWillMount 这个生命周期函数的调用次数会变得不确定，React 可能会多次频繁调用 componentWillMount。如果我们将 AJAX 请求放到 componentWillMount 函数中，那么显而易见其会被触发多次，自然也就不是好的选择。 如果我们将 AJAX 请求放置在生命周期的其他函数中，我们并不能保证请求仅在组件挂载完毕后才会要求响应。如果我们的数据请求在组件挂载之前就完成，并且调用了setState函数将数据添加到组件状态中，对于未挂载的组件则会报错。而在 componentDidMount 函数中进行 AJAX 请求则能有效避免这个问题 shouldComponentUpdate 的作用 shouldComponentUpdate 允许我们手动地判断是否要进行组件更新，根据组件的应用场景设置函数的合理返回值能够帮我们避免不必要的更新 如何告诉 React 它应该编译生产环境版 通常情况下我们会使用 Webpack 的 DefinePlugin 方法来将 NODE_ENV 变量值设置为 production。编译版本中 React 会忽略 propType 验证以及其他的告警信息，同时还会降低代码库的大小，React 使用了 Uglify 插件来移除生产环境下不必要的注释等信息 概述下 React 中的事件处理逻辑 为了解决跨浏览器兼容性问题，React 会将浏览器原生事件（Browser Native Event）封装为合成事件（SyntheticEvent）传入设置的事件处理器中。这里的合成事件提供了与原生事件相同的接口，不过它们屏蔽了底层浏览器的细节差异，保证了行为的一致性。另外有意思的是，React 并没有直接将事件附着到子元素上，而是以单一事件监听器的方式将所有的事件发送到顶层进行处理。这样 React 在更新 DOM 的时候就不需要考虑如何去处理附着在 DOM 上的事件监听器，最终达到优化性能的目的 createElement 与 cloneElement 的区别是什么 createElement 函数是 JSX 编译之后使用的创建 React Element 的函数，而 cloneElement 则是用于复制某个元素并传入新的 Props redux中间件 中间件提供第三方插件的模式，自定义拦截 action -&gt; reducer 的过程。变为 action -&gt; middlewares -&gt; reducer 。这种机制可以让我们改变数据流，实现如异步 action ，action 过滤，日志输出，异常报告等功能 redux-logger：提供日志输出 redux-thunk：处理异步操作 redux-promise：处理异步操作，actionCreator的返回值是promise redux有什么缺点 一个组件所需要的数据，必须由父组件传过来，而不能像flux中直接从store取。 当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新render，可能会有效率影响，或者需要写复杂的shouldComponentUpdate进行判断。 react组件的划分业务组件技术组件？ 根据组件的职责通常把组件分为UI组件和容器组件。 UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。 两者通过React-Redux 提供connect方法联系起来 react生命周期函数初始化阶段 getDefaultProps:获取实例的默认属性 getInitialState:获取每个实例的初始化状态 componentWillMount：组件即将被装载、渲染到页面上 render:组件在这里生成虚拟的DOM节点 omponentDidMount:组件真正在被装载之后 运行中状态 componentWillReceiveProps:组件将要接收到属性的时候调用 shouldComponentUpdate:组件接受到新属性或者新状态的时候（可以返回false，接收数据后不更新，阻止render调用，后面的函数不会被继续执行了） componentWillUpdate:组件即将更新不能修改属性和状态 render:组件重新描绘 componentDidUpdate:组件已经更新 销毁阶段 componentWillUnmount:组件即将销毁 react性能优化是哪个周期函数 shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom。因为dom的描绘非常消耗性能，如果我们能在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高性能 为什么虚拟dom会提高性能 虚拟dom相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操作，从而提高性能 具体实现步骤如下 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异 把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新 diff算法? 把树形结构按照层级分解，只比较同级元素。 给列表结构的每个单元添加唯一的key属性，方便比较。 React 只会匹配相同 class 的 component（这里面的class指的是组件的名字） 合并操作，调用 component 的 setState 方法的时候, React 将其标记为 - dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制. 选择性子树渲染。开发人员可以重写shouldComponentUpdate提高diff的性能 react性能优化方案 重写shouldComponentUpdate来避免不必要的dom操作 使用 production 版本的react.js 使用key来帮助React识别列表中所有子组件的最小变化 当你调用 setState 的时候，发生了什么事？将传递给 setState 的对象合并到组件的当前状态，这将启动一个和解的过程，构建一个新的 react 元素树，与上一个元素树进行对比（ diff ），从而进行最小化的重渲染。 React 项目用过什么脚手架（本题是开放性题目）creat-react-app Yeoman 等 什么时候在功能组件( Class Component )上使用类组件( Functional Component )？如果您的组件具有状态( state ) 或 生命周期方法，请使用 Class 组件。否则，使用功能组件 React 中 keys 的作用是什么？Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。 123456789render () &#123; return ( &lt;ul&gt; &#123;this.state.todoItems.map((&#123;item, key&#125;) =&gt; &#123; return &lt;li key=&#123;key&#125;&gt;&#123;item&#125;&lt;/li&gt; &#125;)&#125; &lt;/ul&gt; )&#125; 在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性。 React 优势1、React 速度很快：它并不直接对 DOM 进行操作，引入了一个叫做虚拟 DOM 的概念，安插在 javascript 逻辑和实际的 DOM 之间，性能好。 2、跨浏览器兼容：虚拟 DOM 帮助我们解决了跨浏览器问题，它为我们提供了标准化的 API，甚至在 IE8 中都是没问题的。 3、一切都是 component：代码更加模块化，重用代码更容易，可维护性高。 4、单向数据流：Flux 是一个用于在 JavaScript 应用中创建单向数据层的架构，它随着 React 视图库的开发而被 Facebook 概念化。 5、同构、纯粹的 javascript：因为搜索引擎的爬虫程序依赖的是服务端响应而不是 JavaScript 的执行，预渲染你的应用有助于搜索引擎优化。 6、兼容性好：比如使用 RequireJS 来加载和打包，而 Browserify 和 Webpack 适用于构建大型应用。它们使得那些艰难的任务不再让人望而生畏。 react diff 原理（常考，大厂必考）把树形结构按照层级分解，只比较同级元素。 给列表结构的每个单元添加唯一的 key 属性，方便比较。 React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制. 选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。 react 生命周期函数 初始化阶段： getDefaultProps:获取实例的默认属性 getInitialState:获取每个实例的初始化状态 componentWillMount：组件即将被装载、渲染到页面上 render:组件在这里生成虚拟的 DOM 节点 componentDidMount:组件真正在被装载之后 运行中状态： componentWillReceiveProps:组件将要接收到属性的时候调用 shouldComponentUpdate:组件接受到新属性或者新状态的时候（可以返回 false，接收数据后不更新，阻止 render 调用，后面的函数不会被继续执行了） componentWillUpdate:组件即将更新不能修改属性和状态 render:组件重新描绘 componentDidUpdate:组件已经更新 销毁阶段： componentWillUnmount:组件即将销毁 解析：有三大阶段，每阶段的细分 5-5-1 shouldComponentUpdate 是做什么的？（react 性能优化是哪个周期函数？）shouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。 为什么虚拟 dom 会提高性能?(必考)虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。 React 中 refs 的作用是什么？Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。我们可以为元素添加 ref 属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回： 12345678910111213class CustomForm extends Component &#123; handleSubmit = () =&gt; &#123; console.log(\"Input Value: \", this.input.value); &#125;; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;input type=\"text\" ref=&#123;input =&gt; (this.input = input)&#125; /&gt; &lt;button type=\"submit\"&gt;Submit&lt;/button&gt; &lt;/form&gt; ); &#125;&#125; 上述代码中的 input 域包含了一个 ref 属性，该属性声明的回调函数会接收 input 对应的 DOM 元素，我们将其绑定到 this 指针以便在其他的类函数中使用。另外值得一提的是，refs 并不是类组件的专属，函数式组件同样能够利用闭包暂存其值： 123456789function CustomForm(&#123; handleSubmit &#125;) &#123; let inputElement; return ( &lt;form onSubmit=&#123;() =&gt; handleSubmit(inputElement.value)&#125;&gt; &lt;input type=\"text\" ref=&#123;input =&gt; (inputElement = input)&#125; /&gt; &lt;button type=\"submit\"&gt;Submit&lt;/button&gt; &lt;/form&gt; );&#125; redux 有什么缺点 一个组件所需要的数据，必须由父组件传过来，而不能像 flux 中直接从 store 取。 当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新 render，可能会有效率影响，或者需要写复杂的 shouldComponentUpdate 进行判断。 简述 flux 思想Flux 的最大特点，就是数据的”单向流动”。 用户访问 View View 发出用户的 Action Dispatcher 收到 Action，要求 Store 进行相应的更新 Store 更新后，发出一个”change”事件 View 收到”change”事件后，更新页面 了解 redux 么，说一下 redux 吧 redux 是一个应用数据流框架，主要是解决了组件间状态共享的问题，原理是集中式管理，主要有三个核心方法，action，store，reducer，工作流程是 view 调用 store 的 dispatch 接收 action 传入 store，reducer 进行 state 操作，view 通过 store 提供的 getState 获取最新的数据，flux 也是用来进行数据操作的，有四个组成部分 action，dispatch，view，store，工作流程是 view 发出一个 action，派发器接收 action，让 store 进行数据更新，更新完成以后 store 发出 change，view 接受 change 更新视图。Redux 和 Flux 很像。主要区别在于 Flux 有多个可以改变应用状态的 store，在 Flux 中 dispatcher 被用来传递数据到注册的回调事件，但是在 redux 中只能定义一个可更新状态的 store，redux 把 store 和 Dispatcher 合并,结构更加简单清晰 新增 state,对状态的管理更加明确，通过 redux，流程更加规范了，减少手动编码量，提高了编码效率，同时缺点时当数据更新时有时候组件不需要，但是也要重新绘制，有些影响效率。一般情况下，我们在构建多交互，多数据流的复杂项目应用时才会使用它们 React 中有三种构建组件的方式React.createClass()、ES6 class 和无状态函数。 react 组件的划分业务组件技术组件？ 根据组件的职责通常把组件分为 UI 组件和容器组件。 UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。 两者通过 React-Redux 提供 connect 方法联系起来。 描述事件在 React 中的处理方式为了解决跨浏览器兼容性问题，您的 React 中的事件处理程序将传递 SyntheticEvent 的实例，它是 React 的浏览器本机事件的跨浏览器包装器。 这些 SyntheticEvent 与您习惯的原生事件具有相同的接口，除了它们在所有浏览器中都兼容。有趣的是，React 实际上并没有将事件附加到子节点本身。React 将使用单个事件监听器监听顶层的所有事件。这对于性能是有好处的，这也意味着在更新 DOM 时，React 不需要担心跟踪事件监听器。 应该在 React 组件的何处发起 Ajax 请求在 React 组件中，应该在 componentDidMount 中发起网络请求。这个方法会在组件第一次“挂载”(被添加到 DOM)时执行，在组件的生命周期中仅会执行一次。更重要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用。在 componentDidMount 中发起网络请求将保证这有一个组件可以更新了。 (在构造函数中)调用 super(props) 的目的是什么在 super() 被调用之前，子类是不能使用 this 的，在 ES2015 中，子类必须在 constructor 中调用 super()。传递 props 给 super() 的原因则是便于(在子类中)能在 constructor 访问 this.props。 除了在构造函数中绑定 this，还有其它方式吗你可以使用属性初始值设定项(property initializers)来正确绑定回调，create-react-app 也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。 为什么建议传递给 setState 的参数是一个 callback 而不是一个对象因为 this.props 和 this.state 的更新可能是异步的，不能依赖它们的值去计算下一个 state。 何为高阶组件(higher order component)高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 connect 函数。除了简单分享工具库和简单的组合，HOC 最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。 何为受控组件(controlled component)在 HTML 中，类似 &lt;input&gt;, &lt;textarea&gt; 和 &lt;select&gt; 这样的表单元素会维护自身的状态，并基于用户的输入来更新。当用户提交表单时，前面提到的元素的值将随表单一起被发送。但在 React 中会有些不同，包含表单元素的组件将会在 state 中追踪输入的值，并且每次调用回调函数时，如 onChange 会更新 state，重新渲染组件。一个输入表单元素，它的值通过 React 的这种方式来控制，这样的元素就被称为”受控元素”。 在 React 当中 Element 和 Component 有何区别？React Element 是描述屏幕上所见内容的数据结构，是对于 UI 的对象表述。典型的 React Element 就是利用 JSX 构建的声明式代码片然后被转化为 createElement 的调用组合。 React Component 是一个函数或一个类，可以接收参数输入，并且返回某个 React Element (组件的)状态(state)和属性(props)之间有何区别 State 是一种数据结构，用于组件挂载时所需数据的默认值。State 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。 Props(properties 的简写)则是组件的配置。props 由父组件传递给子组件，并且就子组件而言，props 是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据–回调函数也可以通过 props 传递。 展示组件(Presentational component)和容器组件(Container component)之间有何区别？ 展示组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态。 容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 Flux actions，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源。 类组件(Class component)和 函数式组件(Functional component)之间有何区别？ 函数式组件比类组件操作简单，只是简单的调取和返回 JSX；而类组件可以使用生命周期函数来操作业务 函数式组件可以理解为静态组件（组件中的内容调取的时候已经固定了，很难再修改），而类组件，可以基于组件内部的状态来动态更新渲染的内容 类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 store 并维持状态 当组件仅是接收 props，并将组件自身渲染到页面时，该组件就是一个 ‘无状态组件(stateless component)’，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件(dumb components)或展示组件 createElement 和 cloneElement 有什么区别？传入的第一个参数不同 React.createElement():JSX 语法就是用 React.createElement()来构建 React 元素的。它接受三个参数，第一个参数可以是一个标签名。如 div、span，或者 React 组件。第二个参数为传入的属性。第三个以及之后的参数，皆作为组件的子组件。 1React.createElement(type, [props], [...children]); React.cloneElement()与 React.createElement()相似，不同的是它传入的第一个参数是一个 React 元素，而不是标签名或组件。新添加的属性会并入原有的属性，传入到返回的新元素中，而旧的子元素将被替换。将保留原始元素的键和引用。 1React.cloneElement(element, [props], [...children]); setState 和 replaceState 的区别setState 是修改其中的部分状态，相当于 Object.assign，只是覆盖，不会减少原来的状态 replaceState 是完全替换原来的状态，相当于赋值，将原来的 state 替换为另一个对象，如果新状态属性减少，那么 state 中就没有这个状态了","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"React","slug":"React","permalink":"https://qw8.github.io/tags/React/"},{"name":"redux","slug":"redux","permalink":"https://qw8.github.io/tags/redux/"},{"name":"组件","slug":"组件","permalink":"https://qw8.github.io/tags/组件/"}]},{"title":"RequireJS","slug":"knowledges/RequireJS","date":"2019-10-28T11:45:42.000Z","updated":"2023-04-14T17:01:50.000Z","comments":true,"path":"/knowledges/requirejs.html","link":"","permalink":"https://qw8.github.io/knowledges/requirejs.html","excerpt":"","text":"RequireJS是一个JavaScript文件和模块加载器，可视为模块管理工具。 为什么使用RequireJS呢？ 有效防止命名冲突 声明不同JS文件之间的依赖 JS代码以模块化的方式组织 RequireJS为帮助解决前端代码库的组织难题，提供了两种解决思路： 模块化组织JS文件 异步加载JS文件 你用过 require.js 吗？它有什么特性？（1）实现 js 文件的异步加载，避免网页失去响应；（2）管理模块之间的依赖性，便于代码的编写和维护。 requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）核心是 js 的加载模块，通过正则匹配模块以及模块的依赖关系，保证文件加载的先后顺序，根据文件的路径对加载过的文件做了缓存 让你自己设计实现一个 requireJS，你会怎么做？核心是实现 js 的加载模块，维护 js 的依赖关系，控制好文件加载的先后顺序 JavaScript模块化编程JavaScript模块化编程目的是为了让开发者仅需实现核心的业务逻辑，其他都加载他人已写好的模块。但是JavaScript并不是一种模块化的编程语言，虽然ECMAScript6中间正式支持类和模块。但对于之前的版本实际上是不支持类（class），也就更不用说模块（module）。 什么是模块呢？模块是实现特定功能的一组方法。 模块的原始写法将不同函数以及记录状态的变量放在一起，算是一个模块。 12function fn1()&#123;...&#125;function fn2()&#123;...&#125; 缺点：污染全局变量，无法保证与其他模块发生变量命名冲突，而且模块成员之间看不出直接关系。 模块的对象写法将模块定义为一个对象，所有模块成员都放在对象里面。 12345678//将属性和操作都封装在对象中var module = new Object(&#123; _prop:0, fn1:function()&#123;...&#125;, fn2:function()&#123;...&#125;&#125;);// 使用时直接调用对象的属性module.fn1(); 缺点：暴露了模块成员，内部状态可被外部改写。 1module._prop = 100; 立即执行函数写法立即执行函数（IIFE, Immediately-Invoked Function Expression）可达到不暴露私有成员的目的。 123456var module = (function()&#123; var _prop = 0; var fn1 = function()&#123;...&#125;; var fn2 = function()&#123;...&#125;; return &#123;fn1:fn1, fn2:fn2&#125;;&#125;)(); 放大模式如果一个模块很大，必须分成几个部分，或者是一个模块需要继承另一个模块，此时就有必要采用放大模式（augmentation）。 1234var module = (function(mod)&#123; mod.fn = function()&#123;...&#125;; return mod;&#125;)(module); 宽放大模式浏览器环境中模块各部分通常是从网上获取的，有时不知道那个部分会首先加载。采用放大模式，第一个执行的部分可能加载一个不存在的空对象，此时需采用“宽放大模式（Loose Augmentation）”。 1234var module = (function(mod)&#123; mod.fn = function()&#123;...&#125;; return mod;&#125;)(window.module || &#123;&#125;); 输入全局变量独立性是模块的重要特点，模块内部最好不要与程序其他部分直接交互。为了在模块内调用全局变量，必须显式地将其他变量输入模块。 123var module = (function($)&#123; &#125;)(jQuery); AMD规范为什么模块很重要呢？如何规范地使用模块呢？ 因为有了模块就可很方便地使用别人的代码，想要什么样的功能就可加载什么模块。不过前提是大家必须以同样的方式编写模块。而JS模块目前还没有官方规范，通行的JS模块规范有2种方式：CommonJS和AMD。 CommonJS老实说在浏览器环境下，没有模块并不是特别大的问题，毕竟网页程序的复杂性有限。但对于服务端，一定要有模块，与操作系统和其他应用程序交互，否则根本无法编程。 2009年，美国程序员Ryan Dahl创建了NodeJS项目，将JS用于服务端编程。由此标志着JS模块化编程的正式诞生。 NodeJS的模块系统是参照CommonJS规范实现的，在CommonJS中有一个全局方法require()，用于加载模块。 12var math = require(\"math\");math.add(1, 2); 自从有了JS服务端模块以后，对于客户端模块，如何做到兼容，使得一个模块不用修改就可以在服务端和客户端浏览器上都能运行呢？由于一个重大的局限，使得CommonJS规范不适用于浏览器环境。问题是对于服务器而言模块都放在本地，可同步加载等待时间只是硬盘读取时间。但是当浏览器中使用服务端的模块时，等待时间取决于网速快慢，长时间的等待会造成浏览器处于“假死”状态。 因此浏览器端的模块不能采用“同步加载（synchronous）”，只能采用“异步加载（asynchronous）”方式，这就是AMD规范诞生的背景。 AMDAMD(Asynchronous Module Definition)异步模块加载，模块加载不影响后续语句的执行。所有依赖于模块的语句都定义在一个回调函数中，等到加载完成后，回调函数才会执行。 AMD也采用了require()语句加载模块，不同于CommonJS的是，它要求两个参数。 12345678// module参数为一个数组，里面的成员是要加载的模块// callback参数是模块加载成功后执行的回调函数require([module], callback)// math模块与math.add()加载不是同步的，浏览器不会发生假死，因此AMD比较适合浏览器环境。require([\"math\"], function(math)&#123; math.add(1, 2);&#125;); RequireJS早期JS代码都会写在一个文件中，仅需加载一个文件即可。后来代码越来越多，必须分割成多个文件，依次加载。问题是这种加载的方式，浏览器会停止页面渲染，加载文件越多，网页失去响应的时间越长。另外JS文件之间存在依赖关系，必须严格保证加载顺序。当依赖关系非常复杂的时候，代码的编写和维护变得异常困难。 RequireJS的诞生是为了解决这两个问题： 实现JS文件的异步加载避免页面失去响应 管理模块之间的依赖关系，便于代码编写和维护。 加载资源文件1&lt;script src=\"https://cdn.bootcss.com/require.js/2.3.5/require.js\"&gt;&lt;/script&gt; 在引入require.js文件之后，整个windows对象就有require()方法。可通过require()方法来加载其他JS文件。RequireJS的入口是引入时指定的data-main属性，在RequireJS引入后，会自动执行指向data-main属性所指定的入口文件。data-main=&quot;js/main&quot;表示让RequireJS去js目录下寻找main.js文件，默认main.js是项目全局配置文件。 由于引入RequireJS文件本身可能会造成页面失去响应，解决的方式可将其放在网页底部加载，或使用延迟加载。 1&lt;script src=\"./assets/scripts/require-2.3.5.js\" data-main=\"js/main\" async=\"true\" defer&gt;&lt;/script&gt; async=&quot;true&quot;的作用和jQuery中AJAX的async=true的目的一样，表示一边加载RequireJS一边执行它。如果设置为false则表示等待RequireJS完全加载完成后才执行，这种方式的缺陷是在网络延迟较大时页面会出现空白。如果script标签不再head中而在页面尾部，则不会出现空白现象。另外，IE并不支持async属性，仅支持defer属性。 主模块data-main加载的是主模块，意思是页面的入口，类似C语言的main()函数，所有代码从此处开始运行。 RequireJS以一个相对于baseUrl的地址来加载所有代码，页面顶层``标签内含有一个特殊的属性data-main，RequireJS使用它来启动脚本加载过程，baseUrl一般设置到该属性相一致的目录。RequireJS目的是鼓励代码模块化，鼓励在使用脚本时以module ID替代 URL 地址。 1234567891011$ vim index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;app&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\" src=\"./js/require-2.3.5.js\" data-main=\"js/main\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; baseUrl可通过requirejs.config手动设置，若没有显式指定config及data-main，则默认的baseUrl为包含RequireJS的那个HTML页面的所属目录。 12345678910111213$ vim js/main.js/** * RequireJS全局配置文件 */requirejs.config(&#123; //设置项目路径，项目会以baseUrl作为相对路径去查找模块文件 baseUrl:\"./js\", //预加载JS文件的配置项，默认可不用添加.js后缀 paths:&#123; //RequireJS默认假定所有的依赖资源都是JS脚本，因此无需再module ID上再加上js后缀。 jquery:\"../scripts/jquery-3.3.1\" &#125;&#125;); 正常情况下，主模块是依赖于其他模块的，此时就要使用AMD规范定义的require()函数。 12345678910111213141516171819require([module], function(module)&#123;...&#125;);/** * RequireJS全局配置文件 */requirejs.config(&#123; //设置项目路径，项目会以baseUrl作为相对路径去查找模块文件 baseUrl:\"./js\", //预加载JS文件的配置项，默认可不用添加.js后缀 paths:&#123; //RequireJS默认假定所有的依赖资源都是JS脚本，因此无需再module ID上再加上js后缀。 jquery:\"https://cdn.bootcss.com/jquery/3.3.1/jquery\", bootstrap:\"https://cdn.bootcss.com/bootstrap/4.1.1/js/bootstrap\" &#125;&#125;);requirejs(['jquery', 'bootstrap'],function($, undefined)&#123;&#125;); RequireJS要求每个模块是一个的单独的JS文件，如果加载多个模块会发出多次HTTP请求，会影响页面的加载速度。 RequireJS加载的模块采用AMD规范，也就是说模块必须按照AMD的规定来书写。具体说来模块必须采用特定的define()函数来定义，如果一个模块不依赖其他模块，可直接定义在define()函数之中。 但是实际上，虽然部分流行的函数库符合AMD规范，但更多的库并不符合。RequireJS如何加载非规范的模块呢？在使用require()之前，需在require.config()函数中定义非规范模块的特征。 require.config()接收一个配置对象，此对象除了paths属性之外，还有一个shim属性，专门用来配置不兼容的模块。每个模块需要定义exports值即输出的变量名，表明这个模块外部调用名称。其次deps数组属性表明该模块的依赖性。 RequireJS常用方法 requirejs.config() require() define() RequireJS源码解析RequireJS工作流程 载入模块 通过模块名解析出模块信息并计算出URL 通过创建script的形式将模块加载到页面 判断被加载脚本若存在依赖则加载，若不存在则直接执行factory()。 等待所有脚本都加载完毕后执行回调函数 123456// 定义全局变量var requirejs,require,define;// 自执行函数(function(global, setTimeout)&#123; //...&#125;)(this, (typeof setTimeout==='undefined'?undefined:setTimeout)); RequireJS可分为三部分 定义全局变量和帮助函数 模块加载核心部分 定义require和define方法以及项目入口","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"RequireJS","slug":"RequireJS","permalink":"https://qw8.github.io/tags/RequireJS/"},{"name":"模块化","slug":"模块化","permalink":"https://qw8.github.io/tags/模块化/"},{"name":"AMD规范","slug":"AMD规范","permalink":"https://qw8.github.io/tags/AMD规范/"}]},{"title":"TypeScript","slug":"knowledges/TypeScript","date":"2019-10-12T11:25:55.000Z","updated":"2023-04-14T17:01:50.000Z","comments":true,"path":"/knowledges/typescript.html","link":"","permalink":"https://qw8.github.io/knowledges/typescript.html","excerpt":"","text":"什么是Typescript？Typescript是强类型的Javascript超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript并不直接在浏览器上运行，需要编译器编译成纯Javascript来运行。 说说Typescripy和Javascript的区别？ img 说说Typescript的优缺点？优点： 1：快速简单，易于学习。 2：编译时提供错误检查， 在代码运行前就会进行错误提示。 3：支持所有的JS库。 4：支持ES6，提供了ES6所有优点和更高的生产力。 5：使用继承提供可重用性。 6：有助于代码结构。 7：通过定义模块来定义命名空间。 缺点： 1：需要长时间的来编译代码。 2：在使用第三方库时，需要有三方库的定义文件，并不是所有三方库都提供了定义文件，提供的定义文件是否准确也值得商榷。 Typescript有哪些基础类型？1：number 2：string 3：boolean 4：Symbol 5：Array 6：Tuple(元组) 7：enum(枚举) 8：object 9：never 表示那些永不存在的值类型。如总是抛出异常或者根本不会有返回值的函数的返回值类型。 10：void 与any相反表示没有任何类型。函数没有返回值时用void。 11：null和undefined 它们是所有类型的子类型。当你指定structNullChecks时，它们只能赋值给void或者它们自己本身。 12：any 如何编译Typescript?tsc xxx.ts 如何将多个ts文件合并成一个js文件？tsc –outfile compact.js file1.ts file2.ts file3.js 如何自动编译ts文件并实时修改？tsc –watch file.ts typescript 遇到过什么坑main.ts 报错（ Cannot find module ‘./App.vue’.） 原因： typescript 不能识别.vue 文件 解决办法： 引入 vue 的 typescript declare 库 什么是TS接口？说说它有哪些特性？TS的核心原则之一就是对值所具有的结构进行类型检查。 它有时被称为“鸭式辩型法”或“结构性子类型化”。 其作用就是为这些类型进行命名，或为你的代码或者三方代码定义契约。 特点： 1：定义对象、数组、函数、类等。 2：接口可以相互继承 3：接口可以继承类 4：可选属性与额外检查 img 如何理解Typescript中的类？并说说它有什么特性？Typescript是一种面向对象的Javascript语言，和其他任何面向对象编程的强语言一样，类是描述某一组对象共有属性状态或行为的实体。它就是构建具体对象实例的模板和蓝图。 特性： 1：继承 2：多态 3：抽象 4：封装 5：实例 Typescript支持哪些面向对象术语？1：类 2：继承 3：多态 4：抽象 5：泛化 6：接口封装 7：实例化 等等… 如何调用基类中的构造函数？super() 如何实现类的继承？extends Typescript中的模块是什么？Typescript1.5后为了与ES6术语保持一致，内部模块都称为命名空间，外部模块简称模块。 模块在自身的作用域里执行，并不是全局作用域。这就意味着模块类的类、函数、对象等对外都是不可见的。除非你通过export导出，import导入。 模块通过使用模块加载器导入另一个模块。在运行时，模块加载器负责在执行模块之前定位和执行模块的所有依赖项。JavaScript中最常用的模块加载器是用于Node.js的CommonJS模块加载器和用于Web应用程序的require.js模块加载器。 特别说明： 为了支持CommonJS和AMD语法中的exports，TS提供了export = 语法，引入方式为import xxx = require(“xxx”)； 解释下Typescript的装饰器是什么？装饰器是一种特殊类型的声明，它能被附加在类、方法、属性、访问符、参数上。 装饰器使用@expression这种方式，expression求值后必须为一个函数，它在运行时调用，被装饰器声明的信息作为参数传入。 什么是Mixins?一种通过重用组件构建类的方法。 不通过类的直接继承来实现，而是将基类作为接口来实现。对于基类实例化部分在子类中实现，基类中原型的部分在子类中进行声明占位，然后通过一个Minxin函数将基类上的原型属性拷贝到子类上。 TSD是什么？TSD是Typescript的包管理工具，我们都知道在.ts文件中引入第三方库时，第三库是需要.d.ts声明文件的，否则三方库在.ts中是无法识别报错的。 TSD就是帮我查找对应的三方库TS声明文件并下载安装。 使用过程如下： 1：npm install tsd -g 2: tsd init 3: tsd query xxx三方库 –action install 4：在使用的.ts文件中通过reference指向该声明文件 /// Declare关键字是干嘛用的？我们在.ts中使用的第三方库时没有.d.ts声明文件的时候，我们可以通过declare来写申明文件。 可以声明该模块，甚至可以直接声明一个值为any的同名的变量，然后我们就可以在代码中直接使用该三方库了。 如何让.ts文件自动生成对应的.d.ts声明文件？tsc –declaration test.ts tsconfig.json文件有什么作用？该文件存在于Typescript项目的根目录里，其作用是指定相关选项告诉ts编译器如何编译ts文件。 说说什么Typescript中的泛型？作用是什么？泛型代表的是泛指某一类型，更像是一个类型变量。由尖括号包裹。 主要作用是创建逻辑可复用的组件。 泛型可以作用在函数、类、接口上。 函数： function greet(name: T) {} 类： 123class createObj&lt;T&gt; &#123; name: T&#125; 接口： 123interface IF&lt;T&gt; &#123; name: T&#125; 泛型还可以被约束，这样就是任意类型了。 1234567interface TIF &#123; length: number&#125;function test&lt;T extends TIF&gt;(params: T) &#123; console.log(&quot;=========&gt;&gt;&gt;&quot;, params.length);&#125; 泛型约束之类型参数 123function getPropoty&lt;T, K extends keyof T&gt;(obj: T, key: K) &#123; return obj[key];&#125; 说说接口和类型别名type的区别？他们很相似，type可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。 区别一：它并不会真的创建一个新的名字，当你在编译器上将鼠标悬停在定义为该类型别名定义的变量上时返回的是该类型别名引用的对象。相反，接口会创建一个新名字 ，当你把鼠标悬停在该接口定义的变量上时返回的是该接口名。 区别二：类型别名不能extends和implements 区别三：对于元组，联合类型我们一般使用类型别名type。 什么是Typescript映射文件？.map源映射文件 它是编译后的.js与源文件之间的映射文件。调试器使用该文件，使我们可以直接调试Typescript文件而不是编译后的JS文件。 什么是类型断言？类型断言对运行没有什么影响，仅供编译器使用。 向编译器提供我们所希望的分析代码的提示。 表示断言的两种方式： 1：&lt;类型&gt;变量 2：变量 as 类型 （在tsx中只能使用这种方式） 什么是Rest参数？在不使用arguments对象的情况允许我们的函数传递可变数量的参数的另一种实现方式。 表示方式是…params。 rest参数的规则是： 1：一个函数只能有一个rest参数。 2：它只能出现在参数列表的最后一个。 3：该参数必须是数组类型。 什么是枚举？枚举可以使我们定义一些带名字的常量，用于清晰的表达意图和创建一组有区别的用例。 枚举主要分为两类。一类是基于数字的，有自增长和反向映射的特性。一类是基于字符串的。 当然还有混合了这两种基础类型的枚举，我们叫做异构枚举。 说说TS的模块解析策略，什么是相对导入？什么是非相对导入？ img img 可以通过moduleResolution属性来设置解析模式。 什么是声明合并？声明合并是编译器将2个或多个同名声明合并为一个，合并后的声明拥有被合并声明的所有特性。 目前除了类不能与其他类和变量合并外，其他声明都是可以相互合并的。 什么是Typescript?TypeScript是一种由微软开发和维护的免费开源编程语言。它是一个强类型的JavaScript超集，可编译为纯JavaScript。它是一种用于应用级JavaScript开发的语言。对于熟悉c#、Java和所有强类型语言的开发人员来说，TypeScript非常容易学习和使用。 TypeScript可以在任何浏览器、主机和操作系统上执行。TypeScript不是直接在浏览器上运行的。它需要一个编译器来编译和生成JavaScript文件。TypeScript是带有一些附加特性的ES6 JavaScript版本。 TypeScript和JavaScript有什么不同？TypeScript与JavaScript的区别如下: 编号 JavaScript TypeScript 1 它是由网景公司在1995年开发的。 它是2012年由安德斯·海尔斯伯格(Anders Hejlsberg)开发的。 2 JavaScript源文件在”。js”扩展。 TypeScript源文件是”.ts”扩展名。 3 JavaScript不支持ES6。 TypeScript 支持ES6。 4 它不支持强类型或静态类型。 它支持强类型或静态类型特性。 5 它只是一种脚本语言。 它支持面向对象的编程概念，如类、接口、继承、泛型等。 6 JavaScript没有可选的参数特性。 TypeScript有可选的参数特性。 7 它是解释语言，这就是为什么它在运行时突出显示错误。 它编译代码并在开发期间突出显示错误。 8 JavaScript不支持模块。 TypeScript支持模块。 9 在这里，number和string是对象。 在这里，number和string是接口。 10 JavaScript不支持泛型。 TypeScript支持泛型。 我们为什么需要TypeScript？我们需要TypeScript: TypeScript快速、简单，最重要的是，容易学习。 TypeScript支持面向对象的编程特性，比如类、接口、继承、泛型等等。 TypeScript在编译时提供了错误检查功能。它将编译代码，如果发现任何错误，它将在运行脚本之前突出显示这些错误。 TypeScript支持所有JavaScript库，因为它是JavaScript的超集。 TypeScript通过使用继承来支持可重用性。 TypeScript使应用程序开发尽可能的快速和简单，并且TypeScript的工具支持为我们提供了自动完成、类型检查和源文档。 TypeScript支持最新的JavaScript特性，包括ECMAScript 2015。 TypeScript提供了ES6的所有优点和更高的生产力。 TypeScript支持静态类型、强类型、模块、可选参数等。 列出Typescript的一些特性 Typescript的一些特性 列出使用Typescript的一些优点?TypeScript有以下优点。 它提供了可选静态类型的优点。在这里，Typescript提供了可以添加到变量、函数、属性等的类型。 Typescript能够编译出一个能在所有浏览器上运行的JavaScript版本。 TypeScript总是在编译时强调错误，而JavaScript在运行时指出错误。 TypeScript支持强类型或静态类型，而这不是在JavaScript中。 它有助于代码结构。 它使用基于类的面向对象编程。 它提供了优秀的工具支持和智能感知，后者在添加代码时提供活动提示。 它通过定义模块来定义名称空间概念。 Typescript的缺点是什么?TypeScript有以下缺点: TypeScript需要很长时间来编译代码。 TypeScript不支持抽象类。 如果我们在浏览器中运行TypeScript应用程序，需要一个编译步骤将TypeScript转换成JavaScript。 Web开发人员使用了几十年的JavaScript，而TypeScript不是都是新东西。 要使用任何第三方库，必须使用定义文件。并不是所有第三方库都有可用的定义文件。 类型定义文件的质量是一个问题，即如何确保定义是正确的? TypeScript的不同组件是什么?TypeScript主要有三个组件。这些都是- – TypeScript所有组件 语言language该语言由新语法、关键字、类型注释等元素组成，允许我们编写TypeScript。 编译器compilerTypeScript编译器是开源的、跨平台的，是用TypeScript编写的。它将用TypeScript编写的代码转换为JavaScript代码。它执行从TypeScript代码到JavaScript代码的解析和类型检查。它还可以帮助将不同的文件连接到单个输出文件，并生成源映射。 语言服务language service语言服务提供信息，帮助编辑器和其他工具提供更好的辅助功能，如自动重构和智能感知。 Typescript是谁开发的，目前稳定的Typescript版本是什么？typescript是由Anders Hejlsberg开发的，他也是c#语言开发团队的核心成员之一。typescript于2012年10月1日发布，被标记为0.8版。它是由Microsoft在Apache 2许可下开发和维护的。它是为开发大型应用程序而设计的。 目前稳定的TypeScript版本是3.2，于2018年9月30日发布。Typescript编译成简单的JavaScript代码，可以在任何支持ECMAScript 2015框架的浏览器上运行。它支持最新的和不断发展的JavaScript特性。 说说安装Typescript的最低要求。或者我们如何获得TypeScript并安装它？TypeScript可以通过npm (node .js包管理器)在node的帮助下进行安装和管理。要安装TypeScript，首先要确保npm安装正确，然后运行以下命令在系统上全局安装TypeScript。 1$ npm install -g typescript 它安装一个命令行代码“tsc”，它将进一步用于编译我们的Typescript代码。确保检查系统上安装的Typescript版本。 安装TypeScript需要以下步骤: 下载并运行节点的.msi安装程序。 输入命令“node -v”检查安装是否成功。 在终端窗口中输入以下命令安装Typescript: $ npm install -g Typescript 列出在Typescript中的内置类型在Typescript中，内置的数据类型也称为原始数据类型。这些数据如下所示。 typescript内置数据类型02 数字类型: 用于表示数字类型值。TypeScript中的所有数字都存储为浮点值。 语法: let标识符:number = value; 字符串类型: 它表示存储为Unicode UTF-16代码的字符序列。我们通过将字符串括在单引号或双引号中来在脚本中包含字符串。 语法: let标识符:字符串= ” “; 布尔类型: 用于表示逻辑值。当我们使用布尔类型时，我们只得到真或假的输出。布尔值是一个真值，它指定条件是否为真。 语法: let标识符:bool =布尔值; Null类型: Null表示值未定义的变量。不能直接引用空类型值本身。空类型没有用处，因为我们只能为它分配一个空值。 语法: let num: number = null; 未定义类型: 它是未定义字面量的类型。未定义的类型表示所有未初始化的变量。它是没有用的，因为我们只能分配一个未定义的值给它。这种内置类型是所有类型的子类型。 语法: let num: number =未定义; Void类型: Void是不返回任何类型值的函数的返回类型。如果没有可用的数据类型，则使用它。 语法: let unusable:void =未定义; Typescript中的变量是什么？如何在Typescript中创建变量？变量是存储位置，用于存储要被程序引用和使用的值/信息。它充当程序中值的容器。可以使用var关键字声明它。它应该在使用前声明。在Typescript中声明变量时，应该遵循某些规则- 变量名必须是字母或数字。 变量名不能以数字开头。 变量名不能包含空格和特殊字符，除了下划线(_)和美元($)符号。 我们可以通过以下四种方式之一声明一个变量: 在一条语句中声明类型和值。语法:var [identifier]: [type-annotation] = value; 声明没有值的类型。语法:var [identifier]: [type-annotation]; 在没有类型的情况下声明它的值。语法:var [identifier] = value; 声明没有值和类型。语法:var(标识符); 如何编译Typescript文件？下面是将Typescript文件编译成JavaScript时所遵循的命令。 1$ tsc &lt;TypeScript File Name&gt; 例如，编译“hello .ts”。 1$ tsc helloworld.ts 结果是helloworld.js。 是否可以将多个.ts文件合并成一个.js文件？如果是，那么如何做？是的，有可能。为此，我们需要添加——outFILE [OutputJSFileName]编译选项。 1$ tsc --outFile comman.js file1.ts file2.ts file3.ts 上面的命令将编译所有这三个.ts文件和结果将存储在一个comman.js文件中，在这种情况下，当我们不提供输出文件名像下面的命令。 1$ tsc --outFile file1.ts file2.ts file3.ts 然后file2.ts和file3.ts将被编译，并将输出放在file1.ts中，现在是file1.ts包含JavaScript代码。 能否自动编译.ts文件，并实时修改.ts文件？这是可以的，自动实时根据.ts文件变化自动编译.ts文件是可以的。这可以通过使用——watch compiler选项来实现 1tsc --watch file1.ts 上面的命令首先编译file1为file1.js，并注意文件的变化，如果检测到任何更改，它将再次编译文件。这里，我们需要确保在使用——watch选项运行时命令提示符不能关闭。 TS的接口是什么意思？参照TS来解释它们。接口是在我们的应用程序中充当契约的结构。它定义了要遵循的类的语法，这意味着实现接口的类必须实现它的所有成员。它不能被实例化，但是可以被实现它的类对象引用。无论对象是否具有特定的结构，TypeScript编译器都使用接口进行类型检查(也称为“duck typing”鸭子类型或“结构化子类型”)。 语法: 12345interface interface_name &#123; // 字段声明 // 方法声明&#125; 接口只是声明方法和字段，它不能用来建造任何东西。不需要将接口转换为JavaScript来执行，它们对运行时JavaScript没有任何影响。因此，它们的唯一目的是在开发阶段提供帮助。 你如何理解Typescript中的类？列出类的一些特性。我们知道，TypeScript是一种面向对象的JavaScript语言，支持OOP编程特性，比如类、接口等。与Java一样，类是用于创建可重用组件的基本实体。它是一组具有公共属性的对象。类是创建对象的模板或蓝图。它是一个逻辑实体。“class”关键字用于在Typescript中声明一个类。 例子: 123456789101112class Student &#123; studCode: number; studName: string; constructor(code: number, name: string) &#123; this.studName = name; this.studCode = code; &#125; getGrade() : string &#123; return &quot;A+&quot; ; &#125; &#125; 类的特征是- 继承 封装 多态性 抽象 本地Javascript支持模块吗？不。目前，本地JavaScript不支持模块。为了在Javascript中创建和使用模块，我们需要一个像CommonJS这样的外部模块。 TypeScript支持哪些面向对象的术语？TypeScript支持以下面向对象的术语。 模块 类 接口 继承 数据类型 成员函数 如何从TypeScript的子类调用基类构造函数？super()函数的作用是: 从子类中调用父类或基类构造函数。 如何在TypeScript中实现继承？继承是一种从另一个类获取一个类的属性和行为的机制。它是OOPs语言的一个重要方面，并且具有从现有类创建新类的能力，继承成员的类称为基类，继承这些成员的类称为派生类。 继承可以通过使用extend关键字来实现。我们可以通过下面的例子来理解它。 12345678910111213141516class Shape &#123; Area:number constructor(area:number) &#123; this.Area = area &#125; &#125; class Circle extends Shape &#123; display():void &#123; console.log(&quot;圆的面积: &quot;+this.Area) &#125; &#125; var obj = new Circle(320); obj.display() Typescript中的模块是什么？模块是创建一组相关变量、函数、类和接口等的强大方法。它可以在它们自己的范围内执行，而不是在全局范围内。换句话说，在模块中声明的变量、函数、类和接口不能在模块外部直接访问。 创建一个模块 可以使用export关键字创建模块，也可以在其他模块中使用import关键字。 1234567module module_name&#123; class xyz&#123; export sum(x, y)&#123; return x+y; &#125; &#125; &#125; 内部模块和外部模块有什么区别？内部模块与外部模块的区别如下: 编号 内部模块 外部模块 1 内部模块用于将类、接口、函数和变量逻辑地分组到一个单元中，并可以导出到另一个模块中。 外部模块用于隐藏模块定义的内部语句，并且只显示与声明的变量相关的方法和参数。 2 内部模块在Typescript的早期版本中。但是在最新版本的TypeScript中使用名称空间仍然支持它们。 外部模块在最新版本的TypeScript中称为模块。 3 内部模块是其他模块(包括全局模块和外部模块)的本地或导出成员。 外部模块是使用外部模块名称引用的单独加载的代码体。 4 内部模块使用指定其名称和主体的moduledeclaration来声明。 外部模块被编写为一个单独的源文件，其中包含至少一个导入或导出声明。 5 例子: module Sum { export function add(a, b) { console.log(“Sum: ” +(a+b)); } } 例子: export class Addition{ constructor(private x?: number, private y?: number){ } Sum(){ console.log(“SUM: ” +(this.x + this.y)); } } Typescript中的名称空间是什么？如何在Typescript中声明名称空间？名称空间是用于对功能进行逻辑分组的一种方式。名称空间用于在内部维护typescript的遗留代码。它封装了共享某些关系的特性和对象。名称空间也称为内部模块。名称空间还可以包括接口、类、函数和变量，以支持一组相关功能。 注意: 名称空间可以在多个文件中定义，并允许将每个文件都定义在一个地方。它使代码更容易维护。 用于创建名称空间的语法 12345678910111213namespace &lt;namespace_name&gt; &#123; export interface I1 &#123; &#125; export class c1&#123; &#125; &#125; 解释在TypeScript中的装饰器？修饰符是一种特殊类型的声明，可以应用于类、方法、访问器、属性或参数。修饰符只是以@expression符号为前缀的函数，其中表达式必须求值为一个函数，该函数将在运行时用有关修饰声明的信息调用。 TypeScript装饰器以声明的方式将注释和元数据添加到现有代码中。装饰器是为ES7提出的一个实验性特性。它已经被一些JavaScript框架使用，包括Angular 2。装饰器在未来的版本中可能会改变。 要启用对decorator的实验支持，我们必须在命令行或在我们的tsconfig.json中启用experimental aldecorators编译器选项: 命令行 1$tsc --target ES5 --experimentalDecorators tsconfig.json 123456&#123; &quot;compilerOptions&quot;: &#123; &quot;target&quot;: &quot;ES5&quot;, &quot;experimentalDecorators&quot;: true &#125; &#125; 什么是混合mixin？在Javascript中，mixin是一种从可重用组件构建类的方法，通过组合称为mixin的更简单的部分类来构建它们。 这个想法很简单，不是类a扩展类B来获得它的功能，而是函数B获取类a并返回一个新类，这个类具有这个添加的功能。函数B是一个混合函数。 TypeScript类中属性/方法的默认可见性是什么？Public是TypeScript类中属性/方法的默认可见性。 TypeScript是如何在函数中支持可选参数的？与JavaScript不同，如果我们试图调用一个函数而不提供其函数签名中声明的参数的确切数量和类型，那么TypeScript编译器将抛出一个错误。为了克服这个问题，我们可以通过使用问号符号(‘?’)来使用可选参数。这意味着可以或不可以接收值的参数可以附加一个’?”“可选的。 123function Demo(arg1: number, arg2? :number) &#123; &#125;因此，arg1总是必需的，而arg2是一个可选参数 因此，arg1总是必需的，而arg2是一个可选参数。 注意: 可选参数必须遵循要求的参数。如果我们想让arg1成为可选的，而不是arg2，那么我们需要改变顺序，arg1必须放在arg2之后。 123function Demo(arg2: number, arg1? :number) &#123; &#125; JavaScript不支持函数重载，但TypeScript是否支持函数重载？是的，TypeScript支持函数重载。但是它的实现很奇怪，当我们在TypeScript中执行函数重载时，我们只能实现一个带有多个签名的函数。 12345678//带有字符串类型参数的函数 function add(a:string, b:string): string; //带有数字类型参数的函数function add(a:number, b:number): number; //函数定义function add(a: any, b:any): any &#123; return a + b; &#125; 在上面的例子中，前两行是函数重载声明。它有两次重载，第一个签名的参数类型为string，而第二个签名的参数类型为number。第三个函数包含实际实现并具有any类型的参数。任何数据类型都可以接受任何类型的数据。然后，实现检查所提供参数的类型，并根据供应商参数类型执行不同的代码段。 可以调试任何TypeScript文件吗？是的。要调试任何TypeScript文件，我们需要.js源映射文件。因此，使用—sourcemap标志编译.ts文件以生成源映射文件。 1$ tsc -sourcemap file1.ts 这将创建file1.js和file1.js.map，而file1.js的最后一行是源映射文件的引用。 1//# sourceMappingURL=file1.js.map 什么是TypeScript定义管理器？为什么我们需要它？TypeScript定义管理器(TSD)是一个包管理器，用于直接从社区驱动的DefinitelyTyped库中搜索和安装TypeScript定义文件。 假设我们想在.ts文件中使用一些jQuery代码。 1$(document).ready(function() &#123; //Your jQuery code &#125;); 现在，当我们尝试使用tsc编译它时，它会给出一个编译时错误: 找不到名称“$”。因此，我们需要通知TypeScript编译器“$”属于jQuery。要做到这一点，TSD就要发挥作用。我们可以下载jQuery类型定义文件并将其包含在.ts文件中。以下是实现这一目标的步骤: 首先,安装TSD中。 1$ npm install tsd -g 在TypeScript目录中，通过运行创建一个新的TypeScript项目 1$ tsd init 然后安装jQuery的定义文件。 1tsd query jquery --action install 上面的命令将下载并创建一个包含以“.d.ts”结尾的jQuery定义文件的新目录。现在，通过更新TypeScript文件以指向jQuery定义来包含定义文件。 123/// &lt;reference path=&quot;typings/jquery/jquery.d.ts&quot; /&gt; $(document).ready(function() &#123; //To Do &#125;); 现在，再次编译。这次将生成js文件，没有任何错误。因此，TSD的需要帮助我们获得所需框架的类型定义文件。 什么是TypeScript Declare关键字?我们知道所有的JavaScript库/框架都没有TypeScript声明文件，但是我们希望在TypeScript文件中使用它们时不会出现编译错误。为此，我们使用declare关键字。在我们希望定义可能存在于其他地方的变量的环境声明和方法中，可以使用declare关键字。 例如，假设我们有一个名为myLibrary的库，它没有TypeScript声明文件，在全局命名空间中有一个名为myLibrary的命名空间。如果我们想在TypeScript代码中使用这个库，我们可以使用以下代码: 1declare var myLibrary; TypeScript运行时将把myLibrary变量赋值为任意类型。这是一个问题，我们不会得到智能感知在设计时，但我们将能够使用库在我们的代码。 如何从任何.ts文件生成TypeScript定义文件?我们可以使用tsc编译器从任何.ts文件生成TypeScript定义文件。它将生成一个TypeScript定义，使我们的TypeScript文件可重用。 1tsc --declaration file1.ts 什么是tsconfig.son文件吗？tsconfig.son文件是json格式的文件。tsconfig.json文件中，我们可以指定各种选项告诉编译器如何编译当前项目。目录中存在tsconfig.json文件，表明该目录是TypeScript项目的根目录。 下面是一个示例tsconfig.json文件。 12345678910111213141516&#123; &quot;compilerOptions&quot;: &#123; &quot;declaration&quot;: true, &quot;emitDecoratorMetadata&quot;: false, &quot;experimentalDecorators&quot;: false, &quot;module&quot;: &quot;none&quot;, &quot;moduleResolution&quot;: &quot;node&quot; &quot;removeComments&quot;: true, &quot;sourceMap&quot;: true &#125;, &quot;files&quot;: [ &quot;main.ts&quot;, &quot;othermodule.ts&quot; ] &#125; 解释TypeScript中的泛型？TypeScript泛型是一个提供创建可重用组件方法的工具。它能够创建可以处理多种数据类型而不是单一数据类型的组件。泛型在不影响性能或生产率的情况下提供类型安全性。泛型允许我们创建泛型类、泛型函数、泛型方法和泛型接口。 在泛型中，类型参数写在开(&lt;)和闭(&gt;)括号之间，这使得它是强类型集合。泛型使用一种特殊类型的类型变量，它表示类型。泛型集合只包含类似类型的对象。 12345678function identity&lt;T&gt;(arg: T): T &#123; return arg; &#125; let output1 = identity&lt;string&gt;(&quot;myString&quot;); let output2 = identity&lt;number&gt;( 100 ); console.log(output1); console.log(output2); TypeScript是否支持所有面向对象的原则？是的，TypeScript支持所有面向对象的原则。面向对象编程有四个主要原则: 封装, 继承, 抽象, 多态性。 如何检查TypeScript中的null和undefined ？通过使用一个缓冲检查，我们可以检查空和未定义: 123if (x == null) &#123; &#125; 如果我们使用严格的检查，它将总是对设置为null的值为真，而对未定义的变量不为真。 例子 123456789101112131415var a: number; var b: number = null; function check(x, name) &#123; if (x == null) &#123; console.log(name + &apos; == null&apos;); &#125; if (x === null) &#123; console.log(name + &apos; === null&apos;); &#125; if (typeof x === &apos;undefined&apos;) &#123; console.log(name + &apos; is undefined&apos;); &#125; &#125; check(a, &apos;a&apos;); check(b, &apos;b&apos;); 输出 1234&quot;a == null&quot; &quot;a is undefined&quot; &quot;b == null&quot; &quot;b === null&quot; 我们可以在后端使用TypeScript吗？如果可以，如何使用？是的，我们可以在后端使用TypeScript。我们可以通过下面的例子来理解它。在这里，我们选择Node.js，并具有一些额外的类型安全性和该语言带来的其他抽象。 安装TypeScript编译器 1npm i -g typescript TypeScript编译器接受tsconfig.json文件中的选项，此文件确定将构建的文件放在何处。 12345678&#123; &quot;compilerOptions&quot;: &#123; &quot;target&quot;: &quot;es5&quot;, &quot;module&quot;: &quot;commonjs&quot;, &quot;declaration&quot;: true, &quot;outDir&quot;: &quot;build&quot; &#125; &#125; 编译ts文件 1tsc 运行 1node build/index.js TS的“接口”和“type”语句有什么区别？123456789nterface X &#123; a: number b: string &#125; type X = &#123; a: number b: string &#125;; 编号 接口 Type**类型** 1 接口声明总是引入指定的对象类型。 类型别名声明可以为任何类型(包括基元类型、联合类型和交集类型)引入名称。 2 接口可以在extends或implements子句中命名。 对象类型文字的类型别名不能在“扩展”或“实现”子句中命名。 3 接口创建一个到处使用的新名称。 类型别名不创建新名称。 4 一个接口可以有多个合并声明。 对象类型字面量的类型别名不能有多个合并声明。 TypeScript中的环境是什么？何时使用它？环境声明告诉编译器其他地方存在的实际源代码。如果这些源代码在运行时不存在，而我们尝试使用它们，则它将中断而不会发出警告。 环境声明文件类似于docs文件。如果源更改，则还需要保持文档更新。如果环境声明文件未更新，那么我们将得到编译器错误。 Ambient声明使我们能够安全轻松地使用现有流行的JavaScript库，例如jquery，angularjs，nodejs等。 什么是TypeScript映射文件？ TypeScript Map文件是一个源映射文件，其中包含有关我们原始文件的信息。 .map文件是源映射文件，可让工具在发出的JavaScript代码和创建它的TypeScript源文件之间进行映射。 许多调试器可以使用这些文件，因此我们可以调试TypeScript文件而不是JavaScript文件。 什么是TypeScript中的类型断言？类型断言的工作方式类似于其他语言中的类型转换，但是它不像其他语言一样执行C＃和Java那样的类型检查或数据重组。类型转换附带运行时支持，而类型断言对运行时没有影响。但是，类型断言仅由编译器使用，并向编译器提供有关我们希望如何分析代码的提示。 例 123let empCode: any = 111; let employeeCode = &lt;number&gt; code; console.log(typeof(employeeCode)); // : number TypeScript的as语法是什么？as是TypeScript中类型断言的附加语法，引入as-语法的原因是原始语法()与JSX冲突。 例子 12et empCode: any = 111; let employeeCode = code as number; 当使用带有JSX的TypeScript时，只允许as风格的断言。 什么是JSX？我们可以在TypeScript中使用JSX吗？JSX只不过是带有不同扩展名的Javascript。Facebook提出了这个新的扩展，以便与JavaScript中类似xml的HTML实现区分开来。 JSX是一种可嵌入的类似xml的语法。它将被转换成有效的JavaScript。JSX随着React框架而流行起来。TypeScript支持嵌入、类型检查和直接将JSX编译成JavaScript。 要使用JSX，我们必须做两件事。 使用.tsx扩展名命名文件 启用jsx选项 什么是Rest参数？rest参数用于向函数传递零个或多个值。它是通过在参数前加上三个点字符(‘…’)来声明的。它允许函数在不使用arguments对象的情况下拥有可变数量的参数。当我们有不确定数量的参数时，这是非常有用的。 rest参数要遵循的规则: 一个函数中只允许有一个rest参数。 它必须是数组类型。 它必须是参数列表中的最后一个参数。 1234567891011function sum(a: number, ...b: number[]): number &#123; let result = a; for (var i = 0; i &lt; b.length; i++) &#123; result += b[i]; &#125; console.log(result); &#125; let result1 = sum(3, 5); let result2 = sum(3, 5, 7, 9); 解释TypeScript的Enum枚举类型？枚举或枚举是一种数据类型，允许我们定义一组命名常量。使用枚举可以更容易地记录意图，或者创建一组不同的案例。它是相关值的集合，可以是数值或字符串值。 例子 123456789enum Gender &#123; Male, Female Other &#125; console.log(Gender.Female); // : 1 // 我们还可以通过enum值的number值来访问它console.log(Gender[1]); // : Female 解释相对模块和非相对模块的导入 非相对 相对 非相对导入可以相对于baseUrl解析，也可以通过路径映射解析。换句话说，我们在导入任何外部依赖项时使用非相对路径。 例子**:** import * as $ from “jquery”; import { Component } from “@angular/core”; 相对导入可以用于我们自己的模块，这些模块保证在运行时维护它们的相对位置。相对导入以/、./或../开头。 例子: import Entry from “./components/Entry”; import {DefaultHeaders} from “../constants/http”; 什么是匿名函数？匿名函数是声明时没有任何命名标识符的函数。这些函数是在运行时动态声明的。与标准函数一样，匿名函数可以接受输入和返回输出。匿名函数在初始创建之后通常是不可访问的。 例子 12345let myAdd = function(x: number, y: number): number &#123; return x + y; &#125;; console.log(myAdd()) 什么是声明合并？声明合并是编译器随后合并两个或多个独立声明的过程。将具有相同名称的声明声明为单个定义。这个合并的定义具有两个原始声明的特性。 最简单也是最常见的声明合并类型是接口合并。在最基本的层次上，merge将两个声明的成员机械地连接到一个具有相同名称的接口中。 例子 123456789101112interface Cloner &#123; clone(animal: Animal): Animal; &#125; interface Cloner &#123; clone(animal: Sheep): Sheep; &#125; interface Cloner &#123; clone(animal: Dog): Dog; clone(animal: Cat): Cat; &#125; 这三个接口将合并为一个单独的声明 123456interface Cloner &#123; clone(animal: Dog): Dog; clone(animal: Cat): Cat; clone(animal: Sheep): Sheep; clone(animal: Animal): Animal; &#125; 注: 在TypeScript中不是所有的合并都允许。目前，类不能与其他类或变量合并。 TypeScript中的方法重写是什么?如果子类(子类)具有与父类中声明的相同的方法，则称为方法覆盖。换句话说，在派生类或子类中重新定义基类方法。 方法重写的规则 该方法必须具有与父类相同的名称 该方法必须具有与父类相同的参数。 必须有一个IS-A关系(继承)。 例子 1234567891011121314class NewPrinter extends Printer &#123; doPrint(): any &#123; super.doPrint(); console.log(&quot;Called Child class.&quot;); &#125; doInkJetPrint(): any &#123; console.log(&quot;Called doInkJetPrint().&quot;); &#125; &#125;let printer: new () =&gt; NewPrinter; printer.doPrint(); printer.doInkJetPrint(); Lambda/箭头函数是什么？ES6版本的TypeScript提供了定义匿名函数的简写语法，也就是用于函数表达式。这些箭头函数也称为Lambda函数。lambda函数是没有名称的函数，箭头函数省略了function关键字。 例子 12345let sum = (a: number, b: number): number =&gt; &#123; return a + b; &#125; console.log(sum(20, 30)); //returns 50 在上面，?=&gt;?是一个lambda操作符，(a + b)是函数的主体，(a: number, b: number)是内联参数。 ypeScript 是 Microsoft 开发的JavaScript 的开源超集，用于在不破坏现有程序的情况下添加附加功能。 由于其独特的优势，例如,静态类型和许多速记符号，TypeScript 现在被前端和全栈开发人员广泛用于大型项目。 TypeScript 的主要特点是什么？ 跨平台：TypeScript 编译器可以安装在任何操作系统上，包括 Windows、macOS 和 Linux。 ES6 特性：TypeScript 包含计划中的 ECMAScript 2015 (ES6) 的大部分特性，例如箭头函数。 面向对象的语言：TypeScript 提供所有标准的 OOP 功能，如类、接口和模块。 静态类型检查：TypeScript 使用静态类型并帮助在编译时进行类型检查。因此，你可以在编写代码时发现编译时错误，而无需运行脚本。 可选的静态类型：如果你习惯了 JavaScript 的动态类型，TypeScript 还允许可选的静态类型。 DOM 操作：您可以使用 TypeScript 来操作 DOM 以添加或删除客户端网页元素。 使用 TypeScript 有什么好处？ TypeScript 更具表现力，这意味着它的语法混乱更少。 由于高级调试器专注于在编译时之前捕获逻辑错误，因此调试很容易。 静态类型使 TypeScript 比 JavaScript 的动态类型更易于阅读和结构化。 由于通用的转译，它可以跨平台使用，在客户端和服务器端项目中。 TypeScript 的内置数据类型有哪些？数字类型：用于表示数字类型的值。TypeScript 中的所有数字都存储为浮点值。 1let identifier: number = value; 布尔类型：一个逻辑二进制开关，包含true或false 1let identifier: string = \" \"; Null 类型： Null 表示值未定义的变量。 1let identifier: bool = Boolean value; 未定义类型：一个未定义的字面量，它是所有变量的起点。 1let num: number = null; void 类型：分配给没有返回值的方法的类型。 1let unusable: void = undefined; TypeScript 目前的稳定版本是什么？当前的稳定版本是 4.2.3。 TypeScript 中的接口是什么？接口为使用该接口的对象定义契约或结构。 接口是用关键字定义的interface，它可以包含使用函数或箭头函数的属性和方法声明。 123456interface IEmployee &#123; empCode: number; empName: string; getSalary: (number) =&gt; number; // arrow function getManagerName(number): string; &#125; TypeScript 中的模块是什么？TypeScript 中的模块是相关变量、函数、类和接口的集合。 你可以将模块视为包含执行任务所需的一切的容器。可以导入模块以轻松地在项目之间共享代码。 123456module module_name&#123; class xyz&#123; export sum(x, y)&#123; return x+y; &#125;&#125; 后端如何使用TypeScript？你可以将 Node.js 与 TypeScript 结合使用，将 TypeScript 的优势带入后端工作。 只需输入以下命令，即可将 TypeScript 编译器安装到你的 Node.js 中： 1npm i -g typescript TypeScript 中的类型断言是什么？TypeScript 中的类型断言的工作方式类似于其他语言中的类型转换，但没有 C# 和 Java 等语言中可能的类型检查或数据重组。类型断言对运行时没有影响，仅由编译器使用。 类型断言本质上是类型转换的软版本，它建议编译器将变量视为某种类型，但如果它处于不同的形式，则不会强制它进入该模型。 如何在 TypeScript 中创建变量？你可以通过三种方式创建变量：var，let，和const。var是严格范围变量的旧风格。你应该尽可能避免使用，var因为它会在较大的项目中导致问题。 1var num:number = 1; let是在 TypeScript 中声明变量的默认方式。与var相比，let减少了编译时错误的数量并提高了代码的可读性。 1let num:number = 1; const创建一个其值不能改变的常量变量。它使用相同的范围规则，let并有助于降低整体程序的复杂性。 1const num:number = 100; 在TypeScript中如何从子类调用基类构造函数？你可以使用该super()函数来调用基类的构造函数。 123456789101112131415161718192021class Animal &#123; name: string; constructor(theName: string) &#123; this.name = theName; &#125; move(distanceInMeters: number = 0) &#123; console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`); &#125;&#125;class Snake extends Animal &#123; constructor(name: string) &#123; super(name); &#125; move(distanceInMeters = 5) &#123; console.log(\"Slithering...\"); super.move(distanceInMeters); &#125;&#125; 解释如何使用 TypeScript mixinMixin 本质上是在相反方向上工作的继承。Mixins 允许你通过组合以前类中更简单的部分类设置来构建新类。 相反，类A继承类B来获得它的功能，类B从类A需要返回一个新类的附加功能。 TypeScript 中如何检查 null 和 undefined？你可以使用 juggle-check，它检查 null 和 undefined，或者使用 strict-check，它返回true设置为null的值，并且不会评估true未定义的变量。 1234567891011121314151617181920//juggleif (x == null) &#123; &#125;var a: number; var b: number = null; function check(x, name) &#123; if (x == null) &#123; console.log(name + ' == null'); &#125; if (x === null) &#123; console.log(name + ' === null'); &#125; if (typeof x === 'undefined') &#123; console.log(name + ' is undefined'); &#125; &#125; check(a, 'a'); check(b, 'b'); TypeScript 中的 getter/setter 是什么？你如何使用它们？Getter 和 setter 是特殊类型的方法，可帮助你根据程序的需要委派对私有变量的不同级别的访问。 Getters 允许你引用一个值但不能编辑它。Setter 允许你更改变量的值，但不能查看其当前值。这些对于实现封装是必不可少的。 例如，新雇主可能能够了解get公司的员工人数，但无权set了解员工人数。 12345678910111213141516171819const fullNameMaxLength = 10;class Employee &#123; private _fullName: string = \"\"; get fullName(): string &#123; return this._fullName; &#125; set fullName(newName: string) &#123; if (newName &amp;&amp; newName.length &gt; fullNameMaxLength) &#123; throw new Error(\"fullName has a max length of \" + fullNameMaxLength); &#125; this._fullName = newName; &#125;&#125;let employee = new Employee();employee.fullName = \"Bob Smith\";if (employee.fullName) &#123; console.log(employee.fullName);&#125; 如何允许模块外定义的类可以访问？你可以使用export关键字打开模块以供在模块外使用。 12345678910module Admin &#123; // use the export keyword in TypeScript to access the class outside export class Employee &#123; constructor(name: string, email: string) &#123; &#125; &#125; let alex = new Employee('alex', 'alex@gmail.com');&#125;// The Admin variable will allow you to access the Employee class outside the module with the help of the export keyword in TypeScriptlet nick = new Admin.Employee('nick', 'nick@yahoo.com'); 如何使用 Typescript 将字符串转换为数字？与 JavaScript 类似，你可以使用parseInt或parseFloat函数分别将字符串转换为整数或浮点数。你还可以使用一元运算符+将字符串转换为最合适的数字类型，“3”成为整数，3而“3.14”成为浮点数3.14。 12var x = \"32\";var y: number = +x; 什么是 .map 文件，为什么/如何使用它？甲.map文件是源地图，显示原始打字稿代码是如何解释成可用的JavaScript代码。它们有助于简化调试，因为你可以捕获任何奇怪的编译器行为。 调试工具还可以使用这些文件来允许你编辑底层的 TypeScript 而不是发出的 JavaScript 文件。 TypeScript 中的类是什么？你如何定义它们？类表示一组相关对象的共享行为和属性。 例如，我们的类可能是Student，其所有对象都具有该attendClass方法。另一方面，John是一个单独的 type 实例，Student可能有额外的独特行为，比如attendExtracurricular. 你使用关键字声明类class： 1234567class Student &#123; studCode: number; studName: string; constructor(code: number, name: string) &#123; this.studName = name; this.studCode = code; &#125; TypeScript 与 JavaScript 有什么关系？TypeScript 是 JavaScript 的开源语法超集，可编译为 JavaScript。所有原始 JavaScript 库和语法仍然有效，但 TypeScript 增加了 JavaScript 中没有的额外语法选项和编译器功能。 TypeScript 还可以与大多数与 JavaScript 相同的技术接口，例如 Angular 和 jQuery。 TypeScript 中的 JSX 是什么？JSX 是一种可嵌入的类似于 XML 的语法，允许你创建 HTML。TypeScript 支持嵌入、类型检查和将 JSX 直接编译为 JavaScript。 TypeScript 支持哪些 JSX 模式？TypeScript有内置的支持preserve，react和react-native。 preserve 保持 JSX 完整以用于后续转换。 react不经过 JSX 转换，而是react.createElement作为.js文件扩展名发出和输出。 react-native结合起来preserve，react因为它维护所有 JSX 和输出作为.js扩展。 如何编译 TypeScript 文件？你需要调用 TypeScript 编译器tsc来编译文件。你需要安装 TypeScript 编译器，你可以使用npm. 123npm install -g typescripttsc &lt;TypeScript File Name&gt; TypeScript 中有哪些范围可用？这与JS相比如何？ 全局作用域：在任何类之外定义，可以在程序中的任何地方使用。 函数/类范围：在函数或类中定义的变量可以在该范围内的任何地方使用。 局部作用域/代码块：在局部作用域中定义的变量可以在该块中的任何地方使用。 TypeScript 中的箭头/lambda 函数是什么？胖箭头函数是用于定义匿名函数的函数表达式的速记语法。它类似于其他语言中的 lambda 函数。箭头函数可让你跳过function关键字并编写更简洁的代码。 解释rest参数和声明rest参数的规则。其余参数允许你将不同数量的参数（零个或多个）传递给函数。当你不确定函数将接收多少参数时，这很有用。其余符号之后的所有参数…都将存储在一个数组中。例如： 123456function Greet(greeting: string, ...names: string[]) &#123; return greeting + \" \" + names.join(\", \") + \"!\";&#125;Greet(\"Hello\", \"Steve\", \"Bill\"); // returns \"Hello Steve, Bill!\"Greet(\"Hello\");// returns \"Hello !\" rest 参数必须是参数定义的最后一个，并且每个函数只能有一个 rest 参数。 什么是三斜线指令？有哪些三斜杠指令？三斜线指令是单行注释，包含用作编译器指令的 XML 标记。每个指令都表示在编译过程中要加载的内容。三斜杠指令仅在其文件的顶部工作，并且将被视为文件中其他任何地方的普通注释。 /// 是最常见的指令，定义文件之间的依赖关系。 /// 类似于path但定义了包的依赖项。 /// 允许您显式包含内置lib文件。 Omit类型有什么作用？Omit是实用程序类型的一种形式，它促进了常见的类型转换。Omit允许你通过传递电流Type并选择Keys在新类型中省略来构造类型。 1Omit&lt;Type, Keys&gt; 例如： 1234567interface Todo &#123; title: string; description: string; completed: boolean; createdAt: number;&#125;type TodoPreview = Omit&lt;Todo, \"description\"&gt;; TypeScript中如何实现函数重载？要在 TypeScript 中重载函数，只需创建两个名称相同但参数/返回类型不同的函数。两个函数必须接受相同数量的参数。这是 TypeScript 中多态性的重要组成部分。 例如，你可以创建一个add函数，如果它们是数字，则将两个参数相加，如果它们是字符串，则将它们连接起来。 1234567function add(a:string, b:string):string;function add(a:number, b:number): number;function add(a: any, b:any): any &#123; return a + b;&#125;add(\"Hello \", \"Steve\"); // returns \"Hello Steve\" add(10, 20); // returns 30 如何让接口的所有属性都可选？你可以使用partial映射类型轻松地将所有属性设为可选。 什么时候应该使用关键字unknown？unknown，如果你不知道预先期望哪种类型，但想稍后分配它，则应该使用该any关键字，并且该关键字将不起作用。 什么是装饰器，它们可以应用于什么？装饰器是一种特殊的声明，它允许你通过使用@注释标记来一次性修改类或类成员。每个装饰器都必须引用一个将在运行时评估的函数。 例如，装饰器@sealed将对应于sealed函数。任何标有 的@sealed都将用于评估sealed函数。 123function sealed(target) &#123; // do something with 'target' ...&#125; 它们可以附加到： 类声明 方法 配件 特性 参数 注意：默认情况下不启用装饰器。要启用它们，你必须experimentalDecorators从tsconfig.json文件或命令行编辑编译器选项中的字段。 ts中type和interface的区别？相同点：（1） 两者都可以定义对象和函数。 interface: 1234567 interface Person&#123; name: string; age: number;&#125;interface SetPerson &#123; (name: string, age: number): void;&#125; type: 12345type Person= &#123; name: string; age: number&#125;;type SetPerson = (name: string, age: number)=&gt; void; (2) 都可以继承。interface 定义的对象用extends继承，type用&amp;继承。二者之间可以用前面提到的自己的语法互相继承。 不同点：（1）interface可以声明合并，即声明了多个同样名称的接口可以合并成一个，而type不行。 1234567891011121314interface Pesron&#123; name: string; age: number;&#125;interface Person&#123; sex: string;&#125;/*Person接口为 &#123; name: string; age: number; sex: string ;&#125;*/ (2) type可以声明：基本类型的别名、联合类型、元组等类型，而interface不行。 12345678910111213141516 // 别名type Empty=null;// 联合类型interface Person1&#123; sayHi();&#125;interface Person2&#123; eat();&#125;type Person = Person1 | Person2;type ex = number | string;// 元组 数组中元素的数据类型都一般是相同的（any[] 类型的数组可以不同），如果存储的元素数据类型不同，则需要使用元组。type tuple=[1,&apos;good&apos;];//type 语句中可以使用 typeof 获取实例的类型进行赋值let tem = new Number();type B = typeof tem; (3)还有其他复杂操作，泛型等。 ts中interface和class的区别? 分别什么时候使用？A2: interface和class都能定义数据模型。区别：……区别：interface只是用来声明对象类型或方法，不做实现；而class是类的声明并实现。 简单的数据模型，直接用于展示的，用 interface 进行定义；比较复杂的数据模型，有字段属性定义以及一些方法，就需要使用 class 。里面还有constructor构造函数。interface 只在编译时用于类型检查，class 编译完成之后实际上就是 javascript 中的原型（prototype）。接口可以通过extends继承类，类可以通过implements去实现接口。有个很好的例子帮助理解。 ts中的泛型有什么了解？不用泛型的话，这个函数可能是下面这样：123function identity(arg: number): number &#123; return arg;&#125; 或者，我们使用any类型来定义函数： 123function identity(arg: any): any &#123; return arg;&#125; any的情况，可以是任何类型。因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。 这时，就用到了T，类型变量，它是一种特殊的变量，只用于表示类型而不是值。 123function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125; 这样就可以跟踪函数里使用的类型信息。 泛型的使用方法有两种：此处参考官方文档改写。(1) 尖括号的形式：let output = identity&lt; string&gt; (“myString”);// type of output will be ‘string’这里明确的指定了T是string类型，并做为一个参数传给函数，使用了&lt;&gt;括起来。 (2) 利用了类型推论，即编译器会根据传入的参数自动地帮助我们确定T的类型：let output = identity(“myString”); // type of output will be ‘string’ typescript 基础类型对象类型 12345678const test:&#123; name:string, age:number&#125; = &#123; name:&apos;comix&apos;, age:19&#125;复制代码 数组类型 12const testArry :string[] = [&apos;123&apos;,&apos;232&apos;]复制代码 类类型 123class Person&#123;&#125;const test:Person = new Person()复制代码 函数类型 1234const test:() =&gt; string = () =&gt; &#123; return &apos;xiao&apos;&#125;复制代码 type与interface 的区别ts中定义类型的两种方式: 接口（interface） 类型别名（type alias） interface只能定义对象类型, type声明的方式可以定义组合类型、交叉类型和原始类型 相同点： 都可以描述一个对象或函数 123456789101112131415interface User &#123; name: string age: number&#125; interface SetUser &#123; (name: string, age: number): void;&#125;复制代码type User = &#123; name: string age: number&#125;; type SetUser = (name: string, age: number): void; 不同点： type 可以声明基本类型别名，联合类型，元组等类型 interface 能够声明合并，type不可以","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://qw8.github.io/tags/TypeScript/"}]},{"title":"DOM","slug":"knowledges/DOM","date":"2019-10-09T07:38:24.000Z","updated":"2024-02-18T09:03:44.000Z","comments":true,"path":"/knowledges/dom.html","link":"","permalink":"https://qw8.github.io/knowledges/dom.html","excerpt":"","text":"DOM DOM文档对象模型，用来操作html文档 属性 属性 描述 URL 网站的url charset 查看字符集 title 文档的标题 可读取/可修改 forms 文档中所有的form表单元素的集合 images 文档中所有的img元素的集合 body 获取body标签 head 获取head标签 documentElement 获取html标签 方法 方法 描述 返回值 document.write(“string”) 动态向页面写入内容//输出工具 undefined document.getElementsByTagName(“tagName”) 通过标签名获取DOM元素 类数组 document.getElementsByClassName(“class”) 通过类名获取DOM元素 类数组 document.getElementById(“id”) 通过id获取DOM元素 DOM对象 document.getElementsByName(“name属性值”) 通过name属性获取DOM元素 类数组 document.querySelector(“css选择器”) 通过css选择器获取DOM元素 DOM对象 document.querySelectorAll(“css选择器”) 通过选择器获取DOM元素 类数组 注意： 1.只有写css选择器的时候才是写. # 这些，其他都是直接写名字。 2.querySelector()只获取第一个查询到的DOM节点，而querySelectorAll()获取所有查询到的DOM节点，并且返回一个Nodelist对象。 JS获取DOM节点的N种方式1.document.getElementById()通过id来获取DOM节点，返回的是一个HTML的节点信息 12345&lt;div id=&quot;main&quot;&gt;content1&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var byid = document.getElementById(&quot;main&quot;) console.log(byid);&lt;/script&gt; 2.document.getElementsByClassName();通过class来获取DOM节点，返回的是一个HTMLCollection对象 12345678910&lt;div class=&quot;sub&quot;&gt; content1&lt;/div&gt;&lt;div class=&quot;sub&quot;&gt; content2&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var byclass = document.getElementsByClassName(&apos;sub&apos;); console.log(byclass);&lt;/script&gt; 3.document.getElementsByName();通过name来获取DOM节点，返回的是一个NodeList对象 1234567&lt;input type=&quot;radio&quot; name=&quot;book&quot; id=&quot;&quot; value=&quot;php&quot; /&gt;&lt;input type=&quot;radio&quot; name=&quot;book&quot; id=&quot;&quot; value=&quot;java&quot; /&gt;&lt;input type=&quot;radio&quot; name=&quot;book&quot; id=&quot;&quot; value=&quot;python&quot; /&gt;&lt;script type=&quot;text/javascript&quot;&gt; var byname = document.getElementsByName(&apos;book&apos;); console.log(byname);&lt;/script&gt; 4.document.getElementsByTagName();通过tagName（标签名）来获取DOM节点，返回的是一个HTMLCollection对象 12345678&lt;p&gt;content1&lt;/p&gt;&lt;p&gt;content2&lt;/p&gt;&lt;p&gt;content3&lt;/p&gt;&lt;p&gt;content4&lt;/p&gt;&lt;script type=&quot;text/javascript&quot;&gt; var byTagName = document.getElementsByTagName(&apos;p&apos;); console.log(byTagName);&lt;/script&gt; 5.document.querySelector();querySelector()可以通过id来获取DOM节点，也可以通过class来获取DOM节点，还可以通过tagName（标签名）来获取DOM节点，它囊括了前面几种功能，实在是强大。 5.1 通过id获取 1234567&lt;div id=&quot;main&quot;&gt; content&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var byQuery = document.querySelector(&apos;#main&apos;) console.log(byQuery);&lt;/script&gt; 5.2 通过class获取 1234567&lt;div class=&quot;main&quot;&gt; content&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var byQuery = document.querySelector(&apos;.class&apos;) console.log(byQuery);&lt;/script&gt; 5.3 通过标签名获取 1234567&lt;div&gt; content&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var byQuery = document.querySelector(&apos;div&apos;) console.log(byQuery);&lt;/script&gt; 6.document.querySelectorAll();6.1 通过id获取 12345678910&lt;div id=&quot;main&quot;&gt; content1&lt;/div&gt;&lt;div id=&quot;main&quot;&gt; content2&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var byQuery = document.querySelectorAll(&apos;#main&apos;) console.log(byQuery);&lt;/script&gt; 6.2 通过class获取 12345678910&lt;div class=&quot;sub&quot;&gt; content1&lt;/div&gt;&lt;div class=&quot;sub&quot;&gt; content2&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var byQuery = document.querySelectorAll(&apos;.sub&apos;) console.log(byQuery);&lt;/script&gt; 6.3 通过标签名来获取 12345678910&lt;div&gt; content1&lt;/div&gt;&lt;div&gt; content2&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var byQuery = document.querySelectorAll(&apos;div&apos;) console.log(byQuery);&lt;/script&gt; querySelector方法只能对第一个元素生效，我们可以通过循环遍历来对某一个元素进行操作。 1234567// 所有itemc类的元素均隐藏let itemc = document.querySelectorAll(&quot;.itemc&quot;)itemc.forEach((item,index)=&gt;&#123; item.onclick = function()&#123; item1[index].style.display = &quot;none&quot; &#125;&#125;) 操作内容 属性 描述 对象.innerHTML 可访问，可修改，可以识别标签，用来给元素内添加子标签很方便 对象.innerText 可访问，可修改，输出纯文本，无法识别标签 12345678910&lt;div class=\"box\"&gt; &lt;/div&gt;&lt;script&gt;//操作对象 先获取对象var b = document.querySelector(\".box\");// console.log(b);console.dir(b);//b.innerHTML=\"&lt;h2&gt;标题&lt;/h2&gt;\";// innerHTML可以识别标签b.innerText = \"操作内容\";//不能识别标签&lt;/script&gt; 操作样式修改idclassName 访问、修改DOM对象的类名 1234对象.className = \"类名\"var b = document.querySelector(\".bos\");b.className=\"aaa\";console.log(b); classList 操作DOM对象类名 方法 描述 classList.add(类名1,类名2) 不修改原类名，添加新类名，可同时添加多个 classList.remove(类名1,类名2) 删除某一类名 classList.contains(类名) 判断一个类名是否存在 classList.toggle(类名1,类名2) 如果类名已存在，则删除；如果类名没有，则添加 1234567891011//添加类名//b.classList.add(\"aa\",\"bb\")//删除类名//b.classList.remove(\"aa\")//console.log(b.classList.contains(\"aa\")); //flase//console.log(b.classList.contains(\"bb\"));//true//如果类名已存在，则删除；如果类名没有，则添加//b.classList.toggle(\"bos\");//b.classList.toggle(\"bos\");//b.classList.toggle(123);//console.log(b); 修改行内样式123456789101112131415对象.style.样式属性 = \"样式值\" // 不会覆盖原样式 b.style[\"background-color\"]=\"red\" b.style.backgroundColor=\"red\"// 所有行内样式组成的字符串// 等价于重写行内样式 (不需要驼峰命名法)// 原本行内样式会被覆盖对象.style.cssText = \"\" // 原本行内样式 不会 覆盖对象.style.cssText += \"\"获取行内样式及dom对象.style.css属性获取行内样式及外部引入样式window.getComputedStyle(对象).css属性 操作属性原生属性 html标签自带的属性 1234对象.属性名 = \"属性值\"对象.className = \"类名\"div.id = \"box\"input.name = \"age\" 自定义属性 方法 描述 对象.setAttribute(属性名,属性值) 设置属性 对象.getAttribute(属性名) 获取属性 对象.removeAttribute(属性名) 删除属性 对象.hasAttribute(属性名) 检测属性 12345678910//添加属性 两个参数 属性名 ， 属性值s.setAttribute(\"title\",\"张三\");//获取属性 参数是属性 返回属性值var b = s.getAttribute(\"title\")//检测是否存在某属性 返回值 是true 和 false// var b = s.hasAttribute(\"title\")//删除属性s.removeAttribute(\"title\")var b = s.hasAttribute(\"title\")console.log(b); //false 节点 在html dom中，所有事物都是节点，DOM是被视为节点树的HTML 节点种类 节点分类 节点类型(nodeType) 节点名称(nodeName) 节点内容(nodeValue) 元素节点 1 标签名 null 属性节点 2 属性名 属性值 文本节点 3 #text 文本 注释节点 8 #comment 注释文本 文档节点 9 #document null 节点属性 属性 可读 描述 示例 dom元素.parentElement 只读 获取父元素 var parent = node.parentElement 父元素.children 只读 获取所有子元素 var elements = node.children; 父元素.childElementCount 只读 获取子元素数量 var count = node.childElementCount; 父元素.firstElementChild 只读 第一个子元素 var element = node.firstElementChild; 父元素.lastElementChild 只读 最后一个子元素 var element = node.lastElementChild; dom元素.nextElementSibling 只读 下一个元素 var element = node.nextElementSibling; dom元素.previousElementSibling 只读 上一个元素 var element = node.previousElementSibling; 节点方法 方法 描述 document.createElement(“div”) 创建一个元素节点 document.createTextNode(“文本内容”) 创建一个文本节点 父元素.appendChild(子节点) 插入一个子节点 父元素.insertBefore(要插入的节点, 插入到某个元素之前) 插入到某个节点之前 父元素.removeChild(子节点) 删除子节点 父元素.replaceChild(新节点,被修改的节点) 替换节点 dom元素.cloneNode(boolean) 克隆节点,克隆dom节点，true克隆所有元素包括子元素，false只克隆当前元素 创建并插入节点流程 document.createElement(“标签名”) (创建标签) 添加属性： (给创建的标签添加属性，参考DOM属性和方法) 添加内容： (给创建的标签添加内容，参考DOM属性和方法) 添加样式： (给创建的标签添加样式，参考DOM属性和方法) 父元素.appendChild(子节点) 被插入的节点，可以是新创建的，也可是页面中已经存在的 父元素.insertBefore(要插入的节点, 插入到某个元素之前) 父元素.removeChild(子节点) 删除子节点 父元素.replaceChild(新节点,被修改的节点) 替换节点 node.cloneNode(boolean) 克隆节点 如何解决body的overflow:hidden;在移动端失效在PC端中百试不爽的document.body.style.overflow=’hidden’;可以使屏幕滑动时而不滚动，但是在移动端却达不到效果了，我在网上也看过一些资料，有说加上html,body 它们的高度设置为100%，就可以解决这个问题，但在我的尝试中一样没有效果，那如何解决呢？ 如何解决呢？可以给设置 1document.body.style.position='fixed'; 使body根据屏幕定位，这样你如何滚动body都还是在你屏幕定位的地方。 如何恢复呢？当你想让屏幕继续滚动的时候可以设置 1document.body.style.position='static'; 恢复定位的默认属性，这样就代替了document.body.style.overflow=’hidden’;在移动端失效的效果了。 移动端界面禁止触摸事件作用： addEventListener()与removeEventListener()用于处理指定和删除事件处理程序操作。 它们都接受3个参数：事件名、事件处理的函数和布尔值。 布尔值参数是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。 示例：环境：移动端，界面禁止触摸事件要在body上添加事件处理程序，可以使用下列代码： 123document.body.addEventListener(&apos;touchmove&apos;, function (event) &#123; event.preventDefault();&#125;,false)； 通过addEventListener()添加的事件处理程序只能使用removeEventListener()来移除；移除时传入的参数与添加处理程序时使用的参数相同。这也 意味着通过addEventListener()添加的匿名函数无法移除 错误用法示例：123456document.body.addEventListener(&apos;touchmove&apos;, function (event) &#123; event.preventDefault();&#125;,false);document.body.removeEventListener(&apos;touchmove&apos;, function (event) &#123; event.preventDefault();&#125;,false); 这个例子中，我使用addEventListener()添加一个事件处理程序。虽然调用removeEventListener(0是看似使用了相同的参数，但实际上，第二个参数与传入addEventListener()中的那一个完全不同的函数。而传入removeEventListener()中的事件处理程序函数必须与传addEventListener()中的相同 正确用法示例：12345function bodyScroll(event)&#123; event.preventDefault();&#125;document.body.addEventListener(&apos;touchmove&apos;,bodyScroll,false);document.body.removeEventListener(&apos;touchmove&apos;,bodyScroll,false); 重写后的这个例子没有问题，是因为在addEventListener()和removeEventListener()中用来相同的函数。 共用函数不能带参数，错误用法示例：12345function bodyScroll(event)&#123; event.preventDefault();&#125;document.body.addEventListener(&apos;touchmove&apos;,bodyScroll(event),false);document.body.removeEventListener(&apos;touchmove&apos;,bodyScroll(event),false); 总结：一：相同事件绑定和解除，需要使用共用函数； 二：共用函数不能带参数； addEventListener注意问题 1document.addEventListener(&apos;touchmove&apos;, function(e) &#123; e.preventDefault(); &#125;, **false**); 但是有另外一个需求是需要将以上的’touchmove’恢复为默认的。开始我直接使用removeEventListener,但是不起作用。后来发现如果要让removeEventListener成功的话需要把里面function单独封装成一个方法。 123function preventDefault(e) &#123; e.preventDefault(); &#125;; document.addEventListener(&apos;touchmove&apos;, preventDefault, **false**); document.removeEventListener(&apos;touchmove&apos;, preventDefault, **false**); 把操作封装成一个单独的方法，调用时引用同一个方法，listener才能准确找到。如果直接写在参数里，会认为是两个function(e)是不同的操作，所以不能remove成功。 注：JS每次使用addEventListener后，该事件函数为全局监听，每次不使用时必须removeEventListener掉，不然容易出错，例如每次进入该界面时都会注册一个相同的事件 节点层次 DOM可以将任何HTML或XML文档描绘成一个由多层节点构成的结构。 节点氛围几种不同的类型，每种类型分别表示文档中不同的信息及标记。 每个节点都拥有各自的特点、数据和方法，另外也与其他节点存在某种关系。 节点之间的关系构成了层次，而所有页面标记则表现为一个以特定节点为根节点的树形结构。 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;Sample Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello World!&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 文档节点是每个文档的根节点，上面那个栗子中，文档节点只有一个子节点，即元素，我们称之为文档元素。 文档元素是文档的最外层元素，文档中的其他所有元素都包含在文档元素中。 每个文档只能有一个文档元素。 在HTML页面中，文档元素始终都是元素。 在XML中，没有预定义的元素，因此任何元素都能成为文档元素。 HTML元素通过元素节点表示 特性(attribute)通过特性节点表示 文档类型通过文档类型节点表示 注释则通过注释节点表示 总共有12种节点类型，这些类型都继承自一个基类型 Node类型 DOM1级定义了一个Node接口，该接口将由DOM中的所有节点类型实现。 这个Node接口在JS中作为Node类型实现的 除了IE之外，在其他所有浏览器中都可以访问到和这个类型 JS中的所有节点类型都继承自Node类型，因此所有及诶单类型都共享着相同的基本属性和方法。 有12个常量 Node. 不打了 为了保证兼容性，最好还是将nodeType属性与数字值进行比较123if( someNode.nodeType == 1 )&#123; alert( \"Node is an element\" )&#125; nodeName 和 nodeValue属性 要了解节点的具体信息，可以使用nodeName和nodeValue属性。这两个属性的值完全取决于节点的类型 在使用这两个值以前，最好先检测下节点类型123if( someNode.nodeType == 1 )&#123; value = someNode.nodeName // nodeName的值是元素的标签名&#125; 节点关系 每个节点都有一个childNodes属性，其中保存着一个NodeList对象。 NodeList是一种类数组对象，用于保存一组有序的节点，可以通过位置来访问这些节点。 虽然可以通过方括号语法来访问NodeList的值，而且这个对象也有length属性，但它并不是Array的实例。 NodeList对象的独特之处在于，他实际上是基于DOM结构动态执行查询的结果，因此DOM结构的变化能够自动反映在NodeList对象中 它是一个有生命呼吸的对象不是第一次访问他们的某个瞬间拍下的快照。 123var firstChild = someNode.childNodes[0];var secondChild = someNode.childNodes.item(1);var count = someNode.childNodes.length; 如果在IE8之后 1var arrayOfNodes = Array.prototype.slice.call( someNode.childNodes, 0 ); IE8及更早版本将NodeList实现为一个COM对象，我们不能像使用JS对象那样使用这种对象，因此上面的代码会导致错误。 兼容写法 12345678910111213function convertToArray( nodes )&#123; var array = null; try &#123; // 针对非IE array = Array.prototype.slice.call( nodes, 0 ) &#125; catch(err)&#123; array = new Array(); for( var i = 0, l = nodes.length; i &lt; l; i++ )&#123; array.push( nodes[i] ) &#125; &#125; return array;&#125; 每个节点都有个parentNode属性，该属性指向文档树中的父节点。 包含在childNodes里诶保重的所有节点都具有相同的父节点，因此他们的parentNode属性都指向同一个节点。 包含在childNodes列表中的每个节点相互之间都是同胞节点。 通过使用列表中每个节点的previousSibling（上一个兄弟节点）和nextSibling（相邻的下一个兄弟节点）属性，可以访问同一列表中的其他节点。不存在就返回null 父节点的firstChild和lastChild属性分别指向其childNodes里诶保重的第一个和最后一个节点。 操作节点 关系指针都是只读的。 appendChild() 向childNodes列表的末尾添加一个节点。 添加节点后，childNodes的新增节点，父节点及以前的最后一个子节点的关系指针都会相应的得到更新 更新完后，appendChild()返回新增的节点 123var returnedNode = someNode.appendChild( newNode );alert( returnNode = newNode ) // truealert( soemNode.lastChild == newNode ) // true insertBefore() 把节点放在childNodes列表中某个特定位置上，而不是放在末尾。 两个参数： 要插入的节点和作为参照的节点。 插入节点后，被插入的节点会变化才能参照节点的前一个同胞节点( previousSibling ) 同事被方法返回 如果参照节点是null 则inserBefore()与appendChild()执行相同的操作。 12345678// 插入后成为最后一个子节点returnedNode = someNode.insertBefore( newNode, null );// 插入成为第一个子节点var returnedNode = someNode.insertBefore( newNode, someNode.firstChild );// 插入成为最后一个子节点前面returnedNode = someNode.insertBefore( newNode, someNode.lastChild ) replaceChild() 参数： 要插入的节点和要替换的及诶单。要替换的节点将由这个方法返回并从文档树中被移除，同时由要插入的节点占据其位置。 使用该方法插入一个节点时，该节点的所有关系指针都会从被它替换的节点复制过来。尽管从技术上将，被替换的节点仍然还在文档中，单它在文档中已经没有了自己的位置 1234// 替换第一个节点var returnedNode = someNode.replaceChild( newNode, someNode.firstChild )// 替换最后一个子节点returnedNode = soemNode.replaceChild( newNode, someNode.lastChild ) removeChild() 只有一个参数，即要移除的节点， 被移除的节点将成为方法的返回值。 1var formerLastChild = someNode.removeChild( someNode.lastChild ) 通过removeChild移除的节点仍为文档所有，只不过在文档中已经没有了自己的位置。 注意 前面介绍的四个方法都是某个节点的子节点，要使用这些方法必须先取得父节点（parentNode）。 并不是所有的节点都有子节点，如果在不支持子节点的节点使用该方法将会报错。 其他方法cloneNode() 用于创建调用这个方法的节点的一个完全相同的副本 cloneNode方法接受一个布尔值参数，表示是否执行深刻复制， 当参数为true时，执行深刻复制，也就是复制节点及其整个节点树 当参数为false时，执行浅复制，即只复制节点本身。复制后返回的节点副本属于文档所有，但并没有为它指定父节点。因此，这个节点副本就成为了一个孤儿，除非通过appendChild()、 insertBefore()或replaceChild()将它添加到文档中1234567891011121314&lt;ul&gt; &lt;li&gt;item 1&lt;/li&gt; &lt;li&gt;item 2&lt;/li&gt; &lt;li&gt;item 3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; // 若果我们已经将ul元素的引用保存在了变量myList中，name通常下列代码就可以看出使用cloneNode()方法的两种模式 var deepList = myList.cloneNode( true ); alert( deepList.childNodes.length ) // 3 (IE &lt; 9) 或 7（其他浏览器); 可能会有些差异，主要因为IE8及更早版本与其他浏览器处理空白字符的方式不一样 var shallowList = myList.cloneNode( false ); alert( shallowList.childNodes.length ) // 0 浅复制不包含子节点 &lt;/script&gt; normalize() 这个方法唯一的作用就是处理文档树中的文本节点 由于解析器的实现或DOM操作等原因，可能会出现文本节点不包含文本，或者接连出现连个文本几点的情况 当在某个节点上调用这个方法时，就会在该节点的后代节点中查找上述两种情况 如果找到了空文本节点，则删除它，如果找到相邻的文本节点，则将他们合并为一个文本节点。 Document类型JS通过Document类型表示文档。 在浏览器中，document对象是HTMLDocument( 继承自Document类型 )的一个是心理，表示整个HTML页面 document对象是window对象的一个属性，因此可以将其作为全局对象来访问 特征： nodeType 9 nodeName “#document” nodeValue null parentNode null ownerDocument null 其子节点可能是一个DocumentType(最多一个) Element(最多一个) ProcessingInstruction 或 Comment Document类型可以表示HTML页面或者其它基于XML的文档。不过，最常见的应用还是作为HTMLDocument实例的doucment对象。 通过这个文档对象，不仅可以取得与页面有关的信息，而且还能操作页面的外观及其底层结构。 文档的子节点 虽然DOM标准规定Document节点的自及诶单可以是DocumentTYpe、 Element、 ProcessingInstruction 或Comment 但还有两个内置的访问器子节点的快捷方式。 documentElement documentElement 该属性始终指向HTML页面中的元素。 另个一个就是通过 childNodes里诶包访问文档元素 单通过documentElement属性则能更快捷、更直接的访问该元素。 123456789&lt;html&gt; &lt;body&gt; &lt;script&gt; var html = document.documentElement // 取得对&lt;html&gt;的引用 alert( html === document.childNodes[0] ) // true alert( html === document.firstChild ) // true &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 作为HTMLDocument的实例，document对象还有一个body属性，直接指向元素 1var body = document.body; // 取得对body的引用 DocumentType Document另一个可能的子节点是DocumentType。通常将&lt;!DOCTYPE&gt;标签看成一个与文档其他部分不同的实体，可以通过doctype属性来访问它的信息 1var doctype = document.doctype; // 取得对&lt;!DOCTYPE&gt;的引用 &lt;IE8，如果存在文档类型声明，会将其错误地解释为一个注释并把它 当做 Comment节点；而document.doctype的值始终为null IE9+及firefox 如果在文档类型声明，则将其作为围挡的第一个子节点；documnt.doctype是一个DocumentType节点，也可以通过document.firstChild或document.childNodes[0]访问同一个节点 Safari Chrome 和Opera 如果存在文档类型声明，则将其解析，但不作为文档的子节点。document.doctype是一个DocumentType节点，但该节点不会出现在document.childNodes中 由于浏览器对docuemnt.doctype的支持不一，因此这个属性的用处很有限 注释的节点问题 123456&lt;!--第一条注释--&gt;&lt;html&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;&lt;!--第二条注释--&gt; 这个页面看起来有3个子节点： 注释、元素、注释。从逻辑上将，我们会认为document.childNodes中英爱包含与这3个子节点对应的3项。但是现实中的浏览器在处理位于外部的主食方面存在如下差异 &lt;IE8、Safari3.1及更高版本、Opera Chrome职位的一条注释创建节点不为第二条注释创建节点，结果第一条注释就会成为document.childNodes中的第一个子节点。 IE9+会为每条注释创建一个节点 Firefox以及Safari3.1之前的版本会完全你忽略这两条注释 同样，浏览器间的这种不一致性也导致了位于元素外部的注释没有什么用处 文档信息documtn.title 作为HTMLDocument的一个实例，document独享还有一些标准的Document对象所没有的属性，这些属性提供了document对象所表现的网页的一些信息。1docuemnt.title = \"new Title\" document.domain document.URL document.referrer URL 地址栏中的URL domain 取得域名 referrer 去的来源页面的URL 三个属性中，只有domain是可设置的，但不能设置任何值。只能设置成主域名值。不能将这个属性设置为URL中不包含的域。 如果域名一开始是松散的(loose)，那么不能将它在设置为”紧绷的”（tight）123// 假设页面来自于 p2p.wrox.com 域document.domain = \"wrox.com\" // 松散的(成功)docuemnt.domain = \"p2p.wrox.com\" // 紧绷的(出错) 查找元素document.getElementById 接收一个参数，要取得元素的ID，如果找到相应的元素则返回该元素，如果不存在，返回Null，严格匹配包括大小写 1234// #myDivdocument.getElementById(\"myDiv\");document.getElementById(\"mydiv\") // IE7及更早版本之外的所有浏览器中都会返回Null// IE8及较低版本不区分ID的大小写 &lt;IE7 低版本有个怪癖：name特性与给定ID匹配的表单元素也会被该方法返回，所以ID尽量和name不要相同 document.getElementsByTagName 接收一个参数，要取得元素的标签名，返回的是包含零或多个元素的NodeList 在HTML文档中，这个放啊会返回一个HTMLCollection对象，作为一个动态集合，该对象与NodeList非常类似，可以使用方括号语法item()方法来访问HTMLCollection对象中的项 这个对象中元素的数量可以通过length属性得到 namedItem(): 使用这个方法可以通过元素的name特性取到集合中的项 1234567&lt;img src=\"\" name=\"myImg\"&gt;&lt;script&gt; var imgs = document.getElementsByTagName('img'); var myImg = imgs.namedItem(\"myImg\") // 还可以按名称访问 var myImg = imgs[\"myImg\"]&lt;/script&gt; “*“ 表示全部 12docuemnt.getElementsByTagName(\"*\") // 返回页面中所有的元素// 由于IE将注释实现为元素，因此IE中调用会返回所有注释节点 getElementsByName 只有HTMLDocument类型才有的方法，这个方法会返回带有给定name特性的所有元素 特殊集合 docuemnt.anchors 文档中带有name特性的a元素 docuemnt.applets 文档中所有 已废弃 document.forms 文档中所有表单元素 document.images 所有img元素 document.links 所有带href特性的a DOM一致性检测 document.implementation DOM一级职位该属性规定了一个方法——hasFeature()。参数1： 要检测的DOM功能的名称及版本号，如果浏览器支持给定名称和版本的功能，返回true 该方法也有缺陷，最好除了检测hasFeature之外还是用能力检测 文档写入 docuemnt.write() 原样写入 doucemnt.writeln() 字符串末尾加上换行符 docuemnt.open和close 用于打开和关闭网页输出流 Element类型Element类型用于表现XML或HTML元素，提供了对元素标签名，子节点及特性的访问 nodeType 值为1 nodeName 值为元素标签名 nodeValue 的值为null parentNode 可能是Document或Element 子节点类型比较多 要访问元素标签名，可以使用nodeNmae属性，也可以使用tagName属性，这两个属性会返回相同的值（使用后者主要是为了清晰可见） 1234var div = document.getElementById('myDiv');div.tagName // \"DIV\" // 在HTML中，标签名始终以全部大写表示，在XML中则与源码一直，当不确定在HTML还是XML中，最好都转换成小写div.tagName.toLowerCase() // divdiv.nodeName // true HTML元素 所有HTML元素都有HTMLElement类型表示，不是直接通过这个类型也是通过它的子类型表示 HTMLElement类型直接继承自Element并添加了一些属性 id 元素在文档中的唯一标识符 title 有关元素的附加说明信息，一般通过工具提示条显示出来 lang 元素内容的语言代码 dir 语言的方向 ltr left-to-right rtl right-to-left className 与元素的calss特性对应，即为元素指定的CSS类 以上都是可读可修改的 特性 getAttribute setAttribute removeAttribute 自定义属性应该加上data-前缀 只有公认的（非自定义的）特性才会以属性的形式添加到DOM对象中 style和onclick等事件的会返回的不一致 &lt;IE7 setAttribute存在一些异常 蛇者clas和style没有效果设置事件处理也无效IE8才解决 &lt;IE6 不支持removeAttribute attributes Element类型是使用attributes属性的唯一一个DOM节点类型 attributes属性中包含一个NamedNodeMap， 与NodeList类似也是一个动态集合，元素的每一个特性都由一个Attr节点表示，每个节点都保存在NamedNodeMap对象中 getNamedItem 返回nodeName属性等于name的节点 removeNamedItem 从列表中移除nodeNmae属性等于name的节点 setNamedItem 想列表中添加节点 以节点的nodeName属性为索引 item 返回位于数字pos位置处的节点 不太方便 大家还是用上面的特性 创建元素 docuemnt.createElement()方法创建新元素 只接受一个参数——要创建的元素标签名 这个标签名在HTML中不区分大小写，而在XML中区分 使用该方法的同时，也为新元素设置了ownerDocuemnt属性，此时，还可以操作元素的特性，为它添加更多子节点及操作 123var div = document.createElement(\"div\");div.id = \"myNewDiv\";div.className = \"box\" 创建好后并没有添加到文档树中，因此，设置这些特性不会影响浏览器的显示 可以使用 appendChild() insertBefore() 或 replaceChild()方法， 一但将元素添加到文档中，浏览器就会立即呈现该元素，此后，对这个元素的任何修改都会实时反映在浏览器中 IE中可以为这个方法传入完整的元素标签，也可以包含属性 1var div = docuemnt.createElement(\"&lt;div id=\\\"myNewDiv\\\" class=\\\"box\\\" &gt;&lt;/div&gt;\") 这种方式有助于避开在IE7及更早版本中动态创建元素的某些问题 不能设置动态创建的iframe元素的name特性 不鞥呢通过表单的reset方法重设动态创建的input元素 动态创建的type特性值为”reset”的元素重设不了表单 动态创建的一批name相同的单选按钮彼此毫无关系 上述问题都可以通过这种方式解决 但是只能在IE中 元素子节点 元素的childNodes属性中包含了它的所有子节点 不同浏览器中子节点数量不同，所以在执行某项操作前，都要先检查下nodeType属性 12345for( var i = 0, l = element.childNodes.length; i &lt; l; i++ )&#123; if( element.childNodes[i].nodeType == 1 )&#123; &#125;&#125; 通过某个特定的标签名取得子节点或后代节点 12var ul = docuemnt.getElementById(\"myList\");var items = ul.getElementsByTagName(\"li\") Text类型文本节点由Text类型表示，包含的是可以照字面解释的纯文本内容。春文中可以包含转义后的HTML字符，但不能包含HTML代码 nodeType 3 nodeName “#text” nodeValue 为节点所包含的文本 parentNode是一个Element 不支持（没）子节点 可以通过nodeValue属性或data属性访问Text接地那种包含的文本，两个属性更改，另一方都会反映出来。 appendData(text) 将text添加到节点末尾 deleteData(offset, count) 从offset指定的位置开始删除count个字符 insertData(offset, test) 在offset指定的位置插入text replaceData(offset, count, text) 用text替换从offset指定的位置开始到offsetcout为止处的文本 splietText(offset) 从offset指定的位置将当前文本节点分成两个文本节点 substringData(offset, count) 提取从offset指定的位置开始到offsetcount位置的字符串 length 属性 nodeValue.length 和 data.length 相同的值 修改文本节点时还要注意，此时的字符串会经过HTML（取决于文档类型）编码 创建文本节点 document.createTextNode() 同样可以设置ownerDocuemnt属性 同样是添加到文档树中才能看到 如果连个文本几点是相邻的同胞节点，那么这两个节点就会串联显示，中间不会有空格 规范化文本节点 normalize() IE6中使用这个方法可能会崩溃IE6 如果一个包含两个或多个文本节点的父元素上调用normalize()方法，则会将所有文本节点合并成一个节点，结果节点的nodeValue等于将合并前每个文本节点的nodeValue值拼起来的值 分割文本节点 splitText() 按照指定位置分割文本节点 Comment类型是注释类型 nodeType 8 nodeName “#comment” nodeValue 值为注释内容 parentNode 可能是Docuemnt或Element 不支持（没有）子节点 Comment类型与Text类型继承自相同的基类，因此它拥有除splitText()之外的所有字符串操作方法，与Text类型相似，也可以通过nodeValue或data属性来取得注释内容 CDATASection基于XML文档，表示的是CDATA区域 与Comment类似，CDATASection类型继承自Text类型，因此拥有除solitText之外的所有字符串操作方法 nodeType 4 nodeName “#cdata-section” nodeValue 是CDATA区域中的内容 parentNode 可能是Docuemnt 或Element 不支持 没有子节点 DocuemntType类型DocumentFragment类型Attr类型 nodeType 2 DOM操作动态脚本12345678910111213var script = docuemnt.createElement(\"script\");script.type = \"text/javascript\";script.src = \"client.js\"docuemnt.bpdy.appendChild(script)// script.appendChild( document.createTextNode(\"function()&#123;alert(\\\"hi\\\")&#125;\") ) 这种在IE可能会报错script.text = \"function()&#123;alert(\\\"hi\\\")&#125;\" // safari 3.0 之前可能会报错// 兼容写法var code = \"function()&#123;alert(\\\"hi\\\")&#125;\";try &#123; script.appendChild( document.createTextNode(code) )&#125; catch (ex)&#123; script.text = code;&#125; 动态样式12345678910111213141516var link = document.createElement(\"link\");link.rel = \"stylesheet\";link.type = \"text/css\";link.href = \"style.css\";var head = document.getElementsByTagName('head')[0];head.appendChild( link )var style = docuemnt.createElement(\"style\"), code = \"body&#123;color: #666&#125;\" ;style.type = \"text/css\";try&#123; // IE 低版本会报错 style.appendChild( document.createTerxtNode(code);&#125; catch(ex)&#123; style.styleSheet.cssText = code;&#125; 创建表格 太麻烦了 直接 innerHTML吧。。。 使用NodeList NodeList 近亲 NameNodeMap HTMLCollection 三个都是动态的 每当文档结构变化 他们都会得到更新123456789101112131415// 这种由于divs每次都是动态获取的所以会无限循环 因为length是动态的var divs = document.getElementsByTagName(\"div\"), div;for( i = 0; i &lt; divs.length; i++ )&#123; div = document.createElement(\"div\"); document.body.appendChild(div)&#125;// 把length存起来即可var divs = document.getElementsByTagName(\"div\"), div;for( i = 0, l = divs.length; i &lt; l; i++ )&#123; div = document.createElement(\"div\"); document.body.appendChild(div)&#125; DOM扩展querySlector() 接收一个CSS选择符， 返回该模式匹配的第一个元素，如果没有，返回null 通过Element类型调用querySelector方法时，只会在该元素后代元素的范围内查找匹配元素 如果传入了不被支持的选择符，querySelector会抛出错误 IE8开始支持 querySelectorAll() 接受一个css选择符 返回NodeList实例 如果没有找到匹配的元素 返回的是空的 如果传入了不被支持的选择符，querySelectorAll会抛出错误 MDN上说IE不支持:SCOPED matchesSelector() matches() 一个参数，如果调用该元素与该选择符匹配，返回true 否则 返回false 所有浏览器都不支持 可以用浏览器私有123456789101112131415// 兼容写法if (!Element.prototype.matches) &#123; Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function(s) &#123; var matches = (this.document || this.ownerDocument).querySelectorAll(s), i = matches.length; while (--i &gt;= 0 &amp;&amp; matches.item(i) !== this) &#123;&#125; return i &gt; -1; &#125;;&#125; 元素遍历对于元素间的空格 IE9及之前版本不会返回文本节点，而其他所有浏览器都会返回文本节点，为了弥补差异同事保持DOM规范不变，新增了如下API childElementCount 返回子元素（不包括文本节点和注释）的个数 firstElementChild 指向第一个子元素 firstChild的元素版 lastElementChild 指向对吼一个子元素 lastChild的元素版 previousElementSibling 指向前一个同辈元素 previousSibling 的元素版 nextElementSibling 指向后一个同辈元素 nextSibling的元素版 IE9+ Firefox 3.5+ Safari 4+ Chrome Opera 10+ 利用这些元素不必担心空白文本节点，从而更方便的查找DOM元素了， 举个例子 12345678910var i, len, child = element.firstChild;while( child != element.lastChild )&#123; // 检查是不是元素 if( child.nodeType == 1 )&#123; processChild(child) &#125; child = child.nextSibling'&#125; 12345678// 使用 Element Traversal 新增的元素var i, len, child = element.firstElementChild; while( child != element.lastElementChild )&#123; processChild( child ) child = child.nextElementSibling; &#125;; HTML5getElementsByClassName()方法 接收一个参数，即一个包含已获多个类名的字符串，返回带有指定类的所有元素的NodeList 传入多个类名时先后顺序不重要 1docuemnt.getElementById('#div').docuemnt.getElementsByClassName(\" username current \") IE 9+ Firefox 3+ Safari 3.1+ Chrome Opera 9.5+ classList在操作类名时，需要通过className 属性添加、删除和替换类名。因为className是一个字符串，即使修改字符串的一部分，也必须每次都设置整个字符串的值 123456789101112131415161718&lt;div class=\"bd user disabled\"&gt;...&lt;/div&gt;&lt;script&gt;// 删除user类var className = div.className.split(/\\s+/);var pos = -1, i, len;for( i = 0, len = classNames.length; i &lt; len; i++ )&#123; if( className[i] == \"user\" )&#123; pos = i; break; &#125; &#125; // 删除类名 classNames.splice(i, 1); // 把剩下的类名拼成字符串重新设置div.className = classNames.join(\" \"); &lt;/script&gt; classList属性是心机和类型DOMTokenList的实例 DOMTokenList有一个标识自己包含多少元素的length属性，而要取得每个元素可以使用item()方法，也可以使用方括号语法，还有如下方法 add 将给定的字符串值添加到列表中，如果值已经存在，就不添加了 contains 标识列表中是否存在给定的值，如果存在返回true 否则返回false remove 从列表中删除给定的字符串 toggle 如果列表中存在给定的值，删除它；如果列表中没有给定的值，添加它 很可惜 只有Firefox 3.6+ 和Chrome8.0 IE10+(不支持toggle) Opera11.5 Safari (WebKit)5.1 焦点管理 document.activeElement 这个属性始终会引用DOM中当前获得了焦点的元素 默认情况下，文档刚刚加载完成时，doucment.activeElement中保存的是document.body元素的引用。文档加载期间，document.activeElement的值为null document.hasFocus(); 用于确定文档是否获得了焦点 HTMLDocument变化readyState属性 IE4提出，HTML5纳入标准 两个值： loading——正在加载文档 complete——已经加载完文档123if( document.readyState == \"complete\" )&#123; // 执行操作&#125; 兼容模式 从IE6开始区分渲染页面的模式是标准的还是混杂的。 IE6给document添加了一个名为compatMode的属性，值是浏览器采用了哪种渲染模式 标准模式下 document.compatMode的值是CSS1Compat 混杂模式下 document.compatMode的值是BackCompat head属性 HTML5增加了docuemnt.head属性12// 兼容写法var head = document.head || document.getElementsByTagName(\"head\")[0] 字符集属性 document.charset 如果文档没有使用默认的字符集，那charset和defaultCharset属性的值可能会不一样123if( document.charset != document.defaultCharset )&#123; // &#125; 自定义数据属性 为元素添加非标准的属性必须要写成data-的形式，目的是伪元素提供与渲染无关的信息，或者提供语义信息 1234567&lt;div id=\"myDiv\" data-appid = \"123456\" &gt;&lt;/div&gt;&lt;script&gt; var div = document.getElmentById(\"myDiv\"); var appId = div.dataset.appId; console.log( appId ) div.dataset.appId = 2446;&lt;/script&gt; 全浏览器支持 插入标记innerHTML 不多讲 插入script时，必须为其制定defer属性，必须位于有作用域的元素之后 很多问题 插入script 和link 在IE8中 可以通过 window.toStaticHTML()方法去除脚本节点和事件处理程序属性 自己也要注意处理 outerHTML 在读模式下，outerHTML返回调用它的元素及所有子节点的HTML标签。 在写模式下，outerHTML会根据指定的HTML字符串创建新的DOM子树，然后用这个DOM子树完全替换调用元素 参考 12345678910111213141516171819202122&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset= 'utf-8'&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"test1\"&gt;这是div中的文字&lt;span&gt;这是span中的文字&lt;/span&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; console.log('innerHTML:'+test1.innerHTML); console.log('outerHTML:'+test1.outerHTML); console.log('innerText:'+test1.innerText); console.log('outerText:'+test1.outerText); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; innerHTML:这是div中的文字&lt;span&gt;这是span中的文字&lt;/span&gt;outerHTML:&lt;div id=\"test1\"&gt;这是div中的文字&lt;span&gt;这是span中的文字&lt;/span&gt;&lt;/div&gt;innerText:这是div中的文字这是span中的文字outerText:这是div中的文字这是span中的文字 insertAdjacentHTML()方法 最早在IE中出现的， 接收两个参数 插入位置和要插入的HTML文本 第一个参数 beforebegin 在当前元素之前插入一个紧邻的 afterbegin 在当前元素之下插入一个新的子元素或在第一个子元素之前在插入新的子元素 beforeend 在当前元素之下插入一个新的子元素或在最后一个子元素之后再插入新的子元素 afterend 在当前元素之后插入一个紧邻的同辈元素 IE8+ 都支持 scrollIntoView() 可以在所有HTML元素上调用，通过滚动浏览器窗口或某个容器内的元素，调用元素就可以出现在视口中 传入true或不传入，窗口滚动之后会让调用元素的顶部与视口顶部尽可能平齐 传入false元素尽可能出现在视口中，可能的话，调用元素的底部会与视口顶部平齐 不过顶部不一定平齐 1document.forms[0].scrollIntoView(); IE8+ 专有扩展文档模式 页面的文档模式决定了可以使用什么功能 页面的文档模式决定了你可以使用哪个级别的CSS 可以在JS中使用哪些API，以及如何对待文档类型 到了IE9 总共有四种文档模式 IE5 以混杂模式渲染页面 ie8+的功能都无法使用 IE7 IE7标准模式 IE8+无法使用 IE8 已IE8标准渲染 IE8中的新api都可使用 IE9+无法使用 IE9 IE9 最好使用 IE = Edge 始终已最新的文档模式来渲染 var mode = document.documentMode // 返回模式 children 由于IE9之前的版本处理空白文本有差异，于是就出现了children属性 12var childCount = element.children.lengthvar firstChild = element.children[0] IE8及更早版本的children属性中也会包含注释节点 ie9之后只返回元素节点 contains() 检测某个节点是否是另一个节点的后代 所有浏览器都支持 1document.documentElement.contains( document.body ) // true 使用 DOM Level3 compareDocumentPosition() 也能够确定节点之间的关系 IE9+ 返回一个标识该关系的位掩码 1 无关 给定的节点不在当前文档中 2 居前 给定的节点再DOM树中位于参考节点之前 4 居后 给定的结点在DOM数中位于参考节点之后 8 包含 给定的节点是参考节点的祖先 16 被包含 给定的节点是参考节点的后代 为模仿contains方法 应该关注的是掩码16 可对compareDocumnetPosition 的结果执行按位与，以确定参考节点（调用compareDocumentPosition方法的当前节点）是否包含给定的节点（传入的节点） 12var result = docuemnt.docuemntElement.compareDocumentPosition( document.body );alert( !!( result &amp; 16 ) ) // 20 执行上面的代码后，结果会变成20（表示居后的4加上表示被包含的16） 对掩码16执行按位操作会返回一个非零数值，而两个逻辑非操作会将该数值转换成布尔值 123456789101112131415161718function contains(refNode, otherNode)&#123; if (typeof refNode.contains == \"function\" &amp;&amp; (!client.engine.webkit || client.engine.webkit &gt;= 522))&#123; return refNode.contains(otherNode); &#125; else if (typeof refNode.compareDocumentPosition == \"function\")&#123; return !!(refNode.compareDocumentPosition(otherNode) &amp; 16); &#125; else &#123; var node = otherNode.parentNode; do &#123; if (node === refNode)&#123; return true; &#125; else &#123; node = node.parentNode; &#125; &#125; while (node !== null); return false; &#125;&#125; 插入文本 IE的innerText和outerText没有纳入HTML5规范 innerText 通过innerText属性可以操作元素中包含的所有文本内容，包括子文档树中的文本 在通过innerText读取值时，它会按照由浅入深的顺序，将子文档树中的所有文本拼接起来 在通过innerText写入值时，结果会删除元素的所有子节点，插入包含响应文本值的文本节点 firefox 45 才开始支持 他有类似的 textContent123456789101112function getInnerText(element)&#123; return ( typeof element.textContent == \"string\" ) ? element.textContent : clement.innerText&#125;function setInnerText(element, text)&#123; if( typeof element.textContent == \"string\" )&#123; element.textContent = text; &#125; else &#123; element.innerText = text; &#125;&#125; outerText 读的模式下 和 innerText基本上没多大区别 写的模式下 outerText会替换整个元素，导致该元素从文档中被删除而无法访问 滚动 scrollIntoViewIfNeeded(alignCenter): 只在当前元素在是口中不可见的情况下，才滚动浏览器窗口或容器元素，最终让它看见，如果当前元素在视口中课件，这个方法什么都不做 scrollByLines(lineCount): 将元素的内容滚动指定的行高，lineCount可以是正值也可以是负值 非规范 S 和Chrome实现 scrollByPage(pageCount): 将元素内容滚动到指定的页面高度 scrollIntoView 和 scrollIntoViewIfNeeded作用的是元素容器 scrollByLines 和 scrollByPages 影响的是元素本身 DOM2和DOM3DOM3 同时增强了既有类型，也引入了一些新类型 主要是命名空间 Node类型的变化 命名空间实际上没有什么用 混合两种语言的时候就有用了 localName 不带命名空间前缀的节点名称 namespaceURI 命名空间URI或者（未指定）情况下 null prefix 命名空间前缀或者（未指定）null 12345678910111213141516&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt; &lt;head&gt; &lt;title&gt;Example XHTML page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;s:svg xmlns:s=\"http://www.w3.org/2000/svg\" version=\"1.1\" viewBox=\"0 0 100 100\" style=\"width:100%; height:100%\"&gt; &lt;s:rect x=\"0\" y=\"0\" width=\"100\" height=\"100\" style=\"fill:red\"/&gt; &lt;/s:svg&gt; &lt;/body&gt; &lt;/html&gt;对于&lt;s:svg&gt;而言它的localName 是 svgtagName 是 s:svgnamespaceURI 是 prefix 是s 更多方法就不介绍啦 很少用 其他方面变化DocumentType publicId systemId 上面两个DOM1中无法访问 123456&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\"&gt; 对这个文档类型声明而言，publicId是\"-//W3C//DTD HTML 4.01//EN\"，而systemId是\"http: //www.w3.org/TR/html4/strict.dtd\"。在支持DOM2级的浏览器中，应该可以运行下列代码。alert(document.doctype.publicId); alert(document.doctype.systemId); internalSubset 文档类型声明中的额外定义 Document 类型的变化 唯一与命名空间无关的是 importNode 从文档中去的一个节点，然后将其导入另一个文档，时期成为这个文档结构的一部分 每个节点都有一个ownerDocument属性，表示所属的文档 如果调用appendChild()时传入的节点属于不同的文档，则会导致错误 但在调用importNode()时传入不同文档的节点会返回一个新节点，这个新节点的所有权归当前文档所有 和element的cloneNode()方法非常相似 接受两个参数 要复制的节点合一表示是否赋值子节点对的布尔值 defaultView DOM2级视图模块添加了一个名为defaultView属性，其中保存着一个指针，指向拥有给定文档的窗口（或框架） 除IE之外所有有浏览器都支持 IE中有个等价属性叫parentWindow(Opera也支持)1var parentWindow = docuemnt.defaultView || document.parentWindow document.implementation createDocumentType 文档类型名称 publicId stytemId 123var doctype = document.implementation.createDocumentType(\"html\", \"-//W3C//DTD HTML 4.01//EN\", \"http://www.w3.org/TR/html4/strict.dtd\"); createDocument 针对文档中元素的 namespaceURI 文档元素的标签名 新文档的文档类型 123456var doctype = document.implementation.createDocumentType(\"html\", \" -//W3C//DTD XHTML 1.0 Strict//EN\", \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"); var doc = document.implementation.createDocument(\"http://www.w3.org/1999/xhtml\", \"html\", doctype); // 创建一个新的xhtml文档 document.implementation DOM2级的HTML模块也新增了一个方法 叫 createHTMLDocument() 这个方法用途是创建一个完整的HTML文档 包括L2Dwidget.init({\"model\":{\"scale\":1,\"hHeadPos\":0.5,\"vHeadPos\":0.618,\"jsonPath\":\"/live2dw/assets/tororo.model.json\"},\"display\":{\"superSample\":2,\"position\":\"right\",\"width\":150,\"height\":300,\"hOffset\":-25,\"vOffset\":30},\"mobile\":{\"show\":false,\"scale\":1.2},\"react\":{\"opacityDefault\":0.7,\"opacityOnHover\":0.2},\"log\":false,\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"pluginRootPath\":\"live2dw/\",\"tagMode\":false});!function(e){var r=Array.prototype.slice.call(document.querySelectorAll(\"img[data-original]\"));function t(){for(var c=0;c","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"https://qw8.github.io/tags/DOM/"}]},{"title":"BOM","slug":"knowledges/BOM","date":"2019-10-08T07:38:24.000Z","updated":"2024-02-18T08:36:40.000Z","comments":true,"path":"/knowledges/bom.html","link":"","permalink":"https://qw8.github.io/knowledges/bom.html","excerpt":"","text":"window对象窗口关系及框架 window.frame[0] window.frame[‘topFrame’] window.parent window.top top.frame[0] 特别注意跨域问题 窗口位置screenLeft screenTop screenX screenY IE Safari Opear Chrome 提供了 screenLeft 和 screenTop属性，分别用于表示窗口相对于屏幕左边和上边 Firefox在screenX和screenY属性中提供了相同的窗口位置信息，Safari和Chrome也同时支持这两个属性。Opera虽然也支持screenX和screenY属性，单与screenLeft和screenTop并不对应。 兼容代码 12var leftPos = ( typeof window.screenLeft === \"number\" ) ? window.screenLeft : window.screenX;var topPos = ( typeof window.screenTop === \"number\" ) ? window.screenTop : window.screenY; 但是 仍然会有些计算不精确的小问题 浏览器的问题 moveTo moveBy 将窗口精确地移动到一个新位置 moveTo 接受两个参数， 新位置的X,Y值 moveBy 接收的是在水平和垂直方向上移动的像素数 但是这两个方法可能被浏览器禁用 窗口大小 跨浏览器确定窗口大小不是一件简单的事情 获取可视区域大小 IE9+ Firefox Safari Opera 和 Chrome均为此提供了四个属性—— innerWidth、 innerHeight、 outerWidth、 outerHeight 在IE9+ Safari 和 Firefox中， outerWidth 和 outerHeight返回浏览器窗口本身的尺寸（无论从最外层的window对象还是从某个框架访问）。 在Opera中，这两个属性的值表示页面视图容器的大小（无论是从最外层的window对象还是从某个框架访问） 在Opera中，这两个属性的值表示页面视图容器的大小。而innerWidth和innerHeight则表示该容器中页面视图区的大小（减去边框宽度）。 在Chrome中，outerWidth、outerHeight与innerWidth、innerHeight返回相同的值，即视口（viewport）大小而非浏览器窗口大小 IE8及更糟的版本没有提供取得当前浏览器窗口尺寸的属性。不过，它通过DOM提供了页面可见区域的相关信息。 在IE Firefox Safari Opera 和 Chrome中，document.documentElement.clientWidth 和 document.documentElement.clientHeight中保存了页面视口的信息。 在IE6中， 这些属性必须在标准模式下才有效。如果是混杂模式，就必须通过document.body.clientWidth和document.body.clientHeight取得相同信息。 而对于混杂模式下的Chrome，则无论通过document.documentElement还是document.body中的clientWidth和clientHeight属性，都可以取得视口大小。 虽然最终无法确定浏览器窗口本身的大小，但却可以取得页面视口大小。1234567891011var pageWidth = window.innerWidth, pageHeight = window.innerHeight;if( typeof pageWidth != \"number\" )&#123; if( document.compatMode == \"CSS1Compat\" )&#123; pageWidth = document.documentElement.clientWidth; pageHeight = document.documentElement.clientHeight; &#125; else &#123; pageWidth = document.body.clientWidth; pageHeight = document.body.clientHeight; &#125;&#125; 调整浏览器窗口大小 resizeTo() 接收浏览器窗口的新宽度和新高度 resizeABy() 接收新窗口与原窗口的宽度和高度之差 只能在最外层window对象使用 IE7及更高版本中默认是金庸的 弹出关闭窗口 window.open 详细参数看mdn window.close 一般是通过JS或者用户点击打开的才会执行 检测window.open的返回值可以确定弹出窗口是否被屏蔽 如果浏览器内置的屏蔽程序阻止的弹出窗口，那么window.open()很可能返回null 如果浏览器扩展或其他程序阻止弹出窗口，那么window.open()通常会抛出一个错误 location对象location对象既是window对象的属性，也是document对象的属性。 换句话说，window.location和document.loaction引用的是同一个对象。 参数 hash 返回url中的hash 不存在返回空字符串 host 服务器名称和端口号 hostname 不带端口号的服务器名称 href 返回当前加载页面的完整URL location.toString()方法也返回这个值 pathname 返回url中的目录和（或）文件名 port 返回url中指定的端口号。如果url中年不包含端口号，返回空字符串 protocol 返回页面使用的协议 通常是HTTP https search 返回url的查询字符串。字符串以问号开头 查询字符串参数 12345678910111213141516171819202122function getQueryStringArgs()&#123; // 取得查询字符串并去掉开头的问号 var qs = ( location.search.length &gt; 0 ? location.search.substring(1) : \"\" ), args = &#123;&#125;, items = qs.length ? qs.split(\"&amp;\") : [], item = null, name = null, value = null, i = 0, len = items.length; // 逐个加到args对象中 for( i = 0; i &lt; len; i++ )&#123; item = items[i].split(\"=\"); name = decodeURIComponent( item[0] ); value = decodeURIComponent( item[1] ); if( name.length )&#123; args[name] = value; &#125; &#125; return args;&#125; assign() 立即打开新URL并在历史记录中生成一条新纪录 replace() 打开的URL history不会记录 用户不能后退到上个页面 navigator 对象检测插件 非IE可以使用plugins数组来达到目的。 name： 插件的名字 description： 插件的描述 filename 插件的文件名 length 插件所处理的MIME类型数量1234567891011// 检测插件 在IE中无效function hasPlugin( name )&#123; var name = name.toLowerCase(); for( var i = 0, l = navigator.plugins.length; i &lt; l; i++ )&#123; if( navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; -1 )&#123; return true &#125;; &#125; return false&#125;alert( hasPlugin(\"Flash\") ) 检测IE中的插件 使用专有的ActiveXObject类型 IE是以COM独享的方式实现插件的，而COM对象使用唯一标识符来标识，因此，要检查特定的插件，就必须知道其COM标识符。1234567891011function hasIEPlugin( name )&#123; try&#123; new ActiveXObject( name ); return true &#125; catch (ex)&#123; return false &#125;&#125;// 检测 QuickTimealert( hasIEPlugin( \"QuickTime.QuickTime\" ) ) registerContentHandler() 和 registerProtocolHandler() 这两个方法可以让一个站点指明它可以处理特定类型的信息。","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"BOM","slug":"BOM","permalink":"https://qw8.github.io/tags/BOM/"},{"name":"window对象","slug":"window对象","permalink":"https://qw8.github.io/tags/window对象/"}]},{"title":"Angular","slug":"knowledges/Angular","date":"2019-10-07T07:38:24.000Z","updated":"2024-03-31T16:08:38.000Z","comments":true,"path":"/knowledges/angular.html","link":"","permalink":"https://qw8.github.io/knowledges/angular.html","excerpt":"","text":"angular 的数据绑定采用什么机制？详述原理脏检查机制。 解析：双向数据绑定是 AngularJS 的核心机制之一。当 view 中有任何数据变化时，会更新到 model ，当 model 中数据有变化时，view 也会同步更新，显然，这需要一个监控。 原理就是，Angular 在 scope 模型上设置了一个监听队列，用来监听数据变化并更新 view 。每次绑定一个东西到 view 上时 AngularJS 就会往 $watch 队列里插入一条 $watch ，用来检测它监视的 model 里是否有变化的东西。当浏览器接收到可以被 angular context 处理的事件时， $digest 循环就会触发，遍历所有的 $watch ，最后更新 dom。 AngularJS 的数据双向绑定是怎么实现的？1、每个双向绑定的元素都有一个 watcher 2、在某些事件发生的时候，调用 digest 脏数据检测。 这些事件有：表单元素内容变化、Ajax 请求响应、点击按钮执行的函数等。 3、脏数据检测会检测 rootscope 下所有被 watcher 的元素。 $digest 函数就是脏数据监测 angular 和 jquery 的区别angular 是基于数据驱动，所以 angular 适合做数据操作比较繁琐的项目（这里可以再提一下单页面应用，如果你不会福利又来了 http://www.zhihu.com/question/20792064） jquery 是基于 dom 驱动，jquery 适合做 dom 操作多的项目 angularjs 是 mvc 还是 mvvm 框架mvvm 在 angular 中 MVVM 模式主要分为四部分： View：它专注于界面的显示和渲染，在 angular 中则是包含一堆声明式 Directive 的视图模板。 ViewModel：它是 View 和 Model 的粘合体，负责 View 和 Model 的交互和协作，它负责给 View 提供显示的数据，以及提供了 View 中 Command 事件操作 Model 的途径；在 angular 中$scope 对象充当了这个 ViewModel 的角色； Model：它是与应用程序的业务逻辑相关的数据的封装载体，它是业务领域的对象，Model 并不关心会被如何显示或操作，所以模型也不会包含任何界面显示相关的逻辑。在 web 页面中，大部分 Model 都是来自 Ajax 的服务端返回数据或者是全局的配置对象；而 angular 中的 service 则是封装和处理这些与 Model 相关的业务逻辑的场所，这类的业务服务是可以被多个 Controller 或者其他 service 复用的领域服务。 Controller：这并不是 MVVM 模式的核心元素，但它负责 ViewModel 对象的初始化，它将组合一个或者多个 service 来获取业务领域 Model 放在 ViewModel 对象上，使得应用界面在启动加载的时候达到一种可用的状态。 mvc的界面和逻辑关联紧密，数据直接从数据库读取。 mvvm 的界面与 viewmode 是松耦合，界面数据从 viewmodel 中获取。所以 angularjs 更倾向于 mvvm 解释下什么是$rootScrope以及和$scope 的区别？通俗的说$rootScrope 页面所有$scope 的父亲。 解析： 我们来看下如何产生$rootScope和$scope吧。 12345step1:Angular 解析 ng-app 然后在内存中创建`$rootScope`。step2:angular 回继续解析，找到&#123;&#123;&#125;&#125;表达式，并解析成变量。step3:接着会解析带有 ng-controller 的 div 然后指向到某个 controller 函数。 这个时候在这个 controller 函数变成一个`$scope `对象实例。 列出至少三种实现不同模块之间通信方式？12345- Service- events,指定绑定的事件- 使用 $rootScope- controller 之间直接使用$parent, $childHead等- directive 指定属性进行数据绑定 在使用 angularjs 项目开发中 你使用过那些第三方的插件AngularUi ui-router oclazyload 等等 附上一篇文章仔细去看看 https://segmentfault.com/a/1190000003858219 ng-show/ng-hide 与 ng-if 的区别？我们都知道 ng-show/ng-hide 实际上是通过 display 来进行隐藏和显示的。而 ng-if 实际上控制 dom 节点的增删除来实现的。因此如果我们是根据不同的条件来进行 dom 节点的加载的话，那么 ng-if 的性能好过 ng-show。 表达式yourModel是如何工作的？123表达式 &#123;&#123;yourModel&#125;&#125; 是如何工作的？它依赖于 `$interpolation`服务，在初始化页面html后，它会找到这些表达式，并且进行标记，于是每遇见一个 &#123;&#123;&#125;&#125; ，则会设置一个 `$watch` 。而 `$interpolation` 会返回一个带有上下文参数的函数，最后该函数执行，则算是表达式 `$parse` 到那个作用域上。 angular 中的$http$http 是 AngularJS 中的一个核心服务，用于读取远程服务器的数据。 我们可以使用内置的$http服务直接同外部进行通信。$http 服务只是简单的封装了浏览器原生的 XMLHttpRequest 对象。 ng-repeat 迭代数组的时候，如果数组中有相同值，会有什么问题，如何解决？会提示 Duplicates in a repeater are not allowed. 加 track by $index 可解决。当然，也可以 trace by 任何一个普通的值，只要能唯一性标识数组中的每一项即可（建立 dom 和数据之间的关联） angularjs 中$scope，controller，directive，sevice 在 mvvm 中充当什么角色如果你不知道，第一题的分析以及很明确，仔细再仔细的看一遍 在写 controlloer 逻辑的时候 你需要注意什么？1.简化代码（这个是所有开发人员都要具备的） 2.坚决不能操作 dom 节点 这个时候可能会问 为什么不能啊 你的回答是：DOM 操作只能出现在指令（directive）中。最不应该出现的位置就是服务（service）中。Angular 倡导以测试驱动开发，在 service 或者 controller 中出现了 DOM 操作，那么也就意味着的测试是无法通过的。当然，这只是一点，重要的是使用 Angular 的其中一个好处是啥，那就是双向数据绑定，这样就能专注于处理业务逻辑，无需关系一堆堆的 DOM 操作。如果在 Angular 的代码中还到处充斥着各种 DOM 操作，那为什么不直接使用 jquery 去开发呢。 测试驱动开发是什么呢？普及一下： 测试驱动开发，英文全称 Test-Driven Development，简称 TDD，是一种不同于传统软件开发流程的新型的开发方法。它要求在编写某个功能的代码之前先编写测试代码，然后只编写使测试通过的功能代码，通过测试来推动整个开发的进行。这有助于编写简洁可用和高质量的代码，并加速开发过程。 controller 之间怎么通讯1、event 这里可以有两种方式，一种是$scope.$emit，然后通过监听$rootScope的事件获取参数；另一种是$rootScope.$broadcast，通过监听$scope 的事件获取参数。 这两种方法在最新版本的 Angular 中已经没有性能区别了，主要就是事件发送的方向不同，可以按实际情况选择。 2、service 可以创建一个专用的事件 Service，也可以按照业务逻辑切分，将数据存储在相应的 Service 中 3、$rootScope 这个方法可能会比较 dirty 一点，胜在方便，也就是把数据存在$rootScope中，这样各个子$scope 都可以调用，不过需要注意一下生命周期 4、直接使用$scope.$$nextSibling及类似的属性 类似的还有$scope.$parent。这个方法的缺点就更多了，官方不推荐使用任何$$开头的属性，既增加了耦合，又需要处理异步的问题，而且 scope 的顺序也不是固定的。不推荐 另外就是通过本地存储、全局变量或者现代浏览器的 postMessage 来传递参数了，除非特殊情况，请避免这类方式。 自定义指令的几个参数说几个常用的如： restrict:指令在 dom 中的声明形式 E（元素）A（属性）C（类名）M（注释） template：两种形式，一种 HTML 文本；一个可以接受两个参数的函数，tElemetn 和 tAttrs，并返回一个代表模板的字符串。模板字符串必须存在一个根 DOM 元素 templateUrl:两种形式，一种代表外部 HTML 文件路径的字符串；一个可以接受两个参数的函数，参数为 tElement 和 tAttrs，并返回一个外部 HTML 文件路径的字符串 compile (对象或函数)：compile 选项可以返回一个对象或函数。如果设置了 compile 函数,说明我们希望在指令和实时数据被放到 DOM 中之前进行 DOM 操作,在这个函数中进行诸如添加和删除节点等 DOM 操作是安全的。本质上,当我们设置了 link 选项,实际上是创建了一个 postLink() 链接函数,以便 compile() 函数可以定义链接函数。 然后又是传送门：http://www.cnblogs.com/mliudong/p/4180680.html compile 和 link 的区别： 编译的时候，compile 转换 dom，碰到绑定监听器的地方就先存着，有几个存几个，到最后汇总成一个 link 函数，一并执行，提升了性能。 对 angular 中的 form 表单了解多少Angular 对 input 元素的 type 进行了扩展，一共提供了以下 10 种类型： text、number、url、email、radio、checkboxhidden、button、submit、reset Angular 为表单内置了 4 中 CSS 样式。 ng-valid 校验合法状态 ng-invalid 校验非法状态 ng-pristine 如果要使用原生的 form，需要设置这个值 ng-dirty 表单处于脏数据状态 Angular 在对表单进行自动校验的时候会校验 Model 上的属性，如果不设置 ng-model，则 Angular 无法知道 myForm.$invalid 这个值是否为真。 校验的一下内容 required 表示是否输入内容 ng-maxlength 最大长度 ng-minlength 最小长度 例子：传送门https://github.com/18500047564/clutter fliter 是什么你了解的有多少？实现一个自定义 fliter date（日期） currency（货币） limitTo（限制数组或字符串长度） orderBy（排序） lowercase（小写） uppercase（大写） number（格式化数字，加上千位分隔符，并接收参数限定小数点位数） filter（处理一个数组，过滤出含有某个子串的元素） json（格式化 json 对象） filter 有两种使用方法， 一种是直接在页面里： 1&lt;p&gt;&#123;&#123;now | date : ‘yyyy-MM-dd’&#125;&#125;&lt;/p&gt; 另一种是在 js 里面用： $filter(‘过滤器名称’)(需要过滤的对象, 参数 1, 参数 2,…) $filter(&#39;date&#39;)(now, &#39;yyyy-MM-dd hh:mm:ss’); 自定义一个去重数组的 12345678910111213app.filter(&apos;unique&apos;, function()&#123;return function(arr)&#123;var n = [];var obj = &#123;&#125;; for(var i = 0;i&lt;arr.length;i++)&#123; if(!obj[arr[i]])&#123; n.push(arr[i]) obj[arr[i]] = 1; &#125; &#125; return n;&#125;&#125;)","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"https://qw8.github.io/tags/Angular/"},{"name":"数据绑定","slug":"数据绑定","permalink":"https://qw8.github.io/tags/数据绑定/"},{"name":"MVVM","slug":"MVVM","permalink":"https://qw8.github.io/tags/MVVM/"}]},{"title":"字节跳动面经总结","slug":"interview/字节跳动面经总结","date":"2019-09-19T15:30:33.000Z","updated":"2023-04-14T17:01:50.000Z","comments":true,"path":"/interview/zi-jie-tiao-dong-mian-jing-zong-jie.html","link":"","permalink":"https://qw8.github.io/interview/zi-jie-tiao-dong-mian-jing-zong-jie.html","excerpt":"","text":"记录一下自己的第二次面试经历 面试公司：字节跳动 公司介绍： ​ 字节跳动是全球第一家将人工智能应用到主产品的科技公司。全系产品矩阵包括今日头条、抖音、西瓜视频、火山小视频、TopBuzz、Faceu激萌、图虫、懂车帝等多款产品。截止2019年1月，字节跳动旗下全线产品日活超过6亿，月活超过10亿。字节跳动也在积极进行国际化部署，产品覆盖150多个国家和地区，75个语种，在40多个国家和地区排在应用商店总榜前列。 加入我们，一起和优秀的人做有挑战的事。 点击官网链接，了解更多公司信息 面试岗位：前端研发工程师职位（校招全职） 面试形式：视频面试 面试时间：2019-09-19 17:00:00 GMT+08:00（周四下午五点） 面试来源：字节跳动商业平台团队内部前端岗直推，“流云破风”在2019.9.13发布于前端迷公众号 发送邮箱：yuanlin@bytedance.com ，标注邮件标题：内推，其他岗位，实习校招社招均可 团队特色：全栈、NodeJS&amp;框架、React/Vue、前端基础建设、组件库、数据可视化、多个新方向、自主发挥空间 岗位描述： 1234负责前端技术选型和开发工作；优化前端功能设计，解决各种浏览器和终端设备的兼容性问题；通过技术手段，提升用户体验并满足高性能要求；通用组件、类库编写，提升开发效率和质量。 岗位要求： 1234567本科及以上学历，计算机相关专业； 精通HTML、CSS、JS，熟悉页面架构和布局，熟悉HTML5/CSS3等常用技术；熟悉常用UI框架（如bootstrap/pure/kendo等);精通JavaScript、AJAX、DOM、jQuery等技术；熟悉NodeJS，熟练使用Grunt、Gulp、Webpack等构建工具；具备MVVM框架开发经验，如React、VueJS、AngularJS等；良好的沟通和团队协作能力、热爱技术、责任心强、能推动技术框架的落地使用。 考察内容: 我们主要考察通用型的业务问题和过往的项目经历 价值观和软性技能也是我们选择人才的重要因素 12345678910111213141516171819202122232425262728293031- 自我介绍 什么方式学习- div居中几种方法 盒模型 position属性详细问，相对定位绝对定位fixed box-sizing作用 http状态码304 http请求方法get post put delete head cookie应用在什么方面 cookie有哪些属性、大小 localStorage，sessionStorage的区别 网页访问速度慢，怎么优化- es6（了解吗） this指向（有class的话指向哪里） 作用域 事件循环 异步原理，比如setTimeout 箭头函数与普通函数区别 原型链 闭包 变量提升- vue与jQuery区别 vue实现原理 vue绑定- 编程题： var versions=[&apos;1.45.0&apos;,&apos;1.5&apos;,&apos;6&apos;,&apos;3.3.3.3.3.3.3&apos;] var sorted=[&apos;1.5&apos;,&apos;1.45.0&apos;,&apos;3.3.3.3.3.3&apos;,&apos;6&apos;] 面试就是一个不断见面，试验，总结，归纳与提高的过程。 面试不同于考试，考试机会难得，形式及考察能力单一，而面试机会很多，形式不同，考察能力全面。 只要一直面，总会有进步，总会有提高的。 ​ 写于： 2019.9.19 面试之前找的各种面经投递简历后过了一段时间接到约面小姐姐的电话，了解你的具体的实习时间段，和你约定面试时间。你确认后小姐姐挂电话。过段时间hr给你发视频面试的链接，是牛客网用来面试的链接。 正文面试前做出的准备我在面试前准备以下几点东西，似乎都解决了面试的部分问题 面试前我查阅了其他朋友写的字节跳动的面经以及面试题目，寻找题目解答，把它们总结了下来，用了一天一夜的时间，并把它们放到了我的这个博客上面。我做了一份详细的自我介绍，通过三段开发经历来总结出了我的一些优点和开发经验，用讲故事的形式说明情况，最后点明故事中表现了自己具有哪些素质，点明自己为什么可以做前端的工作。字节跳动的宗旨“和优秀的人一起做有挑战的事情”也被我用到了自我介绍中，“我认为我是优秀的人，也喜欢做有挑战的事情，更喜欢与优秀的人为伍”“我希望搭上字节跳动这架火箭”等等。快要面试时做出的准备快要面试了，第一次面试，有些紧张，但还是像平常考试一样，将总结下来的面试题目总结、前端遇到问题的总结又看了一遍，把自己做好的自我介绍熟悉的几遍，给自己亲近的朋友发条消息获得她的祝福，又站在电脑桌前活动了一下身子，头脑顿时清醒利索了许多。 面试前奏由于紧张怕错过面试，早早的便坐在了电脑桌前。面试官迟到了一会，就给我发起了面试视频邀请，终于开始了。迎面是一个挺帅气的哥哥，简单的打了一下招呼，就进入了自我介绍的环节。由于自我介绍我已经熟悉过几遍了，自我介绍的效果看起来效果还是不错的。开始问我项目经历的细节以及自我介绍中的细节，由于项目经历确实是自己亲身经历过的事情，并且我一般项目完成时都会做一下总结，所以也能够答个头头是道。个人感觉上的，至于面试官怎么想的，我就不清楚了， 说不定是那种我就静静的看着你装逼的情况。 面试高潮来了来了，开始问技术的问题了。 你对Vue的理解有多少因为我在简历的项目经历中写了一个Vue项目，于是他问的时候就把我在项目中对Vue的理解和面试前准备的Vue总结结合起来回答。 用css2和css3分别写一下垂直居中和水平居中这道题我不会，并不知道css2和css3有什么区别以及写法，只会css3，我脑袋里有面试前总结的垂直居中和水平居中其中的两种方式，我就给他讲了一讲，倒是他没有再问下去，可能看出来我不会了吧。这也体现出了面试前知识点总结复习的重要性，不然你不会的东西你连说都不会说。 css3新增了一些属性，像flex，这是css3中很重要的改变，所以除了flex以外的垂直水平居中的技巧都是属于css2的。 css2的水平居中技巧将元素display为行内元素，再text-align:center;即可或者将块级元素定义一个宽度，再margin: 0 auto;即可 css3的水平居中技巧将元素display设为flex，再通过justify-content: center; 实现居中。 css2的垂直居中技巧单行内容的垂直居中可以通过设置相同height值和line-height值来实现。多行内容的垂直居中且高度可变可以通过设置上下相同的padding值来实现。行级盒子：小图标和标题对齐设置vertical-align: middle。绝对定位：top:50%; left:50%;的方法，需要已知块级的宽高 css3的垂直居中技巧将元素display设为flex，再通过align-items:center;来实现。 你对计算机网络的认识怎么样又是一道探底的题，判断能否从这里给你出题考察你 讲述一下计算机网络的七层应用层、表示层、会话层、传输层、网络层、数据链路层、物理层 TCP和UDP的区别是什么TCP：面向连接、传输可靠(保证数据正确性,保证数据顺序)、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)UDP：面向非连接、传输不可靠、用于传输少量数据(数据包模式)、速度快TCP和UDP协议的一些应用例子：TCP一般用于文件传输（FTP HTTP 对数据准确性要求高，速度可以相对慢），发送或接收邮件（POP IMAP SMTP 对数据准确性要求高，非紧急应用），远程登录（TELNET SSH 对数据准确性有一定要求，有连接的概念）等等；UDP一般用于即时通信（QQ聊天 对数据准确性和丢包要求比较低，但速度必须快），在线视频（RTSP 速度一定要快，保证视频连续，但是偶尔花了一个图像帧，人们还是能接受的），网络语音电话（VoIP 语音数据包一般比较小，需要高速发送，偶尔断音或串音也没有问题）等等。 TCP和UDP属于计算机网络中的哪一层网际层协议：IP协议、ICMP协议、ARP协议、RARP协议传输层协议：TCP协议、UDP协议应用层协议：FTP、Telnet、SMTP、HTTP、RIP、NFS、DNS HTTPS是什么HTTPS即加密的HTTP，HTTPS并不是一个新协议，而是HTTP+SSL（TLS）。原本HTTP先和TCP（假定传输层是TCP协议）直接通信，而加了SSL后，就变成HTTP先和SSL通信，再由SSL和TCP通信，相当于SSL被嵌在了HTTP和TCP之间 介绍几种常见的状态码2XX系列：代表请求已成功被服务器接收、理解、并接受。200状态码：表示请求已成功，请求所希望的响应头或数据体将随此响应返回201状态码：表示请求成功并且服务器创建了新的资源，且其 URI 已经随Location 头信息返回。3XX系列：代表需要客户端采取进一步的操作才能完成请求，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。301状态码：被请求的资源已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。302状态码：请求的资源临时从不同的URI响应请求，但请求者应继续使用原有位置来进行以后的请求。304状态码：自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。4XX系列：表示请求错误。代表了客户端看起来可能发生了错误，妨碍了服务器的处理。401状态码：请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。403状态码：服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。404状态码：请求失败，请求所希望得到的资源未被在服务器上发现。5xx系列：代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。500状态码：服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。503状态码：由于临时的服务器维护或者过载，服务器当前无法处理请求。 闭包是什么闭包就是能够读取其他函数内部变量的函数。闭包的用途：可以读取函数内部的变量，并且让这些变量的值始终保持在内存中。 123456789101112131415// 输出全为10for(var i=0;i&lt;10;i++)&#123; setTimeout(function()&#123; console.log(i); &#125;,50);&#125;// 输出相应的输出for(var i=0;i&lt;10;i++)&#123; (function(i)&#123; setTimeout(function()&#123; console.log(i); &#125;,50); &#125;)(i);&#125; js的隐性转换和显性转换隐性转换为： 1 + ‘1’ = ‘11’显性转换Number(“24 cccc”);//结果：NaNParseInt(“24 cccc”);//结果：24备注：Number的显性转换比较严格，若无法强转则直接报错 NaN是什么，用typeof会输出什么Not a Number会输出 Number js的隐性转换和显性转换隐性转换为： 1 + ‘1’ = ‘11’显性转换Number(“24 cccc”);//结果：NaNParseInt(“24 cccc”);//结果：24备注：Number的显性转换比较严格，若无法强转则直接报错面试官后引伸了两个问题1 + -‘1’ + 1 等于什么等于 0 ，’1’前面的负号把其数字化，变为-1，则后值为1‘A’ - ‘B’ 等于什么NaN 跨域问题如何解决同源策略：浏览器安全策略，同协议、ip、端口的脚本才会执行。只要协议、域名、端口有任何一个不同，都被当作是不同的域js跨域是指通过js在不同的域之间进行数据传输或通信 通过jsonp跨域 jsonp在页面上引入不同域上的js脚本文件实现请求不同域上的数据 (1) 通过script标签引入一个js文件 (2) js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入 注：需要服务器端的页面进行相应的配合 通过修改document.domain来跨子域 使用window.name来进行跨域window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。 知道babel么可以实现将ES6编译为ES5代码 用js实现判断一个变量是否为整数的函数实现思路：先判断该变量是否为Number类型，以此来缩小范围，再判断该变量除以1后是否与原值全等，若全等则返回true，若不全等则返回false 进程和线程是什么线程是最小的执行单元，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。进程指计算机中已运行的程序。线程指操作系统能够进行运算调度的最小单位。 死锁是什么当两个以上的运算单元，双方都在等待对方停止运行，以获取系统资源，但是没有一方提前退出时，就称为死锁。 Left Join、Right Join、Inner Join 指的是什么 LEFT JOIN 关键字会从左表那里返回所有的行，即使在右表中没有匹配的行 RIGHT JOIN 关键字会右表那里返回所有的行，即使在左表中没有匹配的行 在表中存在至少一个匹配时，INNER JOIN 关键字返回行 快速排序用js怎么写 1234567891011121314151617181920function quickSort(arr) &#123; if(arr.length&lt;=1) &#123; return arr; &#125; var s = Math.floor(arr.length/2); var temp = arr.splice(s,1); var left=[]; var right=[]; for(var i=0;i&lt;arr.length;i++) &#123; if(arr[i]&lt;temp) &#123; left.push(arr[i]); &#125; if(arr[i]&gt;=temp) &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat(temp,quickSort(right)); 面试尾声 面试官的突然一声“我这边没有什么问题了”，吓了我一跳，悬了悬了，我还想着跟他唠嗑两小时呢，唠嗑的感觉真好。 “我这边没有什么问题了，请等待hr的通知吧” 小技巧做项目小技巧每次项目完成后，都需要做一下项目的总结，这是做一两个项目并做总结的人比做很多的项目不做总结的人看起来更有经验的原因。古人说的好，“总结反思才能成长”。做简历小技巧套模板，注意写下什么时间毕业，尽可能的填充项目经验，项目经验写的详细些，重点是从项目中学到了什么。面试写代码小技巧写的代码记得加注释，考虑代码的时间复杂度问题，不会写代码一定要给面试官说一下你的思路，脑袋中想到什么说什么，部分解决方法也比说一声我不会强太多。总结实习的面试多进行基础知识的储备 我上个月的实习生面试是，两点半开始一面，结束后等个十分钟继续二面，视频面试。实习生的话只有两轮技术面+hr面。楼主加油，千万要准备好现场写一堆代码的准备�� 牛客上可以在线写代码，面试官可以实时看到的，写完代码后面试官还会就你写的代码进行提问。 技术岗一般连续面3轮。除非第一面安排在下午~ 我记得我那天从4点面到8点半，连续三轮（中间留了会吃饭时间） 面试官很有亲和力，面试过程更像是聊天多一点，但面试官提的问题也很有专业性，会对简历经历进行提问，并进行扩展，最后有对英语能力的考察。 面试官人很好,约定的六点面试,提前五分钟就到了面试间(还好我提前十分钟就在了..) 答题期间会根据我的答案给出建议和提示,全程虽然很紧张,但是知晓了自己的不足,考察点偏向基础和数据结构 问题如下: http协议知道吗? cookie session介绍一下 session表结构怎么设计,储存在哪里 你们的session cookie在项目里运用到哪里 算法题目:[删除链表中重复的节点]在一个排序的链表中,存在重复的节点,请删除该链表中重复的节点,重复的节点不保留,返回链表头指针.例如,链表1-2-3-3-4-4-5处理后为1-2-5 TCP/UDP的区别介绍一下 三次握手和四次挥手,time_wait是什么状态 B树 B+树区别说一下 数据库平时用到过什么 咱们先问MySQL MySQL索引原理知道吗 问了两种索引的区别(没记住…) 乐观锁悲观锁区别说一下 innodb和myisam的区别 数据库四种隔离状态 分别有什么问题 redis的数据结构 sortset底层,原理,怎么保证有序 总结: 就是自己太菜了..很多基础知识忘得很厉害,大公司感觉考察的都是基础,面试官在面试过程中有耐心,也会给与一些提示,素质很好 下来自己多背背知识,多刷一下leetcode吧..争取下次成功 面试用的视频面，面试官挺和善，问的内容也挺基础的，大概回忆着记录一下。 TCP和UDP的区别。TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接 TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付 TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的 UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等） 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信 TCP首部开销20字节;UDP的首部开销小，只有8个字节 TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道 说一下你对http协议的理解这个我只讲了个三次握手和四次挥手的内容，面试官貌似不太满意 get和post的区别这个回答的也不太全，其中我提到了数据存储在request body，面试官又问了我request body存储get和post的区别，emmmm…实在不会就下一题了 css实现一个左侧固定20px，右侧响应式的布局这个就蒙蔽了，因为我用的bootstrap是自带的响应式布局，不太了解原生css。回答的面试官也不太满意。 css实现水平垂直居中基础题jQuery选择器是如何实现的，例如$（#a.b…）对于jquery我当时也只是停留在使用层面，没去了解过实现原理，结果也没答上来 谈一下对事件流的了解大概讲了一下事件的冒泡和捕获的区别，然后面试官又问了一下冒泡最后会到哪里，我不太确定说了到,面试官又问我确不确定，我说不太确定。 8.最后给了一道算法题。大概是字符串的模式识别的题我写了一个最简单的，然后面试官要求优化复杂度，这个我当时隐约记得个kmp算法，就讲了一下思路，结果面试官要求写出实现代码，这磨蹭了半天也没写出来emmmmm…（顺带一提，当时面试用的是同学的电脑，不知道他装的IDE在哪，只好用的记事本写代码，痛苦） 总结 说实话当时我根本啥都不会，纯小白一个，复习了两三天菜鸟教程，w3school就去面试了，不出意外被拒了。 大厂很看重基础，考的都是原生css原生js和一些计算机网络、数据结构的内容，我了解的那些框架问题都没用上。 面试铁律自我介绍，基本上这是开启激战的导火索。顺便一提，宇宙条的视频面试是在牛客网上，可进行编码，视频，语音，文字沟通。面试官可以实时看到应聘者当前页面的内容和操作。 基础题1.display的取值和各种值的区别？ 2.相邻的两个inline-block节点为什么会出现间隔，该如何解决？ 3.用过nodejs中的EventEmitter吗？详细讲讲。 4.前端性能优化有哪些？ 5.讲简历中提到的一个项目，并且讲解服务端渲染和前端渲染的优缺点？为什么你的项目会选择服务端渲染？ 6.讲讲CSRF。 7.ts和js的区别，为什么要选择使用ts？ 算法题找出数组中和为给定值的两个元素，如：[1, 2, 3, 4, 5]中找出和为6的两个元素。 题目很清晰，也很容易理解，相信很多小伙伴看到这个题都能直观地用“冒泡排序”的方法解决，但是冒泡排序的时间复杂度明显不是我们想要的结果，我把我能够想到的几种方法由易到难记录下来： 冒泡排序的方式 12345678910111213141516function getNum(arr, sum) &#123; if (!Array.isArray(arr)) return null; for (var i = 0; i &lt; arr.length - 1; i++) &#123; if (arr[i] &gt; sum) continue; for (var j = 0; j &lt; arr.length; j++) &#123; if (arr[j] &gt; sum) continue; if (arr[i] + arr[j] == sum) return [arr[i], arr[j]]; &#125; &#125; return null;&#125;复制代码 这种解法很容易想到，也很容易理解，我们不多过多的讲解，接下来分享一种上述解法的优化版。 查找的方式 最终的结果是要找到和为sum的两个数，那么我们可以转换一种思路：默认第一个num1数已经存在，那么第二个数就是sum - num1，这就转换为从数组中查找的问题了。虽然和第一种方法很像，但是在有序数列中进行查找明显要快于逐个比较。 12345678910111213141516function getNum(arr, sum) &#123; if (!Array.isArray(arr)) return null; arr.sort(); for (var i = 0; i &lt; arr.length - 1; i++) &#123; if (arr[i] &gt; sum) continue; var restNum = sum - arr[i]; // 考虑下为什么要 &gt; i if (arr.indexOf(restNum) &gt; i) return [arr[i], restNum]; &#125; return null;&#125; 这种解法的前提是需要对数组进行排序（快排），故时间复杂度为O(nlogn)，二分查找的时间复杂度为O(log2n)，最坏的情况是遍历了整个数组，即时间复杂度为O(n)，那么整体的时间复杂度为O(nlog2n)，效果上要优于冒泡排序的方式。 快排方式 同样需要对数组进行排序（升序），我们知道排序后的数组必然是左边的数不会超过右边的数，因此我们可以把左边的数和右边的数的和作为基准值来和目标值比较，如果该值小于目标值，那么代表两个加数的值不够大，右边的值已经到达顶峰了，那么就从左边取下一个值相加和目标值比较，如果该值比目标值大，那么表示右边的值太大了，需要获取一个小一点的加数，这时需要从右边取倒数第二个数相加后比较，如果此时的值和目标值相等，恭喜你，我的小乖乖，原来你俩在这里！说了这么多感觉还是一头雾水的同学直接看代码吧，毕竟我们都是同一类猿:-) 123456789101112131415function getNum(arr, sum) &#123; if (!Array.isArray(arr)) return null; arr.sort(); for (var i = 0, j = arr.length - 1; i &lt; j;) &#123; if (arr[i] + arr[j] &lt; sum) i++; else if (arr[i] + arr[j] &gt; sum) j--; else return [arr[i], arr[j]]; &#125; return null;&#125; 这种方法我是受到了快速排序的启发，所以命名为快速排序的方式，它是目前为止我能想到效率最高的解决方案，时间复杂度为O(nlogn)。如果需求是找出所有对组合，只要控制退出条件即可，难度不大故不做讨论。 面试考察点归纳 这里只是简要记录个人在前端面试遇到的考察点： position和display、事件机制、dom、捕获冒泡、this及作用域、原型链、es6（了解）、vue的双向绑定原理（最好有用过，一定程度上考察了源代码理解）、基础的数据结构……等。 其中，dom的考察了一道，this及作用域考察了两道，数据结构考察了一道，其它的都以概念提问的方式进行考察。 可以总结出以下教训： js基础是重中之重，而前端对算法的要求基本上不是特别高，基础的数据结构牢固掌握了就没问题。另外前端的话，刷算法题最好用js。 对于你没怎么接触过的领域，面试官并不会去深究；但是，对于网上疯传的Vue等框架，最好有个了解和体验，甚至是深入源码。 一个很明显的现象是，一个概念你知道了，但不一定能说得清楚；一个概念你看似仔细了解过，但真正面临考察时不一定能说出个所以然。解决这个问题的最好办法是——写博客。 并没有考察到websocket、nodejs等知识，这个阶段的面试要求并没有网传得那么高。 笔试 + 一面敲黑板！头条是一定会有笔试题的哦，css，js，算法都会考察噢。我尽量还原题目。。有的实在是忘了-.- 实现css布局1234567一个div垂直居中其距离屏幕左右两边各10px其高度始终是宽度的50%div中有文本'A'其font—size:20px文本水平垂直居中 我的回答： 12345678910111213141516171819202122232425262728293031&lt;div class=\"wrap\"&gt; &lt;div class=\"box\"&gt; &lt;span class=\"text\"&gt;A&lt;/span&gt; &lt;div&gt;&lt;/div&gt;.wrap &#123; position: fixed; left: 10px; right: 10px; top: 0; bottom: 0;&#125;.box &#123; position: absolute; top: 50%; transform: translateY(-50%); width: 100%; height: 50%; background: red;&#125;.text &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; font-size: 14px; background: blue;&#125; 我的回答好像做不到“其高度始终是宽度的50%”这一点，网上参考了一下其他大神的，使用了calc和flex，大家可以看看： 123456789101112131415161718192021222324252627282930&lt;div class=\"box\"&gt; &lt;div class=\"Abox\"&gt;A&lt;/div&gt;&lt;/div&gt;*&#123; padding:0; margin: 0;&#125;html,body&#123; width: 100%; height: 100%;&#125;.box&#123; position: relative; background: red; width: 100%; height: 100%;&#125;.Abox&#123; margin-left:10px; width: calc(100vw - 20px); height: calc(50vw - 10px); position: absolute; background: yellow; top:50%; transform: translateY(-50%); display: flex; align-items: center; justify-content: center; font-size: 20px;&#125; 函数中的arguments是数组吗？类数组转数组的方法了解一下？答： arguments当然不是数组啦，转数组的方法有： […arguments] Array.from(arguments) 类型比较1234if([]==false)&#123;console.log(1)&#125;;if(&#123;&#125;==false)&#123;console.log(2)&#125;;if([])&#123;console.log(3)&#125;if([1]==[1])&#123;console.log(4)&#125; 答：1 3 == 是非严格比较操作符，false会转换为0，[]会转换成’’，{}会转换为”[object Object]”，所以会输出1，不输出2，具体的可以看看以下文章 参考文章 为什么[] 是 false []和{}是“空”的对象，不是“空”，所以会输出3 最后一个引用地址不一致，不是同一个对象，所以不会输出4 EventLoop123456789101112131415161718192021222324252627282930313233async function a1 () &#123; console.log('a1 start') await a2() console.log('a1 end')&#125;async function a2 () &#123; console.log('a2')&#125;console.log('script start')setTimeout(() =&gt; &#123; console.log('setTimeout')&#125;, 0)Promise.resolve().then(() =&gt; &#123; console.log('promise1')&#125;)a1()let promise2 = new Promise((resolve) =&gt; &#123; resolve('promise2.then') console.log('promise2')&#125;)promise2.then((res) =&gt; &#123; console.log(res) Promise.resolve().then(() =&gt; &#123; console.log('promise3') &#125;)&#125;)console.log('script end') 正确答案： 1234567891011121314script starta1 starta2promise2script end// 此处开始执行异步队列promise1promise2.thenpromise3// 真的不知道 a1 end 为啥在这里才输出，还以为会在promise1 后面。。// 大家知道的话可以评论区分享一下啊～在网上看到的答案都说得模凌两可的a1 end// 执行完所有微任务才执行宏任务setTimeout 改正代码，输出01234012341234567891011function a () &#123; for (var i = 0; i &lt; 5; i++) &#123; this.i = i setTimeout(function () &#123; console.log(i) &#125;, 0) console.log(this.i) &#125;&#125;a() 答：首先留意var，可以改成let，再加个立即执行函数；然后留意this指向，可以改为箭头函数。（我当时的想法就是这么短浅。。。） 12345678910111213function a () &#123; for (let i = 0; i &lt; 5; i++) &#123; (function (i) &#123; this.i = i setTimeout(() =&gt; &#123; console.log(i) &#125;, 0) console.log(this.i) &#125;)(i) &#125;&#125;a() 我的一个牛逼大神同事用了这个方法，实在佩服啊哈哈哈👇 1234567891011121314151617181920var count = 0;Object.defineProperty(window, 'i', &#123; get: function() &#123; return count++ &#125;, set: function() &#123;&#125;&#125;)function a () &#123; for (let i = 0; i &lt; 5; i++) &#123; (function (i) &#123; this.i = i setTimeout(() =&gt; &#123; console.log(this.i) &#125;, 0) &#125;)(i) &#125;&#125;a() 5分钟后他又想出了一个新方法！我的膝盖啪一声跪下来👇 12345678function a () &#123; for (var i = 0; i &lt; 5; i++) &#123; this.i = i setTimeout(function () &#123; console.log(this.i) &#125;.bind(&#123;i: i&#125;), 0) &#125;&#125; 按要求写出bind（题目我实在记不清楚，反正不是简单的写一个bind）答：(以下是正常的bind手写实现) 1234567891011121314151617181920Function.prototype.bind2 = function (context) &#123; if (typeof this !== \"function\") &#123; throw new Error(\"Function.prototype.bind - what is trying to be bound is not callable\"); &#125; var self = this; var args = Array.prototype.slice.call(arguments, 1); var fNOP = function () &#123;&#125;; var fbound = function () &#123; self.apply(this instanceof self ? this : context, args.concat(Array.prototype.slice.call(arguments))); &#125; fNOP.prototype = this.prototype; fbound.prototype = new fNOP(); return fbound;&#125; 从一个无序，不相等的数组中，选取N个数，使其和为M实现算法哈哈哈哈哈做不出来，面试官很有耐心引导，假如选取2个数的话怎么实现呢，我就想到递归函数之类的，但是最后还是手写不出来。。。 一面的面试官主要是看着笔试题拓展问了相关的知识点，然后我也不知道怎么就过了一面了，，， 二面二面几乎都是算法题，再加点js基础题这样。emmm算法题我就说说当时的做法吧，，感觉要误人子弟了，，改天研究透了再单独分享 1. 一个字典[‘I’, ‘have’, ‘a’, ‘book’, ‘good’]，实现一个函数，判断一个字符串中是否都是出自字典中的，输出true/false 例如： 输入’I have a book’ 输出 true 输入 ‘this is a good book’ 输出 false 答： 我当时是想出了个很蠢的方法，就是将字符串的字典词都切了，切完后还有得剩就说明是false，哈哈哈哈啊哈哈哈好蠢啊，面试官不满意地问我这个做法的复杂度，我说好的我知错了。。。 2. 一个长阶梯有n级，可以一次走1级，一次走2级，一共有多少种走法？ 答： 引导了一番后我写了个递归函数 12345function step (n) &#123; if (n === 1) return 1 if (n === 2) return 2 return step(n - 1) + step(n - 2)&#125; 面试官看完后不是很满意，说假如在浏览器上敲step(40000)会怎样，我说会爆掉吧。。他说为什么。。我说内存会溢出。。他问我为什么。。 blablabla一大堆后我还是没答好，回到家后我想想觉得应该是还存在尾递归的优化空间吧。。。 ////////之后问的算法题我已经记不住了。。我再分享一些基础题题目吧，大部分答案都在之前的文章和面经都提过了，此处不再赘述 3. 说说http缓存 4. 用过typescript吗？它的作用是什么？ 答： 用过，我真的只想到类型检查，提供缺省值诶，，后来想想还有引入了“类”“模块”的概念。 5. ts的用法用到了装饰器，你了解过吗？知道如何实现的嘛？ 答：这个正好我写了一篇装饰器的文章，略知一二。。。实现大概就是使用object.defineProperty来拦截对象的属性进行“加工” 6. PWA使用过吗？serviceWorker的使用原理是啥？ 最后。。。有的题目真的想不起来了，最后二面面试官和我说他们是对算法有要求的，包括前端。这次面试真的被虐得很惨，但是收获真的很多很多，而且也让自己意识到算法真的（对找工作）很重要～！ 一面（40分钟）自我介绍 1.线程与进程，空间分配、资源分配等等 2.三次握手、四次挥手及标志位、time-wait等等 3.H5的新特性，语义化 4.BOM与DOM，及BOM相关的一些属性 写代码：双向绑定、防抖和节流 5.设计模式：发布订阅、观察者 二面（1小时）介绍项目 1.web worker，web storage，怎样验证本地数据的有效性 2.性能优化相关 3.缓存相关的http头部属性，强制缓存，协商缓存，优先级，以及meta标签 4.怎样做的登录，接着就是session，cookie，token等等 5.input属性相关，以及怎样做的文件上传 6.微信小程序相关（项目中有涉及到） 7.transform transition与animation 8.setTimeout、setInterval与requestAnimationFrame 9.页面加载问题，JS的异步加载 10.给出代码，说出运算结果（this、event loop） 写代码：回文数，数组去重，自定义log，判断数据类型 ​ 11.React与Vue，各自做了些什么事情 三面（1小时）介绍项目 缓存命中率的问题，怎样确保缓存全部数据，缓存命中率不是100%应该怎么办 说说性能优化的通用架构方案 请求优化和渲染优化的方法 数据类型转换的原理 编程，5个feach请求，请求完成后要求立即执行，但最终的输出顺序要按照要求输出ABCDE（思路是：将每个feach的回调通过a/a的方式输出，但最后没有run出来） 面了一个小时，从四点面到五点一十，下面的问题可能不是所有的，反正我记得起来的都写了。 算法：链表反序输出，不再申请内存空间 0.1+0.2===0.3吗，为什么？ Number()的存储空间是多大，如果后台发送了一个超过最大字节的数字怎们办 垂直居中实现方法 跨域、jsonp原理、CORS原理 Proxy Promise原理 浏览器请求数据问题，请求数据到请求结束与服务器进行了几次交互 TCP为什么要四次挥手 cookie有哪些属性、大小、浏览器如何禁止别人访问cookie localStorage，sessionStorage的区别。 display:none,visibility:hidden,opactiy:0的区别。 BFC，如何形成BFC BFC与IFC的区别 BFC会与float元素相互覆盖吗？为什么？举例说明 回流与重绘，如何避免回流 git merge、git rebase的区别 js脚本加载问题，async、defer问题 antd源码相关，使用什么语言写的，按需加载实现 设计模式，有哪些设计模式 在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持 websocket与ajax的区别 fetch API与传统request的区别 说一下心得好了，因为他面算法，我不会，我说我只会简单的快排、冒泡、归并等算法，所以面试官后面就没问算法了 问框架我有的答得出来，我跟他说我框架掌握比较薄弱，基础比较厉害，所以框架就问的少，问很多js相关、交互相关的基础 一面过了，面试官是个很可爱的小哥哥，虽然前面第一题问算法，第二题问框架，我都没答出来很尴尬，但后面问很多js和浏览器基础，都答上来了，所以,面试还是很人性化的~ 其实这些面试题哈哈，上次我跟部门的小哥哥小姐姐去吃火锅，坐在我一面面试官对面，还拿着题考他哈哈，这边的人真的超级可爱～ 然后我一面、二面、三面都发了帖子，大家可以对比一下啊。，一般一面是部门同事面，涉及到比较广，如果面到40min以上基本上稳的几率比较大，二面是其他部门的前端交叉面你，主要问项目比较多，然后很可能手撕代码（校招可能一面就手撕）。三面的话是leader面，应该会着重问一下你的学习能力什么的。 首先，一般的都是介绍自己，主要是项目经历jQuery与Vue的区别是什么？JQuery和Vue的主要区别是JQuery主要是通过选择器来选取DOM，对其进行赋值，取值，事件绑定等操作，数据和页面是混合在一起的；Vue则是通过Vue对象将数据和视图完全分割开来，对数据进行操作，不再需要引用相应的DOM对象，实现了MVVM。 javascript数据基本类型有哪些？null、boolean、string、undefined、number、symbol(ES6新加) css 水平垂直居中方法body{ 123456789101112 height:1000 px;&#125;.antzoen&#123; position:fixed; width:250px; height:100px; background:#ececec; left:50%; top:50%; margin-left:-125px; margin-top:-50px&#125; 利用flex布局：.center{ 123display:flex;justify-content:center;align-items:center; }等等还有很多其他的方法就不一一分享了。 11月25号流程： 1.笔试，给了两页题自己做，大概做了40分钟我怕时间太久，有一道题没写出来就交了。 ​ 2.一面，面试官拿着我的笔试答案一道题一道题问，答上来的就直接说答案，答不上来的我说了下我的思路，和面试官一起探讨思考答案。 ​ 3.二面，问项目，问了问以前做的项目，遇到什么挑战等等，还问了几个JS问题。 ​ 4.三面，主管面，问项目，问方案，三面就像在聊天，没有压力。 ​ 5.四面，HR面，问一些和技术无关的，如兴趣、原来公司等等，然后就定级、定薪资了。发布 11月26号： ​ 6.五面，交叉面，别的部门的人来面试，简单聊了聊项目，然后出了个算法题，没答上来，15分钟就结束了 11月27号： ​ 面试结果审核通过，薪资审核 11月28号： ​ 薪资审核通过，收到了offer 简答题1.css3特性中的transform：translateZ(0)有什么作用答案：GPU加速，优化前端性能 2.列举三种禁止浏览器缓存的头字段，并写出响应的设置值Expires：告诉浏览器把回送的资源缓存多长时间 -1或0则是不缓存简要：添加Expires头能有效的利用浏览器的缓存能力来改善页面的性能，能在后续的页面中有效避免很多不必要的Http请求，WEB服务器使用Expires头来告诉Web客户端它可以使用一个组件的当前副本，直到指定的时间为止。例如：Expires：Thu，15 Apr 2010 20：00：00 GMT; 他告诉浏览器缓存有效性持续到2010年4月15日为止，在这个时间之内相同的请求使用缓存，这个时间之外使用http请求。 Cache-Control：no-cacheCathe-Control：max-age=315360000 Expires有一个非常大的缺陷，它使用一个固定的时间，要求服务器与客户端的时钟保持严格的同步，并且这一天到来后，服务器还得重新设定新的时间。HTTP1.1引入了Cathe-Control，它使用max-age指定组件被缓存多久，从请求开始在max-age时间内浏览器使用缓存，之外的使用请求，这样就可以消除Expires的限制，如果对浏览器兼容性要求很高的话，可以两个都使用。 Pragma：no-cache 3.精确获取页面元素位置的方式有哪些那就是使用getBoundingClientRect()方法。它返回一个对象，其中包含了left、right、top、bottom四个属性，分别对应了该元素的左上角和右下角相对于浏览器窗口（viewport）左上角的距离。 12345var X= this.getBoundingClientRect().left;var Y =this.getBoundingClientRect().top;//再加上滚动距离，就可以得到绝对位置var X= this.getBoundingClientRect().left+document.documentElement.scrollLeft;var Y =this.getBoundingClientRect().top+document.documentElement.scrollTop; 4.正则从2018-10-07T11:48:47 Asia/zh-cn 提取出来结果[2018,10,07,11,48,47]“2018-10-07T11:48:47 Asia/zh-cn”.match( /\\d{1,}/g ) 5.如何判断object是数组类型？12345678alert(typeof 1); // 返回字符串\"number\" alert(typeof \"1\"); // 返回字符串\"string\" alert(typeof true); // 返回字符串\"boolean\" alert(typeof &#123;&#125;); // 返回字符串\"object\" alert(typeof []); // 返回字符串\"object \" alert(typeof function()&#123;&#125;); // 返回字符串\"function\" alert(typeof null); // 返回字符串\"object\" alert(typeof undefined); // 返回字符串\"undefined\" 其中，typeof {}和typeof []的结果都是object，那么问题来了，我怎么通过typeof去判断一个对象是不是数组类型呢？ 对象是对象，数组也是对象，js中万物皆对象，很显然，通过简单的typeof运算符是不能够达到目的，我们得换个方法。 1、从原型入手，Array.prototype.isPrototypeOf(obj); 利用isPrototypeOf()方法，判定Array是不是在obj的原型链中，如果是，则返回true,否则false。 判断object是数组类型 2.Array.isArray()方法。 1234Array.isArray([1, 2, 3]); // trueArray.isArray(&#123;foo: 123&#125;); // falseArray.isArray('foobar'); // falseArray.isArray(undefined); // false 500：服务器内部错误。 501：服务器不具备完成请求的功能。 502：Bad Gateway错误。 503：服务器目前无法使用。 504： Bad Gateway timeout 网关超时。 cookie： 在本地计算机保存一些用户操作的历史信息（当然包括登录信息），并在用户再次访问该站点时浏览器通过HTTP协议将本地cookie内容发送给服务器，从而完成验证，或继续上一步操作。 session： 是一种服务器端的机制，服务器使用一种类似于散列表的结构(也可能就是使用散列表)来保存信息。 编程题1.已知数据结构users，请实现语法支持user.unique能够按照name字段去重，并输出结构为：[“a”,“b”]123456789101112131415161718192021222324var users=[&#123; id:1,name:\"a\"&#125;,&#123; id:2,name:\"a\"&#125;,&#123; id:3,name:\"b\"&#125;,&#123; id:4,name:\"v\"&#125;]Array.prototype.unique = function () &#123; var res; this.map(item =&gt; &#123; this[item.id - 1] = item.name &#125;) // ES6里新添加了两个很好用的东西，set和Array.from // set是一种新的数据结构，它可以接收一个数组或者是类数组对象，自动去重其中的重复项目。 res=new Set(this); console.log(\"new Set对象\",res) // 但是这里大家可以看到，set返回的是一个对象，但是我们想要的是数组啊。 // 这回，就该轮到Array.from出场了，它的作用，就是可以把类数组对象、可迭代对象转化为数组。 res=Array.from(new Set(this)); return res//es6 数组去重&#125;console.log(users.unique()); 去重 2.已知如下对象，请基于es6的proxy方法设计一个属性拦截读取操作的例子，要求实现去访问目标对象example中不存在的属性时，抛出错误：Property “$(property)” does not exist123456789const man=&#123; name:'jscoder', age:22&#125; //补全代码const proxy = new Proxy(...)proxy.name //\"jscoder\"proxy.age //22proxy.location //Property \"$(property)\" does not exist 考点es6 javascript的Proxy 实例的方法 ,get() get方法用于拦截某个属性的读取操作。 12345678910111213141516var man = &#123; name:'jscoder', age:22&#125;;var proxy = new Proxy(man, &#123; get: function(target, property) &#123; if(property in target) &#123; return target[property]; &#125; else &#123; throw new ReferenceError(`Property $&#123;property&#125; does not exist.`); &#125; &#125;&#125;);console.log(proxy.name)console.log(proxy.age)console.log(proxy.location) Proxy 实例的方法的其他方法参考这个链接，很详细https://blog.csdn.net/qq_30100043/article/details/53443017 3.给出如下虚拟dom的数据结构，如何实现简单的虚拟dom，渲染到目标dom树123456789//样例数据let demoNode = (&#123; tagName: 'ul', props: &#123;'class': 'list'&#125;, children: [ (&#123;tagName: 'li', children: ['douyin']&#125;), (&#123;tagName: 'li', children: ['toutiao']&#125;) ]&#125;); //构建一个render函数，将demoNode对象渲染为以下dom 1234&lt;ul class=\"list\"&gt; &lt;li&gt;douyin&lt;/li&gt; &lt;li&gt;toutiao&lt;/li&gt;&lt;/ul&gt; 看到虚拟DOM，是不是感觉很玄乎，但是剥开它华丽的外衣，也就那样: 通过JavaScript来构建虚拟的DOM树结构，并将其呈现到页面中； 当数据改变，引起DOM树结构发生改变，从而生成一颗新的虚拟DOM树，将其与之前的DOM对比，将变化部分应用到真实的DOM树中，即页面中。通过上面的介绍，下面，我们就来实现一个简单的虚拟DOM，并将其与真实的DOM关联。 构建虚拟DOM 虚拟DOM，其实就是用JavaScript对象来构建DOM树，如上ul组件模版，其树形结构如下： DOM树 通过JavaScript，我们可以很容易构建它，如下： 12345678var elem = Element(&#123; tagName: 'ul', props: &#123;'class': 'list'&#125;, children: [ Element(&#123;tagName: 'li', children: ['item1']&#125;), Element(&#123;tagName: 'li', children: ['item2']&#125;) ]&#125;); note：Element为一个构造函数，返回一个Element对象。为了更清晰的呈现虚拟DOM结构，我们省略了new，而在Element中实现。 1234567891011121314/** @Params:* tagName(string)(requered)* props(object)(optional)* children(array)(optional)* */function Element(&#123;tagName, props, children&#125;)&#123; if(!(this instanceof Element))&#123; return new Element(&#123;tagName, props, children&#125;) &#125; this.tagName = tagName; this.props = props || &#123;&#125;; this.children = children || [];&#125; 好了，通过Element我们可以任意地构建虚拟DOM树了。但是有个问题，虚拟的终归是虚拟的，我们得将其呈现到页面中，不然，没卵用。。 怎么呈现呢？ 从上面得知，这是一颗树嘛，那我们就通过遍历，逐个节点地创建真实DOM节点: \\1. createElement; \\2. createTextNode. 怎么遍历呢？ 因为这是一颗树嘛，对于树形结构无外乎两种遍历： \\1. 深度优先遍历(DFS) 深度优先遍历 \\2. 广度优先遍历(BFS) 广度优先遍历 针对实际情况，我们得采用DFS，为什么呢？ 因为我们得将子节点append到父节点中 好了，那我们采用DFS，就来实现一个render函数吧，如下： 1234567891011121314151617181920Element.prototype.render = function()&#123; var el = document.createElement(this.tagName), props = this.props, propName, propValue; for(propName in props)&#123; propValue = props[propName]; el.setAttribute(propName, propValue); &#125; this.children.forEach(function(child)&#123; var childEl = null; if(child instanceof Element)&#123; childEl = child.render(); &#125;else&#123; childEl = document.createTextNode(child); &#125; el.appendChild(childEl); &#125;); return el;&#125;; 此时，我们就可以轻松地将虚拟DOM呈现到指定真实DOM中啦。假设，我们将上诉ul虚拟DOM呈现到页面body中，如下： 123456789var elem = Element(&#123; tagName: 'ul', props: &#123;'class': 'list'&#125;, children: [ Element(&#123;tagName: 'li', children: ['item1']&#125;), Element(&#123;tagName: 'li', children: ['item2']&#125;) ]&#125;);document.querySelector('body').appendChild(elem.render()); 整个面试持续了41分钟….上来寒暄几句，例行自我介绍 第一部分：JS基础1.JS的数据类型有哪些张口就出，没啥难度2.讲一讲js的作用域？ES6之前函数作用域，ES6之后有了块作用域（let）3.let和var有啥区别？和const有啥区别？和var的比较简单。。。变量声明不提前，不能重复定义，作用域不同等等张口就来，和const的不太了解，只答了个const定义的是不可改变的常量4.ES6之前通过prototype实现继承，聊一聊？巴拉巴拉一大堆5.函数的call和apply有什么区别？和bind又有啥区别？比较简单。。。call和apply区别在于第二个参数，而bind这个和另外两个根本没啥相似的，说一遍他的作用就行了。6.如果一个构造函数，bind了一个对象，用这个构造函数创建出的实例会继承这个对象的属性吗？为什么？不会，bind没有改变原函数，单纯返回一个绑定了目标对象的新函数7.箭头函数和普通函数有啥区别？箭头函数能当构造函数吗？区别主要在于this，能不能当不知道。。。老实交代了8.说一说this在各种情况下可能的取值？这个感觉答得还不错，主要就是全局函数的this是全局对象，但是严格模式下是undefined，平常调用的话this就是调用函数的对象，还有比较特殊的就是apply和call调用的函数，this是主动设置的。另外，forEach函数可以传入第二个参数作为第一个参数的this值。9.http有哪些状态码？分别代表什么意思？这个简单，学过计网的都知道，12345开头的都说一下就行10.用过哪些http请求方法？GET POST OPTION PUT DELETE11.OPTION是干啥的？举个用到OPTION的例子？测试服务器支持的请求类型，例子的话我举的CORS中应对非简单跨域请求时会先发一个OPTION测一测允不允许跨域。12.你知道哪些跨域方法？说说他们的原理？JSONP、CORS。。。本咸鱼就知道这两个，然后讲了讲实现方案13.知道ES6的class吗？了解一些，它是prototype的语法糖，但是不熟悉（干脆利落不给自己挖坑，把战场拉回自己熟悉的领域）14.static关键字了解吗？不了解，但是我知道java中的static，巴拉巴拉讲一堆java的static15.数组和类数组对象有啥区别？二者如何转换？这里我提到了“鸭式辩形”，围绕这个聊二者的区别。转换的话，说实话我是不知道的，然后编了一下应该是可以用循环遍历类数组对象的所有属性，然后挨个push到真正的数组里的。 第二部分 CSS基础1 .说一下你知道的position属性，都有啥特点？张口就来系列2.聊一聊盒模型？开始没弄明白面试官想问啥。。懵了一会。。。后来在面试官的指引下才知道他想让我说盒模型由什么组成。。。width height margin padding border张口就来。。。松了一口气3.两个div上下排列，都设margin，有什么现象？这个简单，就是margin重叠，同正取大正负相加很简单4.为什么会有这种现象？你能解释一下吗恕我直言。。。不能。。。。5.其实这是由块级格式化上下文决定的，你了解吗，能说一下吗？emmm之前看过格式化上下文这块，还专门做过笔记，但是忘了。。。。emmm，勉强说了一些自己还记得的东西6.了解css3中的新东西吗？比如flex、动画这些？flex了解，但是动画只写过一些小demo7.清除浮动有哪些方法？一时想不起来。。就说了个overflow：hidden。太长时间没写过浮动了，都忘了，太菜了。。（面试官可能看出来我css差的离谱了。。。就不聊css了） 第三部分 现场写代码（用自己电脑屏幕分享，面试官会看着你敲的每个字母，挺紧张的）1.实现一个两栏三列的布局，并且要求三列等高，且以内容最多的一列的高度为准。两栏三列比较好实现，双飞翼、圣杯布局这都是基础的东西。然后面试官问，还有没有其他实现方案？提示了一下说用新特性，然后我用flex又写了一个，搞定。高度的问题的话，很快想出了解决方案，okpass。2.判断一个字符串是不是回文的这个也挺简单的。。。不到十行搞定，一次测试通过。然后面试官问有没有其他实现方案，我又巴拉巴拉说了一下，最后问我两个方案哪个好，时间复杂度分别是多少？应该没说错（吧）这里最好注意一下。。面试官让你现场运行测试，如果用js写的话最好是node跑一下就行，如果不会node的话，还得放到浏览器跑就很low。。。 第四部分 智商测试（我自己取的名字）一个圆形的桌子，在上面随意放圆形棋子，谁先没地方放谁输，问有没有必胜策略，有的话应该怎么才能达到必胜？这个真的是我想多了。。。我当时还在考虑各种问题，比如棋子的直径和圆桌半径的关系，甚至极限情况下整个桌子只能放一个棋子呢之类的。。。。后来面试官提示“想想圆有什么特殊的位置”，恍然大悟，只要占据了圆心，其他任何地方你落一个子我都能找到一个关于圆心对称的地方落子。。。哎呀，真是太菜了。面试结束后搜了搜这道题，尼玛还是经典面试题。。。面试之前多看看面经肯定秒答。。。真的是太菜了。 面试经验一：凉的很快，不过面试官人比较好此面试总共花费1天时间，面试形式包括1对1面试，面试的职位是前端开发实习生。 面试过程凉的很快，不过面试官人比较好，一面本来是考基础的，上来就是5到编程题，虽然比较简单，但是我有点头皮发麻。 面试过程中面试官提了哪些问题1、一亿条数据中如何快速的查找1000条最大的数据2、对于promise的了解3、get和post的区别3、http状态码4、tcp和udp的区别5、dns的详细过程 面试经验二：电脑视频面试。一面小语种自我介绍此面试总共花费1天时间，面试形式包括电话面试，面试的职位是内容安全运营。 面试过程电脑视频面试。一面小语种自我介绍，面试官做相关提问。之后看一些小视频判断其中是否有问题，并指出问题。二面看你对该岗位的了解程度和意愿。之后还有三面谈一些待遇问题。 面试过程中面试官提了哪些问题是否了解此岗位。这些视频是否有问题，是否有语言问题（是否存在不文明用语）。是否能实习半年。 面试经验三：先是电话面试了解了一下情况面试的职位是招聘实习生。 面试过程先是电话面试了解了一下情况 是不是应届 了解了未来规划之类的 说明了实习转正所需时间以及要求 没有特别肯定说啥然后就是远程视频面试了 面试过程中面试官提了哪些问题主要是围绕简历挖掘了很多 首先是简单的自我介绍 具体工作的状况 遇到的问题 还有个人性格方面的 优缺点啥的 还有对岗位的了解 面试经验四：主要是个人介绍，从学历到几段工作经验此面试总共花费2天时间，面试形式包括1对1面试，面试的职位是软件产品经理。 面试过程主要是个人介绍，从学历到几段工作经验，详细介绍，由于之前一直是开发，对方对开发经历不是很感兴趣，主要介绍了近一年的工作经历，做了哪些项目之类的 面试过程中面试官提了哪些问题自我介绍，关于项目上的一些问题，详细问了项目都做了些什么，系统的功能之类的，自身有什么优势，关于产品有什么想法。 面试经验五：面试官很nice，很准时、很随和面试形式包括1对1面试，面试的职位是hr。 面试过程面试官很nice，很准时、很随和，问的问题围绕个人的经历，全程气氛很轻松，会回答可以多说，不会也不会为难你的 面试过程中面试官提了哪些问题分享一下你抗压的经验和你解决的方法，进行自我介绍和为什么投递这个岗位，也问了一些专业相关的问题，但是我不太懂所以就水过去了 面试经验六：两轮面试 简单的聊天， 二面偏压力面面试形式包括电话面试、1对1面试，面试的职位是商务合同。 面试过程两轮面试简单的聊天， 二面偏压力面， 基本上是简历上的问题 问的比较详细。用zoom进行面试，部门领导直接面，会问有没有参加秋招 面试过程中面试官提了哪些问题对加班的看法为什么不选择财务我的职业规划有没有参加秋招春招准备参加与否家乡 父母的工作 二面 对函数式编程了解说一下 纯函数，偏应用，柯里化，compose 分别是什么 写一下柯里化 apply，call，bind 的区别 一段代码 setTimeout(function() { console.log(1) }, 0); new Promise(functionexecutor(resolve) { console.log(2); for (var i = 0; i &lt; 10000; i++) { i == 9999&amp;&amp; resolve(); } console.log(3); }).then(function() { console.log(4); }); console.log(5);为什么 3 不打印（这里说错了，应该是打印的），1 最后打印 说一下事件循环 BFC 和 IFC 有了解吗，BFC 特性及条件 盒模型 css 画一个平行四边形，translate 浏览器输入 url 到渲染 缓存 状态码了解哪些，301 和 302 区别 option 方法知道吗 排序算法，事件复杂度，归并，快排，堆排的应用场景 CSRF 原理及防御 ES6 用过哪些 最近收获较大的一篇文章及收获 设计消息通知，比如点赞，评论这些通知二面面试官特别好，不会的地方都会跟你讲一下。最后一题不会说没关系，应届生系统设计和代码实践能力确实差一点，这一题是加分题。然后通知 10 分钟后三面 三面 顺时针打印矩阵https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&amp;tqId=11172&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking（如果没过肯定就是因为这题，面试官都快把答案说出来了我还是没做出来） http 和 https 区别及建立连接的过程 instanceof 原理（代码） 寻找二叉树中路径是否存在某条值等给定值的路径，看我算法比较差就让我说了思路 自己写的爬虫里面的一些细节及如何处理反爬 最有成就感的一件事","categories":[{"name":"前端面试题","slug":"前端面试题","permalink":"https://qw8.github.io/categories/前端面试题/"}],"tags":[{"name":"面试问题","slug":"面试问题","permalink":"https://qw8.github.io/tags/面试问题/"},{"name":"面试经验","slug":"面试经验","permalink":"https://qw8.github.io/tags/面试经验/"},{"name":"字节跳动","slug":"字节跳动","permalink":"https://qw8.github.io/tags/字节跳动/"}]},{"title":"Web安全","slug":"knowledges/Web安全","date":"2019-08-30T10:21:17.000Z","updated":"2024-05-14T06:45:23.839Z","comments":true,"path":"/knowledges/web-an-quan.html","link":"","permalink":"https://qw8.github.io/knowledges/web-an-quan.html","excerpt":"","text":"CSRF 问的不难，一般问： CSRF的基本概念、缩写、全称 攻击原理 防御措施 如果把攻击原理和防御措施掌握好，基本没什么问题。 CSRF的基本概念CSRF（Cross-site request forgery）：跨站请求伪造。 伪造合法请求，让用户在不知情的情况下以登录的身份访问，利用用户信任达到攻击目的。 对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。 CSRF 攻击攻击原理及过程如下 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A； 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A； 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B； 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A； 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 用户是网站A的注册用户，且登录进去，于是网站A就给用户下发cookie。 从上图可以看出，要完成一次CSRF攻击，受害者必须满足两个必要的条件： 登录受信任网站A，并在本地生成Cookie。（如果用户没有登录网站A，那么网站B在诱导的时候，请求网站A的api接口时，会提示你登录） 在不登出A的情况下，访问危险网站B（其实是利用了网站A的漏洞）。 我们在讲CSRF时，一定要把上面的两点说清楚。 温馨提示一下，cookie保证了用户可以处于登录状态，但网站B其实拿不到 cookie。 举个例子，前段时间里，微博网站有个api接口有漏洞，导致很多用户的粉丝暴增。 特点 依靠用户标识危害网站 利用网站对用户标识的信任 欺骗用户的浏览器发送 HTTP 请求给目标站点 另外可以通过 IMG 标签会触发一个 GET 请求，可以利用它来实现 CSRF 攻击。 CSRF如何防御方法一、Token 验证：（用的最多，在请求地址中添加 token 并验证） 服务器发送给客户端一个token； 客户端提交的表单中带着这个token。 如果这个 token 不合法，那么服务器拒绝这个请求。 方法二：隐藏令牌：在 HTTP 头中自定义属性并验证。 把 token 隐藏在 http 的 head头中。 方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别。 方法三、Referer 验证：验证 HTTP Referer 字段 Referer 指的是页面请求来源。意思是，只接受本站的请求，服务器才做响应；如果不是，就拦截。 用户操作验证（验证码），额外验证机制（token使用）等，服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。 通过 referer、token 或者验证码来检测用户提交。 尽量不要在页面的链接中暴露用户隐私信息。 对于用户修改删除等操作最好都使用 post 操作 。 避免全站通用的 cookie，严格设置 cookie 的域。 XSSXSS的基本概念 XSS（Cross Site Scripting）：跨域脚本攻击。 XSS攻击：指的是攻击者往Web页面里插入恶意html标签或者javascript代码。 比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。 XSS 是一种经常出现在 web 应用中的计算机安全漏洞，它允许恶意 web 用户将代码植入到提供给其它用户使用的页面中。 比如这些代码包括 HTML 代码和客户端脚本。攻击者利用 XSS 漏洞旁路掉访问控制——例如同源策略(same origin policy)。 这种类型的漏洞由于被黑客用来编写危害性更大的网络钓鱼(Phishing)攻击而变得广为人知。 对于跨站脚本攻击，黑客界共识是：跨站脚本攻击是新型的“缓冲区溢出攻击“，而 JavaScript 是新型的“ShellCode”。 12示例：&lt;script&gt;alert(document.cookie)&lt;/script&gt; XSS的攻击原理 XSS攻击的核心原理是：不需要你做任何的登录认证，它会通过合法的操作（比如在url中输入、在评论框中输入），向你的页面注入脚本（可能是js、hmtl代码块等）。 HTML是一种超文本标记语言，当动态页面中插入的内容含有这些特殊字符（如&lt;）时，用户浏览器会将其误认为是插入了HTML标签，当这些HTML标签引入了一段JavaScript脚本时，这些脚本程序就将会在用户浏览器中执行。所以，当这些特殊字符不能被动态页面检查或检查出现失误时，就将会产生XSS漏洞。 最后导致的结果可能是： 盗用Cookie 破坏页面的正常结构，插入广告等恶意内容 D-doss攻击 XSS(cross-site scripting)攻击：指的是攻击者往Web页面里插入恶意html标签或者javascript代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点 XSS 是一种经常出现在 web 应用中的计算机安全漏洞，它允许恶意 web 用户将代码植入到提供给其它用户使用的页面中。 比如这些代码包括 HTML 代码和客户端脚本。攻击者利用 XSS 漏洞旁路掉访问控制——例如同源策略(same origin policy)。 这种类型的漏洞由于被黑客用来编写危害性更大的网络钓鱼(Phishing)攻击而变得广为人知。 对于跨站脚本攻击，黑客界共识是：跨站脚本攻击是新型的“缓冲区溢出攻击“，而 JavaScript 是新型的“ShellCode”。 12示例：&lt;script&gt;alert(document.cookie)&lt;/script&gt; XSS的攻击方式 反射型 发出请求时，XSS代码出现在url中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，所以叫反射型XSS。 存储型 存储型XSS和反射型XSS的差别在于，提交的代码会存储在服务器端（数据库、内存、文件系统等），下次请求时目标页面时不用再提交XSS代码。 XSS的防范措施（encode + 过滤）XSS的防范措施主要有三个： 1. 编码： 对用户输入的数据进行HTML Entity编码。 如上图所示，把字符转换成 转义字符。 Encode的作用是将$var等一些字符进行转化，使得浏览器在最终输出结果上是一样的。 比如说这段代码： 1&lt;script&gt;alert(1)&lt;/script&gt; 若不进行任何处理，则浏览器会执行alert的js操作，实现XSS注入。 进行编码处理之后，L在浏览器中的显示结果就是&lt;script&gt;alert(1)&lt;/script&gt;，实现了将``$var作为纯文本进行输出，且不引起JavaScript`的执行。 2、过滤： 移除用户输入的和事件相关的属性。如onerror可以自动触发攻击，还有onclick等。（总而言是，过滤掉一些不安全的内容） 移除用户输入的Style节点、Script节点、Iframe节点。（尤其是Script节点，它可是支持跨域的呀，一定要移除）。 3、校正 避免直接对HTML Entity进行解码。 使用DOM Parse转换，校正不配对的DOM标签。 备注：我们应该去了解一下DOM Parse这个概念，它的作用是把文本解析成DOM结构。 比较常用的做法是，通过第一步的编码转成文本，然后第三步转成DOM对象，然后经过第二步的过滤。 还有一种简洁的答案： 首先是encode，如果是富文本，就白名单。 XSS 防范方法 表单数据规定值的类型，例如：年龄应为只能为 int、name 只能为字母数字组合。代码里对用户输入的地方和变量都需要仔细检查长度和对”&lt;”,”&gt;”,”;”,”’”等字符做过滤； 对数据进行 Html Encode 处理：任何内容写到页面之前都必须加以 encode，避免不小心把 html tag 弄出来。这一个层面做好，至少可以堵住超过一半的 XSS 攻击。 过滤或移除特殊的 Html 标签， 例如: , , &lt; for , &quot for 过滤 JavaScript 事件的标签。例如 \"onclick=\", \"onfocus\" 等等。 避免直接在 cookie 中泄露用户隐私，例如 email、密码等等。 通过使 cookie 和系统 ip 绑定来降低 cookie 泄露后的危险。这样攻击者得到的 cookie 没有实际价值，不可能拿来重放。 如果网站不需要再浏览器端对 cookie 进行操作，可以在 Set-Cookie 末尾加上 HttpOnly 来防止 javascript 代码直接获取 cookie ，这样的话 Javascript 中的 document.cookie 语句就不能获取到 cookie 了。 尽量采用 POST 而非 GET 提交表单 特点 能注入恶意的 HTML/JavaScript 代码到用户浏览的网页上，从而达到 Cookie 资料窃取、会话劫持、钓鱼欺骗等攻击。 攻击代码不一定（非要）在 中&gt; 原因 Web 浏览器本身的设计不安全。浏览器能解析和执行 JS 等代码，但是不会判断该数据和程序代码是否恶意。 输入和输出是 Web 应用程序最基本的交互，而且网站的交互功能越来越丰富。如果在这过程中没有做好安全防护，很容易会出现 XSS 漏洞。 程序员水平参差不齐，而且大都没有过正规的安全培训，没有相关的安全意识。 XSS 攻击手段灵活多变。 危害 盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号 控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力 盗窃企业重要的具有商业价值的资料 非法转账 强制发送电子邮件 网站挂马 控制受害者机器向其它网站发起攻击 参考资料：https://www.cnblogs.com/phpstudy2015-6/p/6767032.htmlhttps://www.cnblogs.com/443855539-wind/p/6055816.htmlhttps://baike.baidu.com/item/XSS%E6%94%BB%E5%87%BB/954065?fr=aladdin ### 其他CSRF 和 XSS 的区别 面试官还可能喜欢问二者的区别。 XSS 利用站点内的信任用户，而 CSRF 则通过伪装来自受信任用户的请求来利用受信任的网站。与 XSS 攻击相比，CSRF 攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比 XSS 更具危险性。 区别一： CSRF：需要用户先登录网站A，获取 cookie XSS：不需要登录。 XSS是获取信息，不需要提前知道其他用户页面的代码和数据包。 CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次CSRF攻击，受害者必须依次完成两个步骤 登录受信任网站 A，并在本地生成 Cookie。 在不登出 A 的情况下，访问危险网站 B。 区别二：（原理的区别） CSRF：是利用网站A本身的漏洞，去请求网站A的api。 XSS：是向网站 A 注入 JS代码，然后执行 JS 里的代码，篡改网站A的内容。 SQL注入原理就是通过把 SQL 命令插入到 Web 表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的 SQL 命令。 总的来说有以下几点： 永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双”-“进行转换等。 永远不要使用动态拼装 SQL，可以使用参数化的 SQL 或者直接使用存储过程进行数据查询存取。 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。 不要把机密信息明文存放，请加密或者 hash 掉密码和敏感的信息。 http2 和 https 的关系 HTTP 协议通常承载于 TCP 协议之上，在 HTTP 和 TCP 之间添加一个安全协议层（SSL 或 TSL），这个时候，就成了我们常说的 HTTPS。 默认 HTTP 的端口号为 80，HTTPS 的端口号为 443。 HTTPS实现原理HTTPS 在通讯过程中的原理，总共分为 8 步STEP 1: 客户端发起 HTTPS 请求STEP 2: 服务端的配置STEP 3: 传送证书STEP 4: 客户端解析证书STEP 5: 传送加密信息STEP 6: 服务端解密信息STEP 7: 传输加密后的信息STEP 8: 客户端解密信息 为什么 HTTPS 安全答案：因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用 HTTPS，密钥在你和终点站才有。https 之所以比 http 安全，是因为他利用 ssl/tls 协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer 传递等。保障了传输过程的安全性 什么是点击劫持？如何防范？最常见的是恶意网站使用 标签把我方的一些含有重要信息类如交易的网页嵌入进去，然后把 iframe 设置透明，用定位的手段的把一些引诱用户在恶意网页上点击。这样用户不知不觉中就进行了某些不安全的操作。 有两种方式可以防范： 1.使用 JS 防范：if (top.location.hostname !== self.location.hostname) {alert(“您正在访问不安全的页面，即将跳转到安全页面！”);top.location.href = self.location.href;} 2.使用 HTTP 头防范：通过配置 nginx 发送 X-Frame-Options 响应头，这样浏览器就会阻止嵌入网页的渲染。更详细的可以查阅 MDN 上关于 X-Frame-Options 响应头的内容。add_header X-Frame-Options SAMEORIGIN; 域名收敛是什么？PC 时代为了突破浏览器的域名并发限制。有了域名发散。浏览器有并发限制，是为了防止DDOS攻击。域名收敛：就是将静态资源放在一个域名下。减少DNS解析的开销。域名发散：是将静态资源放在多个子域名下，就可以多线程下载，提高并行度，使客户端加载静态资源更加迅速。域名发散是pc端为了利用浏览器的多线程并行下载能力。而域名收敛多用与移动端，提高性能，因为dns解析是是从后向前迭代解析，如果域名过多性能会下降，增加DNS的解析开销。 如何防范 Web 前端攻击？ 不要信任任何外部传入的数据 针对用户输入作相关的格式检查、过滤等操作 不要信任在任何传入的第三方数据 使用 CORS，设置 Access-Control-Allow-Origin 更安全地使用 Cookie 设置Cookie为HttpOnly，禁止了JavaScript操作Cookie 防止网页被其他网站内嵌为iframe 服务器端设置 X-Frame-Options 响应头，防止页面被内嵌 什么是 XSS 攻击？如何防范 XSS 攻击？XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。 XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。 XSS 一般分为存储型、反射型和 DOM 型。 存储型指的是恶意代码提交到了网站的数据库中，当用户请求数据的时候，服务器将其拼接为 HTML 后返回给了用户，从而导致了恶意代码的执行。 反射型指的是攻击者构建了特殊的 URL，当服务器接收到请求后，从 URL 中获取数据，拼接到 HTML 后返回，从而导致了恶意代码的执行。 DOM 型指的是攻击者构建了特殊的 URL，用户打开网站后，js 脚本从 URL 中获取数据，从而导致了恶意代码的执行。 XSS 攻击的预防可以从两个方面入手，一个是恶意代码提交的时候，一个是浏览器执行恶意代码的时候。 对于第一个方面，如果我们对存入数据库的数据都进行的转义处理，但是一个数据可能在多个地方使用，有的地方可能不需要转义，由于我们没有办法判断数据最后的使用场景，所以直接在输入端进行恶意代码的处理，其实是不太可靠的。 因此我们可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，我们对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。 还有一些方式，比如使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。 还可以对一些敏感信息进行保护，比如 cookie 使用 http-only ，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。 详细资料可以参考：《前端安全系列（一）：如何防止 XSS 攻击？》 什么是 CSRF 攻击？如何防范 CSRF 攻击？CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。 CSRF 攻击的本质是利用了 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。 一般的 CSRF 攻击类型有三种： 第一种是 GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。 第二种是 POST 类型的 CSRF 攻击，比如说构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。 第三种是链接类型的 CSRF 攻击，比如说在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。 CSRF 可以用下面几种方法来防护： 第一种是同源检测的方法，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止。这种方式的缺点是有些情况下 referer 可以被伪造。还有就是我们这种方法同时把搜索引擎的链接也给屏蔽了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。 第二种方法是使用 CSRF Token 来进行验证，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果我们的请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况我们可以通过改变 token 的构建方式来解决。 第三种方式使用双重 Cookie 验证的办法，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。 第四种方式是使用在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。 详细资料可以参考：《前端安全系列之二：如何防止 CSRF 攻击？》《[ HTTP 趣谈] origin, referer 和 host 区别》 什么是 CSP？CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。 123通常有两种方式来开启 CSP一种是设置 HTTP 首部中的 Content-Security-Policy一种是设置 meta 标签的方式 &lt;metahttp-equiv=&quot;Content-Security-Policy&quot;&gt; 详细资料可以参考：《内容安全策略（CSP）》《前端面试之道》 什么是 Samesite Cookie 属性？Samesite Cookie 表示同站 cookie，避免 cookie 被第三方所利用。 将 Samesite 设为 strict ，这种称为严格模式，表示这个 cookie 在任何情况下都不可能作为第三方 cookie。 将 Samesite 设为 Lax ，这种模式称为宽松模式，如果这个请求是个 GET 请求，并且这个请求改变了当前页面或者打开了新的页面，那么这个 cookie 可以作为第三方 cookie，其余情况下都不能作为第三方 cookie。 使用这种方法的缺点是，因为它不支持子域，所以子域没有办法与主域共享登录信息，每次转入子域的网站，都回重新登录。还有一个问题就是它的兼容性不够好。 什么是点击劫持？如何防范点击劫持？点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。 我们可以在 http 相应头中设置 X-FRAME-OPTIONS 来防御用 iframe 嵌套的点击劫持攻击。通过不同的值，可以规定页面在特定的一些情况才能作为 iframe 来使用。 详细资料可以参考：《web 安全之–点击劫持攻击与防御技术简介》 SQL 注入攻击？SQL 注入攻击指的是攻击者在 HTTP 请求中注入恶意的 SQL 代码，服务器使用参数构建数据库 SQL 命令时，恶意 SQL 被一起构造，破坏原有 SQL 结构，并在数据库中执行，达到编写程序时意料之外结果的攻击行为。 详细资料可以参考：《Web 安全漏洞之 SQL 注入》《如何防范常见的 Web 攻击》 token有限期最佳是多长时间Token 的有效期（或称为“生命周期”）的最佳长度取决于你的具体应用场景和安全需求。以下是一些考虑因素，可以帮助你确定适合你的应用的 Token 有效期： 安全性： 较短的 Token 有效期意味着攻击者有更少的时间来利用被盗的 Token。 如果你的应用涉及敏感数据或高价值交易，建议使用较短的 Token 有效期。 用户体验： 频繁地要求用户重新认证（例如，登录或刷新 Token）可能会降低用户体验。 对于非敏感应用或低频次使用的应用，可以考虑较长的 Token 有效期。 应用场景： 对于一次性使用的 Token（如密码重置链接），有效期应该非常短（几分钟到几小时）。 对于持续会话（如 Web 应用中的用户会话），有效期可以更长（几小时到几天）。 对于 API 访问 Token（用于客户端与服务器之间的通信），有效期可能介于这两者之间，具体取决于 API 的使用频率和安全性要求。 刷新机制： 如果你的应用支持 Token 刷新机制（即，使用刷新 Token 来获取新的访问 Token），你可以将访问 Token 的有效期设置得相对较短，并通过刷新 Token 来延长会话。 刷新 Token 通常具有更长的有效期，但也需要安全地存储和管理。 合规性： 某些行业或地区可能有关于数据保护和身份验证的法规要求。确保你的 Token 有效期符合这些要求。 测试和调整： 根据你的应用的实际使用情况，定期测试和评估 Token 有效期的设置。根据用户反馈和安全事件来调整有效期。 总之，没有一种通用的“最佳” Token 有效期。你需要根据你的具体需求来权衡安全性、用户体验和其他因素，以确定适合你的应用的 Token 有效期。","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"CSRF","slug":"CSRF","permalink":"https://qw8.github.io/tags/CSRF/"},{"name":"XSS","slug":"XSS","permalink":"https://qw8.github.io/tags/XSS/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://qw8.github.io/tags/SQL注入/"},{"name":"HTTPS","slug":"HTTPS","permalink":"https://qw8.github.io/tags/HTTPS/"}]},{"title":"webpack","slug":"knowledges/webpack","date":"2019-08-27T11:21:17.000Z","updated":"2024-01-22T03:35:04.000Z","comments":true,"path":"/knowledges/webpack.html","link":"","permalink":"https://qw8.github.io/knowledges/webpack.html","excerpt":"","text":"谈谈你对 webpack 的看法我当时使用 webpack 的一个最主要原因是为了简化页面依赖的管理，并且通过将其打包为一个文件来降低页面加载时请求的资源数。 我认为 webpack 的主要原理是，它将所有的资源都看成是一个模块，并且把页面逻辑当作一个整体，通过一个给定的入口文件，webpack 从这个文件开始，找到所有的依赖文件，将各个依赖文件模块通过 loader 和 plugins 处理后，然后打包在一起，最后输出一个浏览器可识别的 JS 文件。 Webpack 具有四个核心的概念，分别是 Entry（入口）、Output（输出）、loader 和 Plugins（插件）。 Entry 是 webpack 的入口起点，它指示 webpack 应该从哪个模块开始着手，来作为其构建内部依赖图的开始。 Output 属性告诉 webpack 在哪里输出它所创建的打包文件，也可指定打包文件的名称，默认位置为 ./dist。 loader 可以理解为 webpack 的编译器，它使得 webpack 可以处理一些非 JavaScript 文件。在对 loader 进行配置的时候，test 属性，标志有哪些后缀的文件应该被处理，是一个正则表达式。use 属性，指定 test 类型的文件应该使用哪个 loader 进行预处理。常用的 loader 有 css-loader、style-loader 等。 插件可以用于执行范围更广的任务，包括打包、优化、压缩、搭建服务器等等，要使用一个插件，一般是先使用 npm 包管理器进行安装，然后在配置文件中引入，最后将其实例化后传递给 plugins 数组属性。 使用 webpack 的确能够提供我们对于项目的管理，但是它的缺点就是调试和配置起来太麻烦了。但现在 webpack4.0 的免配置一定程度上解决了这个问题。但是我感觉就是对我来说，就是一个黑盒，很多时候出现了问题，没有办法很好的定位。 详细资料可以参考：《不聊 webpack 配置，来说说它的原理》《前端工程化——构建工具选型：grunt、gulp、webpack》《浅入浅出 webpack》《前端构建工具发展及其比较》 webpack的作用是什么，谈谈你对它的理解？现在的前端网页功能丰富，特别是SPA（single page web application 单页应用）技术流行后，JavaScript的复杂度增加和需要一大堆依赖包，还需要解决Scss，Less……新增样式的扩展写法的编译工作。 所以现代化的前端已经完全依赖于webpack的辅助了。 现在最流行的三个前端框架，可以说和webpack已经紧密相连，框架官方都推出了和自身框架依赖的webpack构建工具。 react.js+WebPack vue.js+WebPack AngluarJS+WebPack webpack的工作原理?WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Sass，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。在3.0出现后，Webpack还肩负起了优化项目的责任。 webpack打包原理把一切都视为模块：不管是 css、JS、Image 还是 html 都可以互相引用，通过定义 entry.js，对所有依赖的文件进行跟踪，将各个模块通过 loader 和 plugins 处理，然后打包在一起。 按需加载：打包过程中 Webpack 通过 Code Splitting 功能将文件分为多个 chunks，还可以将重复的部分单独提取出来作为 commonChunk，从而实现按需加载。把所有依赖打包成一个 bundle.js 文件，通过代码分割成单元片段并按需加载 webpack的核心概念 Entry：入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。告诉webpack要使用哪个模块作为构建项目的起点，默认为./src/index.js output ：出口，告诉webpack在哪里输出它打包好的代码以及如何命名，默认为./dist Module：模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。 Chunk：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。 Loader：模块转换器，用于把模块原内容按照需求转换成新内容。 Plugin：扩展插件，在 Webpack 构建流程中的特定时机会广播出对应的事件，插件可以监听这些事件的发生，在特定时机做对应的事情。 Webpack的基本功能有哪些？ 代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等等 文件优化：压缩 JavaScript、CSS、html 代码，压缩合并图片等 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载 模块合并：在采用模块化的项目有很多模块和文件，需要构建功能把模块分类合并成一个文件 自动刷新：监听本地源代码的变化，自动构建，刷新浏览器 代码校验：在代码被提交到仓库前需要检测代码是否符合规范，以及单元测试是否通过 自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。 gulp/grunt 与 webpack的区别是什么?三者都是前端构建工具，grunt和gulp在早期比较流行，现在webpack相对来说比较主流，不过一些轻量化的任务还是会用gulp来处理，比如单独打包CSS文件等。grunt和gulp是基于任务和流（Task、Stream）的。 类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。webpack是基于入口的。 webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。 webpack是解决什么问题而生的?如果像以前开发时一个html文件可能会引用十几个js文件,而且顺序还不能乱，因为它们存在依赖关系，同时对于ES6+等新的语法，less, sass等CSS预处理都不能很好的解决……，此时就需要一个处理这些问题的工具。 你是如何提高webpack构件速度的?多入口情况下，使用CommonsChunkPlugin来提取公共代码 通过externals配置来提取常用库 利用DllPlugin和DllReferencePlugin预编译资源模块通过DllPlugin来对那些我们 引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来。 使用Happypack 实现多线程加速编译 使用webpack-uglify-paralle来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度使用Tree-shaking和Scope Hoisting来剔除多余代码 npm打包时需要注意哪些？如何利用webpack来更好的构建？Npm是目前最大的 JavaScript 模块仓库，里面有来自全世界开发者上传的可复用模块。 你可能只是JS模块的使用者，但是有些情况你也会去选择上传自己开发的模块。 关于NPM模块上传的方法可以去官网上进行学习，这里只讲解如何利用webpack来构建。 NPM模块需要注意以下问题： 要支持CommonJS模块化规范，所以要求打包后的最后结果也遵守该规则。 Npm模块使用者的环境是不确定的，很有可能并不支持ES6，所以打包的最后结果应该是采用ES5编写的。并且如果ES5是经过转换的，请最好连同SourceMap一同上传。 Npm包大小应该是尽量小（有些仓库会限制包大小） 发布的模块不能将依赖的模块也一同打包，应该让用户选择性的去自行安装。这样可以避免模块应用者再次打包时出现底层模块被重复打包的情况。 UI组件类的模块应该将依赖的其它资源文件，例如.css文件也需要包含在发布的模块里。 前端为什么要进行打包和构建？代码层面： 体积更小（Tree-shaking、压缩、合并），加载更快 编译高级语言和语法（TS、ES6、模块化、scss） 兼容性和错误检查（polyfill,postcss,eslint） 研发流程层面： 统一、高效的开发环境 统一的构建流程和产出标准 集成公司构建规范（提测、上线） webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程： 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数； 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译； 确定入口：根据配置中的 entry 找出所有的入口文件； 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理； 完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系； 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会； 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。 在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。 怎么配置单页应用？怎么配置多页应用？单页应用可以理解为webpack的标准模式，直接在entry中指定单页应用的入口即可，这里不再赘述 多页应用的话，可以使用webpack的 AutoWebPlugin来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。多页应用中要注意的是： 每个页面都有公共的代码，可以将这些代码抽离出来，避免重复的加载。比如，每个页面都引用了同一套css样式表 随着业务的不断扩展，页面可能会不断的追加，所以一定要让入口的配置足够灵活，避免每次添加新页面还需要修改构建配置 Loader机制的作用是什么？webpack默认只能打包js文件，配置里的module.rules数组配置了一组规则，告诉 Webpack 在遇到哪些文件时使用哪些 Loader 去加载和转换打包成js。 注意： use属性的值需要是一个由 Loader 名称组成的数组，Loader 的执行顺序是由后到前的；每一个 Loader 都可以通过 URL querystring 的方式传入参数，例如css-loader?minimize中的minimize告诉css-loader要开启 CSS 压缩。 常用loadercss-loader读取 合并CSS 文件style-loader把 CSS 内容注入到 JavaScript 里sass-loader 解析sass文件（安装sass-loader，node-sass）postcss-loader自动添加浏览器兼容前缀（postcss.config配置）url-loader将文件转换为base64 URI。vue-loader处理vue文件。 Plugin（插件）的作用是什么？Plugin 是用来扩展 Webpack 功能的，通过在构建流程里注入钩子实现，它给 Webpack 带来了很大的灵活性。 Webpack 是通过plugins属性来配置需要使用的插件列表的。plugins属性是一个数组，里面的每一项都是插件的一个实例，在实例化一个组件时可以通过构造函数传入这个组件支持的配置属性。 什么是bundle，什么是chunk，什么是modulebundle：是由webpack打包出来的文件 chunk：是指webpack在进行模块依赖分析的时候，代码分割出来的代码块 module：是开发中的单个模块 常见PluginsHtmlWbpackPlugin自动在打包结束后生成html文件，并引入bundle.jscleanwebPackPlugin打包自动删除上次打包文件 ExtractTextPlugin插件的作用ExtractTextPlugin插件的作用是提取出 JavaScript 代码里的 CSS 到一个单独的文件。 对此你可以通过插件的filename属性，告诉插件输出的 CSS 文件名称是通过[name]_[contenthash:8].css字符串模版生成的，里面的[name]代表文件名称，[contenthash:8]代表根据文件内容算出的8位 hash 值， 还有很多配置选项可以在ExtractTextPlugin的主页上查到。 sourceMap是一个映射关系，将打包后的文件隐射到源代码，用于定位报错位置 配置方式: 例如：devtool：‘source-map’加不同前缀意义： inline:不生成映射关系文件，打包进main.js cheap: 1.只精确到行，不精确到列，打包速度快 2.只管业务代码，不管第三方模块 module：不仅管业务代码，而且管第三方代码 eval:执行效率最快，性能最好 最佳实践：开发环境：cheap-module-eval-source-map线上环境：cheap-mudole-source-map HMR热模块更新借助webpack.HotModuleReplacementPlugin()，devServer开启hot 场景1：实现只刷新css，不影响js场景2：js中实现热更新，只更新指定js模块 1234if (module.hot) &#123; module.hot.accept(’./library.js’, function() &#123; // Do something with the updated library module…&#125;);&#125; webpack如何配置多入口文件?1entry: &#123; home: resolve(__dirname, &quot;src/home/index.js&quot;), about: resolve(__dirname, &quot;src/about/index.js&quot;)&#125; 用于描述入口的对象。你可以使用如下属性： dependOn: 当前入口所依赖的入口。它们必须在该入口被加载前被加载。 filename: 指定要输出的文件名称。 import: 启动时需加载的模块。 library: 指定 library 选项，为当前 entry 构建一个 library。 runtime: 运行时 chunk 的名字。如果设置了，就会创建一个新的运行时 chunk。在 webpack 5.43.0 之后可将其设为 false 以避免一个新的运行时 chunk。 publicPath: 当该入口的输出文件在浏览器中被引用时，为它们指定一个公共 URL 地址 babel 相关: polyfill 以及 runtime 区别， ES stage 含义，preset–env 作用等等 1.polyfill 以及 runtime 区别 babel-polyfill 的原理是当运行环境中并没有实现的一些方法，babel-polyfill会做兼容。 babel-runtime 它是将es6编译成es5去执行。我们使用es6的语法来编写，最终会通过babel-runtime编译成es5.也就是说，不管浏览器是否支持ES6，只要是ES6的语法，它都会进行转码成ES5.所以就有很多冗余的代码。 babel-polyfill 它是通过向全局对象和内置对象的prototype上添加方法来实现的。比如运行环境中不支持Array.prototype.find 方法，引入polyfill, 我们就可以使用es6方法来编写了，但是缺点就是会造成全局空间污染。 babel-runtime: 它不会污染全局对象和内置对象的原型，比如说我们需要Promise，我们只需要import Promise from ‘babel-runtime/core-js/promise’即可，这样不仅避免污染全局对象，而且可以减少不必要的代码。 2.stage-x：指处于某一阶段的js语言提案Stage 0 - 设想（Strawman）：只是一个想法，可能有 Babel插件。Stage 1 - 建议（Proposal）：这是值得跟进的。Stage 2 - 草案（Draft）：初始规范。Stage 3 - 候选（Candidate）：完成规范并在浏览器上初步实现。Stage 4 - 完成（Finished）：将添加到下一个年度版本发布中。 理解 babel-preset-envbabel-preset-es2015: 可以将es6的代码编译成es5.babel-preset-es2016: 可以将es7的代码编译为es6.babel-preset-es2017: 可以将es8的代码编译为es7.babel-preset-latest: 支持现有所有ECMAScript版本的新特性 什么是模热更新？有什么优点？模块热更新是webpack的一个功能，它可以使得代码修改之后，不用刷新浏览器就可以更新。 在应用过程中替换添加删出模块，无需重新加载整个页面，是高级版的自动刷新浏览器。 优点：只更新变更内容，以节省宝贵的开发时间。调整样式更加快速，几乎相当于在浏览器中更改样式 lazy loading（模块懒加载）借助import()语法异步引入组件，实现文件懒加载：prefetch,preloadingwebpack提倡多写异步代码，提升代码利用率，从而提升页面性能先加载主业务文件，prefetch利用网络空闲时间，异步加载组件 1import(/* webpackPrefetch: true / ‘LoginModal’); preload和主业务文件一起加载，异步加载组件 1import(/ webpackPreload: true */ ‘ChartingLibrary’); 什么是长缓存？在webpack中如何做到长缓存优化？浏览器在用户访问页面的时候，为了加快加载速度，会对用户访问的静态资源进行存储，但是每一次代码升级或者更新，都需要浏览器去下载新的代码，最方便和最简单的更新方式就是引入新的文件名称。 在webpack中，可以在output给出输出的文件制定chunkhash，并且分离经常更新的代码和框架代码，通过NameModulesPlugin或者HashedModulesPlugin使再次打包文件名不变。 什么是Tree-sharking?指打包中去除那些引入了但在代码中没用到的死代码。在wepack中js treeshaking通过UglifyJsPlugin来进行，css中通过purify-CSS来进行。 webpack-dev-server 和 http服务器的区别webpack-dev-server使用内存来存储webpack开发环境下的打包文件，并且可以使用模块热更新，比传统的http服务对开发更加有效。 webpack与grunt、gulp的不同？三者都是前端构建工具，grunt和gulp在早期比较流行，现在webpack相对来说比较主流，不过一些轻量化的任务还是会用gulp来处理，比如单独打包CSS文件等。 grunt和gulp是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。 webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。 所以总结一下： 从构建思路来说 gulp和grunt需要开发者将整个前端构建过程拆分成多个Task，并合理控制所有Task的调用关系 webpack需要开发者找到入口，并需要清楚对于不同的资源应该使用什么Loader做何种解析和加工 对于知识背景来说 gulp更像后端开发者的思路，需要对于整个流程了如指掌 webpack更倾向于前端开发者的思路 与webpack类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用webpack？同样是基于入口的打包工具还有以下几个主流的： webpack rollup parcel 从应用场景上来看： webpack适用于大型复杂的前端站点构建 rollup适用于基础库的打包，如vue、react parcel适用于简单的实验性项目，他可以满足低门槛的快速看到效果 由于parcel在打包过程中给出的调试信息十分有限，所以一旦打包出错难以调试，所以不建议复杂的项目使用parcel 有哪些常见的Loader？他们是解决什么问题的？ file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去 source-map-loader：加载额外的 Source Map 文件，以方便断点调试 image-loader：加载并且压缩图片文件 babel-loader：把 ES6 转换成 ES5 css-loader：加载 CSS，支持模块化、压缩、文件导入等特性 style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。 eslint-loader：通过 ESLint 检查 JavaScript 代码 有哪些常见的Plugin？他们是解决什么问题的？ define-plugin：定义环境变量 commons-chunk-plugin：提取公共代码 uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码 Loader和Plugin的不同？ 不同的作用 Loader 直译为”加载器”。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。 Plugin 直译为”插件”。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。 不同的用法 Loader 在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options） Plugin 在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。 webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程： 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数； 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译； 确定入口：根据配置中的 entry 找出所有的入口文件； 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理； 完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系； 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会； 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。 在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。 是否写过Loader和Plugin？描述一下编写loader或plugin的思路？Loader像一个”翻译官”把读到的源文件内容转义成新的文件内容，并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。 编写Loader时要遵循单一原则，每个Loader只做一种”转义”工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。 相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。 webpack的热更新是如何做到的？说明其原理？webpack的热更新又称热替换（Hot Module Replacement），缩写为HMR。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。 原理： img 首先要知道server端和client端都做了处理工作 第一步，在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。 第二步是 webpack-dev-server 和 webpack 之间的接口交互，而在这一步，主要是 dev-server 的中间件 webpack-dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调用 webpack 暴露的 API对代码变化进行监控，并且告诉 webpack，将代码打包到内存中。 第三步是 webpack-dev-server 对文件变化的一个监控，这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了devServer.watchContentBase 为 true 的时候，Server 会监听这些配置文件夹中静态文件的变化，变化后会通知浏览器端对应用进行 live reload。注意，这儿是浏览器刷新，和 HMR 是两个概念。 第四步也是 webpack-dev-server 代码的工作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器端和服务端之间建立一个 websocket 长连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket 消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后面的步骤根据这一 hash 值来进行模块热替换。 webpack-dev-server/client 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了 webpack，webpack/hot/dev-server 的工作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器，也就没有后面那些步骤了。 HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。 而第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。 最后一步，当 HMR 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码。 如何利用webpack来优化前端性能？（提高性能和体验）用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。 压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件， 利用cssnano（css-loader?minimize）来压缩css 利用CDN加速。在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径 删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数–optimize-minimize来实现 提取公共代码。 如何提高webpack的构建速度？ 多入口情况下，使用CommonsChunkPlugin来提取公共代码 通过externals配置来提取常用库 利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来。 使用Happypack 实现多线程加速编译 使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度 使用Tree-shaking和Scope Hoisting来剔除多余代码 怎么配置单页应用？怎么配置多页应用？单页应用可以理解为webpack的标准模式，直接在entry中指定单页应用的入口即可，这里不再赘述 多页应用的话，可以使用webpack的 AutoWebPlugin来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。 多页应用中要注意的是： 每个页面都有公共的代码，可以将这些代码抽离出来，避免重复的加载。比如，每个页面都引用了同一套css样式表 随着业务的不断扩展，页面可能会不断的追加，所以一定要让入口的配置足够灵活，避免每次添加新页面还需要修改构建配置 npm打包时需要注意哪些？如何利用webpack来更好的构建？Npm是目前最大的 JavaScript 模块仓库，里面有来自全世界开发者上传的可复用模块。你可能只是JS模块的使用者，但是有些情况你也会去选择上传自己开发的模块。 关于NPM模块上传的方法可以去官网上进行学习，这里只讲解如何利用webpack来构建。 NPM模块需要注意以下问题： 要支持CommonJS模块化规范，所以要求打包后的最后结果也遵守该规则。 Npm模块使用者的环境是不确定的，很有可能并不支持ES6，所以打包的最后结果应该是采用ES5编写的。并且如果ES5是经过转换的，请最好连同SourceMap一同上传。 Npm包大小应该是尽量小（有些仓库会限制包大小） 发布的模块不能将依赖的模块也一同打包，应该让用户选择性的去自行安装。这样可以避免模块应用者再次打包时出现底层模块被重复打包的情况。 UI组件类的模块应该将依赖的其它资源文件，例如.css文件也需要包含在发布的模块里。 基于以上需要注意的问题，我们可以对于webpack配置做以下扩展和优化： CommonJS模块化规范的解决方案： 设置output.libraryTarget=’commonjs2’使输出的代码符合CommonJS2 模块化规范，以供给其它模块导入使用 输出ES5代码的解决方案：使用babel-loader把 ES6 代码转换成 ES5 的代码。再通过开启devtool: ‘source-map’输出SourceMap以发布调试。 Npm包大小尽量小的解决方案：Babel 在把 ES6 代码转换成 ES5 代码时会注入一些辅助函数，最终导致每个输出的文件中都包含这段辅助函数的代码，造成了代码的冗余。解决方法是修改.babelrc文件，为其加入transform-runtime插件 不能将依赖模块打包到NPM模块中的解决方案：使用externals配置项来告诉webpack哪些模块不需要打包。 对于依赖的资源文件打包的解决方案：通过css-loader和extract-text-webpack-plugin来实现，配置如下： img 如何在vue项目中实现按需加载？Vue UI组件库的按需加载 为了快速开发前端项目，经常会引入现成的UI组件库如ElementUI、iView等，但是他们的体积和他们所提供的功能一样，是很庞大的。 而通常情况下，我们仅仅需要少量的几个组件就足够了，但是我们却将庞大的组件库打包到我们的源码中，造成了不必要的开销。 不过很多组件库已经提供了现成的解决方案，如Element出品的babel-plugin-component和AntDesign出品的babel-plugin-import 安装以上插件后，在.babelrc配置中或babel-loader的参数中进行设置，即可实现组件按需加载了。 img 单页应用的按需加载 现在很多前端项目都是通过单页应用的方式开发的，但是随着业务的不断扩展，会面临一个严峻的问题——首次加载的代码量会越来越多，影响用户的体验。 通过import()语句来控制加载时机，webpack内置了对于import()的解析，会将import()中引入的模块作为一个新的入口在生成一个chunk。 当代码执行到import()语句时，会去加载Chunk对应生成的文件。import()会返回一个Promise对象，所以为了让浏览器支持，需要事先注入Promise polyfill 前端为什么要进行打包和构建？代码层面： 体积更小（Tree-shaking、压缩、合并），加载更快 编译高级语言和语法（TS、ES6、模块化、scss） 兼容性和错误检查（polyfill,postcss,eslint） 研发流程层面： 统一、高效的开发环境 统一的构建流程和产出标准 集成公司构建规范（提测、上线） module chunk bundle区别module - 各个源码文件，webpack中一切皆模块chunk - 多模块合并成的在 entry import() splitChunks 都可以定义chunk: 12345678entry: &#123; index: path.join(srcPath, &apos;index.js&apos;), other: path.join(srcPath, &apos;other.js&apos;)&#125;,import(&apos;./ */djdj.js&apos;).then(res=&gt;&#123; console.log(res.data)&#125;)// splitChunks 代码分割；HtmlWebpackPlugin引用 chunk bundle -最终输出文件loader和plugin的区别loader 模块转换器 （less-&gt;css）plugin 是扩展插件，如HtmlWebpackPlugin 常见的loader和plugin有哪些？Loader: babel-loader：把 ES6 转换成 ES5 css-loader：加载 CSS，支持模块化、压缩、文件导入等特性 style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。 file-loader (png|jpg|jpeg|gif 开发 ‘url-loader’, 生产 vue-loader Plugin: IgnorePlugin 避免引入无用模块 HotModuleReplacementPlugin 热更新 define-plugin：定义环境变量 commons-chunk-plugin：提取公共代码 uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码 babel和webpack的区别babel JS新语法编译工具，只关心语法，不关心模块化webpack -打包构建工具，是多个Loader plugin的集合 webpack如何实现懒加载import() 结合 vue 异步组件 $nexitick 结合vue-router异步加载路由 import 如何产出一个lib12345678output: &#123; // lib的文件名 filename: &apos;lodash.js&apos;, // 输出的lib都放到 dist 目录下 path: distPath, // 存放lib的全局变量名称 library: &apos;lodash&apos;,&#125;, babel-polyfill babel-runtime 区别babel-polyfill 会污染全局babel-runtime 不会污染全局，产出第三方lib时要用babel-runtime 为什么 Proxy 不能被 Polyfill如 Class 可以用 function 模拟如 Promise 可以用 callback 模拟但是 Proxy 功能用 Object.defineProperty 无法模拟 webpack优化构建速度生产环境：babel-loaderIgnorePluginnoParsehappyPackParallelUglifyPlugin 不能用于生产环境：自动刷新热更新DllPlugin webpack优化产出代码小图片base64编码bundle加hash懒加载提取公共代码使用cdn加速IgnorePlugin使用productionScope Hosting(场景、效果、原理) webpack3和webpack4的区别1.1. mode/–mode参数 新增了mode/–mode参数来表示是开发还是生产（development/production） production 侧重于打包后的文件大小，development侧重于goujiansud1.2. 移除loaders，必须使用rules（在3版本的时候loaders和rules 是共存的但是到4的时候只允许使用rules）1.3. 移除了CommonsChunkPlugin (提取公共代码)，用optimization.splitChunks和optimization.runtimeChunk来代替1.4. 支持es6的方式导入JSON文件，并且可以过滤无用的代码 123let jsonData = require('./data.json')import jsonData from './data.json'import &#123; first &#125; from './data.json' // 打包时只会把first相关的打进去 1.5. 升级happypack插件（happypack可以进行多线程加速打包）1.6. ExtractTextWebpackPlugin调整，建议选用新的CSS文件提取kiii插件mini-css-extract-plugin，production模式，增加 minimizer loader 和 plugin 不同2.1. loader是使wenbpack拥有加载和解析非js文件的能力 2.2. plugin 可以扩展webpack的功能，使得webpack更加灵活。可以在构建的过程中通过webpack的api改变输出的结果 webpack构建流程3.1. 初始化参数，从配置文件和shell语句中读到的参数合并，得到最后的参数3.2. 开始编译：用合并得到的参数初始化complier对象，加载是所有配置的插件，执行run方法开始编译3.3. 确定入口，通过entry找到入口文件3.4. 编译模块，从入口文件出发，调用所有配置的loader对模块进行解析翻译，在找到该模块依赖的模块进行处理3.5. 完成模块编译，得到每个模块被翻译之后的最终的内容和依赖关系3.6. 输出资源，根据入口和模块之间的依赖关系，组装成一个个包含多个模块的chunk，在把每个chunk转换成一个单独的文件加载到输出列表3.7. 输出完成，确定输出的路径和文件名，把内容写到文件系统中 在以上过程中，webpack会在特定的时间点广播出特定的事件，插件在舰艇感兴趣的事件后会执行特定的逻辑，改变webpack的运行结果 如何利用webpack来优化前端性能5.1. 压缩代码。uglifyJsPlugin 压缩js代码， mini-css-extract-plugin 压缩css代码5.2. 利用CDN加速，将引用的静态资源修改为CDN上对应的路径，可以利用webpack对于output参数和loader的publicpath参数来修改资源路径5.3. 删除死代码（tree shaking），css需要使用Purify-CSS5.4. 提取公共代码。webpack4移除了CommonsChunkPlugin (提取公共代码)，用optimization.splitChunks和optimization.runtimeChunk来代替 什么是bundle,什么是chunk，什么是module?bundle:有webpack打包出来的文件 chunk：webpack在进行模块的依赖分析的时候，代码分割出来的代码块 module:开发中的单个模块 webpack-dev-server和http服务器如nginx有什么区别?webpack-dev-server使用内存来存储webpack开发环境下的打包文件，并且可以使用模块热更新，他比传统的http服务对开发更加简单高效。 DefinePluginDefinePlugin ：允许创建一个在编译时可以配置的全局变量 DllPlugin使用DllPlugin可以减少基础模块编译次数，动态链接库插件，其原理是吧网页依赖的基础模块抽离出来打包到dll文件中，当需要导入的模块存在于某个dll中时，这个模块不再被打包，而是去dll中获取。在dll中大多包含的时常用的第三方模块，只要这些模块版本不升级，就只需要被编译一次。 注意 DllPlugin参数中的name必须要和output.library值保持一致，并且生成的mainfest文件中会引用output.library值 happyPack开启多线程loader转换运行在node.js之上的webpack时单线程模型，也就是只能一个一个文件进行处理，不能并行处理，happypack可以将任务分解给多个子进程，最后将结果发给主进程，js是单线程模型，只能通过这种多线程的方式提高性能 概念 clipboard.png 从一个空的配置文件逐步完成一个完整的设置进行打包文件 不像大多数的模块打包机，webpack是收把项目当作一个整体，通过一个给定的的主文件，webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包成一个或多个浏览器可识别的js文件 install首先添加我们即将使用的包： 1npm install webpack webpack-dev-server --save-dev webpack是我们需要的模块打包机，webpack-dev-server用来创建本地服务器，监听你的代码修改，并自动刷新修改后的结果。这些是有关devServer的配置 12345678910111213141516contentBase, // 为文件提供本地服务器port, // 监听端口，默认8080inline, // 设置为true,源文件发生改变自动刷新页面historyApiFallback // 依赖HTML5 history API,如果设置为true,所有的页面跳转指向index.htmldevServer:&#123; contentBase: './src' // 本地服务器所加载的页面所在的目录 historyApiFallback: true, // 不跳转 inline: true // 实时刷新&#125;然后我们在根目录下创建一个'webpack.config.js'，在'package.json'添加两个命令用于本地开发和生产发布 \"scripts\": &#123; \"start\": \"webpack-dev-server\", \"build\": \"webpack\" &#125; 在使用webpack命令的时候，他将接受webpack的配置文件，除非我们使用其他的操作 entryentry: 用来写入口文件，它将是整个依赖关系的根 123var baseConfig = &#123; entry: './src/index.js' &#125; 当我们需要多个入口文件的时候，可以把entry写成一个对象 12345var baseConfig = &#123; entry: &#123; main: './src/index.js' &#125; &#125; 我建议使用后面一种方法，因为他的规模会随你的项目增大而变得繁琐 outputoutput: 即使入口文件有多个，但是只有一个输出配置 1234567891011var path = require('path') var baseConfig = &#123; entry: &#123; main: './src/index.js' &#125;, output: &#123; filename: 'main.js', path: path.resolve('./build') &#125; &#125; module.exports = baseConfig 如果你定义的入口文件有多个，那么我们需要使用占位符来确保输出文件的唯一性 1234output: &#123; filename: '[name].js', path: path.resolve('./build') &#125; 如今这么少的配置，就能够让你运行一个服务器并在本地使用命令npm start或者npm run build来打包我们的代码进行发布 Loader loader的作用 ：1、实现对不同格式的文件的处理，比如说将scss转换为css，或者typescript转化为js2、转换这些文件，从而使其能够被添加到依赖图中loader是webpack最重要的部分之一，通过使用不同的Loader，我们能够调用外部的脚本或者工具，实现对不同格式文件的处理，loader需要在webpack.config.js里边单独用module进行配置，配置如下： 12345678910111213141516171819test: 匹配所处理文件的扩展名的正则表达式（必须） loader: loader的名称（必须） include/exclude: 手动添加处理的文件，屏蔽不需要处理的文件（可选） query: 为loaders提供额外的设置选项 ex: var baseConfig = &#123; // ... module: &#123; rules: [ &#123; test: /*匹配文件后缀名的正则*/, use: [ loader: /*loader名字*/, query: /*额外配置*/ ] &#125; ] &#125; &#125; 要是loader工作，我们需要一个正则表达式来标识我们要修改的文件，然后有一个数组表示我们表示我们即将使用的Loader,当然我们需要的loader需要通过npm 进行安装。例如我们需要解析less的文件，那么webpack.config.js的配置如下： 123456789101112131415161718192021222324252627var baseConfig = &#123; entry: &#123; main: './src/index.js' &#125;, output: &#123; filename: '[name].js', path: path.resolve('./build') &#125;, devServer: &#123; contentBase: './src', historyApiFallBack: true, inline: true &#125;, module: &#123; rules: [ &#123; test: /\\.less$/, use: [ &#123;loader: 'style-loader'&#125;, &#123;loader: 'css-loader'&#125;, &#123;loader: 'less-loader'&#125; ], exclude: /node_modules/ &#125; ] &#125; &#125; 这里介绍几个常用的loader：babel-loader： 让下一代的js文件转换成现代浏览器能够支持的JS文件。babel有些复杂，所以大多数都会新建一个.babelrc进行配置css-loader,style-loader:两个建议配合使用，用来解析css文件，能够解释@import,url()如果需要解析less就在后面加一个less-loaderfile-loader: 生成的文件名就是文件内容的MD5哈希值并会保留所引用资源的原始扩展名url-loader: 功能类似 file-loader,但是文件大小低于指定的限制时，可以返回一个DataURL事实上，在使用less,scss,stylus这些的时候，npm会提示你差什么插件，差什么，你就安上就行了 Pluginsplugins和loader很容易搞混，说都是外部引用有什么区别呢？ 事实上他们是两个完全不同的东西。这么说 loaders负责的是处理源文件的如css、jsx，一次处理一个文件。而plugins并不是直接操作单个文件， 它直接对整个构建过程起作用下面列举了一些我们常用的plugins和他的用法ExtractTextWebpackPlugin: 它会将入口中引用css文件，都打包都独立的css文件中，而不是内嵌在js打包文件中。下面是他的应用 1234567891011121314151617181920var ExtractTextPlugin = require('extract-text-webpack-plugin') var lessRules = &#123; use: [ &#123;loader: 'css-loader'&#125;, &#123;loader: 'less-loader'&#125; ] &#125; var baseConfig = &#123; // ... module: &#123; rules: [ // ... &#123;test: /\\.less$/, use: ExtractTextPlugin.extract(lessRules)&#125; ] &#125;, plugins: [ new ExtractTextPlugin('main.css') ] &#125; HtmlWebpackPlugin:作用： 依据一个简单的index.html模版，生成一个自动引用你打包后的js文件的新index.html 1234567var HTMLWebpackPlugin = require('html-webpack-plugin') var baseConfig = &#123; // ... plugins: [ new HTMLWebpackPlugin() ] &#125; HotModuleReplacementPlugin: 它允许你在修改组件代码时，自动刷新实时预览修改后的结果注意永远不要在生产环境中使用HMR。这儿说一下一般情况分为开发环境，测试环境，生产环境。用法如 new webpack.HotModuleReplacementPlugin() 1234567891011121314151617181920212223242526272829303132333435 webapck.config.js的全部内容 const webpack = require(\"webpack\") const HtmlWebpackPlugin = require(\"html-webpack-plugin\") var ExtractTextPlugin = require('extract-text-webpack-plugin') var lessRules = &#123; use: [ &#123;loader: 'css-loader'&#125;, &#123;loader: 'less-loader'&#125; ] &#125; module.exports = &#123; entry: &#123; main: './src/index.js' &#125;, output: &#123; filename: '[name].js', path: path.resolve('./build') &#125;, devServer: &#123; contentBase: '/src', historyApiFallback: true, inline: true, hot: true &#125;, module: &#123; rules: [ &#123;test: /\\.less$/, use: ExtractTextPlugin.extract(lessRules)&#125; ] &#125;, plugins: [ new ExtractTextPlugin('main.css') ] &#125; 产品阶段的构建目前为止，在开发阶段的东西我们已经基本完成了。但是在产品阶段，还需要对资源进行别的处理，例如压缩，优化，缓存，分离css和js。首先我们来定义产品环境 123456789var ENV = process.env.NODE_ENV var baseConfig = &#123; // ... plugins: [ new webpack.DefinePlugin(&#123; 'process.env.NODE_ENV': JSON.stringify(ENV) &#125;) ] &#125; 然后还需要修改我们的script命令 1234\"scripts\": &#123; \"start\": \"NODE_ENV=development webpack-dev-server\", \"build\": \"NODE_ENV=production webpack\" &#125; process.env.NODE_ENV 将被一个字符串替代，它运行压缩器排除那些不可到达的开发代码分支。当你引入那些不会进行生产的代码，下面这个代码将非常有用。 123if (process.env.NODE_ENV === 'development') &#123; console.warn('这个警告会在生产阶段消失') &#125; 优化插件下面介绍几个插件用来优化代码OccurenceOrderPlugin: 为组件分配ID,通过这个插件webpack可以分析和优先考虑使用最多 的模块，然后为他们分配最小的IDUglifyJsPlugin: 压缩代码下面是他们的使用方法var baseConfig = { 123// ... new webpack.optimize.OccurenceOrderPlugin() new webpack.optimize.UglifyJsPlugin() }然后在我们使用npm run build会发现代码是压缩的 webpack打包复制文件插件copy-webpack-plugin在离线应用中，前端所有文件都需在在本地，有些文件（比如iconFont)需要转为离线文件，这些文件可以直接引用更方便些，这就需要在打包时直接复制到打包文件下。 前端的文件复制让人直接联想到node的fs，可以在打包时调用文件复制方法，当然webpack提供一款插件来解决这一问题：copy-webpack-plugin 安装： 123cnpm i copy-webpack-plugin -D /* 或 */npm i copy-webpack-plugin --save-dev 使用： 12345678910111213141516const CopyPlugin = require(&quot;copy-webpack-plugin&quot;);module.exports = &#123; plugins: [ new CopyPlugin(&#123; patterns: [ &#123; from: &quot;source&quot;, to: &quot;dest&quot; &#125;, // 例如 &#123; from: path.resolve(__dirname, &apos;../static&apos;), to: &apos;static&apos; &#125;, ], options: &#123; concurrency: 100, &#125;, &#125;), ],&#125;;","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"https://qw8.github.io/categories/前端知识点/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://qw8.github.io/tags/webpack/"}]},{"title":"秦伟博客","slug":"other/秦伟博客","date":"2019-08-25T10:00:00.000Z","updated":"2024-06-05T02:19:23.389Z","comments":true,"path":"/other/qin-wei-bo-ke.html","link":"","permalink":"https://qw8.github.io/other/qin-wei-bo-ke.html","excerpt":"博客介绍Welcome to QinWei‘s blog! 本博客有以下5个分类： 前端知识点 前端面试题 前端问题 链接 其他 This is my first post.If you have any problems in using this website , you can contact me by QQ： 124729081 or Wechat：qwqw75.","text":"博客介绍Welcome to QinWei‘s blog! 本博客有以下5个分类： 前端知识点 前端面试题 前端问题 链接 其他 This is my first post.If you have any problems in using this website , you can contact me by QQ： 124729081 or Wechat：qwqw75. This website is built usingHexo, and here are some brief introduction. 文件夹目录 node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章 themes：主题 _config.yml: 博客的配置文件 博客运行部署Create a new post（新建日志）1$ hexo new \"My New Post\" More info: Writing Run server（运行服务）1$ hexo server 使用ctrl+c可以把服务关掉。 More info: Server Generate static files（生成静态文件）1$ hexo generate More info: Generating Deploy to remote sites（部署到远程站点）1$ hexo deploy More info: Deployment 博客问题更改样式后网站没有生效确认非缓存问题后，执行 hexo clean 再进行生成上传。 清理之前在public文件夹中生成的文件 hexo d生成HTML文件报错错误代码：FATAL Something’s wrong. Maybe you can find the solution here: http://hexo.io/do cs/troubleshooting.html Template render error: (unknown path) [Line 1, Column 12] unexpected token: }} 问题原因：看到其中有一句Template render error，模板渲染错误 看到渲染错误，我的md文档中不就有渲染的语法嘛，双大括号就是做渲染的语法，可能有冲突吧，有文章说有代码块包含就可以，那么我试试 12// 有包含&#123;&#123;&#125;&#125; 果然，hexo g试验了一下，果然是没有报错的，而我没有使用代码块包含双大括号的时候，就会报上面的错误代码 如何在文章中使用图标先到 fontawesome 找到你需要的图标名，比如：book，按以下格式使用： 1&lt;i class=&quot;icon icon-book&quot;&gt;&lt;/i&gt; 图标样式前缀均为 icon，此外还有 5 个图标大小调节类和 1 个间距类。 1234567891011121314&lt;!-- 1.3倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-lg&quot;&gt;&lt;/i&gt;&lt;!-- 2倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-2x&quot;&gt;&lt;/i&gt;&lt;!-- 3倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-3x&quot;&gt;&lt;/i&gt;&lt;!-- 4倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-4x&quot;&gt;&lt;/i&gt;&lt;!-- 5倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-5x&quot;&gt;&lt;/i&gt;&lt;!-- 5px右边距 --&gt;&lt;i class=&quot;icon icon-book icon-pr&quot;&gt;&lt;/i&gt;&lt;!-- 5px左边距 --&gt;&lt;i class=&quot;icon icon-book icon-pl&quot;&gt;&lt;/i&gt; 个别图标无法显示如果你的浏览器安装了 ADBlock，它会屏蔽 SNS 相关的内容，比如：Github。 解决办法：可配置 ADBlock 不在你的站点运行。 本地ssh目录1C:\\Users\\tuitui\\.ssh 主题添加字数统计和阅读时长功能1.安装 hexo-wordcount在博客目录下打开Git Bash Here 输入命令 npm i –save hexo-wordcount 2.文件配置1234// 单篇文章字数&lt;span class=&quot;post-count&quot;&gt;&lt;%= wordcount(post.content) %&gt;字&lt;/span&gt;&lt;span class=&quot;post-count&quot;&gt;&lt;%= min2read(post.content) %&gt;分&lt;/span&gt;&lt;span&gt;本网站总字数：&lt;%= totalcount(site) %&gt;&lt;/span&gt; 在theme\\yilia\\layout\\_partial\\post下创建word.ejs文件： 123456789101112131415161718&lt;div style=\"margin-top:10px;\"&gt; &lt;span class=\"post-time\"&gt; &lt;span class=\"post-meta-item-icon\"&gt; &lt;i class=\"fa fa-keyboard-o\"&gt;&lt;/i&gt; &lt;span class=\"post-meta-item-text\"&gt; 字数统计: &lt;/span&gt; &lt;span class=\"post-count\"&gt;&lt;%= wordcount(post.content) %&gt;字&lt;/span&gt; &lt;/span&gt; &lt;/span&gt; &lt;span class=\"post-time\"&gt; &amp;nbsp; | &amp;nbsp; &lt;span class=\"post-meta-item-icon\"&gt; &lt;i class=\"fa fa-hourglass-half\"&gt;&lt;/i&gt; &lt;span class=\"post-meta-item-text\"&gt; 阅读时长: &lt;/span&gt; &lt;span class=\"post-count\"&gt;&lt;%= min2read(post.content) %&gt;分&lt;/span&gt; &lt;/span&gt; &lt;/span&gt;&lt;/div&gt; 然后在 themes/yilia/layout/_partial/article.ejs中添加 123456789101112131415&lt;div class=\"article-inner\"&gt; &lt;% if (post.link || post.title)&#123; %&gt; &lt;header class=\"article-header\"&gt; &lt;%- partial('post/title', &#123;class_name: 'article-title'&#125;) %&gt; &lt;% if (!post.noDate)&#123; %&gt; &lt;%- partial('post/date', &#123;class_name: 'archive-article-date', date_format: null&#125;) %&gt; &lt;!-- 需要添加的位置 --&gt; &lt;!-- 开始添加字数统计--&gt; &lt;% if(theme.word_count &amp;&amp; !post.no_word_count)&#123;%&gt; &lt;%- partial('post/word') %&gt; &lt;% &#125; %&gt; &lt;!-- 添加完成 --&gt; &lt;% &#125; %&gt; &lt;/header&gt; 3. 开启功能在站点的_config.yml中添加下面代码 123# 是否开启字数统计#不需要使用，直接设置值为false，或注释掉word_count: true 中文链接转拼音如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 SEO，且 gitment 评论对中文链接也不支持。我们可以用 hexo-permalink-pinyin Hexo 插件使在生成文章时生成中文拼音的永久链接。 这里为可选安装，因为我希望使用urlname进行连接访问，中文链接转拼音由一个缺点就是当文章名字过长会显示十分臃肿。urlname的方式见下文。 安装命令如下： 1npm i hexo-permalink-pinyin --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 123permalink_pinyin: enable: true separator: '-' # default: '-' 复制 注：除了此插件外，hexo-abbrlink 插件也可以生成非中文的链接。 网站收录为了使博客能被谷歌、bing、百度收录，最好生成 sitemap 方便爬取 1npm install hexo-generator-sitemap --save _config.yml配置 12345678# hexo-generator-sitemap为了使博客能被谷歌、bing、百度收录，最好生成 sitemap 方便爬取# https://github.com/hexojs/hexo-generator-sitemapsitemap: path: sitemap.xml # template: ./sitemap_template.xml rel: true tags: false categories: false 安装Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 1$ npm install -g hexo-cli 进阶安装和使用对于熟悉 npm 的进阶用户，可以仅局部安装 hexo 包。 1$ npm install hexo 安装以后，可以使用以下两种方式执行 Hexo： npx hexo Linux 用户可以将 Hexo 所在的目录下的 node_modules 添加到环境变量之中即可直接使用 hexo： 1echo &apos;PATH=&quot;$PATH:./node_modules/.bin&quot;&apos; &gt;&gt; ~/.profile Node.js版本限制如果你坚持使用旧的 Node.js，你可以考虑安装 Hexo 的过去版本。 请注意，我们不提供对过去版本 Hexo 的错误修复。 我们强烈建议永远安装 最新版本 的 Hexo，以及 推荐的 Node.js 版本。 Hexo 版本 最低版本 (Node.js 版本) 最高版本 (Node.js 版本) 7.0+ 14.0.0 latest 6.2+ 12.13.0 latest 6.0+ 12.13.0 18.5.0 5.0+ 10.13.0 12.0.0 4.1 - 4.2 8.10 10.0.0 4.0 8.6 8.10.0 3.3 - 3.9 6.9 8.0.0 3.2 - 3.3 0.12 未知 3.0 - 3.1 0.10 或 iojs 未知 0.0.1 - 2.8 0.10 未知 建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml网站的 配置 信息，您可以在此配置大部分的参数。 package.json应用程序的信息。EJS, Stylus 和 Markdown 渲染引擎 已默认安装，您可以自由移除。 1234567891011121314151617181920&#123; &quot;name&quot;: &quot;hexo-site&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;hexo&quot;: &#123; &quot;version&quot;: &quot;&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;hexo&quot;: &quot;^7.0.0&quot;, &quot;hexo-generator-archive&quot;: &quot;^2.0.0&quot;, &quot;hexo-generator-category&quot;: &quot;^2.0.0&quot;, &quot;hexo-generator-index&quot;: &quot;^3.0.0&quot;, &quot;hexo-generator-tag&quot;: &quot;^2.0.0&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^2.0.0&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^3.0.0&quot;, &quot;hexo-renderer-marked&quot;: &quot;^6.0.0&quot;, &quot;hexo-server&quot;: &quot;^3.0.0&quot;, &quot;hexo-theme-landscape&quot;: &quot;^1.0.0&quot; &#125;&#125; scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来创建文件。 Hexo 的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改 scaffold/post.md 中的 Front-matter 内容，那么每次新建一篇文章时都会包含这个修改。 source资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题 文件夹。Hexo 会根据主题来生成静态页面。 配置您可以在 _config.yml 或 代替配置文件 中修改大部分的配置。 网站 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 keywords 网站的关键词。支持多个关键词。 author 您的名字 language 网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 zh-Hans和 zh-CN。 timezone 网站时区。Hexo 默认使用您电脑的时区。请参考 时区列表 进行设置，如 America/New_York, Japan, 和 UTC 。一般的，对于中国大陆地区可以使用 Asia/Shanghai。 其中，description 主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author 参数用于主题显示文章的作者。 网址 参数 描述 默认值 url 网址, 必须以 http:// 或 https:// 开头 root 网站根目录 url&#39;s pathname permalink 文章的 永久链接 格式 :year/:month/:day/:title/ permalink_defaults 永久链接中各部分的默认值 pretty_urls 改写 permalink 的值来美化 URL pretty_urls.trailing_index 是否在永久链接中保留尾部的 index.html，设置为 false 时去除 true pretty_urls.trailing_html 是否在永久链接中保留尾部的 .html, 设置为 false 时去除 (对尾部的 index.html无效) true 网站存放在子目录 如果您的网站存放在子目录中，例如 http://example.com/blog，则请将您的 url 设为 http://example.com/blog 并把 root 设为 /blog/。 例如： 1234# 比如，一个页面的永久链接是 http://example.com/foo/bar/index.htmlpretty_urls: trailing_index: false# 此时页面的永久链接会变为 http://example.com/foo/bar/ 目录 参数 描述 默认值 source_dir 资源文件夹，这个文件夹用来存放内容。 source public_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 public tag_dir 标签文件夹 tags archive_dir 归档文件夹 archives category_dir 分类文件夹 categories code_dir Include code 文件夹，source_dir 下的子目录 downloads/code i18n_dir 国际化（i18n）文件夹 :lang skip_render 跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 public 目录中。您可使用 glob 表达式来匹配路径。 例如： 12345skip_render: &quot;mypage/**/*&quot;# 将会直接将 `source/mypage/index.html` 和 `source/mypage/code.js` 不做改动地输出到 &apos;public&apos; 目录# 你也可以用这种方法来跳过对指定文章文件的渲染skip_render: &quot;_posts/test-post.md&quot;# 这将会忽略对 &apos;test-post.md&apos; 的渲染 提示 如果您刚刚开始接触 Hexo，通常没有必要修改这一部分的值。 文章 参数 描述 默认值 new_post_name 新文章的文件名称 :title.md default_layout 预设布局 post auto_spacing 在中文和英文之间加入空格 false titlecase 把标题转换为 title case false external_link 在新标签中打开链接 true external_link.enable 在新标签中打开链接 true external_link.field 对整个网站（site）生效或仅对文章（post）生效 site external_link.exclude 需要排除的域名。主域名和子域名如 www 需分别配置 [] filename_case 把文件名称转换为 (1) 小写或 (2) 大写 0 render_drafts 显示草稿 false post_asset_folder 启用 资源文件夹 false relative_link 把链接改为与根目录的相对位址 false future 显示未来的文章 true syntax_highlighter 代码块的设置, 请参考 代码高亮 进行设置 highlight.js highlight 代码块的设置, 请参考 Highlight.js 进行设置 prismjs 代码块的设置, 请参考 PrismJS 进行设置 相对地址 默认情况下，Hexo 生成的超链接都是绝对地址。例如，如果您的网站域名为 example.com，您有一篇文章名为 hello，那么绝对链接可能像这样：http://example.com/hello.html，它是绝对于域名的。相对链接像这样：/hello.html，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。 分类 &amp; 标签 参数 描述 默认值 default_category 默认分类 uncategorized category_map 分类别名 tag_map 标签别名 日期 / 时间格式Hexo 使用 Moment.js 来解析和显示时间。 参数 描述 默认值 date_format 日期格式 YYYY-MM-DD time_format 时间格式 HH:mm:ss updated_option 当 Front Matter 中没有指定 updated 时 updated 的取值 mtime updated_option updated_option 控制了当 Front Matter 中没有指定 updated 时，updated 如何取值： mtime: 使用文件的最后修改时间。这是从 Hexo 3.0.0 开始的默认行为。 date: 使用 date 作为 updated 的值。可被用于 Git 工作流之中，因为使用 Git 管理站点时，文件的最后修改日期常常会发生改变 empty: 直接删除 updated。使用这一选项可能会导致大部分主题和插件无法正常工作。 use_date_for_updated 选项已经在 v7.0.0+ 中被移除。请改为使用 updated_option: &#39;date&#39;。 分页 参数 描述 默认值 per_page 每页显示的文章量 (0 = 关闭分页功能) 10 pagination_dir 分页目录 page 例如： 12345pagination_dir: &apos;page&apos;# http://example.com/page/2pagination_dir: &apos;awesome-page&apos;# http://example.com/awesome-page/2 扩展 参数 描述 theme 当前主题名称。值为false时禁用主题 theme_config 主题的配置文件。在这里放置的配置会覆盖主题目录下的 _config.yml 中的配置 deploy 部署部分的设置 meta_generator Meta generator 标签。 值为 false 时 Hexo 不会在头部插入该标签 包括或不包括目录和文件在 Hexo 配置文件中，通过设置 include/exclude 可以让 Hexo 进行处理或忽略某些目录和文件夹。你可以使用 glob 表达式 对目录和文件进行匹配。 include 和 exclude 选项只会应用到 source/ ，而 ignore 选项会应用到所有文件夹. 参数 描述 include Hexo 默认会不包括 source/ 下的文件和文件夹（包括名称以下划线和 . 开头的文件和文件夹，Hexo 的 _posts 和 _data 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 source 目录下。 exclude Hexo 不包括 source/ 下的这些文件和目录 ignore Hexo 会忽略整个 Hexo 项目下的这些文件夹或文件 例如： 12345678910111213141516171819202122232425262728293031# 处理或不处理目录或文件include: - &quot;.nojekyll&quot; # 处理 &apos;source/css/_typing.css&apos; - &quot;css/_typing.css&quot; # 处理 &apos;source/_css/&apos; 中的任何文件，但不包括子目录及其其中的文件。 - &quot;_css/*&quot; # 处理 &apos;source/_css/&apos; 中的任何文件和子目录下的任何文件 - &quot;_css/**/*&quot;exclude: # 不处理 &apos;source/js/test.js&apos; - &quot;js/test.js&quot; # 不处理 &apos;source/js/&apos; 中的文件、但包括子目录下的所有目录和文件 - &quot;js/*&quot; # 不处理 &apos;source/js/&apos; 中的文件和子目录下的任何文件 - &quot;js/**/*&quot; # 不处理 &apos;source/js/&apos; 目录下的所有文件名以 &apos;test&apos; 开头的文件，但包括其它文件和子目录下的单文件 - &quot;js/test*&quot; # 不处理 &apos;source/js/&apos; 及其子目录中任何以 &apos;test&apos; 开头的文件 - &quot;js/**/test*&quot; # 不要用 exclude 来忽略 &apos;source/_posts/&apos; 中的文件。你应该使用 &apos;skip_render&apos;，或者在要忽略的文件的文件名之前加一个下划线 &apos;_&apos; # 在这里配置一个 - &quot;_posts/hello-world.md&quot; 是没有用的。ignore: # 忽略任何一个名叫 &apos;foo&apos; 的文件夹 - &quot;**/foo&quot; # 只忽略 &apos;themes/&apos; 下的 &apos;foo&apos; 文件夹 - &quot;**/themes/*/foo&quot; # 对 &apos;themes/&apos; 目录下的每个文件夹中忽略名叫 &apos;foo&apos; 的子文件夹 - &quot;**/themes/**/foo&quot; 列表中的每一项都必须用单引号或双引号包裹起来。 include 和 exclude 并不适用于 themes/ 目录下的文件。如果需要忽略 themes/ 目录下的部分文件或文件夹，可以使用 ignore 或在文件名之前添加下划线 _。 source/_posts 文件夹是一个例外，但该文件夹下任何名称以 _ 开头的文件或文件夹仍会被忽略。不建议在该文件夹中使用 include 规则。 使用代替配置文件可以在 hexo-cli 中使用 --config 参数来指定自定义配置文件的路径。你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如： 12345# 用 &apos;custom.yml&apos; 代替 &apos;_config.yml&apos;$ hexo server --config custom.yml# 使用 &apos;custom.yml&apos; 和 &apos;custom2.json&apos;，优先使用 &apos;custom3.yml&apos;，然后是 &apos;custom2.json&apos;$ hexo generate --config custom.yml,custom2.json,custom3.yml 当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 _multiconfig.yml。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。 例如，使用 --config 指定了两个自定义配置文件： 1$ hexo generate --config custom.yml,custom2.json 如果 custom.yml 中指定了 foo: bar，在 custom2.json 中指定了 &quot;foo&quot;: &quot;dinosaur&quot;，那么在 _multiconfig.yml 中你会得到 foo: dinosaur。 使用代替主题配置文件通常情况下，Hexo 主题是一个独立的项目，并拥有一个独立的 _config.yml 配置文件。 除了自行维护独立的主题配置文件，你也可以在其它地方对主题进行配置。 配置文件中的 theme_config 该特性自 Hexo 2.8.2 起提供 123456# _config.ymltheme: &quot;my-theme&quot;theme_config: bio: &quot;My awesome bio&quot; foo: bar: &apos;a&apos; 12345# themes/my-theme/_config.ymlbio: &quot;Some generic bio&quot;logo: &quot;a-cool-image.png&quot; foo: baz: &apos;b&apos; 最终主题配置的输出是： 12345678&#123; bio: &quot;My awesome bio&quot;, logo: &quot;a-cool-image.png&quot;, foo: &#123; bar: &quot;a&quot;, baz: &quot;b&quot; &#125;&#125; 独立的 _config.[theme].yml 文件 该特性自 Hexo 5.0.0 起提供 独立的主题配置文件应放置于站点根目录下，支持 yml 或 json 格式。需要配置站点 _config.yml 文件中的 theme 以供 Hexo 寻找 _config.[theme].yml 文件。 12# _config.ymltheme: &quot;my-theme&quot; 1234# _config.my-theme.ymlbio: &quot;My awesome bio&quot;foo: bar: &apos;a&apos; 12345# themes/my-theme/_config.ymlbio: &quot;Some generic bio&quot;logo: &quot;a-cool-image.png&quot; foo: baz: &apos;b&apos; 最终主题配置的输出是： 12345678&#123; bio: &quot;My awesome bio&quot;, logo: &quot;a-cool-image.png&quot;, foo: &#123; bar: &quot;a&quot;, baz: &quot;b&quot; &#125;&#125; 我们强烈建议你将所有的主题配置集中在一处。如果你不得不在多处配置你的主题，那么这些信息对你将会非常有用：Hexo 在合并主题配置时，Hexo 配置文件中的 theme_config 的优先级最高，其次是 _config.[theme].yml 文件，最后是位于主题目录下的 _config.yml 文件。 指令init1$ hexo init [folder] 新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。 本命令相当于执行了以下几步： Git clone hexo-starter 和 hexo-theme-landscape 主题到当前目录或指定目录。 使用 Yarn 1、pnpm 或 npm 包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 Node.js 安装。 new1$ hexo new [layout] &lt;title&gt; 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 1$ hexo new &quot;post title with whitespace&quot; 参数 描述 -p, --path 自定义新文章的路径 -r, --replace 如果存在同名文章，将其替换 -s, --slug 文章的 Slug，作为新文章的文件名和发布后的 URL 默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 index.md 文件。你可以使用 --path 参数来覆盖上述行为、自行决定文件的目录： 1hexo new page --path about/me &quot;About me&quot; 以上命令会创建一个 source/about/me.md 文件，同时 Front Matter 中的 title 为 &quot;About me&quot; 注意！title 是必须指定的！如果你这么做并不能达到你的目的： 1hexo new page --path about/me 此时 Hexo 会创建 source/_posts/about/me.md，同时 me.md 的 Front Matter 中的 title 为 &quot;page&quot;。这是因为在上述命令中，hexo-cli 将 page 视为指定文章的标题、并采用默认的 layout。 generate1$ hexo generate 生成静态文件。 选项 描述 -d, --deploy 文件生成后立即部署网站 -w, --watch 监视文件变动 -b, --bail 生成过程中如果发生任何未处理的异常则抛出异常 -f, --force 强制重新生成文件 Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。 使用该参数的效果接近 hexo clean &amp;&amp; hexo generate -c, --concurrency 最大同时生成文件的数量，默认无限制 该命令可以简写为 1$ hexo g publish1$ hexo publish [layout] &lt;filename&gt; 发表草稿。 server1$ hexo server 启动服务器。默认情况下，访问网址为： http://localhost:4000/。 选项 描述 -p, --port 重设端口 -s, --static 只使用静态文件 -l, --log 启动日记记录，使用覆盖记录格式 deploy1$ hexo deploy 部署网站。 参数 描述 -g, --generate 部署之前预先生成静态文件 该命令可以简写为： 1$ hexo d render1$ hexo render &lt;file1&gt; [file2] ... 渲染文件。 参数 描述 -o, --output 设置输出路径 migrate1$ hexo migrate &lt;type&gt; 从其他博客系统 迁移内容。 clean1$ hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 list1$ hexo list &lt;type&gt; 列出网站数据。 version1$ hexo version 显示 Hexo 版本。 config1$ hexo config [key] [value] 列出网站的配置（_config.yml）。如果指定了 key，则只展示配置中对应 key 的值；如果同时指定了 key 和 value，则将配置中对应的 key 的值修改为 value。 选项安全模式1$ hexo --safe 在安全模式下，不会加载插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。 调试模式1$ hexo --debug 在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。 简洁模式1$ hexo --silent 隐藏终端信息。 自定义配置文件的路径12345# 使用 custom.yml 代替默认的 _config.yml$ hexo server --config custom.yml# 使用 custom.yml 和 custom2.json，其中 custom2.json 优先级更高$ hexo generate --config custom.yml,custom2.json,custom3.yml 自定义配置文件的路径，指定这个参数后将不再使用默认的 _config.yml。你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如： 12345# 使用 custom.yml 代替默认的 _config.yml$ hexo server --config custom.yml# 使用 custom.yml, custom2.json 和 custom3.yml，其中 custom3.yml 优先级最高，其次是 custom2.json$ hexo generate --config custom.yml,custom2.json,custom3.yml 当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 _multiconfig.yml。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。 显示草稿1$ hexo --draft 显示 source/_drafts 文件夹中的草稿文章。 自定义 CWD1$ hexo --cwd /path/to/cwd 自定义当前工作目录（Current working directory）的路径。 主题Solitudehttps://solitude-docs.efu.me/ shokahttps://www.kaitaku.xyz/ yilia-plus matery 3-hexo Butterflyhttps://blog.270916.xyz/ Cuteenhttps://blog.moej.cn/ 免费托管静态网页GitHub 页面 - https://pages.github.com/ Vercel- https://vercel.com/ Netlify - https://www.netlify.com/ 亚马逊 S3 - https://aws.amazon.com/s3/Firebase 托管 - https://firebase.google.com/products/hosting/激增 - https://surge.sh/GitLab 页面 - https://docs.gitlab.com/ee/user/project/pages/Bitbucket - https://bitbucket.org/product/features/pagesGitBook - https://www.gitbook.com/渲染 - https://render.com/谷歌云存储 - https://cloud.google.com/storage/DigitalOcean 空间 - https://www.digitalocean.com/products/spaces/Cloudflare 页面 - https://pages.cloudflare.com/Azure 静态 Web 应用 -https://azure.microsoft.com/en-us/services/app-service/static/AWS Amplify - https://aws.amazon.com/amplify/","categories":[{"name":"其他","slug":"其他","permalink":"https://qw8.github.io/categories/其他/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://qw8.github.io/tags/博客/"},{"name":"Hexo","slug":"Hexo","permalink":"https://qw8.github.io/tags/Hexo/"}]}]}
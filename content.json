{"meta":{"title":"秦伟的个人博客","subtitle":"前端及全栈知识点、面试题与学习链接的整理","description":"前端及全栈知识点、面试题与学习链接的整理","author":"秦伟","url":"http://www.bluedream.top","root":"/"},"pages":[{"title":"categories","date":"2019-08-30T02:14:28.000Z","updated":"2019-08-30T02:15:01.036Z","comments":false,"path":"categories/index.html","permalink":"http://www.bluedream.top/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-08-30T02:12:55.000Z","updated":"2019-08-30T02:14:06.907Z","comments":false,"path":"tags/index.html","permalink":"http://www.bluedream.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"字节跳动面经总结","slug":"字节跳动面经总结","date":"2019-09-19T15:30:33.000Z","updated":"2019-09-20T01:29:51.931Z","comments":true,"path":"前端面试题/字节跳动面经总结.html","link":"","permalink":"http://www.bluedream.top/前端面试题/字节跳动面经总结.html","excerpt":"","text":"记录一下自己的第二次面试经历 面试公司：字节跳动 公司介绍： ​ 字节跳动是全球第一家将人工智能应用到主产品的科技公司。全系产品矩阵包括今日头条、抖音、西瓜视频、火山小视频、TopBuzz、Faceu激萌、图虫、懂车帝等多款产品。截止2019年1月，字节跳动旗下全线产品日活超过6亿，月活超过10亿。字节跳动也在积极进行国际化部署，产品覆盖150多个国家和地区，75个语种，在40多个国家和地区排在应用商店总榜前列。 加入我们，一起和优秀的人做有挑战的事。 点击官网链接，了解更多公司信息 面试岗位：前端研发工程师职位（校招全职） 面试形式：视频面试 面试时间：2019-09-19 17:00:00 GMT+08:00（周四下午五点） 面试来源：字节跳动商业平台团队内部前端岗直推，“流云破风”在2019.9.13发布于前端迷公众号 发送邮箱：yuanlin@bytedance.com ，标注邮件标题：内推，其他岗位，实习校招社招均可 团队特色：全栈、NodeJS&amp;框架、React/Vue、前端基础建设、组件库、数据可视化、多个新方向、自主发挥空间 岗位描述： 1234负责前端技术选型和开发工作；优化前端功能设计，解决各种浏览器和终端设备的兼容性问题；通过技术手段，提升用户体验并满足高性能要求；通用组件、类库编写，提升开发效率和质量。 岗位要求： 1234567本科及以上学历，计算机相关专业； 精通HTML、CSS、JS，熟悉页面架构和布局，熟悉HTML5/CSS3等常用技术；熟悉常用UI框架（如bootstrap/pure/kendo等);精通JavaScript、AJAX、DOM、jQuery等技术；熟悉NodeJS，熟练使用Grunt、Gulp、Webpack等构建工具；具备MVVM框架开发经验，如React、VueJS、AngularJS等；良好的沟通和团队协作能力、热爱技术、责任心强、能推动技术框架的落地使用。 考察内容: 我们主要考察通用型的业务问题和过往的项目经历 价值观和软性技能也是我们选择人才的重要因素 1234567891011121314151617181920212223242526272829- 自我介绍 什么方式学习- div居中几种方法 盒模型 position属性详细问，相对定位绝对定位fixed http状态码304 http请求方法get post put delete head cookie应用在什么方面 cookie有哪些属性、大小 localStorage，sessionStorage的区别 网页访问速度慢，怎么优化- es6（了解吗） this指向（有class的话指向哪里） 作用域 事件循环 异步原理，比如setTimeout 箭头函数与普通函数区别 原型链 闭包 变量提升- vue与jQuery区别 vue绑定- 编程题： var versions=[&apos;1.45.0&apos;,&apos;1.5&apos;,&apos;6&apos;,&apos;3.3.3.3.3.3.3&apos;] var sorted=[&apos;1.5&apos;,&apos;1.45.0&apos;,&apos;3.3.3.3.3.3&apos;,&apos;6&apos;] 面试就是一个不断见面，试验，总结，归纳与提高的过程。 面试不同于考试，考试机会难得，形式及考察能力单一，而面试机会很多，形式不同，考察能力全面。 只要一直面，总会有进步，总会有提高的。 ​ 写于： 2019.9.19 面试之前找的各种面经投递简历后过了一段时间接到约面小姐姐的电话，了解你的具体的实习时间段，和你约定面试时间。你确认后小姐姐挂电话。过段时间hr给你发视频面试的链接，是牛客网用来面试的链接。 正文面试前做出的准备我在面试前准备以下几点东西，似乎都解决了面试的部分问题 面试前我查阅了其他朋友写的字节跳动的面经以及面试题目，寻找题目解答，把它们总结了下来，用了一天一夜的时间，并把它们放到了我的这个博客上面。我做了一份详细的自我介绍，通过三段开发经历来总结出了我的一些优点和开发经验，用讲故事的形式说明情况，最后点明故事中表现了自己具有哪些素质，点明自己为什么可以做前端的工作。字节跳动的宗旨“和优秀的人一起做有挑战的事情”也被我用到了自我介绍中，“我认为我是优秀的人，也喜欢做有挑战的事情，更喜欢与优秀的人为伍”“我希望搭上字节跳动这架火箭”等等。快要面试时做出的准备快要面试了，第一次面试，有些紧张，但还是像平常考试一样，将总结下来的面试题目总结、前端遇到问题的总结又看了一遍，把自己做好的自我介绍熟悉的几遍，给自己亲近的朋友发条消息获得她的祝福，又站在电脑桌前活动了一下身子，头脑顿时清醒利索了许多。 面试前奏由于紧张怕错过面试，早早的便坐在了电脑桌前。面试官迟到了一会，就给我发起了面试视频邀请，终于开始了。迎面是一个挺帅气的哥哥，简单的打了一下招呼，就进入了自我介绍的环节。由于自我介绍我已经熟悉过几遍了，自我介绍的效果看起来效果还是不错的。开始问我项目经历的细节以及自我介绍中的细节，由于项目经历确实是自己亲身经历过的事情，并且我一般项目完成时都会做一下总结，所以也能够答个头头是道。个人感觉上的，至于面试官怎么想的，我就不清楚了， 说不定是那种我就静静的看着你装逼的情况。 面试高潮来了来了，开始问技术的问题了。 你对Vue的理解有多少因为我在简历的项目经历中写了一个Vue项目，于是他问的时候就把我在项目中对Vue的理解和面试前准备的Vue总结结合起来回答。 用css2和css3分别写一下垂直居中和水平居中这道题我不会，并不知道css2和css3有什么区别以及写法，只会css3，我脑袋里有面试前总结的垂直居中和水平居中其中的两种方式，我就给他讲了一讲，倒是他没有再问下去，可能看出来我不会了吧。这也体现出了面试前知识点总结复习的重要性，不然你不会的东西你连说都不会说。 css3新增了一些属性，像flex，这是css3中很重要的改变，所以除了flex以外的垂直水平居中的技巧都是属于css2的。 css2的水平居中技巧将元素display为行内元素，再text-align:center;即可或者将块级元素定义一个宽度，再margin: 0 auto;即可 css3的水平居中技巧将元素display设为flex，再通过justify-content: center; 实现居中。 css2的垂直居中技巧单行内容的垂直居中可以通过设置相同height值和line-height值来实现。多行内容的垂直居中且高度可变可以通过设置上下相同的padding值来实现。行级盒子：小图标和标题对齐设置vertical-align: middle。绝对定位：top:50%; left:50%;的方法，需要已知块级的宽高 css3的垂直居中技巧将元素display设为flex，再通过align-items:center;来实现。 你对计算机网络的认识怎么样又是一道探底的题，判断能否从这里给你出题考察你 讲述一下计算机网络的七层应用层、表示层、会话层、传输层、网络层、数据链路层、物理层 TCP和UDP的区别是什么TCP：面向连接、传输可靠(保证数据正确性,保证数据顺序)、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)UDP：面向非连接、传输不可靠、用于传输少量数据(数据包模式)、速度快TCP和UDP协议的一些应用例子：TCP一般用于文件传输（FTP HTTP 对数据准确性要求高，速度可以相对慢），发送或接收邮件（POP IMAP SMTP 对数据准确性要求高，非紧急应用），远程登录（TELNET SSH 对数据准确性有一定要求，有连接的概念）等等；UDP一般用于即时通信（QQ聊天 对数据准确性和丢包要求比较低，但速度必须快），在线视频（RTSP 速度一定要快，保证视频连续，但是偶尔花了一个图像帧，人们还是能接受的），网络语音电话（VoIP 语音数据包一般比较小，需要高速发送，偶尔断音或串音也没有问题）等等。 TCP和UDP属于计算机网络中的哪一层网际层协议：IP协议、ICMP协议、ARP协议、RARP协议传输层协议：TCP协议、UDP协议应用层协议：FTP、Telnet、SMTP、HTTP、RIP、NFS、DNS HTTPS是什么HTTPS即加密的HTTP，HTTPS并不是一个新协议，而是HTTP+SSL（TLS）。原本HTTP先和TCP（假定传输层是TCP协议）直接通信，而加了SSL后，就变成HTTP先和SSL通信，再由SSL和TCP通信，相当于SSL被嵌在了HTTP和TCP之间 介绍几种常见的状态码2XX系列：代表请求已成功被服务器接收、理解、并接受。200状态码：表示请求已成功，请求所希望的响应头或数据体将随此响应返回201状态码：表示请求成功并且服务器创建了新的资源，且其 URI 已经随Location 头信息返回。3XX系列：代表需要客户端采取进一步的操作才能完成请求，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。301状态码：被请求的资源已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。302状态码：请求的资源临时从不同的URI响应请求，但请求者应继续使用原有位置来进行以后的请求。304状态码：自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。4XX系列：表示请求错误。代表了客户端看起来可能发生了错误，妨碍了服务器的处理。401状态码：请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。403状态码：服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。404状态码：请求失败，请求所希望得到的资源未被在服务器上发现。5xx系列：代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。500状态码：服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。503状态码：由于临时的服务器维护或者过载，服务器当前无法处理请求。 闭包是什么闭包就是能够读取其他函数内部变量的函数。闭包的用途：可以读取函数内部的变量，并且让这些变量的值始终保持在内存中。 123456789101112131415// 输出全为10for(var i=0;i&lt;10;i++)&#123; setTimeout(function()&#123; console.log(i); &#125;,50);&#125;// 输出相应的输出for(var i=0;i&lt;10;i++)&#123; (function(i)&#123; setTimeout(function()&#123; console.log(i); &#125;,50); &#125;)(i);&#125; js的隐性转换和显性转换隐性转换为： 1 + ‘1’ = ‘11’显性转换Number(“24 cccc”);//结果：NaNParseInt(“24 cccc”);//结果：24备注：Number的显性转换比较严格，若无法强转则直接报错 NaN是什么，用typeof会输出什么Not a Number会输出 Number js的隐性转换和显性转换隐性转换为： 1 + ‘1’ = ‘11’显性转换Number(“24 cccc”);//结果：NaNParseInt(“24 cccc”);//结果：24备注：Number的显性转换比较严格，若无法强转则直接报错面试官后引伸了两个问题1 + -‘1’ + 1 等于什么等于 0 ，’1’前面的负号把其数字化，变为-1，则后值为1‘A’ - ‘B’ 等于什么NaN 跨域问题如何解决同源策略：浏览器安全策略，同协议、ip、端口的脚本才会执行。只要协议、域名、端口有任何一个不同，都被当作是不同的域js跨域是指通过js在不同的域之间进行数据传输或通信 通过jsonp跨域 jsonp在页面上引入不同域上的js脚本文件实现请求不同域上的数据 (1) 通过script标签引入一个js文件 (2) js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入 注：需要服务器端的页面进行相应的配合 通过修改document.domain来跨子域 使用window.name来进行跨域window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。 知道babel么可以实现将ES6编译为ES5代码 用js实现判断一个变量是否为整数的函数实现思路：先判断该变量是否为Number类型，以此来缩小范围，再判断该变量除以1后是否与原值全等，若全等则返回true，若不全等则返回false 进程和线程是什么线程是最小的执行单元，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。进程指计算机中已运行的程序。线程指操作系统能够进行运算调度的最小单位。 死锁是什么当两个以上的运算单元，双方都在等待对方停止运行，以获取系统资源，但是没有一方提前退出时，就称为死锁。 Left Join、Right Join、Inner Join 指的是什么 LEFT JOIN 关键字会从左表那里返回所有的行，即使在右表中没有匹配的行 RIGHT JOIN 关键字会右表那里返回所有的行，即使在左表中没有匹配的行 在表中存在至少一个匹配时，INNER JOIN 关键字返回行 快速排序用js怎么写 1234567891011121314151617181920function quickSort(arr) &#123; if(arr.length&lt;=1) &#123; return arr; &#125; var s = Math.floor(arr.length/2); var temp = arr.splice(s,1); var left=[]; var right=[]; for(var i=0;i&lt;arr.length;i++) &#123; if(arr[i]&lt;temp) &#123; left.push(arr[i]); &#125; if(arr[i]&gt;=temp) &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat(temp,quickSort(right)); 面试尾声 面试官的突然一声“我这边没有什么问题了”，吓了我一跳，悬了悬了，我还想着跟他唠嗑两小时呢，唠嗑的感觉真好。 “我这边没有什么问题了，请等待hr的通知吧” 小技巧做项目小技巧每次项目完成后，都需要做一下项目的总结，这是做一两个项目并做总结的人比做很多的项目不做总结的人看起来更有经验的原因。古人说的好，“总结反思才能成长”。做简历小技巧套模板，注意写下什么时间毕业，尽可能的填充项目经验，项目经验写的详细些，重点是从项目中学到了什么。面试写代码小技巧写的代码记得加注释，考虑代码的时间复杂度问题，不会写代码一定要给面试官说一下你的思路，脑袋中想到什么说什么，部分解决方法也比说一声我不会强太多。总结实习的面试多进行基础知识的储备 我上个月的实习生面试是，两点半开始一面，结束后等个十分钟继续二面，视频面试。实习生的话只有两轮技术面+hr面。楼主加油，千万要准备好现场写一堆代码的准备�� 牛客上可以在线写代码，面试官可以实时看到的，写完代码后面试官还会就你写的代码进行提问。 技术岗一般连续面3轮。除非第一面安排在下午~ 我记得我那天从4点面到8点半，连续三轮（中间留了会吃饭时间） 面试官很有亲和力，面试过程更像是聊天多一点，但面试官提的问题也很有专业性，会对简历经历进行提问，并进行扩展，最后有对英语能力的考察。 面试官人很好,约定的六点面试,提前五分钟就到了面试间(还好我提前十分钟就在了..) 答题期间会根据我的答案给出建议和提示,全程虽然很紧张,但是知晓了自己的不足,考察点偏向基础和数据结构 问题如下: http协议知道吗? cookie session介绍一下 session表结构怎么设计,储存在哪里 你们的session cookie在项目里运用到哪里 算法题目:[删除链表中重复的节点]在一个排序的链表中,存在重复的节点,请删除该链表中重复的节点,重复的节点不保留,返回链表头指针.例如,链表1-2-3-3-4-4-5处理后为1-2-5 TCP/UDP的区别介绍一下 三次握手和四次挥手,time_wait是什么状态 B树 B+树区别说一下 数据库平时用到过什么 咱们先问MySQL MySQL索引原理知道吗 问了两种索引的区别(没记住…) 乐观锁悲观锁区别说一下 innodb和myisam的区别 数据库四种隔离状态 分别有什么问题 redis的数据结构 sortset底层,原理,怎么保证有序 总结: 就是自己太菜了..很多基础知识忘得很厉害,大公司感觉考察的都是基础,面试官在面试过程中有耐心,也会给与一些提示,素质很好 下来自己多背背知识,多刷一下leetcode吧..争取下次成功 面试用的视频面，面试官挺和善，问的内容也挺基础的，大概回忆着记录一下。 TCP和UDP的区别。TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接 TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付 TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的 UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等） 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信 TCP首部开销20字节;UDP的首部开销小，只有8个字节 TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道 说一下你对http协议的理解这个我只讲了个三次握手和四次挥手的内容，面试官貌似不太满意 get和post的区别这个回答的也不太全，其中我提到了数据存储在request body，面试官又问了我request body存储get和post的区别，emmmm…实在不会就下一题了 css实现一个左侧固定20px，右侧响应式的布局这个就蒙蔽了，因为我用的bootstrap是自带的响应式布局，不太了解原生css。回答的面试官也不太满意。 css实现水平垂直居中基础题jQuery选择器是如何实现的，例如$（#a.b…）对于jquery我当时也只是停留在使用层面，没去了解过实现原理，结果也没答上来 谈一下对事件流的了解大概讲了一下事件的冒泡和捕获的区别，然后面试官又问了一下冒泡最后会到哪里，我不太确定说了到,面试官又问我确不确定，我说不太确定。 8.最后给了一道算法题。大概是字符串的模式识别的题我写了一个最简单的，然后面试官要求优化复杂度，这个我当时隐约记得个kmp算法，就讲了一下思路，结果面试官要求写出实现代码，这磨蹭了半天也没写出来emmmmm…（顺带一提，当时面试用的是同学的电脑，不知道他装的IDE在哪，只好用的记事本写代码，痛苦） 总结 说实话当时我根本啥都不会，纯小白一个，复习了两三天菜鸟教程，w3school就去面试了，不出意外被拒了。 大厂很看重基础，考的都是原生css原生js和一些计算机网络、数据结构的内容，我了解的那些框架问题都没用上。 面试铁律自我介绍，基本上这是开启激战的导火索。顺便一提，宇宙条的视频面试是在牛客网上，可进行编码，视频，语音，文字沟通。面试官可以实时看到应聘者当前页面的内容和操作。 基础题1.display的取值和各种值的区别？ 2.相邻的两个inline-block节点为什么会出现间隔，该如何解决？ 3.用过nodejs中的EventEmitter吗？详细讲讲。 4.前端性能优化有哪些？ 5.讲简历中提到的一个项目，并且讲解服务端渲染和前端渲染的优缺点？为什么你的项目会选择服务端渲染？ 6.讲讲CSRF。 7.ts和js的区别，为什么要选择使用ts？ 算法题找出数组中和为给定值的两个元素，如：[1, 2, 3, 4, 5]中找出和为6的两个元素。 题目很清晰，也很容易理解，相信很多小伙伴看到这个题都能直观地用“冒泡排序”的方法解决，但是冒泡排序的时间复杂度明显不是我们想要的结果，我把我能够想到的几种方法由易到难记录下来： 冒泡排序的方式 12345678910111213141516function getNum(arr, sum) &#123; if (!Array.isArray(arr)) return null; for (var i = 0; i &lt; arr.length - 1; i++) &#123; if (arr[i] &gt; sum) continue; for (var j = 0; j &lt; arr.length; j++) &#123; if (arr[j] &gt; sum) continue; if (arr[i] + arr[j] == sum) return [arr[i], arr[j]]; &#125; &#125; return null;&#125;复制代码 这种解法很容易想到，也很容易理解，我们不多过多的讲解，接下来分享一种上述解法的优化版。 查找的方式 最终的结果是要找到和为sum的两个数，那么我们可以转换一种思路：默认第一个num1数已经存在，那么第二个数就是sum - num1，这就转换为从数组中查找的问题了。虽然和第一种方法很像，但是在有序数列中进行查找明显要快于逐个比较。 12345678910111213141516function getNum(arr, sum) &#123; if (!Array.isArray(arr)) return null; arr.sort(); for (var i = 0; i &lt; arr.length - 1; i++) &#123; if (arr[i] &gt; sum) continue; var restNum = sum - arr[i]; // 考虑下为什么要 &gt; i if (arr.indexOf(restNum) &gt; i) return [arr[i], restNum]; &#125; return null;&#125; 这种解法的前提是需要对数组进行排序（快排），故时间复杂度为O(nlogn)，二分查找的时间复杂度为O(log2n)，最坏的情况是遍历了整个数组，即时间复杂度为O(n)，那么整体的时间复杂度为O(nlog2n)，效果上要优于冒泡排序的方式。 快排方式 同样需要对数组进行排序（升序），我们知道排序后的数组必然是左边的数不会超过右边的数，因此我们可以把左边的数和右边的数的和作为基准值来和目标值比较，如果该值小于目标值，那么代表两个加数的值不够大，右边的值已经到达顶峰了，那么就从左边取下一个值相加和目标值比较，如果该值比目标值大，那么表示右边的值太大了，需要获取一个小一点的加数，这时需要从右边取倒数第二个数相加后比较，如果此时的值和目标值相等，恭喜你，我的小乖乖，原来你俩在这里！说了这么多感觉还是一头雾水的同学直接看代码吧，毕竟我们都是同一类猿:-) 123456789101112131415function getNum(arr, sum) &#123; if (!Array.isArray(arr)) return null; arr.sort(); for (var i = 0, j = arr.length - 1; i &lt; j;) &#123; if (arr[i] + arr[j] &lt; sum) i++; else if (arr[i] + arr[j] &gt; sum) j--; else return [arr[i], arr[j]]; &#125; return null;&#125; 这种方法我是受到了快速排序的启发，所以命名为快速排序的方式，它是目前为止我能想到效率最高的解决方案，时间复杂度为O(nlogn)。如果需求是找出所有对组合，只要控制退出条件即可，难度不大故不做讨论。 面试考察点归纳 这里只是简要记录个人在前端面试遇到的考察点： position和display、事件机制、dom、捕获冒泡、this及作用域、原型链、es6（了解）、vue的双向绑定原理（最好有用过，一定程度上考察了源代码理解）、基础的数据结构……等。 其中，dom的考察了一道，this及作用域考察了两道，数据结构考察了一道，其它的都以概念提问的方式进行考察。 可以总结出以下教训： js基础是重中之重，而前端对算法的要求基本上不是特别高，基础的数据结构牢固掌握了就没问题。另外前端的话，刷算法题最好用js。 对于你没怎么接触过的领域，面试官并不会去深究；但是，对于网上疯传的Vue等框架，最好有个了解和体验，甚至是深入源码。 一个很明显的现象是，一个概念你知道了，但不一定能说得清楚；一个概念你看似仔细了解过，但真正面临考察时不一定能说出个所以然。解决这个问题的最好办法是——写博客。 并没有考察到websocket、nodejs等知识，这个阶段的面试要求并没有网传得那么高。 笔试 + 一面敲黑板！头条是一定会有笔试题的哦，css，js，算法都会考察噢。我尽量还原题目。。有的实在是忘了-.- 实现css布局1234567一个div垂直居中其距离屏幕左右两边各10px其高度始终是宽度的50%div中有文本'A'其font—size:20px文本水平垂直居中 我的回答： 12345678910111213141516171819202122232425262728293031&lt;div class=\"wrap\"&gt; &lt;div class=\"box\"&gt; &lt;span class=\"text\"&gt;A&lt;/span&gt; &lt;div&gt;&lt;/div&gt;.wrap &#123; position: fixed; left: 10px; right: 10px; top: 0; bottom: 0;&#125;.box &#123; position: absolute; top: 50%; transform: translateY(-50%); width: 100%; height: 50%; background: red;&#125;.text &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; font-size: 14px; background: blue;&#125; 我的回答好像做不到“其高度始终是宽度的50%”这一点，网上参考了一下其他大神的，使用了calc和flex，大家可以看看： 123456789101112131415161718192021222324252627282930&lt;div class=\"box\"&gt; &lt;div class=\"Abox\"&gt;A&lt;/div&gt;&lt;/div&gt;*&#123; padding:0; margin: 0;&#125;html,body&#123; width: 100%; height: 100%;&#125;.box&#123; position: relative; background: red; width: 100%; height: 100%;&#125;.Abox&#123; margin-left:10px; width: calc(100vw - 20px); height: calc(50vw - 10px); position: absolute; background: yellow; top:50%; transform: translateY(-50%); display: flex; align-items: center; justify-content: center; font-size: 20px;&#125; 函数中的arguments是数组吗？类数组转数组的方法了解一下？答： arguments当然不是数组啦，转数组的方法有： […arguments] Array.from(arguments) 类型比较1234if([]==false)&#123;console.log(1)&#125;;if(&#123;&#125;==false)&#123;console.log(2)&#125;;if([])&#123;console.log(3)&#125;if([1]==[1])&#123;console.log(4)&#125; 答：1 3 == 是非严格比较操作符，false会转换为0，[]会转换成’’，{}会转换为”[object Object]”，所以会输出1，不输出2，具体的可以看看以下文章 参考文章 为什么[] 是 false []和{}是“空”的对象，不是“空”，所以会输出3 最后一个引用地址不一致，不是同一个对象，所以不会输出4 EventLoop123456789101112131415161718192021222324252627282930313233async function a1 () &#123; console.log('a1 start') await a2() console.log('a1 end')&#125;async function a2 () &#123; console.log('a2')&#125;console.log('script start')setTimeout(() =&gt; &#123; console.log('setTimeout')&#125;, 0)Promise.resolve().then(() =&gt; &#123; console.log('promise1')&#125;)a1()let promise2 = new Promise((resolve) =&gt; &#123; resolve('promise2.then') console.log('promise2')&#125;)promise2.then((res) =&gt; &#123; console.log(res) Promise.resolve().then(() =&gt; &#123; console.log('promise3') &#125;)&#125;)console.log('script end') 正确答案： 1234567891011121314script starta1 starta2promise2script end// 此处开始执行异步队列promise1promise2.thenpromise3// 真的不知道 a1 end 为啥在这里才输出，还以为会在promise1 后面。。// 大家知道的话可以评论区分享一下啊～在网上看到的答案都说得模凌两可的a1 end// 执行完所有微任务才执行宏任务setTimeout 改正代码，输出01234012341234567891011function a () &#123; for (var i = 0; i &lt; 5; i++) &#123; this.i = i setTimeout(function () &#123; console.log(i) &#125;, 0) console.log(this.i) &#125;&#125;a() 答：首先留意var，可以改成let，再加个立即执行函数；然后留意this指向，可以改为箭头函数。（我当时的想法就是这么短浅。。。） 12345678910111213function a () &#123; for (let i = 0; i &lt; 5; i++) &#123; (function (i) &#123; this.i = i setTimeout(() =&gt; &#123; console.log(i) &#125;, 0) console.log(this.i) &#125;)(i) &#125;&#125;a() 我的一个牛逼大神同事用了这个方法，实在佩服啊哈哈哈👇 1234567891011121314151617181920var count = 0;Object.defineProperty(window, 'i', &#123; get: function() &#123; return count++ &#125;, set: function() &#123;&#125;&#125;)function a () &#123; for (let i = 0; i &lt; 5; i++) &#123; (function (i) &#123; this.i = i setTimeout(() =&gt; &#123; console.log(this.i) &#125;, 0) &#125;)(i) &#125;&#125;a() 5分钟后他又想出了一个新方法！我的膝盖啪一声跪下来👇 12345678function a () &#123; for (var i = 0; i &lt; 5; i++) &#123; this.i = i setTimeout(function () &#123; console.log(this.i) &#125;.bind(&#123;i: i&#125;), 0) &#125;&#125; 按要求写出bind（题目我实在记不清楚，反正不是简单的写一个bind）答：(以下是正常的bind手写实现) 1234567891011121314151617181920Function.prototype.bind2 = function (context) &#123; if (typeof this !== \"function\") &#123; throw new Error(\"Function.prototype.bind - what is trying to be bound is not callable\"); &#125; var self = this; var args = Array.prototype.slice.call(arguments, 1); var fNOP = function () &#123;&#125;; var fbound = function () &#123; self.apply(this instanceof self ? this : context, args.concat(Array.prototype.slice.call(arguments))); &#125; fNOP.prototype = this.prototype; fbound.prototype = new fNOP(); return fbound;&#125; 从一个无序，不相等的数组中，选取N个数，使其和为M实现算法哈哈哈哈哈做不出来，面试官很有耐心引导，假如选取2个数的话怎么实现呢，我就想到递归函数之类的，但是最后还是手写不出来。。。 一面的面试官主要是看着笔试题拓展问了相关的知识点，然后我也不知道怎么就过了一面了，，， 二面二面几乎都是算法题，再加点js基础题这样。emmm算法题我就说说当时的做法吧，，感觉要误人子弟了，，改天研究透了再单独分享 1. 一个字典[‘I’, ‘have’, ‘a’, ‘book’, ‘good’]，实现一个函数，判断一个字符串中是否都是出自字典中的，输出true/false 例如： 输入’I have a book’ 输出 true 输入 ‘this is a good book’ 输出 false 答： 我当时是想出了个很蠢的方法，就是将字符串的字典词都切了，切完后还有得剩就说明是false，哈哈哈哈啊哈哈哈好蠢啊，面试官不满意地问我这个做法的复杂度，我说好的我知错了。。。 2. 一个长阶梯有n级，可以一次走1级，一次走2级，一共有多少种走法？ 答： 引导了一番后我写了个递归函数 12345function step (n) &#123; if (n === 1) return 1 if (n === 2) return 2 return step(n - 1) + step(n - 2)&#125; 面试官看完后不是很满意，说假如在浏览器上敲step(40000)会怎样，我说会爆掉吧。。他说为什么。。我说内存会溢出。。他问我为什么。。 blablabla一大堆后我还是没答好，回到家后我想想觉得应该是还存在尾递归的优化空间吧。。。 ////////之后问的算法题我已经记不住了。。我再分享一些基础题题目吧，大部分答案都在之前的文章和面经都提过了，此处不再赘述 3. 说说http缓存 4. 用过typescript吗？它的作用是什么？ 答： 用过，我真的只想到类型检查，提供缺省值诶，，后来想想还有引入了“类”“模块”的概念。 5. ts的用法用到了装饰器，你了解过吗？知道如何实现的嘛？ 答：这个正好我写了一篇装饰器的文章，略知一二。。。实现大概就是使用object.defineProperty来拦截对象的属性进行“加工” 6. PWA使用过吗？serviceWorker的使用原理是啥？ 最后。。。有的题目真的想不起来了，最后二面面试官和我说他们是对算法有要求的，包括前端。这次面试真的被虐得很惨，但是收获真的很多很多，而且也让自己意识到算法真的（对找工作）很重要～！ 一面（40分钟）自我介绍 1.线程与进程，空间分配、资源分配等等 2.三次握手、四次挥手及标志位、time-wait等等 3.H5的新特性，语义化 4.BOM与DOM，及BOM相关的一些属性 写代码：双向绑定、防抖和节流 5.设计模式：发布订阅、观察者 二面（1小时）介绍项目 1.web worker，web storage，怎样验证本地数据的有效性 2.性能优化相关 3.缓存相关的http头部属性，强制缓存，协商缓存，优先级，以及meta标签 4.怎样做的登录，接着就是session，cookie，token等等 5.input属性相关，以及怎样做的文件上传 6.微信小程序相关（项目中有涉及到） 7.transform transition与animation 8.setTimeout、setInterval与requestAnimationFrame 9.页面加载问题，JS的异步加载 10.给出代码，说出运算结果（this、event loop） 写代码：回文数，数组去重，自定义log，判断数据类型 ​ 11.React与Vue，各自做了些什么事情 三面（1小时）介绍项目 缓存命中率的问题，怎样确保缓存全部数据，缓存命中率不是100%应该怎么办 说说性能优化的通用架构方案 请求优化和渲染优化的方法 数据类型转换的原理 编程，5个feach请求，请求完成后要求立即执行，但最终的输出顺序要按照要求输出ABCDE（思路是：将每个feach的回调通过a/a的方式输出，但最后没有run出来） 面了一个小时，从四点面到五点一十，下面的问题可能不是所有的，反正我记得起来的都写了。 算法：链表反序输出，不再申请内存空间 0.1+0.2===0.3吗，为什么？ Number()的存储空间是多大，如果后台发送了一个超过最大字节的数字怎们办 垂直居中实现方法 跨域、jsonp原理、CORS原理 Proxy Promise原理 浏览器请求数据问题，请求数据到请求结束与服务器进行了几次交互 TCP为什么要四次挥手 cookie有哪些属性、大小、浏览器如何禁止别人访问cookie localStorage，sessionStorage的区别。 display:none,visibility:hidden,opactiy:0的区别。 BFC，如何形成BFC BFC与IFC的区别 BFC会与float元素相互覆盖吗？为什么？举例说明 回流与重绘，如何避免回流 git merge、git rebase的区别 js脚本加载问题，async、defer问题 antd源码相关，使用什么语言写的，按需加载实现 设计模式，有哪些设计模式 在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持 websocket与ajax的区别 fetch API与传统request的区别 说一下心得好了，因为他面算法，我不会，我说我只会简单的快排、冒泡、归并等算法，所以面试官后面就没问算法了 问框架我有的答得出来，我跟他说我框架掌握比较薄弱，基础比较厉害，所以框架就问的少，问很多js相关、交互相关的基础 一面过了，面试官是个很可爱的小哥哥，虽然前面第一题问算法，第二题问框架，我都没答出来很尴尬，但后面问很多js和浏览器基础，都答上来了，所以,面试还是很人性化的~ 其实这些面试题哈哈，上次我跟部门的小哥哥小姐姐去吃火锅，坐在我一面面试官对面，还拿着题考他哈哈，这边的人真的超级可爱～ 然后我一面、二面、三面都发了帖子，大家可以对比一下啊。，一般一面是部门同事面，涉及到比较广，如果面到40min以上基本上稳的几率比较大，二面是其他部门的前端交叉面你，主要问项目比较多，然后很可能手撕代码（校招可能一面就手撕）。三面的话是leader面，应该会着重问一下你的学习能力什么的。 首先，一般的都是介绍自己，主要是项目经历jQuery与Vue的区别是什么？JQuery和Vue的主要区别是JQuery主要是通过选择器来选取DOM，对其进行赋值，取值，事件绑定等操作，数据和页面是混合在一起的；Vue则是通过Vue对象将数据和视图完全分割开来，对数据进行操作，不再需要引用相应的DOM对象，实现了MVVM。 javascript数据基本类型有哪些？null、boolean、string、undefined、number、symbol(ES6新加) css 水平垂直居中方法body{ 123456789101112 height:1000 px;&#125;.antzoen&#123; position:fixed; width:250px; height:100px; background:#ececec; left:50%; top:50%; margin-left:-125px; margin-top:-50px&#125; 利用flex布局：.center{ 123display:flex;justify-content:center;align-items:center; }等等还有很多其他的方法就不一一分享了。 11月25号流程： 1.笔试，给了两页题自己做，大概做了40分钟我怕时间太久，有一道题没写出来就交了。 ​ 2.一面，面试官拿着我的笔试答案一道题一道题问，答上来的就直接说答案，答不上来的我说了下我的思路，和面试官一起探讨思考答案。 ​ 3.二面，问项目，问了问以前做的项目，遇到什么挑战等等，还问了几个JS问题。 ​ 4.三面，主管面，问项目，问方案，三面就像在聊天，没有压力。 ​ 5.四面，HR面，问一些和技术无关的，如兴趣、原来公司等等，然后就定级、定薪资了。发布 11月26号： ​ 6.五面，交叉面，别的部门的人来面试，简单聊了聊项目，然后出了个算法题，没答上来，15分钟就结束了 11月27号： ​ 面试结果审核通过，薪资审核 11月28号： ​ 薪资审核通过，收到了offer 简答题1.css3特性中的transform：translateZ(0)有什么作用答案：GPU加速，优化前端性能 2.列举三种禁止浏览器缓存的头字段，并写出响应的设置值Expires：告诉浏览器把回送的资源缓存多长时间 -1或0则是不缓存简要：添加Expires头能有效的利用浏览器的缓存能力来改善页面的性能，能在后续的页面中有效避免很多不必要的Http请求，WEB服务器使用Expires头来告诉Web客户端它可以使用一个组件的当前副本，直到指定的时间为止。例如：Expires：Thu，15 Apr 2010 20：00：00 GMT; 他告诉浏览器缓存有效性持续到2010年4月15日为止，在这个时间之内相同的请求使用缓存，这个时间之外使用http请求。 Cache-Control：no-cacheCathe-Control：max-age=315360000 Expires有一个非常大的缺陷，它使用一个固定的时间，要求服务器与客户端的时钟保持严格的同步，并且这一天到来后，服务器还得重新设定新的时间。HTTP1.1引入了Cathe-Control，它使用max-age指定组件被缓存多久，从请求开始在max-age时间内浏览器使用缓存，之外的使用请求，这样就可以消除Expires的限制，如果对浏览器兼容性要求很高的话，可以两个都使用。 Pragma：no-cache 3.精确获取页面元素位置的方式有哪些那就是使用getBoundingClientRect()方法。它返回一个对象，其中包含了left、right、top、bottom四个属性，分别对应了该元素的左上角和右下角相对于浏览器窗口（viewport）左上角的距离。 12345var X= this.getBoundingClientRect().left;var Y =this.getBoundingClientRect().top;//再加上滚动距离，就可以得到绝对位置var X= this.getBoundingClientRect().left+document.documentElement.scrollLeft;var Y =this.getBoundingClientRect().top+document.documentElement.scrollTop; 4.正则从2018-10-07T11:48:47 Asia/zh-cn 提取出来结果[2018,10,07,11,48,47]“2018-10-07T11:48:47 Asia/zh-cn”.match( /\\d{1,}/g ) 5.如何判断object是数组类型？12345678alert(typeof 1); // 返回字符串\"number\" alert(typeof \"1\"); // 返回字符串\"string\" alert(typeof true); // 返回字符串\"boolean\" alert(typeof &#123;&#125;); // 返回字符串\"object\" alert(typeof []); // 返回字符串\"object \" alert(typeof function()&#123;&#125;); // 返回字符串\"function\" alert(typeof null); // 返回字符串\"object\" alert(typeof undefined); // 返回字符串\"undefined\" 其中，typeof {}和typeof []的结果都是object，那么问题来了，我怎么通过typeof去判断一个对象是不是数组类型呢？ 对象是对象，数组也是对象，js中万物皆对象，很显然，通过简单的typeof运算符是不能够达到目的，我们得换个方法。 1、从原型入手，Array.prototype.isPrototypeOf(obj); 利用isPrototypeOf()方法，判定Array是不是在obj的原型链中，如果是，则返回true,否则false。 判断object是数组类型 2.Array.isArray()方法。 1234Array.isArray([1, 2, 3]); // trueArray.isArray(&#123;foo: 123&#125;); // falseArray.isArray('foobar'); // falseArray.isArray(undefined); // false 500：服务器内部错误。 501：服务器不具备完成请求的功能。 502：Bad Gateway错误。 503：服务器目前无法使用。 504： Bad Gateway timeout 网关超时。 cookie： 在本地计算机保存一些用户操作的历史信息（当然包括登录信息），并在用户再次访问该站点时浏览器通过HTTP协议将本地cookie内容发送给服务器，从而完成验证，或继续上一步操作。 session： 是一种服务器端的机制，服务器使用一种类似于散列表的结构(也可能就是使用散列表)来保存信息。 编程题1.已知数据结构users，请实现语法支持user.unique能够按照name字段去重，并输出结构为：[“a”,“b”]123456789101112131415161718192021222324var users=[&#123; id:1,name:\"a\"&#125;,&#123; id:2,name:\"a\"&#125;,&#123; id:3,name:\"b\"&#125;,&#123; id:4,name:\"v\"&#125;]Array.prototype.unique = function () &#123; var res; this.map(item =&gt; &#123; this[item.id - 1] = item.name &#125;) // ES6里新添加了两个很好用的东西，set和Array.from // set是一种新的数据结构，它可以接收一个数组或者是类数组对象，自动去重其中的重复项目。 res=new Set(this); console.log(\"new Set对象\",res) // 但是这里大家可以看到，set返回的是一个对象，但是我们想要的是数组啊。 // 这回，就该轮到Array.from出场了，它的作用，就是可以把类数组对象、可迭代对象转化为数组。 res=Array.from(new Set(this)); return res//es6 数组去重&#125;console.log(users.unique()); 去重 2.已知如下对象，请基于es6的proxy方法设计一个属性拦截读取操作的例子，要求实现去访问目标对象example中不存在的属性时，抛出错误：Property “$(property)” does not exist123456789const man=&#123; name:'jscoder', age:22&#125; //补全代码const proxy = new Proxy(...)proxy.name //\"jscoder\"proxy.age //22proxy.location //Property \"$(property)\" does not exist 考点es6 javascript的Proxy 实例的方法 ,get() get方法用于拦截某个属性的读取操作。 12345678910111213141516var man = &#123; name:'jscoder', age:22&#125;;var proxy = new Proxy(man, &#123; get: function(target, property) &#123; if(property in target) &#123; return target[property]; &#125; else &#123; throw new ReferenceError(`Property $&#123;property&#125; does not exist.`); &#125; &#125;&#125;);console.log(proxy.name)console.log(proxy.age)console.log(proxy.location) Proxy 实例的方法的其他方法参考这个链接，很详细https://blog.csdn.net/qq_30100043/article/details/53443017 3.给出如下虚拟dom的数据结构，如何实现简单的虚拟dom，渲染到目标dom树123456789//样例数据let demoNode = (&#123; tagName: 'ul', props: &#123;'class': 'list'&#125;, children: [ (&#123;tagName: 'li', children: ['douyin']&#125;), (&#123;tagName: 'li', children: ['toutiao']&#125;) ]&#125;); //构建一个render函数，将demoNode对象渲染为以下dom 1234&lt;ul class=\"list\"&gt; &lt;li&gt;douyin&lt;/li&gt; &lt;li&gt;toutiao&lt;/li&gt;&lt;/ul&gt; 看到虚拟DOM，是不是感觉很玄乎，但是剥开它华丽的外衣，也就那样: 通过JavaScript来构建虚拟的DOM树结构，并将其呈现到页面中； 当数据改变，引起DOM树结构发生改变，从而生成一颗新的虚拟DOM树，将其与之前的DOM对比，将变化部分应用到真实的DOM树中，即页面中。通过上面的介绍，下面，我们就来实现一个简单的虚拟DOM，并将其与真实的DOM关联。 构建虚拟DOM 虚拟DOM，其实就是用JavaScript对象来构建DOM树，如上ul组件模版，其树形结构如下： DOM树 通过JavaScript，我们可以很容易构建它，如下： 12345678var elem = Element(&#123; tagName: 'ul', props: &#123;'class': 'list'&#125;, children: [ Element(&#123;tagName: 'li', children: ['item1']&#125;), Element(&#123;tagName: 'li', children: ['item2']&#125;) ]&#125;); note：Element为一个构造函数，返回一个Element对象。为了更清晰的呈现虚拟DOM结构，我们省略了new，而在Element中实现。 1234567891011121314/** @Params:* tagName(string)(requered)* props(object)(optional)* children(array)(optional)* */function Element(&#123;tagName, props, children&#125;)&#123; if(!(this instanceof Element))&#123; return new Element(&#123;tagName, props, children&#125;) &#125; this.tagName = tagName; this.props = props || &#123;&#125;; this.children = children || [];&#125; 好了，通过Element我们可以任意地构建虚拟DOM树了。但是有个问题，虚拟的终归是虚拟的，我们得将其呈现到页面中，不然，没卵用。。 怎么呈现呢？ 从上面得知，这是一颗树嘛，那我们就通过遍历，逐个节点地创建真实DOM节点: \\1. createElement; \\2. createTextNode. 怎么遍历呢？ 因为这是一颗树嘛，对于树形结构无外乎两种遍历： \\1. 深度优先遍历(DFS) 深度优先遍历 \\2. 广度优先遍历(BFS) 广度优先遍历 针对实际情况，我们得采用DFS，为什么呢？ 因为我们得将子节点append到父节点中 好了，那我们采用DFS，就来实现一个render函数吧，如下： 1234567891011121314151617181920Element.prototype.render = function()&#123; var el = document.createElement(this.tagName), props = this.props, propName, propValue; for(propName in props)&#123; propValue = props[propName]; el.setAttribute(propName, propValue); &#125; this.children.forEach(function(child)&#123; var childEl = null; if(child instanceof Element)&#123; childEl = child.render(); &#125;else&#123; childEl = document.createTextNode(child); &#125; el.appendChild(childEl); &#125;); return el;&#125;; 此时，我们就可以轻松地将虚拟DOM呈现到指定真实DOM中啦。假设，我们将上诉ul虚拟DOM呈现到页面body中，如下： 123456789var elem = Element(&#123; tagName: 'ul', props: &#123;'class': 'list'&#125;, children: [ Element(&#123;tagName: 'li', children: ['item1']&#125;), Element(&#123;tagName: 'li', children: ['item2']&#125;) ]&#125;);document.querySelector('body').appendChild(elem.render()); 整个面试持续了41分钟….上来寒暄几句，例行自我介绍 第一部分：JS基础1.JS的数据类型有哪些张口就出，没啥难度2.讲一讲js的作用域？ES6之前函数作用域，ES6之后有了块作用域（let）3.let和var有啥区别？和const有啥区别？和var的比较简单。。。变量声明不提前，不能重复定义，作用域不同等等张口就来，和const的不太了解，只答了个const定义的是不可改变的常量4.ES6之前通过prototype实现继承，聊一聊？巴拉巴拉一大堆5.函数的call和apply有什么区别？和bind又有啥区别？比较简单。。。call和apply区别在于第二个参数，而bind这个和另外两个根本没啥相似的，说一遍他的作用就行了。6.如果一个构造函数，bind了一个对象，用这个构造函数创建出的实例会继承这个对象的属性吗？为什么？不会，bind没有改变原函数，单纯返回一个绑定了目标对象的新函数7.箭头函数和普通函数有啥区别？箭头函数能当构造函数吗？区别主要在于this，能不能当不知道。。。老实交代了8.说一说this在各种情况下可能的取值？这个感觉答得还不错，主要就是全局函数的this是全局对象，但是严格模式下是undefined，平常调用的话this就是调用函数的对象，还有比较特殊的就是apply和call调用的函数，this是主动设置的。另外，forEach函数可以传入第二个参数作为第一个参数的this值。9.http有哪些状态码？分别代表什么意思？这个简单，学过计网的都知道，12345开头的都说一下就行10.用过哪些http请求方法？GET POST OPTION PUT DELETE11.OPTION是干啥的？举个用到OPTION的例子？测试服务器支持的请求类型，例子的话我举的CORS中应对非简单跨域请求时会先发一个OPTION测一测允不允许跨域。12.你知道哪些跨域方法？说说他们的原理？JSONP、CORS。。。本咸鱼就知道这两个，然后讲了讲实现方案13.知道ES6的class吗？了解一些，它是prototype的语法糖，但是不熟悉（干脆利落不给自己挖坑，把战场拉回自己熟悉的领域）14.static关键字了解吗？不了解，但是我知道java中的static，巴拉巴拉讲一堆java的static15.数组和类数组对象有啥区别？二者如何转换？这里我提到了“鸭式辩形”，围绕这个聊二者的区别。转换的话，说实话我是不知道的，然后编了一下应该是可以用循环遍历类数组对象的所有属性，然后挨个push到真正的数组里的。 第二部分 CSS基础1 .说一下你知道的position属性，都有啥特点？张口就来系列2.聊一聊盒模型？开始没弄明白面试官想问啥。。懵了一会。。。后来在面试官的指引下才知道他想让我说盒模型由什么组成。。。width height margin padding border张口就来。。。松了一口气3.两个div上下排列，都设margin，有什么现象？这个简单，就是margin重叠，同正取大正负相加很简单4.为什么会有这种现象？你能解释一下吗恕我直言。。。不能。。。。5.其实这是由块级格式化上下文决定的，你了解吗，能说一下吗？emmm之前看过格式化上下文这块，还专门做过笔记，但是忘了。。。。emmm，勉强说了一些自己还记得的东西6.了解css3中的新东西吗？比如flex、动画这些？flex了解，但是动画只写过一些小demo7.清除浮动有哪些方法？一时想不起来。。就说了个overflow：hidden。太长时间没写过浮动了，都忘了，太菜了。。（面试官可能看出来我css差的离谱了。。。就不聊css了） 第三部分 现场写代码（用自己电脑屏幕分享，面试官会看着你敲的每个字母，挺紧张的）1.实现一个两栏三列的布局，并且要求三列等高，且以内容最多的一列的高度为准。两栏三列比较好实现，双飞翼、圣杯布局这都是基础的东西。然后面试官问，还有没有其他实现方案？提示了一下说用新特性，然后我用flex又写了一个，搞定。高度的问题的话，很快想出了解决方案，okpass。2.判断一个字符串是不是回文的这个也挺简单的。。。不到十行搞定，一次测试通过。然后面试官问有没有其他实现方案，我又巴拉巴拉说了一下，最后问我两个方案哪个好，时间复杂度分别是多少？应该没说错（吧）这里最好注意一下。。面试官让你现场运行测试，如果用js写的话最好是node跑一下就行，如果不会node的话，还得放到浏览器跑就很low。。。 第四部分 智商测试（我自己取的名字）一个圆形的桌子，在上面随意放圆形棋子，谁先没地方放谁输，问有没有必胜策略，有的话应该怎么才能达到必胜？这个真的是我想多了。。。我当时还在考虑各种问题，比如棋子的直径和圆桌半径的关系，甚至极限情况下整个桌子只能放一个棋子呢之类的。。。。后来面试官提示“想想圆有什么特殊的位置”，恍然大悟，只要占据了圆心，其他任何地方你落一个子我都能找到一个关于圆心对称的地方落子。。。哎呀，真是太菜了。面试结束后搜了搜这道题，尼玛还是经典面试题。。。面试之前多看看面经肯定秒答。。。真的是太菜了。 面试经验一：凉的很快，不过面试官人比较好此面试总共花费1天时间，面试形式包括1对1面试，面试的职位是前端开发实习生。 面试过程凉的很快，不过面试官人比较好，一面本来是考基础的，上来就是5到编程题，虽然比较简单，但是我有点头皮发麻。 面试过程中面试官提了哪些问题1、一亿条数据中如何快速的查找1000条最大的数据2、对于promise的了解3、get和post的区别3、http状态码4、tcp和udp的区别5、dns的详细过程 面试经验二：电脑视频面试。一面小语种自我介绍此面试总共花费1天时间，面试形式包括电话面试，面试的职位是内容安全运营。 面试过程电脑视频面试。一面小语种自我介绍，面试官做相关提问。之后看一些小视频判断其中是否有问题，并指出问题。二面看你对该岗位的了解程度和意愿。之后还有三面谈一些待遇问题。 面试过程中面试官提了哪些问题是否了解此岗位。这些视频是否有问题，是否有语言问题（是否存在不文明用语）。是否能实习半年。 面试经验三：先是电话面试了解了一下情况面试的职位是招聘实习生。 面试过程先是电话面试了解了一下情况 是不是应届 了解了未来规划之类的 说明了实习转正所需时间以及要求 没有特别肯定说啥然后就是远程视频面试了 面试过程中面试官提了哪些问题主要是围绕简历挖掘了很多 首先是简单的自我介绍 具体工作的状况 遇到的问题 还有个人性格方面的 优缺点啥的 还有对岗位的了解 面试经验四：主要是个人介绍，从学历到几段工作经验此面试总共花费2天时间，面试形式包括1对1面试，面试的职位是软件产品经理。 面试过程主要是个人介绍，从学历到几段工作经验，详细介绍，由于之前一直是开发，对方对开发经历不是很感兴趣，主要介绍了近一年的工作经历，做了哪些项目之类的 面试过程中面试官提了哪些问题自我介绍，关于项目上的一些问题，详细问了项目都做了些什么，系统的功能之类的，自身有什么优势，关于产品有什么想法。 面试经验五：面试官很nice，很准时、很随和面试形式包括1对1面试，面试的职位是hr。 面试过程面试官很nice，很准时、很随和，问的问题围绕个人的经历，全程气氛很轻松，会回答可以多说，不会也不会为难你的 面试过程中面试官提了哪些问题分享一下你抗压的经验和你解决的方法，进行自我介绍和为什么投递这个岗位，也问了一些专业相关的问题，但是我不太懂所以就水过去了 面试经验六：两轮面试 简单的聊天， 二面偏压力面面试形式包括电话面试、1对1面试，面试的职位是商务合同。 面试过程两轮面试简单的聊天， 二面偏压力面， 基本上是简历上的问题 问的比较详细。用zoom进行面试，部门领导直接面，会问有没有参加秋招 面试过程中面试官提了哪些问题对加班的看法为什么不选择财务我的职业规划有没有参加秋招春招准备参加与否家乡 父母的工作 二面 对函数式编程了解说一下 纯函数，偏应用，柯里化，compose 分别是什么 写一下柯里化 apply，call，bind 的区别 一段代码 setTimeout(function() { console.log(1) }, 0); new Promise(functionexecutor(resolve) { console.log(2); for (var i = 0; i &lt; 10000; i++) { i == 9999&amp;&amp; resolve(); } console.log(3); }).then(function() { console.log(4); }); console.log(5);为什么 3 不打印（这里说错了，应该是打印的），1 最后打印 说一下事件循环 BFC 和 IFC 有了解吗，BFC 特性及条件 盒模型 css 画一个平行四边形，translate 浏览器输入 url 到渲染 缓存 状态码了解哪些，301 和 302 区别 option 方法知道吗 排序算法，事件复杂度，归并，快排，堆排的应用场景 CSRF 原理及防御 ES6 用过哪些 最近收获较大的一篇文章及收获 设计消息通知，比如点赞，评论这些通知二面面试官特别好，不会的地方都会跟你讲一下。最后一题不会说没关系，应届生系统设计和代码实践能力确实差一点，这一题是加分题。然后通知 10 分钟后三面 三面 顺时针打印矩阵https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&amp;tqId=11172&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking（如果没过肯定就是因为这题，面试官都快把答案说出来了我还是没做出来） http 和 https 区别及建立连接的过程 instanceof 原理（代码） 寻找二叉树中路径是否存在某条值等给定值的路径，看我算法比较差就让我说了思路 自己写的爬虫里面的一些细节及如何处理反爬 最有成就感的一件事","categories":[{"name":"前端面试题","slug":"前端面试题","permalink":"http://www.bluedream.top/categories/前端面试题/"}],"tags":[{"name":"面试问题","slug":"面试问题","permalink":"http://www.bluedream.top/tags/面试问题/"},{"name":"面试经验","slug":"面试经验","permalink":"http://www.bluedream.top/tags/面试经验/"},{"name":"字节跳动","slug":"字节跳动","permalink":"http://www.bluedream.top/tags/字节跳动/"}]},{"title":"JavaScript类、对象和继承","slug":"JavaScript类、对象和继承","date":"2019-09-05T13:10:40.000Z","updated":"2019-09-20T01:34:49.217Z","comments":true,"path":"前端知识点/JavaScript类、对象和继承.html","link":"","permalink":"http://www.bluedream.top/前端知识点/JavaScript类、对象和继承.html","excerpt":"","text":"类的定义、实例化JavaScript如何实现一个类，怎么实例化这个类？ 构造函数法（this + prototype） – 用 new 关键字 生成实例对象缺点：用到了 this 和 prototype，编写复杂，可读性差 123456789function Mobile(name, price)&#123; this.name = name;//通过this，表明这是一个构造函数 this.price = price; &#125; Mobile.prototype.sell = function()&#123; alert(this.name + \"，售价 $\" + this.price); &#125; var iPhone7 = new Mobile(\"iPhone7\", 1000); iPhone7.sell(); Object.create 法 – 用 Object.create() 生成实例对象缺点：不能实现私有属性和私有方法，实例对象之间也不能共享数据 1234567891011121314151617181920var Person = &#123; firstname: \"Mark\", lastname: \"Yun\", age: 25, introduce: function()&#123; alert('I am ' + Person.firstname + ' ' + Person.lastname); &#125;&#125;;var person = Object.create(Person);person.introduce();// Object.create 要求 IE9+，低版本浏览器可以自行部署：if (!Object.create) &#123; Object.create = function (o) &#123; function F() &#123;&#125; F.prototype = o; return new F(); &#125;; &#125; 极简主义法（消除 this 和 prototype） – 调用 createNew() 得到实例对象优点：容易理解，结构清晰优雅，符合传统的”面向对象编程”的构造 12345678910111213141516171819var Cat = &#123; age: 3, // 共享数据 -- 定义在类对象内，createNew() 外 createNew: function () &#123; var cat = &#123;&#125;; // var cat = Animal.createNew(); // 继承 Animal 类 cat.name = \"小咪\"; var sound = \"喵喵喵\"; // 私有属性--定义在 createNew() 内，输出对象外 cat.makeSound = function () &#123; alert(sound); // 暴露私有属性 &#125;; cat.changeAge = function(num)&#123; Cat.age = num; // 修改共享数据 &#125;; return cat; // 输出对象 &#125;&#125;;var cat = Cat.createNew();cat.makeSound(); ES6 语法糖 class – 用 new 关键字 生成实例对象类的实例化很简单，直接 new 出来即可。函数可以作为构造函数来使用，通过 new 来实例化，其实函数本身也是一个对象。 1234567891011 class Point &#123; constructor(x, y) &#123; this.x = x;//可以在构造函数里写属性 this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125; &#125;var point = new Point(2, 3); 对象什么是面向对象？面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。 面向对象和面向过程的异同 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。 面向对象的三大特性 封装 继承 多态 谈谈This对象的理解 this总是指向函数的直接调用者（而非间接调用者） 如果有new关键字，this指向new出来的那个对象 在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent（触发事件）中的this总是指向全局对象Window 原型的constructor属性问题：已知A继承了B，B继承了C。怎么判断 a 是由A直接生成的实例，还是B直接生成的实例呢？还是C直接生成的实例呢？ 分析：这就要用到原型的constructor属性了。 foo.__proto__.constructor === M的结果为true，但是 foo.__proto__.constructor === Object的结果为false。 所以，用 consturctor判断就比用 instanceof判断，更为严谨。 new 操作符具体干了什么呢?12function Test()&#123;&#125;const test = new Test() 创建一个新的空对象实例。 1const obj = &#123;&#125; 设置新对象的 constructor 属性为构造函数的名称，设置新对象的proto属性指向构造函数的 prototype 对象（设置原型链） 12obj.constructor = Testobj.__proto__ = Test.prototype 使用新对象调用函数，函数中的 this 被指向新实例对象（执行构造函数，传入相应的参数，如果没有参数就不用传；让 Func 中的 this 指向 obj，并执行 Func 的函数体） 1Test.call(obj) 将初始化完毕的新对象地址，保存到等号左边的变量中。判断 Func 的返回值类型： 如果无返回值或者返回一个非对象值，则就将步骤（1）创建的对象返回；如果返回值是一个新对象的话那么直接直接返回该对象。 new操作符具体干了什么呢? 创建一个空实例对象，并且 this 变量引用该对象，同时还继承了该函数的原型 属性和方法被加入到 this 引用的对象中 新创建的对象由 this 所引用，并且最后隐式的返回 this call() 和 apply() 的含义和区别？含义： call：调用一个对象的一个方法，用另一个对象替换当前对象。 例如：B.call(A, args1,args2);即 A 对象调用 B 对象的方法。 apply：调用一个对象的一个方法，用另一个对象替换当前对象。 例如：B.apply(A, arguments);即 A 对象应用 B 对象的方法。 相同点： 方法的含义是一样的，即方法功能是一样的； 第一个参数的作用是一样的； 不同点：两者传入的列表形式不一样 call 可以传入多个参数； apply 只能传入两个参数，所以其第二个参数往往是作为数组形式传入 javascript 的本地对象，内置对象和宿主对象 本地对象ECMA-262 把本地对象（native object）定义为“独立于宿主环境的 ECMAScript 实现提供的对象”。简单来说，本地对象就是 ECMA-262 定义的类（引用类型）。它们包括：Object、Function、Array、String、Boolean、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError 内置对象JS中内置了17个对象，常用的是Array对象、Date对象、正则表达式对象、string对象、Global对象 宿主对象由ECMAScript实现的宿主环境提供的对象，可以理解为：浏览器提供的对象。所有的BOM和DOM都是宿主对象。 如何判断一个对象是否属于某个类？instanceof 123if (a instanceof Person) &#123; alert(\"yes\");&#125; 对象的几种创建方式 javascript创建对象简单的说,无非就是用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用 第一种：内置对象Object 创建1234567var wcDog =new Object(); wcDog.name=&quot;旺财&quot;; wcDog.age=3; wcDog.work=function()&#123; alert(&quot;我是&quot;+wcDog.name+&quot;,汪汪汪......&quot;); &#125; wcDog.work(); 123var Person = new Object();Person.name = \"Nike\";Person.age = 29; 这行代码创建了 Object 引用类型的一个新实例，然后把实例保存在变量 Person 中。 第二种：使用对象字面量表示法12345var Person = &#123;&#125;; //相当于 var Person = new Object();var Person = &#123; name: 'Nike'; age: 29;&#125; 对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。也就是说，第一种和第二种方式创建对象的方法其实都是一样的，只是写法上的区别不同 在介绍第三种的创建方法之前，我们应该要明白为什么还要用别的方法来创建对象，也就是第一种，第二种方法的缺点所在：它们都是用了同一个接口创建很多对象，会产生大量的重复代码，就是如果你有 100 个对象，那你要输入 100 次很多相同的代码。那我们有什么方法来避免过多的重复代码呢，就是把创建对象的过程封装在函数体内，通过函数的调用直接生成对象。 第三种：使用工厂模式创建对象123456789101112function createPerson(name, age, job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function() &#123; alert(this.name); &#125;; return o;&#125;var person1 = createPerson(\"Nike\", 29, \"teacher\");var person2 = createPerson(\"Arvin\", 20, \"student\"); 在使用工厂模式创建对象的时候，我们都可以注意到，在 createPerson 函数中，返回的是一个对象。那么我们就无法判断返回的对象究竟是一个什么样的类型。于是就出现了第四种创建对象的模式。 第四种:使用构造函数创建对象12345678910function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; alert(this.name); &#125;;&#125;var person1 = new Person(\"Nike\", 29, \"teacher\");var person2 = new Person(\"Arvin\", 20, \"student\"); 对比工厂模式，我们可以发现以下区别： 1.没有显示地创建对象 2.直接将属性和方法赋给了 this 对象 3.没有 return 语句 4.终于可以识别的对象的类型。对于检测对象类型，我们应该使用 instanceof 操作符，我们来进行自主检测： 1234567alert(person1 instanceof Object); //turealert(person1 instanceof Person); //turealert(person2 instanceof Object); //turealert(person2 instanceof Object); //ture 同时我们也应该明白，按照惯例，构造函数始终要应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。 那么构造函数确实挺好用的，但是它也有它的缺点： 就是每个方法都要在每个实例上重新创建一遍，方法指的就是我们在对象里面定义的函数。如果方法的数量很多，就会占用很多不必要的内存。于是出现了第五种创建对象的方法 第五种：原型创建对象模式1234567function Dog()&#123;&#125;Dog.prototype.name=&quot;旺财&quot;;Dog.prototype.eat=function()&#123; alert(this.name+&quot;是个吃货&quot;);&#125;var wangcai =new Dog();wangcai.eat(); 123456789function Person() &#123;&#125;Person.prototype.name = \"Nike\";Person.prototype.age = 20;Person.prototype.jbo = \"teacher\";Person.prototype.sayName = function() &#123; alert(this.name);&#125;;var person1 = new Person();person1.sayName(); 使用原型创建对象的方式，可以让所有对象实例共享它所包含的属性和方法。 如果是使用原型创建对象模式，请看下面代码： 123456789101112function Person() &#123;&#125;Person.prototype.name = \"Nike\";Person.prototype.age = 20;Person.prototype.jbo = \"teacher\";Person.prototype.sayName = function() &#123; alert(this.name);&#125;;var person1 = new Person();var person2 = new Person();person1.name = \"Greg\";alert(person1.name); //'Greg' --来自实例alert(person2.name); //'Nike' --来自原型 当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性。 这时候我们就可以使用构造函数模式与原型模式结合的方式，构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性 第六种：组合使用构造函数模式和原型模式123456789101112function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job;&#125;Person.prototype = &#123; constructor: Person, sayName: function() &#123; alert(this.name); &#125;;&#125;var person1 = new Person('Nike', 20, 'teacher'); 123456789function Car(name,price)&#123; this.name=name; this.price=price; &#125; Car.prototype.sell=function()&#123; alert(&quot;我是&quot;+this.name+&quot;，我现在卖&quot;+this.price+&quot;万元&quot;); &#125; var camry =new Car(&quot;凯美瑞&quot;,27); camry.sell(); 用function来模拟无参的构造函数 123456789 function Person()&#123;&#125; //定义一个function，如果使用new&quot;实例化&quot;,该function可以看作是一个Class var person=new Person(); person.name=&quot;Mark&quot;; person.age=&quot;25&quot;; person.work=function()&#123; alert(person.name+&quot; hello...&quot;); &#125;person.work(); 用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性） 12345678910function Pet(name,age,hobby)&#123; this.name=name;//this作用域：当前对象 this.age=age; this.hobby=hobby; this.eat=function()&#123; alert(&quot;我叫&quot;+this.name+&quot;,我喜欢&quot;+this.hobby+&quot;,是个程序员&quot;); &#125; &#125; var maidou =new Pet(&quot;麦兜&quot;,25,&quot;coding&quot;);//实例化、创建对象 maidou.eat();//调用eat方法 继承 继承的本质就是原型链。（这些问题必问的，其实就是考察你对原型链的掌握程度。） Javascript如何实现继承？ 构造函数绑定：使用 call 或 apply 方法，将父对象的构造函数绑定在子对象上 12345function Cat(name,color)&#123; Animal.apply(this, arguments); this.name = name; this.color = color;&#125; 实例继承：将子对象的 prototype 指向父对象的一个实例 12Cat.prototype = new Animal();Cat.prototype.constructor = Cat; 拷贝继承：如果把父对象的所有属性和方法，拷贝进子对象 12345678function extend(Child, Parent) &#123; var p = Parent.prototype; var c = Child.prototype; for (var i in p) &#123; c[i] = p[i]; &#125; c.uber = p; &#125; 原型继承：将子对象的 prototype 指向父对象的 prototype 1234567function extend(Child, Parent) &#123; var F = function()&#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child; Child.uber = Parent.prototype;&#125; ES6 语法糖 extends：class ColorPoint extends Point {} 123456789class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y) this.color = color; &#125; toString() &#123; return this.color + ' ' + super.toString(); // 调用父类的toString() &#125;&#125; 原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式 12345678910111213function Parent()&#123; this.name = &apos;wang&apos;; &#125; function Child()&#123; this.age = 28; &#125; Child.prototype = new Parent();//继承了Parent，通过原型 var demo = new Child(); alert(demo.age); alert(demo.name);//得到被继承的属性 &#125; JavaScript 继承方式和优缺点原型链继承1234567891011121314151617function Parent () &#123; this.name = 'kevin';&#125;Parent.prototype.getName = function () &#123; console.log(this.name);&#125;function Child () &#123;&#125;Child.prototype = new Parent();var child1 = new Child();console.log(child1.getName()) // kevin 缺点： 1.引用类型的属性被所有实例共享，举个例子： 12345678910111213141516171819function Parent () &#123; this.names = ['kevin', 'daisy'];&#125;function Child () &#123;&#125;Child.prototype = new Parent();var child1 = new Child();child1.names.push('yayu');console.log(child1.names); // [\"kevin\", \"daisy\", \"yayu\"]var child2 = new Child();console.log(child2.names); // [\"kevin\", \"daisy\", \"yayu\"] 2.在创建 Child 的实例时，不能向Parent传参 3.字面量重写原型会中断关系，使用引用类型的原型 借用构造函数(经典继承)1234567891011121314151617function Parent () &#123; this.names = ['kevin', 'daisy'];&#125;function Child () &#123; Parent.call(this);&#125;var child1 = new Child();child1.names.push('yayu');console.log(child1.names); // [\"kevin\", \"daisy\", \"yayu\"]var child2 = new Child();console.log(child2.names); // [\"kevin\", \"daisy\"] 优点： 1.避免了引用类型的属性被所有实例共享 2.可以在 Child 中向 Parent 传参 举个例子： 123456789101112131415function Parent (name) &#123; this.name = name;&#125;function Child (name) &#123; Parent.call(this, name);&#125;var child1 = new Child('kevin');console.log(child1.name); // kevinvar child2 = new Child('daisy');console.log(child2.name); // daisy 缺点： 方法都在构造函数中定义，每次创建实例都会创建一遍方法。 没有原型，则复用无从谈起。 组合继承原型链继承和经典继承双剑合璧。 1234567891011121314151617181920212223242526272829303132function Parent (name) &#123; this.name = name; this.colors = ['red', 'blue', 'green'];&#125;Parent.prototype.getName = function () &#123; console.log(this.name)&#125;function Child (name, age) &#123; Parent.call(this, name); this.age = age;&#125;Child.prototype = new Parent();var child1 = new Child('kevin', '18');child1.colors.push('black');console.log(child1.name); // kevinconsole.log(child1.age); // 18console.log(child1.colors); // [\"red\", \"blue\", \"green\", \"black\"]var child2 = new Child('daisy', '20');console.log(child2.name); // daisyconsole.log(child2.age); // 20console.log(child2.colors); // [\"red\", \"blue\", \"green\"] 优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。 其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。 原型式继承12345function createObj(o) &#123; function F()&#123;&#125; F.prototype = o; return new F();&#125; 就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。 缺点： 包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。 12345678910111213var person = &#123; name: 'kevin', friends: ['daisy', 'kelly']&#125;var person1 = createObj(person);var person2 = createObj(person);person1.name = 'person1';console.log(person2.name); // kevinperson1.firends.push('taylor');console.log(person2.friends); // [\"daisy\", \"kelly\", \"taylor\"] 注意：修改person1.name的值，person2.name的值并未发生改变，并不是因为person1和person2有独立的 name 值，而是因为person1.name = &#39;person1&#39;，给person1添加了 name 值，并非修改了原型上的 name 值。 寄生式继承创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。 1234567function createObj (o) &#123; var clone = object.create(o); clone.sayName = function () &#123; console.log('hi'); &#125; return clone;&#125; 缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。 寄生组合式继承为了方便大家阅读，在这里重复一下组合继承的代码： 12345678910111213141516171819function Parent (name) &#123; this.name = name; this.colors = ['red', 'blue', 'green'];&#125;Parent.prototype.getName = function () &#123; console.log(this.name)&#125;function Child (name, age) &#123; Parent.call(this, name); this.age = age;&#125;Child.prototype = new Parent();var child1 = new Child('kevin', '18');console.log(child1) 组合继承最大的缺点是会调用两次父构造函数。 一次是设置子类型实例的原型的时候： 1Child.prototype = new Parent(); 一次在创建子类型实例的时候： 1var child1 = new Child('kevin', '18'); 回想下 new 的模拟实现，其实在这句中，我们会执行： 1Parent.call(this, name); 在这里，我们又会调用了一次 Parent 构造函数。 所以，在这个例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为colors，属性值为[&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;]。 那么我们该如何精益求精，避免这一次重复调用呢？ 如果我们不使用 Child.prototype = new Parent() ，而是间接的让 Child.prototype 访问到 Parent.prototype 呢？ 看看如何实现： 12345678910111213141516171819202122232425function Parent (name) &#123; this.name = name; this.colors = ['red', 'blue', 'green'];&#125;Parent.prototype.getName = function () &#123; console.log(this.name)&#125;function Child (name, age) &#123; Parent.call(this, name); this.age = age;&#125;// 关键的三步var F = function () &#123;&#125;;F.prototype = Parent.prototype;Child.prototype = new F();var child1 = new Child('kevin', '18');console.log(child1); 最后我们封装一下这个继承方法： 1234567891011121314function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;function prototype(child, parent) &#123; var prototype = object(parent.prototype); prototype.constructor = child; child.prototype = prototype;&#125;// 当我们使用的时候：prototype(Child, Parent); 优点：引用《JavaScript高级程序设计》中对寄生组合式继承的夸赞就是： 1.这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。 2.与此同时，原型链还能保持不变； 3.因此，还能够正常使用 instanceof 和 isPrototypeOf。 开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。 如何避免原型链上面的对象共享避免对象共享可以参考经典的 extend()函数，很多前端框架都有封装的，就是用一个空函数当做中间变量","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"http://www.bluedream.top/categories/前端知识点/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.bluedream.top/tags/JavaScript/"},{"name":"面向对象","slug":"面向对象","permalink":"http://www.bluedream.top/tags/面向对象/"},{"name":"类","slug":"类","permalink":"http://www.bluedream.top/tags/类/"},{"name":"对象","slug":"对象","permalink":"http://www.bluedream.top/tags/对象/"},{"name":"继承","slug":"继承","permalink":"http://www.bluedream.top/tags/继承/"}]},{"title":"面试问题","slug":"面试问题","date":"2019-09-02T07:30:21.000Z","updated":"2019-09-18T10:14:06.857Z","comments":true,"path":"前端面试题/面试问题.html","link":"","permalink":"http://www.bluedream.top/前端面试题/面试问题.html","excerpt":"","text":"面试是一个非常重要的过程，有些人在这个过程中感到不知所措，或者做得不好，使自己在求职中因小失大，达不到成功。在求职过程中注意了以下基本礼仪和技巧，才能达到事半功倍，增强面试的有效性。 面试前准备（1）穿着得体，干净。 （2）对公司做简单的了解 （3）保证充足睡眠，保持自信 注意事项(1)一旦约好面试时间，一定要提前 5-10 分钟到达地点，以表示求职者的诚意，给对方以信任感。 (2)面试时不要紧张，保持微笑，如果门关着，应先敲门，得到允许后再进去。开关门动作要轻。 (3) 对于面试官的问题要一一回答，可以适当点头，不要打断用人单位的问话或抢问抢答。回答问题是眼睛要注视面试官，切记不要左顾右盼。 谈话技巧(1)自我介绍在三分钟之内，口齿清晰，语言流利，吐字清晰。 (2) 注意听者的反应。比如，听者心不在焉，可能表示他对自己这段话没有兴趣，你得设法转移话题；侧耳倾听，可能说明由于自己音量过小使对方难于听清；皱眉、摆头可能表示自己言语有不当之处。根据对方的这些反应，就要适时地调整自己的语言、语调、语气、音量、修辞，包括陈述内容。这样才能取得良好的面试效果。 (3) 表示关注的手势。在与他人交谈中，一定要对对方的谈话表示关注，要表示出你在聚精会神地听。对方在感到自己的谈话被人关注和理解后，才能愉快专心地听取你的谈话，并对你产生好感。 回答问题的技巧(1) 把握重点，简捷明了，条理清楚，有理有据。一般情况下回答问题要结论在先，议论在后，先将自己的中心意思表达清晰，然后再做叙述和论证。否则，长篇大论，会让人不得要领。面试时间有限，神经有些紧张，多余的话太多，容易走题，反倒会将主题冲淡或漏掉。 (2) 讲清原委，避免抽象。 用人单位提问总是想了解一些应试者的具体情况，切不可简单地仅以“是”和“否”作答。应针对所提问题的不同，有的需要解释原因，有的需要说明程度。不讲原委，过于抽象的回答，往往不会给主试者留下具体的印象。 (3) 确认提问内容，切忌答非所问。面试中，如果对用人单位提出的问题，一时摸不到边际，以致不知从何答起或难以理解对方问题的含义时，可将问题复述一遍，并先谈自己对这一问题的理解，请教对方以确认内容。对不太明确的问题，一定要搞清楚，这样才会有的放矢，不致答非所问。 (4) 有个人见解，有个人特色。用人单位有时接待应试者若干名，相同的问题问若干遍，类似的回答也要听若干遍。因此，用人单位会有乏味、枯燥之感。只有具有独到的个人见解和个人特色的回答，才会引起对方的兴趣和注意。 (5) 知之为知之，不知为不知。面试遇到自己不知、不懂、不会的问题时，回避闪烁，默不作声，牵强附会，不懂装懂的做法均不足取，诚恳坦率地承认自己的不足之处，反倒会赢得主试者的信任和好感。 总结：保持自信，做自我介绍时，时间应控制在三分钟之内，不要啰嗦，把自己取得过什么成就，或者在公司做过什么贡献，总结自己的优势时刻保持微笑。最后，紧张的同学，可以把面试官当做同事，面试是一个相互选择的过程，你找我我还不一定干呢。 请你自我介绍一下你自己回答提示：一般人回答这个问题过于平常，只说姓名、年龄、爱好、工作经验，这些在简历上都有，其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，这些都可以和学习无关，也可以和学习有关，但要突出积极的个性和做事的能力，说得合情合理企业才会相信。企业很重视一个人的礼貌，求职者要尊重考官，在回答每个问题之后都说一句“谢谢”。企业喜欢有礼貌的求职者。 回答样本： 1、我叫xxx,来自于xxx，从网上看得到公司招聘的这个职位，觉得非常适合自己的发展。所以来这里争取下这份工作。2、接下来可以讲解自己的核心竞争力（最强的技能、最深入研究的知识领域、个性中最积极的部分）和闪光点（做过的最成功的事，主要的成就）。核心就是要体现自己胜任这份工作（介绍时候要自然有底气，合情合理，面试前要充分准备好）。3、先介绍到这里，面试官看看有什么问题，我可以再补充。4、最后要说谢谢，任何企业都喜欢有礼貌的人！ 注意：自曝其短（说自己的缺点）没有必要，自我介绍的时候千万不要和简历有冲突！ 你觉得你个性上最大的优点是什么？回答提示：沉着冷静、条理清楚、立场坚定、顽强向上、乐于助人和关心他人、适应能力和幽默感、乐观和友爱、技术狂热、学习能力强、为人谦和。 说说你最大的缺点？回答提示：这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼、爱忌妒人、非常懒、脾气大、工作效率低，企业肯定不会录用你。绝对不要自作聪明地回答“我最大的缺点是过于追求完美”，有的人以为这样回答会显得自己比较出色，但事实上，他已经岌芨可危了。企业喜欢求职者从自己的优点说起，中间加一些小缺点，最后再把问题转回到优点上，突出优点的部分。企业喜欢聪明的求职者。 你对加班的看法？回答提示：实际上好多公司问这个问题，并不证明一定要加班。 只是想测试你是否愿意为公司奉献。回答样本：如果是工作需要我会义不容辞加班。我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。 你对薪资的要求？回答提示：如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高，那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求聘的职位定下开支预算，因而他们第一次提出的价钱往往是他们所能给予的最高价钱。他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。 回答样本一：“我对工资没有硬性要求。我相信贵公司在处理我的问题上会友善合理。我注重的是找对工作机会，所以只要条件公平，我则不会计较太多 回答样本二：我受过系统的软件编程的训练，不需要进行大量的培训。而且我本人也对编程特别感兴趣。因此，我希望公司能根据我的情况和市场标准的水平，给我合理的薪水。 回答样本三：如果你必须自己说出具体数目，请不要说一个宽泛的范围，那样你将只能得到最低限度的数字。最好给出一个具体的数字，这样表明你已经对当今的人才市场作了调查，知道像自己这样学历的雇员有什么样的价值。 我们先来了解面试官如何评判应聘者的工资，知己知彼才能对症下药啊！ 一些正规的大公司主要是根据以下四个方面进行评判（重要性从上至下） 1、掌握的技术（通过笔试、项目经验、工作时间）2、表达3、学历4、其他素质（如英语四六级等） 面试官评判应聘者工资的重要性之所以采取如此的顺序，根本原因在于面试官最最重要的是程序员能不能把工作做好，让公司放心。所以学员技术很重要，表达也很重要（技术牛但不会表达，也会让人怀疑技术实力） 当 HR 问：你对薪资有什么要求？大家找工作，都希望找个高薪的，那我们如何和公司去谈薪酬呢？如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高，那又会显得你分量过重，公司受用不起。这个问题确实是个比较难于回答的问题，处理不好的话，会影响面试的效果，但又是不可避免的一个现实问题。 对于这个问题，第一首先要知道程序员等级、技能、工资的绑定情况，因为我们前端工程师主要是看技术。技术实力决定了我们的月薪；第二要打探出公司能给出的薪资范围。在这个范围内争取高薪资。 回答提示： 第一步是了解对方可以提供的薪酬幅度是多少，这里的关键是善于发问，让对方多讲，而自己了解足够的信息。当经过几轮面试后，面试官会问应聘者：你还有什么想了解的问题吗？应聘者就可问：像你们这样的大企业都有自己的一套薪酬体系，请问可以简单介绍一下吗？面试官一般就会简单介绍一下，如果介绍得不是太详细，还可以问：贵公司的薪酬水平在同行业中的位置是怎样的？除了工资之外还有哪些奖金、福利和培训机会？试用期后工资的加幅是多少？等问题。从对方的回答中，你再对照一下市场行情心里就有底了。 第二步是根据以上信息，提出自己的期望薪酬。如果对自己想提的薪资还是把握不准，那也可以把问题抛给对方：我想请教一个问题，以我现在的经历、学历和您对我面试的了解，在公司的薪酬体系中大约能达到怎么样的水平？对方就会透露给你准备开的工资水平。 迂回战术求高薪如果你对该公司开出的薪资标准不太满意，就可以尝试用探讨式、协商式的口气去争取高一些：比如我认为工作最重要的是合作开心，薪酬是其次的，不过我原来的月薪是××元，如果跳槽的话就希望自己能有点进步，如果不是让您太为难的话，您看这个工资是不是可以有一点提高？这时要看对方的口气是否可以松动，松动的话则可以再举出你值更高价的理由。 如果对方的口气坚决，则可以迂回争取试用期的缩短，比如说：我对自己是比较有自信的，您看能不能一步到位直接拿转正期的工资，或者把３个月的试用期缩短为１个月？额外工资多争取。 很多企业除了正式的工资以外，都会产生一些奖金、福利等额外工资，在这方面应聘者就要大胆争取了。应聘者要注意察言观色见好就收，不要过度要求，否则让对方破例后，到时你进来后对方也会以更高的要求来考核你，还可能答应了最后也不兑现。为了保险起见，应聘者最好让对方在接收函上写明薪酬、试用期限、上班时间等，这样可免去日后口说无凭的纠纷。 总之，好的薪水是要靠势力得到的,但多调查和多注意这方面的资讯,使自己在面试前做到对这个职位的大致薪水有个了解,就会使你不至于提太高或太低不切实际的要求,从而失去到手的工作。 HR 指责要薪太高怎么办？想象下，当你实事求是的按照以上的方法报出自己的工资为 7000 元的时候，面试官呵呵笑道：“你是应届生，却要求 7000 元的工资，是不是太高了？”此时，你该怎么办？ 回答提示： 1、北京的生活成本高，3000元在北京生存很艰难，在饭店工作也可能不值这个，北京的web前端平均工资我也是有过了解的。同学大都是这个工资（注意：这个同学可以向HR强调是平时一起讨论问题的同学，暗示水平差不多)；2、上几家都给我6千了，我没有去（觉得自己值多少钱，那就是值多少）；3、我不是乱要价，我有能力完成完成上级交代的任务，创造出超过7000元价值的能力（强调自己的能力）；4、对技术狂热，会沿着前端道路一直往前走（强调自己对这份工作的热爱）；5、再说公司会有试用期，试用期可以低于7000，我会在这个阶段证明我自己的能力，可以如果没有达到，公司也可以开除我。 在五年的时间内，你的职业规划？回答提示：这是每一个应聘者都不希望被问到的问题，但是几乎每个人都会被问到。比较多的答案是“管理者”。但是近几年来，许多公司都已经建立了专门的技术途径。这些工作地位往往被称作“顾问”、“参议技师”或“高级软件工程师”等等。当然，说出其他一些你感兴趣的职位也是可以的，比如产品销售部经理，生产部经理等一些与你的专业有相关背景的工作。要知道，考官总是喜欢有进取心的应聘者，此时如果说“不知道”，或许就会使你丧失一个好机会。最普通的回答应该是 “我准备在技术领域有所作为”或“我希望能按照公司的管理思路发展”。 你朋友对你的评价？回答提示： 想从侧面了解一下你的性格及与人相处的问题。回答样本：“我的朋友都说我是一个可以信赖的人。因为，我一旦答应别人的事情，就一定会做到。如果我做不到，我就不会轻易许诺。回答样本：”我觉的我是一个比较随和的人，与不同的人都可以友好相处。在我与人相处时，我总是能站在别人的角度考虑问题“ 你还有什么问题要问吗？回答提示：企业的这个问题看上去可有可无，其实很关键，企业不喜欢说“没有问题”的人，因为其很注重员工的个性和创新能力。企业不喜欢求职者问个人福利之类的问题，如果有人这样问：贵公司对新入公司的员工有没有什么培训项目，我可以参加吗？或者说贵公司的晋升机制是什么样的？企业将很欢迎，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。 如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？回答提示：一段时间发现工作不适合我，有两种情况： 1、如果你确实热爱这个职业，那你就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距； 2、你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。 在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？①.原则上我会尊重和服从领导的工作安排；同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法；② 如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作；③.还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见；如领导仍固执己见，我会毫不犹豫地再向上级领导反映。 你希望与什么样的上级共事？① 通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识，这既上一个陷阱，又是一次机会；② 最好回避对上级具体的希望，多谈对自己的要求；③ 如“做为刚步入社会的新人，我应该多要求自己尽快熟悉环境、适应环境，而不应该对环境提出什么要求，只要能发挥我的专长就可以了 分析：这个问题比较好的回答是，希望我的上级能够在工作中对我多指导，对我工作中的错误能够立即指出。总之，从上级指导这个方面谈，不会有大的纰漏。 在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？①.原则上我会尊重和服从领导的工作安排；同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法；② 如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作；③.还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见；如领导仍固执己见，我会毫不犹豫地再向上级领导反映。 与上级意见不一致，你将怎么办？① 一般可以这样回答“我会给上级以必要的解释和提醒，在这种情况下，我会服从上级的意见。”② 如果面试你的是总经理，而你所应聘的职位另有一位经理，且这位经理当时不在场，可以这样回答：“对于非原则性问题，我会服从上级的意见，对于涉及公司利益的重大问题，我希望能向更高层领导反映。” 分析：这个问题的标准答案是思路 1，如果用 2 的回答，必死无疑。你没有摸清楚改公司的内部情况，先想打小报告，这样的人没有人敢要。 如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？回答提示：我首先不会找那位上级领导说明这件事，我会主动找我的主管领导来沟通，因为沟通是解决人际关系的最好办法，但结果会有两种：我的主管领导认识到自己的错误，我想我会视具体情况决定是否原谅他；2.他更加变本加厉的来威胁我，那我会毫不犹豫地找我的上级领导反映此事，因为他这样做会造成负面影响，对今后的工作不利。 如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？① 我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决；② 是责任问题。分清责任，各负其责，如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸，作为一个团队，需要互相提携共同完成工作，安慰同事并且帮助同事查找原因总结经验。③ 总结经验教训，一个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中吸取经验教训，并在今后的工作中避免发生同类的错误。检讨自己的工作方法、分析问题的深度和力度是否不够，以致出现了本可以避免的错误。 如果你在这次考试中没有被录用，你怎么打算？回答提示：现在的社会是一个竞争的社会,从这次面试中也可看出这一点,有竞争就必然有优劣,有成功必定就会有失败.往往成功的背后有许多的困难和挫折,如果这次失败了也仅仅是一次而已,只有经过经验经历的积累才能塑造出一个完全的成功者。我会从以下几个方面来正确看待这次失败. 第一、要敢于面对,面对这次失败不气馁,接受已经失去了这次机会就不会回头这个现实,从心理意志和精神上体现出对这次失败的抵抗力。要有自信,相信自己经历了这次之后经过努力一定能行.能够超越自我. 第二、善于反思,对于这次面试经验要认真总结,思考剖析,能够从自身的角度找差距。正确对待自己,实事求是地评价自己,辩证的看待自己的长短得失,做一个明白人. 第三、走出阴影,要克服这一次失败带给自己的心理压力,时刻牢记自己弱点,防患于未然,加强学习,提高自身素质. 第四、认真工作,回到原单位岗位上后,要实实在在、踏踏实实地工作,三十六行,行行出状元,争取在本岗位上做出一定的成绩. 第五、再接再厉,成为软件工程师或网络工程师一直是我的梦想,以后如果有机会我仍然后再次参加竞争. 谈谈你对跳槽的看法？（1）正常的”跳槽”能促进人才合理流动，应该支持；（2）频繁的跳槽对单位和个人双方都不利，应该反对。 工作中你难以和同事、上司相处，你该怎么办？① 我会服从领导的指挥，配合同事的工作。② 我会从自身找原因，仔细分析是不是自己工作做得不好让领导不满意，同事看不惯。还要看看是不是为人处世方面做得不好。如果是这样的话 我会努力改正。③ 如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足。有问题就及时改正。④ 作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看见我在努力，总有一天会对我微笑的！ 假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？① 成绩比较突出，得到领导的肯定是件好事情，以后更加努力② 检讨一下自己是不是对工作的热心度超过同事间交往的热心了，加强同事间的交往及共同的兴趣爱好。③ 工作中，切勿伤害别人的自尊心④ 不再领导前拨弄是非⑤ 乐于助人对面 你最近是否参加了培训课程？谈谈培训课程的内容。是公司资助还是自费参加？回答提示：请自行根据自己情况做回答，这个没有统一标准答案。 你对于我们公司了解多少？回答提示：在去公司面试前上网查一下该公司主营业务。 请说出你选择这份工作的动机？你为什么选择我们公司？1.面试前，对应聘公司各方面，要了解详尽！至少要了解到行业、企业、岗位这三方面！最好要准备一些具体的数据和实例！2.面试时候，可以将之前对公司的了解（行业、企业、数据、实例）结合自己的面试岗位，大略的说一遍，然后强调自己“觉得这个工作合适”即可。3.如果对这个行业确实很喜欢，要说出你对这个行业的认识与热爱。 你最擅长的技术方向是什么？回答提示：说和你要应聘的职位相关的课程，表现一下自己的热诚没有什么坏处。 你能为我们公司带来什么呢？① 假如你可以的话，试着告诉他们你可以减低他们的费用——“我已经接受过专业的培训或者工作 X 年，立刻就可以上岗工作”。② 企业很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后说：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多的收益”。企业喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以说：“我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需求和消费。”等等。 最能概括你自己的三个词是什么？回答提示：我经常用的三个词是适应能力强，有责任心和做事有始终，结合具体例子向主考官解释。 你的业余爱好是什么？回答提示：找一些富于团体合作精神的，这里有一个真实的故事：有人被否决掉，因为他的爱好是深海潜水。主考官说：因为这是一项单人活动，我不敢肯定他能否适应团体工作。 作为被面试者给我打一下分回答提示：试着列出四个优点和一个非常非常非常小的缺点，（可以抱怨一下事实，没有明确责任人的缺点是不会有人介意的）。 你怎么理解你应聘的职位？回答提示：把岗位职责和任务及工作态度阐述一下 喜欢这份工作的哪一点？回答提示：相信其实大家心中一定都有答案了吧！每个人的价值观不同，自然评断的标准也会不同，但是，在回答面试官这个问题时可不能太直接就把自己心理的话说出来，尤其是薪资方面的问题，不过一些无伤大雅的回答是不错的考虑，如交通方便，工作性质及内容颇能符合自己的兴趣等等都是不错的答案，不过如果这时自己能仔细思考出这份工作的与众不同之处，相信在面试上会大大加分。 为什么要离职?您在前一家公司的离职原因是什么?① 回答这个问题时一定要小心，就算在前一个工作受到再大的委屈，对公司有多少的怨言，都千万不要表现出来，尤其要避免对公司本身主管的批评，避免面试官的负面情绪及印象；建议此时最好的回答方式是将问题归咎在自己身上，例如觉得工作没有学习发展的空间，自己想在面试工作的相关产业中多加学习，或是前一份工作与自己的生涯规划不合等等，回答的答案最好是积极正面的。② 我希望能获得一份更好的工作，如果机会来临，我会抓住；我觉得目前的工作，已经达到顶峰，即沒有升迁机会。③ 最重要的是：应聘者要使找招聘单位相信，应聘者在过往的单位的“离职原因”在此家招聘单位里不存在；④ 避免把“离职原因”说得太详细、太具体；⑤ 不能掺杂主观的负面感受，如“太辛苦”、“人际关系复杂”、“管理太混乱”、“公司不重视人才”、“公司排斥我们某某的员工”等；但也不能躲闪、回避，如“想换换环境”、“个人原因”等；⑥ 不能涉及自己负面的人格特征，如不诚实、懒惰、缺乏责任感、不随和等；尽量使解释的理由为应聘者个人形象添彩； 回答样本：如“我离职是因为这家公司倒闭；我在公司工作了三年多，有较深的感情；从去年始，由于市场形势突变，公司的局面急转直下；到眼下这一步我觉得很遗憾，但还要面对显示，重新寻找能发挥我能力的舞台。”同一个面试问题并非只有一个答案，而同一个答案并不是在任何面试场合都有效，关键在应聘者掌握了规律后，对面试的具体情况进行把握，有意识地揣摩面试官提出问题的心理背景，然后投其所好。 分析：除非是薪资太低，或者是最初的工作，否则不要用薪资作为理由。“求发展”也被考官听得太多，离职理由要根据每个人的真实离职理由来设计，但是在回答时一定要表现得真诚。实在想不出来的时候，家在外地可以说是因为家中有事，须请假几个月，公司又不可能准假，所以辞职。这个答案一般面试官还能接受。 说说你对行业、技术发展趋势的看法？回答提示：企业对这个问题很感兴趣，只有有备而来的求职者能够过关。求职者可以直接在网上查找对你所申请的行业部门的信息，只有深入了解才能产生独特的见解。企业认为最聪明的求职者是对所面试的公司预先了解很多，包括公司各个部门，发展情况，在面试回答问题的时候可以提到所了解的情况，企业欢迎进入企业的人是“知己”，而不是“盲人”。 对工作的期望与目标何在？回答提示：这是面试者用来评断求职者是否对自己有一定程度的期望、对这份工作是否了解的问题。对于工作有确实学习目标的人通常学习较快，对于新工作自然较容易进入状况，这时建议你，最好针对工作的性质找出一个确实的答案，如业务员的工作可以这样回答：“我的目标是能成为一个超级业务员，将公司的产品广泛的推销出去，达到最好的业绩成效；为了达到这个目标，我一定会努力学习，而我相信以我认真负责的态度，一定可以达到这个目标。”其他类的工作也可以比照这个方式来回答，只要在目标方面稍微修改一下就可以了。 说说你的家庭回答提示：企业面试时询问家庭问题不是非要知道求职者家庭的情况，探究隐私，企业不喜欢探究个人隐私，而是要了解家庭背景对求职者的塑造和影响。企业希望听到的重点也在于家庭对求职者的积极影响。企业最喜欢听到的是：我很爱我的家庭！我的家庭一向很和睦，虽然我的父亲和母亲都是普通人，但是从小，我就看到我父亲起早贪黑，每天工作特别勤劳，他的行动无形中培养了我认真负责的态度和勤劳的精神。我母亲为人善良，对人热情，特别乐于助人，所以在单位人缘很好，她的一言一行也一直在教导我做人的道理。企业相信，和睦的家庭关系对一个人的成长有潜移默化的影响。 就你申请的这个职位，你认为你还欠缺什么？回答提示：企业喜欢问求职者弱点，但精明的求职者一般不直接回答。他们希望看到这样的求职者：继续重复自己的优势，然后说：“对于这个职位和我的能力来说，我相信自己是可以胜任的，只是缺乏经验，这个问题我想我可以进入公司以后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。”企业喜欢能够巧妙地躲过难题的求职者。 你欣赏哪种性格的人？回答提示：诚实、不死板而且容易相处的人、有”实际行动”的人。 你通常如何处理別人的批评？① 沈默是金。不必说什么，否则情况更糟，不过我会接受建设性的批评； ② 我会等大家冷靜下来再讨论。 你怎样对待自己的失敗？回答提示：我们大家生来都不是十全十美的，我相信我有第二个机会改正我的错误。 什么会让你有成就感？回答提示：为贵公司竭力效劳；尽我所能，完成一个项目 眼下你生活中最重要的是什么？回答提示：对我来说，能在这个领域找到工作是最重要的；望能在贵公司任职对我说最重要。 你为什么愿意到我们公司来工作？回答提示：对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些详细的原因，像“公司本身的高技术开发环境很吸引我。”，“我同公司出生在同样的时代，我希望能够进入一家与我共同成长的公司。”“你们公司一直都稳定发展，在近几年来在市场上很有竞争力。”或者“我认为贵公司能够给我提供一个与众不同的发展道路。”这都显示出你已经做了一些调查，也说明你对自己的未来有了较为具体的远景规划。 你和别人发生过争执吗？你是怎样解决的？回答提示：这是面试中最险恶的问题。其实是考官布下的一个陷阱。千万不要说任何人的过错。应知成功解决矛盾是一个协作团体中成员所必备的能力。假如你工作在一个服务行业，这个问题简直成了最重要的一个环节。你是否能获得这份工作，将取决于这个问题的回答。考官希望看到你是成熟且乐于奉献的。他们通过这个问题了解你的成熟度和处世能力。在没有外界干涉的情况下，通过妥协的方式来解决才是正确答案。 你做过的哪件事最令自己感到骄傲?回答提示：这是考官给你的一个机会，让你展示自己把握命运的能力。这会体现你潜在的领导能力以及你被提升的可能性。假如你应聘于一个服务性质的单位，你很可能会被邀请去午餐。记住：你的前途取决于你的知识、你的社交能力和综合表现。 你新到一个部门,一天一个客户来找你解决问题,你努力想让他满意，可是始终达不到群众得满意,他投诉你们部门工作效率低,你这个时候怎么作?(1)首先，我会保持冷静。作为一名工作人员，在工作中遇到各种各样的问题是正常的，关键是如何认识它，积极应对，妥善处理。 (2)其次，我会反思一下客户不满意的原因。一是看是否是自己在解决问题上的确有考虑的不周到的地方，二是看是否是客户不太了解相关的服务规定而提出超出规定的要求，三是看是否是客户了解相关的规定，但是提出的要求不合理。 (3)再次，根据原因采取相对的对策。如果是自己确有不周到的地方，按照服务规定作出合理的安排，并向客户作出解释；如果是客户不太了解政策规定而造成的误解，我会向他作出进一步的解释，消除他的误会；如果是客户提出的要求不符合政策规定，我会明确地向他指出。 (4)再次，我会把整个事情的处理情况向领导作出说明，希望得到他的理解和支持。 (5)我不会因为客户投诉了我而丧失工作的热情和积极性，而会一如既往地牢记为客户服务的宗旨，争取早日做一名领导信任、公司放心、客户满意的职员。 对这项工作，你有哪些可预见的困难？① 不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行；② 可以尝试迂回战术，说出应聘者对困难所持有的态度——“工作中出现一些困难是正常的，也是难免的，但是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以克服。” 分析：一般问这个问题，面试者的希望就比较大了，因为已经在谈工作细节。但常规思路中的回答，又被面试官“骗”了。当面试官询问这个问题的时候，有两个目的。 第一，看看应聘者是不是在行，说出的困难是不是在这个职位中一般都不可避免的问题。 第二，是想看一下应聘者解决困难的手法对不对，及公司能否提供这样的资源。而不是想了解应聘者对困难的态度。 如果我录用你，你将怎样开展工作？① 如果应聘者对于应聘的职位缺乏足够的了解，最好不要直接说出自己开展工作的具体办法；② 可以尝试采用迂回战术来回答，如“首先听取领导的指示和要求，然后就有关情况进行了解和熟悉，接下来制定一份近期的工作计划并报领导批准，最后根据计划开展工作。” 分析：这个问题的主要目的也是了解应聘者的工作能力和计划性、条理性，而且重点想要知道细节。如果向思路中所讲的迂回战术，面试官会认为回避问题，如果引导了几次仍然是回避的话。此人绝对不会录用了。 你工作经验欠缺，如何能胜任这项工作？① 如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在乎“经验”，关键看应聘者怎样回答；② 对这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业；③ 如“作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。” 点评：这个问题思路中的答案尚可。突出自己的吃苦能力和适应性以及学习能力（不是学习成绩）为好。 为了做好你工作份外之事，你该怎样获得他人的支持和帮助？回答提示：每个公司都在不断变化发展的过程中；你当然希望你的员工也是这样。你希望得到那些希望并欢迎变化的人，因为这些人明白，为了公司的发展，变化是公司日常生活中重要组成部分。这样的员工往往很容易适应公司的变化，并会对变化做出积极的响应。此外，他们遇到矛盾和问题时，也能泰然处之。下面的问题能够考核应聘者这方面的能力。据说有人能从容避免正面冲突。请讲一下你在这方面的经验和技巧。有些时候，我们得和我们不喜欢的人在一起共事。说说你曾经克服了性格方面的冲突而取得预期工作效果的经历。 项目中遇到困难，你怎么办？怎么回答回答提示：自己能搞定的，就自己上网找资料；但如果比如在 2 个小时之内还没有头绪，就考虑问公司技术水平比较高的同事之类的，然后还要及时和项目经理沟通 那不浪费了 2 个小时时间 业务问题的话，谁清楚就问谁啊……即时沟通能够大大提高工作效率。 技术问题查资料，需求问题重新分析 还是写程序的时候有技术难点、技术难点又分普遍的技术难点、还是你个人不会做、 第一种这个要找项目负责人商量、甚至要找产品/运行或其他甲方沟通、 第二种普遍技术难点的话、参考资料或者和项目负责人商量看看怎么办、 第三种的话、先自己查资料试着解决、不行就找人其他资讯、、 你在现在的团队处于什么样的角色，起到了什么明显的作用？回答提示：请自行根据自己情况做回答，这个没有统一标准答案。 最近在学什么？能谈谈你未来 3，5 年给自己的规划吗？面试时，经常会被面试官问到关于职业规划的问题，比如：你准备在我们公司做多久？你未来几年的职业规划是什么？等等。还没有进入公司，对公司工作环境还不太了解就被面试官问到这些问题，该怎么答才能合情有合理呢？ 问：你准备在我们这家单位做多久？ 答： 这不是自己单方面决定的，还要看公司，但是可以肯定的是，如果公司跟自己的职业发展一致，我是会一直干下去的 以我对公司和现有职位的了解，如果能应聘上的话，目前来看至少可以稳定三年 问：未来五年的规划是怎样的？ 答： 1.如果应聘成功，我至少会稳定的做两年，踏实的做好自己的本职工作。2.在工作中，会向高手请教，研究些新技术，提高自己的技术水平。3.目前的规划是要优先做一名技术高手，如果有可能的话，做管理也是可以考虑的。 当然，说出其他一些你感兴趣的职位也是可以的，比如产品销售部经理，生产部经理等一些与你的专业有相关背景的工作。要知道，考官总是喜欢有进取心的应聘者，此时如果说“不知道”，或许就会使你丧失一个好机会。最普通的回答应该是“我准备在技术领域有所作为”或“我希望能按照公司的管理思路发展”。 大部分面试官司都会问你是否有职业规划，这个问题的背后是了解你的求职动机和对自己中长期职业发展的思考。在回答这个问题之前，要对自己有个清晰的认识，知道自己想往哪个方向发展以及未来有什么计划，要给面试官一种积极向上，好学上进，有追求，有规划的感觉，面试官喜欢有规划的求职者。 如何向 HR 介绍你做过的项目项目经验与工作经验是相辅相成的，但较之于工作经验，项目经验更侧重于表现求职者在某个专业领域内的技能水平（技能水平决定了工资水平）。因而，技术类岗招聘的时候，更注重项目经验。项目介绍是有套路的，面试时，要将简历中的项目准备好！ 我们在跟面试官讲解的时候，讲解项目一定要围绕着以下几个方面： 1、项目名称2、开发时间（这里有个注意点：时间不要说的太短，而应该把前期的构思、需求分析、准备工作等时间都可以加进去）；3、项目描述（做什么的）；4、项目职责（说清楚自己职责，同时为了提高自己的技术形象，可以将项目说大点）；5、项目使用的技术（除了说现在使用的技术，还可以说项目进行了压力测试、兼容性处理、数据库的3F、未来还要放mysql集群技术、页面静态化技术、以提升自己在对方心目中的技术形象）；6、项目的亮点；7、在自己的项目上可以想一些市面上没有但是自己觉得很有创意的点子。实现不实现都是无所谓了，但是你给面试官的印象会再上一个层次。8、项目体会（可以说说：多人协作、命名规范、模块划分）； HR 贬低项目时你该怎么办我们在上文讲解了如何向 HR 介绍项目。由于项目反映了技术，技术决定了薪资，所以面试官一般会把打压我们的项目变相打压我们技术，以达到打压我们薪资预期的目的，同时观察我们在打压环境中的表现来决定到底打压薪资到何种程度！所以，当 HR 说：“一个月的时间，四五个人的配合就完成了项目，可见你们项目不大、技术含量不高啊”，各位面试者一定要冷静！来学学在 HR 贬低项目时的应对方法！ 1.项目实现也许花的时间不多，但是前期的构思、需求分析、页面设计等等准备工作是花了很多时间的。2.项目大小和技术含量并不能够成正比，我们的项目，虽然小，但麻雀虽小，却五脏俱全。接着向面试官介绍你们团队在项目过程中所使用的技术等等。3.项目大小主要是体现在功能上，有些功能客户并没有提出。如果后期客户有提出，我们也能够快速的实现。 项目经验少该怎么办对于前端来说，技术水平是决定我们工资最重要的因素。技术水平是要通过我们的项目体现出来的，但项目经验少该怎么办？ 1、项目经验是拿高工资最重要的一个指标。这反映了程序员的价值，也是用人单位给出薪资报价最重要的因素。所以面试者一定要重视项目。2、简历中至少要写出3个项目。3、项目可以适当包装。可以多说一些比较高端大气上档次的技术。4、面试官问到简历中的项目细节你要能答上来。否则，就算是你做的，面试官因你答不上来也会认为不是你做的。所以要花时间，搞定写在简历上的项目模块。5、项目抓亮点来说，可以对照企业的需求，将最有竞争力的点说清楚。这种能够加分的亮点一定要说到。 你学历低，为什么要录用你？面试一份工作时，学历有时候是一块敲门砖。对于学历不高的面试者，如果 HR 问：你才高中学历，而现在大学生一大把，我们为什么要录用你？你如果学历真的很低，那该怎么回答呢？ 回答提示： 1、通过自信的表现，有效的沟通，让面试官主动忽略这个问题。或者说是你把你最好的展现出来，让面试官信服，觉得你是合适的人选而不提及或忽略掉这个问题。2、即使面试官提出来了，勇敢面对主动承认，赞同面试官的提问，确实学历较低，自已已经深刻认识此问题，也因为认识到这个事实，你才更加注重能力的培养，同时自己也在工作之余继续课堂学习，增加扎实的理论知识。同时说出你的学历提升打算，提升计划一定要与你现行的工作职位结合。3、如果面试官对学历一直抓住不放，或作为必要条件，以退为进吧，委婉表达自己想得到职位的态度，并做好了放弃的心理准备。 总的来说，在面试的时候，表现出自信，从谈吐和沟通上，给面试官好印象。如果问到你学历的时候，表现出“学历不代表能力”的自信来就好，一般的企业不会把这个当做决定性因素，还是看综合素质。 你是不是年龄太大了？都说 IT 行业是个吃青春饭的行业，你现在已经接近 30 岁了，你是不是年龄太大了？这个问题应该被问到的不多，但是万一真的被问到这个问题，你该如何作答呢？ 1、 能不能做事才是大问题。而不是年龄。是不是有能力，试用期间可以检验。2、 要表现出自己很喜欢这份工作，要长久的做下去（年龄大的人，工作经历多，接触的东西多，才能够在众多的经历中明确知道自己未来到底要走什么路）。要突出自己年龄大的优势，比如思想更成熟，眼界更开阔等等。 你太小了，你能承担项目吗？虽说 IT 行业是个吃青春饭的行业，但是你年纪太小了，让人感觉不踏实。虽然我们最重要拼的是技术，但真的被问到这个问题，你该如何作答呢？ 1、虽然我年纪小，但是我技术是没有问题的，也是有担当的。试用期间可以检验。2、对于前端，我做过很多的项目，也有系统的学习过。并不比年纪大的人差。3、正因为我年纪小，我对于工作有十足的干劲，我很想在这行好好的发展，也能承受比较强的工作压力。 你对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？a. 前端是最贴近用户的程序员，前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。前端的能力就是能让产品从 90 分进化到 100 分，甚至更好 b. 参与项目，快速高质量完成实现效果图，精确到 1px； c. 与团队成员，UI 设计，产品经理的沟通； d. 做好的页面结构，页面重构和用户体验； e. 处理 hack，兼容、写出优美的代码格式； f. 针对服务器的优化、拥抱最新前端技术。 1、实现界面交互 2、提升用户体验 3、有了 Node.js，前端可以实现服务端的一些事情 其它相关的加分项： 都使用和了解过哪些编辑器?都使用和了解过哪些日常工具? 都知道有哪些浏览器内核?开发过的项目都兼容哪些浏览器? 瀑布流布局或者流式布局是否有了解 HTML5 都有哪些新的 API? 都用过什么代码调试工具? 是否有接触过或者了解过重构。 你遇到过比较难的技术问题是？你是如何解决的？","categories":[{"name":"前端面试题","slug":"前端面试题","permalink":"http://www.bluedream.top/categories/前端面试题/"}],"tags":[{"name":"面试技巧","slug":"面试技巧","permalink":"http://www.bluedream.top/tags/面试技巧/"},{"name":"面试问题","slug":"面试问题","permalink":"http://www.bluedream.top/tags/面试问题/"},{"name":"面试经验","slug":"面试经验","permalink":"http://www.bluedream.top/tags/面试经验/"}]},{"title":"JavaScript原型链","slug":"JavaScript原型链","date":"2019-08-31T07:10:08.000Z","updated":"2019-09-11T05:07:20.927Z","comments":true,"path":"前端知识点/JavaScript原型链.html","link":"","permalink":"http://www.bluedream.top/前端知识点/JavaScript原型链.html","excerpt":"","text":"面向对象原理：​ 1）目标：实现封装、继承、多态等面向对象的基本功能。 ​ 2）原理：原型链是面向对象的基础,使用prototype、function 、new、this模拟面向对象的类。 ​ JavaScript是面向对象语言，但不使用类（根本不存在类）。JavaScript的面向对象是基于prototype和function的，而不是基于类的。 介绍JavaScript的原型，原型链？有什么特点？ 原型： JavaScript的所有对象中都包含了一个 [proto] 内部属性，这个属性所对应的就是该对象的原型。 JavaScript的函数对象，除了原型 [proto] 之外，还预置了 prototype 属性。 当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型 [proto]。 原型链： 原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链。 当一个对象调用的属性/方法自身不存在时，就会去自己 [proto] 关联的前辈 prototype 对象上去找。 如果没找到，就会去该 prototype 原型 [proto] 关联的前辈 prototype 去找。依次类推，直到找到属性/方法（一直检索到 Object 内建对象）或 undefined 为止。从而形成了所谓的“原型链” 关系：instance.constructor.prototype = instance.__proto__ 原型特点： JavaScript对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变 原型链的基本原理： 任何一个实例，通过原型链，找到它上面的原型，该原型对象中的方法和属性，可以被所有的原型实例共享。 原型可以起到继承的作用，原型里的方法都可以被不同的实例共享。 其他理解： 通过一个对象的proto可以找到它的原型对象，原型对象也是一个对象，就可以通过原型对象的proto，最后找到了我们的 Object.prototype，Object是原型链的顶端。从实例的原型对象开始一直到 Object.prototype 就是我们的原型链。 每个对象都有一个私有属性（称之为 [[Prototype]]），它指向它的原型对象（prototype）。该 prototype 对象又具有一个自己的 prototype ，层层向上直到一个对象的原型为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。 当查找一个对象的属性时，JavaScript 会向上遍历原型链，直到找到给定名称的属性为止，到查找到达原型链的顶部 - 也就是 Object.prototype - 但是仍然没有找到指定的属性，就会返回 undefined 12345678910function Func()&#123;&#125;Func.prototype.name = &quot;Sean&quot;;Func.prototype.getInfo = function() &#123; return this.name;&#125;var person = new Func();//现在可以参考var person = Object.create(oldObject);console.log(person.getInfo());//它拥有了Func的属性和方法//&quot;Sean&quot;console.log(Func.prototype);// Func &#123; name=&quot;Sean&quot;, getInfo=function()&#125; js001 原型、构造函数、实例三者之间的关系 PS：任何一个函数，如果在前面加了new，那就是构造函数。 构造函数通过 new 生成实例 构造函数也是函数，构造函数的prototype指向原型。（所有的函数有prototype属性，但实例没有 prototype属性） 原型对象中有 constructor，指向该原型的构造函数。 上面的三行，代码演示： 12345var Foo = function (name) &#123; this.name = name;&#125;;var fn = new Foo('smyhvae'); 上面的代码中，Foo.prototype.constructor === Foo的结果是true： 实例的__proto__指向原型。也就是说，Foo.__proto__ === M.prototype。 声明：所有的引用类型（数组、对象、函数）都有__proto__这个属性。 Foo.__proto__ === Function.prototype的结果为true，说明Foo这个普通的函数，是Function构造函数的一个实例。 prototype 和proto的关系是什么？所有的对象都拥有proto属性，它指向对象构造函数的 prototype 属性 12345let obj = &#123;&#125;obj.__proto__ === Object.prototype // truefunction Test()&#123;&#125;test.__proto__ == Test.prototype // true 所有的函数都同时拥有proto和 protytpe 属性函数的proto指向自己的函数实现 函数的 protytpe 是一个对象 所以函数的 prototype 也有proto属性 指向 Object.prototype 12function func() &#123;&#125;func.prototype.__proto__ === Object.prototype // true Object.prototype.proto指向 null 1Object.prototype.__proto__ // null 执行时对象查找时，永远不会去查找原型的一个函数是？ javaScript中hasOwnProperty函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员 使用方法： object.hasOwnProperty(proName) 其中参数object是必选项。一个对象的实例。 proName是必选项。一个属性名称的字符串值。 如果 object 具有指定名称的属性，那么JavaScript中hasOwnProperty函数方法返回 true，反之则返回 false。 instanceof的原理 instanceof的作用：用于判断实例属于哪个构造函数。 instanceof的原理：判断实例对象的__proto__属性，和构造函数的prototype属性，是否为同一个引用（是否指向同一个地址）。 注意1：虽然说，实例是由构造函数 new 出来的，但是实例的__proto__属性引用的是构造函数的prototype。也就是说，实例的__proto__属性与构造函数本身无关。 注意2：在原型链上，原型的上面可能还会有原型，以此类推往上走，继续找__proto__属性。这条链上如果能找到， instanceof 的返回结果也是 true。 比如说： foo instance of Foo的结果为true，因为foo.__proto__ === M.prototype为true。 foo instance of Objecet的结果也为true，为Foo.prototype.__proto__ === Object.prototype为true。 instanceof 的内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。 使用 instanceof 判断一个对象是否为数组，instanceof 会判断这个对象的原型链上是否会找到对应的 Array 的原型，找到返回 true，否则返回 false。 1[] instanceof Array; // true 但 instanceof 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true。 1[] instanceof Object; // true 优点：instanceof 可以弥补 Object.prototype.toString.call()不能判断自定义实例化对象的缺点。 缺点：instanceof 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true，且不同于其他两种方法的是它不能检测出 iframes。 12345function f(name) &#123; this.name = name;&#125;var f1 = new f(\"martin\");console.log(f1 instanceof f); //true 推荐阅读: https://www.cnblogs.com/zhoulujun/p/9667651.html","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"http://www.bluedream.top/categories/前端知识点/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.bluedream.top/tags/JavaScript/"},{"name":"原型","slug":"原型","permalink":"http://www.bluedream.top/tags/原型/"},{"name":"原型链","slug":"原型链","permalink":"http://www.bluedream.top/tags/原型链/"},{"name":"instanceof","slug":"instanceof","permalink":"http://www.bluedream.top/tags/instanceof/"}]},{"title":"光阴","slug":"光阴","date":"2019-08-31T02:18:08.000Z","updated":"2019-09-16T01:37:58.776Z","comments":true,"path":"散文/光阴.html","link":"","permalink":"http://www.bluedream.top/散文/光阴.html","excerpt":"","text":"作者：赵丽宏 谁也无法描绘出他的面目。但世界上处处能听到他的脚步。 当旭日驱散夜的残幕时,当夕阳被朦胧的地平线吞噬时,他不慌不忙地走着,光明和黑暗都无法改变他进行的节奏。 当蓓蕾在春风中灿然绽开湿润的花瓣时,当婴儿在产房里以响亮的哭声向人世报到时,他悄无声息地走着,欢笑不能挽留他的脚步。 当枯黄的树叶在寒风中飘飘坠落时,当垂危的老人以留恋的目光扫视周围的天地时,他还是沉着而又默然地走,叹息也不能使他停步。 他从你的手指缝里流过去。 从你的脚底下滑过去。 从你的视野和你的思想里飞过去….. 他是一把神奇而又无情的雕刻刀,在天地之间创造着种种奇迹,他能把巨石分裂成尘土,把幼苗雕成大树,把荒漠变成城市和园林,当然,他也能使繁华之都衰败成荒凉的废墟,使锃亮的金属爬满绿锈、失去光泽。老人额头的皱纹是他刻出来的,少女脸上的红晕也是他描绘出来的。生命的繁衍和世界的运动正是由他精心指挥着。 他按时撕下一张又一张日历,把将来变成现在,把现在变成过去,把过去变成越来越遥远的[历史])。 他慷慨。你不必乞求,属于你的,他总是如数奉献。 他公正。不管你权重如山、腰缠万贯,还是一个布衣、两袖清风,他都一视同仁。没有人能将他占为己有,哪怕你一掷千金,他也决不会因此而施舍一分一秒。 你珍重他，他便在你的身后长出绿阴，结出沉甸甸的果实。 你漠视他,他就化成轻烟,消散得无影无踪。 有时,短暂的一瞬会成为永恒,这是因为他把脚印深深地留在了人们心里。 有时,漫长的岁月会成为一瞬,这是因为浓雾和风沙湮没了他的脚印。","categories":[{"name":"散文","slug":"散文","permalink":"http://www.bluedream.top/categories/散文/"}],"tags":[{"name":"光阴","slug":"光阴","permalink":"http://www.bluedream.top/tags/光阴/"},{"name":"赵丽宏","slug":"赵丽宏","permalink":"http://www.bluedream.top/tags/赵丽宏/"}]},{"title":"JavaScript闭包","slug":"JavaScript闭包","date":"2019-08-29T12:50:00.000Z","updated":"2019-09-09T07:56:21.557Z","comments":true,"path":"前端知识点/JavaScript闭包.html","link":"","permalink":"http://www.bluedream.top/前端知识点/JavaScript闭包.html","excerpt":"","text":"说说你对闭包的理解（什么是闭包（closure），为什么要用它？）使用闭包主要是为了设计私有的方法和变量。闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域。在js中，函数即闭包，只有函数才会产生作用域的概念。 闭包有三个特性： 函数内再嵌套函数 函数内部可以引用外部的参数和变量 参数和变量不会被垃圾回收机制回收 优点： 希望一个变量长期存储在内存中。 避免全局变量的污染。 私有成员的存在。 缺点： 常驻内存，会增大内存使用量。 使用不当会很容易造成内存泄露。 示例： 12345678function outer() &#123; var name = \"jack\"; function inner() &#123; console.log(name); &#125; return inner;&#125;outer()(); // jack 1234567function sayHi(name) &#123; return () =&gt; &#123; console.log(`Hi! $&#123;name&#125;`); &#125;;&#125;const test = sayHi(\"xiaoming\");test(); // Hi! xiaoming 虽然 sayHi 函数已经执行完毕，但是其活动对象也不会被销毁，因为 test 函数仍然引用着 sayHi 函数中的变量 name，这就是闭包。但也因为闭包引用着另一个函数的变量，导致另一个函数已经不使用了也无法销毁，所以闭包使用过多，会占用较多的内存，这也是一个副作用。 解析： 由于在 ECMA2015 中，只有函数才能分割作用域，函数内部可以访问当前作用域的变量，但是外部无法访问函数内部的变量，所以闭包可以理解成“定义在一个函数内部的函数，外部可以通过内部返回的函数访问内部函数的变量“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。 闭包由来JavaScript 变量JavaScript 变量可以是局部变量或全局变量。 全局变量：作用域是全局性的，可应用于页面上的所有脚本，在web页面中全局变量属于 window 对象。 局部变量：在函数内部声明的变量，只在函数内部起作用，作用域是局部性的；函数的参数也是局部性的，只在函数内部起作用。 全局和局部变量即便名称相同，它们也是两个不同的变量。修改其中一个，不会影响另一个的值。私有变量可以用到闭包。 计数器困境设想下如果你想统计一些数值，且该计数器在所有函数中都是可用的。你可以使用全局变量，函数设置计数器递增： 1234567891011var counter = 0; function add() &#123; return counter += 1;&#125; add();add();add(); // 计数器现在为 3 计数器数值在执行 add() 函数时发生变化。 但问题来了，页面上的任何脚本都能改变计数器，即便没有调用 add() 函数。 如果我在函数内声明计数器，如果没有调用函数将无法修改计数器的值：12345678910function add() &#123; var counter = 0; return counter += 1;&#125; add();add();add(); // 本意是想输出 3, 但事与愿违，输出的都是 1 以上代码将无法正确输出，每次我调用 add() 函数，计数器都会设置为 1。 JavaScript 内嵌函数可以解决该问题。 JavaScript 内嵌函数所有函数都能访问全局变量。 实际上，在 JavaScript 中，所有函数都能访问它们上一层的作用域。 JavaScript 支持嵌套函数。嵌套函数可以访问上一层的函数变量。 内嵌函数 plus() 可以访问父函数的 counter 变量：123456function add() &#123; var counter = 0; function plus() &#123;counter += 1;&#125; plus(); return counter; &#125; 如果我们能在外部访问 plus() 函数，这样就能解决计数器的困境。 我们同样需要确保 counter = 0只执行一次。 我们需要闭包。 JavaScript 闭包还记得函数自我调用吗？该函数会做什么？ 12345678910var add = (function () &#123; var counter = 0; return function () &#123;return counter += 1;&#125;&#125;)(); add();add();add(); // 计数器为 3 变量 add 指定了函数自我调用的返回字值。 自我调用函数只执行一次。设置计数器为 0。并返回函数表达式。 add变量可以作为一个函数使用。非常棒的部分是它可以访问函数上一层作用域的计数器。 这个叫作 JavaScript 闭包。它使得函数拥有私有变量变成可能。 计数器受匿名函数的作用域保护，只能通过 add 方法修改。 闭包是一种保护私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不受外界干扰。直观的说就是形成一个不销毁的栈环境。","categories":[{"name":"前端知识点","slug":"前端知识点","permalink":"http://www.bluedream.top/categories/前端知识点/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.bluedream.top/tags/JavaScript/"},{"name":"闭包","slug":"闭包","permalink":"http://www.bluedream.top/tags/闭包/"}]},{"title":"电脑常用快捷键","slug":"电脑常用快捷键","date":"2019-08-28T03:58:08.000Z","updated":"2019-09-09T08:00:19.205Z","comments":true,"path":"其他/电脑常用快捷键.html","link":"","permalink":"http://www.bluedream.top/其他/电脑常用快捷键.html","excerpt":"","text":"文件操作快捷键：Ctrl+C 复制 Ctrl+V 粘贴 Ctrl+X 剪切 Ctrl+A 全选 Ctrl 多选：按住Ctrl，再用鼠标单击即可选中文件，可以反选； Shift 多选：先选中一个文件a，按住Shift键，再用鼠标单击文件h，即可把从a到h选中； Ctrl+Shift+N 新建文件夹。注意：XP系统不行； Shift+Delete 彻底删除文件。选中文件后，先按住Shift键不放手，再按Delete键，彻底删除的文件不在回收站里； 文字输入快捷键：Tab与Shift+Tab：1、在输入账号之后按Tab键，会自动跳到输入密码框进行输入； 2、有些地方相当于输入两个汉字那么长的空格（如代码编写的缩进等）； 3、Shift+Tab为Tab的反操作； Delete 反向删除文字。比如”AB”字符，当光标在A与B之间时，按”Back”退格键时删除”A”，当按”Delete”键时则删除B； Home与End 当输入一行文字时发现有错误，可以按Home回到第一个字，按End时回到最后一个字。此时可以免去动鼠标或者按”←”或”→”方向键的麻烦； 窗口（Win）键【窗口】显示或隐藏“开始”菜单 【窗口】+F1帮助 【窗口】+D显示桌面，一个一个地关闭窗口或最小化窗口会很麻烦，这个快捷键很方便； 【窗口】+R打开“运行”窗口，可以输入”cmd”进入命令行黑窗口，还可以输入”msconfig”等命令； 【窗口】+E打开“我的电脑”，即使桌面上没有“我的电脑”图标也可以进入文件管理； 【窗口】+F搜索文件或文件夹 【窗口】+U打开“工具管理器” 【窗口】+BREAK显示“系统属性” 【窗口】+TAB在打开的项目之间切换 【窗口】+Pause 打开系统相关信息。可以快速查看别人电脑配置，相当于“控制面板\\系统和安全\\系统”。 【窗口】+U+U/R XP系统关机/重启（Win8不行）。注意：每按一个键都要松手，不是连按的； Ctrl键Ctrl+1,2,3… 功能：切换到从左边数起第1,2,3…个标签 Ctrl+A 功能：全部选中当前页面内容 Ctrl+C 功能：复制当前选中内容 Ctrl+D 功能：打开“添加收藏”面版(把当前页面添加到收藏夹中) Ctrl+E 功能：打开或关闭“搜索”侧边栏(各种搜索引擎可选) Ctrl+F 功能：打开“查找”面版 Ctrl+G 功能：打开或关闭“简易收集”面板 Ctrl+H 功能：打开“历史”侧边栏 Ctrl+I 功能：打开“收藏夹”侧边栏/另:将所有垂直平铺或水平平铺或层叠的窗口恢复 Ctrl+K 功能：关闭除当前和锁定标签外的所有标签 Ctrl+L 功能：打开“打开”面版(可以在当前页面打开Iternet地址或其他文件…) Ctrl+N 功能：新建一个空白窗口(可更改,Maxthon选项→标签→新建) Ctrl+O 功能：打开“打开”面版(可以在当前页面打开Iternet地址或其他文件…) Ctrl+P 功能：打开“打印”面板(可以打印网页,图片什么的…) Ctrl+Q 功能：打开“添加到过滤列表”面板(将当前页面地址发送到过滤列表) Ctrl+R 功能：刷新当前页面 Ctrl+S 功能：打开“保存网页”面板(可以将当前页面所有内容保存下来) Ctrl+T 功能：垂直平铺所有窗口 Ctrl+V 功能：粘贴当前剪贴板内的内容 Ctrl+W 功能：关闭当前标签(窗口) Ctrl+X 功能：剪切当前选中内容(一般只用于文本操作) Ctrl+Y 功能：重做刚才动作(一般只用于文本操作) Ctrl+Z 功能：撤消刚才动作(一般只用于文本操作) Ctrl+F4 功能：关闭当前标签(窗口) Ctrl+F5 功能：刷新当前页面 Ctrl+F6 功能：按页面打开的先后时间顺序向前切换标签(窗口) Ctrl+F11 功能：隐藏或显示菜单栏 Ctrl+Tab 功能：以小菜单方式向下切换标签(窗口) Ctrl+拖曳 功能：保存该链接的地址或已选中的文本或指定的图片到一个文件夹中(保存目录可更改,Maxthon选项→保存) Ctrl+小键盘’+’ 功能：当前页面放大20% Ctrl+小键盘’-‘ 功能：当前页面缩小20% Ctrl+小键盘’*’ 功能：恢复当前页面的缩放为原始大小 Ctrl+Alt+S 功能：自动保存当前页面所有内容到指定文件夹(保存路径可更改,Maxthon选项→保存) Ctrl+Shift+小键盘’+’ 功能：所有页面放大20% Ctrl+Shift+小键盘’-‘ 功能：所有页面缩小20% Ctrl+Shift+F 功能：输入焦点移到搜索栏 Ctrl+Shift+G 功能：关闭“简易收集”面板 Ctrl+Shift+H 功能：打开并激活到你设置的主页 Ctrl+Shift+N 功能：在新窗口中打开剪贴板中的地址,如果剪贴板中为文字,则调用搜索引擎搜索该文字(搜索引擎可选择,Maxthon选项→搜索) Ctrl+Shift+S 功能：打开“保存网页”面板(可以将当前页面所有内容保存下来,等同于Ctrl+S) Ctrl+Shift+W 功能：关闭除锁定标签外的全部标签(窗口) Ctrl+Shift+F6 功能：按页面打开的先后时间顺序向后切换标签(窗口) Ctrl+Shift+Tab 功能：以小菜单方式向上切换标签(窗口) 其他常用快捷键：END 显示当前窗口的底端 HOME 显示当前窗口的顶端 Ctrl+Alt+Delete 打开任务管理器（结束一些常规方法关闭不了的程序）。 Print 电脑屏幕截屏。（然后在画图或Word中粘贴保存）； Ctrl+Alt+Print 对当前窗口截屏。（然后在画图或Word中粘贴保存）； Alt+Tab 切换已打开的程序窗口。先用一个手指按住Alt键，再用另外一个手指陆续按Tab键切换不同窗口； Alt+F4 关闭当前窗口。如果没有窗口时则提示关机； F5 刷新当前窗口。包括系统和网页。 Alt+1 功能：保存当前表单 Alt+2 功能：保存为通用表单 Alt+A 功能：展开收藏夹列表 辅助功能按右边的SHIFT键八秒钟切换筛选键的开和关 按SHIFT五次切换粘滞键的开和关 按NUMLOCK五秒钟切换切换键的开和关 左边的ALT+左边的SHIFT+NUMLOCK切换鼠标键的开和关 左边的ALT+左边的SHIFT+PRINTSCREEN切换高对比度的开和关 QQ快捷键Alt+S 快速回复 Alt+C 关闭当前窗口 Alt+H 打开聊天记录 Alt+T 更改消息模式 Ait+J 打开聊天纪录 Ctrl+A 全选当前对话框里的内容 Ctrl+F QQ里直接显示字体设置工具条 Ctrl+J 输入框里回车(跟回车一个效果) Ctrl+M 输入框里回车(跟回车一个效果) Ctrl+L 对输入框里当前行的文字左对齐 Ctrl+R 对输入框里当前行的文字右对齐 Ctrl+E 对输入框里当前行的文字居中 Ctrl+V 在qq对话框里实行粘贴 Ctrl+Z 清空/恢复输入框里的文字 Ctrl+回车 快速回复 这个可能是聊QQ时最常用到的了 Ctrl+Alt+Z 快速提取消息 Ctrl+Alt+A 捕捉屏幕","categories":[{"name":"其他","slug":"其他","permalink":"http://www.bluedream.top/categories/其他/"}],"tags":[{"name":"电脑","slug":"电脑","permalink":"http://www.bluedream.top/tags/电脑/"},{"name":"快捷键","slug":"快捷键","permalink":"http://www.bluedream.top/tags/快捷键/"}]},{"title":"vue","slug":"vue","date":"2019-08-27T13:02:08.000Z","updated":"2019-09-09T08:00:19.045Z","comments":true,"path":"前端面试题/vue.html","link":"","permalink":"http://www.bluedream.top/前端面试题/vue.html","excerpt":"","text":"什么是mvvm？ MVVM是Model-View-ViewModel的缩写。mvvm是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象 在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。 ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理 vue的优点是什么？ 低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变 可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑 可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写 为什么用 vue ？简洁、轻快、舒服 请详细说下你对vue生命周期的理解 答：总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后 创建前/后： 在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el还没有 载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。 更新前/后：当data变化时，会触发beforeUpdate和updated方法 销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在 组件之间的传值？父组件与子组件传值12345678910111213141516171819202122232425262728293031323334//父组件通过标签上面定义传值&lt;template&gt; &lt;Main :obj=&quot;data&quot;&gt;&lt;/Main&gt;&lt;/template&gt;&lt;script&gt; //引入子组件 import Main form &quot;./main&quot; exprot default&#123; name:&quot;parent&quot;, data()&#123; return &#123; data:&quot;我要向子组件传递数据&quot; &#125; &#125;, //初始化组件 components:&#123; Main &#125; &#125;&lt;/script&gt;//子组件通过props方法接受数据&lt;template&gt; &lt;div&gt;&#123;&#123;data&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; exprot default&#123; name:&quot;son&quot;, //接受父组件传值 props:[&quot;data&quot;] &#125;&lt;/script&gt; 子组件向父组件传递数据123456789101112131415161718192021222324252627//子组件通过$emit方法传递参数&lt;template&gt; &lt;div v-on:click=&quot;events&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; //引入子组件 import Main form &quot;./main&quot; exprot default&#123; methods:&#123; events:function()&#123; &#125; &#125; &#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt;&#123;&#123;data&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; exprot default&#123; name:&quot;son&quot;, //接受父组件传值 props:[&quot;data&quot;] &#125;&lt;/script&gt; 路由之间跳转？声明式（标签跳转）1&lt;router-link :to=&quot;index&quot;&gt; 编程式（ js跳转）1router.push(&apos;index&apos;) vuex是什么？怎么使用？哪种功能场景使用它？ vue框架中状态管理。在main.js引入store，注入。新建了一个目录store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车 实现 Vue SSR其基本实现原理 app.js 作为客户端与服务端的公用入口，导出 Vue 根实例，供客户端 entry 与服务端 entry 使用。客户端 entry 主要作用挂载到 DOM 上，服务端 entry 除了创建和返回实例，还进行路由匹配与数据预获取。 webpack 为客服端打包一个 Client Bundle ，为服务端打包一个 Server Bundle 。 服务器接收请求时，会根据 url，加载相应组件，获取和解析异步数据，创建一个读取 Server Bundle 的 BundleRenderer，然后生成 html 发送给客户端。 客户端混合，客户端收到从服务端传来的 DOM 与自己的生成的 DOM 进行对比，把不相同的 DOM 激活，使其可以能够响应后续变化，这个过程称为客户端激活 。为确保混合成功，客户端与服务器端需要共享同一套数据。在服务端，可以在渲染之前获取数据，填充到 stroe 里，这样，在客户端挂载到 DOM 之前，可以直接从 store 里取数据。首屏的动态数据通过 window.__INITIAL_STATE__发送到客户端 Vue SSR 的实现，主要就是把 Vue 的组件输出成一个完整 HTML, vue-server-renderer 就是干这事的 Vue SSR需要做的事多点（输出完整 HTML），除了complier -&gt; vnode，还需如数据获取填充至 HTML、客户端混合（hydration）、缓存等等。相比于其他模板引擎（ejs, jade 等），最终要实现的目的是一样的，性能上可能要差点 Vue 组件 data 为什么必须是函数 每个组件都是 Vue 的实例。 组件共享 data 属性，当 data 的值是同一个引用类型的值时，改变其中一个会影响其他 Vue computed 实现 建立与其他属性（如：data、 Store）的联系； 属性改变后，通知计算属性重新计算 实现时，主要如下 初始化 data， 使用 Object.defineProperty 把这些属性全部转为 getter/setter。 初始化 computed, 遍历 computed 里的每个属性，每个 computed 属性都是一个 watch 实例。每个属性提供的函数作为属性的 getter，使用 Object.defineProperty 转化。 Object.defineProperty getter 依赖收集。用于依赖发生变化时，触发属性重新计算。 若出现当前 computed 计算属性嵌套其他 computed 计算属性时，先进行其他的依赖收集 Vue complier 实现 模板解析这种事，本质是将数据转化为一段 html ，最开始出现在后端，经过各种处理吐给前端。随着各种 mv* 的兴起，模板解析交由前端处理。 总的来说，Vue complier 是将 template 转化成一个 render 字符串。 可以简单理解成以下步骤： parse 过程，将 template 利用正则转化成 AST 抽象语法树。 optimize 过程，标记静态节点，后 diff 过程跳过静态节点，提升性能。 generate 过程，生成 render 字符串 怎么快速定位哪个组件出现性能问题 用 timeline 工具。 大意是通过 timeline 来查看每个函数的调用时常，定位出哪个函数的问题，从而能判断哪个组件出了问题","categories":[{"name":"前端面试题","slug":"前端面试题","permalink":"http://www.bluedream.top/categories/前端面试题/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://www.bluedream.top/tags/vue/"},{"name":"MVVM","slug":"MVVM","permalink":"http://www.bluedream.top/tags/MVVM/"}]},{"title":"前端知识点","slug":"前端知识点","date":"2019-08-27T12:30:00.000Z","updated":"2019-09-09T08:00:19.140Z","comments":true,"path":"前端面试题/前端知识点.html","link":"","permalink":"http://www.bluedream.top/前端面试题/前端知识点.html","excerpt":"","text":"前端开发知识点 HTML&amp;CSS对Web标准的理解、浏览器内核差异、兼容性、hack、CSS基本功：布局、盒子模型、选择器优先级、HTML5、CSS3、Flexbox JavaScript：数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、RegExp、JSON、Ajax、DOM、BOM、内存泄漏、跨域、异步装载、模板引擎、前端MVC、路由、模块化、Canvas、ECMAScript 其他： 移动端、响应式、自动化构建、HTTP、离线存储、WEB安全、优化、重构、团队协作、可维护、易用性、SEO、UED、架构、职业生涯、快速学习能力 DOM结构 —— 两个节点之间可能存在哪些关系以及如何在节点之间任意移动。 DOM操作 —— 如何添加、移除、移动、复制、创建和查找节点等。 事件 —— 如何使用事件，以及IE和标准DOM事件模型之间存在的差别。 XMLHttpRequest —— 这是什么、怎样完整地执行一次GET请求、怎样检测错误。 严格模式与混杂模式 —— 如何触发这两种模式，区分它们有何意义。 盒模型 —— 外边距、内边距和边框之间的关系，及IE8以下版本的浏览器中的盒模型 块级元素与行内元素 —— 怎么用CSS控制它们、以及如何合理的使用它们 浮动元素 —— 怎么使用它们、它们有什么问题以及怎么解决这些问题。 HTML与XHTML —— 二者有什么区别，你觉得应该使用哪一个并说出理由。 JSON —— 作用、用途、设计结构 JSON 相关 JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式 它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小 JSON字符串转换为JSON对象: 123var obj =eval(&apos;(&apos;+ str +&apos;)&apos;);var obj = str.parseJSON();var obj = JSON.parse(str); JSON对象转换为JSON字符串： 12var last=obj.toJSONString();var last=JSON.stringify(obj); XML和JSON的区别？ 数据体积方面 JSON相对于XML来讲，数据的体积小，传递的速度更快些。 数据交互方面 JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互 数据描述方面 JSON对数据的描述性比XML较差 传输速度方面 JSON的速度要远远快于XML PS相关 PNG,GIF,JPG的区别及如何选 GIF： 8位像素，256色 无损压缩 支持简单动画 支持boolean透明 适合简单动画 JPEG： 颜色限于256 有损压缩 可控制压缩质量 不支持透明 适合照片 PNG： 有PNG8和truecolor PNG PNG8类似GIF颜色上限为256，文件小，支持alpha透明度，无动画 适合图标、背景、按钮 Git相关git fetch和git pull的区别 git pull：相当于是从远程获取最新版本并merge到本地 git fetch：相当于是从远程获取最新版本到本地，不会自动merge SEO相关前端需要注意哪些SEO 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可 语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页 重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取 重要内容不要用js输出：爬虫不会执行js获取内容 少用iframe：搜索引擎不会抓取iframe中的内容 非装饰性图片必须加alt 提高网站速度：网站速度是搜索引擎排序的一个重要指标 如何做SEO优化? 标题与关键词 设置有吸引力切合实际的标题，标题中要包含所做的关键词 网站结构目录 最好不要超过三级，每级有“面包屑导航”，使网站成树状结构分布 页面元素 给图片标注”Alt”可以让搜索引擎更友好的收录 网站内容 每个月每天有规律的更新网站的内容，会使搜索引擎更加喜欢 友情链接 对方一定要是正规网站，每天有专业的团队或者个人维护更新 内链的布置 使网站形成类似蜘蛛网的结构，不会出现单独连接的页面或链接 流量分析 通过统计工具(百度统计，CNZZ)分析流量来源，指导下一步的SEO 存储相关浏览器本地存储 在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了localStorage来取代globalStorage html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储 而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的 web storage和cookie的区别 Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用 除此之外，WebStorage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie 但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生 浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等 cookie 和session 的区别： session： 是一个抽象概念，开发者为了实现中断和继续等操作，将 user agent和 server 之间一对一的交互，抽象为“会话”，进而衍生出“会话状态”，也就是 session 的概念 cookie：它是一个世纪存在的东西，http 协议中定义在 header 中的字段，可以认为是 session 的一种后端无状态实现 现在我们常说的 session，是为了绕开 cookie 的各种限制，通常借助 cookie本身和后端存储实现的，一种更高级的会话状态实现 session 的常见实现要借助cookie来发送 sessionID 1、cookie数据存放在客户的浏览器上，session数据放在服务器上。 2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗 考虑到安全应当使用session。 3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能 考虑到减轻服务器性能方面，应当使用COOKIE。 4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。 5、所以个人建议： 将登陆信息等重要信息存放为SESSION 其他信息如果需要保留，可以放在COOKIE中 描述 cookies、sessionStorage 和 localStorage 的区别？ 与服务器交互： cookie 是网站为了标示用户身份而储存在用户本地终端上的数据（通常经过加密） cookie 始终会在同源 http 请求头中携带（即使不需要），在浏览器和服务器间来回传递 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存 存储大小： cookie 数据根据不同浏览器限制，大小一般不能超过 4k sessionStorage 和 localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 有期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据 sessionStorage 数据在当前浏览器窗口关闭后自动删除 cookie 设置的cookie过期时间之前一直有效，与浏览器是否关闭无关 谈谈Cookie的弊端cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的 1.每个特定的域名下最多生成20个cookie， 个数有限制（IE6或更低版本最多20个cookie） 2.Firefox、IE7和之后的版本最后可以有50个cookie，chrome和Safari没有做硬性限制 3.IE 和 Opera 会清理近期最少使用的 cookie，Firefox 会随机清理 cookie 4.cookie 的最大大约为 4096 字节，为了兼容性，一般设置不超过 4095 字节 5.如果 cookie 被人拦截了，就可以取得所有的 session 信息 重构相关谈谈你对重构的理解 网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化， 在扩展的同时保持一致的UI 对于传统的网站来说重构通常是： 表格(table)布局改为DIV+CSS 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) 对于移动平台的优化 针对于SEO进行优化 深层次的网站重构应该考虑的方面 页面重构怎么操作？ 网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI 对于传统的网站来说重构通常可以考虑的方面是： 升级第三方依赖 使用HTML5、CSS3、ES6 新特性 加入响应式布局 统一代码风格规范 减少代码间的耦合 压缩/合并JS、CSS、image等静态资源(通常是由服务器来解决) 程序的性能优化 采用CDN来加速资源加载 对于JS DOM的优化 HTTP服务器的文件缓存 表格(table)布局改为DIV+CSS 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) 对于移动平台的优化 针对于SEO进行优化 深层次的网站重构应该考虑的方面 让代码保持弹性 严格按规范编写代码 设计可扩展的API 代替旧有的框架、语言(如VB) 增强用户体验 通常来说对于速度的优化也包含在重构中 前端相关前端页面有哪三层构成，分别是什么？作用是什么？ 结构层：由 (X)HTML 标记语言负责，解决页面“内容是什么”的问题 表示层：由 CSS 负责，解决页面“如何显示内容”的问题 行为层：由 JS 脚本负责，解决页面上“内容应该如何对事件作出反应”的问题 Web 前端开发的注意事项？ 特别设置 meta 标签 viewport 百分比布局宽度，结合 box-sizing: border-box; 使用 rem 作为计算单位。rem 只参照跟节点 html 的字体大小计算 使用 css3 新特性。弹性盒模型、多列布局、媒体查询等 多机型、多尺寸、多系统覆盖测试 说说你对前端架构师的理解 负责前端团队的管理及与其他团队的协调工作，提升团队成员能力和整体效率；带领团队完成研发工具及平台前端部分的设计、研发和维护； 带领团队进行前端领域前沿技术研究及新技术调研，保证团队的技术领先负责前端开发规范制定、功能模块化设计、公共组件搭建等工作，并组织培训 平时如何管理你的项目？ 规定全局样式、公共脚本 严格要求代码注释(html/js/css) 严格要求静态资源存放路径 Git 提交必须填写说明 说说最近最流行的一些东西吧？ ES6、Node、React、Webpack 什么样的前端代码是好的 高复用低耦合，这样文件小，好维护，而且好扩展。 移动端相关你怎么看待 Web App/hybrid App/Native App？（移动端前端 和 Web 前端区别？） Web App(HTML5)：采用HTML5生存在浏览器中的应用，不需要下载安装 优点：开发成本低，迭代更新容易，不需用户升级，跨多个平台和终端 缺点：消息推送不够及时，支持图形和动画效果较差，功能使用限制（相机、GPS等） Hybrid App(混合开发)：UI WebView，需要下载安装 优点：接近 Native App 的体验，部分支持离线功能 缺点：性能速度较慢，未知的部署时间，受限于技术尚不成熟 Native App(原生开发)：依托于操作系统，有很强的交互，需要用户下载安装使用 优点：用户体验完美，支持离线工作，可访问本地资源（通讯录，相册） 缺点：开发成本高（多系统），开发成本高（版本更新），需要应用商店的审核 在设计 Web APP 时，应当遵循以下几点 简化不重要的动画/动效/图形文字样式 少用手势，避免与浏览器手势冲突 减少页面内容，页面跳转次数，尽量在当前页面显示 增强 Loading 趣味性，增强页面主次关系 移动端（Android、IOS）怎么做好用户体验? 清晰的视觉纵线 信息的分组、极致的减法 利用选择代替输入 标签及文字的排布方式 依靠明文确认密码 合理的键盘利用 其他如何设计突发大规模并发架构？ 及时响应(NoSQL缓存) 数据安全(数据备份) 负载均衡 列举IE与其他浏览器不一样的特性？ IE 的渲染引擎是 Trident 与 W3C 标准差异较大：例如盒子模型的怪异模式 JS 方面有很多独立的方法，例如事件处理不同：绑定/删除事件，阻止冒泡，阻止默认事件等 CSS 方面也有自己独有的处理方式，例如设置透明，低版本IE中使用滤镜的方式 是否了解公钥加密和私钥加密？ 私钥用于对数据进行签名，公钥用于对签名进行验证 网站在浏览器端用公钥加密敏感数据，然后在服务器端再用私钥解密 WEB应用从服务器主动推送Data到客户端有那些方式？ AJAX 轮询 html5 服务器推送事件(new EventSource(SERVER_URL)).addEventListener(&quot;message&quot;, func); html5 Websocket (new WebSocket(SERVER_URL)).addEventListener(&quot;message&quot;, func); 不可见的iframe WebSocket通过Flash XHR长时间连接 XHR Multipart Streaming script标签的长时间连接(可跨域) 列举IE与其他浏览器不一样的特性？ 事件不同之处： 触发事件的元素被认为是目标（target）。而在 IE 中，目标包含在 event 对象的 srcElement 属性； 获取字符代码、如果按键代表一个字符（shift、ctrl、alt除外），IE 的 keyCode 会返回字符代码（Unicode），DOM 中按键的代码和字符是分离的，要获取字符代码，需要使用 charCode 属性； 阻止某个事件的默认行为，IE 中阻止某个事件的默认行为，必须将 returnValue 属性设置为 false，Mozilla 中，需要调用 preventDefault() 方法； 停止事件冒泡，IE 中阻止事件进一步冒泡，需要设置 cancelBubble 为 true，Mozzilla 中，需要调用 stopPropagation() 什么叫优雅降级和渐进增强？ 优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用 渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好） 注：这题胜在区分度高，知识点覆盖广，再不懂的人，也能答出几句，而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、 到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等 详细版： 1、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理; 2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法; 3、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求; 4、进行HTTP协议会话，客户端发送报头(请求报头); 5、进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器; 6、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理; 7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304; 8、浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存; 9、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie; 10、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。 简洁版： 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求； 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）； 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）； 载入解析到的资源文件，渲染页面，完成","categories":[{"name":"前端面试题","slug":"前端面试题","permalink":"http://www.bluedream.top/categories/前端面试题/"}],"tags":[{"name":"知识点","slug":"知识点","permalink":"http://www.bluedream.top/tags/知识点/"},{"name":"Json","slug":"Json","permalink":"http://www.bluedream.top/tags/Json/"},{"name":"PS","slug":"PS","permalink":"http://www.bluedream.top/tags/PS/"},{"name":"Git","slug":"Git","permalink":"http://www.bluedream.top/tags/Git/"},{"name":"SEO","slug":"SEO","permalink":"http://www.bluedream.top/tags/SEO/"},{"name":"存储","slug":"存储","permalink":"http://www.bluedream.top/tags/存储/"},{"name":"重构","slug":"重构","permalink":"http://www.bluedream.top/tags/重构/"},{"name":"前端","slug":"前端","permalink":"http://www.bluedream.top/tags/前端/"},{"name":"移动端","slug":"移动端","permalink":"http://www.bluedream.top/tags/移动端/"}]},{"title":"welcome","slug":"welcome","date":"2019-08-25T10:26:47.000Z","updated":"2019-09-12T14:21:32.391Z","comments":true,"path":"其他/welcome.html","link":"","permalink":"http://www.bluedream.top/其他/welcome.html","excerpt":"Welcome to QinWei‘s blog! 本博客有以下八个分类： 前端知识点 全栈知识点 前端面试题 全栈面试题 链接 随笔 散文 其他 This is my first post.If you have any problems in using this website , you can contact me by QQ： 124729081 or Wechat：qwqw75.","text":"Welcome to QinWei‘s blog! 本博客有以下八个分类： 前端知识点 全栈知识点 前端面试题 全栈面试题 链接 随笔 散文 其他 This is my first post.If you have any problems in using this website , you can contact me by QQ： 124729081 or Wechat：qwqw75. This website is built usingHexo, and here are some brief introduction. 文件夹目录 node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章 themes：主题 _config.yml: 博客的配置文件 Create a new post（新建日志）1$ hexo new \"My New Post\" More info: Writing Run server（运行服务）1$ hexo server 使用ctrl+c可以把服务关掉。 More info: Server Generate static files（生成静态文件）1$ hexo generate More info: Generating Deploy to remote sites（部署到远程站点）1$ hexo deploy More info: Deployment 更改样式后网站没有生效确认非缓存问题后，执行 hexo clean 再进行生成上传。 清理之前在public文件夹中生成的文件 如何在文章中使用图标先到 fontawesome 找到你需要的图标名，比如：book，按以下格式使用： 1&lt;i class=&quot;icon icon-book&quot;&gt;&lt;/i&gt; 图标样式前缀均为 icon，此外还有 5 个图标大小调节类和 1 个间距类。 1234567891011121314&lt;!-- 1.3倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-lg&quot;&gt;&lt;/i&gt;&lt;!-- 2倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-2x&quot;&gt;&lt;/i&gt;&lt;!-- 3倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-3x&quot;&gt;&lt;/i&gt;&lt;!-- 4倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-4x&quot;&gt;&lt;/i&gt;&lt;!-- 5倍大小 --&gt;&lt;i class=&quot;icon icon-book icon-5x&quot;&gt;&lt;/i&gt;&lt;!-- 5px右边距 --&gt;&lt;i class=&quot;icon icon-book icon-pr&quot;&gt;&lt;/i&gt;&lt;!-- 5px左边距 --&gt;&lt;i class=&quot;icon icon-book icon-pl&quot;&gt;&lt;/i&gt; 个别图标无法显示如果你的浏览器安装了 ADBlock，它会屏蔽 SNS 相关的内容，比如：Github。 解决办法：可配置 ADBlock 不在你的站点运行。 作者：秦伟","categories":[{"name":"其他","slug":"其他","permalink":"http://www.bluedream.top/categories/其他/"}],"tags":[{"name":"欢迎","slug":"欢迎","permalink":"http://www.bluedream.top/tags/欢迎/"},{"name":"介绍","slug":"介绍","permalink":"http://www.bluedream.top/tags/介绍/"},{"name":"Hexo","slug":"Hexo","permalink":"http://www.bluedream.top/tags/Hexo/"}]}]}
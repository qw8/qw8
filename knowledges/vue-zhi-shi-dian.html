<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>vue知识点 | 秦伟博客 | 前端、全栈、SEO的知识点、面试题与学习链接的整理</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="vue,MVVM">
    <meta name="description" content="1.什么是vue的生命周期？Vue实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载DOM-&amp;gt;渲染、更新-&amp;gt;渲染、卸载等一系列过程，我们称这是Vue的生命周期。 2.vue生命周期的作用是什么？它的生命周期中有多个事件钩子，让我们在控制整个vue实例的过程时更容易形成好的逻辑。 3.Vue生命周期总共有几个阶段？它可以总共分为8个阶段：创建前/后，载入前">
<meta name="keywords" content="vue,MVVM">
<meta property="og:type" content="article">
<meta property="og:title" content="vue知识点">
<meta property="og:url" content="https://qw8.github.io/qw8/knowledges/vue-zhi-shi-dian.html">
<meta property="og:site_name" content="秦伟博客">
<meta property="og:description" content="1.什么是vue的生命周期？Vue实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载DOM-&amp;gt;渲染、更新-&amp;gt;渲染、卸载等一系列过程，我们称这是Vue的生命周期。 2.vue生命周期的作用是什么？它的生命周期中有多个事件钩子，让我们在控制整个vue实例的过程时更容易形成好的逻辑。 3.Vue生命周期总共有几个阶段？它可以总共分为8个阶段：创建前/后，载入前">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:updated_time" content="2024-06-06T01:59:24.038Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="vue知识点">
<meta name="twitter:description" content="1.什么是vue的生命周期？Vue实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载DOM-&amp;gt;渲染、更新-&amp;gt;渲染、卸载等一系列过程，我们称这是Vue的生命周期。 2.vue生命周期的作用是什么？它的生命周期中有多个事件钩子，让我们在控制整个vue实例的过程时更容易形成好的逻辑。 3.Vue生命周期总共有几个阶段？它可以总共分为8个阶段：创建前/后，载入前">
<meta name="twitter:image" content="https://qw8.github.io/img/loading.gif">
    
        <link rel="alternate" type="application/atom+xml" title="秦伟博客" href="/qw8/atom.xml">
    
    <link rel="shortcut icon" href="/qw8/img/qw.ico">
    <link rel="stylesheet" href="/qw8/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
<div id="loading" class="active"></div>

<aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/qw8/img/brand.jpg)">
      <div class="brand">
        <a href="/qw8/" class="avatar waves-effect waves-circle waves-light">
          <img src="/qw8/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">秦伟</h5>
          <a href="mailto:124729081@qq.com" title="124729081@qq.com" class="mail">124729081@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/qw8/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/qw8/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/qw8/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/qw8/archives"  >
                <i class="icon icon-lg icon-hourglass"></i>
                时光
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://wpa.qq.com/msgrd?v=3&uin=124729081&site=qq&menu=yes" target="_blank" >
                <i class="icon icon-lg icon-qq"></i>
                聊天
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=124729081@qq.com"  >
                <i class="icon icon-lg icon-envelope-o"></i>
                邮箱
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/qw8/user"  >
                <i class="icon icon-lg icon-user"></i>
                简介
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://gitee.com/qw66" target="_blank" >
                <i class="icon icon-lg icon-code"></i>
                Gitee
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/qw8" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

<main id="main">
    <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">vue知识点</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">vue知识点</h1>
        <h5 class="subtitle">
            
                <time datetime="2024-03-07T13:02:08.000Z" itemprop="datePublished" class="page-time">
  2024-03-07
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/qw8/categories/前端知识点/">前端知识点</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-什么是vue的生命周期？"><span class="post-toc-number">1.</span> <span class="post-toc-text">1.什么是vue的生命周期？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-vue生命周期的作用是什么？"><span class="post-toc-number">2.</span> <span class="post-toc-text">2.vue生命周期的作用是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-Vue生命周期总共有几个阶段？"><span class="post-toc-number">3.</span> <span class="post-toc-text">3.Vue生命周期总共有几个阶段？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-第一次页面加载会触发那几个钩子？"><span class="post-toc-number">4.</span> <span class="post-toc-text">4.第一次页面加载会触发那几个钩子？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-DOM渲染在哪个周期中就已经完成？"><span class="post-toc-number">5.</span> <span class="post-toc-text">5.DOM渲染在哪个周期中就已经完成？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-生命周期钩子的一些使用方法："><span class="post-toc-number">6.</span> <span class="post-toc-text">6.生命周期钩子的一些使用方法：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-v-show与v-if的区别"><span class="post-toc-number">7.</span> <span class="post-toc-text">7.v-show与v-if的区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8-开发中常用的指令有哪些"><span class="post-toc-number">8.</span> <span class="post-toc-text">8.开发中常用的指令有哪些?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#9-绑定class的数组用法"><span class="post-toc-number">9.</span> <span class="post-toc-text">9.绑定class的数组用法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#10-路由跳转方式"><span class="post-toc-number">10.</span> <span class="post-toc-text">10.路由跳转方式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#11-MVVM"><span class="post-toc-number">11.</span> <span class="post-toc-text">11.MVVM</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#12-computed和watch有什么区别"><span class="post-toc-number">12.</span> <span class="post-toc-text">12.computed和watch有什么区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#13-vue组件的scoped属性的作用"><span class="post-toc-number">13.</span> <span class="post-toc-text">13.vue组件的scoped属性的作用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#14-vue是渐进式的框架的理解：-主张最少-没有多做职责之外的事"><span class="post-toc-number">14.</span> <span class="post-toc-text">14.vue是渐进式的框架的理解：(主张最少,没有多做职责之外的事)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#15-vue-js的两个核心是什么-数据驱动、组件系统。"><span class="post-toc-number">15.</span> <span class="post-toc-text">15.vue.js的两个核心是什么(数据驱动、组件系统。)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#16-vue常用修饰符"><span class="post-toc-number">16.</span> <span class="post-toc-text">16.vue常用修饰符</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#①一般修饰符："><span class="post-toc-number">16.1.</span> <span class="post-toc-text">①一般修饰符：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#②-事件修饰符"><span class="post-toc-number">16.2.</span> <span class="post-toc-text">② 事件修饰符</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#③按键修饰符"><span class="post-toc-number">16.3.</span> <span class="post-toc-text">③按键修饰符</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#④系统修饰键-（可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。）"><span class="post-toc-number">16.4.</span> <span class="post-toc-text">④系统修饰键 （可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。）</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#17-v-on可以监听多个方法吗？（可以的）"><span class="post-toc-number">17.</span> <span class="post-toc-text">17.v-on可以监听多个方法吗？（可以的）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#18-vue事件中如何使用event对象"><span class="post-toc-number">18.</span> <span class="post-toc-text">18.vue事件中如何使用event对象</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#19-比如你想让一个dom元素显示，然后下一步去获取这个元素的offsetWidth，最后你获取到的会是0。"><span class="post-toc-number">19.</span> <span class="post-toc-text">19.比如你想让一个dom元素显示，然后下一步去获取这个元素的offsetWidth，最后你获取到的会是0。</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#20-Vue-组件中-data-为什么必须是函数"><span class="post-toc-number">20.</span> <span class="post-toc-text">20.Vue 组件中 data 为什么必须是函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#21-vue中子组件调用父组件的方法"><span class="post-toc-number">21.</span> <span class="post-toc-text">21.vue中子组件调用父组件的方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#22-vue中-keep-alive-组件的作用"><span class="post-toc-number">22.</span> <span class="post-toc-text">22.vue中 keep-alive 组件的作用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#23-vue中如何编写可复用的组件？"><span class="post-toc-number">23.</span> <span class="post-toc-text">23.vue中如何编写可复用的组件？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#24-什么是vue生命周期和生命周期钩子函数？"><span class="post-toc-number">24.</span> <span class="post-toc-text">24.什么是vue生命周期和生命周期钩子函数？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#26-webpack的作用"><span class="post-toc-number">25.</span> <span class="post-toc-text">26.webpack的作用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#webpack怎么工作的过程"><span class="post-toc-number">26.</span> <span class="post-toc-text">webpack怎么工作的过程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#27-vue等单页面应用及其优缺点"><span class="post-toc-number">27.</span> <span class="post-toc-text">27.vue等单页面应用及其优缺点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#28-什么是vue的计算属性computed"><span class="post-toc-number">28.</span> <span class="post-toc-text">28.什么是vue的计算属性computed</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#29-vue-cli提供的几种脚手架模板"><span class="post-toc-number">29.</span> <span class="post-toc-text">29.vue-cli提供的几种脚手架模板</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#30-组件中传递数据？"><span class="post-toc-number">30.</span> <span class="post-toc-text">30.组件中传递数据？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#32-vue-router-的导航钩子-主要用来作用是拦截导航-让他完成跳转或取消。"><span class="post-toc-number">31.</span> <span class="post-toc-text">32.vue-router 的导航钩子,主要用来作用是拦截导航,让他完成跳转或取消。</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#33-完整的-vue-router-导航解析流程"><span class="post-toc-number">32.</span> <span class="post-toc-text">33.完整的 vue-router 导航解析流程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#34-vue-router如何响应-路由参数-的变化？"><span class="post-toc-number">33.</span> <span class="post-toc-text">34.vue-router如何响应 路由参数 的变化？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#35-vue-router的几种实例方法以及参数传递"><span class="post-toc-number">34.</span> <span class="post-toc-text">35.vue-router的几种实例方法以及参数传递</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#36-is的用法（用于动态组件且基于-DOM-内模板的限制来工作。）"><span class="post-toc-number">35.</span> <span class="post-toc-text">36.is的用法（用于动态组件且基于 DOM 内模板的限制来工作。）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#动态组件"><span class="post-toc-number">36.</span> <span class="post-toc-text">动态组件</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#37-vuex是什么？怎么使用？哪种功能场景使用它？"><span class="post-toc-number">37.</span> <span class="post-toc-text">37.vuex是什么？怎么使用？哪种功能场景使用它？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#说说你对-SPA-单页面的理解，它的优缺点分别是什么？"><span class="post-toc-number">38.</span> <span class="post-toc-text">说说你对 SPA 单页面的理解，它的优缺点分别是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#v-show-与-v-if-有什么区别？"><span class="post-toc-number">39.</span> <span class="post-toc-text">v-show 与 v-if 有什么区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Class-与-Style-如何动态绑定？"><span class="post-toc-number">40.</span> <span class="post-toc-text">Class 与 Style 如何动态绑定？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#怎样理解-Vue-的单向数据流？"><span class="post-toc-number">41.</span> <span class="post-toc-text">怎样理解 Vue 的单向数据流？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#computed-和-watch-的区别和运用的场景？"><span class="post-toc-number">42.</span> <span class="post-toc-text">computed 和 watch 的区别和运用的场景？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#直接给一个数组项赋值，Vue-能检测到变化吗？"><span class="post-toc-number">43.</span> <span class="post-toc-text">直接给一个数组项赋值，Vue 能检测到变化吗？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#谈谈你对-Vue-生命周期的理解？"><span class="post-toc-number">44.</span> <span class="post-toc-text">谈谈你对 Vue 生命周期的理解？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#（1）生命周期是什么？"><span class="post-toc-number">44.1.</span> <span class="post-toc-text">（1）生命周期是什么？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#（2）各个生命周期的作用"><span class="post-toc-number">44.2.</span> <span class="post-toc-text">（2）各个生命周期的作用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#（3）生命周期示意图"><span class="post-toc-number">44.3.</span> <span class="post-toc-text">（3）生命周期示意图</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Vue-的父组件和子组件生命周期钩子函数执行顺序？"><span class="post-toc-number">45.</span> <span class="post-toc-text">Vue 的父组件和子组件生命周期钩子函数执行顺序？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#在哪个生命周期内调用异步请求？"><span class="post-toc-number">46.</span> <span class="post-toc-text">在哪个生命周期内调用异步请求？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#在什么阶段才能访问操作DOM？"><span class="post-toc-number">47.</span> <span class="post-toc-text">在什么阶段才能访问操作DOM？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#父组件可以监听到子组件的生命周期吗？"><span class="post-toc-number">48.</span> <span class="post-toc-text">父组件可以监听到子组件的生命周期吗？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#谈谈你对-keep-alive-的了解？"><span class="post-toc-number">49.</span> <span class="post-toc-text">谈谈你对 keep-alive 的了解？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#组件中-data-为什么是一个函数？"><span class="post-toc-number">50.</span> <span class="post-toc-text">组件中 data 为什么是一个函数？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#v-model-的原理？"><span class="post-toc-number">51.</span> <span class="post-toc-text">v-model 的原理？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Vue-组件间通信有哪几种方式？"><span class="post-toc-number">52.</span> <span class="post-toc-text">Vue 组件间通信有哪几种方式？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#父传子"><span class="post-toc-number">52.1.</span> <span class="post-toc-text">父传子</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#props"><span class="post-toc-number">52.1.1.</span> <span class="post-toc-text">props</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#refs"><span class="post-toc-number">52.1.2.</span> <span class="post-toc-text">refs</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#子传父"><span class="post-toc-number">52.2.</span> <span class="post-toc-text">子传父</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#sync-传参绑定"><span class="post-toc-number">52.3.</span> <span class="post-toc-text">.sync 传参绑定</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#兄弟组件：通过共同祖辈组件"><span class="post-toc-number">52.4.</span> <span class="post-toc-text">兄弟组件：通过共同祖辈组件</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#EventBus"><span class="post-toc-number">52.5.</span> <span class="post-toc-text">EventBus</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#dispatch：后代给祖先传值"><span class="post-toc-number">52.6.</span> <span class="post-toc-text">dispatch：后代给祖先传值</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#任意两个组件之间：事件总线-或-vuex"><span class="post-toc-number">52.7.</span> <span class="post-toc-text">任意两个组件之间：事件总线 或 vuex</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#sync修饰符"><span class="post-toc-number">53.</span> <span class="post-toc-text">.sync修饰符</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-作用"><span class="post-toc-number">53.1.</span> <span class="post-toc-text">1.作用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-场景"><span class="post-toc-number">53.2.</span> <span class="post-toc-text">2.场景</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-本质"><span class="post-toc-number">53.3.</span> <span class="post-toc-text">3.本质</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-案例一"><span class="post-toc-number">53.4.</span> <span class="post-toc-text">4.案例一</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-案例二"><span class="post-toc-number">53.5.</span> <span class="post-toc-text">5.案例二</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#你使用过-Vuex-吗？"><span class="post-toc-number">54.</span> <span class="post-toc-text">你使用过 Vuex 吗？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用过-Vue-SSR-吗？说说-SSR？"><span class="post-toc-number">55.</span> <span class="post-toc-text">使用过 Vue SSR 吗？说说 SSR？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#服务端渲染-SSR-的优缺点如下："><span class="post-toc-number">56.</span> <span class="post-toc-text">服务端渲染 SSR 的优缺点如下：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#vue-router-路由模式有几种？"><span class="post-toc-number">57.</span> <span class="post-toc-text">vue-router 路由模式有几种？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？"><span class="post-toc-number">58.</span> <span class="post-toc-text">能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#（1）hash-模式的实现原理"><span class="post-toc-number">58.1.</span> <span class="post-toc-text">（1）hash 模式的实现原理</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#（2）history-模式的实现原理"><span class="post-toc-number">58.2.</span> <span class="post-toc-text">（2）history 模式的实现原理</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是-MVVM？"><span class="post-toc-number">59.</span> <span class="post-toc-text">什么是 MVVM？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#（1）View-层"><span class="post-toc-number">59.1.</span> <span class="post-toc-text">（1）View 层</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#（2）Model-层"><span class="post-toc-number">59.2.</span> <span class="post-toc-text">（2）Model 层</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#（3）ViewModel-层"><span class="post-toc-number">59.3.</span> <span class="post-toc-text">（3）ViewModel 层</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Vue-是如何实现数据双向绑定的？"><span class="post-toc-number">60.</span> <span class="post-toc-text">Vue 是如何实现数据双向绑定的？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Vue-框架怎么实现对象和数组的监听？"><span class="post-toc-number">61.</span> <span class="post-toc-text">Vue 框架怎么实现对象和数组的监听？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Proxy-与-Object-defineProperty-优劣对比"><span class="post-toc-number">62.</span> <span class="post-toc-text">Proxy 与 Object.defineProperty 优劣对比</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#vue中this-set的用法"><span class="post-toc-number">63.</span> <span class="post-toc-text">vue中this.$set的用法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#vue更新数组时触发视图更新的方法"><span class="post-toc-number">64.</span> <span class="post-toc-text">vue更新数组时触发视图更新的方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#直接给一个数组项赋值，Vue-能检测到变化吗？-1"><span class="post-toc-number">65.</span> <span class="post-toc-text">直接给一个数组项赋值，Vue 能检测到变化吗？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#vue更新数组时触发视图更新的方法-1"><span class="post-toc-number">66.</span> <span class="post-toc-text">vue更新数组时触发视图更新的方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#vue的数据是响应式的，请问什么时候是非响应式的并如何解决"><span class="post-toc-number">67.</span> <span class="post-toc-text">vue的数据是响应式的，请问什么时候是非响应式的并如何解决</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#数组数据："><span class="post-toc-number">67.1.</span> <span class="post-toc-text">数组数据：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#对象数据变化："><span class="post-toc-number">67.2.</span> <span class="post-toc-text">对象数据变化：</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#vm-set-obj-key-val-做了什么？"><span class="post-toc-number">68.</span> <span class="post-toc-text">vm.$set(obj, key, val) 做了什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Vue-怎么用-vm-set-解决对象新增属性不能响应的问题-？"><span class="post-toc-number">69.</span> <span class="post-toc-text">Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#虚拟-DOM-的优缺点？"><span class="post-toc-number">70.</span> <span class="post-toc-text">虚拟 DOM 的优缺点？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#虚拟-DOM-实现原理？"><span class="post-toc-number">71.</span> <span class="post-toc-text">虚拟 DOM 实现原理？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#你有对-Vue-项目进行哪些优化？"><span class="post-toc-number">72.</span> <span class="post-toc-text">你有对 Vue 项目进行哪些优化？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#（1）代码层面的优化"><span class="post-toc-number">72.1.</span> <span class="post-toc-text">（1）代码层面的优化</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#（2）Webpack-层面的优化"><span class="post-toc-number">72.2.</span> <span class="post-toc-text">（2）Webpack 层面的优化</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#（3）基础的-Web-技术的优化"><span class="post-toc-number">72.3.</span> <span class="post-toc-text">（3）基础的 Web 技术的优化</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#vue路由组件动态引入"><span class="post-toc-number">73.</span> <span class="post-toc-text">vue路由组件动态引入</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#对于即将到来的-vue3-0-特性你有什么了解的吗？"><span class="post-toc-number">74.</span> <span class="post-toc-text">对于即将到来的 vue3.0 特性你有什么了解的吗？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#（1）监测机制的改变"><span class="post-toc-number">74.1.</span> <span class="post-toc-text">（1）监测机制的改变</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#（2）模板"><span class="post-toc-number">74.2.</span> <span class="post-toc-text">（2）模板</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#（3）对象式的组件声明方式"><span class="post-toc-number">74.3.</span> <span class="post-toc-text">（3）对象式的组件声明方式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#（4）其它方面的更改"><span class="post-toc-number">74.4.</span> <span class="post-toc-text">（4）其它方面的更改</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#说说你使用-Vue-框架踩过最大的坑是什么？怎么解决的？"><span class="post-toc-number"></span> <span class="post-toc-text">说说你使用 Vue 框架踩过最大的坑是什么？怎么解决的？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#MVVM是什么"><span class="post-toc-number">1.</span> <span class="post-toc-text">MVVM是什么?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#MVVM的优缺点"><span class="post-toc-number">2.</span> <span class="post-toc-text">MVVM的优缺点?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#异步请求适合在哪个生命周期调用？"><span class="post-toc-number">3.</span> <span class="post-toc-text">异步请求适合在哪个生命周期调用？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Vue组件如何通信？"><span class="post-toc-number">4.</span> <span class="post-toc-text">Vue组件如何通信？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#computed和watch有什么区别"><span class="post-toc-number">5.</span> <span class="post-toc-text">computed和watch有什么区别?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Vue是如何实现双向绑定的"><span class="post-toc-number">6.</span> <span class="post-toc-text">Vue是如何实现双向绑定的?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Proxy与Object-defineProperty的优劣对比"><span class="post-toc-number">7.</span> <span class="post-toc-text">Proxy与Object.defineProperty的优劣对比?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#你是如何理解Vue的响应式系统的"><span class="post-toc-number">8.</span> <span class="post-toc-text">你是如何理解Vue的响应式系统的?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#虚拟DOM的优劣如何"><span class="post-toc-number">9.</span> <span class="post-toc-text">虚拟DOM的优劣如何?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#虚拟DOM实现原理"><span class="post-toc-number">10.</span> <span class="post-toc-text">虚拟DOM实现原理?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#既然Vue通过数据劫持可以精准探测数据变化-为什么还需要虚拟DOM进行diff检测差异"><span class="post-toc-number">11.</span> <span class="post-toc-text">既然Vue通过数据劫持可以精准探测数据变化,为什么还需要虚拟DOM进行diff检测差异?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Vue为什么没有类似于React中shouldComponentUpdate的生命周期？"><span class="post-toc-number">12.</span> <span class="post-toc-text">Vue为什么没有类似于React中shouldComponentUpdate的生命周期？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Vue中的key到底有什么用？"><span class="post-toc-number">13.</span> <span class="post-toc-text">Vue中的key到底有什么用？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#vue-cli提供了几种脚手架模板"><span class="post-toc-number">14.</span> <span class="post-toc-text">vue-cli提供了几种脚手架模板</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#computed、methods的区别"><span class="post-toc-number">15.</span> <span class="post-toc-text">computed、methods的区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是自定义指令，有哪些钩子函数及自定义指令的使用场景"><span class="post-toc-number">16.</span> <span class="post-toc-text">什么是自定义指令，有哪些钩子函数及自定义指令的使用场景</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#父组件获取异步动态数据传递给子组件"><span class="post-toc-number">17.</span> <span class="post-toc-text">父组件获取异步动态数据传递给子组件</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#vue-router实现原理"><span class="post-toc-number">18.</span> <span class="post-toc-text">vue-router实现原理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#那与传统的页面跳转有什么区别呢？"><span class="post-toc-number">18.1.</span> <span class="post-toc-text">那与传统的页面跳转有什么区别呢？</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#路由模式"><span class="post-toc-number">19.</span> <span class="post-toc-text">路由模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Hash模式"><span class="post-toc-number">19.1.</span> <span class="post-toc-text">Hash模式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#History模式"><span class="post-toc-number">19.2.</span> <span class="post-toc-text">History模式</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#配置Apache"><span class="post-toc-number">20.</span> <span class="post-toc-text">配置Apache</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Vuex"><span class="post-toc-number">21.</span> <span class="post-toc-text">Vuex</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#vuex中如何异步修改数据"><span class="post-toc-number">22.</span> <span class="post-toc-text">vuex中如何异步修改数据</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#荣耀黄金"><span class="post-toc-number"></span> <span class="post-toc-text">荣耀黄金</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-Vue的优点？Vue的缺点？"><span class="post-toc-number">1.</span> <span class="post-toc-text">1. Vue的优点？Vue的缺点？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-为什么说Vue是一个渐进式框架？"><span class="post-toc-number">2.</span> <span class="post-toc-text">2. 为什么说Vue是一个渐进式框架？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-Vue跟React的异同点？"><span class="post-toc-number">3.</span> <span class="post-toc-text">3. Vue跟React的异同点？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-MVVM是什么？和MVC有何区别呢？"><span class="post-toc-number">4.</span> <span class="post-toc-text">4. MVVM是什么？和MVC有何区别呢？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-Vue和JQuery的区别在哪？为什么放弃JQuery用Vue？"><span class="post-toc-number">5.</span> <span class="post-toc-text">5. Vue和JQuery的区别在哪？为什么放弃JQuery用Vue？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-Vue的作者是谁？大声说出它的名字！！！"><span class="post-toc-number">6.</span> <span class="post-toc-text">6. Vue的作者是谁？大声说出它的名字！！！</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#永恒钻石"><span class="post-toc-number"></span> <span class="post-toc-text">永恒钻石</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-为什么data是个函数并且返回一个对象呢？"><span class="post-toc-number">1.</span> <span class="post-toc-text">7. 为什么data是个函数并且返回一个对象呢？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8-使用过哪些Vue的修饰符呢？"><span class="post-toc-number">2.</span> <span class="post-toc-text">8. 使用过哪些Vue的修饰符呢？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#9-使用过哪些Vue的内部指令呢？"><span class="post-toc-number">3.</span> <span class="post-toc-text">9. 使用过哪些Vue的内部指令呢？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#10-组件之间的传值方式有哪些？"><span class="post-toc-number">4.</span> <span class="post-toc-text">10. 组件之间的传值方式有哪些？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#11-路由有哪些模式呢？又有什么不同呢？"><span class="post-toc-number">5.</span> <span class="post-toc-text">11. 路由有哪些模式呢？又有什么不同呢？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#12-如何设置动态class，动态style？"><span class="post-toc-number">6.</span> <span class="post-toc-text">12. 如何设置动态class，动态style？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#13-v-if和v-show有何区别？"><span class="post-toc-number">7.</span> <span class="post-toc-text">13. v-if和v-show有何区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#14-computed和watch有何区别？"><span class="post-toc-number">8.</span> <span class="post-toc-text">14. computed和watch有何区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#15-Vue的生命周期，讲一讲？"><span class="post-toc-number">9.</span> <span class="post-toc-text">15. Vue的生命周期，讲一讲？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#16-为什么v-if和v-for不建议用在同一标签？"><span class="post-toc-number">10.</span> <span class="post-toc-text">16. 为什么v-if和v-for不建议用在同一标签？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#17-vuex的有哪些属性？用处是什么？"><span class="post-toc-number">11.</span> <span class="post-toc-text">17. vuex的有哪些属性？用处是什么？</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#至尊星耀"><span class="post-toc-number"></span> <span class="post-toc-text">至尊星耀</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#18-不需要响应式的数据应该怎么处理？"><span class="post-toc-number">1.</span> <span class="post-toc-text">18. 不需要响应式的数据应该怎么处理？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#19-watch有哪些属性，分别有什么用？"><span class="post-toc-number">2.</span> <span class="post-toc-text">19. watch有哪些属性，分别有什么用？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#20-父子组件生命周期顺序"><span class="post-toc-number">3.</span> <span class="post-toc-text">20. 父子组件生命周期顺序</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#21-对象新属性无法更新视图，删除属性无法更新视图，为什么？怎么办？"><span class="post-toc-number">4.</span> <span class="post-toc-text">21. 对象新属性无法更新视图，删除属性无法更新视图，为什么？怎么办？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#22-直接arr-index-xxx无法更新视图怎么办？为什么？怎么办？"><span class="post-toc-number">5.</span> <span class="post-toc-text">22. 直接arr[index] = xxx无法更新视图怎么办？为什么？怎么办？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#24-插槽的使用以及原理？"><span class="post-toc-number">6.</span> <span class="post-toc-text">24. 插槽的使用以及原理？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#25-为什么不建议用index做key，为什么不建议用随机数做key？"><span class="post-toc-number">7.</span> <span class="post-toc-text">25. 为什么不建议用index做key，为什么不建议用随机数做key？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#26-说说nextTick的用处？"><span class="post-toc-number">8.</span> <span class="post-toc-text">26. 说说nextTick的用处？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#27-Vue的SSR是什么？有什么好处？"><span class="post-toc-number">9.</span> <span class="post-toc-text">27. Vue的SSR是什么？有什么好处？</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#最强王者"><span class="post-toc-number"></span> <span class="post-toc-text">最强王者</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#28-Vue响应式是怎么实现的？"><span class="post-toc-number">1.</span> <span class="post-toc-text">28. Vue响应式是怎么实现的？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#29-为什么只对对象劫持，而要对数组进行方法重写？"><span class="post-toc-number">2.</span> <span class="post-toc-text">29. 为什么只对对象劫持，而要对数组进行方法重写？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#30-Vue的模板编译原理？"><span class="post-toc-number">3.</span> <span class="post-toc-text">30. Vue的模板编译原理？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#31-Vue的computed和watch的原理？"><span class="post-toc-number">4.</span> <span class="post-toc-text">31. Vue的computed和watch的原理？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#32-Vue-set方法的原理？"><span class="post-toc-number">5.</span> <span class="post-toc-text">32. Vue.set方法的原理？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#33-Vue-delete方法的原理？"><span class="post-toc-number">6.</span> <span class="post-toc-text">33. Vue.delete方法的原理？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#34-nextTick的原理？"><span class="post-toc-number">7.</span> <span class="post-toc-text">34. nextTick的原理？</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#冷门的知识点"><span class="post-toc-number"></span> <span class="post-toc-text">冷门的知识点</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#36-如果子组件改变props里的数据会发生什么"><span class="post-toc-number">1.</span> <span class="post-toc-text">36. 如果子组件改变props里的数据会发生什么</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#37-props怎么自定义验证"><span class="post-toc-number">2.</span> <span class="post-toc-text">37. props怎么自定义验证</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#38-watch的immediate属性有什么用？"><span class="post-toc-number">3.</span> <span class="post-toc-text">38. watch的immediate属性有什么用？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#39-watch监听一个对象时，如何排除某些属性的监听"><span class="post-toc-number">4.</span> <span class="post-toc-text">39. watch监听一个对象时，如何排除某些属性的监听</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#40-审查元素时发现data-v-xxxxx，这是啥？"><span class="post-toc-number">5.</span> <span class="post-toc-text">40. 审查元素时发现data-v-xxxxx，这是啥？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#41-computed如何实现传参？"><span class="post-toc-number">6.</span> <span class="post-toc-text">41. computed如何实现传参？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#42-vue的hook的使用"><span class="post-toc-number">7.</span> <span class="post-toc-text">42. vue的hook的使用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#43-provide和inject是响应式的吗？"><span class="post-toc-number">8.</span> <span class="post-toc-text">43. provide和inject是响应式的吗？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#44-Vue的el属性和-mount优先级？"><span class="post-toc-number">9.</span> <span class="post-toc-text">44.Vue的el属性和 $mount优先级？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#45-动态指令和参数使用过吗？"><span class="post-toc-number">10.</span> <span class="post-toc-text">45. 动态指令和参数使用过吗？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#46-相同的路由组件如何重新渲染？"><span class="post-toc-number">11.</span> <span class="post-toc-text">46. 相同的路由组件如何重新渲染？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#47-自定义v-model"><span class="post-toc-number">12.</span> <span class="post-toc-text">47. 自定义v-model</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#48-如何将获取data中某一个数据的初始状态？"><span class="post-toc-number">13.</span> <span class="post-toc-text">48. 如何将获取data中某一个数据的初始状态？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#49-为什么不建议v-for和v-if同时存在"><span class="post-toc-number">14.</span> <span class="post-toc-text">49.为什么不建议v-for和v-if同时存在</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#50-计算变量时，methods和computed哪个好？"><span class="post-toc-number">15.</span> <span class="post-toc-text">50.计算变量时，methods和computed哪个好？</span></a></li></ol>
        </nav>
    </aside>


<article id="post-knowledges/vue知识点"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">vue知识点</h1>
        <div class="post-meta">
            <time class="post-time" title="2024-03-07 21:02:08" datetime="2024-03-07T13:02:08.000Z"  itemprop="datePublished">2024-03-07</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/qw8/categories/前端知识点/">前端知识点</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h3 id="1-什么是vue的生命周期？"><a href="#1-什么是vue的生命周期？" class="headerlink" title="1.什么是vue的生命周期？"></a>1.什么是vue的生命周期？</h3><p>Vue实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载DOM-&gt;渲染、更新-&gt;渲染、卸载等一系列过程，我们称这是Vue的生命周期。</p>
<h3 id="2-vue生命周期的作用是什么？"><a href="#2-vue生命周期的作用是什么？" class="headerlink" title="2.vue生命周期的作用是什么？"></a>2.vue生命周期的作用是什么？</h3><p>它的生命周期中有多个事件钩子，让我们在控制整个vue实例的过程时更容易形成好的逻辑。</p>
<h3 id="3-Vue生命周期总共有几个阶段？"><a href="#3-Vue生命周期总共有几个阶段？" class="headerlink" title="3.Vue生命周期总共有几个阶段？"></a>3.Vue生命周期总共有几个阶段？</h3><p>它可以总共分为8个阶段：创建前/后，载入前/后，更新前/后，销毁前/销毁后</p>
<h3 id="4-第一次页面加载会触发那几个钩子？"><a href="#4-第一次页面加载会触发那几个钩子？" class="headerlink" title="4.第一次页面加载会触发那几个钩子？"></a>4.第一次页面加载会触发那几个钩子？</h3><p>第一次页面加载时会触发beforeCreate,created,beforeMount,mounted</p>
<h3 id="5-DOM渲染在哪个周期中就已经完成？"><a href="#5-DOM渲染在哪个周期中就已经完成？" class="headerlink" title="5.DOM渲染在哪个周期中就已经完成？"></a>5.DOM渲染在哪个周期中就已经完成？</h3><p>DOM渲染在mounted中就已经完成了</p>
<h3 id="6-生命周期钩子的一些使用方法："><a href="#6-生命周期钩子的一些使用方法：" class="headerlink" title="6.生命周期钩子的一些使用方法："></a>6.生命周期钩子的一些使用方法：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>beforecreate:可以在加个loading事件，在加载实例是触发</span><br><span class="line"><span class="number">2.</span>created:初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用</span><br><span class="line"><span class="number">3.</span>mounted:挂载元素，获取到dom节点</span><br><span class="line"><span class="number">4.</span>updated:如果对数据统一处理，在这里写上相应函数</span><br><span class="line"><span class="number">5.</span>beforeDestroy:可以一个确认停止事件的确认框</span><br><span class="line"><span class="number">6.</span>nextTick:更新数据后立即操作dom</span><br></pre></td></tr></table></figure>

<h3 id="7-v-show与v-if的区别"><a href="#7-v-show与v-if的区别" class="headerlink" title="7.v-show与v-if的区别"></a>7.v-show与v-if的区别</h3><p>v-show是css切换，v-if是完整的销毁和重新创建<br>使用频繁切换时用v-show,运行时较少改变时用v-if<br>V-if=’false’v-if是条件渲染，当false的时候不会渲染<br>使用v-if的时候，如果值为false，那么页面将不会有这个html标签生成<br>v-show则是不管值是为true还是false，html元素都会存在，只是css中的display显示或隐藏<br>v-show 仅仅控制元素的显示方式，将 display 属性在 block 和 none 来回切换；而v-if会控制这个 DOM 节点的存在与否。</p>
<p><strong>当我们需要经常切换某个元素的显示/隐藏时，使用v-show会更加节省性能上的开销；</strong></p>
<p><strong>当只需要一次显示或隐藏时，使用v-if更加合理。</strong></p>
<h3 id="8-开发中常用的指令有哪些"><a href="#8-开发中常用的指令有哪些" class="headerlink" title="8.开发中常用的指令有哪些?"></a>8.开发中常用的指令有哪些?</h3><p>v-model:一般用在表达输入，很轻松的实现表单控件和数据的双向绑定<br>v-html：更新元素的innerHTML<br>v-show与v-if：条件渲染，注意二者区别<br>v-on:click:可以简写为@click,@绑定一个事件。如果事件触发了，就可以指定事件的处理函数<br>v-for：基于源数据多次渲染元素或模板<br>v-bind:当表达式的值改变时，将其产生的连带影响，响应式地作用于DOM语法<br>v-bind:title=”msg”简写 :title=”msg”</p>
<h3 id="9-绑定class的数组用法"><a href="#9-绑定class的数组用法" class="headerlink" title="9.绑定class的数组用法"></a>9.绑定class的数组用法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>对象方法v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"&#123;'orange':isRipe, 'green':isNotRipe&#125;”</span></span><br><span class="line"><span class="string">2.数组方法v-bind:class="</span>[class1,class2]<span class="string">"</span></span><br><span class="line"><span class="string">3.行内v-bind:style="</span>&#123;<span class="attr">color</span>:color,<span class="attr">fontSize</span>:fontSize+<span class="string">'px'</span>&#125;”</span><br></pre></td></tr></table></figure>

<h3 id="10-路由跳转方式"><a href="#10-路由跳转方式" class="headerlink" title="10.路由跳转方式"></a>10.路由跳转方式</h3><p>1.router-link标签会渲染为标签，咋填template中的跳转都是这种；<br>2.另一种是编辑是导航，也就是通过js跳转比如router.push(‘/home’)</p>
<h3 id="11-MVVM"><a href="#11-MVVM" class="headerlink" title="11.MVVM"></a>11.MVVM</h3><p>M-model，model代表数据模型，也可以在model中定义数据修改和操作的业务逻辑</p>
<p>V-view,view代表UI组件，它负责将数据模型转化为UI展现出来</p>
<p>VM-viewmodel,viewmodel监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步view和model的对象，连接model和view</p>
<h3 id="12-computed和watch有什么区别"><a href="#12-computed和watch有什么区别" class="headerlink" title="12.computed和watch有什么区别"></a>12.<strong>computed和watch有什么区别</strong></h3><p><strong>computed</strong></p>
<p>computed是计算属性，也就是计算值，它<strong>更多用于计算值的场景</strong><br>computed具有缓存性，computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时重新调用对应的getter来计算<br>computed适用于计算比较消耗性能的计算场景</p>
<p><strong>watch</strong></p>
<p>watch更多的是[观察]的作用，类似于某些数据的监听回调，用于观察props $emit或者本组件的值，当数据变化时来执行回调进行后续操作<br>无缓存性，页面重新渲染时值不变化也会执行</p>
<p><strong>小结</strong></p>
<p><strong>当我们要进行数值计算，而且依赖于其他数据，那么把这个数据设计为computed</strong><br><strong>如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化。</strong></p>
<h3 id="13-vue组件的scoped属性的作用"><a href="#13-vue组件的scoped属性的作用" class="headerlink" title="13.vue组件的scoped属性的作用"></a>13.<strong>vue组件的scoped属性的作用</strong></h3><p>在style标签上添加scoped属性，以表示它的样式作用于当下的模块，很好的实现了样式私有化的目的；<br>但是也得慎用：样式不易（可）修改，而很多时候，我们是需要对公共组件的样式做微调的；</p>
<p><strong>解决办法：</strong></p>
<p>①：使用混合型的css样式：（混合使用全局跟本地的样式） </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt; /* 全局样式 */ &lt;/style&gt;</span><br><span class="line">&lt;style scoped&gt; /* 本地样式 */ &lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>②：深度作用选择器（&gt;&gt;&gt;）如果你希望 scoped 样式中的一个选择器能够作用得“更深”，例如影响子组件，你可以使用 &gt;&gt;&gt; 操作符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt; .a &gt;&gt;&gt; .b &#123; /* ... */ &#125; &lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="14-vue是渐进式的框架的理解：-主张最少-没有多做职责之外的事"><a href="#14-vue是渐进式的框架的理解：-主张最少-没有多做职责之外的事" class="headerlink" title="14.vue是渐进式的框架的理解：(主张最少,没有多做职责之外的事)"></a>14.vue是渐进式的框架的理解：(<strong>主张最少,没有多做职责之外的事</strong>)</h3><p>Vue的核心的功能，是一个视图模板引擎，但这不是说Vue就不能成为一个框架。如下图所示，这里包含了Vue的所有部件，在声明式渲染（视图模板引擎）的基础上，我们可以通过添加组件系统、客户端路由、大规模状态管理来构建一个完整的框架。更重要的是，这些功能相互独立，你可以在核心功能的基础上任意选用其他的部件，不一定要全部整合在一起。可以看到，所说的“渐进式”，其实就是Vue的使用方式，同时也体现了Vue的设计的理念<br>在我看来，渐进式代表的含义是：主张最少。视图模板引擎<br>每个框架都不可避免会有自己的一些特点，从而会对使用者有一定的要求，这些要求就是主张，主张有强有弱，它的强势程度会影响在业务开发中的使用方式。<br>比如说，Angular，它两个版本都是强主张的，如果你用它，必须接受以下东西：<br>必须使用它的模块机制- 必须使用它的依赖注入- 必须使用它的特殊形式定义组件（这一点每个视图框架都有，难以避免）<br>所以Angular是带有比较强的排它性的，如果你的应用不是从头开始，而是要不断考虑是否跟其他东西集成，这些主张会带来一些困扰。<br>Vue可能有些方面是不如React，不如Angular，但它是渐进的，没有强主张，你可以在原有大系统的上面，把一两个组件改用它实现，当jQuery用；也可以整个用它全家桶开发，当Angular用；还可以用它的视图，搭配你自己设计的整个下层用。也可以函数式，都可以，它只是个轻量视图而已，只做了自己该做的事，没有做不该做的事，仅此而已。<br><strong>渐进式的含义，我的理解是：没有多做职责之外的事。</strong></p>
<h3 id="15-vue-js的两个核心是什么-数据驱动、组件系统。"><a href="#15-vue-js的两个核心是什么-数据驱动、组件系统。" class="headerlink" title="15.vue.js的两个核心是什么(数据驱动、组件系统。)"></a>15.vue.js的两个核心是什么(数据驱动、组件系统。)</h3><p>数据驱动:Object.defineProperty和存储器属性: getter和setter（所以只兼容IE9及以上版本），可称为基于依赖收集的观测机制,核心是VM，即ViewModel，保证数据和视图的一致性。<br>组件系统:<a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/tangxiujiang/article/details/79620542%23commentBox" target="_blank" rel="noopener">点此查看</a></p>
<h3 id="16-vue常用修饰符"><a href="#16-vue常用修饰符" class="headerlink" title="16.vue常用修饰符"></a>16.vue常用修饰符</h3><p><strong>修饰符分为：一般修饰符，事件修饰符，按键、系统</strong></p>
<h4 id="①一般修饰符："><a href="#①一般修饰符：" class="headerlink" title="①一般修饰符："></a>①一般修饰符：</h4><p>.lazy：v-model 在每次 input 事件触发后将输入框的值与数据进行同步 。你可以添加 lazy 修饰符，从而转变为使用 change 事件进行同步</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model.lazy=<span class="string">"msg"</span> &gt;</span><br></pre></td></tr></table></figure>

<p><strong>.number</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model.number=<span class="string">"age"</span> type=<span class="string">"number"</span>&gt;</span><br></pre></td></tr></table></figure>

<p><strong>.trim</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>如果要自动过滤用户输入的首尾空白字符 &lt;input v-model.trim=<span class="string">'trim'</span>&gt;</span><br></pre></td></tr></table></figure>

<h4 id="②-事件修饰符"><a href="#②-事件修饰符" class="headerlink" title="② 事件修饰符"></a>② 事件修饰符</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-on:click.stop=<span class="string">"doThis"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><span class="xml"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span> <span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">"doThat"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span>   <span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">"doThis"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>   <span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span> <span class="comment">&lt;!-- 即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理 --&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">"doThat"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  <span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span> <span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.once</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="comment">&lt;!-- 点击事件将只会触发一次 --&gt;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="③按键修饰符"><a href="#③按键修饰符" class="headerlink" title="③按键修饰符"></a>③按键修饰符</h4><p>全部的按键别名:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.enter</span><br><span class="line">.tab</span><br><span class="line">.delete (捕获“删除”和“退格”键)</span><br><span class="line">.esc</span><br><span class="line">.space</span><br><span class="line">.up</span><br><span class="line">.down</span><br><span class="line">.left</span><br><span class="line">.right</span><br><span class="line">.ctrl</span><br><span class="line">.alt</span><br><span class="line">.shift</span><br><span class="line">.meta</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-on:keyup.enter=<span class="string">"submit"</span>&gt; 或者 &lt;input @keyup.enter=<span class="string">"submit"</span>&gt;</span><br></pre></td></tr></table></figure>

<h4 id="④系统修饰键-（可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。）"><a href="#④系统修饰键-（可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。）" class="headerlink" title="④系统修饰键 （可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。）"></a>④系统修饰键 （可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.ctrl</span><br><span class="line">.alt</span><br><span class="line">.shift</span><br><span class="line">.meta</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input @keyup.alt<span class="number">.67</span>=<span class="string">"clear"</span>&gt; 或者 &lt;div @click.ctrl=<span class="string">"doSomething"</span>&gt;Do something&lt;<span class="regexp">/div&gt;&lt;!-- Ctrl + Click --&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="17-v-on可以监听多个方法吗？（可以的）"><a href="#17-v-on可以监听多个方法吗？（可以的）" class="headerlink" title="17.v-on可以监听多个方法吗？（可以的）"></a>17.<strong>v-on可以监听多个方法吗？（可以的）</strong></h3><p>一个元素绑定多个事件的两种写法，一个事件绑定多个函数的两种写法，修饰符的使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a style=<span class="string">"cursor:default"</span> v-on=<span class="string">'&#123;click:DoSomething,mouseleave:MouseLeave&#125;'</span>&gt;doSomething&lt;<span class="regexp">/a&gt;</span></span><br></pre></td></tr></table></figure>

<p>在method方法里面分别写两个时事件；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=<span class="string">"a(),b()"</span>&gt;点我ab&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="18-vue事件中如何使用event对象"><a href="#18-vue事件中如何使用event对象" class="headerlink" title="18.vue事件中如何使用event对象"></a>18.<strong>vue事件中如何使用event对象</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=<span class="string">"Event($event)"</span>&gt;事件对象&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="19-比如你想让一个dom元素显示，然后下一步去获取这个元素的offsetWidth，最后你获取到的会是0。"><a href="#19-比如你想让一个dom元素显示，然后下一步去获取这个元素的offsetWidth，最后你获取到的会是0。" class="headerlink" title="19.比如你想让一个dom元素显示，然后下一步去获取这个元素的offsetWidth，最后你获取到的会是0。"></a>19.<strong>比如你想让一个dom元素显示</strong>，然后下一步去获取这个元素的offsetWidth，最后你获取到的会是0。</h3><p>因为你改变数据把show变成true,元素并不会立即显示，理所当然也不会获取到动态宽度。<br>正确的做法是先把元素show出来，在$nextTick去执行获取宽度的操作，不知道这样说会不会好理解一点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">openSubmenu() &#123;</span><br><span class="line">	<span class="keyword">this</span>.show = <span class="literal">true</span> <span class="comment">//获取不到宽度</span></span><br><span class="line">	<span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="comment">//这里才可以 let w = this.$refs.submenu.offsetWidth;</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20-Vue-组件中-data-为什么必须是函数"><a href="#20-Vue-组件中-data-为什么必须是函数" class="headerlink" title="20.Vue 组件中 data 为什么必须是函数"></a>20.Vue 组件中 data 为什么必须是函数</h3><p>vue组件中data值不能为对象，<strong>因为对象是引用类型，组件可能会被多个实例同时引用</strong>。<br>如果data值为对象，将导致多个实例共享一个对象，其中一个组件改变data属性值，其它实例也会受到影响。</p>
<h3 id="21-vue中子组件调用父组件的方法"><a href="#21-vue中子组件调用父组件的方法" class="headerlink" title="21.vue中子组件调用父组件的方法"></a>21.vue中子组件调用父组件的方法</h3><p>第一种方法是直接在子组件中通过this.$parent.event来调用父组件的方法<br>第二种方法是在子组件里用$emit向父组件触发一个事件，父组件监听这个事件就行了。<br>第三种都可以实现子组件调用父组件的方法，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click=<span class="string">"childMethod()"</span>&gt;点击&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  export default &#123;</span></span><br><span class="line"><span class="regexp">    props: &#123;</span></span><br><span class="line"><span class="regexp">      fatherMethod: &#123;</span></span><br><span class="line"><span class="regexp">        type: Function,</span></span><br><span class="line"><span class="regexp">        default: null</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    methods: &#123;</span></span><br><span class="line"><span class="regexp">      childMethod() &#123;</span></span><br><span class="line"><span class="regexp">        if (this.fatherMethod) &#123;</span></span><br><span class="line"><span class="regexp">          this.fatherMethod();</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="22-vue中-keep-alive-组件的作用"><a href="#22-vue中-keep-alive-组件的作用" class="headerlink" title="22.vue中 keep-alive 组件的作用"></a>22.vue中 keep-alive 组件的作用</h3><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;component&gt;</span><br><span class="line">    &lt;!-- 该组件将被缓存！ --&gt;</span><br><span class="line">  &lt;<span class="regexp">/component&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>keep-alive&gt;</span><br><span class="line">如果只想 router-view 里面某个组件被缓存</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/'</span>,</span><br><span class="line">    name: <span class="string">'home'</span>,</span><br><span class="line">    component: Home,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      keepAlive: <span class="literal">true</span> <span class="comment">// 需要被缓存</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    path: <span class="string">'/:id'</span>,</span><br><span class="line">    name: <span class="string">'edit'</span>,</span><br><span class="line">    component: Edit,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      keepAlive: <span class="literal">false</span> <span class="comment">// 不需要被缓存</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">    &lt;router-view v-<span class="keyword">if</span>=<span class="string">"$route.meta.keepAlive"</span>&gt;</span><br><span class="line">        &lt;!-- 这里是会被缓存的视图组件，比如 Home！ --&gt;</span><br><span class="line">    &lt;<span class="regexp">/router-view&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>keep-alive&gt;</span><br><span class="line"> </span><br><span class="line">&lt;router-view v-<span class="keyword">if</span>=<span class="string">"!$route.meta.keepAlive"</span>&gt;</span><br><span class="line">    &lt;!-- 这里是不被缓存的视图组件，比如 Edit！ --&gt;</span><br><span class="line">&lt;<span class="regexp">/router-view&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="23-vue中如何编写可复用的组件？"><a href="#23-vue中如何编写可复用的组件？" class="headerlink" title="23.vue中如何编写可复用的组件？"></a>23.vue中如何编写可复用的组件？</h3><p><a href="https://blog.csdn.net/qq_38563845/article/details/77524934" target="_blank" rel="noopener">https://blog.csdn.net/qq_38563845/article/details/77524934</a></p>
<p>①创建组件页面eg Toast.vue；<br>②用Vue.extend()扩展一个组件构造器,再通过实例化组件构造器,就可创造出可复用的组件<br>③将toast组件挂载到新创建的div上；<br>④把toast组件的dom添加到body里；<br>⑤修改优化达到动态控制页面显示文字跟显示时间；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>; </span><br><span class="line"><span class="keyword">import</span> Toast <span class="keyword">from</span> <span class="string">'@/components/Toast'</span>;     <span class="comment">//引入组件</span></span><br><span class="line"><span class="keyword">let</span> ToastConstructor  = Vue.extend(Toast) <span class="comment">// 返回一个“扩展实例构造器”</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> myToast = <span class="function">(<span class="params">text,duration</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> toastDom = <span class="keyword">new</span> ToastConstructor(&#123;</span><br><span class="line">        el:<span class="built_in">document</span>.createElement(<span class="string">'div'</span>)    <span class="comment">//将toast组件挂载到新创建的div上</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild( toastDom.$el )   <span class="comment">//把toast组件的dom添加到body里</span></span><br><span class="line">    </span><br><span class="line">    toastDom.text = text;</span><br><span class="line">    toastDom.duration = duration;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 在指定 duration 之后让 toast消失</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        toastDom.isShow = <span class="literal">false</span>;  </span><br><span class="line">    &#125;, toastDom.duration);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> myToast;</span><br></pre></td></tr></table></figure>

<h3 id="24-什么是vue生命周期和生命周期钩子函数？"><a href="#24-什么是vue生命周期和生命周期钩子函数？" class="headerlink" title="24.什么是vue生命周期和生命周期钩子函数？"></a>24.什么是vue生命周期和生命周期钩子函数？</h3><p><strong>beforecreated</strong>：在实例初始化之后，el 和 data 并未初始化（这个时期，this变量还不能使用，在data下的数据，和methods下的方法，watcher中的事件都不能获得到；）<br><strong>created</strong>:完成了 data 数据的初始化，el没有（这个时候可以操作vue实例中的数据和各种方法，但是还不能对”dom”节点进行操作；）<br><strong>beforeMount</strong>：完成了 el 和 data 初始化 //这里的el是虚拟的dom；<br><strong>mounted</strong> ：完成挂载，在这发起后端请求，拿回数据，配合路由钩子做一些事情（挂载完毕，这时dom节点被渲染到文档内，一些需要dom的操作在此时才能正常进行）<br><strong>beforeUpdate</strong>：是指view层数据变化前，不是data中的数据改变前触发；<br><strong>update</strong>：是指view层的数据变化之后，<br><strong>beforeDestory</strong>： 你确认删除XX吗？<br><strong>destoryed</strong> ：当前组件已被删除，清空相关内容<br><strong>A、什么是vue生命周期？</strong><br>Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。<br><strong>B、vue生命周期的作用是什么？</strong><br>它的生命周期有多个事件钩子,让我们在控制整个Vue实例的过程时更容易形成好的逻辑。<br><strong>C、vue生命周期总共有几个阶段？</strong><br>它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后<br><strong>D、第一次页面加载会触发哪几个钩子？</strong><br>第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子<br><strong>E、DOM 渲染在 哪个周期中就已经完成？</strong><br>DOM 渲染在 mounted 中就已经完成了。<br><strong>F、简单描述每个周期具体适合哪些场景？</strong><br>生命周期钩子的一些使用方法： beforecreate : 可以在这加个loading事件，在加载实例时触发 created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用 mounted : 挂载元素，获取到DOM节点 updated : 如果对数据统一处理，在这里写上相应函数 beforeDestroy : 可以做一个确认停止事件的确认框 nextTick : 更新数据后立即操作dom;</p>
<h3 id="26-webpack的作用"><a href="#26-webpack的作用" class="headerlink" title="26.webpack的作用"></a>26.webpack的作用</h3><p>①、依赖管理：方便引用第三方模块、让模块更容易复用，避免全局注入导致的冲突、避免重复加载或者加载不需要的模块。会一层一层的读取依赖的模块，添加不同的入口；同时，不会重复打包依赖的模块。<br>②、合并代码：把各个分散的模块集中打包成大文件，减少HTTP的请求链接数，配合UglifyJS（压缩代码）可以减少、优化代码的体积。<br>③、各路插件：统一处理引入的插件，babel编译ES6文件，TypeScript,eslint 可以检查编译期的错误。<br><strong>一句话总结：</strong>webpack 的作用就是处理依赖，模块化，打包压缩文件，管理插件。<br>一切皆为模块，由于webpack只支持js文件，所以需要用loader 转换为webpack支持的模块，其中plugin 用于扩张webpack 的功能，在webpack构建生命周期的过程中，在合适的时机做了合适的事情。</p>
<h3 id="webpack怎么工作的过程"><a href="#webpack怎么工作的过程" class="headerlink" title="webpack怎么工作的过程"></a>webpack怎么工作的过程</h3><p>①解析配置参数，合并从shell(npm install 类似的命令)和webpack.config.js文件的配置信息，输出最终的配置信息；<br>②注册配置中的插件,让插件监听webpack构建生命周期中的事件节点，做出对应的反应；<br>③解析配置文件中的entry入口文件，并找出每个文件依赖的文件，递归下去；<br>④在递归每个文件的过程中，根据文件类型和配置文件中的loader找出对应的loader对文件进行转换；<br>⑤递归结束后得到每个文件最终的结果，根据entry 配置生成代码chunk(打包之后的名字)；<br>⑥输出所以chunk 到文件系统。</p>
<h3 id="27-vue等单页面应用及其优缺点"><a href="#27-vue等单页面应用及其优缺点" class="headerlink" title="27.vue等单页面应用及其优缺点"></a>27.vue等单页面应用及其优缺点</h3><p><strong>缺点：</strong></p>
<blockquote>
<p>不支持低版本的浏览器，最低只支持到IE9；<br>不利于SEO的优化（如果要支持SEO，建议通过服务端来进行渲染组件）；<br>第一次加载首页耗时相对长一些；<br>不可以使用浏览器的导航按钮需要自行实现前进、后退。</p>
</blockquote>
<p><strong>优点：</strong></p>
<blockquote>
<p>无刷新体验,提升了用户体验；<br>前端开发不再以页面为单位，更多地采用组件化的思想，代码结构和组织方式更加规范化，便于修改和调整；<br>API 共享，同一套后端程序代码不用修改就可以用于Web界面、手机、平板等多种客户端<br>用户体验好、快，内容的改变不需要重新加载整个页面。</p>
</blockquote>
<h3 id="28-什么是vue的计算属性computed"><a href="#28-什么是vue的计算属性computed" class="headerlink" title="28.什么是vue的计算属性computed"></a>28.什么是vue的计算属性computed</h3><p>计算属性是需要复杂的逻辑，可以用方法method代替</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">    totalPrice()&#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">this</span>.good.price*<span class="keyword">this</span>.good.count)*<span class="keyword">this</span>.discount+<span class="keyword">this</span>.deliver;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="29-vue-cli提供的几种脚手架模板"><a href="#29-vue-cli提供的几种脚手架模板" class="headerlink" title="29.vue-cli提供的几种脚手架模板"></a>29.vue-cli提供的几种脚手架模板</h3><blockquote>
<p>vue-cli 的脚手架项目模板有browserify 和 webpack；</p>
</blockquote>
<h3 id="30-组件中传递数据？"><a href="#30-组件中传递数据？" class="headerlink" title="30.组件中传递数据？"></a>30.组件中传递数据？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">props：<span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">props: &#123;</span><br><span class="line">	message: <span class="built_in">String</span> <span class="comment">//定义传值的类型&lt;br&gt;</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者props:["message"]</span></span><br><span class="line">data: &#123;&#125;</span><br><span class="line">父组件调用子组件的方法：父组件   <span class="keyword">this</span>.$refs.yeluosen.childMethod()</span><br><span class="line">子组件向父组件传值并调用方法 $emit</span><br><span class="line">组件之间：bus==$emit+$on</span><br></pre></td></tr></table></figure>

<h3 id="32-vue-router-的导航钩子-主要用来作用是拦截导航-让他完成跳转或取消。"><a href="#32-vue-router-的导航钩子-主要用来作用是拦截导航-让他完成跳转或取消。" class="headerlink" title="32.vue-router 的导航钩子,主要用来作用是拦截导航,让他完成跳转或取消。"></a>32.vue-router 的导航钩子,主要用来作用是拦截导航,让他完成跳转或取消。</h3><blockquote>
<p><strong>全局的:</strong>前置守卫、后置钩子（beforeEach，afterEach）beforeResolve<br><strong>单个路由独享的:</strong>beforeEnter<br><strong>组件级的:</strong> beforeRouteEnter（不能获取组件实例 this）、beforeRouteUpdate、beforeRouteLeave<br>这是因为在执行路由钩子函数beforRouteEnter时候，组件还没有被创建出来；<br>先执行beforRouteEnter，再执行组件周期钩子函数beforeCreate，可以通过 next 获取组件的实例对象，如：next( (vm)=&gt;{} )，参数vm就是组件的实例化对象。</p>
</blockquote>
<h3 id="33-完整的-vue-router-导航解析流程"><a href="#33-完整的-vue-router-导航解析流程" class="headerlink" title="33.完整的 vue-router 导航解析流程"></a>33.完整的 vue-router 导航解析流程</h3><blockquote>
<p>1.导航被触发；<br>2.在失活的组件里调用beforeRouteLeave守卫；<br>3.调用全局beforeEach守卫；<br>4.在复用组件里调用beforeRouteUpdate守卫；<br>5.调用路由配置里的beforeEnter守卫；<br>6.解析异步路由组件；<br>7.在被激活的组件里调用beforeRouteEnter守卫；<br>8.调用全局beforeResolve守卫；<br>9.导航被确认；<br>10..调用全局的afterEach钩子；<br>11.DOM更新；<br>12.用创建好的实例调用beforeRouteEnter守卫中传给next的回调函数。</p>
</blockquote>
<h3 id="34-vue-router如何响应-路由参数-的变化？"><a href="#34-vue-router如何响应-路由参数-的变化？" class="headerlink" title="34.vue-router如何响应 路由参数 的变化？"></a>34.vue-router如何响应 路由参数 的变化？</h3><p><strong>原来的组件实例会被复用。这也意味着组件的生命周期钩子不会再被调用。你可以简单地 watch (监测变化) $route 对象：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">'...'</span>,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="string">'$route'</span> (to, <span class="keyword">from</span>) &#123;</span><br><span class="line">      <span class="comment">// 对路由变化作出响应...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">'...'</span>,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="string">'$route'</span> (to, <span class="keyword">from</span>) &#123;</span><br><span class="line">      <span class="comment">// 对路由变化作出响应...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="35-vue-router的几种实例方法以及参数传递"><a href="#35-vue-router的几种实例方法以及参数传递" class="headerlink" title="35.vue-router的几种实例方法以及参数传递"></a>35.vue-router的几种实例方法以及参数传递</h3><blockquote>
<p>name传递<br>to来传递<br>采用url传参</p>
</blockquote>
<h3 id="36-is的用法（用于动态组件且基于-DOM-内模板的限制来工作。）"><a href="#36-is的用法（用于动态组件且基于-DOM-内模板的限制来工作。）" class="headerlink" title="36.is的用法（用于动态组件且基于 DOM 内模板的限制来工作。）"></a>36.is的用法（用于动态组件且基于 DOM 内模板的限制来工作。）</h3><p>is用来动态切换组件，DOM模板解析</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt; <span class="xml"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">is</span>=<span class="string">"my-row"</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a><a href="https://v2.cn.vuejs.org/v2/guide/components.html#动态组件" target="_blank" rel="noopener">动态组件</a></h3><p>有的时候，在不同组件之间进行动态切换是非常有用的，比如在一个多标签的界面里： </p>
<p>上述内容可以通过 Vue 的 <code>&lt;component&gt;</code> 元素加一个特殊的 <code>is</code> attribute 来实现： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 组件会在 `currentTabComponent` 改变时改变 --&gt;</span><br><span class="line">&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>currentTabComponent</code> 可以包括</p>
<ul>
<li><p>已注册组件的名字，或</p>
</li>
<li><p>一个组件的选项对象</p>
<p>请留意，这个 attribute 可以用于常规 HTML 元素，但这些元素将被视为组件，这意味着所有的 attribute <strong>都会作为 DOM attribute 被绑定</strong>。对于像 <code>value</code> 这样的 property，若想让其如预期般工作，你需要使用 <a href="https://v2.cn.vuejs.org/v2/api/#v-bind" target="_blank" rel="noopener"><code>.prop</code> 修饰器</a>。 </p>
</li>
</ul>
<h3 id="37-vuex是什么？怎么使用？哪种功能场景使用它？"><a href="#37-vuex是什么？怎么使用？哪种功能场景使用它？" class="headerlink" title="37.vuex是什么？怎么使用？哪种功能场景使用它？"></a>37.vuex是什么？怎么使用？哪种功能场景使用它？</h3><blockquote>
<p>是什么：vue框架中状态管理:有五种，分别是 State、 Getter、Mutation 、Action、 Module<br>使用：新建一个目录store，<br>场景：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">vuex的State特性</span><br><span class="line">A、Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于一般Vue对象里面的data</span><br><span class="line">B、state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新</span><br><span class="line">C、它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中</span><br><span class="line"></span><br><span class="line">vuex的Getter特性</span><br><span class="line">A、getters 可以对State进行计算操作，它就是Store的计算属性</span><br><span class="line">B、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用</span><br><span class="line">C、 如果一个状态只在一个组件内使用，是可以不用getters</span><br><span class="line"></span><br><span class="line">vuex的Mutation特性</span><br><span class="line">改变store中state状态的唯一方法就是提交mutation，就很类似事件。</span><br><span class="line">每个mutation都有一个字符串类型的事件类型和一个回调函数，我们需要改变state的值就要在回调函数中改变。</span><br><span class="line">我们要执行这个回调函数，那么我们需要执行一个相应的调用方法：store.commit。</span><br><span class="line"></span><br><span class="line">Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态；</span><br><span class="line">Action 可以包含任意异步操作，Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，</span><br><span class="line">因此你可以调用 context.commit 提交一个 mutation，</span><br><span class="line">或者通过 context.state 和 context.getters 来获取 state 和 getters。</span><br><span class="line">Action 通过 store.dispatch 方法触发：eg。</span><br><span class="line">store.dispatch(<span class="string">'increment'</span>)</span><br><span class="line"></span><br><span class="line">vuex的<span class="built_in">module</span>特性</span><br><span class="line">Module其实只是解决了当state中很复杂臃肿的时候，<span class="built_in">module</span>可以将store分割成模块，</span><br><span class="line">每个模块中拥有自己的state、mutation、action和getter</span><br></pre></td></tr></table></figure>

<h3 id="说说你对-SPA-单页面的理解，它的优缺点分别是什么？"><a href="#说说你对-SPA-单页面的理解，它的优缺点分别是什么？" class="headerlink" title="说说你对 SPA 单页面的理解，它的优缺点分别是什么？"></a>说说你对 SPA 单页面的理解，它的优缺点分别是什么？</h3><p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p>
<p>优点：</p>
<ul>
<li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li>
<li>基于上面一点，SPA 相对对服务器压力小；</li>
<li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li>
</ul>
<p>缺点：</p>
<ul>
<li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li>
<li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li>
<li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li>
</ul>
<h3 id="v-show-与-v-if-有什么区别？"><a href="#v-show-与-v-if-有什么区别？" class="headerlink" title="v-show 与 v-if 有什么区别？"></a>v-show 与 v-if 有什么区别？</h3><p>v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>
<p>v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。</p>
<p>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p>
<h3 id="Class-与-Style-如何动态绑定？"><a href="#Class-与-Style-如何动态绑定？" class="headerlink" title="Class 与 Style 如何动态绑定？"></a>Class 与 Style 如何动态绑定？</h3><p>Class 可以通过对象语法和数组语法进行动态绑定：</p>
<ul>
<li>对象语法：</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"&#123; active: isActive, 'text-danger': hasError &#125;"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>数组语法：</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"[isActive ? activeClass : '', errorClass]"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>Style 也可以通过对象语法和数组语法进行动态绑定：</p>
<ul>
<li>对象语法：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>数组语法：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"[styleColor, styleSize]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="怎样理解-Vue-的单向数据流？"><a href="#怎样理解-Vue-的单向数据流？" class="headerlink" title="怎样理解 Vue 的单向数据流？"></a>怎样理解 Vue 的单向数据流？</h3><p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。</p>
<p>这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p>
<p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。</p>
<p>子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p>
<p>有两种常见的试图改变一个 prop 的情形 :</p>
<ul>
<li>这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。 在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">'initialCounter'</span>],</span><br></pre></td></tr></table></figure>

<ul>
<li>这个 prop 以一种原始的值传入且需要进行转换。 在这种情况下，最好使用这个 prop 的值来定义一个计算属性</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">'size'</span>],</span><br></pre></td></tr></table></figure>

<h3 id="computed-和-watch-的区别和运用的场景？"><a href="#computed-和-watch-的区别和运用的场景？" class="headerlink" title="computed 和 watch 的区别和运用的场景？"></a>computed 和 watch 的区别和运用的场景？</h3><p>computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；</p>
<p>watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p>
<p>运用场景：</p>
<ul>
<li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</li>
<li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li>
</ul>
<h3 id="直接给一个数组项赋值，Vue-能检测到变化吗？"><a href="#直接给一个数组项赋值，Vue-能检测到变化吗？" class="headerlink" title="直接给一个数组项赋值，Vue 能检测到变化吗？"></a>直接给一个数组项赋值，Vue 能检测到变化吗？</h3><p>由于 JavaScript 的限制，Vue 不能检测到以下数组的变动：</p>
<ul>
<li>当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue</li>
<li>当你修改数组的长度时，例如：vm.items.length = newLength</li>
</ul>
<p>为了解决第一个问题，Vue 提供了以下操作方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue.set</span></span><br></pre></td></tr></table></figure>

<p>为了解决第二个问题，Vue 提供了以下操作方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array.prototype.splice</span></span><br></pre></td></tr></table></figure>

<h3 id="谈谈你对-Vue-生命周期的理解？"><a href="#谈谈你对-Vue-生命周期的理解？" class="headerlink" title="谈谈你对 Vue 生命周期的理解？"></a>谈谈你对 Vue 生命周期的理解？</h3><h4 id="（1）生命周期是什么？"><a href="#（1）生命周期是什么？" class="headerlink" title="（1）生命周期是什么？"></a>（1）生命周期是什么？</h4><p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p>
<h4 id="（2）各个生命周期的作用"><a href="#（2）各个生命周期的作用" class="headerlink" title="（2）各个生命周期的作用"></a>（2）各个生命周期的作用</h4><table>
<thead>
<tr>
<th>生命周期</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>beforeCreate</td>
<td>组件实例被创建之初，组件的属性生效之前</td>
</tr>
<tr>
<td>created</td>
<td>组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用</td>
</tr>
<tr>
<td>beforeMount</td>
<td>在挂载开始之前被调用：相关的 render 函数首次被调用</td>
</tr>
<tr>
<td>mounted</td>
<td>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td>组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td>
</tr>
<tr>
<td>update</td>
<td>组件数据更新之后</td>
</tr>
<tr>
<td>activited</td>
<td>keep-alive 专属，组件被激活时调用</td>
</tr>
<tr>
<td>deactivated</td>
<td>keep-alive 专属，组件被销毁时调用</td>
</tr>
<tr>
<td>beforeDestory</td>
<td>组件销毁前调用</td>
</tr>
<tr>
<td>destoryed</td>
<td>组件销毁后调用</td>
</tr>
</tbody></table>
<h4 id="（3）生命周期示意图"><a href="#（3）生命周期示意图" class="headerlink" title="（3）生命周期示意图"></a>（3）生命周期示意图</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https:////upload-images.jianshu.io/upload_images/12842279-43f8b23ff3bd3a30?imageMogr2/auto-orient/strip|imageView2/2/w/640/format/webp" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>



<h3 id="Vue-的父组件和子组件生命周期钩子函数执行顺序？"><a href="#Vue-的父组件和子组件生命周期钩子函数执行顺序？" class="headerlink" title="Vue 的父组件和子组件生命周期钩子函数执行顺序？"></a>Vue 的父组件和子组件生命周期钩子函数执行顺序？</h3><p>Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</p>
<ul>
<li><p>加载渲染过程</p>
<p>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p>
</li>
<li><p>子组件更新过程</p>
<p>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p>
</li>
<li><p>父组件更新过程</p>
<p>父 beforeUpdate -&gt; 父 updated</p>
</li>
<li><p>销毁过程</p>
<p>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p>
</li>
</ul>
<h3 id="在哪个生命周期内调用异步请求？"><a href="#在哪个生命周期内调用异步请求？" class="headerlink" title="在哪个生命周期内调用异步请求？"></a>在哪个生命周期内调用异步请求？</h3><p>可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p>
<ul>
<li>能更快获取到服务端数据，减少页面 loading 时间；</li>
<li>ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</li>
</ul>
<h3 id="在什么阶段才能访问操作DOM？"><a href="#在什么阶段才能访问操作DOM？" class="headerlink" title="在什么阶段才能访问操作DOM？"></a>在什么阶段才能访问操作DOM？</h3><p>在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 DOM。vue 具体的生命周期示意图可以参见如下，理解了整个生命周期各个阶段的操作，关于生命周期相关的面试题就难不倒你了。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https:////upload-images.jianshu.io/upload_images/12842279-f01c5f655dd3628a?imageMogr2/auto-orient/strip|imageView2/2/w/640/format/webp" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<h3 id="父组件可以监听到子组件的生命周期吗？"><a href="#父组件可以监听到子组件的生命周期吗？" class="headerlink" title="父组件可以监听到子组件的生命周期吗？"></a>父组件可以监听到子组件的生命周期吗？</h3><p>比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parent.vue</span></span><br></pre></td></tr></table></figure>

<p>以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Parent.vue</span></span><br></pre></td></tr></table></figure>

<p>当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。</p>
<h3 id="谈谈你对-keep-alive-的了解？"><a href="#谈谈你对-keep-alive-的了解？" class="headerlink" title="谈谈你对 keep-alive 的了解？"></a>谈谈你对 keep-alive 的了解？</h3><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p>
<ul>
<li>一般结合路由和动态组件一起使用，用于缓存组件；</li>
<li>提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；</li>
<li>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</li>
</ul>
<h3 id="组件中-data-为什么是一个函数？"><a href="#组件中-data-为什么是一个函数？" class="headerlink" title="组件中 data 为什么是一个函数？"></a>组件中 data 为什么是一个函数？</h3><p>为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// data</span></span><br></pre></td></tr></table></figure>

<p>因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。</p>
<h3 id="v-model-的原理？"><a href="#v-model-的原理？" class="headerlink" title="v-model 的原理？"></a>v-model 的原理？</h3><p>我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p>
<ul>
<li>text 和 textarea 元素使用 value 属性和 input 事件；</li>
<li>checkbox 和 radio 使用 checked 属性和 change 事件；</li>
<li>select 字段将 value 作为 prop 并将 change 作为事件。</li>
</ul>
<p>以 input 表单元素为例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">'something'</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父组件：</span><br></pre></td></tr></table></figure>

<h3 id="Vue-组件间通信有哪几种方式？"><a href="#Vue-组件间通信有哪几种方式？" class="headerlink" title="Vue 组件间通信有哪几种方式？"></a>Vue 组件间通信有哪几种方式？</h3><p>Vue 组件间通信是面试常考的知识点之一，这题有点类似于开放题，你回答出越多方法当然越加分，表明你对 Vue 掌握的越熟练。Vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。</p>
<p><strong>（1）props / $emit 适用 父子组件通信</strong></p>
<p>这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。</p>
<p><strong>（2）ref 与 <figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://math.jianshu.com/math?formula=parent%20%2F" alt="parent /" title>
                </div>
                <div class="image-caption">parent /</div>
            </figure>children 适用 父子组件通信</strong></p>
<ul>
<li>ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</li>
<li><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://math.jianshu.com/math?formula=parent%20%2F" alt="parent /" title>
                </div>
                <div class="image-caption">parent /</div>
            </figure>children：访问父 / 子实例

</li>
</ul>
<p><strong>（3）EventBus （<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://math.jianshu.com/math?formula=emit%20%2F" alt="emit /" title>
                </div>
                <div class="image-caption">emit /</div>
            </figure>on） 适用于 父子、隔代、兄弟组件通信</strong></p>
<p>这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。</p>
<p><strong>（4）<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://math.jianshu.com/math?formula=attrs%2F" alt="attrs/" title>
                </div>
                <div class="image-caption">attrs/</div>
            </figure>listeners 适用于 隔代组件通信</strong></p>
<ul>
<li><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://math.jianshu.com/math?formula=attrs%EF%BC%9A%E5%8C%85%E5%90%AB%E4%BA%86%E7%88%B6%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E4%B8%8D%E8%A2%AB%20prop%20%E6%89%80%E8%AF%86%E5%88%AB%20(%E4%B8%94%E8%8E%B7%E5%8F%96)%20%E7%9A%84%E7%89%B9%E6%80%A7%E7%BB%91%E5%AE%9A%20(%20class%20%E5%92%8C%20style%20%E9%99%A4%E5%A4%96%20)%E3%80%82%E5%BD%93%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6%E6%B2%A1%E6%9C%89%E5%A3%B0%E6%98%8E%E4%BB%BB%E4%BD%95%20prop%20%E6%97%B6%EF%BC%8C%E8%BF%99%E9%87%8C%E4%BC%9A%E5%8C%85%E5%90%AB%E6%89%80%E6%9C%89%E7%88%B6%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E7%BB%91%E5%AE%9A%20(%20class%20%E5%92%8C%20style%20%E9%99%A4%E5%A4%96%20)%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%20v-bind%3D%22" alt="attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind=" " title>
                </div>
                <div class="image-caption">attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind="</div>
            </figure>attrs" 传入内部组件。通常配合 inheritAttrs 选项一起使用。</li>
<li><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://math.jianshu.com/math?formula=listeners%EF%BC%9A%E5%8C%85%E5%90%AB%E4%BA%86%E7%88%B6%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E7%9A%84%20(%E4%B8%8D%E5%90%AB%20.native%20%E4%BF%AE%E9%A5%B0%E5%99%A8%E7%9A%84)%20v-on%20%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8%E3%80%82%E5%AE%83%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%20v-on%3D%22" alt="listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=" " title>
                </div>
                <div class="image-caption">listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on="</div>
            </figure>listeners" 传入内部组件

</li>
</ul>
<p><strong>（5）provide / inject 适用于 隔代组件通信</strong></p>
<p>祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。</p>
<p><strong>（6）Vuex 适用于 父子、隔代、兄弟组件通信</strong></p>
<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p>
<ul>
<li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>
<li>改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</li>
</ul>
<h4 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h4><h5 id="props"><a href="#props" class="headerlink" title="props"></a>props</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//child</span><br><span class="line">props: &#123;</span><br><span class="line">  msg: String;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// parent</span><br><span class="line">&lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot; /&gt;;</span><br></pre></td></tr></table></figure>

<h5 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// parent</span><br><span class="line">&lt;HelloWorld ref=&quot;hw&quot; /&gt;</span><br><span class="line"></span><br><span class="line">this.$refs.hw.xx</span><br></pre></td></tr></table></figure>

<h4 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// child</span><br><span class="line">this.$emit(&apos;add&apos;, good)</span><br><span class="line"></span><br><span class="line">// parent</span><br><span class="line">&lt;div @add=&quot;cartAdd($event)&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="sync-传参绑定"><a href="#sync-传参绑定" class="headerlink" title=".sync 传参绑定"></a>.sync 传参绑定</h4><p>.sync 其实也是事件传参的语法糖，父组件 以这样的形式@update:msg=”changeEmit” 子组件 this.$emit(‘update:msg’,this.msg)进行触发 而sync是可以进行简写的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">        &#123;&#123;msg&#125;&#125;</span><br><span class="line">        &lt;son @update:msg=&quot;changeEmit&quot;&gt;&lt;/son&gt;</span><br><span class="line">        // 这下面是上面的语法糖，可以简写成这样</span><br><span class="line">        &lt;son :msg.sync=&quot;msg&quot;&gt;&lt;/son&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import son from &apos;./son.vue&apos;</span><br><span class="line">    export default &#123;</span><br><span class="line">        components:&#123;</span><br><span class="line">            son</span><br><span class="line">        &#125;,</span><br><span class="line">        data()&#123;</span><br><span class="line">            return&#123;</span><br><span class="line">                msg:&quot;我是父亲&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            changeEmit(value)&#123;</span><br><span class="line">                this.msg = value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">     &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data()&#123;</span><br><span class="line">             return&#123;</span><br><span class="line">                  msg:&quot;我是儿子emit&quot;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">         mounted() &#123;</span><br><span class="line">              this.$emit(&apos;update:msg&apos;,this.msg)</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="兄弟组件：通过共同祖辈组件"><a href="#兄弟组件：通过共同祖辈组件" class="headerlink" title="兄弟组件：通过共同祖辈组件"></a>兄弟组件：通过共同祖辈组件</h4><p>通过共同的祖辈组件搭桥，$parent或$root。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// brother1</span></span><br><span class="line"><span class="keyword">this</span>.$parent.$on(<span class="string">"foo"</span>, handle);</span><br><span class="line"><span class="comment">// brother2</span></span><br><span class="line"><span class="keyword">this</span>.$parent.$emit(<span class="string">"foo"</span>);</span><br></pre></td></tr></table></figure>

<h4 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h4><p>EventBus 又称为事件总线。在Vue中可以使用 EventBus 来作为沟通桥梁的概念， 就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件， 所以组件都可以上下平行地通知其他组件，但也就是太方便所以若使用不慎， 就会造成难以维护的灾难，因此才需要更完善的Vuex作为状态管理中心，将通知的概念上升到共享状态层次。</p>
<p>平常我们采用更多的是父传子，子传父，当遇到兄弟之间的组件通信的时候 就可以使用EventBus<br>如下例 Vue.prototype.$EventBus = new Vue() 这句话的意思是 因为Vue的原型上有$on $emit 方法 继承自vue原型上的方法，实现一个发布订阅模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">//这句话的意思是 因为Vue的原型上有$on $emit 方法 继承自vue原型上的方法，实现一个发布订阅模式</span><br><span class="line">Vue.prototype.$EventBus = new Vue()</span><br><span class="line">// 父组件-----------------</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">        &#123;&#123;msg&#125;&#125;</span><br><span class="line">        &lt;son&gt;&lt;/son&gt;</span><br><span class="line">        &lt;son1&gt;&lt;/son1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import son from &apos;./son.vue&apos;</span><br><span class="line">    import son1 from &apos;./son1.vue&apos;</span><br><span class="line">    export default &#123;</span><br><span class="line">        components:&#123;</span><br><span class="line">            son,</span><br><span class="line">            son1</span><br><span class="line">        &#125;,</span><br><span class="line">        data()&#123;</span><br><span class="line">            return&#123;</span><br><span class="line">                msg:&quot;我是父亲&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// 子组件son------------------------</span><br><span class="line">&lt;template&gt;</span><br><span class="line">     &lt;div&gt;</span><br><span class="line">          &lt;span&gt;&#123;&#123;sonValue&#125;&#125;&lt;/span&gt;</span><br><span class="line">     &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data()&#123;</span><br><span class="line">          return&#123;</span><br><span class="line">               sonValue:&quot;我是son1&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">         mounted() &#123;</span><br><span class="line">             this.$EventBus.$on(&apos;son1&apos;,(val)=&gt;&#123;</span><br><span class="line">                  this.sonValue = val</span><br><span class="line">             &#125;)</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// 子组件son1----------------</span><br><span class="line">&lt;template&gt;</span><br><span class="line">     &lt;div&gt;</span><br><span class="line">          &lt;span&gt;&#123;&#123;sonValue&#125;&#125;&lt;/span&gt;</span><br><span class="line">          &lt;button @click=&quot;btn&quot;&gt;在son1里面改变son的值&lt;/button&gt;</span><br><span class="line">     &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data()&#123;</span><br><span class="line">          return&#123;</span><br><span class="line">               sonValue:&quot;我是son2&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">         methods:&#123;</span><br><span class="line">             btn()&#123;</span><br><span class="line">                  this.$EventBus.$emit(&apos;son1&apos;,&apos;在son1里面改变son的值&apos;)</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">​``` --&gt;</span><br><span class="line"></span><br><span class="line">### 祖先和后代之间</span><br><span class="line"></span><br><span class="line">provide/inject：能够实现祖先给后代传值</span><br><span class="line"></span><br><span class="line">​```javascript</span><br><span class="line">// ancestor</span><br><span class="line">provide() &#123;    </span><br><span class="line">    return &#123;foo: &apos;foo&apos;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// descendant</span><br><span class="line">inject: [&apos;foo&apos;]</span><br></pre></td></tr></table></figure>

<h4 id="dispatch：后代给祖先传值"><a href="#dispatch：后代给祖先传值" class="headerlink" title="dispatch：后代给祖先传值"></a>dispatch：后代给祖先传值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个dispatch方法，指定要派发事件名称和数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">eventName, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> parent = <span class="keyword">this</span>.$parent;</span><br><span class="line">  <span class="comment">// 只要还存在父元素就继续往上查找</span></span><br><span class="line">  <span class="keyword">while</span> (parent) &#123;</span><br><span class="line">    <span class="comment">// 父元素用$emit触发</span></span><br><span class="line">    parent.$emit(eventName, data);</span><br><span class="line">    <span class="comment">// 递归查找父元素</span></span><br><span class="line">    parent = parent.$parent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用，HelloWorld.vue</span></span><br><span class="line">&lt;h1 @click=<span class="string">"dispatch('hello', 'hello,world')"</span>&gt;&#123;&#123; msg &#125;&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ App.vue</span></span><br><span class="line"><span class="regexp">this.$on('hello', this.sayHello)</span></span><br></pre></td></tr></table></figure>

<h4 id="任意两个组件之间：事件总线-或-vuex"><a href="#任意两个组件之间：事件总线-或-vuex" class="headerlink" title="任意两个组件之间：事件总线 或 vuex"></a>任意两个组件之间：事件总线 或 vuex</h4><p>事件总线：创建一个 Bus 类负责事件派发、监听和回调管理</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bus：事件派发、监听和回调管理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//   eventName1:[fn1,fn2],</span></span><br><span class="line">    <span class="comment">//   eventName2:[fn3,fn4],</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">this</span>.callbacks = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  $on(name, fn) &#123;</span><br><span class="line">    <span class="keyword">this</span>.callbacks[name] = <span class="keyword">this</span>.callbacks[name] || [];</span><br><span class="line">    <span class="keyword">this</span>.callbacks[name].push(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  $emit(name, args) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.callbacks[name]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.callbacks[name].forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb(args));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line">Vue.prototype.$bus = <span class="keyword">new</span> Bus()</span><br><span class="line"></span><br><span class="line"><span class="comment">// child1 </span></span><br><span class="line"><span class="keyword">this</span>.$bus.$on(<span class="string">'foo'</span>, handle) </span><br><span class="line"><span class="comment">// child2 </span></span><br><span class="line"><span class="keyword">this</span>.$bus.$emit(<span class="string">'foo'</span>)</span><br></pre></td></tr></table></figure>

<p>vuex：创建唯一的全局数据管理者 store，通过它管理数据并通知组件状态变更</p>
<h3 id="sync修饰符"><a href="#sync修饰符" class="headerlink" title=".sync修饰符"></a>.sync修饰符</h3><h4 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h4><p>可以实现子组件与父组件数据的双向绑定，简化代码</p>
<p>简单理解:子组件可以修改父组件传过来的props值</p>
<h4 id="2-场景"><a href="#2-场景" class="headerlink" title="2.场景"></a>2.场景</h4><p>封装弹框类的基础组件， visible属性true显示false隐藏</p>
<p>特点:prop属性名，可以自定义，非固定为value</p>
<h4 id="3-本质"><a href="#3-本质" class="headerlink" title="3.本质"></a>3.本质</h4><p>.sync修饰符就是:属性名和@update:属性名合写</p>
<p>.sync(有语义)</p>
<p>:属性.sync=’数据’ 相当于</p>
<p>：属性=“数据“ + @update：属性=”数据=$event”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;base-select :selectId=&quot;selectId&quot;@update:selectId=&quot;selectId = $event&quot; &gt;</span><br></pre></td></tr></table></figure>

<p>相当于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;base-select :selectId.sync=&quot;selectId&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>v-model中的value不具有语义，要使其有语义写成 <strong>：属性名=” 数据” @update:属性名=” 数据”</strong></p>
<p>来替换原来的 <strong>：属性名=”数据” @input=”数据”</strong></p>
<h4 id="4-案例一"><a href="#4-案例一" class="headerlink" title="4.案例一"></a>4.案例一</h4><p>App.vue</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;大标题&lt;/h1&gt;</span><br><span class="line">    &lt;!-- &lt;header-comp :projectId=&quot;selectId&quot; @changeId=&quot;selectId=$event&quot;&gt;&lt;/header-comp&gt; --&gt;</span><br><span class="line">&lt;header-comp :selectId=&quot;selectId&quot; @update:selectId=&quot;selectId=$event&quot;&gt;&lt;/header-comp&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">import HeaderComp from &apos;./components/HeaderComp.vue&apos;</span><br><span class="line"> </span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    HeaderComp</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      selectId: &apos;2&apos;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> </span><br><span class="line">&lt;style&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>HeaderComp.vue</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;fa&quot;&gt;</span><br><span class="line">    &lt;h2&gt;h2文章二级标题&lt;/h2&gt;</span><br><span class="line">&lt;select name=&quot;&quot; id=&quot;&quot; :value=&quot;selectId&quot;  @change=&quot;handleChange&quot;&gt;</span><br><span class="line">  &lt;option value=&quot;1&quot;&gt;html&lt;/option&gt;</span><br><span class="line">  &lt;option value=&quot;2&quot;&gt;css&lt;/option&gt;</span><br><span class="line">  &lt;option value=&quot;3&quot;&gt;js&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line"> </span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    selectId: String</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleChange (e) &#123;</span><br><span class="line">      console.log(e.target.value)</span><br><span class="line">      this.$emit(&apos;update:selectId&apos;, e.target.value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> </span><br><span class="line">&lt;style&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>用.sync修饰符简化，只需将App.vue中的子组件标签写成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;header-comp :selectId.sync=&quot;selectId&quot;&gt;&lt;/header-comp&gt;</span><br></pre></td></tr></table></figure>

<h4 id="5-案例二"><a href="#5-案例二" class="headerlink" title="5.案例二"></a>5.案例二</h4><p>father.vue</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line"> &lt;input type=&quot;text&quot; v-model=&quot;wrd&quot;&gt;</span><br><span class="line"> &lt;box :wrd.sync=&quot;wrd&quot;&gt;&lt;/box&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import box from &apos;./box&apos;</span><br><span class="line">export default &#123;</span><br><span class="line"> name: &apos;HelloWorld&apos;,</span><br><span class="line"> data() &#123;</span><br><span class="line"> return &#123;</span><br><span class="line">  wrd: &apos;&apos;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> methods: &#123;</span><br><span class="line"> boxIncremend(e) &#123;</span><br><span class="line">  this.wrd = e</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> components: &#123;</span><br><span class="line"> box</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>child.vue</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; v-model=&quot;str&quot;&gt;</span><br><span class="line"> &lt;h2&gt;&#123;&#123; word &#125;&#125;&lt;/h2&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line"> name: &apos;box&apos;,</span><br><span class="line"> props: &#123;</span><br><span class="line"> word: &apos;&apos;</span><br><span class="line"> &#125;,</span><br><span class="line"> watch: &#123;</span><br><span class="line"> str: function(newword) &#123;</span><br><span class="line">  //往父级发射incre事件</span><br><span class="line">  this.$emit(&apos;update:word&apos;, newword)</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>父组件中的子组件，少写了一个自定义事件属性，子组件中$emit直接出发父组件中数据的更新，清新明了。使用中需要注意的是，update和后面对应的数据名不能写错。 </p>
<h3 id="你使用过-Vuex-吗？"><a href="#你使用过-Vuex-吗？" class="headerlink" title="你使用过 Vuex 吗？"></a>你使用过 Vuex 吗？</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p>
<p>（1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p>
<p>（2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</p>
<p>主要包括以下几个模块：</p>
<ul>
<li>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li>
<li>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li>
<li>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。</li>
<li>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</li>
<li>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</li>
</ul>
<h3 id="使用过-Vue-SSR-吗？说说-SSR？"><a href="#使用过-Vue-SSR-吗？说说-SSR？" class="headerlink" title="使用过 Vue SSR 吗？说说 SSR？"></a>使用过 Vue SSR 吗？说说 SSR？</h3><blockquote>
<p>Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。</p>
<p>即：SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。</p>
</blockquote>
<h3 id="服务端渲染-SSR-的优缺点如下："><a href="#服务端渲染-SSR-的优缺点如下：" class="headerlink" title="服务端渲染 SSR 的优缺点如下："></a>服务端渲染 SSR 的优缺点如下：</h3><p>（1）服务端渲染的优点：</p>
<ul>
<li>更好的 SEO：因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</li>
<li>更快的内容到达时间（首屏加载更快）：SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；</li>
</ul>
<p>（2) 服务端渲染的缺点：</p>
<ul>
<li>更多的开发条件限制：例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</li>
<li>更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</li>
</ul>
<p>如果没有 SSR 开发经验的同学，可以参考本文作者的另一篇 SSR 的实践文章《Vue SSR 踩坑之旅》，里面 SSR 项目搭建以及附有项目源码。</p>
<h3 id="vue-router-路由模式有几种？"><a href="#vue-router-路由模式有几种？" class="headerlink" title="vue-router 路由模式有几种？"></a>vue-router 路由模式有几种？</h3><p>vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (mode) &#123;</span><br></pre></td></tr></table></figure>

<p>其中，3 种路由模式的说明如下：</p>
<ul>
<li>hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；</li>
<li>history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；</li>
<li>abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</li>
</ul>
<h3 id="能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？"><a href="#能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？" class="headerlink" title="能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？"></a>能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？</h3><h4 id="（1）hash-模式的实现原理"><a href="#（1）hash-模式的实现原理" class="headerlink" title="（1）hash 模式的实现原理"></a>（1）hash 模式的实现原理</h4><p>早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 ‘#search’：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.word.com<span class="comment">#search</span></span><br></pre></td></tr></table></figure>

<p>hash 路由模式的实现主要是基于下面几个特性：</p>
<ul>
<li>URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；</li>
<li>hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；</li>
<li>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；</li>
<li>我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。</li>
</ul>
<h4 id="（2）history-模式的实现原理"><a href="#（2）history-模式的实现原理" class="headerlink" title="（2）history 模式的实现原理"></a>（2）history 模式的实现原理</h4><p>HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.history.pushState(<span class="keyword">null</span>, <span class="keyword">null</span>, path);</span><br></pre></td></tr></table></figure>

<p>history 路由模式的实现主要基于存在下面几个特性：</p>
<ul>
<li>pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；</li>
<li>我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）；</li>
<li>history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。</li>
</ul>
<h3 id="什么是-MVVM？"><a href="#什么是-MVVM？" class="headerlink" title="什么是 MVVM？"></a>什么是 MVVM？</h3><p>Model–View–ViewModel （MVVM） 是一个软件架构设计模式，由微软 WPF 和 Silverlight 的架构师 Ken Cooper 和 Ted Peters 开发，是一种简化用户界面的事件驱动编程方式。由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于2005年在他的博客上发表</p>
<p>MVVM 源自于经典的 Model–View–Controller（MVC）模式 ，MVVM 的出现促进了前端开发与后端业务逻辑的分离，极大地提高了前端开发效率，MVVM 的核心是 ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。如下图所示：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https:////upload-images.jianshu.io/upload_images/12842279-5af933c42fa81a9e?imageMogr2/auto-orient/strip|imageView2/2/w/640/format/webp" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<h4 id="（1）View-层"><a href="#（1）View-层" class="headerlink" title="（1）View 层"></a>（1）View 层</h4><p>View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。</p>
<h4 id="（2）Model-层"><a href="#（2）Model-层" class="headerlink" title="（2）Model 层"></a>（2）Model 层</h4><p>Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。</p>
<h4 id="（3）ViewModel-层"><a href="#（3）ViewModel-层" class="headerlink" title="（3）ViewModel 层"></a>（3）ViewModel 层</h4><p>ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。</p>
<p>需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的，比如页面的这一块展示什么，而页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互），视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。</p>
<p>MVVM 框架实现了双向绑定，这样 ViewModel 的内容会实时展现在 View 层，前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新。</p>
<p>这样 View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。</p>
<p>我们以下通过一个 Vue 实例来说明 MVVM 的具体实现，有 Vue 开发经验的同学应该一目了然：</p>
<p>（1）View 层</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="keyword">id</span>=<span class="string">"app"</span>&gt;</span><br></pre></td></tr></table></figure>

<p>（2）ViewModel 层</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br></pre></td></tr></table></figure>

<p>（3） Model 层</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>

<h3 id="Vue-是如何实现数据双向绑定的？"><a href="#Vue-是如何实现数据双向绑定的？" class="headerlink" title="Vue 是如何实现数据双向绑定的？"></a>Vue 是如何实现数据双向绑定的？</h3><p>Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据，如下图所示：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https:////upload-images.jianshu.io/upload_images/12842279-965e38fb3e4c6774?imageMogr2/auto-orient/strip|imageView2/2/w/492/format/webp" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>即：</p>
<ul>
<li>输入框内容变化时，Data 中的数据同步变化。即 View =&gt; Data 的变化。</li>
<li>Data 中的数据变化时，文本节点的内容同步变化。即 Data =&gt; View 的变化。</li>
</ul>
<p>其中，View 变化更新 Data ，可以通过事件监听的方式来实现，所以 Vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View。</p>
<p>Vue 主要通过以下 4 个步骤来实现数据双向绑定的：</p>
<p>实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。</p>
<p>实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。</p>
<p>实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。</p>
<p>实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。</p>
<p>以上四个步骤的流程图表示如下，如果有同学理解不大清晰的，可以查看作者专门介绍数据双向绑定的文章《0 到 1 掌握：Vue 核心之数据双向绑定》，有进行详细的讲解、以及代码 demo 示例。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https:////upload-images.jianshu.io/upload_images/12842279-fd64627956b167e5?imageMogr2/auto-orient/strip|imageView2/2/w/640/format/webp" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>



<h3 id="Vue-框架怎么实现对象和数组的监听？"><a href="#Vue-框架怎么实现对象和数组的监听？" class="headerlink" title="Vue 框架怎么实现对象和数组的监听？"></a>Vue 框架怎么实现对象和数组的监听？</h3><p>如果被问到 Vue 怎么实现数据双向绑定，大家肯定都会回答 通过 Object.defineProperty() 对数据进行劫持，但是 Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持，同理无法对数组进行劫持，但是我们在使用 Vue 框架中都知道，Vue 能检测到对象和数组（部分方法的操作）的变化，那它是怎么实现的呢？我们查看相关代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br></pre></td></tr></table></figure>

<p>通过以上 Vue 源码部分查看，我们就能知道 Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。</p>
<h3 id="Proxy-与-Object-defineProperty-优劣对比"><a href="#Proxy-与-Object-defineProperty-优劣对比" class="headerlink" title="Proxy 与 Object.defineProperty 优劣对比"></a>Proxy 与 Object.defineProperty 优劣对比</h3><p>Proxy 的优势如下:</p>
<ul>
<li>Proxy 可以直接监听对象而非属性；</li>
<li>Proxy 可以直接监听数组的变化；</li>
<li>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；</li>
<li>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；</li>
<li>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；</li>
</ul>
<p>Object.defineProperty 的优势如下:</p>
<ul>
<li>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。</li>
</ul>
<h3 id="vue中this-set的用法"><a href="#vue中this-set的用法" class="headerlink" title="vue中this.$set的用法"></a>vue中this.$set的用法</h3><p>当你发现你给对象加了一个属性，在控制台能打印出来，但是却没有更新到视图上时，也许这个时候就需要用到this.$set（）这个方法了，简单来说this.$set的功能就是解决这个问题的啦。</p>
<p>官方解释：向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性 (比如 this.myObject.newProperty = ‘hi’)</p>
<p>调用方法：this.$set( target, key, value )</p>
<p>🌹 target：要更改的数据源(可以是对象或者数组)</p>
<p>🌹 key：要更改的具体数据</p>
<p>🌹 value ：重新赋的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 不能动态修改值</span><br><span class="line">item2.price = 0</span><br><span class="line">this.arr[2] = 0</span><br><span class="line">this.$set(item, &apos;price&apos;, 0)	// 对象给item设置新属性price，值为0，可以动态修改</span><br><span class="line">this.$set(this.arr, 2, 0) // 数组给第三个元素赋值为0</span><br></pre></td></tr></table></figure>

<h3 id="vue更新数组时触发视图更新的方法"><a href="#vue更新数组时触发视图更新的方法" class="headerlink" title="vue更新数组时触发视图更新的方法"></a>vue更新数组时触发视图更新的方法</h3><p>1.Vue.set 可以设置对象或数组的值，通过 key 或数组索引，可以触发视图更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数组修改</span><br><span class="line">Vue.set(array, indexOfItem, newValue)</span><br><span class="line">this.array.$set(indexOfItem, newValue)</span><br><span class="line"></span><br><span class="line">对象修改</span><br><span class="line">Vue.set(obj, keyOfItem, newValue)</span><br><span class="line">this.obj.$set(keyOfItem, newValue)</span><br></pre></td></tr></table></figure>

<p>2.Vue.delete 删除对象或数组中元素，通过 key 或数组索引，可以触发视图更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数组修改</span><br><span class="line">Vue.delete(array, indexOfItem)</span><br><span class="line">this.array.$delete(indexOfItem)</span><br><span class="line"></span><br><span class="line">对象修改</span><br><span class="line">Vue.delete(obj, keyOfItem)</span><br><span class="line">this.obj.$delete(keyOfItem)</span><br></pre></td></tr></table></figure>

<p>3.数组对象直接修改属性，可以触发视图更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.array[0].show = true;</span><br><span class="line">this.array.forEach(function(item)&#123;</span><br><span class="line">    item.show = true;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>4.splice 方法修改数组，可以触发视图更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.array.splice(indexOfItem, 1, newElement)</span><br></pre></td></tr></table></figure>

<p>5.数组整体修改，可以触发视图更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var tempArray = this.array;</span><br><span class="line">tempArray[0].show = true;</span><br><span class="line">this.array = tempArray;</span><br></pre></td></tr></table></figure>

<p>6.用 Object.assign 或 lodash.assign 可以为对象添加响应式属性，可以触发视图更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//Object.assign的单层的覆盖前面的属性，不会递归的合并属性</span><br><span class="line">this.obj = Object.assign(&#123;&#125;,this.obj,&#123;a:1, b:2&#125;)</span><br><span class="line"></span><br><span class="line">//assign与Object.assign一样</span><br><span class="line">this.obj = _.assign(&#123;&#125;,this.obj,&#123;a:1, b:2&#125;)</span><br><span class="line"></span><br><span class="line">//merge会递归的合并属性</span><br><span class="line">this.obj = _.merge(&#123;&#125;,this.obj,&#123;a:1, b:2&#125;)</span><br></pre></td></tr></table></figure>

<p>7.Vue 提供了如下的数组的变异方法，可以触发视图更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">push()</span><br><span class="line">pop()</span><br><span class="line">shift()</span><br><span class="line">unshift()</span><br><span class="line">splice()</span><br><span class="line">sort()</span><br><span class="line">reverse()</span><br></pre></td></tr></table></figure>

<h3 id="直接给一个数组项赋值，Vue-能检测到变化吗？-1"><a href="#直接给一个数组项赋值，Vue-能检测到变化吗？-1" class="headerlink" title="直接给一个数组项赋值，Vue 能检测到变化吗？"></a>直接给一个数组项赋值，Vue 能检测到变化吗？</h3><p>由于 JavaScript 的限制，Vue 不能检测到以下数组的变动：</p>
<ul>
<li>当你利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code></li>
<li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li>
</ul>
<p>为了解决第一个问题，Vue 提供了以下操作方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Vue.set</span><br><span class="line">Vue.set(vm.items, indexOfItem, newValue)</span><br><span class="line">// vm.$set，Vue.set的一个别名</span><br><span class="line">vm.$set(vm.items, indexOfItem, newValue)</span><br><span class="line">// Array.prototype.splice</span><br><span class="line">vm.items.splice(indexOfItem, 1, newValue)</span><br></pre></td></tr></table></figure>

<p>为了解决第二个问题，Vue 提供了以下操作方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Array.prototype.splice</span><br><span class="line">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure>

<h3 id="vue更新数组时触发视图更新的方法-1"><a href="#vue更新数组时触发视图更新的方法-1" class="headerlink" title="vue更新数组时触发视图更新的方法"></a>vue更新数组时触发视图更新的方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Vue.set    ==========Vue.set(target,key,value)这个方法主要是用于避开vue不能检测属性被添加的限制</span><br><span class="line">Vue.set(array, indexOfItem, newValue)<span class="comment">//indexOfItem指的索引</span></span><br><span class="line"><span class="keyword">this</span>.array.$<span class="keyword">set</span>(indexOfItem, newValue)</span><br><span class="line">Vue.<span class="keyword">set</span>(obj, keyOfItem, newValue)</span><br><span class="line">this.obj.$<span class="keyword">set</span>(keyOfItem, newValue)</span><br><span class="line">Vue.delete   这个方法主要用于避开vue不能检测到属性被删除；</span><br><span class="line"></span><br><span class="line">Vue.delete(array, indexOfItem)</span><br><span class="line">this.array.$delete(indexOfItem)</span><br><span class="line">Vue.delete(obj, keyOfItem)</span><br><span class="line">this.obj.$delete(keyOfItem)</span><br></pre></td></tr></table></figure>

<h3 id="vue的数据是响应式的，请问什么时候是非响应式的并如何解决"><a href="#vue的数据是响应式的，请问什么时候是非响应式的并如何解决" class="headerlink" title="vue的数据是响应式的，请问什么时候是非响应式的并如何解决"></a>vue的数据是响应式的，请问什么时候是非响应式的并如何解决</h3><h4 id="数组数据："><a href="#数组数据：" class="headerlink" title="数组数据："></a>数组数据：</h4><p>问题1：通过改变长度，利用索引直接设置跟项</p>
<p>解决：Vue.set(数组对象, key, value)            |         vm|this.$set(数组对象, key, value)</p>
<p>问题2：对数组使用了非变异 (non-mutating method) 方法（返回的了新数组）</p>
<p>解决：对象合并</p>
<h4 id="对象数据变化："><a href="#对象数据变化：" class="headerlink" title="对象数据变化："></a>对象数据变化：</h4><p>问题：问题：data:{a:1}；a 数据是响应式的；vm.b=’qq’; b 属性不是响应式的</p>
<p>解决：Vue.set(对象, key, value)              |              vm|this.$set(对象, key, value)</p>
<p>总结：数据一开始就应该出现在data里，数组里面永远不要放置简单性数据</p>
<h3 id="vm-set-obj-key-val-做了什么？"><a href="#vm-set-obj-key-val-做了什么？" class="headerlink" title="vm.$set(obj, key, val) 做了什么？"></a>vm.$set(obj, key, val) 做了什么？</h3><p>由于 Vue 无法探测对象新增属性或者通过索引为数组新增一个元素，所以这才有了 vm.set ， 它 是 Vue.set 的 别 名 。 vm.set，它是 Vue.set 的别名。 vm.set，它是Vue.set的别名。vm.set 用于向响应式对象添加一个新的 property，并确保这个新的 property 同样是响应式的，并触发视图更新。</p>
<p>为对象添加一个新的响应式数据：调用 defineReactive 方法为对象增加响应式数据，然后执行 dep.notify 进行依赖通知，更新视图<br>为数组添加一个新的响应式数据：通过 splice 方法实现</p>
<h3 id="Vue-怎么用-vm-set-解决对象新增属性不能响应的问题-？"><a href="#Vue-怎么用-vm-set-解决对象新增属性不能响应的问题-？" class="headerlink" title="Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？"></a>Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？</h3><p>受现代 JavaScript 的限制 ，Vue 无法检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。</p>
<p>但是 Vue 提供了<code>Vue.set (object, propertyName, value) / vm.$set (object, propertyName, value)</code> 来实现为对象添加响应式属性，那框架本身是如何实现的呢？</p>
<p>我们查看对应的 Vue 源码：<code>vue/src/core/instance/index.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">export function set (target: Array&lt;any&gt; | Object, key: any, val: any): any &#123;</span><br><span class="line">  // target 为数组  </span><br><span class="line">  if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    // 修改数组的长度, 避免索引&gt;数组长度导致splcie()执行有误</span><br><span class="line">    target.length = Math.max(target.length, key)</span><br><span class="line">    // 利用数组的splice变异方法触发响应式  </span><br><span class="line">    target.splice(key, 1, val)</span><br><span class="line">    return val</span><br><span class="line">  &#125;</span><br><span class="line">  // key 已经存在，直接修改属性值  </span><br><span class="line">  if (key in target &amp;&amp; !(key in Object.prototype)) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    return val</span><br><span class="line">  &#125;</span><br><span class="line">  const ob = (target: any).__ob__</span><br><span class="line">  // target 本身就不是响应式数据, 直接赋值</span><br><span class="line">  if (!ob) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    return val</span><br><span class="line">  &#125;</span><br><span class="line">  // 对属性进行响应式处理</span><br><span class="line">  defineReactive(ob.value, key, val)</span><br><span class="line">  ob.dep.notify()</span><br><span class="line">  return val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们阅读以上源码可知，vm.$set 的实现原理是：</p>
<ul>
<li>如果目标是数组，直接使用数组的 splice 方法触发相应式；</li>
<li>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用   defineReactive 方法进行响应式处理（ defineReactive 方法就是  Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）</li>
</ul>
<h3 id="虚拟-DOM-的优缺点？"><a href="#虚拟-DOM-的优缺点？" class="headerlink" title="虚拟 DOM 的优缺点？"></a>虚拟 DOM 的优缺点？</h3><p>优点：</p>
<ul>
<li>保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</li>
<li>无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</li>
<li>跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</li>
</ul>
<p>缺点:</p>
<ul>
<li>无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。</li>
</ul>
<h3 id="虚拟-DOM-实现原理？"><a href="#虚拟-DOM-实现原理？" class="headerlink" title="虚拟 DOM 实现原理？"></a>虚拟 DOM 实现原理？</h3><p>虚拟 DOM 的实现原理主要包括以下 3 部分：</p>
<ul>
<li>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；</li>
<li>diff 算法 — 比较两棵虚拟 DOM 树的差异；</li>
<li>pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</li>
</ul>
<p>如果对以上 3 个部分还不是很了解的同学，可以查看本文作者写的另一篇详解虚拟 DOM 的文章《深入剖析：Vue核心之虚拟DOM》</p>
<h3 id="你有对-Vue-项目进行哪些优化？"><a href="#你有对-Vue-项目进行哪些优化？" class="headerlink" title="你有对 Vue 项目进行哪些优化？"></a>你有对 Vue 项目进行哪些优化？</h3><p>如果没有对 Vue 项目没有进行过优化总结的同学，可以参考本文作者的另一篇文章《 Vue 项目性能优化 — 实践指南 》，文章主要介绍从 3 个大方面，22 个小方面详细讲解如何进行 Vue 项目的优化。</p>
<h4 id="（1）代码层面的优化"><a href="#（1）代码层面的优化" class="headerlink" title="（1）代码层面的优化"></a>（1）代码层面的优化</h4><ul>
<li>v-if 和 v-show 区分使用场景</li>
<li>computed 和 watch 区分使用场景</li>
<li>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li>
<li>长列表性能优化</li>
<li>事件的销毁</li>
<li>图片资源懒加载</li>
<li>路由懒加载</li>
<li>第三方插件的按需引入</li>
<li>优化无限列表性能</li>
<li>服务端渲染 SSR or 预渲染</li>
</ul>
<h4 id="（2）Webpack-层面的优化"><a href="#（2）Webpack-层面的优化" class="headerlink" title="（2）Webpack 层面的优化"></a>（2）Webpack 层面的优化</h4><ul>
<li>Webpack 对图片进行压缩</li>
<li>减少 ES6 转为 ES5 的冗余代码</li>
<li>提取公共代码</li>
<li>模板预编译</li>
<li>提取组件的 CSS</li>
<li>优化 SourceMap</li>
<li>构建结果输出分析</li>
<li>Vue 项目的编译优化</li>
</ul>
<h4 id="（3）基础的-Web-技术的优化"><a href="#（3）基础的-Web-技术的优化" class="headerlink" title="（3）基础的 Web 技术的优化"></a>（3）基础的 Web 技术的优化</h4><ul>
<li>开启 gzip 压缩</li>
<li>浏览器缓存</li>
<li>CDN 的使用</li>
<li>使用 Chrome Performance 查找性能瓶颈</li>
</ul>
<h3 id="vue路由组件动态引入"><a href="#vue路由组件动态引入" class="headerlink" title="vue路由组件动态引入"></a>vue路由组件动态引入</h3><p>在Vue中，可以使用动态组件和Vue Router结合来实现路由组件的动态引入。以下是一个简单的例子：</p>
<p>安装Vue Router：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router</span><br></pre></td></tr></table></figure>

<p>设置Vue Router，并使用动态导入来懒加载组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// router.js</span><br><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line">import Router from &apos;vue-router&apos;;</span><br><span class="line"></span><br><span class="line">Vue.use(Router);</span><br><span class="line"></span><br><span class="line">function loadView(view) &#123;</span><br><span class="line">  return () =&gt; import(`@/views/$&#123;view&#125;.vue`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const router = new Router(&#123;</span><br><span class="line">  mode: &apos;history&apos;,</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/&apos;,</span><br><span class="line">      name: &apos;home&apos;,</span><br><span class="line">      component: loadView(&apos;Home&apos;) // 动态引入Home组件</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/about&apos;,</span><br><span class="line">      name: &apos;about&apos;,</span><br><span class="line">      component: loadView(&apos;About&apos;) // 动态引入About组件</span><br><span class="line">    &#125;,</span><br><span class="line">    // 更多路由...</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default router;</span><br></pre></td></tr></table></figure>

<p>在Vue实例中使用router：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line">import App from &apos;./App.vue&apos;;</span><br><span class="line">import router from &apos;./router&apos;;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;).$mount(&apos;#app&apos;);</span><br></pre></td></tr></table></figure>

<p>在上述代码中，loadView函数负责根据视图名称动态创建组件加载函数。当Vue Router匹配到相应路由时，会调用这个加载函数来懒加载对应的组件文件。这样可以实现按需加载，提高应用的初始化速度和性能。</p>
<h3 id="对于即将到来的-vue3-0-特性你有什么了解的吗？"><a href="#对于即将到来的-vue3-0-特性你有什么了解的吗？" class="headerlink" title="对于即将到来的 vue3.0 特性你有什么了解的吗？"></a>对于即将到来的 vue3.0 特性你有什么了解的吗？</h3><p>Vue 3.0 正走在发布的路上，Vue 3.0 的目标是让 Vue 核心变得更小、更快、更强大，因此 Vue 3.0 增加以下这些新特性：</p>
<h4 id="（1）监测机制的改变"><a href="#（1）监测机制的改变" class="headerlink" title="（1）监测机制的改变"></a>（1）监测机制的改变</h4><p>3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。这消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：</p>
<ul>
<li>只能监测属性，不能监测对象</li>
<li>检测属性的添加和删除；</li>
<li>检测数组索引和长度的变更；</li>
<li>支持 Map、Set、WeakMap 和 WeakSet。</li>
</ul>
<p>新的 observer 还提供了以下特性：</p>
<ul>
<li>用于创建 observable 的公开 API。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。</li>
<li>默认采用惰性观察。在 2.x 中，不管反应式数据有多大，都会在启动时被观察到。如果你的数据集很大，这可能会在应用启动时带来明显的开销。在 3.x 中，只观察用于渲染应用程序最初可见部分的数据。</li>
<li>更精确的变更通知。在 2.x 中，通过 Vue.set 强制添加新属性将导致依赖于该对象的 watcher 收到变更通知。在 3.x 中，只有依赖于特定属性的 watcher 才会收到通知。</li>
<li>不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 prop 传递或 Vuex 状态树以外的变化。</li>
<li>更好的调试功能：我们可以使用新的 renderTracked 和 renderTriggered 钩子精确地跟踪组件在什么时候以及为什么重新渲染。</li>
</ul>
<h4 id="（2）模板"><a href="#（2）模板" class="headerlink" title="（2）模板"></a>（2）模板</h4><p>模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。</p>
<p>同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。</p>
<h4 id="（3）对象式的组件声明方式"><a href="#（3）对象式的组件声明方式" class="headerlink" title="（3）对象式的组件声明方式"></a>（3）对象式的组件声明方式</h4><p>vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。</p>
<p>3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易。</p>
<p>此外，vue 的源码也改用了 TypeScript 来写。其实当代码的功能复杂之后，必须有一个静态类型系统来做一些辅助管理。</p>
<p>现在 vue3.0 也全面改用 TypeScript 来重写了，更是使得对外暴露的 api 更容易结合 TypeScript。静态类型系统对于复杂代码的维护确实很有必要。</p>
<h4 id="（4）其它方面的更改"><a href="#（4）其它方面的更改" class="headerlink" title="（4）其它方面的更改"></a>（4）其它方面的更改</h4><p>vue3.0 的改变是全面的，上面只涉及到主要的 3 个方面，还有一些其他的更改：</p>
<ul>
<li>支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。</li>
<li>支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。</li>
<li>基于 treeshaking 优化，提供了更多的内置功能。</li>
</ul>
<h2 id="说说你使用-Vue-框架踩过最大的坑是什么？怎么解决的？"><a href="#说说你使用-Vue-框架踩过最大的坑是什么？怎么解决的？" class="headerlink" title="说说你使用 Vue 框架踩过最大的坑是什么？怎么解决的？"></a>说说你使用 Vue 框架踩过最大的坑是什么？怎么解决的？</h2><p>本题为开放题目，Vue框架部分我们会涉及一些高频且有一定探讨价值的面试题,我们不会涉及一些非常初级的在官方文档就能查看的纯记忆性质的面试题,比如:</p>
<ul>
<li>vue常用的修饰符?</li>
<li>vue-cli 工程常用的 npm 命令有哪些？</li>
<li>vue中 keep-alive 组件的作用?</li>
</ul>
<p>首先,上述类型的面试题在文档中可查,没有比官方文档更权威的答案了,其次这种问题没有太大价值,除了考察候选人的记忆力,最后,这种面试题只要用过vue的都知道,没有必要占用我们的篇幅.</p>
<p>我们的问题并不多,但是难度可能会高一些,如果你真的搞懂了这些问题,在绝大多数情况下会有举一反三的效果,可以说基本能拿下Vue相关的所有重要知识点了.</p>
<h3 id="MVVM是什么"><a href="#MVVM是什么" class="headerlink" title="MVVM是什么?"></a>MVVM是什么?</h3><p>MVVM 模式，顾名思义即 Model-View-ViewModel 模式。它萌芽于2005年微软推出的基于 Windows 的用户界面框架 WPF ，前端最早的 MVVM 框架 knockout 在2010年发布。</p>
<p>Model 层: 对应数据层的域模型，它主要做域模型的同步。通过 Ajax/fetch 等 API 完成客户端和服务端业务 Model 的同步。在层间关系里，它主要用于抽象出 ViewModel 中视图的 Model。</p>
<p>View 层:作为视图模板存在，在 MVVM 里，整个 View 是一个动态模板。除了定义结构、布局外，它展示的是 ViewModel 层的数据和状态。View 层不负责处理状态，View 层做的是 数据绑定的声明、 指令的声明、 事件绑定的声明。</p>
<p>ViewModel 层:把 View 需要的层数据暴露，并对 View 层的 数据绑定声明、 指令声明、 事件绑定声明 负责，也就是处理 View 层的具体业务逻辑。ViewModel 底层会做好绑定属性的监听。当 ViewModel 中数据变化，View 层会得到更新；而当 View 中声明了数据的双向绑定（通常是表单元素），框架也会监听 View 层（表单）值的变化。一旦值变化，View 层绑定的 ViewModel 中的数据也会得到自动更新。</p>
<h3 id="MVVM的优缺点"><a href="#MVVM的优缺点" class="headerlink" title="MVVM的优缺点?"></a>MVVM的优缺点?</h3><p>优点:</p>
<ol>
<li>分离视图（View）和模型（Model）,降低代码耦合，提高视图或者逻辑的重用性: 比如视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定不同的”View”上，当View变化的时候Model不可以不变，当Model变化的时候View也可以不变。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑</li>
<li>提高可测试性: ViewModel的存在可以帮助开发者更好地编写测试代码</li>
<li>自动更新dom: 利用双向绑定,数据更新后视图自动更新,让开发者从繁琐的手动dom中解放</li>
</ol>
<p>缺点:</p>
<ol>
<li>Bug很难被调试: 因为使用双向绑定的模式，当你看到界面异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。数据绑定使得一个位置的Bug被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了。另外，数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的</li>
<li>一个大的模块中model也会很大，虽然使用方便了也很容易保证了数据的一致性，当时长期持有，不释放内存就造成了花费更多的内存</li>
<li>对于大型的图形应用程序，视图状态较多，ViewModel的构建和维护的成本都会比较高</li>
</ol>
<h3 id="异步请求适合在哪个生命周期调用？"><a href="#异步请求适合在哪个生命周期调用？" class="headerlink" title="异步请求适合在哪个生命周期调用？"></a>异步请求适合在哪个生命周期调用？</h3><p>官方实例的异步请求是在mounted生命周期中调用的，而实际上也可以在created生命周期中调用。</p>
<h3 id="Vue组件如何通信？"><a href="#Vue组件如何通信？" class="headerlink" title="Vue组件如何通信？"></a>Vue组件如何通信？</h3><p>Vue组件通信的方法如下:</p>
<ul>
<li><code>props</code> <code>$emit+v-on</code>: 通过props将数据自上而下传递，而通过<code>$emit</code>和<code>v-on</code>来向上传递信息。</li>
<li>EventBus: 通过EventBus进行信息的发布与订阅</li>
<li>vuex: 是全局数据管理库，可以通过vuex管理全局的数据流</li>
<li><code>$attrs</code> <code>$listeners</code>: Vue2.4中加入的<code>$attrs/$listeners</code>可以进行跨级的组件通信</li>
<li><code>provide/inject</code>：以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效，这成为了跨组件通信的基础</li>
</ul>
<p>还有一些用solt插槽或者ref实例进行通信的，使用场景过于有限就不赘述了。</p>
<h3 id="computed和watch有什么区别"><a href="#computed和watch有什么区别" class="headerlink" title="computed和watch有什么区别?"></a>computed和watch有什么区别?</h3><p>computed:</p>
<ol>
<li><code>computed</code>是计算属性,也就是计算值,它更多用于计算值的场景</li>
<li><code>computed</code>具有缓存性,computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时才会重新调用对应的getter来计算</li>
<li><code>computed</code>适用于计算比较消耗性能的计算场景</li>
</ol>
<p>watch:</p>
<ol>
<li>更多的是「观察」的作用,类似于某些数据的监听回调,用于观察<code>props</code> <code>$emit</code>或者本组件的值,当数据变化时来执行回调进行后续操作</li>
<li>无缓存性，页面重新渲染时值不变化也会执行</li>
</ol>
<p>小结:</p>
<ol>
<li>当我们要进行数值计算,而且依赖于其他数据，那么把这个数据设计为computed</li>
<li>如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化</li>
</ol>
<h3 id="Vue是如何实现双向绑定的"><a href="#Vue是如何实现双向绑定的" class="headerlink" title="Vue是如何实现双向绑定的?"></a>Vue是如何实现双向绑定的?</h3><p>利用<code>Object.defineProperty</code>劫持对象的访问器,在属性值发生变化时我们可以获取变化,然后根据变化进行后续响应,在vue3.0中通过Proxy代理对象进行类似的操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是将要被劫持的对象</span></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">    name: <span class="string">''</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name === <span class="string">'古天乐'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'给大家推荐一款超好玩的游戏'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name === <span class="string">'渣渣辉'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'戏我演过很多,可游戏我只玩贪玩懒月'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'来做我的兄弟'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历对象,对其属性值进行劫持</span></span><br><span class="line"><span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'get'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function(newVal) &#123;</span><br><span class="line">        <span class="comment">// 当属性值发生变化时我们可以进行额外操作</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`大家好,我系<span class="subst">$&#123;newVal&#125;</span>`</span>);</span><br><span class="line">        say(newVal);</span><br><span class="line">    &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">data.name = <span class="string">'渣渣辉'</span>;</span><br><span class="line"><span class="comment">//大家好,我系渣渣辉</span></span><br><span class="line"><span class="comment">//戏我演过很多,可游戏我只玩贪玩懒月</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>详细实现见<a href="http://mp.weixin.qq.com/s?__biz=MzI3NjM1OTI3Mw==&mid=2247483695&idx=1&sn=8f4d74b58f4102eced8089bcaac4c443&chksm=eb77f029dc00793f502d4a39819e488d560e6bf7d268f3e987a03d43d71a07a2edab59d8d78f&scene=21#wechat_redirect" target="_blank" rel="noopener">Proxy比defineproperty优劣对比?</a></p>
</blockquote>
<h3 id="Proxy与Object-defineProperty的优劣对比"><a href="#Proxy与Object-defineProperty的优劣对比" class="headerlink" title="Proxy与Object.defineProperty的优劣对比?"></a>Proxy与Object.defineProperty的优劣对比?</h3><p>Proxy的优势如下:</p>
<ul>
<li>Proxy可以直接监听对象而非属性</li>
<li>Proxy可以直接监听数组的变化</li>
<li>Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是<code>Object.defineProperty</code>不具备的</li>
<li>Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而<code>Object.defineProperty</code>只能遍历对象属性直接修改</li>
<li>Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利</li>
</ul>
<p>Object.defineProperty的优势如下:</p>
<ul>
<li>兼容性好,支持IE9</li>
</ul>
<blockquote>
<p>详细实现见<a href="http://mp.weixin.qq.com/s?__biz=MzI3NjM1OTI3Mw==&mid=2247483695&idx=1&sn=8f4d74b58f4102eced8089bcaac4c443&chksm=eb77f029dc00793f502d4a39819e488d560e6bf7d268f3e987a03d43d71a07a2edab59d8d78f&scene=21#wechat_redirect" target="_blank" rel="noopener">Proxy比defineproperty优劣对比</a>?</p>
</blockquote>
<h3 id="你是如何理解Vue的响应式系统的"><a href="#你是如何理解Vue的响应式系统的" class="headerlink" title="你是如何理解Vue的响应式系统的?"></a>你是如何理解Vue的响应式系统的?</h3><p>响应式系统简述:</p>
<ul>
<li>任何一个 Vue Component 都有一个与之对应的 Watcher 实例。</li>
<li>Vue 的 data 上的属性会被添加 getter 和 setter 属性。</li>
<li>当 Vue Component render 函数被执行的时候, data 上会被 触碰(touch), 即被读, getter 方法会被调用, 此时 Vue 会去记录此 Vue component 所依赖的所有 data。(这一过程被称为依赖收集)</li>
<li>data 被改动时（主要是用户操作）, 即被写, setter 方法会被调用, 此时 Vue 会去通知所有依赖于此 data 的组件去调用他们的 render 函数进行更新。</li>
</ul>
<h3 id="虚拟DOM的优劣如何"><a href="#虚拟DOM的优劣如何" class="headerlink" title="虚拟DOM的优劣如何?"></a>虚拟DOM的优劣如何?</h3><p>优点:</p>
<ul>
<li>保证性能下限: 虚拟DOM可以经过diff找出最小差异,然后批量进行patch,这种操作虽然比不上手动优化,但是比起粗暴的DOM操作性能要好很多,因此虚拟DOM可以保证性能下限</li>
<li>无需手动操作DOM: 虚拟DOM的diff和patch都是在一次更新中自动进行的,我们无需手动操作DOM,极大提高开发效率</li>
<li>跨平台: 虚拟DOM本质上是JavaScript对象,而DOM与平台强相关,相比之下虚拟DOM可以进行更方便地跨平台操作,例如服务器渲染、移动端开发等等</li>
</ul>
<p>缺点:</p>
<ul>
<li>无法进行极致优化: 在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化,比如VScode采用直接手动操作DOM的方式进行极端的性能优化</li>
</ul>
<h3 id="虚拟DOM实现原理"><a href="#虚拟DOM实现原理" class="headerlink" title="虚拟DOM实现原理?"></a>虚拟DOM实现原理?</h3><ul>
<li>虚拟DOM本质上是JavaScript对象,是对真实DOM的抽象</li>
<li>状态变更时，记录新树和旧树的差异</li>
<li>最后把差异更新到真正的dom中</li>
</ul>
<blockquote>
<p>详细实现见<a href="http://mp.weixin.qq.com/s?__biz=MzI3NjM1OTI3Mw==&mid=2247483738&idx=1&sn=3f38e3ad9dddfa9740c9f3f4eb8b412c&chksm=eb77f05cdc00794a8b87f46b5bef4d854227b800c0a3b71178f8cc1624ecafa049c8339981ae&scene=21#wechat_redirect" target="_blank" rel="noopener">虚拟DOM原理</a>?</p>
</blockquote>
<h3 id="既然Vue通过数据劫持可以精准探测数据变化-为什么还需要虚拟DOM进行diff检测差异"><a href="#既然Vue通过数据劫持可以精准探测数据变化-为什么还需要虚拟DOM进行diff检测差异" class="headerlink" title="既然Vue通过数据劫持可以精准探测数据变化,为什么还需要虚拟DOM进行diff检测差异?"></a>既然Vue通过数据劫持可以精准探测数据变化,为什么还需要虚拟DOM进行diff检测差异?</h3><p>考点: Vue的变化侦测原理</p>
<p>前置知识: 依赖收集、虚拟DOM、响应式系统</p>
<p>现代前端框架有两种方式侦测变化,一种是pull一种是push</p>
<p>pull: 其代表为React,我们可以回忆一下React是如何侦测到变化的,我们通常会用<code>setState</code>API显式更新,然后React会进行一层层的Virtual Dom Diff操作找出差异,然后Patch到DOM上,React从一开始就不知道到底是哪发生了变化,只是知道「有变化了」,然后再进行比较暴力的Diff操作查找「哪发生变化了」，另外一个代表就是Angular的脏检查操作。</p>
<p>push: Vue的响应式系统则是push的代表,当Vue程序初始化的时候就会对数据data进行依赖的收集,一但数据发生变化,响应式系统就会立刻得知,因此Vue是一开始就知道是「在哪发生变化了」,但是这又会产生一个问题,如果你熟悉Vue的响应式系统就知道,通常一个绑定一个数据就需要一个Watcher,一但我们的绑定细粒度过高就会产生大量的Watcher,这会带来内存以及依赖追踪的开销,而细粒度过低会无法精准侦测变化,因此Vue的设计是选择中等细粒度的方案,在组件级别进行push侦测的方式,也就是那套响应式系统,通常我们会第一时间侦测到发生变化的组件,然后在组件内部进行Virtual Dom Diff获取更加具体的差异,而Virtual Dom Diff则是pull操作,Vue是push+pull结合的方式进行变化侦测的.</p>
<h3 id="Vue为什么没有类似于React中shouldComponentUpdate的生命周期？"><a href="#Vue为什么没有类似于React中shouldComponentUpdate的生命周期？" class="headerlink" title="Vue为什么没有类似于React中shouldComponentUpdate的生命周期？"></a>Vue为什么没有类似于React中shouldComponentUpdate的生命周期？</h3><p>考点: Vue的变化侦测原理</p>
<p>前置知识: 依赖收集、虚拟DOM、响应式系统</p>
<p>根本原因是Vue与React的变化侦测方式有所不同</p>
<p>React是pull的方式侦测变化,当React知道发生变化后,会使用Virtual Dom Diff进行差异检测,但是很多组件实际上是肯定不会发生变化的,这个时候需要用shouldComponentUpdate进行手动操作来减少diff,从而提高程序整体的性能.</p>
<p>Vue是pull+push的方式侦测变化的,在一开始就知道那个组件发生了变化,因此在push的阶段并不需要手动控制diff,而组件内部采用的diff方式实际上是可以引入类似于shouldComponentUpdate相关生命周期的,但是通常合理大小的组件不会有过量的diff,手动优化的价值有限,因此目前Vue并没有考虑引入shouldComponentUpdate这种手动优化的生命周期.</p>
<h3 id="Vue中的key到底有什么用？"><a href="#Vue中的key到底有什么用？" class="headerlink" title="Vue中的key到底有什么用？"></a>Vue中的key到底有什么用？</h3><p><code>key</code>是为Vue中的vnode标记的唯一id,通过这个key,我们的diff操作可以更准确、更快速</p>
<p>diff算法的过程中,先会进行新旧节点的首尾交叉对比,当无法匹配的时候会用新节点的<code>key</code>与旧节点进行比对,然后超出差异.</p>
<blockquote>
<p>diff程可以概括为：oldCh和newCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较,这四种比较方式就是首、尾、旧尾新头、旧头新尾.</p>
</blockquote>
<ul>
<li>准确: 如果不加<code>key</code>,那么vue会选择复用节点(Vue的就地更新策略),导致之前节点的状态被保留下来,会产生一系列的bug.</li>
<li>快速: key的唯一性可以被Map数据结构充分利用,相比于遍历查找的时间复杂度O(n),Map的时间复杂度仅仅为O(1).</li>
</ul>
<p>在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 message 的翻转字符串。当你想要在模板中多次引用此处的翻转字符串时，就会更加难以处理。</p>
<p>所以，对于任何复杂逻辑，你都应当使用计算属性。</p>
<h3 id="vue-cli提供了几种脚手架模板"><a href="#vue-cli提供了几种脚手架模板" class="headerlink" title="vue-cli提供了几种脚手架模板"></a>vue-cli提供了几种脚手架模板</h3><p>六种</p>
<p><a href="https://github.com/vuejs/vue-cli/tree/v2#vue-cli--" target="_blank" rel="noopener">https://github.com/vuejs/vue-cli/tree/v2#vue-cli--</a></p>
<h3 id="computed、methods的区别"><a href="#computed、methods的区别" class="headerlink" title="computed、methods的区别"></a>computed、methods的区别</h3><p>两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的依赖进行缓存的。只在相关依赖发生改变时它们才会重新求值。这就意味着只要值还没有发生改变，多次访问 定义的计算属性会立即返回之前的计算结果，而不必再次执行函数。</p>
<p>相比之下，每当触发重新渲染时，调用方法(methods)将总会再次执行函数。</p>
<p>我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。</p>
<h3 id="什么是自定义指令，有哪些钩子函数及自定义指令的使用场景"><a href="#什么是自定义指令，有哪些钩子函数及自定义指令的使用场景" class="headerlink" title="什么是自定义指令，有哪些钩子函数及自定义指令的使用场景"></a>什么是自定义指令，有哪些钩子函数及自定义指令的使用场景</h3><p>有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。</p>
<p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p>
<p>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p>
<p>inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</p>
<p>update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</p>
<p>componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</p>
<p>unbind：只调用一次，指令与元素解绑时调用。</p>
<h3 id="父组件获取异步动态数据传递给子组件"><a href="#父组件获取异步动态数据传递给子组件" class="headerlink" title="父组件获取异步动态数据传递给子组件"></a>父组件获取异步动态数据传递给子组件</h3><p>在父组件中使用axios获取异步数据传给子组件，但是发现子组件在渲染的时候并没有数据，在created里面打印也是空的，结果发现一开始子组件绑定的数据是空的，在请求数据没有返回数据时，子组件就已经加载了，并且他绑定的值也是空的，问题找到了，怎么解决呢？</p>
<blockquote>
<p>开始的时候让子组件隐藏,然后等数据返回的时候，让子组件显示</p>
<p>通过v-if，也就是判断数据是否为空，为空就不渲染，也能解决了</p>
<p>为不能读取的属性添加一个默认值，就可以很好的解决了</p>
</blockquote>
<h3 id="vue-router实现原理"><a href="#vue-router实现原理" class="headerlink" title="vue-router实现原理"></a>vue-router实现原理</h3><p>这里指的路由并不是指我们平时所说的硬件路由器，这里的路由就是SPA（单页应用）的路径管理器。 换句话说，vue-router就是WebApp的链接路径管理系统。</p>
<p>vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。</p>
<h4 id="那与传统的页面跳转有什么区别呢？"><a href="#那与传统的页面跳转有什么区别呢？" class="headerlink" title="那与传统的页面跳转有什么区别呢？"></a>那与传统的页面跳转有什么区别呢？</h4><p>1.vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。</p>
<p>2.传统的页面应用，是用一些超链接来实现页面切换和跳转的。</p>
<p>在vue-router单页面应用中，则是路径之间的切换，也就是组件的切换。路由模块的本质 就是建立起url和页面之间的映射关系。</p>
<p>至于为啥不能用a标签，这是因为用Vue做的都是单页应用，就相当于只有一个主的index.html页面，所以你写的标签是不起作用的，必须使用vue-router来进行管理。</p>
<p>SPA(single page application):单一页面应用程序，有且只有一个完整的页面；当它在加载页面的时候，不会加载整个页面的内容，而只更新某个指定的容器中内容。</p>
<p>单页面应用(SPA)的核心之一是:</p>
<p>更新视图而不重新请求页面;</p>
<p>vue-router在实现单页面前端路由时，提供了三种方式：Hash模式、History模式、abstract模式，根据mode参数来决定采用哪一种方式。</p>
<h3 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h3><p>vue-router 提供了三种运行模式：</p>
<p>● hash: 使用 URL hash 值来作路由。默认模式。</p>
<p>● history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。</p>
<p>● abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。</p>
<h4 id="Hash模式"><a href="#Hash模式" class="headerlink" title="Hash模式"></a>Hash模式</h4><p>vue-router 默认模式是 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，当 URL 改变时，页面不会去重新加载。</p>
<p>hash（#）是URL 的锚点，代表的是网页中的一个位置，单单改变#后的部分（/#/…），浏览器只会加载相应位置的内容，不会重新加载网页，也就是说 #是用来指导浏览器动作的，对服务器端完全无用，HTTP请求中不包括#；同时每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置；所以说Hash模式通过锚点值的改变，根据不同的值，渲染指定DOM位置的不同数据。</p>
<p>JavaScript实现SPA路由hash模式详解</p>
<h4 id="History模式"><a href="#History模式" class="headerlink" title="History模式"></a>History模式</h4><p>HTML5 History API提供了一种功能，能让开发人员在不刷新整个页面的情况下修改站点的URL，就是利用 history.pushState API 来完成 URL 跳转而无须重新加载页面；</p>
<p>由于hash模式会在url中自带#，如果不想要很丑的 hash，我们可以用路由的 history 模式，只需要在配置路由规则时，加入”mode: ‘history’”,这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。</p>
<p><a href="https://main.xn--js-ry2cx4aj93f/" target="_blank" rel="noopener">//main.js文件中</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">	mode: ‘history’,</span><br><span class="line">	routes: […]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当使用 history 模式时，URL 就像正常的 url，例如 <a href="http://yoursite.com/user/id，比较好…" target="_blank" rel="noopener">yoursite.com/user/id，比较好…</a> 不过这种模式有点问题，还需要后台配置支持。你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面，如果不这么做，直接访问页面空白</p>
<h3 id="配置Apache"><a href="#配置Apache" class="headerlink" title="配置Apache"></a>配置Apache</h3><p>第一步：新建：.htaccess文件放在服务器根目录下 （命令type null&gt;.htaccess）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line">	RewriteEngine On</span><br><span class="line">	RewriteBase /</span><br><span class="line">	RewriteRule ^index.html$ - [L]</span><br><span class="line">	RewriteCond %&#123;REQUEST_FILENAME&#125; !-f</span><br><span class="line">	RewriteCond %&#123;REQUEST_FILENAME&#125; !-d</span><br><span class="line">	RewriteRule . /index.html [L]</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure>

<p>除了 mod_rewrite，你也可以使用 FallbackResource。</p>
<p>第二步： src/router/index.js</p>
<p>mode: ‘history’,</p>
<p>base: ‘/dist/’,</p>
<p>第三步：访问：地址进行测试</p>
<p>abstract模式</p>
<p>abstract模式是使用一个不依赖于浏览器的浏览历史虚拟管理后端。</p>
<p>根据平台差异可以看出，在 Weex 环境中只支持使用 abstract 模式。 不过，vue-router 自身会对环境做校验，如果发现没有浏览器的 API，vue-router 会自动强制进入 abstract 模式，所以 在使用 vue-router 时只要不写 mode 配置即可，默认会在浏览器环境中使用 hash 模式，在移动端原生环境中使用 abstract 模式。 （当然，你也可以明确指定在所有情况下都使用 abstract 模式）</p>
<h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p>用户在组件中发起动作，然后从API中拿数据，就会牵扯到异步操作，所以我们通过dispatch来提交一个action，在action里面发起ajax请求，拿到数据以后我们只需要通过commit提交mutations改变我的state状态就可以了，状态改变后视图就会改变因为Vuex是响应式的，这就是Vuex的运作流程机制</p>
<h3 id="vuex中如何异步修改数据"><a href="#vuex中如何异步修改数据" class="headerlink" title="vuex中如何异步修改数据"></a>vuex中如何异步修改数据</h3><p>Action 类似于 mutation，不同在于：</p>
<p>Action 提交的是 mutation，而不是直接变更状态。</p>
<p>Action 可以包含任意异步操作。</p>
<p><img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_jpg/yphVQAwjncvicxKz1nicIOUh3ibEd24MWW1C0sVQ35DYJe5rPDTzZ8WeCPib3DibZ0uTc1Zfs9SGyDWoVu0cdgRNR8g/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="荣耀黄金"><a href="#荣耀黄金" class="headerlink" title="荣耀黄金"></a>荣耀黄金</h2><h3 id="1-Vue的优点？Vue的缺点？"><a href="#1-Vue的优点？Vue的缺点？" class="headerlink" title="1. Vue的优点？Vue的缺点？"></a>1. Vue的优点？Vue的缺点？</h3><p>优点：渐进式，组件化，轻量级，虚拟dom，响应式，单页面路由，数据与视图分开</p>
<p>缺点：单页面不利于seo，不支持IE8以下，首屏加载时间长</p>
<h3 id="2-为什么说Vue是一个渐进式框架？"><a href="#2-为什么说Vue是一个渐进式框架？" class="headerlink" title="2. 为什么说Vue是一个渐进式框架？"></a>2. 为什么说Vue是一个渐进式框架？</h3><p>渐进式：通俗点讲就是，你想用啥你就用啥，咱也不强求你。你想用component就用，不用也行，你想用vuex就用，不用也可以</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/sz_mmbiz_png/gMvNo9rxo40PPicD3fczxSYXZxxV3D2ORicibhZDdbZtm29mjvafm5unOBmia0s7iaSwolhVk6Ny4Aqe2Vbncoe4alw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>image.png



<h3 id="3-Vue跟React的异同点？"><a href="#3-Vue跟React的异同点？" class="headerlink" title="3. Vue跟React的异同点？"></a>3. Vue跟React的异同点？</h3><p>相同点：</p>
<ul>
<li>1.都使用了虚拟dom</li>
<li>2.组件化开发</li>
<li>3.都是单向数据流(父子组件之间，不建议子修改父传下来的数据)</li>
<li>4.都支持服务端渲染</li>
</ul>
<p>不同点：</p>
<ul>
<li>1.React的JSX，Vue的template</li>
<li>2.数据变化，React手动(setState)，Vue自动(初始化已响应式处理，Object.defineProperty)</li>
<li>3.React单向绑定，Vue双向绑定</li>
<li>4.React的Redux，Vue的Vuex</li>
</ul>
<h3 id="4-MVVM是什么？和MVC有何区别呢？"><a href="#4-MVVM是什么？和MVC有何区别呢？" class="headerlink" title="4. MVVM是什么？和MVC有何区别呢？"></a>4. MVVM是什么？和MVC有何区别呢？</h3><p>MVC</p>
<ul>
<li>Model(模型)：负责从数据库中取数据</li>
<li>View(视图)：负责展示数据的地方</li>
<li>Controller(控制器)：用户交互的地方，例如点击事件等等</li>
<li>思想：Controller将Model的数据展示在View上</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/sz_mmbiz_png/gMvNo9rxo40PPicD3fczxSYXZxxV3D2ORCeyFh1MjM6kv9Msc0jue4OfHGLlIUQhQXgbwJkngNsGlXO39AoIUog/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>image.png

<p>MVVM</p>
<ul>
<li>VM：也就是View-Model，做了两件事达到了数据的双向绑定 一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。</li>
<li>思想：实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素，来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变（对应Vue数据驱动的思想）</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/sz_mmbiz_png/gMvNo9rxo40PPicD3fczxSYXZxxV3D2ORickpt9vKH462r7e4Qia14ar4icQPk9IfZcFO81GB8AUCsh8Z2icRUzLIIw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>image.png

<p>区别</p>
<p>整体看来，MVVM 比 MVC 精简很多，不仅简化了业务与界面的依赖，还解决了数据频繁更新的问题，不用再用选择器操作 DOM 元素。因为在 MVVM 中，View 不知道 Model 的存在，Model 和 ViewModel 也观察不到 View，这种低耦合模式提高代码的可重用性</p>
<p>Vue是不是MVVM框架？</p>
<p>Vue是MVVM框架，但是不是严格符合MVVM，因为MVVM规定Model和View不能直接通信，而Vue的<code>ref</code>可以做到这点</p>
<h3 id="5-Vue和JQuery的区别在哪？为什么放弃JQuery用Vue？"><a href="#5-Vue和JQuery的区别在哪？为什么放弃JQuery用Vue？" class="headerlink" title="5. Vue和JQuery的区别在哪？为什么放弃JQuery用Vue？"></a>5. Vue和JQuery的区别在哪？为什么放弃JQuery用Vue？</h3><ul>
<li>1.jQuery是直接操作DOM，Vue不直接操作DOM，Vue的数据与视图是分开的，Vue只需要操作数据即可</li>
<li>2.jQuery的操作DOM行为是频繁的，而Vue利用虚拟DOM的技术，大大提高了更新DOM时的性能</li>
<li>3.Vue中不倡导直接操作DOM，开发者只需要把大部分精力放在数据层面上</li>
<li>4.Vue集成的一些库，大大提高开发效率，比如Vuex，Router等</li>
</ul>
<h3 id="6-Vue的作者是谁？大声说出它的名字！！！"><a href="#6-Vue的作者是谁？大声说出它的名字！！！" class="headerlink" title="6. Vue的作者是谁？大声说出它的名字！！！"></a>6. Vue的作者是谁？大声说出它的名字！！！</h3><p>他的名字就是：鱿鱼西</p>
<h2 id="永恒钻石"><a href="#永恒钻石" class="headerlink" title="永恒钻石"></a>永恒钻石</h2><h3 id="7-为什么data是个函数并且返回一个对象呢？"><a href="#7-为什么data是个函数并且返回一个对象呢？" class="headerlink" title="7. 为什么data是个函数并且返回一个对象呢？"></a>7. 为什么data是个函数并且返回一个对象呢？</h3><p><code>data</code>之所以只一个函数，是因为一个组件可能会多处调用，而每一次调用就会执行<code>data函数</code>并返回新的数据对象，这样，可以避免多处调用之间的<code>数据污染</code>。</p>
<h3 id="8-使用过哪些Vue的修饰符呢？"><a href="#8-使用过哪些Vue的修饰符呢？" class="headerlink" title="8. 使用过哪些Vue的修饰符呢？"></a>8. 使用过哪些Vue的修饰符呢？</h3><p>可以看我这篇文章<strong>「百毒不侵」面试官最喜欢问的13种Vue修饰符</strong>[1]</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/sz_mmbiz_png/gMvNo9rxo40PPicD3fczxSYXZxxV3D2OR4V4kawxZ0rNQDgwzWh52f3btQ3sic8LA7DHayibYGicSUuNLo53gPxfCA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>截屏2021-07-11 下午9.56.53.png



<h3 id="9-使用过哪些Vue的内部指令呢？"><a href="#9-使用过哪些Vue的内部指令呢？" class="headerlink" title="9. 使用过哪些Vue的内部指令呢？"></a>9. 使用过哪些Vue的内部指令呢？</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/sz_mmbiz_png/gMvNo9rxo40PPicD3fczxSYXZxxV3D2OReXR4ibmUb9kh4xNDO8cbmDiauq8cZ3mrbDd6VYk3bSblp3re6Xyd4jBA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>image.png



<h3 id="10-组件之间的传值方式有哪些？"><a href="#10-组件之间的传值方式有哪些？" class="headerlink" title="10. 组件之间的传值方式有哪些？"></a>10. 组件之间的传值方式有哪些？</h3><ul>
<li>父组件传值给子组件，子组件使用<code>props</code>进行接收</li>
<li>子组件传值给父组件，子组件使用<code>$emit+事件</code>对父组件进行传值</li>
<li>组件中可以使用<code>$parent</code>和<code>$children</code>获取到父组件实例和子组件实例，进而获取数据</li>
<li>使用<code>$attrs</code>和<code>$listeners</code>，在对一些组件进行二次封装时可以方便传值，例如A-&gt;B-&gt;C</li>
<li>使用<code>$refs</code>获取组件实例，进而获取数据</li>
<li>使用<code>Vuex</code>进行状态管理</li>
<li>使用<code>eventBus</code>进行跨组件触发事件，进而传递数据</li>
<li>使用<code>provide</code>和<code>inject</code>，官方建议我们不要用这个，我在看<code>ElementUI</code>源码时发现大量使用</li>
<li>使用浏览器本地缓存，例如<code>localStorage</code></li>
</ul>
<h3 id="11-路由有哪些模式呢？又有什么不同呢？"><a href="#11-路由有哪些模式呢？又有什么不同呢？" class="headerlink" title="11. 路由有哪些模式呢？又有什么不同呢？"></a>11. 路由有哪些模式呢？又有什么不同呢？</h3><ul>
<li>hash模式：通过<code>#号</code>后面的内容的更改，触发<code>hashchange</code>事件，实现路由切换</li>
<li>history模式：通过<code>pushState</code>和<code>replaceState</code>切换url，触发<code>popstate</code>事件，实现路由切换，需要后端配合</li>
</ul>
<h3 id="12-如何设置动态class，动态style？"><a href="#12-如何设置动态class，动态style？" class="headerlink" title="12. 如何设置动态class，动态style？"></a>12. 如何设置动态class，动态style？</h3><ul>
<li>动态class对象：<code>&lt;div :class={ &#39;is-active&#39;: true, &#39;red&#39;: isRed }&gt;&lt;/div&gt;</code></li>
<li>动态class数组：<code>&lt;div :class=[&#39;is-active&#39;, isRed ? &#39;red&#39; : &#39;&#39; ]&gt;&lt;/div&gt;</code></li>
<li>动态style对象：<code>&lt;div :style={ color: textColor, fontSize: &#39;18px&#39; }&gt;&lt;/div&gt;</code></li>
<li>动态style数组：<code>&lt;div :style=[{ color: textColor, fontSize: &#39;18px&#39; }, { fontWeight: &#39;300&#39; }]&gt;&lt;/div&gt;</code></li>
</ul>
<h3 id="13-v-if和v-show有何区别？"><a href="#13-v-if和v-show有何区别？" class="headerlink" title="13. v-if和v-show有何区别？"></a>13. v-if和v-show有何区别？</h3><ul>
<li>1.<code>v-if</code>是通过控制dom元素的删除和生成来实现显隐，每一次显隐都会使组件重新跑一遍生命周期，因为显隐决定了组件的生成和销毁</li>
<li>2.<code>v-show</code>是通过控制dom元素的css样式来实现显隐，不会销毁</li>
<li>3.频繁或者大数量显隐使用<code>v-show</code>，否则使用<code>v-if</code></li>
</ul>
<h3 id="14-computed和watch有何区别？"><a href="#14-computed和watch有何区别？" class="headerlink" title="14. computed和watch有何区别？"></a>14. computed和watch有何区别？</h3><ul>
<li>1.<code>computed</code>是依赖已有的变量来计算一个目标变量，大多数情况都是<code>多个变量</code>凑在一起计算出<code>一个变量</code>，并且<code>computed</code>具有<code>缓存机制</code>，依赖值不变的情况下其会直接读取缓存进行复用，<code>computed</code>不能进行<code>异步操作</code></li>
<li>2.<code>watch</code>是监听某一个变量的变化，并执行相应的回调函数，通常是<code>一个变量</code>的变化决定<code>多个变量</code>的变化，<code>watch</code>可以进行<code>异步操作</code></li>
<li>3.简单记就是：一般情况下<code>computed</code>是<code>多对一</code>，<code>watch</code>是<code>一对多</code></li>
</ul>
<h3 id="15-Vue的生命周期，讲一讲？"><a href="#15-Vue的生命周期，讲一讲？" class="headerlink" title="15. Vue的生命周期，讲一讲？"></a>15. Vue的生命周期，讲一讲？</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/sz_mmbiz_png/gMvNo9rxo40PPicD3fczxSYXZxxV3D2ORibreS1NicHBvGjhAwC5pkSMeaOVSrS1gl1DwbxxU5LQnhjc4z2AoD3BA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>



<h3 id="16-为什么v-if和v-for不建议用在同一标签？"><a href="#16-为什么v-if和v-for不建议用在同一标签？" class="headerlink" title="16. 为什么v-if和v-for不建议用在同一标签？"></a>16. 为什么v-if和v-for不建议用在同一标签？</h3><p>在Vue2中，<code>v-for</code>优先级是高于<code>v-if</code>的，咱们来看例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=item in [1, 2, 3, 4, 5, 6, 7] v-if=item !== 3&gt;</span><br><span class="line">    &#123;&#123;item&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>上面的写法是<code>v-for</code>和<code>v-if</code>同时存在，会先把7个元素都遍历出来，然后再一个个判断是否为3，并把3给隐藏掉，这样的坏处就是，渲染了无用的3节点，增加无用的dom操作，建议使用computed来解决这个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=item in list&gt;</span><br><span class="line">    &#123;&#123;item&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">computed() &#123;</span><br><span class="line">    list() &#123;</span><br><span class="line">        return [1, 2, 3, 4, 5, 6, 7].filter(item =&gt; item !== 3)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-vuex的有哪些属性？用处是什么？"><a href="#17-vuex的有哪些属性？用处是什么？" class="headerlink" title="17. vuex的有哪些属性？用处是什么？"></a>17. vuex的有哪些属性？用处是什么？</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/sz_mmbiz_png/gMvNo9rxo40PPicD3fczxSYXZxxV3D2ORaSZPoXANK5XTKiaYUKGPDZPjFx61fg7DNxeXctJxT08ibz9IagIXTmrA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>image.png

<ul>
<li>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li>
<li>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li>
<li>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。</li>
<li>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</li>
<li>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</li>
</ul>
<h2 id="至尊星耀"><a href="#至尊星耀" class="headerlink" title="至尊星耀"></a>至尊星耀</h2><h3 id="18-不需要响应式的数据应该怎么处理？"><a href="#18-不需要响应式的数据应该怎么处理？" class="headerlink" title="18. 不需要响应式的数据应该怎么处理？"></a>18. 不需要响应式的数据应该怎么处理？</h3><p>在我们的Vue开发中，会有一些数据，从始至终都<code>未曾改变过</code>，这种<code>死数据</code>，既然<code>不改变</code>，那也就<code>不需要对他做响应式处理</code>了，不然只会做一些无用功消耗性能，比如一些写死的下拉框，写死的表格数据，这些数据量大的<code>死数据</code>，如果都进行响应式处理，那会消耗大量性能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 方法一：将数据定义在data之外</span><br><span class="line">data () &#123;</span><br><span class="line">    this.list1 = &#123; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &#125;</span><br><span class="line">    this.list2 = &#123; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &#125;</span><br><span class="line">    this.list3 = &#123; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &#125;</span><br><span class="line">    this.list4 = &#123; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &#125;</span><br><span class="line">    this.list5 = &#123; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &#125;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line">// 方法二：Object.freeze()</span><br><span class="line">data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        list1: Object.freeze(&#123;xxxxxxxxxxxxxxxxxxxxxxxx&#125;),</span><br><span class="line">        list2: Object.freeze(&#123;xxxxxxxxxxxxxxxxxxxxxxxx&#125;),</span><br><span class="line">        list3: Object.freeze(&#123;xxxxxxxxxxxxxxxxxxxxxxxx&#125;),</span><br><span class="line">        list4: Object.freeze(&#123;xxxxxxxxxxxxxxxxxxxxxxxx&#125;),</span><br><span class="line">        list5: Object.freeze(&#123;xxxxxxxxxxxxxxxxxxxxxxxx&#125;),</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-watch有哪些属性，分别有什么用？"><a href="#19-watch有哪些属性，分别有什么用？" class="headerlink" title="19. watch有哪些属性，分别有什么用？"></a>19. watch有哪些属性，分别有什么用？</h3><p>当我们监听一个基本数据类型时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    value () &#123;</span><br><span class="line">        // do something</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们监听一个引用数据类型时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    obj: &#123;</span><br><span class="line">       handler () &#123; // 执行回调</span><br><span class="line">           // do something</span><br><span class="line">       &#125;,</span><br><span class="line">       deep: true, // 是否进行深度监听</span><br><span class="line">       immediate: true // 是否初始执行handler函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20-父子组件生命周期顺序"><a href="#20-父子组件生命周期顺序" class="headerlink" title="20. 父子组件生命周期顺序"></a>20. 父子组件生命周期顺序</h3><p>父beforeCreate -&gt; 父created -&gt; 父beforeMount -&gt; 子beforeCreate -&gt; 子created -&gt; 子beforeMount -&gt; 子mounted -&gt; 父mounted</p>
<h3 id="21-对象新属性无法更新视图，删除属性无法更新视图，为什么？怎么办？"><a href="#21-对象新属性无法更新视图，删除属性无法更新视图，为什么？怎么办？" class="headerlink" title="21. 对象新属性无法更新视图，删除属性无法更新视图，为什么？怎么办？"></a>21. 对象新属性无法更新视图，删除属性无法更新视图，为什么？怎么办？</h3><ul>
<li>原因：<code>Object.defineProperty</code>没有对对象的新属性进行属性劫持</li>
<li>对象新属性无法更新视图：使用<code>Vue.$set(obj, key, value)</code>，组件中<code>this.$set(obj, key, value)</code></li>
<li>删除属性无法更新视图：使用<code>Vue.$delete(obj, key)</code>，组件中<code>this.$delete(obj, key)</code></li>
</ul>
<h3 id="22-直接arr-index-xxx无法更新视图怎么办？为什么？怎么办？"><a href="#22-直接arr-index-xxx无法更新视图怎么办？为什么？怎么办？" class="headerlink" title="22. 直接arr[index] = xxx无法更新视图怎么办？为什么？怎么办？"></a>22. 直接arr[index] = xxx无法更新视图怎么办？为什么？怎么办？</h3><ul>
<li>原因：Vue没有对数组进行<code>Object.defineProperty</code>的属性劫持，所以直接arr[index] = xxx是无法更新视图的</li>
<li>使用数组的splice方法，<code>arr.splice(index, 1, item)</code></li>
<li>使用<code>Vue.$set(arr, index, value)</code></li>
</ul>
<h3 id="24-插槽的使用以及原理？"><a href="#24-插槽的使用以及原理？" class="headerlink" title="24. 插槽的使用以及原理？"></a>24. 插槽的使用以及原理？</h3><p>建议看我这篇文章<strong>「Vue源码学习」你真的知道插槽Slot是怎么“插”的吗</strong>[3]</p>
<h3 id="25-为什么不建议用index做key，为什么不建议用随机数做key？"><a href="#25-为什么不建议用index做key，为什么不建议用随机数做key？" class="headerlink" title="25. 为什么不建议用index做key，为什么不建议用随机数做key？"></a>25. 为什么不建议用index做key，为什么不建议用随机数做key？</h3><p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=(item, index) in list :key=index&gt;&#123;&#123;item.name&#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">list: [</span><br><span class="line">    &#123; name: &apos;小明&apos;, id: &apos;123&apos; &#125;,</span><br><span class="line">    &#123; name: &apos;小红&apos;, id: &apos;124&apos; &#125;,</span><br><span class="line">    &#123; name: &apos;小花&apos;, id: &apos;125&apos; &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">渲染为</span><br><span class="line">&lt;div key=0&gt;小明&lt;/div&gt;</span><br><span class="line">&lt;div key=1&gt;小红&lt;/div&gt;</span><br><span class="line">&lt;div key=2&gt;小花&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">现在我执行 list.unshift(&#123; name: &apos;小林&apos;, id: &apos;122&apos; &#125;)</span><br><span class="line"></span><br><span class="line">渲染为</span><br><span class="line">&lt;div key=0&gt;小林&lt;/div&gt;</span><br><span class="line">&lt;div key=1&gt;小明&lt;/div&gt;</span><br><span class="line">&lt;div key=2&gt;小红&lt;/div&gt;</span><br><span class="line">&lt;div key=3&gt;小花&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">新旧对比</span><br><span class="line"></span><br><span class="line">&lt;div key=0&gt;小明&lt;/div&gt;  &lt;div key=0&gt;小林&lt;/div&gt;</span><br><span class="line">&lt;div key=1&gt;小红&lt;/div&gt;  &lt;div key=1&gt;小明&lt;/div&gt;</span><br><span class="line">&lt;div key=2&gt;小花&lt;/div&gt;  &lt;div key=2&gt;小红&lt;/div&gt;</span><br><span class="line">                         &lt;div key=3&gt;小花&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">可以看出，如果用index做key的话，其实是更新了原有的三项，并新增了小花，虽然达到了渲染目的，但是损耗性能</span><br><span class="line"></span><br><span class="line">现在我们使用id来做key，渲染为</span><br><span class="line"></span><br><span class="line">&lt;div key=123&gt;小明&lt;/div&gt;</span><br><span class="line">&lt;div key=124&gt;小红&lt;/div&gt;</span><br><span class="line">&lt;div key=125&gt;小花&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">现在我执行 list.unshift(&#123; name: &apos;小林&apos;, id: &apos;122&apos; &#125;)，渲染为</span><br><span class="line"></span><br><span class="line">&lt;div key=122&gt;小林&lt;/div&gt;</span><br><span class="line">&lt;div key=123&gt;小明&lt;/div&gt;</span><br><span class="line">&lt;div key=124&gt;小红&lt;/div&gt;</span><br><span class="line">&lt;div key=125&gt;小花&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">新旧对比</span><br><span class="line"></span><br><span class="line">                           &lt;div key=122&gt;小林&lt;/div&gt;</span><br><span class="line">&lt;div key=123&gt;小明&lt;/div&gt;  &lt;div key=123&gt;小明&lt;/div&gt;</span><br><span class="line">&lt;div key=124&gt;小红&lt;/div&gt;  &lt;div key=124&gt;小红&lt;/div&gt;</span><br><span class="line">&lt;div key=125&gt;小花&lt;/div&gt;  &lt;div key=125&gt;小花&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">可以看出，原有的三项都不变，只是新增了小林这个人，这才是最理想的结果</span><br></pre></td></tr></table></figure>

<p>用<code>index</code>和用<code>随机数</code>都是同理，<code>随机数</code>每次都在变，做不到专一性，很<code>渣男</code>，也很消耗性能，所以，拒绝<code>渣男</code>，选择<code>老实人</code></p>
<h3 id="26-说说nextTick的用处？"><a href="#26-说说nextTick的用处？" class="headerlink" title="26. 说说nextTick的用处？"></a>26. 说说nextTick的用处？</h3><p>我举个例子，在vue中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.name = &apos;公众号：前端印象&apos;</span><br><span class="line">this.age = 18</span><br><span class="line">this.gender = &apos;男&apos;</span><br></pre></td></tr></table></figure>

<p>我们修改了三个变量，那问题来了，是每修改一次，DOM就更新一次吗？不是的，Vue采用的是<code>异步更新</code>的策略，通俗点说就是，<code>同一事件循环内</code>多次修改，会<code>统一</code>进行一次<code>视图更新</code>，这样才能节省性能嘛</p>
<p>看懂了上面，那你应该也看得懂下面的例子了吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div ref=testDiv&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">name: &apos;小林&apos;</span><br><span class="line"></span><br><span class="line">this.name = &apos;公众号：前端印象&apos;</span><br><span class="line">console.log(this.$refs.testDiv.innerHTML) // 这里是啥呢</span><br></pre></td></tr></table></figure>

<p>答案是“小林”，前面说了，Vue是<code>异步更新</code>，所以数据一更新，视图却还没更新，所以拿到的还是上一次的旧视图数据，那么想要拿到最新视图数据怎么办呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.name = &apos;公众号：前端印象&apos;</span><br><span class="line">this.$nextTick(() =&gt; &#123;</span><br><span class="line">    console.log(this.$refs.testDiv.innerHTML) // 公众号：前端印象</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="27-Vue的SSR是什么？有什么好处？"><a href="#27-Vue的SSR是什么？有什么好处？" class="headerlink" title="27. Vue的SSR是什么？有什么好处？"></a>27. Vue的SSR是什么？有什么好处？</h3><ul>
<li><code>SSR</code>就是服务端渲染</li>
<li>基于<code>nodejs serve</code>服务环境开发，所有<code>html</code>代码在服务端渲染</li>
<li>数据返回给前端，然后前端进行“激活”，即可成为浏览器识别的html代码</li>
<li><code>SSR</code>首次加载更快，有更好的用户体验，有更好的seo优化，因为爬虫能看到整个页面的内容，如果是vue项目，由于数据还要经过解析，这就造成爬虫并不会等待你的数据加载完成，所以其实Vue项目的seo体验并不是很好</li>
</ul>
<h2 id="最强王者"><a href="#最强王者" class="headerlink" title="最强王者"></a>最强王者</h2><h3 id="28-Vue响应式是怎么实现的？"><a href="#28-Vue响应式是怎么实现的？" class="headerlink" title="28. Vue响应式是怎么实现的？"></a>28. Vue响应式是怎么实现的？</h3><p>整体思路是数据劫持+观察者模式</p>
<p>对象内部通过<code>defineReactive</code> 方法，使用 <code>Object.defineProperty</code> 将属性进行劫持（只会劫持已经存在的属性），数组则是通过重写数组方法来实现。当页面使用对应属性时，每个属性都拥有自己的<code>dep</code>属性，存放他所依赖的<code>watcher</code>（依赖收集），当属性变化后会通知自己对应的<code>watcher</code> 去更新(派发更新)。</p>
<p>想详细了解过程，建议阅读我的<strong>Vue源码解析系列</strong>[4]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">const &#123; arrayMethods &#125; = require(&apos;./array&apos;)</span><br><span class="line"></span><br><span class="line">class Observer &#123;</span><br><span class="line">    constructor(value) &#123;</span><br><span class="line">        Object.defineProperty(value, &apos;__ob__&apos;, &#123;</span><br><span class="line">            value: this,</span><br><span class="line">            enumerable: false,</span><br><span class="line">            writable: true,</span><br><span class="line">            configurable: true</span><br><span class="line">        &#125;)</span><br><span class="line">        if(Array.isArray(value)) &#123;</span><br><span class="line">            value.__proto__ = arrayMethods</span><br><span class="line">            this.observeArray(value)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.walk(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    walk(data) &#123;</span><br><span class="line">        let keys = Object.keys(data)</span><br><span class="line">        for(let i = 0; i &lt; keys.length; i++) &#123;</span><br><span class="line">            const key = keys[i]</span><br><span class="line">            const value = data[key]</span><br><span class="line">            defineReactive(data, key, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    observeArray(items) &#123;</span><br><span class="line">        for(let i = 0; i &lt; items.length; i++) &#123;</span><br><span class="line">            observe(items[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function defineReactive(data, key, value) &#123;</span><br><span class="line">    const childOb = observe(value)</span><br><span class="line"></span><br><span class="line">    const dep = new Dep()</span><br><span class="line"></span><br><span class="line">    Object.defineProperty(data, key, &#123;</span><br><span class="line">        get() &#123;</span><br><span class="line">            console.log(&apos;获取值&apos;)</span><br><span class="line">            if (Dep.target) &#123;</span><br><span class="line">                dep.depend()</span><br><span class="line"></span><br><span class="line">                if (childOb) &#123;</span><br><span class="line">                    childOb.dep.depend()</span><br><span class="line"></span><br><span class="line">                    if (Array.isArray(value)) &#123;</span><br><span class="line">                        dependArray(value)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return value</span><br><span class="line">        &#125;,</span><br><span class="line">        set(newVal) &#123;</span><br><span class="line">            if (newVal === value) return</span><br><span class="line">            observe(newVal)</span><br><span class="line">            value = newVal</span><br><span class="line">            dep.notify()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function observe(value) &#123;</span><br><span class="line">    if (Object.prototype.toString.call(value) === &apos;[object Object]&apos; || Array.isArray(value)) &#123;</span><br><span class="line">        return new Observer(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function dependArray(value) &#123;</span><br><span class="line">    for(let e, i = 0, l = value.length; i &lt; l; i++) &#123;</span><br><span class="line">        e = value[i]</span><br><span class="line"></span><br><span class="line">        e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend()</span><br><span class="line"></span><br><span class="line">        if (Array.isArray(e)) &#123;</span><br><span class="line">            dependArray(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// array.js</span><br><span class="line">const arrayProto = Array.prototype</span><br><span class="line"></span><br><span class="line">const arrayMethods = Object.create(arrayProto)</span><br><span class="line"></span><br><span class="line">const methodsToPatch = [</span><br><span class="line">    &apos;push&apos;,</span><br><span class="line">    &apos;pop&apos;,</span><br><span class="line">    &apos;shift&apos;,</span><br><span class="line">    &apos;unshift&apos;,</span><br><span class="line">    &apos;splice&apos;,</span><br><span class="line">    &apos;reverse&apos;,</span><br><span class="line">    &apos;sort&apos;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">methodsToPatch.forEach(method =&gt; &#123;</span><br><span class="line">    arrayMethods[method] = function (...args) &#123;</span><br><span class="line">        const result = arrayProto[method].apply(this, args)</span><br><span class="line"></span><br><span class="line">        const ob = this.__ob__</span><br><span class="line"></span><br><span class="line">        var inserted</span><br><span class="line"></span><br><span class="line">        switch (method) &#123;</span><br><span class="line">            case &apos;push&apos;:</span><br><span class="line">            case &apos;unshift&apos;:</span><br><span class="line">                inserted = args</span><br><span class="line">                break;</span><br><span class="line">            case &apos;splice&apos;:</span><br><span class="line">                inserted = args.slice(2)</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (inserted) ob.observeArray(inserted)</span><br><span class="line"></span><br><span class="line">        ob.dep.notify()</span><br><span class="line"></span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="29-为什么只对对象劫持，而要对数组进行方法重写？"><a href="#29-为什么只对对象劫持，而要对数组进行方法重写？" class="headerlink" title="29. 为什么只对对象劫持，而要对数组进行方法重写？"></a>29. 为什么只对对象劫持，而要对数组进行方法重写？</h3><p>因为对象最多也就几十个属性，拦截起来数量不多，但是数组可能会有几百几千项，拦截起来非常耗性能，所以直接重写数组原型上的方法，是比较节省性能的方案</p>
<h3 id="30-Vue的模板编译原理？"><a href="#30-Vue的模板编译原理？" class="headerlink" title="30. Vue的模板编译原理？"></a>30. Vue的模板编译原理？</h3><p>因为这个问题讲起来可能比较长，所以：</p>
<p>建议看我这篇<strong>「Vue源码学习(二)」你不知道的-模板编译原理</strong>[5]</p>
<h3 id="31-Vue的computed和watch的原理？"><a href="#31-Vue的computed和watch的原理？" class="headerlink" title="31. Vue的computed和watch的原理？"></a>31. Vue的computed和watch的原理？</h3><p>因为这个问题讲起来可能比较长，所以：</p>
<p>建议看我这篇<strong>「Vue源码学习(四)」立志写一篇人人都看的懂的computed，watch原理</strong>[6]</p>
<h3 id="32-Vue-set方法的原理？"><a href="#32-Vue-set方法的原理？" class="headerlink" title="32. Vue.set方法的原理？"></a>32. Vue.set方法的原理？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function set(target, key, val) &#123;</span><br><span class="line">    // 判断是否是数组</span><br><span class="line">    if (Array.isArray(target)) &#123;</span><br><span class="line">        // 判断谁大谁小</span><br><span class="line">        target.length = Math.max(target.length, key)</span><br><span class="line">        // 执行splice</span><br><span class="line">        target.splice(key, 1, val)</span><br><span class="line">        return val</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const ob = target.__ob__</span><br><span class="line"></span><br><span class="line">    // 如果此对象没有不是响应式对象，直接设置并返回</span><br><span class="line">    if (key in target &amp;&amp; !(key in target.prototype) || !ob) &#123;</span><br><span class="line">        target[key] = val</span><br><span class="line">        return val</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 否则，新增属性，并响应式处理</span><br><span class="line">    defineReactive(target, key, val)</span><br><span class="line">    return val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="33-Vue-delete方法的原理？"><a href="#33-Vue-delete方法的原理？" class="headerlink" title="33. Vue.delete方法的原理？"></a>33. Vue.delete方法的原理？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function del (target, key) &#123;</span><br><span class="line">    // 判断是否为数组</span><br><span class="line">    if (Array.isArray(target)) &#123;</span><br><span class="line">        // 执行splice</span><br><span class="line">        target.splice(key, 1)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const ob = target.__ob__</span><br><span class="line"></span><br><span class="line">    // 对象本身就没有这个属性，直接返回</span><br><span class="line">    if (!(key in target)) return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 否则，删除这个属性</span><br><span class="line">    delete target[key]</span><br><span class="line"></span><br><span class="line">    // 判断是否是响应式对象，不是的话，直接返回</span><br><span class="line">    if (!ob) return</span><br><span class="line">    // 是的话，删除后要通知视图更新</span><br><span class="line">    ob.dep.notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="34-nextTick的原理？"><a href="#34-nextTick的原理？" class="headerlink" title="34. nextTick的原理？"></a>34. nextTick的原理？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">let callbacks = []; //回调函数</span><br><span class="line">let pending = false;</span><br><span class="line">function flushCallbacks() &#123;</span><br><span class="line">  pending = false; //把标志还原为false</span><br><span class="line">  // 依次执行回调</span><br><span class="line">  for (let i = 0; i &lt; callbacks.length; i++) &#123;</span><br><span class="line">    callbacks[i]( i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let timerFunc; //先采用微任务并按照优先级优雅降级的方式实现异步刷新</span><br><span class="line">if (typeof Promise !== undefined) &#123;</span><br><span class="line">  // 如果支持promise</span><br><span class="line">  const p = Promise.resolve();</span><br><span class="line">  timerFunc = () =&gt; &#123;</span><br><span class="line">    p.then(flushCallbacks);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; else if (typeof MutationObserver !== undefined) &#123;</span><br><span class="line">  // MutationObserver 主要是监听dom变化 也是一个异步方法</span><br><span class="line">  let counter = 1;</span><br><span class="line">  const observer = new MutationObserver(flushCallbacks);</span><br><span class="line">  const textNode = document.createTextNode(String(counter));</span><br><span class="line">  observer.observe(textNode, &#123;</span><br><span class="line">    characterData: true,</span><br><span class="line">  &#125;);</span><br><span class="line">  timerFunc = () =&gt; &#123;</span><br><span class="line">    counter = (counter + 1) % 2;</span><br><span class="line">    textNode.data = String(counter);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; else if (typeof setImmediate !== undefined) &#123;</span><br><span class="line">  // 如果前面都不支持 判断setImmediate</span><br><span class="line">  timerFunc = () =&gt; &#123;</span><br><span class="line">    setImmediate(flushCallbacks);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // 最后降级采用setTimeout</span><br><span class="line">  timerFunc = () =&gt; &#123;</span><br><span class="line">    setTimeout(flushCallbacks, 0);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function nextTick(cb) &#123;</span><br><span class="line">  callbacks.push(cb);</span><br><span class="line">  if (!pending) &#123;</span><br><span class="line">    pending = true;</span><br><span class="line">    timerFunc();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="冷门的知识点"><a href="#冷门的知识点" class="headerlink" title="冷门的知识点"></a>冷门的知识点</h2><h3 id="36-如果子组件改变props里的数据会发生什么"><a href="#36-如果子组件改变props里的数据会发生什么" class="headerlink" title="36. 如果子组件改变props里的数据会发生什么"></a>36. 如果子组件改变props里的数据会发生什么</h3><p>props可以修改对象的属性值，不能直接改其他类型的值</p>
<ul>
<li>改变的props数据是基本类型</li>
</ul>
<blockquote>
<p>如果修改的是基本类型，则会报错</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">    num: Number,</span><br><span class="line">  &#125;</span><br><span class="line">created() &#123;</span><br><span class="line">    this.num = 999</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/sz_mmbiz_png/gMvNo9rxo40PPicD3fczxSYXZxxV3D2ORlUNlxTKRMrIBzJ1XonRXojcVYdg8fsMpncY9eHxxYJDp6rYngeL9Rw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>0458e2ff1538ee85d42953cec9a94ca.png

<ul>
<li>改变的props数据是引用类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">    item: &#123;</span><br><span class="line">      default: () =&gt; &#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">created() &#123;</span><br><span class="line">    // 不报错，并且父级数据会跟着变</span><br><span class="line">    this.item.name = &apos;sanxin&apos;;</span><br><span class="line">    </span><br><span class="line">    // 会报错，跟基础类型报错一样</span><br><span class="line">    this.item = &apos;sss&apos;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<h3 id="37-props怎么自定义验证"><a href="#37-props怎么自定义验证" class="headerlink" title="37. props怎么自定义验证"></a>37. props怎么自定义验证</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">    num: &#123;</span><br><span class="line">      default: 1,</span><br><span class="line">      validator: function (value) &#123;</span><br><span class="line">          // 返回值为true则验证不通过，报错</span><br><span class="line">          return [</span><br><span class="line">            1, 2, 3, 4, 5</span><br><span class="line">          ].indexOf(value) !== -1</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="38-watch的immediate属性有什么用？"><a href="#38-watch的immediate属性有什么用？" class="headerlink" title="38. watch的immediate属性有什么用？"></a>38. watch的immediate属性有什么用？</h3><blockquote>
<p>比如平时created时要请求一次数据，并且当搜索值改变，也要请求数据，我们会这么写：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">created()&#123;</span><br><span class="line">  this.getList()</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">  searchInputValue()&#123;</span><br><span class="line">    this.getList()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用<code>immediate</code>完全可以这么写，当它为<code>true</code>时，会初始执行一次</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  searchInputValue:&#123;</span><br><span class="line">    handler: &apos;getList&apos;,</span><br><span class="line">    immediate: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="39-watch监听一个对象时，如何排除某些属性的监听"><a href="#39-watch监听一个对象时，如何排除某些属性的监听" class="headerlink" title="39. watch监听一个对象时，如何排除某些属性的监听"></a>39. watch监听一个对象时，如何排除某些属性的监听</h3><blockquote>
<p>下面代码是，params发生改变就重新请求数据，无论是a，b，c，d属性改变</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      params: &#123;</span><br><span class="line">        a: 1,</span><br><span class="line">        b: 2,</span><br><span class="line">        c: 3,</span><br><span class="line">        d: 4</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      deep: true,</span><br><span class="line">      handler() &#123;</span><br><span class="line">        this.getList;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是如果我只想要a，b改变时重新请求，c，d改变时不重新请求呢？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">    Object.keys(this.params)</span><br><span class="line">      .filter((_) =&gt; ![c, d].includes(_)) // 排除对c，d属性的监听</span><br><span class="line">      .forEach((_) =&gt; &#123;</span><br><span class="line">        this.$watch((vm) =&gt; vm.params[_], handler, &#123;</span><br><span class="line">          deep: true,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      params: &#123;</span><br><span class="line">        a: 1,</span><br><span class="line">        b: 2,</span><br><span class="line">        c: 3,</span><br><span class="line">        d: 4</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      deep: true,</span><br><span class="line">      handler() &#123;</span><br><span class="line">        this.getList;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>欢迎关注公众号：<code>前端印象</code>，每日精选好文推送</p>
</blockquote>
<h3 id="40-审查元素时发现data-v-xxxxx，这是啥？"><a href="#40-审查元素时发现data-v-xxxxx，这是啥？" class="headerlink" title="40. 审查元素时发现data-v-xxxxx，这是啥？"></a>40. 审查元素时发现data-v-xxxxx，这是啥？</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/sz_mmbiz_png/gMvNo9rxo40PPicD3fczxSYXZxxV3D2ORqNJn2TO6WXVPh7NTpsSY4HHffjia9A4uiceWZfablgNoqAL5Kx9Rzsdg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>image.png

<blockquote>
<p>这是在标记vue文件中css时使用scoped标记产生的，因为要保证各文件中的css不相互影响，给每个component都做了唯一的标记，所以每引入一个component就会出现一个新的’data-v-xxx’标记</p>
</blockquote>
<h3 id="41-computed如何实现传参？"><a href="#41-computed如何实现传参？" class="headerlink" title="41. computed如何实现传参？"></a>41. computed如何实现传参？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// html</span><br><span class="line">&lt;div&gt;&#123;&#123; total(3) &#125;&#125;</span><br><span class="line"></span><br><span class="line">// js</span><br><span class="line">computed: &#123;</span><br><span class="line">    total() &#123;</span><br><span class="line">      return function(n) &#123;</span><br><span class="line">          return n * this.num</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="42-vue的hook的使用"><a href="#42-vue的hook的使用" class="headerlink" title="42. vue的hook的使用"></a>42. vue的hook的使用</h3><ul>
<li>同一组件中使用</li>
</ul>
<blockquote>
<p>这是我们常用的使用定时器的方式</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export default&#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    timer:null  </span><br><span class="line">  &#125;,</span><br><span class="line">  mounted()&#123;</span><br><span class="line">      this.timer = setInterval(()=&gt;&#123;</span><br><span class="line">      //具体执行内容</span><br><span class="line">      console.log(&apos;1&apos;);</span><br><span class="line">    &#125;,1000);</span><br><span class="line">  &#125;</span><br><span class="line">  beforeDestory()&#123;</span><br><span class="line">    clearInterval(this.timer);</span><br><span class="line">    this.timer = null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面做法不好的地方在于：得全局多定义一个timer变量，可以使用hook这么做：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export default&#123;</span><br><span class="line">  methods:&#123;</span><br><span class="line">    fn()&#123;</span><br><span class="line">      const timer = setInterval(()=&gt;&#123;</span><br><span class="line">        //具体执行代码</span><br><span class="line">        console.log(&apos;1&apos;);</span><br><span class="line">      &#125;,1000);</span><br><span class="line">      this.$once(&apos;hook:beforeDestroy&apos;,()=&gt;&#123;</span><br><span class="line">        clearInterval(timer);</span><br><span class="line">        timer = null;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>7.2 父子组件使用</li>
</ul>
<blockquote>
<p>如果子组件需要在mounted时触发父组件的某一个函数，平时都会这么写：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//父组件</span><br><span class="line">&lt;rl-child @childMounted=childMountedHandle</span><br><span class="line">/&gt;</span><br><span class="line">method () &#123;</span><br><span class="line">  childMountedHandle() &#123;</span><br><span class="line">  // do something...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">mounted () &#123;</span><br><span class="line">  this.$emit(&apos;childMounted&apos;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用hook的话可以更方便：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//父组件</span><br><span class="line">&lt;rl-child @hook:mounted=childMountedHandle</span><br><span class="line">/&gt;</span><br><span class="line">method () &#123;</span><br><span class="line">  childMountedHandle() &#123;</span><br><span class="line">  // do something...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="43-provide和inject是响应式的吗？"><a href="#43-provide和inject是响应式的吗？" class="headerlink" title="43. provide和inject是响应式的吗？"></a>43. provide和inject是响应式的吗？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 祖先组件</span><br><span class="line">provide()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">   // keyName: &#123; name: this.name &#125;, // value 是对象才能实现响应式，也就是引用类型</span><br><span class="line">      keyName: this.changeValue // 通过函数的方式也可以[注意，这里是把函数作为value，而不是this.changeValue()]</span><br><span class="line">   // keyName: &apos;test&apos; value 如果是基本类型，就无法实现响应式</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">data()&#123;</span><br><span class="line">  return &#123;</span><br><span class="line"> name:&apos;张三&apos;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">   changeValue()&#123;</span><br><span class="line">    this.name = &apos;改变后的名字-李四&apos;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  // 后代组件</span><br><span class="line">  inject:[&apos;keyName&apos;]</span><br><span class="line">  create()&#123;</span><br><span class="line"> console.log(this.keyName) // 改变后的名字-李四</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="44-Vue的el属性和-mount优先级？"><a href="#44-Vue的el属性和-mount优先级？" class="headerlink" title="44.Vue的el属性和 $mount优先级？"></a>44.Vue的el属性和 $mount优先级？</h3><blockquote>
<p>比如下面这种情况，Vue会渲染到哪个节点上</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;).$mount(&apos;#ggg&apos;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这是官方的一张图，可以看出<code>el</code>和<code>$mount</code>同时存在时，<code>el优先级</code> &gt; <code>$mount</code></p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/sz_mmbiz_png/gMvNo9rxo40PPicD3fczxSYXZxxV3D2ORib744Hzu19Rsf5HIpFjAeakRVBgeMf7sic9O8hvfs8gu9JMTntut1tjQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>image.png



<h3 id="45-动态指令和参数使用过吗？"><a href="#45-动态指令和参数使用过吗？" class="headerlink" title="45. 动态指令和参数使用过吗？"></a>45. 动态指令和参数使用过吗？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;aButton @[someEvent]=handleSomeEvent() :[someProps]=1000 /&gt;...</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  ...</span><br><span class="line">  data()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">      ...</span><br><span class="line">      someEvent: someCondition ? click : dbclick,</span><br><span class="line">      someProps: someCondition ? num : price</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleSomeEvent()&#123;</span><br><span class="line">      // handle some event</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="46-相同的路由组件如何重新渲染？"><a href="#46-相同的路由组件如何重新渲染？" class="headerlink" title="46. 相同的路由组件如何重新渲染？"></a>46. 相同的路由组件如何重新渲染？</h3><blockquote>
<p>开发人员经常遇到的情况是，多个路由解析为同一个Vue组件。问题是，Vue出于性能原因，默认情况下共享组件将不会重新渲染，如果你尝试在使用相同组件的路由之间进行切换，则不会发生任何变化。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: /a,</span><br><span class="line">    component: MyComponent</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: /b,</span><br><span class="line">    component: MyComponent</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果依然想重新渲染，怎么办呢？可以使用<code>key</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;router-view :key=$route.path&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h3 id="47-自定义v-model"><a href="#47-自定义v-model" class="headerlink" title="47. 自定义v-model"></a>47. 自定义v-model</h3><blockquote>
<p>默认情况下，v-model 是 @input 事件侦听器和 :value 属性上的语法糖。但是，你可以在你的Vue组件中指定一个模型属性来定义使用什么事件和value属性——非常棒！</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export default: &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    event: &apos;change&apos;,</span><br><span class="line">    prop: &apos;checked&apos;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="48-如何将获取data中某一个数据的初始状态？"><a href="#48-如何将获取data中某一个数据的初始状态？" class="headerlink" title="48. 如何将获取data中某一个数据的初始状态？"></a>48. 如何将获取data中某一个数据的初始状态？</h3><blockquote>
<p>在开发中，有时候需要拿初始状态去计算。例如</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      num: 10</span><br><span class="line">  &#125;,</span><br><span class="line">mounted() &#123;</span><br><span class="line">    this.num = 1000</span><br><span class="line">  &#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    howMuch() &#123;</span><br><span class="line">        // 计算出num增加了多少，那就是1000 - 初始值</span><br><span class="line">        // 可以通过this.$options.data().xxx来获取初始值</span><br><span class="line">        console.log(1000 - this.$options.data().num)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="49-为什么不建议v-for和v-if同时存在"><a href="#49-为什么不建议v-for和v-if同时存在" class="headerlink" title="49.为什么不建议v-for和v-if同时存在"></a>49.为什么不建议v-for和v-if同时存在</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=item in [1, 2, 3, 4, 5, 6, 7] v-if=item !== 3&gt;</span><br><span class="line">    &#123;&#123;item&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的写法是v-for和v-if同时存在，会先把7个元素都遍历出来，然后再一个个判断是否为3，并把3给隐藏掉，这样的坏处就是，渲染了无用的3节点，增加无用的dom操作，建议使用computed来解决这个问题：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=item in list&gt;</span><br><span class="line">    &#123;&#123;item&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">computed() &#123;</span><br><span class="line">    list() &#123;</span><br><span class="line">        return [1, 2, 3, 4, 5, 6, 7].filter(item =&gt; item !== 3)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="50-计算变量时，methods和computed哪个好？"><a href="#50-计算变量时，methods和computed哪个好？" class="headerlink" title="50.计算变量时，methods和computed哪个好？"></a>50.计算变量时，methods和computed哪个好？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;howMuch1()&#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;howMuch2()&#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;index&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">         index: 0</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">methods: &#123;</span><br><span class="line">    howMuch1() &#123;</span><br><span class="line">        return this.num + this.price</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">computed() &#123;</span><br><span class="line">    howMuch2() &#123;</span><br><span class="line">        return this.num + this.price</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>computed</code>会好一些，因为computed会有<code>缓存</code>。例如index由0变成1，那么会触发视图更新，这时候methods会重新执行一次，而computed不会，因为computed依赖的两个变量num和price都没变。</p>
</blockquote>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2024-06-06T01:59:24.038Z" itemprop="dateUpdated">2024-06-06 09:59:24</time>
</span><br>


        
        感谢您的阅读，欢迎评论(*^▽^*) 转载请附上本文链接：<a href="/qw8/knowledges/vue-zhi-shi-dian.html" target="_blank" rel="external">https://qw8.github.io/qw8/knowledges/vue-zhi-shi-dian.html</a>
        
    </div>
    
    <footer>
        <a href="https://qw8.github.io/qw8">
            <img src="/qw8/img/avatar.jpg" alt="秦伟">
            秦伟
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/qw8/tags/MVVM/">MVVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/qw8/tags/vue/">vue</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://qw8.github.io/qw8/knowledges/vue-zhi-shi-dian.html&title=《vue知识点》 — 秦伟博客&pic=https://qw8.github.io/qw8/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://qw8.github.io/qw8/knowledges/vue-zhi-shi-dian.html&title=《vue知识点》 — 秦伟博客&source=前端、全栈、SEO的知识点、面试题与学习链接的整理" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://qw8.github.io/qw8/knowledges/vue-zhi-shi-dian.html" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《vue知识点》 — 秦伟博客&url=https://qw8.github.io/qw8/knowledges/vue-zhi-shi-dian.html&via=https://qw8.github.io/qw8" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://qw8.github.io/qw8/knowledges/vue-zhi-shi-dian.html" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/qw8/knowledges/vue-quan-jia-tong.html" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">vue全家桶</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/qw8/knowledges/javascript-zhi-xing-ji-zhi.html" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">JavaScript执行机制</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'false' == 'true',
            appId: "TJ17Ax10JrfIIljlO8qkwGvz-gzGzoHsz",
            appKey: "jDGQKdWT9hlzsTLRAbInE4bK",
            avatar: "mm",
            placeholder: "说点什么吧(*╹▽╹*)",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->










</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢您，我会继续努力哒(*^▽^*)
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/qw8/img/wechat.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/qw8/img/wechat.png" data-alipay="/qw8/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

    <footer class="footer">
    <div class="top">
        <div class="map">
            <!--地球信息-->
<script type="text/javascript" src="/js/jquery-3.4.1.js"></script>
<script type="text/javascript">
    var windowWidth = $(window).width();
    if (windowWidth > 480) {
        document.write('<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5mz4gy0w2d8&amp;m=0&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33" async="async">  <\/script>');
    }
</script>
        </div>
        <p>
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>

</p>
        <p>
            <span>本网站总字数：832.3k</span>
            <span id="sitetime"></span>
        </p>
        <p>部分内容来源于互联网，用于个人知识的总结，如有侵权还请联系删除</p>
        <p>
            
            <span><a href="/qw8/atom.xml" target="_blank" class="rss" title="rss"><i
                    class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>

    <div class="bottom">
        <p>
            <span>Copyright &copy; 2019 - 2024 <a
                href="http://pdouyin.com/" target="_blank">秦伟的个人博客</a> All Rights Reserved.</span>
            <!-- <span>
                
                
            </span> -->
        </p>
    </div>
</footer>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2019, 8, 25, 18, 0, 0); // 北京时间
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "已安全运行 " + diffYears + "年 " + diffDays + "天 " + diffHours + "小时 " + diffMinutes + "分钟 " + diffSeconds + "秒";
    }
    siteTime();
</script>
</main>
<div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://qw8.github.io/qw8/knowledges/vue-zhi-shi-dian.html&title=《vue知识点》 — 秦伟博客&pic=https://qw8.github.io/qw8/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://qw8.github.io/qw8/knowledges/vue-zhi-shi-dian.html&title=《vue知识点》 — 秦伟博客&source=前端、全栈、SEO的知识点、面试题与学习链接的整理" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://qw8.github.io/qw8/knowledges/vue-zhi-shi-dian.html" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《vue知识点》 — 秦伟博客&url=https://qw8.github.io/qw8/knowledges/vue-zhi-shi-dian.html&via=https://qw8.github.io/qw8" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://qw8.github.io/qw8/knowledges/vue-zhi-shi-dian.html" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACLUlEQVR42u3ay27DMAwEwP7/T6dAr85jV7ILhB6fgjR1NC6wFUX+/MTX4+969X5yHe9zfH38/MkXBgbG1zLWvv79Io5Lae+Qrw0DA+M+jPche0Xg5rzoHwAGBgZGHMHJIl49iPbxYWBgYOwEZfs+BgYGRsJItnR5SbmzTby8FsfAwPhCRtsY+M/XF/Y3MDAwvoTxOPVqIzIviT/cEwMDYzTjfanZRvD7O7SjFfXhHQYGxlBGXlImS9yJ1Hxo48k3YmBgjGa0P863emujGFEDoC1rMTAwvpzRLroN5TVYPurxpBbHwMAYx9gfsNgpWVtA0cLEwMAYxNg50M/DNy9T86bmh1ocAwNjEGNnnqEN1rwCTYIeAwPjboy1ArVdYh6v7dYTAwNjNiMPxzwE26O6to/x5J4YGBijGe1GbedAf61VmQc0BgbGVEZ+oHbF9i4nfXgHAwNjNCMfjNj55H5kF8UzBgbGUEZbcK7tQNvpj3ZEAwMD426McxsG7aFeXvRiYGBgtMNYeci2LYf6pBADA2M046yBiSS+10bB6pkRDAyMEYx2DCsJ0HM3gvXfBAMDYxDjUV77BWe73CiUMTAwRjP2ByDaZsBauCebRQwMjNmMdgAi3yye3KRcG7bAwMAYxDgr+PItZpv9Hx4uBgYGRryZW2t5tm2DehEYGBi3YSSxm7cE8mZnFNAYGBg3YKxt49Ywa82GeroNAwNjEKNtDOw0F9vmaPu7GBgY4xi/gEZ/rUen3+wAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/qw8/', SHARE: true, REWARD: true };


</script>

<script src="/qw8/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/qw8/js/search.min.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '(つェ⊂)咦!跑去哪里了';
            clearTimeout(titleTime);
        } else {
            document.title = '欢迎回来━(*｀∀´*)ノ';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>




<!-- 点击特效 -->
<script type="text/javascript" src="/js/clicklove.js"></script>
<!--动态线条背景-->
<script type="text/javascript"
        color="220,220,220" opacity='0.7' zIndex="-2" count="200"
        src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>
<!-- 雪花特效 -->
<script type="text/javascript" src="/js/jquery-3.4.1.js"></script>
<script type="text/javascript">
    var windowWidth = $(window).width();
    if (windowWidth > 480) {
        document.write('<script type="text/javascript" src="/js/snow.js"><\/script>');
    }
</script>

<script>!function(e){var r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function t(){for(var c=0;c<r.length;c++)t=r[c],void 0,0<=(n=t.getBoundingClientRect()).top&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=r[c];t=o,n=function(){r=r.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}t(),e.addEventListener("scroll",function(){!function(t,n){clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)}(t,e)})}(this);</script><script src="/qw8/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/qw8/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"position":"right","width":150,"height":300,"hOffset":-25,"vOffset":30},"mobile":{"show":false,"scale":1.2},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>

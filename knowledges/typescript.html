<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>TypeScript | 秦伟博客 | 前端、全栈、SEO的知识点、面试题与学习链接的整理</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="TypeScript">
    <meta name="description" content="什么是Typescript？Typescript是强类型的Javascript超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript并不直接在浏览器上运行，需要编译器编译成纯Javascript来运行。 说说Typescripy和Javascript的区别？">
<meta name="keywords" content="TypeScript">
<meta property="og:type" content="article">
<meta property="og:title" content="TypeScript">
<meta property="og:url" content="https://qw66.gitee.io/knowledges/typescript.html">
<meta property="og:site_name" content="秦伟博客">
<meta property="og:description" content="什么是Typescript？Typescript是强类型的Javascript超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript并不直接在浏览器上运行，需要编译器编译成纯Javascript来运行。 说说Typescripy和Javascript的区别？">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://qw66.gitee.io/img/loading.gif">
<meta property="og:image" content="https://qw66.gitee.io/img/loading.gif">
<meta property="og:image" content="https://qw66.gitee.io/img/loading.gif">
<meta property="og:image" content="https://qw66.gitee.io/img/loading.gif">
<meta property="og:image" content="https://qw66.gitee.io/img/loading.gif">
<meta property="og:image" content="https://qw66.gitee.io/img/loading.gif">
<meta property="og:image" content="https://qw66.gitee.io/img/loading.gif">
<meta property="og:updated_time" content="2023-04-14T17:01:50.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TypeScript">
<meta name="twitter:description" content="什么是Typescript？Typescript是强类型的Javascript超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript并不直接在浏览器上运行，需要编译器编译成纯Javascript来运行。 说说Typescripy和Javascript的区别？">
<meta name="twitter:image" content="https://qw66.gitee.io/img/loading.gif">
    
        <link rel="alternate" type="application/atom+xml" title="秦伟博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/qw.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
<div id="loading" class="active"></div>

<aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">秦伟</h5>
          <a href="mailto:124729081@qq.com" title="124729081@qq.com" class="mail">124729081@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-hourglass"></i>
                时光
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://wpa.qq.com/msgrd?v=3&uin=124729081&site=qq&menu=yes" target="_blank" >
                <i class="icon icon-lg icon-qq"></i>
                聊天
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=124729081@qq.com"  >
                <i class="icon icon-lg icon-envelope-o"></i>
                邮箱
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/user"  >
                <i class="icon icon-lg icon-user"></i>
                简介
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://gitee.com/qw66" target="_blank" >
                <i class="icon icon-lg icon-code"></i>
                Gitee
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/qw8" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

<main id="main">
    <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">TypeScript</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">TypeScript</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-10-12T11:25:55.000Z" itemprop="datePublished" class="page-time">
  2019-10-12
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/前端知识点/">前端知识点</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是Typescript？"><span class="post-toc-number">1.</span> <span class="post-toc-text">什么是Typescript？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#说说Typescripy和Javascript的区别？"><span class="post-toc-number">2.</span> <span class="post-toc-text">说说Typescripy和Javascript的区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#说说Typescript的优缺点？"><span class="post-toc-number">3.</span> <span class="post-toc-text">说说Typescript的优缺点？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Typescript有哪些基础类型？"><span class="post-toc-number">4.</span> <span class="post-toc-text">Typescript有哪些基础类型？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何编译Typescript"><span class="post-toc-number">5.</span> <span class="post-toc-text">如何编译Typescript?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何将多个ts文件合并成一个js文件？"><span class="post-toc-number">6.</span> <span class="post-toc-text">如何将多个ts文件合并成一个js文件？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何自动编译ts文件并实时修改？"><span class="post-toc-number">7.</span> <span class="post-toc-text">如何自动编译ts文件并实时修改？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#typescript-遇到过什么坑"><span class="post-toc-number">8.</span> <span class="post-toc-text">typescript 遇到过什么坑</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是TS接口？说说它有哪些特性？"><span class="post-toc-number">9.</span> <span class="post-toc-text">什么是TS接口？说说它有哪些特性？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何理解Typescript中的类？并说说它有什么特性？"><span class="post-toc-number">10.</span> <span class="post-toc-text">如何理解Typescript中的类？并说说它有什么特性？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Typescript支持哪些面向对象术语？"><span class="post-toc-number">11.</span> <span class="post-toc-text">Typescript支持哪些面向对象术语？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何调用基类中的构造函数？"><span class="post-toc-number">12.</span> <span class="post-toc-text">如何调用基类中的构造函数？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何实现类的继承？"><span class="post-toc-number">13.</span> <span class="post-toc-text">如何实现类的继承？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Typescript中的模块是什么？"><span class="post-toc-number">14.</span> <span class="post-toc-text">Typescript中的模块是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#解释下Typescript的装饰器是什么？"><span class="post-toc-number">15.</span> <span class="post-toc-text">解释下Typescript的装饰器是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是Mixins"><span class="post-toc-number">16.</span> <span class="post-toc-text">什么是Mixins?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TSD是什么？"><span class="post-toc-number">17.</span> <span class="post-toc-text">TSD是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Declare关键字是干嘛用的？"><span class="post-toc-number">18.</span> <span class="post-toc-text">Declare关键字是干嘛用的？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何让-ts文件自动生成对应的-d-ts声明文件？"><span class="post-toc-number">19.</span> <span class="post-toc-text">如何让.ts文件自动生成对应的.d.ts声明文件？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#tsconfig-json文件有什么作用？"><span class="post-toc-number">20.</span> <span class="post-toc-text">tsconfig.json文件有什么作用？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#说说什么Typescript中的泛型？作用是什么？"><span class="post-toc-number">21.</span> <span class="post-toc-text">说说什么Typescript中的泛型？作用是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#说说接口和类型别名type的区别？"><span class="post-toc-number">22.</span> <span class="post-toc-text">说说接口和类型别名type的区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是Typescript映射文件？"><span class="post-toc-number">23.</span> <span class="post-toc-text">什么是Typescript映射文件？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是类型断言？"><span class="post-toc-number">24.</span> <span class="post-toc-text">什么是类型断言？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是Rest参数？"><span class="post-toc-number">25.</span> <span class="post-toc-text">什么是Rest参数？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是枚举？"><span class="post-toc-number">26.</span> <span class="post-toc-text">什么是枚举？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#说说TS的模块解析策略，什么是相对导入？什么是非相对导入？"><span class="post-toc-number">27.</span> <span class="post-toc-text">说说TS的模块解析策略，什么是相对导入？什么是非相对导入？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是声明合并？"><span class="post-toc-number">28.</span> <span class="post-toc-text">什么是声明合并？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是Typescript"><span class="post-toc-number">29.</span> <span class="post-toc-text">什么是Typescript?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TypeScript和JavaScript有什么不同？"><span class="post-toc-number">30.</span> <span class="post-toc-text">TypeScript和JavaScript有什么不同？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#我们为什么需要TypeScript？"><span class="post-toc-number">31.</span> <span class="post-toc-text">我们为什么需要TypeScript？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#列出Typescript的一些特性"><span class="post-toc-number">32.</span> <span class="post-toc-text">列出Typescript的一些特性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#列出使用Typescript的一些优点"><span class="post-toc-number">33.</span> <span class="post-toc-text">列出使用Typescript的一些优点?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Typescript的缺点是什么"><span class="post-toc-number">34.</span> <span class="post-toc-text">Typescript的缺点是什么?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TypeScript的不同组件是什么"><span class="post-toc-number">35.</span> <span class="post-toc-text">TypeScript的不同组件是什么?</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#语言language"><span class="post-toc-number">35.1.</span> <span class="post-toc-text">语言language</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#编译器compiler"><span class="post-toc-number">35.2.</span> <span class="post-toc-text">编译器compiler</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#语言服务language-service"><span class="post-toc-number">35.3.</span> <span class="post-toc-text">语言服务language service</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Typescript是谁开发的，目前稳定的Typescript版本是什么？"><span class="post-toc-number">36.</span> <span class="post-toc-text">Typescript是谁开发的，目前稳定的Typescript版本是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#说说安装Typescript的最低要求。或者我们如何获得TypeScript并安装它？"><span class="post-toc-number">37.</span> <span class="post-toc-text">说说安装Typescript的最低要求。或者我们如何获得TypeScript并安装它？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#列出在Typescript中的内置类型"><span class="post-toc-number">38.</span> <span class="post-toc-text">列出在Typescript中的内置类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Typescript中的变量是什么？如何在Typescript中创建变量？"><span class="post-toc-number">39.</span> <span class="post-toc-text">Typescript中的变量是什么？如何在Typescript中创建变量？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何编译Typescript文件？"><span class="post-toc-number">40.</span> <span class="post-toc-text">如何编译Typescript文件？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#是否可以将多个-ts文件合并成一个-js文件？如果是，那么如何做？"><span class="post-toc-number">41.</span> <span class="post-toc-text">是否可以将多个.ts文件合并成一个.js文件？如果是，那么如何做？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#能否自动编译-ts文件，并实时修改-ts文件？"><span class="post-toc-number">42.</span> <span class="post-toc-text">能否自动编译.ts文件，并实时修改.ts文件？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TS的接口是什么意思？参照TS来解释它们。"><span class="post-toc-number">43.</span> <span class="post-toc-text">TS的接口是什么意思？参照TS来解释它们。</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#你如何理解Typescript中的类？列出类的一些特性。"><span class="post-toc-number">44.</span> <span class="post-toc-text">你如何理解Typescript中的类？列出类的一些特性。</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#本地Javascript支持模块吗？"><span class="post-toc-number">45.</span> <span class="post-toc-text">本地Javascript支持模块吗？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TypeScript支持哪些面向对象的术语？"><span class="post-toc-number">46.</span> <span class="post-toc-text">TypeScript支持哪些面向对象的术语？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何从TypeScript的子类调用基类构造函数？"><span class="post-toc-number">47.</span> <span class="post-toc-text">如何从TypeScript的子类调用基类构造函数？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何在TypeScript中实现继承？"><span class="post-toc-number">48.</span> <span class="post-toc-text">如何在TypeScript中实现继承？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Typescript中的模块是什么？-1"><span class="post-toc-number">49.</span> <span class="post-toc-text">Typescript中的模块是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#内部模块和外部模块有什么区别？"><span class="post-toc-number">50.</span> <span class="post-toc-text">内部模块和外部模块有什么区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Typescript中的名称空间是什么？如何在Typescript中声明名称空间？"><span class="post-toc-number">51.</span> <span class="post-toc-text">Typescript中的名称空间是什么？如何在Typescript中声明名称空间？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#解释在TypeScript中的装饰器？"><span class="post-toc-number">52.</span> <span class="post-toc-text">解释在TypeScript中的装饰器？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是混合mixin？"><span class="post-toc-number">53.</span> <span class="post-toc-text">什么是混合mixin？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TypeScript类中属性-方法的默认可见性是什么？"><span class="post-toc-number">54.</span> <span class="post-toc-text">TypeScript类中属性/方法的默认可见性是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TypeScript是如何在函数中支持可选参数的？"><span class="post-toc-number">55.</span> <span class="post-toc-text">TypeScript是如何在函数中支持可选参数的？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JavaScript不支持函数重载，但TypeScript是否支持函数重载？"><span class="post-toc-number">56.</span> <span class="post-toc-text">JavaScript不支持函数重载，但TypeScript是否支持函数重载？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#可以调试任何TypeScript文件吗？"><span class="post-toc-number">57.</span> <span class="post-toc-text">可以调试任何TypeScript文件吗？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是TypeScript定义管理器？为什么我们需要它？"><span class="post-toc-number">58.</span> <span class="post-toc-text">什么是TypeScript定义管理器？为什么我们需要它？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是TypeScript-Declare关键字"><span class="post-toc-number">59.</span> <span class="post-toc-text">什么是TypeScript Declare关键字?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何从任何-ts文件生成TypeScript定义文件"><span class="post-toc-number">60.</span> <span class="post-toc-text">如何从任何.ts文件生成TypeScript定义文件?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是tsconfig-son文件吗？"><span class="post-toc-number">61.</span> <span class="post-toc-text">什么是tsconfig.son文件吗？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#解释TypeScript中的泛型？"><span class="post-toc-number">62.</span> <span class="post-toc-text">解释TypeScript中的泛型？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TypeScript是否支持所有面向对象的原则？"><span class="post-toc-number">63.</span> <span class="post-toc-text">TypeScript是否支持所有面向对象的原则？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何检查TypeScript中的null和undefined-？"><span class="post-toc-number">64.</span> <span class="post-toc-text">如何检查TypeScript中的null和undefined ？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#我们可以在后端使用TypeScript吗？如果可以，如何使用？"><span class="post-toc-number">65.</span> <span class="post-toc-text">我们可以在后端使用TypeScript吗？如果可以，如何使用？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TS的“接口”和“type”语句有什么区别？"><span class="post-toc-number">66.</span> <span class="post-toc-text">TS的“接口”和“type”语句有什么区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TypeScript中的环境是什么？何时使用它？"><span class="post-toc-number">67.</span> <span class="post-toc-text">TypeScript中的环境是什么？何时使用它？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是TypeScript映射文件？"><span class="post-toc-number">68.</span> <span class="post-toc-text">什么是TypeScript映射文件？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是TypeScript中的类型断言？"><span class="post-toc-number">69.</span> <span class="post-toc-text">什么是TypeScript中的类型断言？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TypeScript的as语法是什么？"><span class="post-toc-number">70.</span> <span class="post-toc-text">TypeScript的as语法是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是JSX？我们可以在TypeScript中使用JSX吗？"><span class="post-toc-number">71.</span> <span class="post-toc-text">什么是JSX？我们可以在TypeScript中使用JSX吗？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是Rest参数？-1"><span class="post-toc-number">72.</span> <span class="post-toc-text">什么是Rest参数？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#解释TypeScript的Enum枚举类型？"><span class="post-toc-number">73.</span> <span class="post-toc-text">解释TypeScript的Enum枚举类型？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#解释相对模块和非相对模块的导入"><span class="post-toc-number">74.</span> <span class="post-toc-text">解释相对模块和非相对模块的导入</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是匿名函数？"><span class="post-toc-number">75.</span> <span class="post-toc-text">什么是匿名函数？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是声明合并？-1"><span class="post-toc-number">76.</span> <span class="post-toc-text">什么是声明合并？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TypeScript中的方法重写是什么"><span class="post-toc-number">77.</span> <span class="post-toc-text">TypeScript中的方法重写是什么?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Lambda-箭头函数是什么？"><span class="post-toc-number">78.</span> <span class="post-toc-text">Lambda/箭头函数是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TypeScript-的主要特点是什么？"><span class="post-toc-number">79.</span> <span class="post-toc-text">TypeScript 的主要特点是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用-TypeScript-有什么好处？"><span class="post-toc-number">80.</span> <span class="post-toc-text">使用 TypeScript 有什么好处？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TypeScript-的内置数据类型有哪些？"><span class="post-toc-number">81.</span> <span class="post-toc-text">TypeScript 的内置数据类型有哪些？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TypeScript-目前的稳定版本是什么？"><span class="post-toc-number">82.</span> <span class="post-toc-text">TypeScript 目前的稳定版本是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TypeScript-中的接口是什么？"><span class="post-toc-number">83.</span> <span class="post-toc-text">TypeScript 中的接口是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TypeScript-中的模块是什么？"><span class="post-toc-number">84.</span> <span class="post-toc-text">TypeScript 中的模块是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#后端如何使用TypeScript？"><span class="post-toc-number">85.</span> <span class="post-toc-text">后端如何使用TypeScript？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TypeScript-中的类型断言是什么？"><span class="post-toc-number">86.</span> <span class="post-toc-text">TypeScript 中的类型断言是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何在-TypeScript-中创建变量？"><span class="post-toc-number">87.</span> <span class="post-toc-text">如何在 TypeScript 中创建变量？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#在TypeScript中如何从子类调用基类构造函数？"><span class="post-toc-number">88.</span> <span class="post-toc-text">在TypeScript中如何从子类调用基类构造函数？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#解释如何使用-TypeScript-mixin"><span class="post-toc-number">89.</span> <span class="post-toc-text">解释如何使用 TypeScript mixin</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TypeScript-中如何检查-null-和-undefined？"><span class="post-toc-number">90.</span> <span class="post-toc-text">TypeScript 中如何检查 null 和 undefined？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TypeScript-中的-getter-setter-是什么？你如何使用它们？"><span class="post-toc-number">91.</span> <span class="post-toc-text">TypeScript 中的 getter/setter 是什么？你如何使用它们？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何允许模块外定义的类可以访问？"><span class="post-toc-number">92.</span> <span class="post-toc-text">如何允许模块外定义的类可以访问？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何使用-Typescript-将字符串转换为数字？"><span class="post-toc-number">93.</span> <span class="post-toc-text">如何使用 Typescript 将字符串转换为数字？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是-map-文件，为什么-如何使用它？"><span class="post-toc-number">94.</span> <span class="post-toc-text">什么是 .map 文件，为什么/如何使用它？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TypeScript-中的类是什么？你如何定义它们？"><span class="post-toc-number">95.</span> <span class="post-toc-text">TypeScript 中的类是什么？你如何定义它们？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TypeScript-与-JavaScript-有什么关系？"><span class="post-toc-number">96.</span> <span class="post-toc-text">TypeScript 与 JavaScript 有什么关系？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TypeScript-中的-JSX-是什么？"><span class="post-toc-number">97.</span> <span class="post-toc-text">TypeScript 中的 JSX 是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TypeScript-支持哪些-JSX-模式？"><span class="post-toc-number">98.</span> <span class="post-toc-text">TypeScript 支持哪些 JSX 模式？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何编译-TypeScript-文件？"><span class="post-toc-number">99.</span> <span class="post-toc-text">如何编译 TypeScript 文件？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TypeScript-中有哪些范围可用？这与JS相比如何？"><span class="post-toc-number">100.</span> <span class="post-toc-text">TypeScript 中有哪些范围可用？这与JS相比如何？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TypeScript-中的箭头-lambda-函数是什么？"><span class="post-toc-number">101.</span> <span class="post-toc-text">TypeScript 中的箭头/lambda 函数是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#解释rest参数和声明rest参数的规则。"><span class="post-toc-number">102.</span> <span class="post-toc-text">解释rest参数和声明rest参数的规则。</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是三斜线指令？有哪些三斜杠指令？"><span class="post-toc-number">103.</span> <span class="post-toc-text">什么是三斜线指令？有哪些三斜杠指令？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Omit类型有什么作用？"><span class="post-toc-number">104.</span> <span class="post-toc-text">Omit类型有什么作用？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TypeScript中如何实现函数重载？"><span class="post-toc-number">105.</span> <span class="post-toc-text">TypeScript中如何实现函数重载？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何让接口的所有属性都可选？"><span class="post-toc-number">106.</span> <span class="post-toc-text">如何让接口的所有属性都可选？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么时候应该使用关键字unknown？"><span class="post-toc-number">107.</span> <span class="post-toc-text">什么时候应该使用关键字unknown？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是装饰器，它们可以应用于什么？"><span class="post-toc-number">108.</span> <span class="post-toc-text">什么是装饰器，它们可以应用于什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ts中type和interface的区别？"><span class="post-toc-number">109.</span> <span class="post-toc-text">ts中type和interface的区别？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#相同点："><span class="post-toc-number">109.1.</span> <span class="post-toc-text">相同点：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#不同点："><span class="post-toc-number">109.2.</span> <span class="post-toc-text">不同点：</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ts中interface和class的区别-分别什么时候使用？"><span class="post-toc-number">110.</span> <span class="post-toc-text">ts中interface和class的区别? 分别什么时候使用？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ts中的泛型有什么了解？"><span class="post-toc-number">111.</span> <span class="post-toc-text">ts中的泛型有什么了解？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#不用泛型的话，这个函数可能是下面这样："><span class="post-toc-number">111.1.</span> <span class="post-toc-text">不用泛型的话，这个函数可能是下面这样：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#泛型的使用方法有两种："><span class="post-toc-number">111.2.</span> <span class="post-toc-text">泛型的使用方法有两种：</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#typescript-基础类型"><span class="post-toc-number">112.</span> <span class="post-toc-text">typescript 基础类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#type与interface-的区别"><span class="post-toc-number">113.</span> <span class="post-toc-text">type与interface 的区别</span></a></li></ol>
        </nav>
    </aside>


<article id="post-knowledges/TypeScript"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">TypeScript</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-10-12 19:25:55" datetime="2019-10-12T11:25:55.000Z"  itemprop="datePublished">2019-10-12</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/前端知识点/">前端知识点</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h3 id="什么是Typescript？"><a href="#什么是Typescript？" class="headerlink" title="什么是Typescript？"></a>什么是Typescript？</h3><p>Typescript是<strong>强类型的Javascript超集</strong>，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript并不直接在浏览器上运行，需要编译器编译成纯Javascript来运行。</p>
<h3 id="说说Typescripy和Javascript的区别？"><a href="#说说Typescripy和Javascript的区别？" class="headerlink" title="说说Typescripy和Javascript的区别？"></a>说说Typescripy和Javascript的区别？</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https:////upload-images.jianshu.io/upload_images/16021827-9f2935d0f3da0cf7.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<h3 id="说说Typescript的优缺点？"><a href="#说说Typescript的优缺点？" class="headerlink" title="说说Typescript的优缺点？"></a>说说Typescript的优缺点？</h3><p><strong>优点：</strong></p>
<p>1：快速简单，易于学习。</p>
<p>2：编译时提供错误检查， 在代码运行前就会进行错误提示。</p>
<p>3：支持所有的JS库。</p>
<p>4：支持ES6，提供了ES6所有优点和更高的生产力。</p>
<p>5：使用继承提供可重用性。</p>
<p>6：有助于代码结构。</p>
<p>7：通过定义模块来定义命名空间。</p>
<p><strong>缺点：</strong></p>
<p>1：需要长时间的来编译代码。</p>
<p>2：在使用第三方库时，需要有三方库的定义文件，并不是所有三方库都提供了定义文件，提供的定义文件是否准确也值得商榷。</p>
<h3 id="Typescript有哪些基础类型？"><a href="#Typescript有哪些基础类型？" class="headerlink" title="Typescript有哪些基础类型？"></a>Typescript有哪些基础类型？</h3><p>1：number</p>
<p>2：string</p>
<p>3：boolean</p>
<p>4：Symbol</p>
<p>5：Array</p>
<p>6：Tuple(元组)</p>
<p>7：enum(枚举)</p>
<p>8：object</p>
<p>9：never</p>
<p>表示那些永不存在的值类型。如总是抛出异常或者根本不会有返回值的函数的返回值类型。</p>
<p>10：void</p>
<p>与any相反表示没有任何类型。函数没有返回值时用void。</p>
<p>11：null和undefined</p>
<p>它们是所有类型的子类型。当你指定structNullChecks时，它们只能赋值给void或者它们自己本身。</p>
<p>12：any</p>
<h3 id="如何编译Typescript"><a href="#如何编译Typescript" class="headerlink" title="如何编译Typescript?"></a>如何编译Typescript?</h3><p>tsc xxx.ts</p>
<h3 id="如何将多个ts文件合并成一个js文件？"><a href="#如何将多个ts文件合并成一个js文件？" class="headerlink" title="如何将多个ts文件合并成一个js文件？"></a>如何将多个ts文件合并成一个js文件？</h3><p>tsc –outfile compact.js file1.ts file2.ts file3.js</p>
<h3 id="如何自动编译ts文件并实时修改？"><a href="#如何自动编译ts文件并实时修改？" class="headerlink" title="如何自动编译ts文件并实时修改？"></a>如何自动编译ts文件并实时修改？</h3><p>tsc –watch file.ts</p>
<h3 id="typescript-遇到过什么坑"><a href="#typescript-遇到过什么坑" class="headerlink" title="typescript 遇到过什么坑"></a>typescript 遇到过什么坑</h3><p>main.ts 报错（ Cannot find module ‘./App.vue’.）</p>
<p>原因： typescript 不能识别.vue 文件</p>
<p>解决办法： 引入 vue 的 typescript declare 库</p>
<h3 id="什么是TS接口？说说它有哪些特性？"><a href="#什么是TS接口？说说它有哪些特性？" class="headerlink" title="什么是TS接口？说说它有哪些特性？"></a>什么是TS接口？说说它有哪些特性？</h3><p>TS的核心原则之一就是<strong>对值所具有的结构进行类型检查</strong>。</p>
<p>它有时被称为“鸭式辩型法”或“结构性子类型化”。</p>
<p>其作用就是为这些类型进行命名，或为你的代码或者三方代码定义契约。</p>
<p><strong>特点：</strong></p>
<p>1：定义对象、数组、函数、类等。</p>
<p>2：接口可以相互继承</p>
<p>3：接口可以继承类</p>
<p>4：可选属性与额外检查</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https:////upload-images.jianshu.io/upload_images/16021827-bb884c0a4ffaf55d.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/960/format/webp" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>



<h3 id="如何理解Typescript中的类？并说说它有什么特性？"><a href="#如何理解Typescript中的类？并说说它有什么特性？" class="headerlink" title="如何理解Typescript中的类？并说说它有什么特性？"></a>如何理解Typescript中的类？并说说它有什么特性？</h3><p>Typescript是一种面向对象的Javascript语言，和其他任何面向对象编程的强语言一样，<strong>类是描述某一组对象共有属性状态或行为的实体</strong>。它就是构建具体对象实例的模板和蓝图。</p>
<p><strong>特性：</strong></p>
<p>1：继承</p>
<p>2：多态</p>
<p>3：抽象</p>
<p>4：封装</p>
<p>5：实例</p>
<h3 id="Typescript支持哪些面向对象术语？"><a href="#Typescript支持哪些面向对象术语？" class="headerlink" title="Typescript支持哪些面向对象术语？"></a>Typescript支持哪些面向对象术语？</h3><p>1：类</p>
<p>2：继承</p>
<p>3：多态</p>
<p>4：抽象</p>
<p>5：泛化</p>
<p>6：接口封装</p>
<p>7：实例化</p>
<p>等等…</p>
<h3 id="如何调用基类中的构造函数？"><a href="#如何调用基类中的构造函数？" class="headerlink" title="如何调用基类中的构造函数？"></a>如何调用基类中的构造函数？</h3><p>super()</p>
<h3 id="如何实现类的继承？"><a href="#如何实现类的继承？" class="headerlink" title="如何实现类的继承？"></a>如何实现类的继承？</h3><p>extends</p>
<h3 id="Typescript中的模块是什么？"><a href="#Typescript中的模块是什么？" class="headerlink" title="Typescript中的模块是什么？"></a>Typescript中的模块是什么？</h3><p>Typescript1.5后为了与ES6术语保持一致，内部模块都称为<strong>命名空间</strong>，外部模块简称<strong>模块</strong>。</p>
<p>模块在自身的作用域里执行，并不是全局作用域。这就意味着模块类的类、函数、对象等对外都是不可见的。除非你通过export导出，import导入。</p>
<p>模块通过使用模块加载器导入另一个模块。在运行时，模块加载器负责在执行模块之前定位和执行模块的所有依赖项。JavaScript中最常用的模块加载器是用于Node.js的CommonJS模块加载器和用于Web应用程序的require.js模块加载器。</p>
<p><strong>特别说明：</strong></p>
<p>为了支持CommonJS和AMD语法中的exports，TS提供了export = 语法，引入方式为import xxx = require(“xxx”)；</p>
<h3 id="解释下Typescript的装饰器是什么？"><a href="#解释下Typescript的装饰器是什么？" class="headerlink" title="解释下Typescript的装饰器是什么？"></a>解释下Typescript的装饰器是什么？</h3><p>装饰器是一种特殊类型的声明，它能被附加在类、方法、属性、访问符、参数上。</p>
<p>装饰器使用@expression这种方式，expression求值后必须为一个函数，它在运行时调用，被装饰器声明的信息作为参数传入。</p>
<h3 id="什么是Mixins"><a href="#什么是Mixins" class="headerlink" title="什么是Mixins?"></a>什么是Mixins?</h3><p>一种通过重用组件构建类的方法。</p>
<p>不通过类的直接继承来实现，而是将基类作为接口来实现。对于基类实例化部分在子类中实现，基类中原型的部分在子类中进行声明占位，然后通过一个Minxin函数将基类上的原型属性拷贝到子类上。</p>
<h3 id="TSD是什么？"><a href="#TSD是什么？" class="headerlink" title="TSD是什么？"></a>TSD是什么？</h3><p>TSD是Typescript的包管理工具，我们都知道在.ts文件中引入第三方库时，第三库是需要.d.ts声明文件的，否则三方库在.ts中是无法识别报错的。</p>
<p>TSD就是帮我查找对应的三方库TS声明文件并下载安装。</p>
<p>使用过程如下：</p>
<p>1：npm install tsd -g</p>
<p>2: tsd init</p>
<p>3: tsd query xxx三方库 –action install</p>
<p>4：在使用的.ts文件中通过reference指向该声明文件</p>
<p>/// <reference path="typings/jquery/jquery.d.ts"></reference></p>
<h3 id="Declare关键字是干嘛用的？"><a href="#Declare关键字是干嘛用的？" class="headerlink" title="Declare关键字是干嘛用的？"></a>Declare关键字是干嘛用的？</h3><p>我们在.ts中使用的第三方库时没有.d.ts声明文件的时候，我们可以通过declare来写申明文件。</p>
<p>可以声明该模块，甚至可以直接声明一个值为any的同名的变量，然后我们就可以在代码中直接使用该三方库了。</p>
<h3 id="如何让-ts文件自动生成对应的-d-ts声明文件？"><a href="#如何让-ts文件自动生成对应的-d-ts声明文件？" class="headerlink" title="如何让.ts文件自动生成对应的.d.ts声明文件？"></a>如何让.ts文件自动生成对应的.d.ts声明文件？</h3><p>tsc –declaration test.ts</p>
<h3 id="tsconfig-json文件有什么作用？"><a href="#tsconfig-json文件有什么作用？" class="headerlink" title="tsconfig.json文件有什么作用？"></a>tsconfig.json文件有什么作用？</h3><p>该文件存在于Typescript项目的根目录里，其作用是指定相关选项告诉ts编译器如何编译ts文件。</p>
<h3 id="说说什么Typescript中的泛型？作用是什么？"><a href="#说说什么Typescript中的泛型？作用是什么？" class="headerlink" title="说说什么Typescript中的泛型？作用是什么？"></a>说说什么Typescript中的泛型？作用是什么？</h3><p>泛型代表的是泛指某一类型，更像是一个类型变量。由尖括号包裹<t>。</t></p>
<p>主要作用是<strong>创建逻辑可复用的组件</strong>。</p>
<p>泛型可以作用在函数、类、接口上。</p>
<p>函数：</p>
<p>function greet<t>(name: T) {}</t></p>
<p>类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class createObj&lt;T&gt; &#123;</span><br><span class="line">  name: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface IF&lt;T&gt; &#123;</span><br><span class="line">  name: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型还可以被约束，这样就是任意类型了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface TIF &#123;</span><br><span class="line">  length: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function test&lt;T extends TIF&gt;(params: T) &#123;</span><br><span class="line">  console.log(&quot;=========&gt;&gt;&gt;&quot;, params.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型约束之类型参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getPropoty&lt;T, K extends keyof T&gt;(obj: T, key: K) &#123;</span><br><span class="line">  return obj[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="说说接口和类型别名type的区别？"><a href="#说说接口和类型别名type的区别？" class="headerlink" title="说说接口和类型别名type的区别？"></a>说说接口和类型别名type的区别？</h3><p>他们很相似，type可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。</p>
<p>区别一：它并不会真的创建一个新的名字，当你在编译器上将鼠标悬停在定义为该类型别名定义的变量上时返回的是该类型别名引用的对象。相反，接口会创建一个新名字 ，当你把鼠标悬停在该接口定义的变量上时返回的是该接口名。</p>
<p>区别二：类型别名不能extends和implements</p>
<p>区别三：对于元组，联合类型我们一般使用类型别名type。</p>
<h3 id="什么是Typescript映射文件？"><a href="#什么是Typescript映射文件？" class="headerlink" title="什么是Typescript映射文件？"></a>什么是Typescript映射文件？</h3><p>.map源映射文件</p>
<p>它是编译后的.js与源文件之间的映射文件。调试器使用该文件，使我们可以直接调试Typescript文件而不是编译后的JS文件。</p>
<h3 id="什么是类型断言？"><a href="#什么是类型断言？" class="headerlink" title="什么是类型断言？"></a>什么是类型断言？</h3><p>类型断言对运行没有什么影响，仅供编译器使用。</p>
<p>向编译器提供我们所希望的分析代码的提示。</p>
<p>表示断言的两种方式：</p>
<p>1：&lt;类型&gt;变量</p>
<p>2：变量 as 类型 （在tsx中只能使用这种方式）</p>
<h3 id="什么是Rest参数？"><a href="#什么是Rest参数？" class="headerlink" title="什么是Rest参数？"></a>什么是Rest参数？</h3><p>在不使用arguments对象的情况允许我们的函数传递可变数量的参数的另一种实现方式。</p>
<p>表示方式是…params。</p>
<p><strong>rest参数的规则是：</strong></p>
<p>1：一个函数只能有一个rest参数。</p>
<p>2：它只能出现在参数列表的最后一个。</p>
<p>3：该参数必须是数组类型。</p>
<h3 id="什么是枚举？"><a href="#什么是枚举？" class="headerlink" title="什么是枚举？"></a>什么是枚举？</h3><p>枚举可以使我们定义一些带名字的常量，用于清晰的表达意图和创建一组有区别的用例。</p>
<p>枚举主要分为两类。一类是基于数字的，有自增长和反向映射的特性。一类是基于字符串的。</p>
<p>当然还有混合了这两种基础类型的枚举，我们叫做异构枚举。</p>
<h3 id="说说TS的模块解析策略，什么是相对导入？什么是非相对导入？"><a href="#说说TS的模块解析策略，什么是相对导入？什么是非相对导入？" class="headerlink" title="说说TS的模块解析策略，什么是相对导入？什么是非相对导入？"></a>说说TS的模块解析策略，什么是相对导入？什么是非相对导入？</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https:////upload-images.jianshu.io/upload_images/16021827-a213202c03d84f74.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https:////upload-images.jianshu.io/upload_images/16021827-d7eb37c8503111ee.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>可以通过moduleResolution属性来设置解析模式。</p>
<h3 id="什么是声明合并？"><a href="#什么是声明合并？" class="headerlink" title="什么是声明合并？"></a>什么是声明合并？</h3><p>声明合并是编译器将2个或多个同名声明合并为一个，合并后的声明拥有被合并声明的所有特性。</p>
<p>目前除了类不能与其他类和变量合并外，其他声明都是可以相互合并的。</p>
<h3 id="什么是Typescript"><a href="#什么是Typescript" class="headerlink" title="什么是Typescript?"></a>什么是Typescript?</h3><p>TypeScript是一种由微软开发和维护的免费开源编程语言。它是一个强类型的JavaScript超集，可编译为纯JavaScript。它是一种用于应用级JavaScript开发的语言。对于熟悉c#、Java和所有强类型语言的开发人员来说，TypeScript非常容易学习和使用。</p>
<p>TypeScript可以在任何浏览器、主机和操作系统上执行。TypeScript不是直接在浏览器上运行的。它需要一个编译器来编译和生成JavaScript文件。TypeScript是带有一些附加特性的ES6 JavaScript版本。</p>
<h3 id="TypeScript和JavaScript有什么不同？"><a href="#TypeScript和JavaScript有什么不同？" class="headerlink" title="TypeScript和JavaScript有什么不同？"></a>TypeScript和JavaScript有什么不同？</h3><p>TypeScript与JavaScript的区别如下:</p>
<table>
<thead>
<tr>
<th><strong>编号</strong></th>
<th><strong>JavaScript</strong></th>
<th><strong>TypeScript</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>它是由网景公司在1995年开发的。</td>
<td>它是2012年由安德斯·海尔斯伯格(Anders Hejlsberg)开发的。</td>
</tr>
<tr>
<td>2</td>
<td>JavaScript源文件在”。js”扩展。</td>
<td>TypeScript源文件是”.ts”扩展名。</td>
</tr>
<tr>
<td>3</td>
<td>JavaScript不支持ES6。</td>
<td>TypeScript 支持ES6。</td>
</tr>
<tr>
<td>4</td>
<td>它不支持强类型或静态类型。</td>
<td>它支持强类型或静态类型特性。</td>
</tr>
<tr>
<td>5</td>
<td>它只是一种脚本语言。</td>
<td>它支持面向对象的编程概念，如类、接口、继承、泛型等。</td>
</tr>
<tr>
<td>6</td>
<td>JavaScript没有可选的参数特性。</td>
<td>TypeScript有可选的参数特性。</td>
</tr>
<tr>
<td>7</td>
<td>它是解释语言，这就是为什么它在运行时突出显示错误。</td>
<td>它编译代码并在开发期间突出显示错误。</td>
</tr>
<tr>
<td>8</td>
<td>JavaScript不支持模块。</td>
<td>TypeScript支持模块。</td>
</tr>
<tr>
<td>9</td>
<td>在这里，number和string是对象。</td>
<td>在这里，number和string是接口。</td>
</tr>
<tr>
<td>10</td>
<td>JavaScript不支持泛型。</td>
<td>TypeScript支持泛型。</td>
</tr>
</tbody></table>
<h3 id="我们为什么需要TypeScript？"><a href="#我们为什么需要TypeScript？" class="headerlink" title="我们为什么需要TypeScript？"></a>我们为什么需要TypeScript？</h3><p>我们需要TypeScript:</p>
<ul>
<li>TypeScript快速、简单，最重要的是，容易学习。</li>
<li>TypeScript支持面向对象的编程特性，比如类、接口、继承、泛型等等。</li>
<li>TypeScript在编译时提供了错误检查功能。它将编译代码，如果发现任何错误，它将在运行脚本之前突出显示这些错误。</li>
<li>TypeScript支持所有JavaScript库，因为它是JavaScript的超集。</li>
<li>TypeScript通过使用继承来支持可重用性。</li>
<li>TypeScript使应用程序开发尽可能的快速和简单，并且TypeScript的工具支持为我们提供了自动完成、类型检查和源文档。</li>
<li>TypeScript支持最新的JavaScript特性，包括ECMAScript 2015。</li>
<li>TypeScript提供了ES6的所有优点和更高的生产力。</li>
<li>TypeScript支持静态类型、强类型、模块、可选参数等。</li>
</ul>
<h3 id="列出Typescript的一些特性"><a href="#列出Typescript的一些特性" class="headerlink" title="列出Typescript的一些特性"></a>列出Typescript的一些特性</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5zcmNtaW5pLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxOS8xMi80ZTg4NzNhMjkyZTQ5OGUucG5n?x-oss-process=image/format,png" alt="Typescript的一些特性" title>
                </div>
                <div class="image-caption">Typescript的一些特性</div>
            </figure>



<h3 id="列出使用Typescript的一些优点"><a href="#列出使用Typescript的一些优点" class="headerlink" title="列出使用Typescript的一些优点?"></a>列出使用Typescript的一些优点?</h3><p>TypeScript有以下优点。</p>
<ul>
<li>它提供了可选静态类型的优点。在这里，Typescript提供了可以添加到变量、函数、属性等的类型。</li>
<li>Typescript能够编译出一个能在所有浏览器上运行的JavaScript版本。</li>
<li>TypeScript总是在编译时强调错误，而JavaScript在运行时指出错误。</li>
<li>TypeScript支持强类型或静态类型，而这不是在JavaScript中。</li>
<li>它有助于代码结构。</li>
<li>它使用基于类的面向对象编程。</li>
<li>它提供了优秀的工具支持和智能感知，后者在添加代码时提供活动提示。</li>
<li>它通过定义模块来定义名称空间概念。</li>
</ul>
<h3 id="Typescript的缺点是什么"><a href="#Typescript的缺点是什么" class="headerlink" title="Typescript的缺点是什么?"></a>Typescript的缺点是什么?</h3><p>TypeScript有以下缺点:</p>
<ul>
<li>TypeScript需要很长时间来编译代码。</li>
<li>TypeScript不支持抽象类。</li>
<li>如果我们在浏览器中运行TypeScript应用程序，需要一个编译步骤将TypeScript转换成JavaScript。</li>
<li>Web开发人员使用了几十年的JavaScript，而TypeScript不是都是新东西。</li>
<li>要使用任何第三方库，必须使用定义文件。并不是所有第三方库都有可用的定义文件。</li>
<li>类型定义文件的质量是一个问题，即如何确保定义是正确的?</li>
</ul>
<h3 id="TypeScript的不同组件是什么"><a href="#TypeScript的不同组件是什么" class="headerlink" title="TypeScript的不同组件是什么?"></a>TypeScript的不同组件是什么?</h3><p>TypeScript主要有三个组件。这些都是- –</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5zcmNtaW5pLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxOS8xMi8wYzdlODA2MzFjMDQxNTYucG5n?x-oss-process=image/format,png" alt="TypeScript所有组件" title>
                </div>
                <div class="image-caption">TypeScript所有组件</div>
            </figure>

<h4 id="语言language"><a href="#语言language" class="headerlink" title="语言language"></a>语言language</h4><p>该语言由新语法、关键字、类型注释等元素组成，允许我们编写TypeScript。</p>
<h4 id="编译器compiler"><a href="#编译器compiler" class="headerlink" title="编译器compiler"></a>编译器compiler</h4><p>TypeScript编译器是开源的、跨平台的，是用TypeScript编写的。它将用TypeScript编写的代码转换为JavaScript代码。它执行从TypeScript代码到JavaScript代码的解析和类型检查。它还可以帮助将不同的文件连接到单个输出文件，并生成源映射。</p>
<h4 id="语言服务language-service"><a href="#语言服务language-service" class="headerlink" title="语言服务language service"></a>语言服务language service</h4><p>语言服务提供信息，帮助编辑器和其他工具提供更好的辅助功能，如自动重构和智能感知。</p>
<h3 id="Typescript是谁开发的，目前稳定的Typescript版本是什么？"><a href="#Typescript是谁开发的，目前稳定的Typescript版本是什么？" class="headerlink" title="Typescript是谁开发的，目前稳定的Typescript版本是什么？"></a>Typescript是谁开发的，目前稳定的Typescript版本是什么？</h3><p>typescript是由Anders Hejlsberg开发的，他也是c#语言开发团队的核心成员之一。typescript于2012年10月1日发布，被标记为0.8版。它是由Microsoft在Apache 2许可下开发和维护的。它是为开发大型应用程序而设计的。</p>
<p>目前稳定的TypeScript版本是3.2，于2018年9月30日发布。Typescript编译成简单的JavaScript代码，可以在任何支持ECMAScript 2015框架的浏览器上运行。它支持最新的和不断发展的JavaScript特性。</p>
<h3 id="说说安装Typescript的最低要求。或者我们如何获得TypeScript并安装它？"><a href="#说说安装Typescript的最低要求。或者我们如何获得TypeScript并安装它？" class="headerlink" title="说说安装Typescript的最低要求。或者我们如何获得TypeScript并安装它？"></a>说说安装Typescript的最低要求。或者我们如何获得TypeScript并安装它？</h3><p>TypeScript可以通过npm (node .js包管理器)在node的帮助下进行安装和管理。要安装TypeScript，首先要确保npm安装正确，然后运行以下命令在系统上全局安装TypeScript。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g typescript</span><br></pre></td></tr></table></figure>

<p>它安装一个命令行代码“tsc”，它将进一步用于编译我们的Typescript代码。确保检查系统上安装的Typescript版本。</p>
<p>安装TypeScript需要以下步骤:</p>
<ul>
<li>下载并运行节点的.msi安装程序。</li>
<li>输入命令“node -v”检查安装是否成功。</li>
<li>在终端窗口中输入以下命令安装Typescript: $ npm install -g Typescript</li>
</ul>
<h3 id="列出在Typescript中的内置类型"><a href="#列出在Typescript中的内置类型" class="headerlink" title="列出在Typescript中的内置类型"></a>列出在Typescript中的内置类型</h3><p>在Typescript中，内置的数据类型也称为原始数据类型。这些数据如下所示。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5zcmNtaW5pLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxOS8xMi8xNWI4MjI2MGI0YzdkZDQucG5n?x-oss-process=image/format,png" alt="typescript内置数据类型02" title>
                </div>
                <div class="image-caption">typescript内置数据类型02</div>
            </figure>

<p><strong>数字类型</strong>: 用于表示数字类型值。TypeScript中的所有数字都存储为浮点值。</p>
<p><strong>语法</strong>: let标识符:number = value;</p>
<p><strong>字符串类型</strong>: 它表示存储为Unicode UTF-16代码的字符序列。我们通过将字符串括在单引号或双引号中来在脚本中包含字符串。</p>
<p><strong>语法</strong>: let标识符:字符串= ” “;</p>
<p><strong>布尔类型</strong>: 用于表示逻辑值。当我们使用布尔类型时，我们只得到真或假的输出。布尔值是一个真值，它指定条件是否为真。</p>
<p><strong>语法</strong>: let标识符:bool =布尔值;</p>
<p><strong>Null类型</strong>: Null表示值未定义的变量。不能直接引用空类型值本身。空类型没有用处，因为我们只能为它分配一个空值。</p>
<p><strong>语法</strong>: let num: number = null;</p>
<p><strong>未定义类型</strong>: 它是未定义字面量的类型。未定义的类型表示所有未初始化的变量。它是没有用的，因为我们只能分配一个未定义的值给它。这种内置类型是所有类型的子类型。</p>
<p><strong>语法</strong>: let num: number =未定义;</p>
<p><strong>Void类型</strong>: Void是不返回任何类型值的函数的返回类型。如果没有可用的数据类型，则使用它。</p>
<p><strong>语法</strong>: let unusable:void =未定义;</p>
<h3 id="Typescript中的变量是什么？如何在Typescript中创建变量？"><a href="#Typescript中的变量是什么？如何在Typescript中创建变量？" class="headerlink" title="Typescript中的变量是什么？如何在Typescript中创建变量？"></a>Typescript中的变量是什么？如何在Typescript中创建变量？</h3><p>变量是存储位置，用于存储要被程序引用和使用的值/信息。它充当程序中值的容器。可以使用var关键字声明它。它应该在使用前声明。在Typescript中声明变量时，应该遵循某些规则-</p>
<ul>
<li>变量名必须是字母或数字。</li>
<li>变量名不能以数字开头。</li>
<li>变量名不能包含空格和特殊字符，除了下划线(_)和美元($)符号。</li>
</ul>
<p>我们可以通过以下四种方式之一声明一个变量:</p>
<ul>
<li>在一条语句中声明类型和值。语法:var [identifier]: [type-annotation] = value;</li>
<li>声明没有值的类型。语法:var [identifier]: [type-annotation];</li>
<li>在没有类型的情况下声明它的值。语法:var [identifier] = value;</li>
<li>声明没有值和类型。语法:var(标识符);</li>
</ul>
<h3 id="如何编译Typescript文件？"><a href="#如何编译Typescript文件？" class="headerlink" title="如何编译Typescript文件？"></a>如何编译Typescript文件？</h3><p>下面是将Typescript文件编译成JavaScript时所遵循的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc &lt;TypeScript File Name&gt;</span><br></pre></td></tr></table></figure>

<p>例如，编译“hello .ts”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc helloworld.ts</span><br></pre></td></tr></table></figure>

<p>结果是helloworld.js。</p>
<h3 id="是否可以将多个-ts文件合并成一个-js文件？如果是，那么如何做？"><a href="#是否可以将多个-ts文件合并成一个-js文件？如果是，那么如何做？" class="headerlink" title="是否可以将多个.ts文件合并成一个.js文件？如果是，那么如何做？"></a>是否可以将多个.ts文件合并成一个.js文件？如果是，那么如何做？</h3><p>是的，有可能。为此，我们需要添加——outFILE [OutputJSFileName]编译选项。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc --outFile comman.js file1.ts file2.ts file3.ts</span><br></pre></td></tr></table></figure>

<p>上面的命令将编译所有这三个.ts文件和结果将存储在一个comman.js文件中，在这种情况下，当我们不提供输出文件名像下面的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc --outFile file1.ts file2.ts file3.ts</span><br></pre></td></tr></table></figure>

<p>然后file2.ts和file3.ts将被编译，并将输出放在file1.ts中，现在是file1.ts包含JavaScript代码。</p>
<h3 id="能否自动编译-ts文件，并实时修改-ts文件？"><a href="#能否自动编译-ts文件，并实时修改-ts文件？" class="headerlink" title="能否自动编译.ts文件，并实时修改.ts文件？"></a>能否自动编译.ts文件，并实时修改.ts文件？</h3><p>这是可以的，自动实时根据.ts文件变化自动编译.ts文件是可以的。这可以通过使用——watch compiler选项来实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --watch file1.ts</span><br></pre></td></tr></table></figure>

<p>上面的命令首先编译file1为file1.js，并注意文件的变化，如果检测到任何更改，它将再次编译文件。这里，我们需要确保在使用——watch选项运行时命令提示符不能关闭。</p>
<h3 id="TS的接口是什么意思？参照TS来解释它们。"><a href="#TS的接口是什么意思？参照TS来解释它们。" class="headerlink" title="TS的接口是什么意思？参照TS来解释它们。"></a>TS的接口是什么意思？参照TS来解释它们。</h3><p>接口是在我们的应用程序中充当契约的结构。它定义了要遵循的类的语法，这意味着实现接口的类必须实现它的所有成员。它不能被实例化，但是可以被实现它的类对象引用。无论对象是否具有特定的结构，TypeScript编译器都使用接口进行类型检查(也称为“duck typing”鸭子类型或“结构化子类型”)。</p>
<p>语法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface interface_name &#123;    </span><br><span class="line">          // 字段声明</span><br><span class="line"></span><br><span class="line">          // 方法声明</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口只是声明方法和字段，它不能用来建造任何东西。不需要将接口转换为JavaScript来执行，它们对运行时JavaScript没有任何影响。因此，它们的唯一目的是在开发阶段提供帮助。</p>
<h3 id="你如何理解Typescript中的类？列出类的一些特性。"><a href="#你如何理解Typescript中的类？列出类的一些特性。" class="headerlink" title="你如何理解Typescript中的类？列出类的一些特性。"></a>你如何理解Typescript中的类？列出类的一些特性。</h3><p>我们知道，TypeScript是一种面向对象的JavaScript语言，支持OOP编程特性，比如类、接口等。与Java一样，类是用于创建可重用组件的基本实体。它是一组具有公共属性的对象。类是创建对象的模板或蓝图。它是一个逻辑实体。“class”关键字用于在Typescript中声明一个类。</p>
<p>例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Student &#123;    </span><br><span class="line">    studCode: number;    </span><br><span class="line">    studName: string;    </span><br><span class="line">    constructor(code: number, name: string) &#123;    </span><br><span class="line">            this.studName = name;    </span><br><span class="line">            this.studCode = code;    </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    getGrade() : string &#123;    </span><br><span class="line">        return &quot;A+&quot; ;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类的特征是-</p>
<ul>
<li>继承</li>
<li>封装</li>
<li>多态性</li>
<li>抽象</li>
</ul>
<h3 id="本地Javascript支持模块吗？"><a href="#本地Javascript支持模块吗？" class="headerlink" title="本地Javascript支持模块吗？"></a>本地Javascript支持模块吗？</h3><p>不。目前，本地JavaScript不支持模块。为了在Javascript中创建和使用模块，我们需要一个像CommonJS这样的外部模块。</p>
<h3 id="TypeScript支持哪些面向对象的术语？"><a href="#TypeScript支持哪些面向对象的术语？" class="headerlink" title="TypeScript支持哪些面向对象的术语？"></a>TypeScript支持哪些面向对象的术语？</h3><p>TypeScript支持以下面向对象的术语。</p>
<ul>
<li>模块</li>
<li>类</li>
<li>接口</li>
<li>继承</li>
<li>数据类型</li>
<li>成员函数</li>
</ul>
<h3 id="如何从TypeScript的子类调用基类构造函数？"><a href="#如何从TypeScript的子类调用基类构造函数？" class="headerlink" title="如何从TypeScript的子类调用基类构造函数？"></a>如何从TypeScript的子类调用基类构造函数？</h3><p>super()函数的作用是: 从子类中调用父类或基类构造函数。</p>
<h3 id="如何在TypeScript中实现继承？"><a href="#如何在TypeScript中实现继承？" class="headerlink" title="如何在TypeScript中实现继承？"></a>如何在TypeScript中实现继承？</h3><p>继承是一种从另一个类获取一个类的属性和行为的机制。它是OOPs语言的一个重要方面，并且具有从现有类创建新类的能力，继承成员的类称为基类，继承这些成员的类称为派生类。</p>
<p>继承可以通过使用extend关键字来实现。我们可以通过下面的例子来理解它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Shape &#123;     </span><br><span class="line">   Area:number     </span><br><span class="line">   constructor(area:number) &#123;     </span><br><span class="line">      this.Area = area    </span><br><span class="line">   &#125;     </span><br><span class="line">&#125;     </span><br><span class="line"></span><br><span class="line">class Circle extends Shape &#123;     </span><br><span class="line">   display():void &#123;     </span><br><span class="line">      console.log(&quot;圆的面积: &quot;+this.Area)     </span><br><span class="line">   &#125;     </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">var obj = new Circle(320);     </span><br><span class="line"></span><br><span class="line">obj.display()</span><br></pre></td></tr></table></figure>

<h3 id="Typescript中的模块是什么？-1"><a href="#Typescript中的模块是什么？-1" class="headerlink" title="Typescript中的模块是什么？"></a>Typescript中的模块是什么？</h3><p>模块是创建一组相关变量、函数、类和接口等的强大方法。它可以在它们自己的范围内执行，而不是在全局范围内。换句话说，在模块中声明的变量、函数、类和接口不能在模块外部直接访问。</p>
<p><strong>创建一个模块</strong></p>
<p>可以使用export关键字创建模块，也可以在其他模块中使用import关键字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module module_name&#123;  </span><br><span class="line">    class xyz&#123;  </span><br><span class="line">        export sum(x, y)&#123;  </span><br><span class="line">            return x+y;  </span><br><span class="line">         &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内部模块和外部模块有什么区别？"><a href="#内部模块和外部模块有什么区别？" class="headerlink" title="内部模块和外部模块有什么区别？"></a>内部模块和外部模块有什么区别？</h3><p>内部模块与外部模块的区别如下:</p>
<table>
<thead>
<tr>
<th><strong>编号</strong></th>
<th>内部模块</th>
<th>外部模块</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>内部模块用于将类、接口、函数和变量逻辑地分组到一个单元中，并可以导出到另一个模块中。</td>
<td>外部模块用于隐藏模块定义的内部语句，并且只显示与声明的变量相关的方法和参数。</td>
</tr>
<tr>
<td>2</td>
<td>内部模块在Typescript的早期版本中。但是在最新版本的TypeScript中使用名称空间仍然支持它们。</td>
<td>外部模块在最新版本的TypeScript中称为模块。</td>
</tr>
<tr>
<td>3</td>
<td>内部模块是其他模块(包括全局模块和外部模块)的本地或导出成员。</td>
<td>外部模块是使用外部模块名称引用的单独加载的代码体。</td>
</tr>
<tr>
<td>4</td>
<td>内部模块使用指定其名称和主体的moduledeclaration来声明。</td>
<td>外部模块被编写为一个单独的源文件，其中包含至少一个导入或导出声明。</td>
</tr>
<tr>
<td>5</td>
<td>例子: module Sum {    export function add(a, b) {     console.log(“Sum: ” +(a+b));    }  }</td>
<td>例子: export class Addition{   constructor(private x?: number, private y?: number){   }   Sum(){     console.log(“SUM: ” +(this.x + this.y));   } }</td>
</tr>
</tbody></table>
<h3 id="Typescript中的名称空间是什么？如何在Typescript中声明名称空间？"><a href="#Typescript中的名称空间是什么？如何在Typescript中声明名称空间？" class="headerlink" title="Typescript中的名称空间是什么？如何在Typescript中声明名称空间？"></a>Typescript中的名称空间是什么？如何在Typescript中声明名称空间？</h3><p>名称空间是用于对功能进行逻辑分组的一种方式。名称空间用于在内部维护typescript的遗留代码。它封装了共享某些关系的特性和对象。名称空间也称为内部模块。名称空间还可以包括接口、类、函数和变量，以支持一组相关功能。</p>
<p>注意: 名称空间可以在多个文件中定义，并允许将每个文件都定义在一个地方。它使代码更容易维护。</p>
<p><strong>用于创建名称空间的语法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">namespace &lt;namespace_name&gt; &#123;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           export interface I1 &#123; &#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           export class c1&#123; &#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解释在TypeScript中的装饰器？"><a href="#解释在TypeScript中的装饰器？" class="headerlink" title="解释在TypeScript中的装饰器？"></a>解释在TypeScript中的装饰器？</h3><p>修饰符是一种特殊类型的声明，可以应用于类、方法、访问器、属性或参数。修饰符只是以@expression符号为前缀的函数，其中表达式必须求值为一个函数，该函数将在运行时用有关修饰声明的信息调用。</p>
<p>TypeScript装饰器以声明的方式将注释和元数据添加到现有代码中。装饰器是为ES7提出的一个实验性特性。它已经被一些JavaScript框架使用，包括Angular 2。装饰器在未来的版本中可能会改变。</p>
<p>要启用对decorator的实验支持，我们必须在命令行或在我们的tsconfig.json中启用experimental aldecorators编译器选项:</p>
<p>命令行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$tsc --target ES5 --experimentalDecorators</span><br></pre></td></tr></table></figure>

<p><strong>tsconfig.json</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">    &quot;compilerOptions&quot;: &#123;    </span><br><span class="line">        &quot;target&quot;: &quot;ES5&quot;,    </span><br><span class="line">        &quot;experimentalDecorators&quot;: true    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="什么是混合mixin？"><a href="#什么是混合mixin？" class="headerlink" title="什么是混合mixin？"></a>什么是混合mixin？</h3><p>在Javascript中，mixin是一种从可重用组件构建类的方法，通过组合称为mixin的更简单的部分类来构建它们。</p>
<p>这个想法很简单，不是类a扩展类B来获得它的功能，而是函数B获取类a并返回一个新类，这个类具有这个添加的功能。函数B是一个混合函数。</p>
<h3 id="TypeScript类中属性-方法的默认可见性是什么？"><a href="#TypeScript类中属性-方法的默认可见性是什么？" class="headerlink" title="TypeScript类中属性/方法的默认可见性是什么？"></a>TypeScript类中属性/方法的默认可见性是什么？</h3><p>Public是TypeScript类中属性/方法的默认可见性。</p>
<h3 id="TypeScript是如何在函数中支持可选参数的？"><a href="#TypeScript是如何在函数中支持可选参数的？" class="headerlink" title="TypeScript是如何在函数中支持可选参数的？"></a>TypeScript是如何在函数中支持可选参数的？</h3><p>与JavaScript不同，如果我们试图调用一个函数而不提供其函数签名中声明的参数的确切数量和类型，那么TypeScript编译器将抛出一个错误。为了克服这个问题，我们可以通过使用问号符号(‘?’)来使用可选参数。这意味着可以或不可以接收值的参数可以附加一个’?”“可选的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Demo(arg1: number, arg2? :number) &#123;              </span><br><span class="line"></span><br><span class="line">&#125;因此，arg1总是必需的，而arg2是一个可选参数</span><br></pre></td></tr></table></figure>

<p>因此，arg1总是必需的，而arg2是一个可选参数。</p>
<p>注意: 可选参数必须遵循要求的参数。如果我们想让arg1成为可选的，而不是arg2，那么我们需要改变顺序，arg1必须放在arg2之后。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Demo(arg2: number, arg1? :number) &#123;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JavaScript不支持函数重载，但TypeScript是否支持函数重载？"><a href="#JavaScript不支持函数重载，但TypeScript是否支持函数重载？" class="headerlink" title="JavaScript不支持函数重载，但TypeScript是否支持函数重载？"></a>JavaScript不支持函数重载，但TypeScript是否支持函数重载？</h3><p>是的，TypeScript支持函数重载。但是它的实现很奇怪，当我们在TypeScript中执行函数重载时，我们只能实现一个带有多个签名的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//带有字符串类型参数的函数  </span><br><span class="line">function add(a:string, b:string): string;    </span><br><span class="line">//带有数字类型参数的函数</span><br><span class="line">function add(a:number, b:number): number;    </span><br><span class="line">//函数定义</span><br><span class="line">function add(a: any, b:any): any &#123;    </span><br><span class="line">    return a + b;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，前两行是函数重载声明。它有两次重载，第一个签名的参数类型为string，而第二个签名的参数类型为number。第三个函数包含实际实现并具有any类型的参数。任何数据类型都可以接受任何类型的数据。然后，实现检查所提供参数的类型，并根据供应商参数类型执行不同的代码段。</p>
<h3 id="可以调试任何TypeScript文件吗？"><a href="#可以调试任何TypeScript文件吗？" class="headerlink" title="可以调试任何TypeScript文件吗？"></a>可以调试任何TypeScript文件吗？</h3><p>是的。要调试任何TypeScript文件，我们需要.js源映射文件。因此，使用—sourcemap标志编译.ts文件以生成源映射文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc -sourcemap file1.ts</span><br></pre></td></tr></table></figure>

<p>这将创建file1.js和file1.js.map，而file1.js的最后一行是源映射文件的引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//# sourceMappingURL=file1.js.map</span><br></pre></td></tr></table></figure>

<h3 id="什么是TypeScript定义管理器？为什么我们需要它？"><a href="#什么是TypeScript定义管理器？为什么我们需要它？" class="headerlink" title="什么是TypeScript定义管理器？为什么我们需要它？"></a>什么是TypeScript定义管理器？为什么我们需要它？</h3><p>TypeScript定义管理器(TSD)是一个包管理器，用于直接从社区驱动的DefinitelyTyped库中搜索和安装TypeScript定义文件。</p>
<p>假设我们想在.ts文件中使用一些jQuery代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(document).ready(function() &#123; //Your jQuery code &#125;);</span><br></pre></td></tr></table></figure>

<p>现在，当我们尝试使用tsc编译它时，它会给出一个编译时错误: 找不到名称“$”。因此，我们需要通知TypeScript编译器“$”属于jQuery。要做到这一点，TSD就要发挥作用。我们可以下载jQuery类型定义文件并将其包含在.ts文件中。以下是实现这一目标的步骤:</p>
<p>首先,安装TSD中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install tsd -g</span><br></pre></td></tr></table></figure>

<p>在TypeScript目录中，通过运行创建一个新的TypeScript项目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsd init</span><br></pre></td></tr></table></figure>

<p>然后安装jQuery的定义文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsd query jquery --action install</span><br></pre></td></tr></table></figure>

<p>上面的命令将下载并创建一个包含以“.d.ts”结尾的jQuery定义文件的新目录。现在，通过更新TypeScript文件以指向jQuery定义来包含定义文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;reference path=&quot;typings/jquery/jquery.d.ts&quot; /&gt;  </span><br><span class="line">$(document).ready(function() &#123; //To Do  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>现在，再次编译。这次将生成js文件，没有任何错误。因此，TSD的需要帮助我们获得所需框架的类型定义文件。</p>
<h3 id="什么是TypeScript-Declare关键字"><a href="#什么是TypeScript-Declare关键字" class="headerlink" title="什么是TypeScript Declare关键字?"></a>什么是TypeScript Declare关键字?</h3><p>我们知道所有的JavaScript库/框架都没有TypeScript声明文件，但是我们希望在TypeScript文件中使用它们时不会出现编译错误。为此，我们使用declare关键字。在我们希望定义可能存在于其他地方的变量的环境声明和方法中，可以使用declare关键字。</p>
<p>例如，假设我们有一个名为myLibrary的库，它没有TypeScript声明文件，在全局命名空间中有一个名为myLibrary的命名空间。如果我们想在TypeScript代码中使用这个库，我们可以使用以下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare var myLibrary;</span><br></pre></td></tr></table></figure>

<p>TypeScript运行时将把myLibrary变量赋值为任意类型。这是一个问题，我们不会得到智能感知在设计时，但我们将能够使用库在我们的代码。</p>
<h3 id="如何从任何-ts文件生成TypeScript定义文件"><a href="#如何从任何-ts文件生成TypeScript定义文件" class="headerlink" title="如何从任何.ts文件生成TypeScript定义文件?"></a>如何从任何.ts文件生成TypeScript定义文件?</h3><p>我们可以使用tsc编译器从任何.ts文件生成TypeScript定义文件。它将生成一个TypeScript定义，使我们的TypeScript文件可重用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --declaration file1.ts</span><br></pre></td></tr></table></figure>

<h3 id="什么是tsconfig-son文件吗？"><a href="#什么是tsconfig-son文件吗？" class="headerlink" title="什么是tsconfig.son文件吗？"></a>什么是tsconfig.son文件吗？</h3><p>tsconfig.son文件是json格式的文件。tsconfig.json文件中，我们可以指定各种选项告诉编译器如何编译当前项目。目录中存在tsconfig.json文件，表明该目录是TypeScript项目的根目录。 下面是一个示例tsconfig.json文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">   &quot;compilerOptions&quot;: &#123;  </span><br><span class="line">      &quot;declaration&quot;: true,      </span><br><span class="line">      &quot;emitDecoratorMetadata&quot;: false,      </span><br><span class="line">      &quot;experimentalDecorators&quot;: false,      </span><br><span class="line">      &quot;module&quot;: &quot;none&quot;,      </span><br><span class="line">      &quot;moduleResolution&quot;: &quot;node&quot;  </span><br><span class="line">      &quot;removeComments&quot;: true,  </span><br><span class="line">      &quot;sourceMap&quot;: true  </span><br><span class="line">   &#125;,  </span><br><span class="line"></span><br><span class="line">   &quot;files&quot;: [  </span><br><span class="line">      &quot;main.ts&quot;,  </span><br><span class="line">      &quot;othermodule.ts&quot;  </span><br><span class="line">    ]  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解释TypeScript中的泛型？"><a href="#解释TypeScript中的泛型？" class="headerlink" title="解释TypeScript中的泛型？"></a>解释TypeScript中的泛型？</h3><p>TypeScript泛型是一个提供创建可重用组件方法的工具。它能够创建可以处理多种数据类型而不是单一数据类型的组件。泛型在不影响性能或生产率的情况下提供类型安全性。泛型允许我们创建泛型类、泛型函数、泛型方法和泛型接口。</p>
<p>在泛型中，类型参数写在开(&lt;)和闭(&gt;)括号之间，这使得它是强类型集合。泛型使用一种特殊类型的类型变量<t>，它表示类型。泛型集合只包含类似类型的对象。</t></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function identity&lt;T&gt;(arg: T): T &#123;      </span><br><span class="line">    return arg;      </span><br><span class="line">&#125;      </span><br><span class="line"></span><br><span class="line">let output1 = identity&lt;string&gt;(&quot;myString&quot;);      </span><br><span class="line">let output2 = identity&lt;number&gt;( 100 );    </span><br><span class="line">console.log(output1);    </span><br><span class="line">console.log(output2);</span><br></pre></td></tr></table></figure>

<h3 id="TypeScript是否支持所有面向对象的原则？"><a href="#TypeScript是否支持所有面向对象的原则？" class="headerlink" title="TypeScript是否支持所有面向对象的原则？"></a>TypeScript是否支持所有面向对象的原则？</h3><p>是的，TypeScript支持所有面向对象的原则。面向对象编程有四个主要原则:</p>
<ul>
<li>封装,</li>
<li>继承,</li>
<li>抽象,</li>
<li>多态性。</li>
</ul>
<h3 id="如何检查TypeScript中的null和undefined-？"><a href="#如何检查TypeScript中的null和undefined-？" class="headerlink" title="如何检查TypeScript中的null和undefined ？"></a>如何检查TypeScript中的null和undefined ？</h3><p>通过使用一个缓冲检查，我们可以检查空和未定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (x == null) &#123;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们使用严格的检查，它将总是对设置为null的值为真，而对未定义的变量不为真。</p>
<p>例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var a: number;  </span><br><span class="line">var b: number = null;  </span><br><span class="line">function check(x, name) &#123;  </span><br><span class="line">    if (x == null) &#123;  </span><br><span class="line">        console.log(name + &apos; == null&apos;);  </span><br><span class="line">    &#125;  </span><br><span class="line">    if (x === null) &#123;  </span><br><span class="line">        console.log(name + &apos; === null&apos;);  </span><br><span class="line">    &#125;  </span><br><span class="line">    if (typeof x === &apos;undefined&apos;) &#123;  </span><br><span class="line">        console.log(name + &apos; is undefined&apos;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">check(a, &apos;a&apos;);  </span><br><span class="line">check(b, &apos;b&apos;);</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;a == null&quot;  </span><br><span class="line">&quot;a is undefined&quot;  </span><br><span class="line">&quot;b == null&quot;  </span><br><span class="line">&quot;b === null&quot;</span><br></pre></td></tr></table></figure>

<h3 id="我们可以在后端使用TypeScript吗？如果可以，如何使用？"><a href="#我们可以在后端使用TypeScript吗？如果可以，如何使用？" class="headerlink" title="我们可以在后端使用TypeScript吗？如果可以，如何使用？"></a>我们可以在后端使用TypeScript吗？如果可以，如何使用？</h3><p>是的，我们可以在后端使用TypeScript。我们可以通过下面的例子来理解它。在这里，我们选择Node.js，并具有一些额外的类型安全性和该语言带来的其他抽象。</p>
<p>安装TypeScript编译器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g typescript</span><br></pre></td></tr></table></figure>

<p>TypeScript编译器接受tsconfig.json文件中的选项，此文件确定将构建的文件放在何处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">  &quot;compilerOptions&quot;: &#123;  </span><br><span class="line">    &quot;target&quot;: &quot;es5&quot;,  </span><br><span class="line">    &quot;module&quot;: &quot;commonjs&quot;,  </span><br><span class="line">    &quot;declaration&quot;: true,  </span><br><span class="line">    &quot;outDir&quot;: &quot;build&quot;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译ts文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc</span><br></pre></td></tr></table></figure>

<p>运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node build/index.js</span><br></pre></td></tr></table></figure>

<h3 id="TS的“接口”和“type”语句有什么区别？"><a href="#TS的“接口”和“type”语句有什么区别？" class="headerlink" title="TS的“接口”和“type”语句有什么区别？"></a>TS的“接口”和“type”语句有什么区别？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nterface X &#123;  </span><br><span class="line">    a: number  </span><br><span class="line">    b: string  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">type X = &#123;  </span><br><span class="line">    a: number  </span><br><span class="line">    b: string  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>编号</strong></th>
<th><strong>接口</strong></th>
<th><strong>Type**</strong>类型**</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>接口声明总是引入指定的对象类型。</td>
<td>类型别名声明可以为任何类型(包括基元类型、联合类型和交集类型)引入名称。</td>
</tr>
<tr>
<td>2</td>
<td>接口可以在extends或implements子句中命名。</td>
<td>对象类型文字的类型别名不能在“扩展”或“实现”子句中命名。</td>
</tr>
<tr>
<td>3</td>
<td>接口创建一个到处使用的新名称。</td>
<td>类型别名不创建新名称。</td>
</tr>
<tr>
<td>4</td>
<td>一个接口可以有多个合并声明。</td>
<td>对象类型字面量的类型别名不能有多个合并声明。</td>
</tr>
</tbody></table>
<h3 id="TypeScript中的环境是什么？何时使用它？"><a href="#TypeScript中的环境是什么？何时使用它？" class="headerlink" title="TypeScript中的环境是什么？何时使用它？"></a>TypeScript中的环境是什么？何时使用它？</h3><p>环境声明告诉编译器其他地方存在的实际源代码。如果这些源代码在运行时不存在，而我们尝试使用它们，则它将中断而不会发出警告。</p>
<p>环境声明文件类似于docs文件。如果源更改，则还需要保持文档更新。如果环境声明文件未更新，那么我们将得到编译器错误。</p>
<p>Ambient声明使我们能够安全轻松地使用现有流行的JavaScript库，例如jquery，angularjs，nodejs等。</p>
<h3 id="什么是TypeScript映射文件？"><a href="#什么是TypeScript映射文件？" class="headerlink" title="什么是TypeScript映射文件？"></a>什么是TypeScript映射文件？</h3><ul>
<li>TypeScript Map文件是一个源映射文件，其中包含有关我们原始文件的信息。</li>
<li>.map文件是源映射文件，可让工具在发出的JavaScript代码和创建它的TypeScript源文件之间进行映射。</li>
<li>许多调试器可以使用这些文件，因此我们可以调试TypeScript文件而不是JavaScript文件。</li>
</ul>
<h3 id="什么是TypeScript中的类型断言？"><a href="#什么是TypeScript中的类型断言？" class="headerlink" title="什么是TypeScript中的类型断言？"></a>什么是TypeScript中的类型断言？</h3><p>类型断言的工作方式类似于其他语言中的类型转换，但是它不像其他语言一样执行C＃和Java那样的类型检查或数据重组。类型转换附带运行时支持，而类型断言对运行时没有影响。但是，类型断言仅由编译器使用，并向编译器提供有关我们希望如何分析代码的提示。</p>
<p>例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let empCode: any = 111;     </span><br><span class="line">let employeeCode = &lt;number&gt; code;     </span><br><span class="line">console.log(typeof(employeeCode)); // : number</span><br></pre></td></tr></table></figure>

<h3 id="TypeScript的as语法是什么？"><a href="#TypeScript的as语法是什么？" class="headerlink" title="TypeScript的as语法是什么？"></a>TypeScript的as语法是什么？</h3><p>as是TypeScript中类型断言的附加语法，引入as-语法的原因是原始语法(<type>)与JSX冲突。</type></p>
<p>例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">et empCode: any = 111;     </span><br><span class="line">let employeeCode = code as number;</span><br></pre></td></tr></table></figure>

<p>当使用带有JSX的TypeScript时，只允许as风格的断言。</p>
<h3 id="什么是JSX？我们可以在TypeScript中使用JSX吗？"><a href="#什么是JSX？我们可以在TypeScript中使用JSX吗？" class="headerlink" title="什么是JSX？我们可以在TypeScript中使用JSX吗？"></a>什么是JSX？我们可以在TypeScript中使用JSX吗？</h3><p>JSX只不过是带有不同扩展名的Javascript。Facebook提出了这个新的扩展，以便与JavaScript中类似xml的HTML实现区分开来。</p>
<p>JSX是一种可嵌入的类似xml的语法。它将被转换成有效的JavaScript。JSX随着React框架而流行起来。TypeScript支持嵌入、类型检查和直接将JSX编译成JavaScript。</p>
<p>要使用JSX，我们必须做两件事。</p>
<ul>
<li>使用.tsx扩展名命名文件</li>
<li>启用jsx选项</li>
</ul>
<h3 id="什么是Rest参数？-1"><a href="#什么是Rest参数？-1" class="headerlink" title="什么是Rest参数？"></a>什么是Rest参数？</h3><p>rest参数用于向函数传递零个或多个值。它是通过在参数前加上三个点字符(‘…’)来声明的。它允许函数在不使用arguments对象的情况下拥有可变数量的参数。当我们有不确定数量的参数时，这是非常有用的。</p>
<p>rest参数要遵循的规则:</p>
<ul>
<li>一个函数中只允许有一个rest参数。</li>
<li>它必须是数组类型。</li>
<li>它必须是参数列表中的最后一个参数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function sum(a: number, ...b: number[]): number &#123;    </span><br><span class="line"> let result = a;    </span><br><span class="line"> for (var i = 0; i &lt; b.length; i++) &#123;    </span><br><span class="line"> result += b[i];    </span><br><span class="line"> &#125;    </span><br><span class="line"></span><br><span class="line"> console.log(result);    </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">let result1 = sum(3, 5);    </span><br><span class="line">let result2 = sum(3, 5, 7, 9);</span><br></pre></td></tr></table></figure>

<h3 id="解释TypeScript的Enum枚举类型？"><a href="#解释TypeScript的Enum枚举类型？" class="headerlink" title="解释TypeScript的Enum枚举类型？"></a>解释TypeScript的Enum枚举类型？</h3><p>枚举或枚举是一种数据类型，允许我们定义一组命名常量。使用枚举可以更容易地记录意图，或者创建一组不同的案例。它是相关值的集合，可以是数值或字符串值。</p>
<p>例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enum Gender &#123;  </span><br><span class="line">  Male,  </span><br><span class="line">  Female  </span><br><span class="line">  Other  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">console.log(Gender.Female); // : 1  </span><br><span class="line">// 我们还可以通过enum值的number值来访问它</span><br><span class="line">console.log(Gender[1]); // : Female</span><br></pre></td></tr></table></figure>

<h3 id="解释相对模块和非相对模块的导入"><a href="#解释相对模块和非相对模块的导入" class="headerlink" title="解释相对模块和非相对模块的导入"></a>解释相对模块和非相对模块的导入</h3><table>
<thead>
<tr>
<th><strong>非相对</strong></th>
<th><strong>相对</strong></th>
</tr>
</thead>
<tbody><tr>
<td>非相对导入可以相对于baseUrl解析，也可以通过路径映射解析。换句话说，我们在导入任何外部依赖项时使用非相对路径。 <strong>例子**</strong>:** import * as $ from “jquery”; import { Component } from “@angular/core”;</td>
<td>相对导入可以用于我们自己的模块，这些模块保证在运行时维护它们的相对位置。相对导入以/、./或../开头。 例子: import Entry from “./components/Entry”; import {DefaultHeaders} from “../constants/http”;</td>
</tr>
</tbody></table>
<h3 id="什么是匿名函数？"><a href="#什么是匿名函数？" class="headerlink" title="什么是匿名函数？"></a>什么是匿名函数？</h3><p>匿名函数是声明时没有任何命名标识符的函数。这些函数是在运行时动态声明的。与标准函数一样，匿名函数可以接受输入和返回输出。匿名函数在初始创建之后通常是不可访问的。</p>
<p>例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let myAdd = function(x: number, y: number): number &#123;   </span><br><span class="line">return x + y;   </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">console.log(myAdd())</span><br></pre></td></tr></table></figure>

<h3 id="什么是声明合并？-1"><a href="#什么是声明合并？-1" class="headerlink" title="什么是声明合并？"></a>什么是声明合并？</h3><p>声明合并是编译器随后合并两个或多个独立声明的过程。将具有相同名称的声明声明为单个定义。这个合并的定义具有两个原始声明的特性。</p>
<p>最简单也是最常见的声明合并类型是接口合并。在最基本的层次上，merge将两个声明的成员机械地连接到一个具有相同名称的接口中。</p>
<p>例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface Cloner &#123;  </span><br><span class="line">    clone(animal: Animal): Animal;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">interface Cloner &#123;  </span><br><span class="line">    clone(animal: Sheep): Sheep;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">interface Cloner &#123;  </span><br><span class="line">    clone(animal: Dog): Dog;  </span><br><span class="line">    clone(animal: Cat): Cat;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这三个接口将合并为一个单独的声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Cloner &#123;  </span><br><span class="line">    clone(animal: Dog): Dog;  </span><br><span class="line">    clone(animal: Cat): Cat;  </span><br><span class="line">    clone(animal: Sheep): Sheep;  </span><br><span class="line">    clone(animal: Animal): Animal;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注: 在TypeScript中不是所有的合并都允许。目前，类不能与其他类或变量合并。</p>
<h3 id="TypeScript中的方法重写是什么"><a href="#TypeScript中的方法重写是什么" class="headerlink" title="TypeScript中的方法重写是什么?"></a>TypeScript中的方法重写是什么?</h3><p>如果子类(子类)具有与父类中声明的相同的方法，则称为方法覆盖。换句话说，在派生类或子类中重新定义基类方法。</p>
<p>方法重写的规则</p>
<ul>
<li>该方法必须具有与父类相同的名称</li>
<li>该方法必须具有与父类相同的参数。</li>
<li>必须有一个IS-A关系(继承)。</li>
</ul>
<p>例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class NewPrinter extends Printer &#123;  </span><br><span class="line">    doPrint(): any &#123;  </span><br><span class="line">        super.doPrint();  </span><br><span class="line">        console.log(&quot;Called Child class.&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    doInkJetPrint(): any &#123;  </span><br><span class="line">        console.log(&quot;Called doInkJetPrint().&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let printer: new () =&gt; NewPrinter;  </span><br><span class="line">printer.doPrint();  </span><br><span class="line">printer.doInkJetPrint();</span><br></pre></td></tr></table></figure>

<h3 id="Lambda-箭头函数是什么？"><a href="#Lambda-箭头函数是什么？" class="headerlink" title="Lambda/箭头函数是什么？"></a>Lambda/箭头函数是什么？</h3><p>ES6版本的TypeScript提供了定义匿名函数的简写语法，也就是用于函数表达式。这些箭头函数也称为Lambda函数。lambda函数是没有名称的函数，箭头函数省略了function关键字。</p>
<p>例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let sum = (a: number, b: number): number =&gt; &#123;    </span><br><span class="line">            return a + b;    </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">console.log(sum(20, 30)); //returns 50</span><br></pre></td></tr></table></figure>

<p>在上面，?=&gt;?是一个lambda操作符，(a + b)是函数的主体，(a: number, b: number)是内联参数。</p>
<p>ypeScript 是 Microsoft 开发的JavaScript 的开源超集，用于在不破坏现有程序的情况下添加附加功能。</p>
<p>由于其独特的优势，例如,静态类型和许多速记符号，TypeScript 现在被前端和全栈开发人员广泛用于大型项目。</p>
<h3 id="TypeScript-的主要特点是什么？"><a href="#TypeScript-的主要特点是什么？" class="headerlink" title="TypeScript 的主要特点是什么？"></a>TypeScript 的主要特点是什么？</h3><ul>
<li>跨平台：TypeScript 编译器可以安装在任何操作系统上，包括 Windows、macOS 和 Linux。</li>
<li>ES6 特性：TypeScript 包含计划中的 ECMAScript 2015 (ES6) 的大部分特性，例如箭头函数。</li>
<li>面向对象的语言：TypeScript 提供所有标准的 OOP 功能，如类、接口和模块。</li>
<li>静态类型检查：TypeScript 使用静态类型并帮助在编译时进行类型检查。因此，你可以在编写代码时发现编译时错误，而无需运行脚本。</li>
<li>可选的静态类型：如果你习惯了 JavaScript 的动态类型，TypeScript 还允许可选的静态类型。</li>
<li>DOM 操作：您可以使用 TypeScript 来操作 DOM 以添加或删除客户端网页元素。</li>
</ul>
<h3 id="使用-TypeScript-有什么好处？"><a href="#使用-TypeScript-有什么好处？" class="headerlink" title="使用 TypeScript 有什么好处？"></a>使用 TypeScript 有什么好处？</h3><ul>
<li>TypeScript 更具表现力，这意味着它的语法混乱更少。</li>
<li>由于高级调试器专注于在编译时之前捕获逻辑错误，因此调试很容易。</li>
<li>静态类型使 TypeScript 比 JavaScript 的动态类型更易于阅读和结构化。</li>
<li>由于通用的转译，它可以跨平台使用，在客户端和服务器端项目中。</li>
</ul>
<h3 id="TypeScript-的内置数据类型有哪些？"><a href="#TypeScript-的内置数据类型有哪些？" class="headerlink" title="TypeScript 的内置数据类型有哪些？"></a>TypeScript 的内置数据类型有哪些？</h3><p>数字类型：用于表示数字类型的值。TypeScript 中的所有数字都存储为浮点值。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> identifier: number = <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure>

<p>布尔类型：一个逻辑二进制开关，包含true或false</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> identifier: <span class="keyword">string</span> = <span class="string">" "</span>;</span><br></pre></td></tr></table></figure>

<p>Null 类型： Null 表示值未定义的变量。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> identifier: <span class="keyword">bool</span> = Boolean <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure>

<p>未定义类型：一个未定义的字面量，它是所有变量的起点。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>void 类型：分配给没有返回值的方法的类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unusable: <span class="keyword">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>

<h3 id="TypeScript-目前的稳定版本是什么？"><a href="#TypeScript-目前的稳定版本是什么？" class="headerlink" title="TypeScript 目前的稳定版本是什么？"></a>TypeScript 目前的稳定版本是什么？</h3><p>当前的稳定版本是 4.2.3。</p>
<h3 id="TypeScript-中的接口是什么？"><a href="#TypeScript-中的接口是什么？" class="headerlink" title="TypeScript 中的接口是什么？"></a>TypeScript 中的接口是什么？</h3><p>接口为使用该接口的对象定义契约或结构。</p>
<p>接口是用关键字定义的interface，它可以包含使用函数或箭头函数的属性和方法声明。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IEmployee &#123;</span><br><span class="line">    empCode: <span class="built_in">number</span>;</span><br><span class="line">    empName: <span class="built_in">string</span>;</span><br><span class="line">    getSalary: <span class="function">(<span class="params"><span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>; <span class="comment">// arrow function</span></span><br><span class="line">    getManagerName(<span class="built_in">number</span>): <span class="built_in">string</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TypeScript-中的模块是什么？"><a href="#TypeScript-中的模块是什么？" class="headerlink" title="TypeScript 中的模块是什么？"></a>TypeScript 中的模块是什么？</h3><p>TypeScript 中的模块是相关变量、函数、类和接口的集合。</p>
<p>你可以将模块视为包含执行任务所需的一切的容器。可以导入模块以轻松地在项目之间共享代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> module_name&#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">xyz</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">export</span> <span class="title">sum</span><span class="params">(x, y)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x+y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后端如何使用TypeScript？"><a href="#后端如何使用TypeScript？" class="headerlink" title="后端如何使用TypeScript？"></a>后端如何使用TypeScript？</h3><p>你可以将 Node.js 与 TypeScript 结合使用，将 TypeScript 的优势带入后端工作。</p>
<p>只需输入以下命令，即可将 TypeScript 编译器安装到你的 Node.js 中：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">npm</span> i -g typescript</span><br></pre></td></tr></table></figure>

<h3 id="TypeScript-中的类型断言是什么？"><a href="#TypeScript-中的类型断言是什么？" class="headerlink" title="TypeScript 中的类型断言是什么？"></a>TypeScript 中的类型断言是什么？</h3><p>TypeScript 中的类型断言的工作方式类似于其他语言中的类型转换，但没有 C# 和 Java 等语言中可能的类型检查或数据重组。类型断言对运行时没有影响，仅由编译器使用。</p>
<p>类型断言本质上是类型转换的软版本，它建议编译器将变量视为某种类型，但如果它处于不同的形式，则不会强制它进入该模型。</p>
<h3 id="如何在-TypeScript-中创建变量？"><a href="#如何在-TypeScript-中创建变量？" class="headerlink" title="如何在 TypeScript 中创建变量？"></a>如何在 TypeScript 中创建变量？</h3><p>你可以通过三种方式创建变量：var，let，和const。<br>var是严格范围变量的旧风格。你应该尽可能避免使用，var因为它会在较大的项目中导致问题。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num:<span class="built_in">number</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>let是在 TypeScript 中声明变量的默认方式。与var相比，let减少了编译时错误的数量并提高了代码的可读性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num:<span class="built_in">number</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>const创建一个其值不能改变的常量变量。它使用相同的范围规则，let并有助于降低整体程序的复杂性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num:<span class="built_in">number</span> = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<h3 id="在TypeScript中如何从子类调用基类构造函数？"><a href="#在TypeScript中如何从子类调用基类构造函数？" class="headerlink" title="在TypeScript中如何从子类调用基类构造函数？"></a>在TypeScript中如何从子类调用基类构造函数？</h3><p>你可以使用该super()函数来调用基类的构造函数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = theName;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  move(distanceInMeters: <span class="built_in">number</span> = <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> moved <span class="subst">$&#123;distanceInMeters&#125;</span>m.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Snake <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  move(distanceInMeters = <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Slithering..."</span>);</span><br><span class="line">    <span class="keyword">super</span>.move(distanceInMeters);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解释如何使用-TypeScript-mixin"><a href="#解释如何使用-TypeScript-mixin" class="headerlink" title="解释如何使用 TypeScript mixin"></a>解释如何使用 TypeScript mixin</h3><p>Mixin 本质上是在相反方向上工作的继承。Mixins 允许你通过组合以前类中更简单的部分类设置来构建新类。</p>
<p>相反，类A继承类B来获得它的功能，类B从类A需要返回一个新类的附加功能。</p>
<h3 id="TypeScript-中如何检查-null-和-undefined？"><a href="#TypeScript-中如何检查-null-和-undefined？" class="headerlink" title="TypeScript 中如何检查 null 和 undefined？"></a>TypeScript 中如何检查 null 和 undefined？</h3><p>你可以使用 juggle-check，它检查 null 和 undefined，或者使用 strict-check，它返回true设置为null的值，并且不会评估true未定义的变量。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//juggle</span></span><br><span class="line"><span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a: <span class="built_in">number</span>;  </span><br><span class="line"><span class="keyword">var</span> b: <span class="built_in">number</span> = <span class="literal">null</span>;  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">x, name</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="built_in">console</span>.log(name + <span class="string">' == null'</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (x === <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="built_in">console</span>.log(name + <span class="string">' === null'</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'undefined'</span>) &#123;  </span><br><span class="line">        <span class="built_in">console</span>.log(name + <span class="string">' is undefined'</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">check(a, <span class="string">'a'</span>);  </span><br><span class="line">check(b, <span class="string">'b'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="TypeScript-中的-getter-setter-是什么？你如何使用它们？"><a href="#TypeScript-中的-getter-setter-是什么？你如何使用它们？" class="headerlink" title="TypeScript 中的 getter/setter 是什么？你如何使用它们？"></a>TypeScript 中的 getter/setter 是什么？你如何使用它们？</h3><p>Getter 和 setter 是特殊类型的方法，可帮助你根据程序的需要委派对私有变量的不同级别的访问。</p>
<p>Getters 允许你引用一个值但不能编辑它。Setter 允许你更改变量的值，但不能查看其当前值。这些对于实现封装是必不可少的。</p>
<p>例如，新雇主可能能够了解get公司的员工人数，但无权set了解员工人数。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fullNameMaxLength = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Employee</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> _fullName: <span class="keyword">string</span> = <span class="string">""</span>;</span><br><span class="line">  <span class="function"><span class="keyword">get</span> <span class="title">fullName</span>(<span class="params"></span>): <span class="keyword">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._fullName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">set</span> <span class="title">fullName</span>(<span class="params">newName: <span class="keyword">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (newName &amp;&amp; newName.length &gt; fullNameMaxLength) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"fullName has a max length of "</span> + fullNameMaxLength);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>._fullName = newName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee();</span><br><span class="line">employee.fullName = <span class="string">"Bob Smith"</span>;</span><br><span class="line"><span class="keyword">if</span> (employee.fullName) &#123;</span><br><span class="line">  console.log(employee.fullName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何允许模块外定义的类可以访问？"><a href="#如何允许模块外定义的类可以访问？" class="headerlink" title="如何允许模块外定义的类可以访问？"></a>如何允许模块外定义的类可以访问？</h3><p>你可以使用export关键字打开模块以供在模块外使用。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Admin &#123;</span><br><span class="line">  <span class="comment">// use the export keyword in TypeScript to access the class outside</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> Employee &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, email: <span class="built_in">string</span></span>) &#123; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> alex = <span class="keyword">new</span> Employee(<span class="string">'alex'</span>, <span class="string">'alex@gmail.com'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The Admin variable will allow you to access the Employee class outside the module with the help of the export keyword in TypeScript</span></span><br><span class="line"><span class="keyword">let</span> nick = <span class="keyword">new</span> Admin.Employee(<span class="string">'nick'</span>, <span class="string">'nick@yahoo.com'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="如何使用-Typescript-将字符串转换为数字？"><a href="#如何使用-Typescript-将字符串转换为数字？" class="headerlink" title="如何使用 Typescript 将字符串转换为数字？"></a>如何使用 Typescript 将字符串转换为数字？</h3><p>与 JavaScript 类似，你可以使用parseInt或parseFloat函数分别将字符串转换为整数或浮点数。你还可以使用一元运算符+将字符串转换为最合适的数字类型，“3”成为整数，3而“3.14”成为浮点数3.14。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">"32"</span>;</span><br><span class="line"><span class="keyword">var</span> y: <span class="built_in">number</span> = +x;</span><br></pre></td></tr></table></figure>

<h3 id="什么是-map-文件，为什么-如何使用它？"><a href="#什么是-map-文件，为什么-如何使用它？" class="headerlink" title="什么是 .map 文件，为什么/如何使用它？"></a>什么是 .map 文件，为什么/如何使用它？</h3><p>甲.map文件是源地图，显示原始打字稿代码是如何解释成可用的JavaScript代码。它们有助于简化调试，因为你可以捕获任何奇怪的编译器行为。</p>
<p>调试工具还可以使用这些文件来允许你编辑底层的 TypeScript 而不是发出的 JavaScript 文件。</p>
<h3 id="TypeScript-中的类是什么？你如何定义它们？"><a href="#TypeScript-中的类是什么？你如何定义它们？" class="headerlink" title="TypeScript 中的类是什么？你如何定义它们？"></a>TypeScript 中的类是什么？你如何定义它们？</h3><p>类表示一组相关对象的共享行为和属性。</p>
<p>例如，我们的类可能是Student，其所有对象都具有该attendClass方法。另一方面，John是一个单独的 type 实例，Student可能有额外的独特行为，比如attendExtracurricular.</p>
<p>你使用关键字声明类class：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Student &#123;    </span><br><span class="line">    studCode: <span class="built_in">number</span>;    </span><br><span class="line">    studName: <span class="built_in">string</span>;    </span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">code: <span class="built_in">number</span>, name: <span class="built_in">string</span></span>) &#123;    </span><br><span class="line">            <span class="keyword">this</span>.studName = name;    </span><br><span class="line">            <span class="keyword">this</span>.studCode = code; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="TypeScript-与-JavaScript-有什么关系？"><a href="#TypeScript-与-JavaScript-有什么关系？" class="headerlink" title="TypeScript 与 JavaScript 有什么关系？"></a>TypeScript 与 JavaScript 有什么关系？</h3><p>TypeScript 是 JavaScript 的开源语法超集，可编译为 JavaScript。所有原始 JavaScript 库和语法仍然有效，但 TypeScript 增加了 JavaScript 中没有的额外语法选项和编译器功能。</p>
<p>TypeScript 还可以与大多数与 JavaScript 相同的技术接口，例如 Angular 和 jQuery。</p>
<h3 id="TypeScript-中的-JSX-是什么？"><a href="#TypeScript-中的-JSX-是什么？" class="headerlink" title="TypeScript 中的 JSX 是什么？"></a>TypeScript 中的 JSX 是什么？</h3><p>JSX 是一种可嵌入的类似于 XML 的语法，允许你创建 HTML。TypeScript 支持嵌入、类型检查和将 JSX 直接编译为 JavaScript。</p>
<h3 id="TypeScript-支持哪些-JSX-模式？"><a href="#TypeScript-支持哪些-JSX-模式？" class="headerlink" title="TypeScript 支持哪些 JSX 模式？"></a>TypeScript 支持哪些 JSX 模式？</h3><p>TypeScript有内置的支持preserve，react和react-native。</p>
<ul>
<li>preserve 保持 JSX 完整以用于后续转换。</li>
<li>react不经过 JSX 转换，而是react.createElement作为.js文件扩展名发出和输出。</li>
<li>react-native结合起来preserve，react因为它维护所有 JSX 和输出作为.js扩展。</li>
</ul>
<h3 id="如何编译-TypeScript-文件？"><a href="#如何编译-TypeScript-文件？" class="headerlink" title="如何编译 TypeScript 文件？"></a>如何编译 TypeScript 文件？</h3><p>你需要调用 TypeScript 编译器tsc来编译文件。你需要安装 TypeScript 编译器，你可以使用npm.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g typescript</span><br><span class="line"></span><br><span class="line">tsc &lt;TypeScript <span class="keyword">File</span> <span class="keyword">Name</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="TypeScript-中有哪些范围可用？这与JS相比如何？"><a href="#TypeScript-中有哪些范围可用？这与JS相比如何？" class="headerlink" title="TypeScript 中有哪些范围可用？这与JS相比如何？"></a>TypeScript 中有哪些范围可用？这与JS相比如何？</h3><ul>
<li>全局作用域：在任何类之外定义，可以在程序中的任何地方使用。</li>
<li>函数/类范围：在函数或类中定义的变量可以在该范围内的任何地方使用。</li>
<li>局部作用域/代码块：在局部作用域中定义的变量可以在该块中的任何地方使用。</li>
</ul>
<h3 id="TypeScript-中的箭头-lambda-函数是什么？"><a href="#TypeScript-中的箭头-lambda-函数是什么？" class="headerlink" title="TypeScript 中的箭头/lambda 函数是什么？"></a>TypeScript 中的箭头/lambda 函数是什么？</h3><p>胖箭头函数是用于定义匿名函数的函数表达式的速记语法。它类似于其他语言中的 lambda 函数。箭头函数可让你跳过function关键字并编写更简洁的代码。</p>
<h3 id="解释rest参数和声明rest参数的规则。"><a href="#解释rest参数和声明rest参数的规则。" class="headerlink" title="解释rest参数和声明rest参数的规则。"></a>解释rest参数和声明rest参数的规则。</h3><p>其余参数允许你将不同数量的参数（零个或多个）传递给函数。当你不确定函数将接收多少参数时，这很有用。其余符号之后的所有参数…都将存储在一个数组中。<br>例如：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">Greet</span>(<span class="params">greeting: <span class="keyword">string</span>, ...names: <span class="keyword">string</span>[]</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> greeting + <span class="string">" "</span> + names.<span class="keyword">join</span>(<span class="string">", "</span>) + <span class="string">"!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Greet(<span class="string">"Hello"</span>, <span class="string">"Steve"</span>, <span class="string">"Bill"</span>); <span class="comment">// returns "Hello Steve, Bill!"</span></span><br><span class="line">Greet(<span class="string">"Hello"</span>);<span class="comment">// returns "Hello !"</span></span><br></pre></td></tr></table></figure>

<p>rest 参数必须是参数定义的最后一个，并且每个函数只能有一个 rest 参数。</p>
<h3 id="什么是三斜线指令？有哪些三斜杠指令？"><a href="#什么是三斜线指令？有哪些三斜杠指令？" class="headerlink" title="什么是三斜线指令？有哪些三斜杠指令？"></a>什么是三斜线指令？有哪些三斜杠指令？</h3><p>三斜线指令是单行注释，包含用作编译器指令的 XML 标记。每个指令都表示在编译过程中要加载的内容。三斜杠指令仅在其文件的顶部工作，并且将被视为文件中其他任何地方的普通注释。</p>
<ul>
<li>/// <reference path="..."> 是最常见的指令，定义文件之间的依赖关系。</reference></li>
<li>/// <reference types="...">类似于path但定义了包的依赖项。</reference></li>
<li>/// <reference lib="...">允许您显式包含内置lib文件。</reference></li>
</ul>
<h3 id="Omit类型有什么作用？"><a href="#Omit类型有什么作用？" class="headerlink" title="Omit类型有什么作用？"></a>Omit类型有什么作用？</h3><p>Omit是实用程序类型的一种形式，它促进了常见的类型转换。Omit允许你通过传递电流Type并选择Keys在新类型中省略来构造类型。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Omit<span class="tag">&lt;<span class="name">Type,</span> <span class="attr">Keys</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  description: <span class="built_in">string</span>;</span><br><span class="line">  completed: <span class="built_in">boolean</span>;</span><br><span class="line">  createdAt: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> TodoPreview = Omit&lt;Todo, <span class="string">"description"</span>&gt;;</span><br></pre></td></tr></table></figure>

<h3 id="TypeScript中如何实现函数重载？"><a href="#TypeScript中如何实现函数重载？" class="headerlink" title="TypeScript中如何实现函数重载？"></a>TypeScript中如何实现函数重载？</h3><p>要在 TypeScript 中重载函数，只需创建两个名称相同但参数/返回类型不同的函数。两个函数必须接受相同数量的参数。这是 TypeScript 中多态性的重要组成部分。</p>
<p>例如，你可以创建一个add函数，如果它们是数字，则将两个参数相加，如果它们是字符串，则将它们连接起来。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a:<span class="built_in">string</span>, b:<span class="built_in">string</span></span>):<span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a:<span class="built_in">number</span>, b:<span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">any</span>, b:<span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="string">"Hello "</span>, <span class="string">"Steve"</span>); <span class="comment">// returns "Hello Steve" </span></span><br><span class="line">add(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// returns 30</span></span><br></pre></td></tr></table></figure>

<h3 id="如何让接口的所有属性都可选？"><a href="#如何让接口的所有属性都可选？" class="headerlink" title="如何让接口的所有属性都可选？"></a>如何让接口的所有属性都可选？</h3><p>你可以使用partial映射类型轻松地将所有属性设为可选。</p>
<h3 id="什么时候应该使用关键字unknown？"><a href="#什么时候应该使用关键字unknown？" class="headerlink" title="什么时候应该使用关键字unknown？"></a>什么时候应该使用关键字unknown？</h3><p>unknown，如果你不知道预先期望哪种类型，但想稍后分配它，则应该使用该any关键字，并且该关键字将不起作用。</p>
<h3 id="什么是装饰器，它们可以应用于什么？"><a href="#什么是装饰器，它们可以应用于什么？" class="headerlink" title="什么是装饰器，它们可以应用于什么？"></a>什么是装饰器，它们可以应用于什么？</h3><p>装饰器是一种特殊的声明，它允许你通过使用@<name>注释标记来一次性修改类或类成员。每个装饰器都必须引用一个将在运行时评估的函数。</name></p>
<p>例如，装饰器@sealed将对应于sealed函数。任何标有 的@sealed都将用于评估sealed函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sealed</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something with 'target' ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它们可以附加到：</p>
<ul>
<li>类声明</li>
<li>方法</li>
<li>配件</li>
<li>特性</li>
<li>参数</li>
</ul>
<p>注意：默认情况下不启用装饰器。要启用它们，你必须experimentalDecorators从tsconfig.json文件或命令行编辑编译器选项中的字段。</p>
<h3 id="ts中type和interface的区别？"><a href="#ts中type和interface的区别？" class="headerlink" title="ts中type和interface的区别？"></a>ts中type和interface的区别？</h3><h4 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h4><p>（1） 两者都可以定义对象和函数。</p>
<p>interface:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> interface Person&#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line">interface SetPerson &#123;</span><br><span class="line">  (name: string, age: number): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>type:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Person= &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number</span><br><span class="line">&#125;;</span><br><span class="line">type SetPerson = (name: string, age: number)=&gt; void;</span><br></pre></td></tr></table></figure>

<p>(2) 都可以继承。<br>interface 定义的对象用extends继承，type用&amp;继承。二者之间可以用前面提到的自己的语法互相继承。</p>
<h4 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h4><p>（1）interface可以声明合并，即声明了多个同样名称的接口可以合并成一个，而type不行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface Pesron&#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Person&#123;</span><br><span class="line">  sex: string;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">Person接口为 &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">  sex: string ;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>(2) type可以声明：基本类型的别名、联合类型、元组等类型，而interface不行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> // 别名</span><br><span class="line">type Empty=null;</span><br><span class="line">// 联合类型</span><br><span class="line">interface Person1&#123;</span><br><span class="line">	sayHi();</span><br><span class="line">&#125;</span><br><span class="line">interface Person2&#123;</span><br><span class="line">	eat();</span><br><span class="line">&#125;</span><br><span class="line">type Person = Person1 | Person2;</span><br><span class="line">type ex = number | string;</span><br><span class="line">// 元组 数组中元素的数据类型都一般是相同的（any[] 类型的数组可以不同），如果存储的元素数据类型不同，则需要使用元组。</span><br><span class="line">type tuple=[1,&apos;good&apos;];</span><br><span class="line">//type 语句中可以使用 typeof 获取实例的类型进行赋值</span><br><span class="line">let tem = new Number();</span><br><span class="line">type B = typeof tem;</span><br></pre></td></tr></table></figure>

<p>(3)还有其他复杂操作，泛型等。</p>
<h3 id="ts中interface和class的区别-分别什么时候使用？"><a href="#ts中interface和class的区别-分别什么时候使用？" class="headerlink" title="ts中interface和class的区别? 分别什么时候使用？"></a>ts中interface和class的区别? 分别什么时候使用？</h3><p>A2: interface和class都能定义数据模型。区别：……<br>区别：interface只是用来声明对象类型或方法，不做实现；而class是类的声明并实现。</p>
<p>简单的数据模型，直接用于展示的，用 interface 进行定义；<br>比较复杂的数据模型，有字段属性定义以及一些方法，就需要使用 class 。里面还有constructor构造函数。<br>interface 只在编译时用于类型检查，class 编译完成之后实际上就是 javascript 中的原型（prototype）。<br>接口可以通过extends继承类，类可以通过implements去实现接口。有个很好的例子帮助理解。</p>
<h3 id="ts中的泛型有什么了解？"><a href="#ts中的泛型有什么了解？" class="headerlink" title="ts中的泛型有什么了解？"></a>ts中的泛型有什么了解？</h3><h4 id="不用泛型的话，这个函数可能是下面这样："><a href="#不用泛型的话，这个函数可能是下面这样：" class="headerlink" title="不用泛型的话，这个函数可能是下面这样："></a>不用泛型的话，这个函数可能是下面这样：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function identity(arg: number): number &#123;</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者，我们使用any类型来定义函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function identity(arg: any): any &#123;</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>any的情况，可以是任何类型。因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。 这时，就用到了T，类型变量，它是一种特殊的变量，只用于表示类型而不是值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function identity&lt;T&gt;(arg: T): T &#123;</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以跟踪函数里使用的类型信息。</p>
<h4 id="泛型的使用方法有两种："><a href="#泛型的使用方法有两种：" class="headerlink" title="泛型的使用方法有两种："></a>泛型的使用方法有两种：</h4><p>此处参考官方文档改写。<br>(1) 尖括号的形式：<br>let output = identity&lt; string&gt; (“myString”);// type of output will be ‘string’<br>这里明确的指定了T是string类型，并做为一个参数传给函数，使用了&lt;&gt;括起来。</p>
<p>(2) 利用了类型推论，即编译器会根据传入的参数自动地帮助我们确定T的类型：<br>let output = identity(“myString”); // type of output will be ‘string’</p>
<h3 id="typescript-基础类型"><a href="#typescript-基础类型" class="headerlink" title="typescript 基础类型"></a>typescript 基础类型</h3><p>对象类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const test:&#123;</span><br><span class="line">    name:string,</span><br><span class="line">    age:number</span><br><span class="line">&#125; = &#123;</span><br><span class="line">    name:&apos;comix&apos;,</span><br><span class="line">    age:19</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>数组类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const testArry :string[] = [&apos;123&apos;,&apos;232&apos;]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>类类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;&#125;</span><br><span class="line">const test:Person = new Person()</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>函数类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const test:() =&gt; string = () =&gt; &#123;</span><br><span class="line">   return &apos;xiao&apos;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="type与interface-的区别"><a href="#type与interface-的区别" class="headerlink" title="type与interface 的区别"></a>type与interface 的区别</h3><p>ts中定义类型的两种方式:</p>
<p>接口（interface） 类型别名（type alias）</p>
<p>interface只能定义对象类型, type声明的方式可以定义组合类型、交叉类型和原始类型</p>
<p>相同点： 都可以描述一个对象或函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface User &#123;</span><br><span class="line"> name: string</span><br><span class="line"> age: number</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">interface SetUser &#123;</span><br><span class="line"> (name: string, age: number): void;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br><span class="line">type User = &#123;</span><br><span class="line"> name: string</span><br><span class="line"> age: number</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">type SetUser = (name: string, age: number): void;</span><br></pre></td></tr></table></figure>

<p>不同点：</p>
<ul>
<li>type 可以声明基本类型别名，联合类型，元组等类型</li>
<li>interface 能够声明合并，type不可以</li>
</ul>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2023-04-14T17:01:50.000Z" itemprop="dateUpdated">2023-04-15 01:01:50</time>
</span><br>


        
        感谢您的阅读，欢迎评论(*^▽^*) 转载请附上本文链接：<a href="/knowledges/typescript.html" target="_blank" rel="external">https://qw66.gitee.io/knowledges/typescript.html</a>
        
    </div>
    
    <footer>
        <a href="https://qw66.gitee.io">
            <img src="/img/avatar.jpg" alt="秦伟">
            秦伟
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TypeScript/">TypeScript</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://qw66.gitee.io/knowledges/typescript.html&title=《TypeScript》 — 秦伟博客&pic=https://qw66.gitee.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://qw66.gitee.io/knowledges/typescript.html&title=《TypeScript》 — 秦伟博客&source=前端、全栈、SEO的知识点、面试题与学习链接的整理" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://qw66.gitee.io/knowledges/typescript.html" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《TypeScript》 — 秦伟博客&url=https://qw66.gitee.io/knowledges/typescript.html&via=https://qw66.gitee.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://qw66.gitee.io/knowledges/typescript.html" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/knowledges/requirejs.html" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">RequireJS</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/knowledges/dom.html" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">DOM</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'false' == 'true',
            appId: "TJ17Ax10JrfIIljlO8qkwGvz-gzGzoHsz",
            appKey: "jDGQKdWT9hlzsTLRAbInE4bK",
            avatar: "mm",
            placeholder: "说点什么吧(*╹▽╹*)",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->










</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢您，我会继续努力哒(*^▽^*)
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.png" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

    <footer class="footer">
    <div class="top">
        <div class="map">
            <!--地球信息-->
<script type="text/javascript" src="/js/jquery-3.4.1.js"></script>
<script type="text/javascript">
    var windowWidth = $(window).width();
    if (windowWidth > 480) {
        document.write('<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5mz4gy0w2d8&amp;m=0&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33" async="async">  <\/script>');
    }
</script>
        </div>
        <p>
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>

</p>
        <p>
            <span>本网站总字数：832.4k</span>
            <span id="sitetime"></span>
        </p>
        <p>部分内容来源于互联网，用于个人知识的总结，如有侵权还请联系删除</p>
        <p>
            
            <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i
                    class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>

    <div class="bottom">
        <p>
            <span>Copyright &copy; 2019 - 2024 <a
                href="http://pdouyin.com/" target="_blank">秦伟的个人博客</a> All Rights Reserved.</span>
            <!-- <span>
                
                
            </span> -->
        </p>
    </div>
</footer>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2019, 8, 25, 18, 0, 0); // 北京时间
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "已安全运行 " + diffYears + "年 " + diffDays + "天 " + diffHours + "小时 " + diffMinutes + "分钟 " + diffSeconds + "秒";
    }
    siteTime();
</script>
</main>
<div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://qw66.gitee.io/knowledges/typescript.html&title=《TypeScript》 — 秦伟博客&pic=https://qw66.gitee.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://qw66.gitee.io/knowledges/typescript.html&title=《TypeScript》 — 秦伟博客&source=前端、全栈、SEO的知识点、面试题与学习链接的整理" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://qw66.gitee.io/knowledges/typescript.html" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《TypeScript》 — 秦伟博客&url=https://qw66.gitee.io/knowledges/typescript.html&via=https://qw66.gitee.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://qw66.gitee.io/knowledges/typescript.html" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACHElEQVR42u3aQU7EMAwFUO5/6bIdCan8b8NIk76sEHSmeVkYO/bXV7yul/X6m+TJ+2d+fuf9Z1cLAwPjYxnX7UqeuSfdb/H+gIo3YmBgPICRbCL5axsu76nJ3jAwMDBWQTAIte3xYWBgYGwCbhIuWzAGBgZGW8TeP7+5sHtrLY6BgfGBjFmp+Z6f/6W/gYGB8VGMq1w5dV/uFrvCwMA4mpEHuNl4xCyhnCWaGBgYZzPahmIyNpGneknDYJgsYmBgHMHIle3Q2KYl2bYZMDAwzmbMAuss1ctbDsP/GBgYGIcyZmnf7DjaoYrhtAgGBsZxjOQDfxXX26u6/BkMDIznMPLttolge6mXF8BREYuBgXEcY5MUzjbaYn7pxGJgYBzHaBO72WVc2xxtE1YMDIyzGcMIHVNnxXMb0DEwMJ7G2F/obxoPydvrsIuBgXEQ44rXLLzOmgerr8DAwDiC0aZc7SjYJoAWA/0YGBhHM9qNJoG4LYlzTATAwMA4lNEmZLNm5yxAF8eEgYHxAMamVdBez+1TwLofi4GBcRBjNpbalqltgyHaCQYGxqGMq1wz0iaYRlQMDIyjGZsGZ15wbsbFkuPAwMB4AqMdrZi9flboFgU2BgbGAxj5tjZjXvl1W3tYGBgYGO1VWtv4zAcvIh8GBsbjGfloV16O7gM3BgbGExj7ZkASjmfbjcI3BgbG0Yy2dHwPrA3iGBgYhzK+AVi27s3h9pgtAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '(つェ⊂)咦!跑去哪里了';
            clearTimeout(titleTime);
        } else {
            document.title = '欢迎回来━(*｀∀´*)ノ';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>




<!-- 点击特效 -->
<script type="text/javascript" src="/js/clicklove.js"></script>
<!--动态线条背景-->
<script type="text/javascript"
        color="220,220,220" opacity='0.7' zIndex="-2" count="200"
        src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>
<!-- 雪花特效 -->
<script type="text/javascript" src="/js/jquery-3.4.1.js"></script>
<script type="text/javascript">
    var windowWidth = $(window).width();
    if (windowWidth > 480) {
        document.write('<script type="text/javascript" src="/js/snow.js"><\/script>');
    }
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"position":"right","width":150,"height":300,"hOffset":-25,"vOffset":30},"mobile":{"show":false,"scale":1.2},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script><script>!function(e){var r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function t(){for(var c=0;c<r.length;c++)t=r[c],void 0,0<=(n=t.getBoundingClientRect()).top&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=r[c];t=o,n=function(){r=r.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}t(),e.addEventListener("scroll",function(){!function(t,n){clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)}(t,e)})}(this);</script></body>
</html>

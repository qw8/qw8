<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>React | 秦伟博客 | 前端、全栈、SEO的知识点、面试题与学习链接的整理</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="React,redux,组件">
    <meta name="description" content="React 是什么？React 不是 MV* 框架，用于构建用户界面的 JavaScript 库，侧重于 View 层 React 主要的原理：  虚拟 DOM + diff 算法 -&amp;gt; 不直接操作 DOM 对象 Components 组件 -&amp;gt; Virtual DOM 的节点 State 触发视图的渲染 -&amp;gt; 单向数据绑定 React 解决方案：React + Redux +">
<meta name="keywords" content="React,redux,组件">
<meta property="og:type" content="article">
<meta property="og:title" content="React">
<meta property="og:url" content="https://qw8.github.io/knowledges/react.html">
<meta property="og:site_name" content="秦伟博客">
<meta property="og:description" content="React 是什么？React 不是 MV* 框架，用于构建用户界面的 JavaScript 库，侧重于 View 层 React 主要的原理：  虚拟 DOM + diff 算法 -&amp;gt; 不直接操作 DOM 对象 Components 组件 -&amp;gt; Virtual DOM 的节点 State 触发视图的渲染 -&amp;gt; 单向数据绑定 React 解决方案：React + Redux +">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:updated_time" content="2023-04-14T17:01:50.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="React">
<meta name="twitter:description" content="React 是什么？React 不是 MV* 框架，用于构建用户界面的 JavaScript 库，侧重于 View 层 React 主要的原理：  虚拟 DOM + diff 算法 -&amp;gt; 不直接操作 DOM 对象 Components 组件 -&amp;gt; Virtual DOM 的节点 State 触发视图的渲染 -&amp;gt; 单向数据绑定 React 解决方案：React + Redux +">
<meta name="twitter:image" content="https://qw8.github.io/img/loading.gif">
    
        <link rel="alternate" type="application/atom+xml" title="秦伟博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/qw.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
<div id="loading" class="active"></div>

<aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">秦伟</h5>
          <a href="mailto:124729081@qq.com" title="124729081@qq.com" class="mail">124729081@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-hourglass"></i>
                时光
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://wpa.qq.com/msgrd?v=3&uin=124729081&site=qq&menu=yes" target="_blank" >
                <i class="icon icon-lg icon-qq"></i>
                聊天
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=124729081@qq.com"  >
                <i class="icon icon-lg icon-envelope-o"></i>
                邮箱
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/user"  >
                <i class="icon icon-lg icon-user"></i>
                简介
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://gitee.com/qw66" target="_blank" >
                <i class="icon icon-lg icon-code"></i>
                Gitee
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/qw8" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

<main id="main">
    <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">React</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">React</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-11-15T09:11:07.000Z" itemprop="datePublished" class="page-time">
  2019-11-15
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/前端知识点/">前端知识点</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#React-是什么？"><span class="post-toc-number">1.</span> <span class="post-toc-text">React 是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#React-组件生命周期"><span class="post-toc-number">2.</span> <span class="post-toc-text">React 组件生命周期</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#挂载"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">挂载</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#更新"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">更新</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#卸载"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">卸载</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#为啥要用Hook"><span class="post-toc-number">3.</span> <span class="post-toc-text">为啥要用Hook</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-Hook是React16-8的新增特性，它可以让我们在不编写class的情况下使用state以及其他的React特性（比如生命周期）。"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">1.Hook是React16.8的新增特性，它可以让我们在不编写class的情况下使用state以及其他的React特性（比如生命周期）。</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-class相比函数式组件的优势："><span class="post-toc-number">3.2.</span> <span class="post-toc-text">2.class相比函数式组件的优势：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-Class组件存在的问题："><span class="post-toc-number">3.3.</span> <span class="post-toc-text">3.Class组件存在的问题：</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Hook优点"><span class="post-toc-number">4.</span> <span class="post-toc-text">Hook优点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#React-中setState更新state何时同步何时异步？"><span class="post-toc-number">5.</span> <span class="post-toc-text">React 中setState更新state何时同步何时异步？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#要探究setState为什么可能是异步的，先了解setState执行后会发生什么？"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">要探究setState为什么可能是异步的，先了解setState执行后会发生什么？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#setState何时同步何时异步？"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">setState何时同步何时异步？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#React是怎样控制异步和同步的呢？"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">React是怎样控制异步和同步的呢？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#多个setState调用会合并处理"><span class="post-toc-number">5.4.</span> <span class="post-toc-text">多个setState调用会合并处理</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#参数为函数的setState用法"><span class="post-toc-number">5.5.</span> <span class="post-toc-text">参数为函数的setState用法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#在同一个事件处理程序中不要混用"><span class="post-toc-number">5.6.</span> <span class="post-toc-text">在同一个事件处理程序中不要混用</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#react-router-路由系统的实现原理？"><span class="post-toc-number">6.</span> <span class="post-toc-text">react-router 路由系统的实现原理？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#React-中-keys-的作用是什么？"><span class="post-toc-number">7.</span> <span class="post-toc-text">React 中 keys 的作用是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#传入-setState-函数的第二个参数的作用是什么？"><span class="post-toc-number">8.</span> <span class="post-toc-text">传入 setState 函数的第二个参数的作用是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#React-中-refs-的作用是什么"><span class="post-toc-number">9.</span> <span class="post-toc-text">React 中 refs 的作用是什么</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#在生命周期中的哪一步你应该发起-AJAX-请求"><span class="post-toc-number">10.</span> <span class="post-toc-text">在生命周期中的哪一步你应该发起 AJAX 请求</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#shouldComponentUpdate-的作用"><span class="post-toc-number">11.</span> <span class="post-toc-text">shouldComponentUpdate 的作用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何告诉-React-它应该编译生产环境版"><span class="post-toc-number">12.</span> <span class="post-toc-text">如何告诉 React 它应该编译生产环境版</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#概述下-React-中的事件处理逻辑"><span class="post-toc-number">13.</span> <span class="post-toc-text">概述下 React 中的事件处理逻辑</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#createElement-与-cloneElement-的区别是什么"><span class="post-toc-number">14.</span> <span class="post-toc-text">createElement 与 cloneElement 的区别是什么</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#redux中间件"><span class="post-toc-number">15.</span> <span class="post-toc-text">redux中间件</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#redux有什么缺点"><span class="post-toc-number">16.</span> <span class="post-toc-text">redux有什么缺点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#react组件的划分业务组件技术组件？"><span class="post-toc-number">17.</span> <span class="post-toc-text">react组件的划分业务组件技术组件？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#react生命周期函数"><span class="post-toc-number">18.</span> <span class="post-toc-text">react生命周期函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#react性能优化是哪个周期函数"><span class="post-toc-number">19.</span> <span class="post-toc-text">react性能优化是哪个周期函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#为什么虚拟dom会提高性能"><span class="post-toc-number">20.</span> <span class="post-toc-text">为什么虚拟dom会提高性能</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#diff算法"><span class="post-toc-number">21.</span> <span class="post-toc-text">diff算法?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#react性能优化方案"><span class="post-toc-number">22.</span> <span class="post-toc-text">react性能优化方案</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#当你调用-setState-的时候，发生了什么事？"><span class="post-toc-number">23.</span> <span class="post-toc-text">当你调用 setState 的时候，发生了什么事？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#React-项目用过什么脚手架（本题是开放性题目）"><span class="post-toc-number">24.</span> <span class="post-toc-text">React 项目用过什么脚手架（本题是开放性题目）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么时候在功能组件-Class-Component-上使用类组件-Functional-Component-？"><span class="post-toc-number">25.</span> <span class="post-toc-text">什么时候在功能组件( Class Component )上使用类组件( Functional Component )？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#React-中-keys-的作用是什么？-1"><span class="post-toc-number">26.</span> <span class="post-toc-text">React 中 keys 的作用是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#React-优势"><span class="post-toc-number">27.</span> <span class="post-toc-text">React 优势</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#react-diff-原理（常考，大厂必考）"><span class="post-toc-number">28.</span> <span class="post-toc-text">react diff 原理（常考，大厂必考）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#react-生命周期函数"><span class="post-toc-number">29.</span> <span class="post-toc-text">react 生命周期函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#shouldComponentUpdate-是做什么的？（react-性能优化是哪个周期函数？）"><span class="post-toc-number">30.</span> <span class="post-toc-text">shouldComponentUpdate 是做什么的？（react 性能优化是哪个周期函数？）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#为什么虚拟-dom-会提高性能-必考"><span class="post-toc-number">31.</span> <span class="post-toc-text">为什么虚拟 dom 会提高性能?(必考)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#React-中-refs-的作用是什么？"><span class="post-toc-number">32.</span> <span class="post-toc-text">React 中 refs 的作用是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#redux-有什么缺点"><span class="post-toc-number">33.</span> <span class="post-toc-text">redux 有什么缺点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#简述-flux-思想"><span class="post-toc-number">34.</span> <span class="post-toc-text">简述 flux 思想</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#了解-redux-么，说一下-redux-吧"><span class="post-toc-number">35.</span> <span class="post-toc-text">了解 redux 么，说一下 redux 吧</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#React-中有三种构建组件的方式"><span class="post-toc-number">36.</span> <span class="post-toc-text">React 中有三种构建组件的方式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#react-组件的划分业务组件技术组件？"><span class="post-toc-number">37.</span> <span class="post-toc-text">react 组件的划分业务组件技术组件？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#描述事件在-React-中的处理方式"><span class="post-toc-number">38.</span> <span class="post-toc-text">描述事件在 React 中的处理方式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#应该在-React-组件的何处发起-Ajax-请求"><span class="post-toc-number">39.</span> <span class="post-toc-text">应该在 React 组件的何处发起 Ajax 请求</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#在构造函数中-调用-super-props-的目的是什么"><span class="post-toc-number">40.</span> <span class="post-toc-text">(在构造函数中)调用 super(props) 的目的是什么</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#除了在构造函数中绑定-this，还有其它方式吗"><span class="post-toc-number">41.</span> <span class="post-toc-text">除了在构造函数中绑定 this，还有其它方式吗</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#为什么建议传递给-setState-的参数是一个-callback-而不是一个对象"><span class="post-toc-number">42.</span> <span class="post-toc-text">为什么建议传递给 setState 的参数是一个 callback 而不是一个对象</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#何为高阶组件-higher-order-component"><span class="post-toc-number">43.</span> <span class="post-toc-text">何为高阶组件(higher order component)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#何为受控组件-controlled-component"><span class="post-toc-number">44.</span> <span class="post-toc-text">何为受控组件(controlled component)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#在-React-当中-Element-和-Component-有何区别？"><span class="post-toc-number">45.</span> <span class="post-toc-text">在 React 当中 Element 和 Component 有何区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#组件的-状态-state-和属性-props-之间有何区别"><span class="post-toc-number">46.</span> <span class="post-toc-text">(组件的)状态(state)和属性(props)之间有何区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#展示组件-Presentational-component-和容器组件-Container-component-之间有何区别？"><span class="post-toc-number">47.</span> <span class="post-toc-text">展示组件(Presentational component)和容器组件(Container component)之间有何区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#类组件-Class-component-和-函数式组件-Functional-component-之间有何区别？"><span class="post-toc-number">48.</span> <span class="post-toc-text">类组件(Class component)和 函数式组件(Functional component)之间有何区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#createElement-和-cloneElement-有什么区别？"><span class="post-toc-number">49.</span> <span class="post-toc-text">createElement 和 cloneElement 有什么区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#setState-和-replaceState-的区别"><span class="post-toc-number">50.</span> <span class="post-toc-text">setState 和 replaceState 的区别</span></a></li></ol>
        </nav>
    </aside>


<article id="post-knowledges/React"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">React</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-11-15 17:11:07" datetime="2019-11-15T09:11:07.000Z"  itemprop="datePublished">2019-11-15</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/前端知识点/">前端知识点</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h3 id="React-是什么？"><a href="#React-是什么？" class="headerlink" title="React 是什么？"></a>React 是什么？</h3><p>React 不是 MV* 框架，用于构建用户界面的 JavaScript 库，侧重于 View 层</p>
<p>React 主要的原理：</p>
<ul>
<li>虚拟 DOM + diff 算法 -&gt; 不直接操作 DOM 对象</li>
<li>Components 组件 -&gt; Virtual DOM 的节点</li>
<li>State 触发视图的渲染 -&gt; 单向数据绑定</li>
<li>React 解决方案：React + Redux + react-router + Fetch + webpack</li>
</ul>
<h3 id="React-组件生命周期"><a href="#React-组件生命周期" class="headerlink" title="React 组件生命周期"></a>React 组件生命周期</h3><p>组件的生命周期可分成三个状态：</p>
<ul>
<li>Mounting(挂载)：已插入真实 DOM</li>
<li>Updating(更新)：正在被重新渲染</li>
<li>Unmounting(卸载)：已移出真实 DOM</li>
</ul>
<h4 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h4><p>当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：</p>
<ul>
<li><code>constructor()</code>: 在 React 组件挂载之前，会调用它的构造函数。</li>
<li><code>getDerivedStateFromProps()</code>: 在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。</li>
<li><code>render()</code>: render() 方法是 class 组件中唯一必须实现的方法。</li>
<li><code>componentDidMount()</code>: 在组件挂载后（插入 DOM 树中）立即调用。</li>
</ul>
<p>render() 方法是 class 组件中唯一必须实现的方法，其他方法可以根据自己的需要来实现。</p>
<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>每当组件的 state 或 props 发生变化时，组件就会更新。</p>
<p>当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下：</p>
<ul>
<li><code>getDerivedStateFromProps()</code>: 在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。根据 shouldComponentUpdate() 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。</li>
<li><code>shouldComponentUpdate()</code>:当 props 或 state 发生变化时，shouldComponentUpdate() 会在渲染执行之前被调用。</li>
<li><code>render()</code>: render() 方法是 class 组件中唯一必须实现的方法。</li>
<li><code>getSnapshotBeforeUpdate()</code>: 在最近一次渲染输出（提交到 DOM 节点）之前调用。</li>
<li><code>componentDidUpdate()</code>: 在更新后会被立即调用。</li>
</ul>
<p>render() 方法是 class 组件中唯一必须实现的方法，其他方法可以根据自己的需要来实现。</p>
<h4 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h4><p>当组件从 DOM 中移除时会调用如下方法：</p>
<ul>
<li><code>componentWillUnmount()</code>: 在组件卸载及销毁之前直接调用。</li>
</ul>
<h3 id="为啥要用Hook"><a href="#为啥要用Hook" class="headerlink" title="为啥要用Hook"></a>为啥要用Hook</h3><h4 id="1-Hook是React16-8的新增特性，它可以让我们在不编写class的情况下使用state以及其他的React特性（比如生命周期）。"><a href="#1-Hook是React16-8的新增特性，它可以让我们在不编写class的情况下使用state以及其他的React特性（比如生命周期）。" class="headerlink" title="1.Hook是React16.8的新增特性，它可以让我们在不编写class的情况下使用state以及其他的React特性（比如生命周期）。"></a>1.Hook是React16.8的新增特性，它可以让我们在不编写class的情况下使用state以及其他的React特性（比如生命周期）。</h4><h4 id="2-class相比函数式组件的优势："><a href="#2-class相比函数式组件的优势：" class="headerlink" title="2.class相比函数式组件的优势："></a>2.class相比函数式组件的优势：</h4><p>class组件内部可以定义自己的state，用来保存组件自己内部的状态；函数式组件不可以，因为函数每次调用都会产生新的临时变量。<br>class组件有自己的生命周期，可以在对应的生命周期中完成自己的逻辑；比如在componentDidMount中发送网络请求，并且该生命周期函数只会执行一次；函数式组件在学习hooks之前，如果在函数中发送网络请求，意味着每次重新渲染都会重新发送一次网络请求。<br>class组件可以在状态改变时只重新执行render函数以及我们希望重新调用的生命周期函数componentDidUpdate等；函数式组件在重新渲染时，整个函数都会被执行，似乎没有什么地方可以只让它们调用一次；<br>在Hook之前，以上情况通常都用class。</p>
<h4 id="3-Class组件存在的问题："><a href="#3-Class组件存在的问题：" class="headerlink" title="3.Class组件存在的问题："></a>3.Class组件存在的问题：</h4><p>复杂组件变得难以理解： 最初编写class组件时，往往逻辑比较简单，但是业务增多，class组件就会越来越复杂；<br>比如componentDidMount中，可能就会有大量逻辑代码，包括网络请求，一些事件的监听（还需要在componentWillUnmount中移除）；<br>而对于这样的class实际上很难拆分，因为这些逻辑往往混在一起，强行拆分反而会造成过度设计，增加代码的复杂度。<br>难以理解的class： ES6中class相当于React的一个障碍；<br>在class中，我们必须搞清楚this的指向到底是谁，所以需要花很多的精力去学习this； 虽然掌握this是必要，但是处理起来依然很麻烦<br>组件复用状态很难： 在之前为了一些状态的复用，我们需要通过高阶组件或render props；<br>像redux中connect或者react-route中的withRouter，这些高阶组件设计的目的就是为了状态的复用。<br>或者类似于Provider，Consumer来共享一些状态，但是多次使用Consumer时，就会有很多嵌套；</p>
<h3 id="Hook优点"><a href="#Hook优点" class="headerlink" title="Hook优点"></a>Hook优点</h3><p>可以让我们在不编写class的情况下使用state以及其他的React特性；也可以延伸很多用法解决上述问题。</p>
<p>Hook使用场景： Hook的出现基本可以替代class组件（除了个别场景）；<br>若项目比较旧，并不需要直接将所有代码重构为Hooks，因为它完全向下兼容，可以渐进式地来使用；<br>Hook只能在函数组件中使用，不能在类组件，或者函数组件之外的地方使用；</p>
<h3 id="React-中setState更新state何时同步何时异步？"><a href="#React-中setState更新state何时同步何时异步？" class="headerlink" title="React 中setState更新state何时同步何时异步？"></a>React 中setState更新state何时同步何时异步？</h3><p>React中constructor是唯一可以初始化state的地方，也可以把它理解成一个钩子函数，该函数最先执行且只执行一次。</p>
<p>更新状态不要直接修改this.state。虽然状态可以改变，但不会触发组件的更新。</p>
<p>应当使用this.setState()，该方法接收两种参数：对象或函数。</p>
<ol>
<li>对象：即想要修改的state</li>
<li>函数：接收两个函数，第一个函数接受两个参数，第一个是当前state，第二个是当前props，该函数返回一个对象，和直接传递对象参数是一样的，就是要修改的state；第二个函数参数是state改变后触发的回调。</li>
</ol>
<p>回到主题，setState可能是异步的。对此官方有这样一段描述：setState() does not always immediately update the component. It may batch or defer the update until later. This makes reading this.state right after calling setState()a potential pitfall.</p>
<p>关键词：batch、defer、may。</p>
<h4 id="要探究setState为什么可能是异步的，先了解setState执行后会发生什么？"><a href="#要探究setState为什么可能是异步的，先了解setState执行后会发生什么？" class="headerlink" title="要探究setState为什么可能是异步的，先了解setState执行后会发生什么？"></a>要探究setState为什么可能是异步的，先了解setState执行后会发生什么？</h4><p>事实上setState内部执行过程是很复杂的，大致过程包括更新state，创建新的VNode，再经过diff算法比对差异，决定渲染哪一部分以及怎么渲染，最终形成最新的UI。这一过程包含组件的四个生命周期函数。</p>
<ul>
<li>shouleComponentUpdate</li>
<li>componentWillUpdate</li>
<li>render</li>
<li>componentDidUpdate</li>
</ul>
<p>需要注意的是如果子组件的数据依赖于父组件，还会执行一个钩子函数<code>componentWillReceiveProps</code>。</p>
<p>假如setState是同步更新的，每更新一次，这个过程都要完整执行一次，无疑会造成性能问题。事实上这些生命周期为纯函数，对性能还好，但是diff比较、更新DOM总消耗时间和性能吧。</p>
<p>此外为了批次和效能，多个setState有可能在执行过程中还会被合并，所以setState延时异步更新是很合理的。</p>
<h4 id="setState何时同步何时异步？"><a href="#setState何时同步何时异步？" class="headerlink" title="setState何时同步何时异步？"></a>setState何时同步何时异步？</h4><p><strong>由React控制的事件处理程序，以及生命周期函数调用setState不会同步更新state</strong> 。</p>
<p><strong>React控制之外的事件中调用setState是同步更新的。比如原生js绑定的事件，setTimeout/setInterval等</strong>。</p>
<p>大部分开发中用到的都是React封装的事件，比如onChange、onClick、onTouchMove等，这些事件处理程序中的setState都是异步处理的。</p>
<p>看以下case：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>() &#123;</span><br><span class="line">  <span class="keyword">this</span>.state = &#123;</span><br><span class="line">    count: <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.handleClickOne = <span class="keyword">this</span>.handleClickOne.bind(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">this</span>.handleClickTwo = <span class="keyword">this</span>.handleClickTwo.bind(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button onClick=&#123;<span class="keyword">this</span>.hanldeClickOne&#125;&gt;clickOne&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button onClick=&#123;this.hanldeClickTwo&#125;&gt;clickTwo&lt;/</span>button&gt;</span><br><span class="line">    &lt;button id=<span class="string">"btn"</span>&gt;clickTwo&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">handleClickOne() &#123;</span></span><br><span class="line"><span class="regexp">  this.setState(&#123; count: this.state.count + 1&#125;)</span></span><br><span class="line"><span class="regexp">  console.log(this.state.count)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>输出：10</p>
<p>由此可以看出该事件处理程序中的setState是异步更新state的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>).addEventListener(<span class="string">'clcik'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span>&#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出： 11</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">handleClickTwo() &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span>&#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count)</span><br><span class="line">  &#125;, <span class="number">10</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出： 11</p>
<p>以上两种方式绕过React，通过js的事件绑定程序 addEventListener 和使用setTimeout/setInterval 等 React 无法掌控的 APIs情况下，setState是同步更新state。</p>
<h4 id="React是怎样控制异步和同步的呢？"><a href="#React是怎样控制异步和同步的呢？" class="headerlink" title="React是怎样控制异步和同步的呢？"></a>React是怎样控制异步和同步的呢？</h4><p>在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到队列中延时更新，而 isBatchingUpdates 默认是 false，表示 setState 会同步更新 this.state；但是，有一个函数 batchedUpdates，该函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会先调用这个 batchedUpdates将isBatchingUpdates修改为true，这样由 React 控制的事件处理过程 setState 不会同步更新 this.state。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/5256541-992ce78e70151b57.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/720/format/webp" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<h4 id="多个setState调用会合并处理"><a href="#多个setState调用会合并处理" class="headerlink" title="多个setState调用会合并处理"></a>多个setState调用会合并处理</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'render'</span>)</span><br><span class="line">&#125;</span><br><span class="line">hanldeClick() &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">name</span>: <span class="string">'jack'</span> &#125;)</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">age</span>: <span class="number">12</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在hanldeClick处理程序中调用了两次setState，但是render只执行了一次。因为React会将多个this.setState产生的修改放在一个队列里进行批延时处理。</p>
<h4 id="参数为函数的setState用法"><a href="#参数为函数的setState用法" class="headerlink" title="参数为函数的setState用法"></a>参数为函数的setState用法</h4><p>先看以下case：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">handleClick() &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上操作存在潜在的陷阱，不应该依靠它们的值来计算下一个状态。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">handleClick() &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终的结果只加了1</p>
<p>因为调用this.setState时，并没有立即更改this.state，所以this.setState只是在反复设置同一个值而已，上面的代码等同于这样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">handleClick() &#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="keyword">this</span>.state.count</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    count: count + <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    count: count + <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    count: count + <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>count相当于一个快照，所以不管重复多少次，结果都是加1。</p>
<p>此外假如setState更新state后我希望做一些事情，而setState可能是异步的，那我怎么知道它什么时候执行完成。所以setState提供了函数式用法，接收两个函数参数，第一个函数调用更新state，第二个函数是更新完之后的回调。</p>
<p>第一个函数接收先前的状态作为第一个参数，将此次更新被应用时的props做为第二个参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">increment(state, props) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    count: state.count + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleClick() &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="keyword">this</span>.increment)</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="keyword">this</span>.increment)</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="keyword">this</span>.increment)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果: 13</p>
<p>对于多次调用函数式setState的情况，React会保证调用每次increment时，state都已经合并了之前的状态修改结果。</p>
<p>也就是说，第一次调用this.setState(increment)，传给increment的state参数的count是10，第二调用是11，第三次调用是12，最终handleClick执行完成后的结果就是this.state.count变成了13。</p>
<p>值得注意的是：在increment函数被调用时，this.state并没有被改变，依然要等到render函数被重新执行时（或者shouldComponentUpdate函数返回false之后）才被改变，因为render只执行一次。</p>
<p>让setState接受一个函数的API的设计是相当棒的！不仅符合函数式编程的思想，让开发者写出没有副作用的函数，而且我们并不去修改组件状态，只是把要改变的状态和结果返回给React，维护状态的活完全交给React去做。正是把流程的控制权交给了React，所以React才能协调多个setState调用的关系。</p>
<h4 id="在同一个事件处理程序中不要混用"><a href="#在同一个事件处理程序中不要混用" class="headerlink" title="在同一个事件处理程序中不要混用"></a>在同一个事件处理程序中不要混用</h4><p>case:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">increment(state, props) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    count: state.count + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleClick() &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="keyword">this</span>.increment)</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;)</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="keyword">this</span>.increment)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果： 12</p>
<p>第一次执行setState，count为11，第二次执行，this.state仍然是没有更新的状态，所以this.state.count又打回了原形为10，加1以后变成11，最后再执行setState，所以最终count的结果是12。（render依然只执行一次）</p>
<p>setState的第二个回调参数会在更新state，重新触发render后执行。</p>
<h3 id="react-router-路由系统的实现原理？"><a href="#react-router-路由系统的实现原理？" class="headerlink" title="react-router 路由系统的实现原理？"></a>react-router 路由系统的实现原理？</h3><ul>
<li>实现原理：location 与 components 之间的同步</li>
</ul>
<ul>
<li>路由的职责是保证 UI 和 URL 的同步</li>
<li>在 react-router 中，URL 对应 Location 对象，UI 由 react components 决定</li>
<li>因此，路由在 react-router 中就转变成 location 与 components 之间的同步</li>
</ul>
<h3 id="React-中-keys-的作用是什么？"><a href="#React-中-keys-的作用是什么？" class="headerlink" title="React 中 keys 的作用是什么？"></a>React 中 keys 的作用是什么？</h3><blockquote>
<p>Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识</p>
</blockquote>
<ul>
<li>在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性</li>
</ul>
<h3 id="传入-setState-函数的第二个参数的作用是什么？"><a href="#传入-setState-函数的第二个参数的作用是什么？" class="headerlink" title="传入 setState 函数的第二个参数的作用是什么？"></a>传入 setState 函数的第二个参数的作用是什么？</h3><blockquote>
<p>该函数会在setState函数调用完成并且组件开始重渲染的时候被调用，我们可以用该函数来监听渲染是否完成：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.setState(</span><br><span class="line">  &#123; username: &apos;tylermcginnis33&apos; &#125;,</span><br><span class="line">  () =&gt; console.log(&apos;setState has finished and the component has re-rendered.&apos;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this.setState((prevState, props) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    streak: prevState.streak + props.count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="React-中-refs-的作用是什么"><a href="#React-中-refs-的作用是什么" class="headerlink" title="React 中 refs 的作用是什么"></a>React 中 refs 的作用是什么</h3><ul>
<li>Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄</li>
<li>可以为元素添加ref属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回</li>
</ul>
<h3 id="在生命周期中的哪一步你应该发起-AJAX-请求"><a href="#在生命周期中的哪一步你应该发起-AJAX-请求" class="headerlink" title="在生命周期中的哪一步你应该发起 AJAX 请求"></a>在生命周期中的哪一步你应该发起 AJAX 请求</h3><blockquote>
<p>我们应当将AJAX 请求放到 <code>componentDidMount</code> 函数中执行，主要原因有下</p>
</blockquote>
<ul>
<li>React 下一代调和算法 Fiber 会通过开始或停止渲染的方式优化应用性能，其会影响到 componentWillMount 的触发次数。对于 componentWillMount 这个生命周期函数的调用次数会变得不确定，React 可能会多次频繁调用 componentWillMount。如果我们将 AJAX 请求放到 componentWillMount 函数中，那么显而易见其会被触发多次，自然也就不是好的选择。</li>
<li>如果我们将 AJAX 请求放置在生命周期的其他函数中，我们并不能保证请求仅在组件挂载完毕后才会要求响应。如果我们的数据请求在组件挂载之前就完成，并且调用了setState函数将数据添加到组件状态中，对于未挂载的组件则会报错。而在 componentDidMount 函数中进行 AJAX 请求则能有效避免这个问题</li>
</ul>
<h3 id="shouldComponentUpdate-的作用"><a href="#shouldComponentUpdate-的作用" class="headerlink" title="shouldComponentUpdate 的作用"></a>shouldComponentUpdate 的作用</h3><blockquote>
<p>shouldComponentUpdate 允许我们手动地判断是否要进行组件更新，根据组件的应用场景设置函数的合理返回值能够帮我们避免不必要的更新</p>
</blockquote>
<h3 id="如何告诉-React-它应该编译生产环境版"><a href="#如何告诉-React-它应该编译生产环境版" class="headerlink" title="如何告诉 React 它应该编译生产环境版"></a>如何告诉 React 它应该编译生产环境版</h3><blockquote>
<p>通常情况下我们会使用 Webpack 的 DefinePlugin 方法来将 NODE_ENV 变量值设置为 production。编译版本中 React 会忽略 propType 验证以及其他的告警信息，同时还会降低代码库的大小，React 使用了 Uglify 插件来移除生产环境下不必要的注释等信息</p>
</blockquote>
<h3 id="概述下-React-中的事件处理逻辑"><a href="#概述下-React-中的事件处理逻辑" class="headerlink" title="概述下 React 中的事件处理逻辑"></a>概述下 React 中的事件处理逻辑</h3><blockquote>
<p>为了解决跨浏览器兼容性问题，React 会将浏览器原生事件（Browser Native Event）封装为合成事件（SyntheticEvent）传入设置的事件处理器中。这里的合成事件提供了与原生事件相同的接口，不过它们屏蔽了底层浏览器的细节差异，保证了行为的一致性。另外有意思的是，React 并没有直接将事件附着到子元素上，而是以单一事件监听器的方式将所有的事件发送到顶层进行处理。这样 React 在更新 DOM 的时候就不需要考虑如何去处理附着在 DOM 上的事件监听器，最终达到优化性能的目的</p>
</blockquote>
<h3 id="createElement-与-cloneElement-的区别是什么"><a href="#createElement-与-cloneElement-的区别是什么" class="headerlink" title="createElement 与 cloneElement 的区别是什么"></a>createElement 与 cloneElement 的区别是什么</h3><blockquote>
<p>createElement 函数是 JSX 编译之后使用的创建 React Element 的函数，而 cloneElement 则是用于复制某个元素并传入新的 Props</p>
</blockquote>
<h3 id="redux中间件"><a href="#redux中间件" class="headerlink" title="redux中间件"></a>redux中间件</h3><blockquote>
<p>中间件提供第三方插件的模式，自定义拦截 action -&gt; reducer 的过程。变为 action -&gt; middlewares -&gt; reducer 。这种机制可以让我们改变数据流，实现如异步 action ，action 过滤，日志输出，异常报告等功能</p>
</blockquote>
<ul>
<li><code>redux-logger</code>：提供日志输出</li>
<li><code>redux-thunk</code>：处理异步操作</li>
<li><code>redux-promise</code>：处理异步操作，<code>actionCreator</code>的返回值是<code>promise</code></li>
</ul>
<h3 id="redux有什么缺点"><a href="#redux有什么缺点" class="headerlink" title="redux有什么缺点"></a>redux有什么缺点</h3><ul>
<li>一个组件所需要的数据，必须由父组件传过来，而不能像flux中直接从store取。</li>
<li>当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新render，可能会有效率影响，或者需要写复杂的<code>shouldComponentUpdate</code>进行判断。</li>
</ul>
<h3 id="react组件的划分业务组件技术组件？"><a href="#react组件的划分业务组件技术组件？" class="headerlink" title="react组件的划分业务组件技术组件？"></a>react组件的划分业务组件技术组件？</h3><ul>
<li>根据组件的职责通常把组件分为UI组件和容器组件。</li>
<li>UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。</li>
<li>两者通过<code>React-Redux</code> 提供<code>connect</code>方法联系起来</li>
</ul>
<h3 id="react生命周期函数"><a href="#react生命周期函数" class="headerlink" title="react生命周期函数"></a>react生命周期函数</h3><p><strong>初始化阶段</strong></p>
<ul>
<li><code>getDefaultProp</code>s:获取实例的默认属性</li>
<li><code>getInitialState</code>:获取每个实例的初始化状态</li>
<li><code>componentWillMount</code>：组件即将被装载、渲染到页面上</li>
<li><code>render</code>:组件在这里生成虚拟的DOM节点</li>
<li><code>omponentDidMount</code>:组件真正在被装载之后</li>
</ul>
<p><strong>运行中状态</strong></p>
<ul>
<li><code>componentWillReceiveProps</code>:组件将要接收到属性的时候调用</li>
<li><code>shouldComponentUpdate</code>:组件接受到新属性或者新状态的时候（可以返回false，接收数据后不更新，阻止<code>render</code>调用，后面的函数不会被继续执行了）</li>
<li><code>componentWillUpdate</code>:组件即将更新不能修改属性和状态</li>
<li><code>render</code>:组件重新描绘</li>
<li><code>componentDidUpdate</code>:组件已经更新</li>
</ul>
<p><strong>销毁阶段</strong></p>
<ul>
<li><code>componentWillUnmount</code>:组件即将销毁</li>
</ul>
<h3 id="react性能优化是哪个周期函数"><a href="#react性能优化是哪个周期函数" class="headerlink" title="react性能优化是哪个周期函数"></a>react性能优化是哪个周期函数</h3><blockquote>
<p>shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom。因为dom的描绘非常消耗性能，如果我们能在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高性能</p>
</blockquote>
<h3 id="为什么虚拟dom会提高性能"><a href="#为什么虚拟dom会提高性能" class="headerlink" title="为什么虚拟dom会提高性能"></a>为什么虚拟dom会提高性能</h3><blockquote>
<p>虚拟dom相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操作，从而提高性能</p>
</blockquote>
<p><strong>具体实现步骤如下</strong></p>
<ul>
<li>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中</li>
<li>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异</li>
<li>把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新</li>
</ul>
<h3 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法?"></a>diff算法?</h3><ul>
<li>把树形结构按照层级分解，只比较同级元素。</li>
<li>给列表结构的每个单元添加唯一的key属性，方便比较。</li>
<li>React 只会匹配相同 class 的 component（这里面的class指的是组件的名字）</li>
<li>合并操作，调用 component 的 setState 方法的时候, React 将其标记为 - dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.</li>
<li>选择性子树渲染。开发人员可以重写shouldComponentUpdate提高diff的性能</li>
</ul>
<h3 id="react性能优化方案"><a href="#react性能优化方案" class="headerlink" title="react性能优化方案"></a>react性能优化方案</h3><ul>
<li>重写<code>shouldComponentUpdate</code>来避免不必要的dom操作</li>
<li>使用 production 版本的react.js</li>
<li>使用key来帮助React识别列表中所有子组件的最小变化</li>
</ul>
<h3 id="当你调用-setState-的时候，发生了什么事？"><a href="#当你调用-setState-的时候，发生了什么事？" class="headerlink" title="当你调用 setState 的时候，发生了什么事？"></a>当你调用 setState 的时候，发生了什么事？</h3><p>将传递给 setState 的对象合并到组件的当前状态，这将启动一个和解的过程，构建一个新的 react 元素树，与上一个元素树进行对比（ diff ），从而进行最小化的重渲染。</p>
<h3 id="React-项目用过什么脚手架（本题是开放性题目）"><a href="#React-项目用过什么脚手架（本题是开放性题目）" class="headerlink" title="React 项目用过什么脚手架（本题是开放性题目）"></a>React 项目用过什么脚手架（本题是开放性题目）</h3><p>creat-react-app Yeoman 等</p>
<h3 id="什么时候在功能组件-Class-Component-上使用类组件-Functional-Component-？"><a href="#什么时候在功能组件-Class-Component-上使用类组件-Functional-Component-？" class="headerlink" title="什么时候在功能组件( Class Component )上使用类组件( Functional Component )？"></a>什么时候在功能组件( Class Component )上使用类组件( Functional Component )？</h3><p>如果您的组件具有状态( state ) 或 生命周期方法，请使用 Class 组件。否则，使用功能组件</p>
<h3 id="React-中-keys-的作用是什么？-1"><a href="#React-中-keys-的作用是什么？-1" class="headerlink" title="React 中 keys 的作用是什么？"></a>React 中 keys 的作用是什么？</h3><p>Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;<span class="keyword">this</span>.state.todoItems.map(<span class="function">(<span class="params">&#123;item, key&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;key&#125;</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">      &#125;)&#125;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性。</p>
<h3 id="React-优势"><a href="#React-优势" class="headerlink" title="React 优势"></a>React 优势</h3><p>1、React 速度很快：它并不直接对 DOM 进行操作，引入了一个叫做虚拟 DOM 的概念，安插在 javascript 逻辑和实际的 DOM 之间，性能好。</p>
<p>2、跨浏览器兼容：虚拟 DOM 帮助我们解决了跨浏览器问题，它为我们提供了标准化的 API，甚至在 IE8 中都是没问题的。</p>
<p>3、一切都是 component：代码更加模块化，重用代码更容易，可维护性高。</p>
<p>4、单向数据流：Flux 是一个用于在 JavaScript 应用中创建单向数据层的架构，它随着 React 视图库的开发而被 Facebook 概念化。</p>
<p>5、同构、纯粹的 javascript：因为搜索引擎的爬虫程序依赖的是服务端响应而不是 JavaScript 的执行，预渲染你的应用有助于搜索引擎优化。</p>
<p>6、兼容性好：比如使用 RequireJS 来加载和打包，而 Browserify 和 Webpack 适用于构建大型应用。它们使得那些艰难的任务不再让人望而生畏。</p>
<h3 id="react-diff-原理（常考，大厂必考）"><a href="#react-diff-原理（常考，大厂必考）" class="headerlink" title="react diff 原理（常考，大厂必考）"></a>react diff 原理（常考，大厂必考）</h3><p>把树形结构按照层级分解，只比较同级元素。</p>
<p>给列表结构的每个单元添加唯一的 key 属性，方便比较。</p>
<p>React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）<br>合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.</p>
<p>选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。</p>
<h3 id="react-生命周期函数"><a href="#react-生命周期函数" class="headerlink" title="react 生命周期函数"></a>react 生命周期函数</h3><ul>
<li>初始化阶段：<ul>
<li>getDefaultProps:获取实例的默认属性</li>
<li>getInitialState:获取每个实例的初始化状态</li>
<li>componentWillMount：组件即将被装载、渲染到页面上</li>
<li>render:组件在这里生成虚拟的 DOM 节点</li>
<li>componentDidMount:组件真正在被装载之后</li>
</ul>
</li>
<li>运行中状态：<ul>
<li>componentWillReceiveProps:组件将要接收到属性的时候调用</li>
<li>shouldComponentUpdate:组件接受到新属性或者新状态的时候（可以返回 false，接收数据后不更新，阻止 render 调用，后面的函数不会被继续执行了）</li>
<li>componentWillUpdate:组件即将更新不能修改属性和状态</li>
<li>render:组件重新描绘</li>
<li>componentDidUpdate:组件已经更新</li>
</ul>
</li>
<li>销毁阶段：<ul>
<li>componentWillUnmount:组件即将销毁</li>
</ul>
</li>
</ul>
<p>解析：有三大阶段，每阶段的细分 5-5-1</p>
<h3 id="shouldComponentUpdate-是做什么的？（react-性能优化是哪个周期函数？）"><a href="#shouldComponentUpdate-是做什么的？（react-性能优化是哪个周期函数？）" class="headerlink" title="shouldComponentUpdate 是做什么的？（react 性能优化是哪个周期函数？）"></a>shouldComponentUpdate 是做什么的？（react 性能优化是哪个周期函数？）</h3><p>shouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。</p>
<h3 id="为什么虚拟-dom-会提高性能-必考"><a href="#为什么虚拟-dom-会提高性能-必考" class="headerlink" title="为什么虚拟 dom 会提高性能?(必考)"></a>为什么虚拟 dom 会提高性能?(必考)</h3><p>虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。</p>
<p>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。</p>
<h3 id="React-中-refs-的作用是什么？"><a href="#React-中-refs-的作用是什么？" class="headerlink" title="React 中 refs 的作用是什么？"></a>React 中 refs 的作用是什么？</h3><p>Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。我们可以为元素添加 ref 属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomForm</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleSubmit = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Input Value: "</span>, <span class="keyword">this</span>.input.value);</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> ref=&#123;input =&gt; (<span class="keyword">this</span>.input = input)&#125; /&gt;</span><br><span class="line">        &lt;button type=<span class="string">"submit"</span>&gt;Submit&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中的 input 域包含了一个 ref 属性，该属性声明的回调函数会接收 input 对应的 DOM 元素，我们将其绑定到 this 指针以便在其他的类函数中使用。另外值得一提的是，refs 并不是类组件的专属，函数式组件同样能够利用闭包暂存其值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomForm</span>(<span class="params">&#123; handleSubmit &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> inputElement;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form onSubmit=&#123;() =&gt; handleSubmit(inputElement.value)&#125;&gt;</span><br><span class="line">      &lt;input type=<span class="string">"text"</span> ref=&#123;input =&gt; (inputElement = input)&#125; /&gt;</span><br><span class="line">      &lt;button type=<span class="string">"submit"</span>&gt;Submit&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="redux-有什么缺点"><a href="#redux-有什么缺点" class="headerlink" title="redux 有什么缺点"></a>redux 有什么缺点</h3><ul>
<li>一个组件所需要的数据，必须由父组件传过来，而不能像 flux 中直接从 store 取。</li>
<li>当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新 render，可能会有效率影响，或者需要写复杂的 shouldComponentUpdate 进行判断。</li>
</ul>
<h3 id="简述-flux-思想"><a href="#简述-flux-思想" class="headerlink" title="简述 flux 思想"></a>简述 flux 思想</h3><p>Flux 的最大特点，就是数据的”单向流动”。</p>
<ol>
<li>用户访问 View</li>
<li>View 发出用户的 Action</li>
<li>Dispatcher 收到 Action，要求 Store 进行相应的更新</li>
<li>Store 更新后，发出一个”change”事件</li>
<li>View 收到”change”事件后，更新页面</li>
</ol>
<h3 id="了解-redux-么，说一下-redux-吧"><a href="#了解-redux-么，说一下-redux-吧" class="headerlink" title="了解 redux 么，说一下 redux 吧"></a>了解 redux 么，说一下 redux 吧</h3><ul>
<li>redux 是一个应用数据流框架，主要是解决了组件间状态共享的问题，原理是集中式管理，主要有三个核心方法，action，store，reducer，工作流程是 view 调用 store 的 dispatch 接收 action 传入 store，reducer 进行 state 操作，view 通过 store 提供的 getState 获取最新的数据，flux 也是用来进行数据操作的，有四个组成部分 action，dispatch，view，store，工作流程是 view 发出一个 action，派发器接收 action，让 store 进行数据更新，更新完成以后 store 发出 change，view 接受 change 更新视图。Redux 和 Flux 很像。主要区别在于 Flux 有多个可以改变应用状态的 store，在 Flux 中 dispatcher 被用来传递数据到注册的回调事件，但是在 redux 中只能定义一个可更新状态的 store，redux 把 store 和 Dispatcher 合并,结构更加简单清晰</li>
<li>新增 state,对状态的管理更加明确，通过 redux，流程更加规范了，减少手动编码量，提高了编码效率，同时缺点时当数据更新时有时候组件不需要，但是也要重新绘制，有些影响效率。一般情况下，我们在构建多交互，多数据流的复杂项目应用时才会使用它们</li>
</ul>
<h3 id="React-中有三种构建组件的方式"><a href="#React-中有三种构建组件的方式" class="headerlink" title="React 中有三种构建组件的方式"></a>React 中有三种构建组件的方式</h3><p>React.createClass()、ES6 class 和无状态函数。</p>
<h3 id="react-组件的划分业务组件技术组件？"><a href="#react-组件的划分业务组件技术组件？" class="headerlink" title="react 组件的划分业务组件技术组件？"></a>react 组件的划分业务组件技术组件？</h3><ul>
<li>根据组件的职责通常把组件分为 UI 组件和容器组件。</li>
<li>UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。</li>
<li>两者通过 React-Redux 提供 connect 方法联系起来。</li>
</ul>
<h3 id="描述事件在-React-中的处理方式"><a href="#描述事件在-React-中的处理方式" class="headerlink" title="描述事件在 React 中的处理方式"></a>描述事件在 React 中的处理方式</h3><p>为了解决跨浏览器兼容性问题，您的 React 中的事件处理程序将传递 SyntheticEvent 的实例，它是 React 的浏览器本机事件的跨浏览器包装器。</p>
<p>这些 SyntheticEvent 与您习惯的原生事件具有相同的接口，除了它们在所有浏览器中都兼容。有趣的是，React 实际上并没有将事件附加到子节点本身。React 将使用单个事件监听器监听顶层的所有事件。这对于性能是有好处的，这也意味着在更新 DOM 时，React 不需要担心跟踪事件监听器。</p>
<h3 id="应该在-React-组件的何处发起-Ajax-请求"><a href="#应该在-React-组件的何处发起-Ajax-请求" class="headerlink" title="应该在 React 组件的何处发起 Ajax 请求"></a>应该在 React 组件的何处发起 Ajax 请求</h3><p>在 React 组件中，应该在 componentDidMount 中发起网络请求。这个方法会在组件第一次“挂载”(被添加到 DOM)时执行，在组件的生命周期中仅会执行一次。更重要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用。在 componentDidMount 中发起网络请求将保证这有一个组件可以更新了。</p>
<h3 id="在构造函数中-调用-super-props-的目的是什么"><a href="#在构造函数中-调用-super-props-的目的是什么" class="headerlink" title="(在构造函数中)调用 super(props) 的目的是什么"></a>(在构造函数中)调用 super(props) 的目的是什么</h3><p>在 super() 被调用之前，子类是不能使用 this 的，在 ES2015 中，子类必须在 constructor 中调用 super()。传递 props 给 super() 的原因则是便于(在子类中)能在 constructor 访问 this.props。</p>
<h3 id="除了在构造函数中绑定-this，还有其它方式吗"><a href="#除了在构造函数中绑定-this，还有其它方式吗" class="headerlink" title="除了在构造函数中绑定 this，还有其它方式吗"></a>除了在构造函数中绑定 this，还有其它方式吗</h3><p>你可以使用属性初始值设定项(property initializers)来正确绑定回调，create-react-app 也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。</p>
<h3 id="为什么建议传递给-setState-的参数是一个-callback-而不是一个对象"><a href="#为什么建议传递给-setState-的参数是一个-callback-而不是一个对象" class="headerlink" title="为什么建议传递给 setState 的参数是一个 callback 而不是一个对象"></a>为什么建议传递给 setState 的参数是一个 callback 而不是一个对象</h3><p>因为 this.props 和 this.state 的更新可能是异步的，不能依赖它们的值去计算下一个 state。</p>
<h3 id="何为高阶组件-higher-order-component"><a href="#何为高阶组件-higher-order-component" class="headerlink" title="何为高阶组件(higher order component)"></a>何为高阶组件(higher order component)</h3><p>高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 connect 函数。除了简单分享工具库和简单的组合，HOC 最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。</p>
<h3 id="何为受控组件-controlled-component"><a href="#何为受控组件-controlled-component" class="headerlink" title="何为受控组件(controlled component)"></a>何为受控组件(controlled component)</h3><p>在 HTML 中，类似 <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code> 和 <code>&lt;select&gt;</code> 这样的表单元素会维护自身的状态，并基于用户的输入来更新。当用户提交表单时，前面提到的元素的值将随表单一起被发送。但在 React 中会有些不同，包含表单元素的组件将会在 state 中追踪输入的值，并且每次调用回调函数时，如 onChange 会更新 state，重新渲染组件。一个输入表单元素，它的值通过 React 的这种方式来控制，这样的元素就被称为”受控元素”。</p>
<h3 id="在-React-当中-Element-和-Component-有何区别？"><a href="#在-React-当中-Element-和-Component-有何区别？" class="headerlink" title="在 React 当中 Element 和 Component 有何区别？"></a>在 React 当中 Element 和 Component 有何区别？</h3><p>React Element 是描述屏幕上所见内容的数据结构，是对于 UI 的对象表述。典型的 React Element 就是利用 JSX 构建的声明式代码片然后被转化为 createElement 的调用组合。</p>
<p>React Component 是一个函数或一个类，可以接收参数输入，并且返回某个 React Element</p>
<h3 id="组件的-状态-state-和属性-props-之间有何区别"><a href="#组件的-状态-state-和属性-props-之间有何区别" class="headerlink" title="(组件的)状态(state)和属性(props)之间有何区别"></a>(组件的)状态(state)和属性(props)之间有何区别</h3><ul>
<li>State 是一种数据结构，用于组件挂载时所需数据的默认值。State 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。</li>
<li>Props(properties 的简写)则是组件的配置。props 由父组件传递给子组件，并且就子组件而言，props 是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据–回调函数也可以通过 props 传递。</li>
</ul>
<h3 id="展示组件-Presentational-component-和容器组件-Container-component-之间有何区别？"><a href="#展示组件-Presentational-component-和容器组件-Container-component-之间有何区别？" class="headerlink" title="展示组件(Presentational component)和容器组件(Container component)之间有何区别？"></a>展示组件(Presentational component)和容器组件(Container component)之间有何区别？</h3><ul>
<li>展示组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态。</li>
<li>容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 Flux actions，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源。</li>
</ul>
<h3 id="类组件-Class-component-和-函数式组件-Functional-component-之间有何区别？"><a href="#类组件-Class-component-和-函数式组件-Functional-component-之间有何区别？" class="headerlink" title="类组件(Class component)和 函数式组件(Functional component)之间有何区别？"></a>类组件(Class component)和 函数式组件(Functional component)之间有何区别？</h3><ol>
<li><p>函数式组件比类组件操作简单，只是简单的调取和返回 JSX；而类组件可以使用生命周期函数来操作业务</p>
</li>
<li><p>函数式组件可以理解为静态组件（组件中的内容调取的时候已经固定了，很难再修改），而类组件，可以基于组件内部的状态来动态更新渲染的内容</p>
</li>
</ol>
<ul>
<li>类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 store 并维持状态</li>
<li>当组件仅是接收 props，并将组件自身渲染到页面时，该组件就是一个 ‘无状态组件(stateless component)’，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件(dumb components)或展示组件</li>
</ul>
<h3 id="createElement-和-cloneElement-有什么区别？"><a href="#createElement-和-cloneElement-有什么区别？" class="headerlink" title="createElement 和 cloneElement 有什么区别？"></a>createElement 和 cloneElement 有什么区别？</h3><p>传入的第一个参数不同</p>
<p>React.createElement():JSX 语法就是用 React.createElement()来构建 React 元素的。它接受三个参数，第一个参数可以是一个标签名。如 div、span，或者 React 组件。第二个参数为传入的属性。第三个以及之后的参数，皆作为组件的子组件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(type, [props], [...children]);</span><br></pre></td></tr></table></figure>

<p>React.cloneElement()与 React.createElement()相似，不同的是它传入的第一个参数是一个 React 元素，而不是标签名或组件。新添加的属性会并入原有的属性，传入到返回的新元素中，而旧的子元素将被替换。将保留原始元素的键和引用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React.cloneElement(element, [props], [...children]);</span><br></pre></td></tr></table></figure>

<h3 id="setState-和-replaceState-的区别"><a href="#setState-和-replaceState-的区别" class="headerlink" title="setState 和 replaceState 的区别"></a>setState 和 replaceState 的区别</h3><p>setState 是修改其中的部分状态，相当于 Object.assign，只是覆盖，不会减少原来的状态</p>
<p>replaceState 是完全替换原来的状态，相当于赋值，将原来的 state 替换为另一个对象，如果新状态属性减少，那么 state 中就没有这个状态了</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2023-04-14T17:01:50.000Z" itemprop="dateUpdated">2023-04-15 01:01:50</time>
</span><br>


        
        感谢您的阅读，欢迎评论(*^▽^*) 转载请附上本文链接：<a href="/knowledges/react.html" target="_blank" rel="external">https://qw8.github.io/knowledges/react.html</a>
        
    </div>
    
    <footer>
        <a href="https://qw8.github.io">
            <img src="/img/avatar.jpg" alt="秦伟">
            秦伟
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redux/">redux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/组件/">组件</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://qw8.github.io/knowledges/react.html&title=《React》 — 秦伟博客&pic=https://qw8.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://qw8.github.io/knowledges/react.html&title=《React》 — 秦伟博客&source=前端、全栈、SEO的知识点、面试题与学习链接的整理" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://qw8.github.io/knowledges/react.html" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《React》 — 秦伟博客&url=https://qw8.github.io/knowledges/react.html&via=https://qw8.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://qw8.github.io/knowledges/react.html" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/knowledges/npm.html" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">npm</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/knowledges/requirejs.html" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">RequireJS</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'false' == 'true',
            appId: "TJ17Ax10JrfIIljlO8qkwGvz-gzGzoHsz",
            appKey: "jDGQKdWT9hlzsTLRAbInE4bK",
            avatar: "mm",
            placeholder: "说点什么吧(*╹▽╹*)",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->










</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢您，我会继续努力哒(*^▽^*)
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.png" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

    <footer class="footer">
    <div class="top">
        <div class="map">
            <!--地球信息-->
<script type="text/javascript" src="/js/jquery-3.4.1.js"></script>
<script type="text/javascript">
    var windowWidth = $(window).width();
    if (windowWidth > 480) {
        document.write('<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5mz4gy0w2d8&amp;m=0&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33" async="async">  <\/script>');
    }
</script>
        </div>
        <p>
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>

</p>
        <p>
            <span>本网站总字数：832.4k</span>
            <span id="sitetime"></span>
        </p>
        <p>部分内容来源于互联网，用于个人知识的总结，如有侵权还请联系删除</p>
        <p>
            
            <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i
                    class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>

    <div class="bottom">
        <p>
            <span>Copyright &copy; 2019 - 2024 <a
                href="https://qw8.github.io/" target="_blank">秦伟的个人博客</a> All Rights Reserved.</span>
            <!-- <span>
                
                
            </span> -->
        </p>
    </div>
</footer>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2019, 8, 25, 18, 0, 0); // 北京时间
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "已安全运行 " + diffYears + "年 " + diffDays + "天 " + diffHours + "小时 " + diffMinutes + "分钟 " + diffSeconds + "秒";
    }
    siteTime();
</script>
</main>
<div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://qw8.github.io/knowledges/react.html&title=《React》 — 秦伟博客&pic=https://qw8.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://qw8.github.io/knowledges/react.html&title=《React》 — 秦伟博客&source=前端、全栈、SEO的知识点、面试题与学习链接的整理" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://qw8.github.io/knowledges/react.html" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《React》 — 秦伟博客&url=https://qw8.github.io/knowledges/react.html&via=https://qw8.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://qw8.github.io/knowledges/react.html" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACMUlEQVR42u3aQW7jMBAEwPz/0841wMZy91BZQGTpZNiSrNKhwZnh11d8vH4cyTk/z/z3qne/Jv+ydGBgYDyW8bo8kkdMfr0mtff/hYqBgXEA412C5bF4fZ8kRhP22+8xMDAwyvDNwdePjoGBgTFjXMflLEzzAhgDA+NkRlJM5oA8RvM4vq0Wx8DAeCAj77r//89/Mt/AwMB4FONVHivx2rbbiqfCwMDYmtEWqO1icQabPQ8GBsaujDw68whu4zUZdn64GwYGxjGM62ZW+/0sgtvhxC+Bi4GBsR1jll0JuC1TZwvQpQjGwMB4CCNZAuaLtvUNrO0WEAwMjBMYefNrdk5bJLfFLQYGxjmMdmE3ex3DGC1fEwYGxq6MPEzbJn4+VLihzYeBgbEpY2UDxKytnyw0kwXi290iGBgYmzJm5WsOW1luRsNLDAyMAxjr48z15tpKfGNgYOzNSLZBzIrVlTbcbOSJgYGxNyMPylkT/94tGlFFjoGBcRij3WyaP1ZeGEfbZDEwMA5j5GuwdgtsO+YsWnUYGBgHMFaWcXlLbnZV9KIxMDAOYLSfVxaCs4bah//FwMDYlPEqj1nK5a20YXBjYGBszZiFXd6SawcG7asZjjkxMDAeyMjHAPmtV8act7XbMDAwtmPkwdcWpW3IzrpqGBgYGHnwtXGct+Q+PA8GBgbGch08GwYUC1AMDIwDGG1h2W4/Ta5d2Q6LgYGxN2MWeW0Qz0YINw81MTAwnsf4BiGGfkwAZtETAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '(つェ⊂)咦!跑去哪里了';
            clearTimeout(titleTime);
        } else {
            document.title = '欢迎回来━(*｀∀´*)ノ';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>




<!-- 点击特效 -->
<script type="text/javascript" src="/js/clicklove.js"></script>
<!--动态线条背景-->
<script type="text/javascript"
        color="220,220,220" opacity='0.7' zIndex="-2" count="200"
        src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>
<!-- 雪花特效 -->
<script type="text/javascript" src="/js/jquery-3.4.1.js"></script>
<script type="text/javascript">
    var windowWidth = $(window).width();
    if (windowWidth > 480) {
        document.write('<script type="text/javascript" src="/js/snow.js"><\/script>');
    }
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"position":"right","width":150,"height":300,"hOffset":-25,"vOffset":30},"mobile":{"show":false,"scale":1.2},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script><script>!function(e){var r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function t(){for(var c=0;c<r.length;c++)t=r[c],void 0,0<=(n=t.getBoundingClientRect()).top&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=r[c];t=o,n=function(){r=r.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}t(),e.addEventListener("scroll",function(){!function(t,n){clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)}(t,e)})}(this);</script></body>
</html>

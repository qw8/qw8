<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>面向对象 | 秦伟博客 | 前端、全栈、SEO的知识点、面试题与学习链接的整理</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="JavaScript,对象,类">
    <meta name="description" content="面向对象的程序设计什么是面向对象？谈谈对面向对象的理解？面向对象。它是指把数据与数据的操作方法放在一起，作为一个相互依赖的 整体，即对象。对同类对象抽象出其共性，及类，类中的大多数数据，只能被本类进行处理。站在抽象的角度，例如人，特征，行为。 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。 面向过程。它是以事件为中心的">
<meta name="keywords" content="JavaScript,对象,类">
<meta property="og:type" content="article">
<meta property="og:title" content="面向对象">
<meta property="og:url" content="https://qw8.github.io/qw8/knowledges/mian-xiang-dui-xiang.html">
<meta property="og:site_name" content="秦伟博客">
<meta property="og:description" content="面向对象的程序设计什么是面向对象？谈谈对面向对象的理解？面向对象。它是指把数据与数据的操作方法放在一起，作为一个相互依赖的 整体，即对象。对同类对象抽象出其共性，及类，类中的大多数数据，只能被本类进行处理。站在抽象的角度，例如人，特征，行为。 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。 面向过程。它是以事件为中心的">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2024-04-03T16:54:30.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面向对象">
<meta name="twitter:description" content="面向对象的程序设计什么是面向对象？谈谈对面向对象的理解？面向对象。它是指把数据与数据的操作方法放在一起，作为一个相互依赖的 整体，即对象。对同类对象抽象出其共性，及类，类中的大多数数据，只能被本类进行处理。站在抽象的角度，例如人，特征，行为。 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。 面向过程。它是以事件为中心的">
    
        <link rel="alternate" type="application/atom+xml" title="秦伟博客" href="/qw8/atom.xml">
    
    <link rel="shortcut icon" href="/qw8/img/qw.ico">
    <link rel="stylesheet" href="/qw8/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
<div id="loading" class="active"></div>

<aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/qw8/img/brand.jpg)">
      <div class="brand">
        <a href="/qw8/" class="avatar waves-effect waves-circle waves-light">
          <img src="/qw8/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">秦伟</h5>
          <a href="mailto:124729081@qq.com" title="124729081@qq.com" class="mail">124729081@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/qw8/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/qw8/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/qw8/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/qw8/archives"  >
                <i class="icon icon-lg icon-hourglass"></i>
                时光
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://wpa.qq.com/msgrd?v=3&uin=124729081&site=qq&menu=yes" target="_blank" >
                <i class="icon icon-lg icon-qq"></i>
                聊天
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=124729081@qq.com"  >
                <i class="icon icon-lg icon-envelope-o"></i>
                邮箱
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/qw8/user"  >
                <i class="icon icon-lg icon-user"></i>
                简介
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://gitee.com/qw66" target="_blank" >
                <i class="icon icon-lg icon-code"></i>
                Gitee
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/qw8" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

<main id="main">
    <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">面向对象</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">面向对象</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-04-19T04:18:49.000Z" itemprop="datePublished" class="page-time">
  2020-04-19
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/qw8/categories/前端知识点/">前端知识点</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#面向对象的程序设计"><span class="post-toc-number">1.</span> <span class="post-toc-text">面向对象的程序设计</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是面向对象？谈谈对面向对象的理解？"><span class="post-toc-number">1.0.1.</span> <span class="post-toc-text">什么是面向对象？谈谈对面向对象的理解？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面向对象和面向过程的异同"><span class="post-toc-number">1.0.2.</span> <span class="post-toc-text">面向对象和面向过程的异同</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面向对象的三大特性"><span class="post-toc-number">1.0.3.</span> <span class="post-toc-text">面向对象的三大特性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面向对象开发的优点："><span class="post-toc-number">1.0.4.</span> <span class="post-toc-text">面向对象开发的优点：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#理解对象"><span class="post-toc-number">1.0.5.</span> <span class="post-toc-text">理解对象</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#属性类型"><span class="post-toc-number">1.0.6.</span> <span class="post-toc-text">属性类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#定义多个属性"><span class="post-toc-number">1.0.7.</span> <span class="post-toc-text">定义多个属性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#读取属性的特性"><span class="post-toc-number">1.0.8.</span> <span class="post-toc-text">读取属性的特性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#创建对象"><span class="post-toc-number">1.0.9.</span> <span class="post-toc-text">创建对象</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#继承"><span class="post-toc-number">1.0.10.</span> <span class="post-toc-text">继承</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-knowledges/面向对象"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">面向对象</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-04-19 12:18:49" datetime="2020-04-19T04:18:49.000Z"  itemprop="datePublished">2020-04-19</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/qw8/categories/前端知识点/">前端知识点</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="面向对象的程序设计"><a href="#面向对象的程序设计" class="headerlink" title="面向对象的程序设计"></a>面向对象的程序设计</h1><h3 id="什么是面向对象？谈谈对面向对象的理解？"><a href="#什么是面向对象？谈谈对面向对象的理解？" class="headerlink" title="什么是面向对象？谈谈对面向对象的理解？"></a>什么是面向对象？谈谈对面向对象的理解？</h3><p>面向对象。它是指把数据与数据的操作方法放在一起，作为一个相互依赖的 整体，即对象。对同类对象抽象出其共性，及类，类中的大多数数据，只能被本类进行处理。站在抽象的角度，例如人，特征，行为。</p>
<p>面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</p>
<p>面向过程。它是以事件为中心的开发方法，逐步有序执行。</p>
<h3 id="面向对象和面向过程的异同"><a href="#面向对象和面向过程的异同" class="headerlink" title="面向对象和面向过程的异同"></a>面向对象和面向过程的异同</h3><ul>
<li>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。</li>
<li>面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</li>
</ul>
<h3 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h3><p>1.封装：<br>封装是指将客观事物抽象成类。每个类对自身的数据和方法实行保护。类可以把自己的数据和方法只让可信的类或者对象操作。对不可信的隐藏。</p>
<p>2.继承：<br>继承是一种联结类的层次模型，并且允许和鼓励类的重用，提供了一种明确表述共性的方法。对象可以从现有的类中派生。这个过程叫做类的继承。</p>
<p>2.多态：<br>多态是指允许不同类的对象对同一方法（消息）作出响应，实际执行逻辑不同。需要 继承、方法重写、父类指向子类对象 三条件。但是父类无法调用子类中特有的功能。</p>
<h3 id="面向对象开发的优点："><a href="#面向对象开发的优点：" class="headerlink" title="面向对象开发的优点："></a>面向对象开发的优点：</h3><p>1、较高的开发效率。<br>2、保证软件的鲁棒性。<br>3、保证软件的高可维护性。</p>
<blockquote>
<p>其实有时间可以看向面向对象的语言 比如JAVA 推荐 <code>《First Head Java》</code>，有可能的话还是希望你先学习的是强类型的语言。</p>
</blockquote>
<p><strong>简介</strong></p>
<ul>
<li>面向对象的语言有一个标志，那就是他们都有类的概念（es6也有类了奥 不过是语法糖），而通过类可以创建任意多个具有相同属性和方法的对象。</li>
<li>可惜的是ECMAScript中没有类的概念，因此它的对象也与基于累的语言中的对象有所不同。</li>
<li><code>ECMA-262</code>把对象定义为 <code>无序属性的集合，其属性可以包含基本值、对象或者函数。</code>严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。</li>
<li>正因为这样，我们可以把<code>ECMAScript</code>的对象想象成散列表。</li>
<li>无非就是一组名值对，其中值可以是数据或函数。</li>
<li>每个对象都是基于一个引用类型创建的，这个引用类型可以是原生类型，也可以是开发人员定义的类型。</li>
</ul>
<h3 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h3><ul>
<li><p>创建自定义对象的最简单方式就是创建一个<code>Object</code>的实例，然后再为它添加属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.name = <span class="string">'Nicholas'</span>;</span><br><span class="line">person.age = <span class="number">29</span>;</span><br><span class="line">person.job = <span class="string">"Software Engineer"</span>;</span><br><span class="line"></span><br><span class="line">person.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert( <span class="keyword">this</span>.name )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后来，对象字面量成为创建对象的首选模式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'Nicholas'</span>,</span><br><span class="line">    age: <span class="number">29</span>,</span><br><span class="line">    job: <span class="string">"Software Engineer"</span>,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert( <span class="keyword">this</span>.name )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h3><ul>
<li><code>ECMA-262第5版</code>在定义只有内部采用的特性（attribute）时，描述了属性（property）的各种特征。</li>
<li>定义这些特性是为了实现JS引擎用的，因此在JS中不能直接访问他们。</li>
<li>为了表示特性是内部属性值，该规范把他们放在了两对儿方括号中， 例如<code>[[Enumerable]]</code>。</li>
</ul>
<p><strong>数据属性</strong></p>
<blockquote>
<p>数据属性包含一个数据值的位置。在这个位置可以读取和写入值。</p>
</blockquote>
<ul>
<li>[[Configurable]]: 表示能否通过<code>delete</code>删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，他们的这个特性默认值是true。</li>
<li>[[Enumerable]]: 表示能否通过<code>for-in</code>循环返回属性。像前面那样直接在对象上定义的属性，他们的这个特性默认值是true。</li>
<li>[[Writable]]: 表示能否修改属性的值。向前面例子中那样直接在对象上定义的属性，他们的这个特性默认是是true。</li>
<li>[[Value]]: 包含这个属性的数据值。读取属性值的时候，从这个位置读。写入属性值的时候，把新值保存在这个位置。这个特性的默认值是<code>undefined</code>。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'Nicholas'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 它的[[Configurable]]、 [[Enumerable]]、 [[Writable]] 特性都被设置为true， 而 [[Value]] 被设置成了指定的值。</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>Object.defineProperty()</strong></p>
<ul>
<li><p>要修改如上属性默认的特性的方法。</p>
</li>
<li><p>这个方法接收三个参数： 属性所在的对象、属性的名字和一个描述符对象。</p>
</li>
<li><p>描述符（<code>descriptor</code>）对象的属性必须是： configurable、 enumerable、 writable和value。设置其中的一或多个值，可以修改对应的特性值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty( person, <span class="string">'name'</span>, &#123;</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">'Nicholas'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 在费严格模式下，赋值操作将被忽略； 严格模式下，赋值操作将会抛出错误。</span></span><br><span class="line">person.name = <span class="string">'Greg'</span>;</span><br><span class="line">alert( person.name ); <span class="comment">// Nicholas</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>把<code>configurable</code>设置成false，表示不能从对象中删除属性。如果对这个属性调用delete，在诶严格模式下什么也不会发生，而再严格模式下会导致错误。而且，一旦把属性定义为不可配置的就不能再把它变回可配置了。此时，再调用Obejct.defineProperty()方法修改除writable之外的特性，都会导致错误。</p>
</li>
<li><p>在调用<code>Object.defineProperty()</code>方法时，如果不指定，<code>configurable</code>、<code>enumerable</code>和<code>writable</code>特性的默认值都是false。</p>
</li>
</ul>
<p><strong>访问器属性</strong></p>
<ul>
<li>访问器属性不包含数据值。</li>
<li>他们包含一对儿<code>getter</code>和<code>setter</code>函数（这两个函数都不是必须的）。</li>
<li>在读取访问器属性时，会调用<code>getter</code>函数，这个函数负责返回有效的值。</li>
<li>在写入访问器属性时，会调用<code>setter</code>函数并传入新值，这个函数负责决定如何处理数据。</li>
</ul>
<p><strong>访问器的4个属性</strong></p>
<ul>
<li>[[Configurable]]: 表示能否通过<code>delete</code>删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为true。</li>
<li>[[Enumerable]]: 能否通过<code>for-in</code>循环返回属性。对于直接在对象上定义的属性，这个特性的默认值是true。</li>
<li>[[Get]]: 在读取属性时调用的函数， 默认值为<code>undefined</code></li>
<li>[[Set]]: 在写入属性时调用的函数， 默认值为<code>undefined</code></li>
<li>访问器属性不能直接定义，必须使用<strong>Object.defineProperty()</strong>来定义。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    _year: <span class="number">2004</span>,</span><br><span class="line">    edition: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty( book, <span class="string">'year'</span>, &#123;</span><br><span class="line">    <span class="keyword">get</span>: function()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function()&#123;</span><br><span class="line">        <span class="keyword">if</span>( newValue &gt; <span class="number">2004</span> )&#123;</span><br><span class="line">            <span class="keyword">this</span>._year = newValue;</span><br><span class="line">            <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line"><span class="built_in">console</span>.log( book.edition ) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不一定非要同时指定<code>getter</code>和<code>setter</code>。只指定<code>getter</code>意味着属性时不能写，尝试写入属性会被忽略。在严格模式下，尝试写入只指定了<code>getter</code>函数的属性会抛出错误。</li>
<li>只指定<code>setter</code>函数的属性也不能读，否则在非严格模式下会返回<code>undefined</code>，严格模式下会抛出错误。</li>
</ul>
<p><strong>Object.defineProperty()的向下兼容</strong></p>
<ul>
<li><p>支持<code>ECMAScript5</code>的这个方法的浏览器有IE9+(IE8只是部分实现)、Firefox 4+、 Opera 12+、 Chrome。</p>
</li>
<li><p>在这个方法之前要创建访问器属性，一般使用两个非标准方法： <code>__defineGetter__()</code>和<code>__defineSetter__()</code>。这两个方法最初是由<code>Firefox</code>引入的，后来<code>Safari 3</code>、<code>Chrome 1</code>和<code>Opera 9.5</code>也给出了相同的实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重现上述方法</span></span><br><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    _year: <span class="number">2004</span>,</span><br><span class="line">    edition: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义访问器的旧有方法</span></span><br><span class="line">book.__defineGetter__( <span class="string">'year'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._year</span><br><span class="line">&#125; );</span><br><span class="line">book.__defineSetter__( <span class="string">'year'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( newValue &gt; <span class="number">2004</span> )&#123;</span><br><span class="line">        <span class="keyword">this</span>._year = newValue;</span><br><span class="line">        <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; );</span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line">alert( book.edition ); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在不支持Object.defineProperty()方法的浏览器中不能修改<code>[[Configurable]]</code>和<code>[[Enumerable]]</code>。</p>
</li>
</ul>
<h3 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h3><ul>
<li><p>由于未对象定义多个属性的可能性很大，<code>ECMAScript5</code>又定义了一个 Object.defineProperties()方法。</p>
</li>
<li><p>利用这个方法可以通过描述符一次定义多个属性。</p>
</li>
<li><p>该方法接收两个对象参数： 第一个对象是要添加和修改其属性的对象，第二个对象的属性和第一个对象中要添加或修改的属性一一对应。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties( book, &#123;</span><br><span class="line">    _year: &#123;</span><br><span class="line">        value: <span class="number">2004</span></span><br><span class="line">    &#125;,</span><br><span class="line">    edition: &#123;</span><br><span class="line">        value: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    year: &#123;</span><br><span class="line">        <span class="keyword">get</span>: function()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>._year</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function( newValue )&#123;</span><br><span class="line">        <span class="keyword">if</span>( newValue &gt; <span class="number">2004</span> )&#123;</span><br><span class="line">            <span class="keyword">this</span>._year = newValue;</span><br><span class="line">            <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; )</span><br></pre></td></tr></table></figure>
</li>
<li><p>兼容性： <code>IE9+</code>、<code>Firefox 4+</code>、<code>Safari 5+</code>、<code>Opera 12+</code>、<code>Chrome</code> </p>
</li>
</ul>
<h3 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h3><ul>
<li>使用<code>ECMAScript5</code>的<code>Object.getOwnPropertyDescriptor()</code>方法，可以取得给定属性描述符</li>
<li>参数1： 属性所在的对象</li>
<li>参数2： 要读取其描述符的属性名称。</li>
<li>返回值是一个对象。如果是访问其属性，这个对象有configurable、 enumerable、 get、 set；如果是数据属性，这个对象的属性有configurable、 enumerable、writable和value。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties( book, &#123;</span><br><span class="line">    _year: &#123;</span><br><span class="line">        value: <span class="number">2004</span></span><br><span class="line">    &#125;,</span><br><span class="line">    edition: &#123;</span><br><span class="line">        value: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    year: &#123;</span><br><span class="line">        <span class="keyword">get</span>: function()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function( newValue )&#123;</span><br><span class="line">            <span class="keyword">if</span>( newValue &gt; <span class="number">2004</span> )&#123;</span><br><span class="line">                <span class="keyword">this</span>._year = newValue;</span><br><span class="line">                <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; );</span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor( book, <span class="string">"_year"</span> );</span><br><span class="line">alert( descriptor.value ) <span class="comment">// 2004</span></span><br><span class="line">alert( descriptor.configurable ) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对于数据属性_year，value等于最初的值，configurable是false，而get等于undefined。对于访问器属性year，value等于undefined，enumerable是false，而get是一个指向setter函数的指针。</li>
<li>在JS中，可以针对任何对象——包括DOM和BOM对象，使用Object.getOwnPropertyDescriptor()方法。</li>
<li>兼容性和Object.defineproperty()相同。</li>
</ul>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p><strong>工厂模式</strong></p>
<ul>
<li><p>虽然Object够咱函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用一个接口创建很多对象，会产生大量的重复代码。</p>
</li>
<li><p>工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程。</p>
</li>
<li><p>考虑到在<code>ECMAScript</code>中无法创建类，开发人员发明了一种函数，用函数来封装以特定接口创建对象的细节。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params"> name, age, job </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert( <span class="keyword">this</span>.name )</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = createPerson( <span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>  );</span><br><span class="line"><span class="keyword">var</span> person2 = createPerson( <span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span> );</span><br></pre></td></tr></table></figure>
</li>
<li><p>优点： 解决了多个相似对象的问题。</p>
</li>
<li><p>缺点： 没有解决对象是别的问题（即怎样知道一个对象的类型）。</p>
</li>
</ul>
<p><strong>构造函数模式</strong></p>
<ul>
<li><p><code>ECMAScript</code>中的构造函数可用来创建特定类型的对象。像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中。</p>
</li>
<li><p>也可以创建自定义的构造函数，从而定义自定义独享类型的属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"> name, age, job </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert( <span class="keyword">this</span>.name )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person( <span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Sofatware Engineer"</span> );</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person( <span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span> )</span><br></pre></td></tr></table></figure>
</li>
<li><p>没有显式地创建对象</p>
</li>
<li><p>直接将属性和方法赋给了this对象</p>
</li>
<li><p>没有return语句</p>
</li>
<li><p>函数名Peroson使用的是大写字母P。 按照惯例，够咱函数始终都应该以一个大写字母开头。而非构造函数则应该以一个小写字母开头。这个做法借鉴其他OO语言，主要是为了区别于ECMAScript中的其他函数。因为够咱函数本身也是函数，只不过可以用来创建对象而已。</p>
</li>
</ul>
<p><strong>new操作符</strong></p>
<blockquote>
<p>面试常考点</p>
</blockquote>
<ul>
<li>创建一个新对象。</li>
<li>将构造函数的作用域赋值给新对象（ 因此this就指向了这个新对象 ）。</li>
<li>执行构造函数中的代码（ 为这个新对象添加属性 ）。</li>
<li>返回新对象。</li>
</ul>
<p><strong>ok接着上面的构造函数</strong></p>
<ul>
<li><p>在前面的栗子中，person1和person2分别保存着Person的一个不同的实例。这两个对象都有一个<code>constructor(构造函数)</code>属性，该属性指向Person</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person1.constructor == Person <span class="comment">// true</span></span><br><span class="line">person2.constructor == Person <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对象的constructor属性最初是用来标识对象类型的。但是还是<code>instanceof</code>检测对象类型更靠谱。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span> =&gt; <span class="literal">true</span></span><br><span class="line">person1 <span class="keyword">instanceof</span> Person =&gt; <span class="literal">true</span></span><br><span class="line">person2 <span class="keyword">instanceof</span> <span class="built_in">Object</span> =&gt; <span class="literal">true</span></span><br><span class="line">person2 <span class="keyword">instanceof</span> Person =&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型，这正是构造函数模式胜过工厂模式的点。</p>
</li>
<li><p>这个栗子中，person1和person2之所以同时是Object实例，是因为<strong>所有对象均继承自Object</strong></p>
</li>
</ul>
<p><strong>造函数当做函数</strong></p>
<ul>
<li>构造函数和其他函数的唯一区别，就在于调用它们的方式不同。</li>
<li>不过，构造函数毕竟也是函数，不存在定义构造函数的特殊语法。</li>
<li><strong>任何函数，只要通过new操作符来调用，那他就可以作为构造函数</strong></li>
<li>而任何函数，如果不通过new操作符来调用，那他跟普通函数也不会有什么两样。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当做构造函数使用</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person( <span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Soft Engineer"</span> );</span><br><span class="line">prson.sayName(); <span class="comment">// "Nicholas</span></span><br><span class="line"></span><br><span class="line">Person( <span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span> ); <span class="comment">// 添加到window</span></span><br><span class="line"><span class="comment">// 当在全局作用域中调用一个函数时，this对象总是指向window/Global对象</span></span><br><span class="line"><span class="built_in">window</span>.sayName()  <span class="comment">// "Greg"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在另一个对象的作用域中调用</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="comment">// 使用call apply 在某个特殊对象的作用域中调用Person()函数。</span></span><br><span class="line"><span class="comment">// 这里在对象o的作用域中调用的，因此调用后o就拥有了Person的所有属性和sayName（）方法</span></span><br><span class="line"><span class="comment">// 通俗的讲（我自己理解的） 就是Person在o的作用域中调用的，Person的this指向了o</span></span><br><span class="line">Person.call( o, <span class="string">"Kristen"</span>, <span class="number">25</span>, <span class="string">"Nurse"</span> );</span><br><span class="line">o.sayName(); <span class="comment">// "Kristen"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>构造函数的问题以及将方法转移到外部的思路</strong></p>
<ul>
<li><p>每个方法都要在每个实例上重新创建一遍。</p>
</li>
<li><p>在前面的例子中，person1和person2都有一个名为sayName()的方法，但那两个方法不是同一个Function的实例。不要忘了<code>ECMAScript</code>中的函数是对象，因此没定义一个函数，也就是实例化了一个对象。从逻辑讲，此时的构造函数也可以这样定义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"> name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="keyword">new</span> <span class="built_in">Function</span>( <span class="string">"alert(this.name)"</span> ); <span class="comment">// 与声明函数在逻辑上是等价的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从这角度上来看构造函数，更容易明白每个Person实例都包含一个不同的Function实例（以显示name属性）的本质。说明白些，以这种方式创建函数，会导致不同的作用域链和标识符解析，单创建Function新实例的机制仍然是相同的。因此，不同实例上的同名函数是不相等的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person1.sayName = preson2.sayName; <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 吃饭去了嘿嘿</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然而，创建两个完成同样任务的Function实例的确没有必要，况且有<code>this</code>对象在，根本不用在执行代码前就把函数绑定到特定对象上面。于是就有了把函数定义转移到构造函数外部来解决这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"> name, age, job </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.sayName = sayName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert( <span class="keyword">this</span>.name )</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person( <span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span> );</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person( <span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span> )</span><br></pre></td></tr></table></figure>
</li>
<li><p>在全局作用域中定义的函数实际上只能被某个对象调用，折让全局作用域有点名不副实。</p>
</li>
<li><p>如果对象需要定义很多方法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。</p>
</li>
</ul>
<p><strong>原型模式</strong></p>
<ul>
<li><p>我们创建的每个函数都有一个prototype(原型)属性，这个属性是一个指针、指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。</p>
</li>
<li><p>如果按照字面意思来理解，那么prototype就是通过调用构造函数而创建的那个对象实例的原型对象。</p>
</li>
<li><p>使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。</p>
</li>
<li><p>换句话说，不必再构造函数中定义对象实例的信息，而可以将这些信息直接添加到原型对象中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">person.prototype.name = <span class="string">'Nicholas'</span>;</span><br><span class="line">person.prototype.age = <span class="number">29</span>;</span><br><span class="line">person.prototype.job = <span class="string">"Software Engineer"</span>;</span><br><span class="line">person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert( <span class="keyword">this</span>.name )</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName(); <span class="comment">// 'Nicholas'</span></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.sayName(); <span class="comment">// 'Nicholas'</span></span><br><span class="line"></span><br><span class="line">person1.sayName == person2.sayName ; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数变成了空函数。</p>
</li>
<li><p>即便如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法。</p>
</li>
<li><p>但与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。</p>
</li>
</ul>
<p><strong>理解原型对象</strong></p>
<ul>
<li>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性<strong>指向函数的原型对象</strong>。</li>
<li>在默认情况下，所有原型对象都会自动获得一个<code>constructor</code>(构造函数)属性，这个属性包含一个指向<code>prototype</code>属性所在函数的指针。就拿前面例子来说，Person.prototype.constructor指向Person。通过这个构造函数，我们还可以继续为原型对象添加其他属性和方法。</li>
<li>创建了自定义的构造函数之后，其原型对象默认只会取得<code>constructor</code>属性；至于其他方法，则都是从<strong>Object</strong>继承而来的。</li>
<li>当调用构造函数创建一个新实例后，该市里的内部将包含一个指针（内部属性），指构造函数的原型对象。<code>ECMA-262</code>第5版中管这个指针叫<code>[[Prototype]]</code>。虽然在脚本中没有标准的方式访问<code>[[Prototype]]</code>，但<code>Firefox</code>、 <code>Safari</code>和<code>Chrome</code>在每个对象上都支持一个属性<code>__proto__</code>;而在其他实现中，这个属性对脚本则是完全不可见的。</li>
<li>要真正的明确一点的就是，这个链接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。</li>
<li>虽然实例不包含属性和方法，但我们却可以通过查找独享属性的过程来实现调用原型对象的方法。</li>
</ul>
<p><strong>isPrototypeOf()</strong></p>
<ul>
<li>虽然在所有视线中都无法访问到[[Prototype]], 但可以通过<code>isPrototypeOf()</code>方法来确定对象之间是否存在这种关系。</li>
<li>从本质上讲，如果[[Prototype]]指向调用<code>isPrototypeOf()</code>方法的对象(Person.prototype)，那么这个方法就返回true。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里，我们用原型对象的isPrototypeOf()方法测试了person1和person2.因为他们内部都有一个指向Person.prototype的指针，因此都返回了true</span></span><br><span class="line">Person.prototype.isPrototypeOf( person1 ) <span class="comment">// true</span></span><br><span class="line">Person.prototype.isPrototypeOf( person2 ) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>Object.getPrototypeOf()</strong></p>
<ul>
<li><p>这个方法返回<a href="部分浏览器中的__proto__">[Prototype]</a>的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 确定Object.getProtyotypeOf()返回的对象实际就是这个对象的原型</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf( person1 ) == Person.prototype <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 取得原型对象中name属性的值</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeof( person1 ).name <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>Object.getPrototypeOf()</code>可以方便的取得一个对象的原型，而这在利用原型实现继承的情况下是非常重要的。</p>
</li>
<li><p>支持这个方法的浏览器有<code>IE9+/ Firefox 3.5+/ Safari 5+/ Opera 12+/ Chrome</code>。</p>
</li>
</ul>
<p><strong>多个对象实例共享原型所保存的属性和方法的基本原理</strong></p>
<ul>
<li><p>当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。</p>
</li>
<li><p>搜索首先从对象实例本身开始。</p>
</li>
<li><p>如果在实例中找到了具有给定名字的属性，则返回该属性的值</p>
</li>
<li><p>如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。</p>
</li>
<li><p>原型最初只包含<code>constructor</code>属性，而该属性也是共享的，因此可以通过对象实例访问。</p>
</li>
<li><p>虽然可以通过对象实例访问保存在原型链中的值，但却不能通过对象实例重写原型中的值。</p>
</li>
<li><p>如果我们在实例中添加了一个属性，而该属性与实力原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name: 'Nicholas',</span><br><span class="line">    age: 29,</span><br><span class="line">    job: 'Softa Engineer',</span><br><span class="line">    sayName: function()&#123;</span><br><span class="line">        alert( <span class="keyword">this</span>.name )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person1.name = <span class="string">'Greg'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( person1.name ) <span class="comment">// 'Greg' —— 来自实例</span></span><br><span class="line"><span class="built_in">console</span>.log( person2.name ) <span class="comment">// 'Nicholas' —— 来自原型</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当为对象添加一个实例属性时，这个属性就会<strong>屏蔽</strong>原型对象中保存的同名属性；换句话说，添加这个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。即使将这个属性设置为<code>null</code>，也只会在实例中设置这个属性，而不会恢复其指向原型的链接。</p>
</li>
<li><p>使用<code>delete</code>操作符可以完全删除实例属性，从而让我们能够重新访问原型中的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name: 'Nicholas',</span><br><span class="line">    age: 29,</span><br><span class="line">    job: 'Softa Engineer',</span><br><span class="line">    sayName: function()&#123;</span><br><span class="line">        alert( <span class="keyword">this</span>.name )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person1.name = <span class="string">'Greg'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( person1.name ) <span class="comment">// 'Greg' —— 来自实例</span></span><br><span class="line"><span class="built_in">console</span>.log( person2.name ) <span class="comment">// 'Nicholas' —— 来自原型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person1.name;</span><br><span class="line"><span class="built_in">console</span>.log( person1.name ) <span class="comment">// 'Nicholas' —— 来自原型</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>hasOwnProperty()</strong></p>
<ul>
<li><p>使用<code>hasOwnProperty()</code>方法可以检测一个属性是否存在与实例中，还是存在于原型中。</p>
</li>
<li><p>这个方法( 不要忘了它是从Object继承来的 )只在给定属性存在于对象实例中时，才会返回true。</p>
</li>
<li><p>实例 —— true; 原型 —— false</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name: 'Nicholas',</span><br><span class="line">    age: 29,</span><br><span class="line">    job: 'Softa Engineer',</span><br><span class="line">    sayName: function()&#123;</span><br><span class="line">        alert( <span class="keyword">this</span>.name )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person1.name = <span class="string">'Greg'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( person1.name ) <span class="comment">// 'Greg' —— 来自实例</span></span><br><span class="line"><span class="built_in">console</span>.log( person2.name ) <span class="comment">// 'Nicholas' —— 来自原型</span></span><br><span class="line"></span><br><span class="line">person1.hasOwnProperty( <span class="string">'name'</span> ) <span class="comment">// true</span></span><br><span class="line">person2.hasOwnProperty( <span class="string">'name'</span> ) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ECMAScript5</code>的<code>Object.getOwnPropertyDescriptor()</code>方法只能用于实例属性，要取得原型属性的描述符，必须直接在原型对象上调用<code>Object.getOwnPropertyDescriptor()</code>方法</p>
</li>
</ul>
<p><strong>原型与in操作符</strong></p>
<ul>
<li><p>有两种方式使用<code>in</code>操作符，单独使用和<code>for-in</code>循环中使用。</p>
</li>
<li><p>在单独使用时，<code>in</code>操作符会在通过对象能够访问给定属性时，返回true，无论该属性存在于实例中还是原型中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name: 'Nicholas',</span><br><span class="line">    age: 29,</span><br><span class="line">    job: 'Softa Engineer',</span><br><span class="line">    sayName: function()&#123;</span><br><span class="line">        alert( <span class="keyword">this</span>.name )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person1.name = <span class="string">'Greg'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( person1.name ) <span class="comment">// 'Greg' —— 来自实例</span></span><br><span class="line"><span class="built_in">console</span>.log( person2.name ) <span class="comment">// 'Nicholas' —— 来自原型</span></span><br><span class="line"></span><br><span class="line">person1.hasOwnProperty( <span class="string">'name'</span> ) <span class="comment">// true</span></span><br><span class="line">person2.hasOwnProperty( <span class="string">'name'</span> ) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="string">'name'</span> <span class="keyword">in</span> person1 <span class="comment">// true</span></span><br><span class="line"><span class="string">'name'</span> <span class="keyword">in</span> person2 <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这两种区别 </span></span><br><span class="line">person1.xxx = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>( <span class="string">'xxx'</span> <span class="keyword">in</span> person1 )&#123; <span class="built_in">console</span>.log( <span class="literal">true</span> ) &#125; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">if</span>( person1.xxx )&#123; <span class="built_in">console</span>.log( <span class="literal">true</span> ) &#125; <span class="comment">//</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>同时使用<code>hasOwnProperty()</code>方法和<code>in</code>操作符就可以确定该属性是否存在且是在对象中还是在原型中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span>(<span class="params"> object, name </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !object.hasOwnProperty( name ) &amp;&amp; ( name <span class="keyword">in</span> object );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>for-in</strong></p>
<ul>
<li>在使用<code>for-in</code>循环时，返回的是所有能够通过对象访问的、可枚举的(enumerated)的属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性</li>
<li>屏蔽了原型中不可枚举的属性( [[Enumerable]]标记为false的属性 )的实例属性（就是新定义的和原型属性同名的实例属性）也会在for-in循环中返回，因为根据规定，所有开发人员定义的属性都是可枚举的——只有在IE8及更早版本中例外。</li>
<li>IE8早期版本的实现中存在一个bug，即屏蔽不可枚举属性的实例属性不会出现在<code>for-in</code>循环中。</li>
<li>该bug会影响默认不可枚举的所有属性和方法。包括<code>hasOwnProperty()/ peropertyIsEnumerable()/ toLocaleString()/ toString()/ valueOf</code></li>
<li><code>ECMAScript5</code>也将<code>constructor</code>和<code>prototype</code>属性的<code>[[Enumerable]]</code>特性设置为false，但并不是所有得浏览器都照此实现。</li>
</ul>
<p><strong>Object.keys()</strong></p>
<ul>
<li>取得该对象上所有可枚举的实例属性。</li>
<li>接收一个对象作为参数，返回一个包含<strong>自身</strong>所有可枚举属性的字符串数组。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name: 'Nicholas',</span><br><span class="line">    age: 29,</span><br><span class="line">    sayName: function()&#123;</span><br><span class="line">        alert( <span class="keyword">this</span>.name )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys( Person.prototype );</span><br><span class="line"><span class="built_in">console</span>.log( keys ); <span class="comment">// 'name, age, job, sayName'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.name = <span class="string">'Rob'</span>;</span><br><span class="line">person1.age = <span class="number">31</span>;</span><br><span class="line"><span class="keyword">var</span> person1Keys = <span class="built_in">Object</span>.keys( person1 );</span><br><span class="line"><span class="comment">// 只返回了自身 并没有往原型对象里面去找</span></span><br><span class="line"><span class="built_in">console</span>.log( person1Keys ) <span class="comment">// ['name', 'age']</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>Object.getOwnPropertyNames()</strong></p>
<ul>
<li>如果你想得到所有实例属性，无论它是否可枚举，就用这个方法吧。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.getOwnPropertyNames( Person.prototype );</span><br><span class="line"><span class="comment">// 结果包含了不可枚举的constructor</span></span><br><span class="line">alert( keys ) <span class="comment">// 'constructor, name, age, job, sayName'</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>更简单的原型语法</strong></p>
<ul>
<li><p>为了减少不必要的输入</p>
</li>
<li><p>为了从视觉上更好的封装原型功能</p>
</li>
<li><p>更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">'Nicholas'</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在上面的代码中，我们将Person.prototype设置为等于一个以对象字面量形式创建的新对象。最终结果相同，但有一个例外：<code>constructor</code>属性不再指向<code>Person</code>了。前面曾经介绍过，每创建一个函数，就会同时创建它的prototype对象，整个对象也会自动获得<code>constructor</code>属性。而我们在这里使用的语法，本质上完全重写了默认的<code>prototype</code>对象，因此<code>constructor</code>属性也就变成了新对象的<code>constructor</code>属性（指向Object构造函数），不再指向Person函数。此时，尽管<code>instaceof</code>操作符还能返回正确的结果，单通过<code>constructor</code>已经无法确定对象的类型了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line">friend <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">//true</span></span><br><span class="line">friend <span class="keyword">instanceof</span> Person <span class="comment">// true</span></span><br><span class="line">friend.constructor == Person <span class="comment">// false</span></span><br><span class="line">frined.constructor == <span class="built_in">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>所以我们要这样写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name: 'Nicholas'</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>以上代码特意包含了一个<code>constructor</code>属性，并将它的值设置为Person，从而确保了通过该属性能够访问到适当的值。</p>
</li>
<li><p>问题来了，以这种方式重设<code>constructor</code>属性会导致他的<code>[[Enumerable]]</code>特性被设置为true。默认情况下，原生的<code>constructor</code>属性是不可枚举的。因此如果你兼容<code>ECMAScript5</code>的JS引擎，可以试一试<code>Object.defineProperty()</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">'Nicholas'</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 重设构造函数，只适用于ECMA5+</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty( Person.prototype, <span class="string">'constructor'</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    value: Person</span><br><span class="line">&#125; )</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>原型的动态性</strong></p>
<ul>
<li><p>由于原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来——即使是县创建了实例后修改原型也照样如此。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'hi'</span>)</span><br><span class="line">&#125;;</span><br><span class="line">friend.sayHi(); <span class="comment">// 'hi'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当我们调用person.sayHi()时，首先会在实例中搜索名为sayHi的属性，没找到的情况下，会继续搜索原型。</p>
</li>
<li><p>因为实例与原型之间的链接只不过<strong>是一个指针而非一个副本</strong>，因此就可以在原型中找到新的sayHi属性并返回保存在那里的函数。</p>
</li>
<li><p>如果是重写整个原型对象，那么情况就不一样了！！！</p>
</li>
<li><p>我们知道，调用构造函数时会为实例添加衣蛾指向最初原型的<code>[[Prototype]]</code>指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。</p>
</li>
<li><p><strong>实例中的指针仅指向原型，而不指向构造函数</strong></p>
</li>
</ul>
<p><strong>原生对象的原型</strong></p>
<ul>
<li><p>原生模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是猜中这种模式创建的。</p>
</li>
<li><p>所有原生引用类型（ Object， Array， String ……）都在其构造函数的原型上定义了方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.sort <span class="comment">// 'function'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">String</span>.prototype.substring <span class="comment">// 'function'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法。</p>
</li>
<li><p>可以像修改自定义对象的远行一样修改原生对象的原型，因此可以随时添加方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.startsWidth = <span class="function"><span class="keyword">function</span>(<span class="params"> text </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.indexOf( text ) === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> msg = <span class="string">'Hello world!'</span>;</span><br><span class="line">alert( msg.startsWith( <span class="string">'hello'</span> ) ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>尽管可以这样做，但我们不推荐在产品化的程序中修改原生对象的原型。如果因某个实现中缺少某个方法，就在原生对象的原型中添加这个方法，那么当在另一个支持该方法的视线中运行代码时，就可能会导致命名冲突。而且，这样做也可能会以外的重写原生方法。</p>
</li>
</ul>
<p><strong>原型对象的问题</strong></p>
<ul>
<li>它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。</li>
<li>最大的问题是由其共享的本性所导致的</li>
<li>原型中所有属性是被很多实例共享的，这种共享对函数非常合适，对于那些包含基本值的属性也说得过去，毕竟通过在实例上添加一个同名属性，可以隐藏原型中的对应属性。但是，对于包含引用类型值的属性来讲，问题比较突出<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name: 'Nicholas',</span><br><span class="line">    job: 'Software Enginerr',</span><br><span class="line">    friends: ['Shelby', 'Court'],</span><br><span class="line">    sayName: function()&#123;</span><br><span class="line">        alert( <span class="keyword">this</span>.name )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.friends.push( <span class="string">'Van'</span> );</span><br><span class="line"></span><br><span class="line">person1.friends <span class="comment">// 'Shelby, Court, Van'</span></span><br><span class="line">person2.friends <span class="comment">// 'Shelby, Court, Van'</span></span><br><span class="line">person1.friends === person2.friends <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Person.prototype对象有一个名为friends的属性，该属性包含一个字符串数组。然后，创建了Person的两个实例。接着，修改了person1.frineds引用的数组，箱数组中添加了一个字符串。</span></span><br><span class="line"><span class="comment"> * 由于friends数组存在于Person.prototpe而非person1中，所以刚刚提到的修改也会通过person2.friends( person1.friends指向同一个数组 )反映出来。假如我们的初衷就是像这样在所有实例中共享一个数组，那么对这个结果我无话可说。可是，实例一般都是要有属于自己的全部属性的。这个问题就是我们很少看到有人单独使用原型模式的原因所在。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>组合使用构造函数模式和原型模式</strong></p>
<ul>
<li><p>创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。</p>
</li>
<li><p>构造函数模式用于定义实例属性。</p>
</li>
<li><p>而原型模式用于定义方法和共享的属性。</p>
</li>
<li><p>结果，每个实例都会有自己的一份实例属性的副本。</p>
</li>
<li><p>但同时有共享着对方法的引用，最大限度地节省了内存。</p>
</li>
<li><p>这种混成模式还支持向构造函数传递参数。</p>
</li>
<li><p>集两种模式之长。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"> name, age, job </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.friends = [ <span class="string">'Shelby'</span>, <span class="string">'Court'</span> ];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    sayName: function()&#123;</span><br><span class="line">        alert( <span class="keyword">this</span>.name )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person( <span class="string">'Nicholas'</span>, <span class="number">29</span>, <span class="string">'Software Engineer'</span> );</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person( <span class="string">'Greg'</span>, <span class="number">27</span>, <span class="string">'Doctor'</span> );</span><br><span class="line"></span><br><span class="line">person1.friends.push(<span class="string">'Van'</span>);</span><br><span class="line">person1.friends <span class="comment">// 'Shelby, Count, Van'</span></span><br><span class="line">person2.frineds <span class="comment">// 'Shelby, Count'</span></span><br><span class="line">preson1.friends === person2.friends <span class="comment">// false</span></span><br><span class="line">person1.sayName === person2.sayName <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>这个例子中，实例属性都是在构造函数中定义的，而由所有实例共享的属性<code>constructor</code>和方法<code>sayName()</code>则是在原型中定义的。</p>
</li>
<li><p>而修改了<code>person1.friends</code>并不会影响到prson2.friends，因为他们分别引用了不同的数组。</p>
</li>
<li><p>这种构造函数与原型混成的模式，是目前在<code>ECMAScript</code>中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。</p>
</li>
</ul>
<p><strong>动态原型模式</strong></p>
<ul>
<li><p>有其他<code>OO</code>语言经验的开发人员在看奥独立的构造函数和原型时，很可能会感到非常困惑。</p>
</li>
<li><p>动态原型模式正事致力于解决这个问题的一个方案，它把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（ 仅在必要的情况下 ），又保持了同时使用构造函数和原型的有点。</p>
</li>
<li><p>换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"> name, age, job </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">'function'</span> )&#123;</span><br><span class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert( <span class="keyword">this</span>.name )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person( <span class="string">'Nicholas'</span>, <span class="number">29</span>, <span class="string">'Software Engineer'</span> );</span><br><span class="line">friend.sayName();</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意构造函数代码中加粗的部分，这里只有在sayName方法不存在的情况下，才会将它添加到原型中。这段代码只会在初次调用构造函数时才会执行。此后，原型已经被完成初始化，不要再做什么修改了。</p>
</li>
<li><p>不过记住，这里对原型所做的修改，能够立即在所有实例中得到反映。</p>
</li>
<li><p>其中，if语句检查的可以是初始化之后应该存在的任何属性或方法——不必用一大堆if语句检查每个属性和方法，只要检查其中一个即可。</p>
</li>
<li><p>对于采用这种模式创建的对象，还可以使用<code>instanceof</code>操作符确定它的类型。</p>
</li>
<li><p><strong>动态原型模式时，不能使用对象字面量重写原型</strong>。如果在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系。</p>
</li>
</ul>
<p><strong>寄生构造函数模式</strong></p>
<ul>
<li><p>在前述的几种模式都不适用的情况下，可以使用寄生（<code>parasitic</code>）构造函数模式。</p>
</li>
<li><p>这种模式基本思想是创建一个函数，该函数的作用仅仅是分装创建对象的代码，然后返回新创建的对象</p>
</li>
<li><p>但从表面上看，这个函数又很像是典型的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"> name, age, job </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert( <span class="keyword">this</span>.name )</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person( <span class="string">'Nicholas'</span>, <span class="number">29</span>, <span class="string">'Software Engineer'</span> );</span><br><span class="line">friend.sayName(); <span class="comment">// 'Nicholas'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在这个栗子中，Person函数创建了一个新对象，并以相应的属性和方法初始化该对象，然后又返回了这个对象。</p>
</li>
<li><p>除了使用new操作符并把使用的包装函数叫做构造函数外，这个模式跟工厂模式其实是一模一样的。</p>
</li>
<li><p>构造函数在不返回值的情况下，默认会返回新对象实例。</p>
</li>
<li><p>而通过在构造函数的末未添加一个return语句，可以重写调用构造函数时返回的值。</p>
</li>
</ul>
<p><strong>寄生构造函数使用场景</strong></p>
<ul>
<li><p>这个模式可以在特殊的情况下用来为对象创建构造函数。</p>
</li>
<li><p>假设我们想创建衣蛾具有额外方法的特殊数组，由于不能直接修改<code>Array</code>构造函数，因此可以使用这个模式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="comment">// 添加值</span></span><br><span class="line">    values.push.apply( values, <span class="built_in">arguments</span> );</span><br><span class="line">    <span class="comment">// 添加方法</span></span><br><span class="line">    values.toPipedString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">'|'</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> SpecialArray( <span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span> );</span><br><span class="line"><span class="built_in">console</span>.log( colors.toPipedString() ) <span class="comment">// 'red|blue|green'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>首先，返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说， 构造函数返回的对象与在构造函数外部创建的对象没有什么不同。</p>
</li>
<li><p>为此，不能依赖<code>instanceof</code>操作符来确定对象类型。所以能适用其他模式的情况下，不建议使用此模式。</p>
</li>
</ul>
<p><strong>稳妥构造函数模式</strong></p>
<ul>
<li><p><code>道格拉斯·克洛克福特</code>发明了JS中的稳妥对象这个概念。</p>
</li>
<li><p>所谓稳妥对象，指的是没有公共属性，而且其犯法也不引用this对象。</p>
</li>
<li><p>稳妥对象最适合在一些按全的环境中（这些环境会禁止使用this和new），或者在防止数据被其他应用程序改动时使用。</p>
</li>
<li><p>稳妥构造函数遵循与寄生构造函数类似的模式。但有两点不同</p>
</li>
<li><p>新创建对象额实例方法不引用this</p>
</li>
<li><p>不使用new操作符调用构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 创建要返回的对象</span></span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="comment">// 定义私有变量和函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加方法</span></span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert( name )</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 返回对象</span></span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = Person( <span class="string">'Nicholas'</span>, <span class="number">29</span>, <span class="string">'Software Engineer'</span> );</span><br><span class="line">friend.sayName(); <span class="comment">// 'Nicholas'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在以这种模式创建的对象中，除了使用sayName()方法外，没有其他办法访问name值</p>
</li>
<li><p>与寄生构造函数模式类似，使用稳妥构造函数模式创建的独享与构造函数之间没有什么关系，因此<code>instaceof</code>操作符对这货在哪个对象也没意义。</p>
</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><strong>简介</strong></p>
<ul>
<li>继承是OO语言中的一个最为人津津乐道的概念。许多OO语言都支持两种继承方式——接口继承和实现继承。</li>
<li><strong>接口继承</strong>值继承方法签名</li>
<li><strong>实现继承</strong>则继承实际的方法</li>
<li>由于函数没有签名，在<code>ECMAScript</code>中无法实现接口继承。</li>
<li><code>ECMAScript</code>只支持实现继承，而且其实现继承主要是依靠原型链来实现的。</li>
</ul>
<p><strong>原型链</strong></p>
<ul>
<li><code>ECMAScript</code>中描述了<strong>原型链</strong>的概念，并将原型链作为实现继承的主要方法。</li>
<li>其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</li>
<li>简单回顾一下构造函数、原型和实例的关系：</li>
<li><strong>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针</strong></li>
<li>那么，假如我们让原型对象等于另一个类型的实例，结果会怎样呢？</li>
<li>显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。</li>
<li>假如另一个原型有事另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。</li>
<li>这就是所谓的原型链的基本概念。</li>
</ul>
<p><strong>原型链的基本模式</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">alert( instance.getSuperValue() ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>以上代码定义了两个类型： SuperType 和 SubType。每个类型分别有一个属性和一个方法。他们的主要区别是 SubType 继承了 SuperType， 而继承是通过创建SuperType的实例，并将该实例赋给SubType.prototype实现的。</li>
<li>实现的本质是重写原型对象，代之以一个新类型的实例。</li>
<li>换句话说，原来存在于 SuperType 的实例中的所有属性和方法，现在也存在于 SubType.prototype 中了。</li>
<li>在确立了继承关系之后，我们给 SubType.prototype 添加了一个方法，这样就在继承了 SuperType 的属性和方法的基础上有添加了一个新方法。</li>
<li>要注意 SubType.prototype.constructor === instance.constructor 而且 instance.constructor现在指向的是SuperType</li>
<li>遵循原型链搜索原则</li>
<li>调用instance.getSuperValue()会经历三个搜索步骤 </li>
<li><ol>
<li>搜索实例</li>
<li>搜索 SubType.prototype</li>
<li>搜索 SuperType.prototype 最后一步才会找到该方法</li>
</ol>
</li>
<li>在找不到属性或方法的情况下，搜索过程总是要一环一环的前行到原型链末端才会停下来</li>
</ul>
<p><strong>别忘记默认原型</strong></p>
<ul>
<li>所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。</li>
<li>所有函数的默认原型都是Object实例</li>
<li>因此默认原型都会包含一个内部指针，指向Object.prototype</li>
<li>这也正是所有自定义类型都会继承<code>toString()</code>、 <code>valueof()</code>等默认方法的根本原因。</li>
</ul>
<p><strong>确定原型和实例的关系</strong></p>
<ul>
<li><p>使用<code>instanceof</code>操作符 只要用这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回true。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于原型链的关系，我们可以说instance是Object、SuperType或SubTYpe中任何一个类型的实例。</span></span><br><span class="line">instance <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">instance <span class="keyword">instanceof</span> SuperType <span class="comment">// true</span></span><br><span class="line">instance <span class="keyword">instanceof</span> SubType <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>isPrototypeOf()</code>方法。同样，只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf( instance ) <span class="comment">// true</span></span><br><span class="line">SuperType.prototype.isPrototypeOf( instance ) <span class="comment">// true</span></span><br><span class="line">SubType.prototype.isPrototypeOf( instance )</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>谨慎地定义方法</strong></p>
<ul>
<li><p>子类型有时需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法</p>
</li>
<li><p>但不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承了SuperTYpe</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加新方法</span></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写超类型中的方法</span></span><br><span class="line">SubType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">alert( instance.getSuperValue() ); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写超类中的方法会屏蔽超类中的原方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过原型链实现继承时，不能使用对象字面量创建原型方法，这样会重写原型链</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承了SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用字面量添加新方法，会导致上一行代码无效</span></span><br><span class="line">SubType.prototype = &#123;</span><br><span class="line">    getSubVale: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.subproperty</span><br><span class="line">    &#125;,</span><br><span class="line">    someOtherMethod: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="comment">// 由于现在原型包含的是一个Object的实例，而非SuperType的实例，因此我们设想中的原型链已经被切断。</span></span><br><span class="line">alert( instance.getSuperValue() ) <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<p><strong>原型链的问题</strong></p>
<ul>
<li><p>问题1:</p>
</li>
<li><p>原型链虽然强大，可以用它来实现继承，但它也存在一些问题。最主要的问题来自包含引用类型值的原型。</p>
</li>
<li><p>在通过原型来实现继承时，圆形实际上会变成另一个类型的实例。</p>
</li>
<li><p>于是，原先的实例属性也就顺理成章的变成了现在的原型属性了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [ <span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span> ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承了SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instancel = <span class="keyword">new</span> SubType();</span><br><span class="line">instancel.colors.push(<span class="string">'black'</span>);</span><br><span class="line">alert( instancel.colors ) <span class="comment">// 'red, blue, green, black'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(); </span><br><span class="line">alert( instance2.colors ) <span class="comment">// 'red, blue, green, black'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>问题2：</p>
</li>
<li><p>在创建子类型的实例时，不能向超类型的构造函数中传递参数。</p>
</li>
<li><p>实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。</p>
</li>
<li><p>有鉴于此，再加上前面刚刚讨论过的由于原型中包含引用类型值所带来的问题，实践中很少会单独使用原型链。</p>
</li>
</ul>
<p><strong>借用构造函数</strong></p>
<ul>
<li><p>借用构造函数的技术有时也称伪造对象或经典继承。</p>
</li>
<li><p>基本思想想当简单，即在子类型构造函数的内部调用超类型构造函数。</p>
</li>
<li><p>别忘了，函数只不过是在特定环境中执行代码的对象，因此通过使用<code>call()</code> <code>apply()</code>方法亦可以在（将来）新创建的对象上执行构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 继承了 SuperType</span></span><br><span class="line">    <span class="comment">// 这行代码借调了超类型的构造函数</span></span><br><span class="line">    <span class="comment">// 通过使用call()或apply()方法，我们实际上是在（未来将要）新创建的SubType实例的环境下调用了SuperType构造函数</span></span><br><span class="line">    <span class="comment">// 这样一来，就会在新SubType对象上执行SuperType()函数中定义的所有对象初始化代码</span></span><br><span class="line">    <span class="comment">// 结果，SubType的每个实例就都会具有自己的colors属性的副本了</span></span><br><span class="line">    SuperType.call( <span class="keyword">this</span> )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push( <span class="string">'blcak'</span> ); <span class="comment">// 'red, blue, green, black'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instace2 = <span class="keyword">new</span> SubType(); <span class="comment">// 'red, blue, green'</span></span><br></pre></td></tr></table></figure>
</li>
<li><ol>
<li><p>传递参数</p>
<ul>
<li><p>相对于原型链而言，借用构造函数有一个很大的优势，就是可以再子类型构造函数中向超类型构造函数传递参数</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 继承了SuperType 同时还传递了参数</span></span><br><span class="line">    SuperType.call( <span class="keyword">this</span>, <span class="string">'Nicholas'</span> )</span><br><span class="line">    <span class="comment">// 实例属性</span></span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">29</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">instace.name <span class="comment">// 'Nicholas'</span></span><br><span class="line">instance.age <span class="comment">// 29</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>为了确保SuperType构造函数不会重写子类型的水性，可以再调用超类型构造函数后，再添加应该在子类型中定义的属性  </p>
</li>
</ul>
</li>
<li><p>借用构造函数的问题</p>
<ul>
<li>如果仅仅是借用构造函数， 那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定义，因此函数复用就无从谈起了</li>
<li>而且在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式</li>
<li>考虑到这些问题，借用构造函数的技术也是很少单独使用的。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><strong>组合继承</strong></p>
<ul>
<li><p>组合继承，有时候也叫伪经典继承，指的是将原型链和借用构造函数的技术组合到一块， 从而发挥二者之长的一种继承模式。</p>
</li>
<li><p>其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。</p>
</li>
<li><p>这样，既通过在圆心上定义方法实现了函数复用，又能保证每个实例都有它自己的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]；</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert( <span class="keyword">this</span>.name )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    SuperType.call( <span class="keyword">this</span>, name )</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert( <span class="keyword">this</span>.name )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType( <span class="string">'Nicholas'</span>, <span class="number">29</span> );</span><br><span class="line">instance1.colors.push( <span class="string">'black'</span> );</span><br><span class="line">alert( instance1.colors ) <span class="comment">// 'red, blue, green, black'</span></span><br><span class="line">instance1.sayName(); <span class="comment">// 'Nicholas'</span></span><br><span class="line">instance1.sayAge(); <span class="comment">// 29</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instace2 = <span class="keyword">new</span> SubType(<span class="string">'greg'</span>, <span class="number">27</span>)</span><br><span class="line">alert( instance2.colors ) <span class="comment">// 'red, blue, green'</span></span><br><span class="line">instance2.sayAge() <span class="comment">// 27</span></span><br><span class="line">instance2.sayName() <span class="comment">// 'greg'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>组合继承避免了原型链和借用构造函数的缺陷，融合了他们的优点，成为JS中最常用的继承模式。而且，<code>instanceof</code>和<code>isPrototypeOf()</code>也能狗用于识别基于组合继承创建的对象。</p>
</li>
</ul>
<p><strong>原型式继承</strong></p>
<ul>
<li><p>道格拉斯克罗克福发明的。</p>
</li>
<li><p>这种方法并没有使用严格意义上的构造函数</p>
</li>
<li><p>他的想法是借助原型可以基于已有的对象创建新对象，同事还不比因此创建自定义类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在object()函数内部，县创建爱你了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。</p>
</li>
<li><p>从本质上讲， object对传入其中的对象执行了一次<code>浅复制</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'Nicholas'</span>,</span><br><span class="line">    friends: [<span class="string">'Shelby'</span>, <span class="string">'Court'</span>, <span class="string">'Van'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>( person );</span><br><span class="line">anotherPerson.name = <span class="string">'Greg'</span>;</span><br><span class="line">anotherPerson.friends.push( <span class="string">' Rob '</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = <span class="built_in">Object</span>( person );</span><br><span class="line">anotherPerson.name = <span class="string">'Linda'</span>;</span><br><span class="line">anotherPerson.friends.push( <span class="string">'Barbie'</span> );</span><br><span class="line">alert( person.friends ) <span class="comment">// 'Shelby, Court, Van, Rob, Barbie'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>克罗克福德主张的这种原型继承，要求你必须有一个对象可以作为另一个对象的基础。</p>
</li>
<li><p>如果有这么一个对象的话，可以把它传递给Object()函数，然后再根据具体需求对得到的对象加以修改即可。</p>
</li>
<li><p><strong>Object.create()</strong></p>
</li>
<li><p><code>ECMAScript5</code>通过新增Object.create()方法规范化了原型式继承。</p>
</li>
<li><p>参数1： 一个用作新对象原型的对象</p>
</li>
<li><p>参数2： 一个为新对象定义额外属性的对象</p>
</li>
<li><p>在传入一个参数的情况下， Object.create和object方法的行为相同</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'Nicholas'</span>,</span><br><span class="line">    friends: [<span class="string">'Shelby'</span>, <span class="string">'Court'</span>, <span class="string">'Van'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create( person );</span><br><span class="line">anotherPerson.name = <span class="string">'Greg'</span>;</span><br><span class="line">anotherPerson.friends.push( <span class="string">'Rob'</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = <span class="built_in">Object</span>.create( person );</span><br><span class="line">yetAnotherPerson.name = <span class="string">'Linda'</span>;</span><br><span class="line">yetAnotherPerson.friends.push( <span class="string">'Barbie'</span> );</span><br><span class="line"></span><br><span class="line">alert( person.friends ) <span class="comment">// 'shelby, court, van, rob, Barbie'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Object.create()方法的第二个参数与Object.definePropertyies()方法的第二个参数格式相同</p>
</li>
<li><p>每个属性欧式通过自己的描述符定义的。</p>
</li>
<li><p>以这种方式指定的任何属性都会覆盖原型对象上的同名属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'Nicholas'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create( person, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: <span class="string">'Greg'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; )</span><br><span class="line">alert( anotherPerson.name ) <span class="comment">// 'Greg'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>兼容 IE9+ Firefox 4+ Safari 5+ Opera 12+ Chrome</p>
</li>
<li><p>在没有必要兴师动众的创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的</p>
</li>
<li><p>不过别忘了，包含引用类型值的属性始终都会共享相应值，就像使用原型模式一样。</p>
</li>
</ul>
<p><strong>寄生式继承</strong></p>
<ul>
<li><p>寄生式继承是与原型式继承紧密相关的一种思路，并且同样也是由<code>克罗克福德</code>推广的</p>
</li>
<li><p>寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数</p>
</li>
<li><p>该函数在内部以某种方式来增强对象，最后再像真的它做了所有工作一样返回对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">crateAnother</span>(<span class="params"> original </span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 通过调用函数创建一个新对象</span></span><br><span class="line">    <span class="keyword">var</span> clone = object( original );</span><br><span class="line">    <span class="comment">// 以某种方式来增强这个对象</span></span><br><span class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">'hi'</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 返回这个对象</span></span><br><span class="line">    <span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。</p>
</li>
<li><p>前面示范继承模式时用的object函数不是必须的</p>
</li>
<li><p>任何能够返回新对象的函数都适用于此模式</p>
</li>
</ul>
<p><strong>寄生组合式继承</strong></p>
<ul>
<li><p>组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数：</p>
<ol>
<li>一次是在创建子类型原型的时候</li>
<li>另一次是在子类型构造函数内部</li>
</ol>
</li>
<li><p>子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子类型构造函数时重写这些属性。 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert( <span class="keyword">this</span>.name )</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"> name, age </span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 第二次调用 SuperType();</span></span><br><span class="line">    SuperType.call( <span class="keyword">this</span>, name )</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 第一次调用SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert( <span class="keyword">this</span>.age )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在第一次调用SuperType构造函数时，SubType.prototype会得到两个属性： name和cloors；他们都是SuperType的实例属性，只不过现在位于SubType的原型中</span></span><br><span class="line"><span class="comment"> * 当调用SubType构造函数时，优惠调用一次SuperType构造函数，这一次又在新都向上创建了实例属性name和colors</span></span><br><span class="line"><span class="comment"> * 于是 这两个属性就屏蔽了原型中的两个同名属性</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>什么是寄生组合继承</strong></p>
</li>
<li><p>所谓寄生组合继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。</p>
</li>
<li><p>其背后的思路是： 不必为了制定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。</p>
</li>
<li><p>本质上，就是使用寄生式继承来继承超类型原型，然后再将结果指定给子类型的原型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params"> subType, superType </span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    <span class="keyword">var</span> prototype = object( superType.prototype );</span><br><span class="line">    <span class="comment">// 增强对象</span></span><br><span class="line">    prototype.constructor = subType;</span><br><span class="line">    <span class="comment">// 指定对象</span></span><br><span class="line">    subType.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这个示例中的 inheritPrototype()函数时间了寄生组合式继承的最简单形式。</span></span><br><span class="line"><span class="comment"> * 这个函数接受两个参数： 子类型构造函数和超类型构造函数。</span></span><br><span class="line"><span class="comment"> * 在函数内部，第一步是创建超类型原型的一个副本。</span></span><br><span class="line"><span class="comment"> * 第二步为创建的副本添加`constructor`属性，从而弥补因重写原型而失去的默认的constructor属性。</span></span><br><span class="line"><span class="comment"> * 最后一步，将新创建的对象（即副本）赋值给予类型的原则。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>看下面例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert( <span class="keyword">this</span>.name )</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    SuperType.call( <span class="keyword">this</span>, name )</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype( SubType, SuperType );</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert( <span class="keyword">this</span>.age ) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2024-04-03T16:54:30.000Z" itemprop="dateUpdated">2024-04-04 00:54:30</time>
</span><br>


        
        感谢您的阅读，欢迎评论(*^▽^*) 转载请附上本文链接：<a href="/qw8/knowledges/mian-xiang-dui-xiang.html" target="_blank" rel="external">https://qw8.github.io/qw8/knowledges/mian-xiang-dui-xiang.html</a>
        
    </div>
    
    <footer>
        <a href="https://qw8.github.io/qw8">
            <img src="/qw8/img/avatar.jpg" alt="秦伟">
            秦伟
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/qw8/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/qw8/tags/对象/">对象</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/qw8/tags/类/">类</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://qw8.github.io/qw8/knowledges/mian-xiang-dui-xiang.html&title=《面向对象》 — 秦伟博客&pic=https://qw8.github.io/qw8/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://qw8.github.io/qw8/knowledges/mian-xiang-dui-xiang.html&title=《面向对象》 — 秦伟博客&source=前端、全栈、SEO的知识点、面试题与学习链接的整理" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://qw8.github.io/qw8/knowledges/mian-xiang-dui-xiang.html" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《面向对象》 — 秦伟博客&url=https://qw8.github.io/qw8/knowledges/mian-xiang-dui-xiang.html&via=https://qw8.github.io/qw8" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://qw8.github.io/qw8/knowledges/mian-xiang-dui-xiang.html" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/qw8/interview/javascript-bu-chang-kao.html" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">JavaScript不常考</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/qw8/knowledges/javascript-dui-xiang.html" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">JavaScript对象</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'false' == 'true',
            appId: "TJ17Ax10JrfIIljlO8qkwGvz-gzGzoHsz",
            appKey: "jDGQKdWT9hlzsTLRAbInE4bK",
            avatar: "mm",
            placeholder: "说点什么吧(*╹▽╹*)",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->










</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢您，我会继续努力哒(*^▽^*)
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/qw8/img/wechat.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/qw8/img/wechat.png" data-alipay="/qw8/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

    <footer class="footer">
    <div class="top">
        <div class="map">
            <!--地球信息-->
<script type="text/javascript" src="/js/jquery-3.4.1.js"></script>
<script type="text/javascript">
    var windowWidth = $(window).width();
    if (windowWidth > 480) {
        document.write('<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5mz4gy0w2d8&amp;m=0&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33" async="async">  <\/script>');
    }
</script>
        </div>
        <p>
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>

</p>
        <p>
            <span>本网站总字数：832.3k</span>
            <span id="sitetime"></span>
        </p>
        <p>部分内容来源于互联网，用于个人知识的总结，如有侵权还请联系删除</p>
        <p>
            
            <span><a href="/qw8/atom.xml" target="_blank" class="rss" title="rss"><i
                    class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>

    <div class="bottom">
        <p>
            <span>Copyright &copy; 2019 - 2024 <a
                href="http://pdouyin.com/" target="_blank">秦伟的个人博客</a> All Rights Reserved.</span>
            <!-- <span>
                
                
            </span> -->
        </p>
    </div>
</footer>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2019, 8, 25, 18, 0, 0); // 北京时间
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "已安全运行 " + diffYears + "年 " + diffDays + "天 " + diffHours + "小时 " + diffMinutes + "分钟 " + diffSeconds + "秒";
    }
    siteTime();
</script>
</main>
<div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://qw8.github.io/qw8/knowledges/mian-xiang-dui-xiang.html&title=《面向对象》 — 秦伟博客&pic=https://qw8.github.io/qw8/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://qw8.github.io/qw8/knowledges/mian-xiang-dui-xiang.html&title=《面向对象》 — 秦伟博客&source=前端、全栈、SEO的知识点、面试题与学习链接的整理" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://qw8.github.io/qw8/knowledges/mian-xiang-dui-xiang.html" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《面向对象》 — 秦伟博客&url=https://qw8.github.io/qw8/knowledges/mian-xiang-dui-xiang.html&via=https://qw8.github.io/qw8" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://qw8.github.io/qw8/knowledges/mian-xiang-dui-xiang.html" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACIUlEQVR42u3aQVLDMAwF0N7/0mHNMAlfUgIT+3nVobHj14WQLH8+8ThOxvXzybc/P1/PHQ0MDIzXMo7LcfaCHHa26WSdZG8YGBj7MJ54fRJ8z9bM94aBgYFRTfXyDSVsDAwMjB4jT+N64RUDAwNjUsRWD8iSJ/+hFsfAwHghIy8v//7zI/0NDAyMVzGO4pgUnL3QHO0KAwNjaUYe4Hop2jyhzAtgDAyMVRnXhWUvaUvWzNsJ0VwMDIwNGJPXXAffXlqZ/4jfAi4GBsaijN5Wek2FJ1oOGBgYOzDyojRPIqtP5lfNTtkYGBhLM6rTqgf6SUqXXAsrNDUxMDCWY9wVXqt/mezk9P8GBgbGxoxq8TkpcZs8DAyMDRjPJXO9o7SkLRGdF2JgYCzBmFx9yFPAuy6BRbMwMDCWY+TJX765XvNgtDIGBsY2jGoSls+dJIJRIMbAwNiAUW0J5EVmElJ7R3gYGBj7MKoHaskrq23L3mWLqBbHwMBYiJHfHesdtE1SyUJCiYGBsSUjWWgSspOAXmgnYGBgbMCohs5ku80LE8V2JgYGxtqMozjyAN1rfzYP4zAwMJZmVMNcc3Ix1OZbL+8HAwPjtYxqkK02F++6OvbLz4qBgbEBo3qtIfm210IY1eIYGBgYcXaZp5LzSxsYGBgYk5BaPWjLqTenhhgYGC9hJEVs9WpXtQDOE1AMDIzdGJPScVLcVo/nyskiBgbGCowvfOR0cky3gkgAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/qw8/', SHARE: true, REWARD: true };


</script>

<script src="/qw8/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/qw8/js/search.min.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '(つェ⊂)咦!跑去哪里了';
            clearTimeout(titleTime);
        } else {
            document.title = '欢迎回来━(*｀∀´*)ノ';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>




<!-- 点击特效 -->
<script type="text/javascript" src="/js/clicklove.js"></script>
<!--动态线条背景-->
<script type="text/javascript"
        color="220,220,220" opacity='0.7' zIndex="-2" count="200"
        src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>
<!-- 雪花特效 -->
<script type="text/javascript" src="/js/jquery-3.4.1.js"></script>
<script type="text/javascript">
    var windowWidth = $(window).width();
    if (windowWidth > 480) {
        document.write('<script type="text/javascript" src="/js/snow.js"><\/script>');
    }
</script>

<script>!function(e){var r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function t(){for(var c=0;c<r.length;c++)t=r[c],void 0,0<=(n=t.getBoundingClientRect()).top&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=r[c];t=o,n=function(){r=r.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}t(),e.addEventListener("scroll",function(){!function(t,n){clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)}(t,e)})}(this);</script><script src="/qw8/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/qw8/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"position":"right","width":150,"height":300,"hOffset":-25,"vOffset":30},"mobile":{"show":false,"scale":1.2},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>

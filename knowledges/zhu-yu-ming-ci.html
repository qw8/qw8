<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>术语名词 | 秦伟博客 | 前端、全栈、SEO的知识点、面试题与学习链接的整理</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="名词">
    <meta name="description" content="最近写了太多技术文章，今天想写一点简单的东西。当一个新人问：如何开始学前端？很多知乎人都会发这样的脑图：                                                                                              img               新人表示很淦，并点上右上角的“关闭”。 个人也有很讨厌找学习资源的时候，">
<meta name="keywords" content="名词">
<meta property="og:type" content="article">
<meta property="og:title" content="术语名词">
<meta property="og:url" content="https://qw8.github.io/knowledges/zhu-yu-ming-ci.html">
<meta property="og:site_name" content="秦伟博客">
<meta property="og:description" content="最近写了太多技术文章，今天想写一点简单的东西。当一个新人问：如何开始学前端？很多知乎人都会发这样的脑图：                                                                                              img               新人表示很淦，并点上右上角的“关闭”。 个人也有很讨厌找学习资源的时候，">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:image" content="https://qw8.github.io/img/loading.gif">
<meta property="og:updated_time" content="2024-05-20T10:06:13.020Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="术语名词">
<meta name="twitter:description" content="最近写了太多技术文章，今天想写一点简单的东西。当一个新人问：如何开始学前端？很多知乎人都会发这样的脑图：                                                                                              img               新人表示很淦，并点上右上角的“关闭”。 个人也有很讨厌找学习资源的时候，">
<meta name="twitter:image" content="https://qw8.github.io/img/loading.gif">
    
        <link rel="alternate" type="application/atom+xml" title="秦伟博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/qw.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
<div id="loading" class="active"></div>

<aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">秦伟</h5>
          <a href="mailto:124729081@qq.com" title="124729081@qq.com" class="mail">124729081@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-hourglass"></i>
                时光
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://wpa.qq.com/msgrd?v=3&uin=124729081&site=qq&menu=yes" target="_blank" >
                <i class="icon icon-lg icon-qq"></i>
                聊天
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=124729081@qq.com"  >
                <i class="icon icon-lg icon-envelope-o"></i>
                邮箱
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/user"  >
                <i class="icon icon-lg icon-user"></i>
                简介
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://gitee.com/qw66" target="_blank" >
                <i class="icon icon-lg icon-code"></i>
                Gitee
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/qw8" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

<main id="main">
    <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">术语名词</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">术语名词</h1>
        <h5 class="subtitle">
            
                <time datetime="2021-10-28T07:55:55.000Z" itemprop="datePublished" class="page-time">
  2021-10-28
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/前端知识点/">前端知识点</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#万维网"><span class="post-toc-number">1.</span> <span class="post-toc-text">万维网</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#构建页面骨架"><span class="post-toc-number">2.</span> <span class="post-toc-text">构建页面骨架</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#美化页面"><span class="post-toc-number">3.</span> <span class="post-toc-text">美化页面</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#CSS-UI-库"><span class="post-toc-number">4.</span> <span class="post-toc-text">CSS UI 库</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#响应式布局"><span class="post-toc-number">5.</span> <span class="post-toc-text">响应式布局</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JavaScript-将内容动起来"><span class="post-toc-number">6.</span> <span class="post-toc-text">JavaScript 将内容动起来</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#服务端渲染"><span class="post-toc-number">7.</span> <span class="post-toc-text">服务端渲染</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JSONP"><span class="post-toc-number">8.</span> <span class="post-toc-text">JSONP</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Ajax"><span class="post-toc-number">9.</span> <span class="post-toc-text">Ajax</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Node-js"><span class="post-toc-number">10.</span> <span class="post-toc-text">Node.js</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Serverless"><span class="post-toc-number">11.</span> <span class="post-toc-text">Serverless</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#模块化"><span class="post-toc-number">12.</span> <span class="post-toc-text">模块化</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#包管理工具"><span class="post-toc-number">13.</span> <span class="post-toc-text">包管理工具</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#工程化"><span class="post-toc-number">14.</span> <span class="post-toc-text">工程化</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#CSS-预处理器"><span class="post-toc-number">15.</span> <span class="post-toc-text">CSS 预处理器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#进击的-JavaScript"><span class="post-toc-number">16.</span> <span class="post-toc-text">进击的 JavaScript</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TypeScript"><span class="post-toc-number">17.</span> <span class="post-toc-text">TypeScript</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#单页应用"><span class="post-toc-number">18.</span> <span class="post-toc-text">单页应用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#前端路由"><span class="post-toc-number">18.1.</span> <span class="post-toc-text">前端路由</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#数据管理"><span class="post-toc-number">18.2.</span> <span class="post-toc-text">数据管理</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#同构渲染"><span class="post-toc-number">19.</span> <span class="post-toc-text">同构渲染</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Single-SPA"><span class="post-toc-number">20.</span> <span class="post-toc-text">Single-SPA</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#自动化测试"><span class="post-toc-number">21.</span> <span class="post-toc-text">自动化测试</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#手机H5"><span class="post-toc-number">22.</span> <span class="post-toc-text">手机H5</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#低代码"><span class="post-toc-number">23.</span> <span class="post-toc-text">低代码</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#需求生成代码"><span class="post-toc-number">24.</span> <span class="post-toc-text">需求生成代码</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#最后"><span class="post-toc-number">25.</span> <span class="post-toc-text">最后</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#References"><span class="post-toc-number">25.1.</span> <span class="post-toc-text">References</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1、什么是mvc、mvp、mvvm？什么是前后端分离，前后端分离的优缺点？"><span class="post-toc-number">26.</span> <span class="post-toc-text">1、什么是mvc、mvp、mvvm？什么是前后端分离，前后端分离的优缺点？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2、什么是单页面应用？为什么使用单页面应用？单页面应用路由实现的方法和原理？"><span class="post-toc-number">27.</span> <span class="post-toc-text">2、什么是单页面应用？为什么使用单页面应用？单页面应用路由实现的方法和原理？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3、什么是单线程？单线程与多线程的区别？什么是进程？进程和线程的区别和联系？"><span class="post-toc-number">28.</span> <span class="post-toc-text">3、什么是单线程？单线程与多线程的区别？什么是进程？进程和线程的区别和联系？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4、异步调用的常用方法？什么是异步调用？"><span class="post-toc-number">29.</span> <span class="post-toc-text">4、异步调用的常用方法？什么是异步调用？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5、对webpack的理解？为什么需要webpck？对构建、打包、编译的理解？"><span class="post-toc-number">30.</span> <span class="post-toc-text">5、对webpack的理解？为什么需要webpck？对构建、打包、编译的理解？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6、git常用命令？git和svn的区别？github是什么，npm又是什么？"><span class="post-toc-number">31.</span> <span class="post-toc-text">6、git常用命令？git和svn的区别？github是什么，npm又是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7、什么是构造函数？什么是原型链？原型链的用途？什么是对象？对象的用途？"><span class="post-toc-number">32.</span> <span class="post-toc-text">7、什么是构造函数？什么是原型链？原型链的用途？什么是对象？对象的用途？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8、对http的认识？从输入url到页面展现都发生了什么？"><span class="post-toc-number">33.</span> <span class="post-toc-text">8、对http的认识？从输入url到页面展现都发生了什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#9、什么是BFC？如何实现BFC？盒子模型认识？如何实现标准盒模型？"><span class="post-toc-number">34.</span> <span class="post-toc-text">9、什么是BFC？如何实现BFC？盒子模型认识？如何实现标准盒模型？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#10、什么是栈，什么是堆？栈用来存储什么，堆用来存储什么？"><span class="post-toc-number">35.</span> <span class="post-toc-text">10、什么是栈，什么是堆？栈用来存储什么，堆用来存储什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#11、什么是组件？什么是插件？组件和插件的区别和联系？"><span class="post-toc-number">36.</span> <span class="post-toc-text">11、什么是组件？什么是插件？组件和插件的区别和联系？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#12、对nodejs的认识？什么是事件驱动？什么是非阻塞I-O？"><span class="post-toc-number">37.</span> <span class="post-toc-text">12、对nodejs的认识？什么是事件驱动？什么是非阻塞I/O？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#13、什么是hybrid？为什么使用hybrid？hybrid为什么可以不用审核直接发布？hybrid如何使用？"><span class="post-toc-number">38.</span> <span class="post-toc-text">13、什么是hybrid？为什么使用hybrid？hybrid为什么可以不用审核直接发布？hybrid如何使用？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#14、什么是浅拷贝？什么是深拷贝？如何实现深拷贝？"><span class="post-toc-number">39.</span> <span class="post-toc-text">14、什么是浅拷贝？什么是深拷贝？如何实现深拷贝？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#15、什么是缓存？缓存的分类？cache、localStorage和sessionStorage和理解？"><span class="post-toc-number">40.</span> <span class="post-toc-text">15、什么是缓存？缓存的分类？cache、localStorage和sessionStorage和理解？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#16、什么是闭包？闭包的用途？什么是递归？递归调用的用途？"><span class="post-toc-number">41.</span> <span class="post-toc-text">16、什么是闭包？闭包的用途？什么是递归？递归调用的用途？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#toA、toB、toC、ToG是什么？有什么区别？"><span class="post-toc-number">42.</span> <span class="post-toc-text">toA、toB、toC、ToG是什么？有什么区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#展业"><span class="post-toc-number">43.</span> <span class="post-toc-text">展业</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#解耦"><span class="post-toc-number">44.</span> <span class="post-toc-text">解耦</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#解耦的定义"><span class="post-toc-number">44.1.</span> <span class="post-toc-text">解耦的定义</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#解耦的目标"><span class="post-toc-number">44.2.</span> <span class="post-toc-text">解耦的目标</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#实现解耦的方法"><span class="post-toc-number">44.3.</span> <span class="post-toc-text">实现解耦的方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#解耦的优点"><span class="post-toc-number">44.4.</span> <span class="post-toc-text">解耦的优点</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#前端hook"><span class="post-toc-number">45.</span> <span class="post-toc-text">前端hook</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#转测是什么意思"><span class="post-toc-number">46.</span> <span class="post-toc-text">转测是什么意思</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#提测和转测有啥区别"><span class="post-toc-number">46.1.</span> <span class="post-toc-text">提测和转测有啥区别</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-knowledges/术语名词"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">术语名词</h1>
        <div class="post-meta">
            <time class="post-time" title="2021-10-28 15:55:55" datetime="2021-10-28T07:55:55.000Z"  itemprop="datePublished">2021-10-28</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/前端知识点/">前端知识点</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>最近写了太多技术文章，今天想写一点简单的东西。当一个新人问：如何开始学前端？很多知乎人都会发这样的脑图：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/c624a52c672b72b4b148d47c8f87f279.png" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>新人表示很淦，并点上右上角的“关闭”。</p>
<p>个人也有很讨厌找学习资源的时候，老手总是给一些“大而全”但对新人极度不友好的答案，我知道发图的人可能真的想为了新人好，但是这种图除了增加焦虑，没有大多作用。</p>
<p>但是前端发明了那么多的“名词”，不去了解又会一头雾水。这篇文章就给大家盘一盘前端开发那些“名词”的由来。</p>
<h3 id="万维网"><a href="#万维网" class="headerlink" title="万维网"></a>万维网</h3><p>让我们把时间倒回 1989 年。一个英国佬 Tim Berners-Lee</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/9d55bf0b6c368aaec8b5712f4bc9e579.jpeg" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>发现他们实验室 CERN(European Organization for Nuclear Research)[1] 的资料越来越难管理了，资料很容易“丢失”，比如文件名忘了、或者维护这个文件的人走了，那么这些文件可能就永远“消失”在茫茫资料中了。</p>
<blockquote>
<p>这个 CERN 实验室其实是研究物理的，并不是搞计算机的！但是当时各个地方的实验室都和这个实验室有合作，就难免要相互分享资料。当资料变得越发庞大的时候就很难管理了。另一个点是 CERN 的全名并不是英文名，而是法文：Conseil européen pour la recherche nucléaire</p>
</blockquote>
<p>为此，Lee 提出 “Linked information systems” 的构想，并称为 <strong>World Wide Web</strong>，也即我们熟知的“万维网”。</p>
<p>两年后，在 1990 年，Lee 又发了第二个提案[2]。最后提出需要2个人在6个月内造出的万维网的想法。最后造出了第一个网站：<a href="http://info.cern.ch/。" target="_blank" rel="noopener">http://info.cern.ch/。</a></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/e2123ec46de8ade7a2bbe81c69a82b4e.png" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>从上面可以看到，一个简单的 Client-Server 架构已经出现了。把文件放到服务器上，在客户端上访问它。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/33d76daa8a7332f3ce9db7a6cbe8f557.png" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>



<h3 id="构建页面骨架"><a href="#构建页面骨架" class="headerlink" title="构建页面骨架"></a>构建页面骨架</h3><p>对于学术论文，一般都是有专业格式的，如果只是纯文字展示，换谁也受不了呀。</p>
<p>所以，Lee 受 SGML(Standard Generalized Markup Language) 的启发创建了 <strong>HTML(Hyper Text Markup Language)</strong>。一般常用的标签有：h1~h6, div, header, body, main, footer, table, ul, li, button 等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;header&gt;头&lt;<span class="regexp">/header&gt;</span></span><br><span class="line"><span class="regexp">&lt;main&gt;身&lt;/m</span>ain&gt;</span><br><span class="line">&lt;footer&gt;脚&lt;<span class="regexp">/footer&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果你简单尝试写一个 .html 出来，会发现 <code>和</code> 的效果是一样的。但是，为了代码更<strong>语义化</strong>，也即可以让后面的人能看得懂，一般在头部会使用 <code>，如果是文章则用</code> 作代码块的区分。如果非要扛：我就喜欢用 div 行不行，那不用扛了，当然行！</p>
<h3 id="美化页面"><a href="#美化页面" class="headerlink" title="美化页面"></a>美化页面</h3><p>虽然标签可以做一些简单的样式，但是依然满足不了设计师的样式要求。</p>
<p>为了解决网页的样式问题，Lee 的同事 Håkon Wium Lie[3] 在 1994 年，起草并提出了 <strong>CSS(Cascading Styling Sheet)</strong>。一段简单的 CSS 就可以让页面丰富起来了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很多人可能都知道 CSS 这个玩意，用得理所当然，但是你有没有想过，其实 XML 也可以用来表示样式的，比如在 Android 上就是这么做的。在那个时候， DSSSL[4] 和  FOSI[5] 也曾是浏览器样式的候选人，但是用这两玩意来写样式太麻烦了，所以最后才选择 CSS 作为浏览器的样式书写标准。</p>
<p>现在我们使用 CSS 已经是非常好用了，但在以前 CSS 的标准化之路是充满着坎坷的：</p>
<p>•当 CSS1.0 发布后，几乎没多少浏览器可以支持它。等支持 CSS1.0 的时候 CSS2.0 都已经被放出来了•CSS2.0 增加了更多的样式选择。CSS2.0 是在1997年提出来的，但是在升级为 3.0 的时候经历了大幅的打回、重改，重新提名。直到 2011年 CSS2.1 才作为标准发布出来•到了 CSS3.0，它不像 1.0 和 2.0 那样整个版本升级，而是将样式的升级模块化。现在，虽然我们用的还是 “CSS3.0”，但是其实某些模块已经可以算是 4.0</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/1cd7e3650f520b3cd4b512efb87bb3ae.png" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>



<h3 id="CSS-UI-库"><a href="#CSS-UI-库" class="headerlink" title="CSS UI 库"></a>CSS UI 库</h3><p>写了很多次 CSS 后，前端工程师们发现，一些好看的 CSS 样式可以拿出来共享呀，比如我写好了一个按钮的样式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.btn &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，其它人只要复制这个 CSS 到他的项目里，然后在 HTML 用上 CSS 类名，就可以直接用上我写的效果啦。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">"btn"</span>&gt;我的按钮&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这段时间里，各种 UI 小组件的 CSS 样式满天飞，比如今天出个按钮的，明天就出了个输入框的。市面上还曾出现过很多类似《XX个好看的UI组件》和《XXXX年最好看的Y个UI组件》的文章。</p>
<p>不久后，开发者就发现另一 个问题：组件样式之间的冲突，比如，按钮的样式影响了自定义按钮的样式。另一个大问题是，单看一个组件的样式挺好看的，但是如果一个网页用了4 5 个别人写好的 CSS 样式，就会显得非常不协调，没有统一感。兼容性也很差。</p>
<p>Twitter 的 Mark Otto 和 Jacob Thornton 也想过这个问题，所以他们开发了 <strong>Bootstrap</strong> UI 库：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/155940849d5119096dbd2cefa9170b78.png" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"input-group mb-3"</span>&gt;</span><br><span class="line">  &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"input-group-text"</span> id=<span class="string">"basic-addon1"</span>&gt;@&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;input type="text" class="form-control" placeholder="Username" aria-label="Username" aria-describedby="basic-addon1"&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>

<p>把常用的按钮、字体、输入框的一些样式都写好了，还提供示例代码。这个 UI 库发布了之后，几乎所有开发者用过了，毕竟 CSS 终于可以不用自己写了。</p>
<p>当时我的也用 Bootstrap 写过课堂作业，那真是爽啊，一行 CSS 都没写过。</p>
<h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><p>2011年，苹果发布了那款经典的 iPhone4S，标志着智能手机真正成为人们不可或缺的一部分，而手机上访问的需求也同时增加了不少。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/d95aa56f0ad03cd0419e6701883fe762.jpeg" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>当年在手机上看网页，用户都要先进入页面，手动放大，点击对应链接再进入下一个网页，操作非常复杂，而且界面很丑陋。</p>
<p>另一个方面，随着手机进入人们的生活，手机上的 App 也像雨后春笋一样疯狂冒出。这时，程序员就想：就把网页做成 App 的样子不就好看了嘛。</p>
<p>那怎么判断用户用的是手机还是电脑呢？很简单：通过屏幕宽度来判断嘛，而 CSS 的 <strong>media query（媒体查询）</strong> 正好可以用来解决这个问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*屏幕宽度在 600px 以内时，背景色显示红色*/</span></span><br><span class="line">@media only screen and (max-width: <span class="number">600</span>px) &#123;</span><br><span class="line">  body &#123;</span><br><span class="line">    background-color: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*大于 600它时，背景色显示白色*/</span></span><br><span class="line">@media only screen and (min-width: <span class="number">600</span>px) &#123;</span><br><span class="line">  body &#123;</span><br><span class="line">    background-color: white;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题又来了：难道每个兼容样式都要写两遍？能不能只写一种样式就能兼容手机和电脑端呢？程序员们开始通过百分比，em，rem，优化布局等方式，使得屏幕变小后样式还是不会乱。</p>
<p>这种写 CSS 的思路就叫做 <strong>响应式</strong> 布局，兼容了手机和网页。</p>
<p>不过 <strong>响应式</strong> 也不是万能的。比如今天淘宝页面里的一些花里胡哨的样式就没法兼容手机端，所以现在的做法是做两套网页，电脑端做一套，手机端做一套。区别是：手机端的样式做得像 App 一些，而且功能不会太多，样式也不会很复杂，而且提供“从XX App”打开的按钮，向自家的 App 引流。电脑端更酷炫，功能更强大。毕竟现在应该没人在手机网页上购物吧？</p>
<p>如果你仔细看手机端的网页地址，都会以 m.xxxxx 开头，就表示网页只在手机上看的。</p>
<h3 id="JavaScript-将内容动起来"><a href="#JavaScript-将内容动起来" class="headerlink" title="JavaScript 将内容动起来"></a>JavaScript 将内容动起来</h3><blockquote>
<p>注意：上面的 HTML、CSS 都不属于编程语言，HTML 是标记语言，而 CSS 是样式表。</p>
</blockquote>
<p>现在我们有 HTML 和 CSS 已经可以让页面变好看了，但是页面内容都是定死的。为了能让页面“动”起来，浏览器必须要引入一种编程语言。那就是 <strong>JavaScript</strong>。</p>
<p>当年，本来有人想把 Java 用作浏览器的编程语言的，但是搞 Java 的 Sun 公司说：没空理你。所以，网景公司 NetSpace 只好自研编程语言。本来新语言想叫作 LiveScript，但是觉得这个名字又平平无其，不能一炮而红。当时 Java 正如日中天，所以，为了做个标题党、蹭个热度，在 12 月发布的时候改名为 <strong>JavaScript</strong>，并引入了一些 Java 的特性，然而，令人没想到的是，这些特性将会成为前端工程师的噩梦。</p>
<p>JavaScript 除了做一些简单的业务逻辑，比如判断是男是女：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (you === <span class="string">'male'</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'男男'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还会操作 HTML，但是 HTML 不是一段文本么？怎么操作呢？实际上当浏览器拿到 .html 文件后，会自动解析 HTML 文本，将其转为为 <strong>DOM(Document Object Modal)</strong>，将普通的文本转换为一棵树的结构。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/816151e9b764baf1861c3d7d94997e28.png" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>JS 只需操作 DOM 就可以修改 HTML 的布局和结构了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getDocumentById(<span class="string">'hello'</span>).textContent = <span class="string">'我是帅哥'</span> <span class="comment">// 内容变成“我是帅哥”</span></span><br></pre></td></tr></table></figure>

<p><strong>JavaScript</strong> 是一个设计极其糟糕的语言，比如 <code>getMonth()</code> 时，如果现在是1 月，返回的则是 <code>0</code>，而 <code>getHours()</code> 又会准确返回当前的小时数。对于数组的操作又少得可怜，比如没有 <code>unique</code>, <code>findBy</code> 这些 API。</p>
<p>为了给 JavaScript 的设计擦屁股，一些工具库营运而生：</p>
<p>•jQuery: 提供很多操作 DOM 的 API•moment, dayjs：提供很多操作 Date 对象的 API•lodash：更多像是个工具库</p>
<h3 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h3><p>虽然 JS 能动态修改内容了，但是，在以前发异步请求是一件很麻烦的事情。</p>
<p>Java 程序员想到了一个办法：JSP。反正要访问服务端，不如在你访问的时候，我直接从数据库里把数据读出来，生成一个 HTML 给你不就好了嘛。这种技术就叫做 JSP。</p>
<p>代码语言：javascript</p>
<p>复制</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=UTF-8"</span></span><br><span class="line">    pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.io.*,java.util.*"</span> %&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">&lt;title&gt;菜鸟教程(runoob.com)&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;HTTP 头部请求实例&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">&lt;table width="100%" border="1" align="center"&gt;</span></span><br><span class="line"><span class="regexp">&lt;tr bgcolor="#949494"&gt;</span></span><br><span class="line"><span class="regexp">&lt;th&gt;Header Name&lt;/</span>th&gt;<span class="xml"><span class="tag">&lt;<span class="name">th</span>&gt;</span>Header Value(s)<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">&lt;%</span></span><br><span class="line"><span class="regexp">   Enumeration headerNames = request.getHeaderNames();</span></span><br><span class="line"><span class="regexp">   while(headerNames.hasMoreElements()) &#123;</span></span><br><span class="line"><span class="regexp">      String paramName = (String)headerNames.nextElement();</span></span><br><span class="line"><span class="regexp">      out.print("&lt;tr&gt;&lt;td&gt;" + paramName + "&lt;/</span>td&gt;\n<span class="string">");</span></span><br><span class="line"><span class="string">      String paramValue = request.getHeader(paramName);</span></span><br><span class="line"><span class="string">      out.println("</span>&lt;td&gt; <span class="string">" + paramValue + "</span>&lt;<span class="regexp">/td&gt;&lt;/</span>tr&gt;\n<span class="string">");</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">%&gt;</span></span><br><span class="line"><span class="string">&lt;/table&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>

<p>被程序员一直喊为 “世界上最好的编程语言” PHP也沿用了这个思路。这类通过服务端动态生成 HTML 的方法就叫 </p>
<p> <strong>服务端渲染</strong>。</p>
<p>但是这上面有两个问题：</p>
<p>1.如果 Java 里有报错的时候，页面会显示整个错误 Stack 给用户，体验非常不友好，而且一崩全崩</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/6b3e54c8fb0d5f091e54cb34cc621ecd.png" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>1.高度耦合的代码非常不利于维护，比如，第一眼看上面的代码能看出个啥子哦2.一个工程师除了要处理服务端的逻辑、也要考虑样式要怎么写、页面逻辑，职责不明确</p>
<p>虽然上面的 JSP 和 PHP 流行过一段时间，但是程序员们为了分工更明确，都选择了前端程序员管页面开发、而后端程序员管服务端的开发。这种开发模式也被称作 <strong>前后端分离</strong>。</p>
<p>而前后端的重要沟通桥梁就是<strong>异步请求</strong>，也即大家现在经常说的 <strong>Ajax请求</strong>，但是在很久以前，异步请求还是一个实现上特别困难的事情。在那个时候发完请求，页面就不得不重新刷新一遍，用户体验非常差。</p>
<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>上面说到的问题在于：浏览器很难在不刷新页面的情况下，向服务器发异步请求来获取内容。</p>
<p>聪明的程序员就开始想：什么东西能发异步请求呢？然后他们发现如果直接创建一个 img 标签并写上 src 就会向服务器发一个 xxx.jpg 的异步请求了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">"xxx.jpg"</span>&gt;</span><br></pre></td></tr></table></figure>

<p>那么如果要发个异步的 Get 请求，可以这样搞呀：</p>
<p>1.偷偷摸摸地创建一个看不见的 img 标签2.把要访问的 url 放到 src 里</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> imgEl = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>) <span class="comment">// 创建 img 标签</span></span><br><span class="line"></span><br><span class="line">  imgEl.visibility = <span class="string">'none'</span> <span class="comment">// 把 img 标签变成不可见</span></span><br><span class="line"></span><br><span class="line">  imgEl.src = url</span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.appendChild(img) <span class="comment">// 加在网页上，自动发送 Get 请求</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是上面这么又引出下面的问题：</p>
<p>1.不知道什么时候要清理新生成的 img2.请求发了就发了，响应后不知道怎么获取数据3.每次都要写 <code>imgEl.visibility = &#39;none&#39; // 把 img 标签变成不可见</code> 这句话</p>
<p>为此，程序员再次想了很多办法。</p>
<p>首先，不再使用 img 标签，而使用 script 标签，就可以把第 3 步省略了。</p>
<p>第二步，在全局定义一个函数用于获取 users 信息：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUsers</span>(<span class="params">users</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(users)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在写 url 的时候加一个参数上去：<code>https://www.baidu.com/users?callback=getUsers</code>。服务端从参数里读取到 getUsers，向浏览器返回 JS 脚本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getUsers([<span class="string">'Jack'</span>. <span class="string">'Mary'</span>])</span><br></pre></td></tr></table></figure>

<p>由于刚刚添加的标签是 script 标签，所以等服务器返回后，<code>getUsers([&#39;Jack&#39;. &#39;Mary&#39;])</code> 就会被马上执行，最终就会将 <code>users</code> 打印出来。这种技术就叫做 <strong>JSONP</strong>，全称为 JSON with padding。</p>
<p>JSONP 另一个好处是可以实现跨域请求，因为 script 标签可以请求非同源策略的资源并获取返回的数据。但是这非常不安全，服务器很容易被一些恶意的 JS 代码给攻击了。</p>
<h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><p>从上面看出来 JSONP 能用但是很不规范，程序员们非常想要一套完善的异步请求机制。</p>
<p>2004 年，Google 在开发 Gmail 和 Map 两个应用的时候，完善了异步请求的机制，并制定了一些标准。</p>
<p>2006年时， W3C 起草了第一份 XMLHttpRequest 的草案，然后不断完善，一直到最后一份草案则在 2016年 被提出，<strong>XMLHttpRequest</strong> 才成为正式的标准。我们经常所说的 Ajax 请求其实就是使用这个对象来发请求的。下面就是用这个对象发送请求的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成请求对象</span></span><br><span class="line">xmlhttp = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 监听请求的状态和返回</span></span><br><span class="line">xmlhttp.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xmlhttp.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (xmlhttp.status === <span class="number">200</span>) &#123; <span class="comment">// 200 = OK</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'成功'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'失败'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 打开通道</span></span><br><span class="line">xmlhttp.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>)</span><br><span class="line"><span class="comment">// 发送请求</span></span><br><span class="line">xmlhttp.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p><strong>Ajax</strong> 全名是 Asynchronous JavaScript[6] and XML[7]，它不是单单一门技术，而是多门技术的全集，所表求的是：在客户端创建异步应用的一系列技术。只不过核心其中一步就是发异步请求，而 XMLHttpRequest 正好可以帮助我们完成这项工作。</p>
<h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>2009 年，前端另一大飓风席卷了全球。Ryan Dahl 编写了第一个最初版本的 Node.js，使得 JavaScript 除了可以在浏览器里运行，也可以在拥有 Node.js 平台的地方运行，比如自己电脑的终端里。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/d8de1dd5e751be71d2d41bb05738febe.png" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>JavaScript 终于不再是客户端语言，也可以做服务端的开发了。为了更方便做服务端的开发，TJ Holowaychuk 一个国外超级大佬，借鉴了 Ruby 社区的 Rack，开发了 Express.js，一个简易的 JS 服务器框架。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/f896eecae3af973eeb919ab01f9bf3b0.png" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>由于 Express.js 提供的功能太简单了，所以，很多开发者不断给这个框架开发各种各样的<a href="https://cloud.tencent.com/product/tdmq?from_column=20065&from=20065" target="_blank" rel="noopener">中间件</a>，使用者可以用这些中间件增强自己服务器的功能，比如 <strong>body-parser, cookie-parser, passport</strong> 等。</p>
<p>后来，TJ 觉得 Express.js 写得还是不够精简，本来想重构的，但是重构成本太大了，干脆再造一个轮子吧，这个轮子也就是我们熟悉的 Koa.js。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/c18663262de077852d6c8d485de18570.png" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>为了让 JS 更好地完成服务端开发的工作，前端开发人员把后端开发的一些工具都造了一遍：</p>
<p>•连接数据库：mysql, mysql2, mongodb•缓存：session, redis•ORM: TypeORM, sequelize•定时任务：node-schedule, cron•…</p>
<h3 id="Serverless"><a href="#Serverless" class="headerlink" title="Serverless"></a>Serverless</h3><p>当很多人都开始用 Node.js 的时候，大家又发现一些问题：</p>
<p>1.写完代码，本地跑起来也挺好的，那怎么部署到服务器上呢？2.服务器要怎么买？HTTPS证书从哪里获取？Nginx是个啥？啊，好烦啊，我只想 <code>npm run start</code> 啊</p>
<p>作为前端程序员，平时搬砖就够累了，还要我配置服务器，一剑杀了我算了。</p>
<p>聪明的程序员发现，不管你写 Express.js 还是 Koa.js 不就是写响应函数么？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/users'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'我是帅哥'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>那我把服务器、证书、域名这些东西都统统给你弄好，你就负责写相应函数和给钱不就很爽了么？这就是 <a href="https://cloud.tencent.com/product/serverless-catalog?from_column=20065&from=20065" target="_blank" rel="noopener"><strong>Serverless</strong></a> 的由来。它的好处是不再操心服务器的配置、扩展等琐碎的事情，只需要写好响应函数就好了。而这种“响应函数”也被称为 <a href="https://cloud.tencent.com/product/scf?from_column=20065&from=20065" target="_blank" rel="noopener"><strong>云函数</strong></a>，Amazon 称此为 <strong>Lambda</strong>。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/519f3ed090dd59e4f7884b77581d193c.png" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>这时候有人发现，我自己写好的一些服务，比如收发邮件、数据库的存取也可以作为一种服务对外提供，前端工程师只需要给钱，然后请求我提供的 API 接口就可以享受我的服务啦。这也是很多云厂商另一种收入来源：卖服务。</p>
<p>比如，常见的：语言翻译服务、手机短信发送服务、鉴黄师、图形识别等。</p>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>当工具变得越来越多，Web 应用体积也变得越来越大了。一个大项目里可能有成百上千个 JavaScript 文件，它们之间相互依赖，可怕的是当前没有工具可以告诉你到底哪个文件是最先被执行的。</p>
<p>文件的管理就成了一个大问题，所以以应用需要划分模块。</p>
<p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 <strong>CommonJS</strong> 和 <strong>AMD</strong> 两种。前者用于服务器，后者用于浏览器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xxx = <span class="built_in">require</span>(<span class="string">'xxx'</span>)</span><br></pre></td></tr></table></figure>

<p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xxx <span class="keyword">from</span> <span class="string">'xxx'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> xxx</span><br></pre></td></tr></table></figure>

<p>模块化思想的提出大大提高了 JS 程序员的幸福感，所有的 JS 文件都不再是同一层级，而可以分块管理了。对前端的工程化有着不可或缺的作用。</p>
<h3 id="包管理工具"><a href="#包管理工具" class="headerlink" title="包管理工具"></a>包管理工具</h3><p>有的工程师发现，自己抽象出来的模块其实也可以放在社区让别人使用，比如发异步请求的 axios，工具库 lodash 等。这就需要一个中心仓库来存放这些库了，同时也需要一个包管理工具来管理包的发布、安装、升级等。</p>
<p>目前 <strong>npm</strong> 就是使用最多的包管理工具，当电脑里装了 Node.js 后，<strong>npm</strong> 也会一并装上。不过使用 npm 在国内下载时会很慢，一般推荐使用 <strong>yarn</strong> 这个包管理工具，速度更快。</p>
<h3 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h3><p>模块拆分使得写代码时候爽了，但是如果把这些 JS 文件都引入到一个 HTML 上是不是太恐怖了？一个 HTML 里有 1000 个 script 标签，比内容还多也有点反人类了吧。CSS 文件同理。</p>
<p>为了解决这个问题，前端工程师提出了 bundle 这个概念——不管你的模块多乱，多分散，最终通过一个工具，直接转换为1 个 .js 文件。这样的工具就叫做打包工具。</p>
<p>在 2016 年，Grunt，一个 JavaScript Task Runner 被制作出来了，开发者可以编写自己的任务，然后流水线地执行。这已经有了工程化的雏形了。</p>
<p>但是 Grunt 的打包速度太慢了。工程师们受不了了，又造了一个 <strong>Glup</strong> 的打包工具，功能差不多，但是一个字快！</p>
<p>与此同时，另一只巨兽也在悄然进化——<strong>Webpack</strong>。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/10a722e3b8e6e092873151ec42fde490.png" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p><strong>Webpack</strong> 以其强大的功能、高灵活配置度的特性直接抢夺了 Glup 的市场，很多人都纷纷用起了 Webpack。</p>
<p>随着 Webpack 的功能不断增强，开发者的要求也不断提高，市面上充斥着大量的 Loader 和插件：</p>
<p>•热加载•代码混淆•代码压缩•精简代码、TreeShaking•loader: file-loader, css-loader, vue-loader•…</p>
<p>Webpack 的另一个问题是，不同环境需要不同的 Webpack 打包配置，导致 Webpack 的配置越来越繁琐，前端工程师除了平常写代码之外，还要负责维护 <code>webpack.config.js</code> 的配置项目。</p>
<p>而 <strong>Parcel</strong> 的出现正好打破了这一局面，使用 Parcel 就像使用 iPhone 一样，不用太多配置可以马上跑出小网页。但是，治本不治根，在大型项目面前，还是没办法解决繁琐配置的问题。所以，Webpack 依旧是占领市场的巨头。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/f216bc99cfb7c84445841c1076c0ff26.jpeg" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>使用 Webpack 的另一个问题是本地开发打包很慢，Webpack 一般先打包构建再启动开发服务器。而 Evan You 则想到另一个方法：先启动开发服务器，当代码执行到模块加载时再请求对应模块的文件。加快本地开发时的打包编译速度，然后造出了 <strong>Vite</strong>。目前 Vite 还是个新生儿，可以关注一波，看看以它以后会迸发出什么好玩的东西。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/cbcce8db1eb350605e4f3ca74dbfe5ad.png" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>



<h3 id="CSS-预处理器"><a href="#CSS-预处理器" class="headerlink" title="CSS 预处理器"></a>CSS 预处理器</h3><p>CSS 让人诟病的一点是不够简洁，很多东西不能复用。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.container &#123; </span><br><span class="line">  background: red; <span class="comment">/*背景为红色*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.container .title &#123; </span><br><span class="line">  color: red; <span class="comment">/*标题字体为红色*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么不写成这样呢：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  backtround: red; <span class="comment">/*背景为红色*/</span></span><br><span class="line">  .title &#123;</span><br><span class="line">    color: red; <span class="comment">/*标题字体为红色*/</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遗憾的是，浏览器只认识 CSS，不认识上面这样的写法。程序员又开始思考了：其实我不用浏览器认识第二种写法，我只要把第二种写法在打包的时候转换成 CSS 不就行了嘛。有了打包工具的加成，这件事我觉得能成！所以，第二种高级写法被称为 <strong>CSS 预处理器</strong>，即这些写法要先被处理成 CSS，然后再以普通 CSS 使用。</p>
<p>于是，在 2007 年，<strong>Sass</strong> 诞生了，借鉴了 Ruby 社区的 Sass 语法，但是前端程序员比较傲娇：凭啥要跟你叫一个名，就叫为 Scss，不过一般叫法还是叫 Sass，因为 Scss 不会读，哈哈。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/9933848d228476458a2ca34d4ef739fa.png" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>后来在 2009 年，<strong>Less</strong> 被创造出来了，语法 Scss 差不多，没多大差别。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/6ebc30397dbd04f2e70617a7281b8fb6.jpeg" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>在 2010 年，又一个预处理器 <strong>Stylus</strong> 诞生了。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/83507d22446d72182ec0e6a9555c0da6.png" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>目前 Scss 和 Less 用的比较多，Stylus 名气比较小。新手不用担心，这三玩意语法都差不多，大同小异，会一个相当于3个都会了。</p>
<h3 id="进击的-JavaScript"><a href="#进击的-JavaScript" class="headerlink" title="进击的 JavaScript"></a>进击的 JavaScript</h3><p>虽然 JavaScript 本来是一个设计非常糟糕的编程语言，但是 JS 它不是咸鱼，它也要努力成为世界上最好的编程语言！</p>
<p>JavaScript 总不能一成不变吧？但是也不能一下子就变天了吧？所以，需要有一个起草方案，审核方案，同意方案，变成规范的过程，这需要大量的人力和专家，那不如做一个 “JS爱好者协会”？<strong>European Computer Manufacturers Association (ECMA)</strong> 就是类似这样的组织，不过这个组织格局比“JS爱好者协会”的格局大多了，主要任务是是将 Computer System 标准化。</p>
<p>ECMA International 在 ECMA-262[8] 里规范了 JavaScript，可以认为 ECMAScript 就是标准的 JavaScript，所有浏览器都要支持标准的 JavaScript。这个 262 的标准规范从 1997 年开始提出了第 1 版。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/31b06ca57905dca132dc754fe91a2bb3.png" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>从上面可以看到，往后几年就是第 N 代的 ES 标准对应标准的 JavaScript 就是 ECMAScript 201(N-1)，比如我们最熟悉的 ES6 其实就是 ECMAScript 2015。而 ES6 对 JavaScript 一个大变革，后面的 ES7，ES8 新增的东西就很少了，所以现在 ES6 其实是 ES6+ 的一个泛指。</p>
<p>但是你有没有想过一个问题：虽然我用最新的语法做开发，但是用户用的可能还是老版本的浏览器呀，这要怎么办呢？</p>
<p>再次得益于自动化打包工具的兴起，我们可以在开发的时候用最新的语法，在打包生产代码时将新语法都转成旧语法就好了嘛。这种语法的转换听起来就很麻烦，不过，聪明的前端工程师已经帮各位大哥大嫂做好，那就是 <strong>Babel</strong>。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/5369b1cb59b565ac5f718995ae2b7b77.png" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p><strong>Babel</strong> 发展到了现在，除了做新旧语法的转换，还支持 JSX 语法的转换。</p>
<h3 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h3><p>虽然 ES6 新增的语法和 API 已经大幅提升前端程序员的幸福感了，但是 JavaScript 依然是个弱类型的语言：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/d0c5946d24b587c7c779f3c2ac88ffae.jpeg" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>类型不规范，同事两行泪。当不正确使用类型时：</p>
<p>那能不能强行给 JavaScript 加上类型呢？微软说：可以！由微软牵头，开发了 <strong>TypeScript</strong> 编程语言和 TypeScript 的编译器，前者其实是 JavaScript 的超集，只是多加了很多料；后者则是负责将 TypeScript 编译成 JavaScript。</p>
<blockquote>
<p>注意：这里的 TypeScript -&gt; JavaScript 是不能用 Babel 实现的，因为这一步是编译，而不是新旧语法的替换。TypeScript 不是新语法，是一门正经的编程语言，只不过可以被编译成 JavaScript。</p>
</blockquote>
<p>有了 TypeScript，开发者终于享受到了强类型约束的福利了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x: string = <span class="string">'123'</span></span><br></pre></td></tr></table></figure>

<p>再再再一次得益于自动化打包工具人 Webpack，可以在输出生产代码时将 TypeScript 编译成 JavaScript，如果再加上 Babel，则能进一步转为某个时代的 ECMAScript。</p>
<h3 id="单页应用"><a href="#单页应用" class="headerlink" title="单页应用"></a>单页应用</h3><p>在打包工具不断厮杀的同时，单页应用框架也一并发展。</p>
<p>在以前，大部分都是一直在用 jQuery 直接操作 DOM 来更新页面。</p>
<p>每次操作 DOM 时就不得不写一些面条代码。但是这样很麻烦啊，操作 DOM 这一步能不能封装一下，数据更新时自动操作 DOM 去更新页面？</p>
<p>2010 年，Google 研发的 <strong>Angular.js</strong> 率先实现了 <strong>MVVM</strong> 想法，即开发者不再需要操作 DOM，可以直接拿数据渲染页面 Modal-View，而页面的变化，比如输入值改变，可以反过来改变数据内容。后来又研发了 Angular2，但是无论是 Angular.js 还是 Angular 本身都太复杂了，借鉴了非常多的后端设计，前端工程师上手难度非常巨大，最终并没有形成大潮流。</p>
<blockquote>
<p>注意 Angular.js 和 Angular 是两个不同的东西！</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/6010408ba5076c450fe69b6076c57e35.png" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>2013 年，一个新的前端框架诞生了——Facebook 的 React.js。React 可以说是一个非常纯净的 JS 框架，没有 Angular 繁琐的内容，开发者只需要关注单向数据流就可以上手撸页面了。最后 React.js 在前端社区流行了起来。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/85a7c0240e136a6b5640032592a5fc11.png" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>但是 React.js 也有自己的问题：由于 React.js 内容太过于纯净了，本身没有太多的功能，导致开发 React 应用时出现非常多的解决方案，但没有一个方案是最优的，各有各的优缺点。这也导致了 React 社区总是骂战不断、帮派林立、出现各式各样的鄙视链的局面。</p>
<p>比如，在写样式时你可以直接 import 样式文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'xxx.css'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> xxx = <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">"xxx"</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>也可以用 CSS module</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'xxx.css'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> xxx = <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&#123;styles.xxx&#125;</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>也可以用 styled-component</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Button = styled.a<span class="string">`</span></span><br><span class="line"><span class="string">  color: white;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> xxx = <span class="xml"><span class="tag">&lt;<span class="name">Button</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>但是偏偏有人说 styled-components 是高级人，别的都是垃圾，使用 CSS Module 的人就受不了了，说你天天引那么多库来干嘛？</p>
<p>另一个麻烦点是，单向数据流并不是所有人都喜欢的，人们开始怀念 Angular 的数据双向绑定了。</p>
<p>到了 2014 年，那个男人来了，他带着 <strong>Vue.js</strong> 来了！</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/86c283b7e2e5dba13748d0a195af9de8.jpeg" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>Evan You 以前在 Google 和 Meteor 工作过。<strong>Vue.js</strong> 取了 Angular 和 React 的中间位置，以一种优雅、轻便的姿态登陆前端社区。保留了 Angular 的数据双向绑定，但是摒弃了 Angular 很多复杂的设计和 API，同时不像 React.js 那么纯净，开放很多方便的 API 给使用者爽爽。而且还基于 Webpack 开发了 vue-loader 用来解析 .vue 模板文件。这种 .vue 模板文件和 .html 非常相象，新人上手十分简单。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/d3c32e0ee440b2085525a5fc80b70412.png" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>同时，得益于 Vue 简洁好看的中文官方文档，Vue.js 在中国迅速抢占了小公司的市场。</p>
<p>但是由于 Vue.js 太容易上手了，所以经常被 React.js 社区的一些人觉得写 Vue.js 的人都是新手。而 Vue.js 的人又觉得写 React.js 的人天天折腾这么多“最佳实践”，简直是在浪费生命，而且 JSX 的语法太丑了，不如我的 template 语法简洁好懂。直到现在，Vue 和 React 社区时不时就会爆发小规模的骂战。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/41f9f48cfcfbe96fc6d21116aed860c1.png" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>另一个问题出现了：原来的 UI 库仅仅提供了简单的 CSS 和原生的 JS，这些 JS 放到单页应用里显得有点冗余了，有的还会报错，因为大多数都是 DOM 的操作。所以 UI 库必须要配合对应的 SPA 框架进行升级。在别的 UI 库升级的同时，饿了么针对 Vue.js 开发 Element UI，而蚂蚁金服则针对 React 开发了 Antd。随后，更多的 UI 库再次涌现，比如 iView、Ant Design for Vue, Ant Design for Angular 等。</p>
<p>总得来说，Angular, React.js, Vue.js 都开发了自己的一套单页应用框架，这套框架最后要做的就是 SPA(Single Page Application) 单页应用。即所有的逻辑都打包在 JavaScript 文件里了，对外，只会看到一个 .html，一个 .css 和一个 .js 文件。</p>
<p>等一下？一个 .html 文件？那不同页面怎么做跳转呢？这就是前端路由的由来了。</p>
<h4 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h4><p>不妨想想以前是怎么做路由的：用户页是 user.html，首页是 index.html，一个 url 对应着一个文件，也就说我们每次键入 url 时，实际上是访问某个 .html。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/18810ca08c84e3c16517902ba1fb9010.png" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>而浏览器里有一个监听浏览器地址改变的功能，单页应用的开发者就想了：我只要监听地址 url 的变化，再用 JS 渲染对应的页面组件，不就可以实现前端控制路由了么？这就是前端路由的基本思想。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/70332ccc4dbb79b3adaf785f2c9ee76b.png" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>上面的三大单页应用框架都有自己的前端路由框架：<strong>@angular/router, react-router, vue-router</strong>。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/a0e29cee63b5d94cfeda163820c47e52.png" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>



<h4 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h4><p>单页应用框架另一个问题就是数据的管理，子组件访问的数据都只能靠父组件传过来，如果一个在很深的子组件想要最外层组件的数据时，就不得不把数据从头一路传到尾。</p>
<p>为了应对这种数据很难共享的问题，程序员就想：我把数据都存到一个公共的地方不就行了嘛？要的时候随便拿。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/ea4d9aee11a0bfbbab8d704cff41bf42.png" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>那公共地方是哪里呢？存全局变量？不行啊，会被别人覆盖啊，而且数据改了之后视图不能随之改变呀。所以，工程师又开发一些全局数据管理库：<strong>mobx, vuex, redux。</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/41241d492ca57d29612e87c050cfdfd8.jpeg" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>



<h3 id="同构渲染"><a href="#同构渲染" class="headerlink" title="同构渲染"></a>同构渲染</h3><p>用多了单页框架之后，程序员们又发现问题了，单页最后生成的 HTML 是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=<span class="string">"root"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &lt;script src=<span class="string">"bundle.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br></pre></td></tr></table></figure>

<p>要知道搜索引擎每天都会用<strong>网络爬虫</strong>抓取成千上万个网页，分析 HTML 里的内容，以此来提高搜索准确性，这种做法做叫 SEO(Search engine optimization) 搜索引擎优化。但是你看上面这样的结构，搜索引擎根本不知道你这个网页是用来干嘛的。另一个问题是，如果用户网络环境很差，那只要 JS 还没被加载出来，网页永远是一片白色，这非常影响用户体验。这要怎么解决呢？</p>
<p>大家开始怀念当时 JSP、PHP 服务端渲染 HTML 的时候了，因为服务端渲染 HTML 可以马上返回 HTML 结构，页面会先展示一些内容，不至于白屏，而且有了大概的 HTML 结构，搜索引擎更容易做 SEO。</p>
<p>前端工程师想到了：对于一些静态内容，比如商品种类、导航栏内容，其实可以在生成 HTML 的时候就加上，不需要再通过 API 获取了。这样的技术就叫做 SSG(Static Site Generation)。那动态的内容，比如朋友圈列表怎么做呢？初始展示的数据可以先通过服务端先渲染，等用户与页面发生交互，比如点击按钮后再发请求获取数据。这就是 <strong>同构渲染</strong>。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/908abb3695329c0c1b09136587593379.png" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>与传统的服务端渲染不同，同构渲染的服务端也使用 JavaScript 来编写，这样一来前后端都使用上了 JavaScript 了。</p>
<p>同构渲染简单来说就是一份代码，服务端先通过服务端渲染(server-side rendering)，生成html以及初始化数据，客户端拿到代码和初始化数据后，通过对 html 的 dom 进行 patch 和事件绑定对 Dom 进行客户端激活(client-side hydration)。</p>
<p>这个整体的过程叫同构渲染。既可以吸取服务端的优点，比如加速首屏渲染，又保留了 SPA 应用的特点，比如前端控制路由跳转，使得跳转时不需要再渲染新 HTML。</p>
<h3 id="Single-SPA"><a href="#Single-SPA" class="headerlink" title="Single-SPA"></a>Single-SPA</h3><p>当越来越多项目用上了 SPA 框架后，当公司要把多个项目合并成一个项目的时候，这就很麻烦了，不同项目可能用的框架都不一样，比如用户详情用的是 Vue.js，而首页用的是 React.js，怎么把这两者结合呢？</p>
<p><strong>single-spa</strong> 和国内阿里开发的<strong>乾坤</strong>就是解决这种问题的。本质上相当于造一个更大的“单页的应用”，这个“单页应用”里又会有多个单页的应用。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/782de91bef50204600af7a28e9f8e68a.png" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>这种将多个 SPA 整合成一个大 Project 的技术就是 <strong>微前端</strong>。</p>
<h3 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h3><p>随着前端越来越工程化，自动化测试是比不可少的一件事。当造好一些轮子后，就需要接入自动化测试，不然每次修改都要做点点点的人工测试。</p>
<p>最简单的莫过于单元测试，目前单测常用的库有 <strong>*ava, jest, moch, sinon, chai</strong> 等。而前端又是一个非常依赖环境的工种，经常要用到不同的环境，比如 JSX 环境、浏览器环境，Vue 环境。又催生出很多提供 Mock 环境的库，比如 <strong>enzyme</strong> 就是用来提供 React 环境的。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/612edada3869ed46f346ec72420082d3.png" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>同时，为了模拟一些特定的场景，前端还要 Mock 一些东西，比如 localStorage, indexedDB, cookie 等。这些都有不同的库和工具来实现，比如 mock-axios, mock-redux, mock-cookie 等。</p>
<p>上面的只是属于白盒测试的做法，前端能不能直接模拟人工做点点点的操作呢？可以的，这就叫<strong>端对端测试</strong>、或者叫 <strong>e2e 测试</strong>，或者叫集成测试。现在比较火的工具是 <strong>cypress</strong> 和 <strong>nightwatch</strong>。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/765e9dd968ff611cdd4b79074b47074f.png" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>不过对于业务经常频繁改动的项目，自动化测试并不是一件好事，改动频繁的业务带来的是变化无常的测试用例。写太多的测试代码，有时候变得事倍功半。</p>
<h3 id="手机H5"><a href="#手机H5" class="headerlink" title="手机H5"></a>手机H5</h3><p>随着智能手机发展得越来越快，微信等一些应用里都不得不内嵌一些前端的 H5 页面，比如微信公众号文章，其实就是一个小型网页。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/aa06ea432b78c0eb0cab0571d136d484.jpeg" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>另一个应用场景是，工程师们发现 App 里也可以嵌入 H5 来做简单的展示和交互，这样一来移动端就可以少开发一些内容了。这种内嵌H5页面的应用开发也称为<strong>混合开发</strong>，开发出来的 App 就是 <strong>Hybird App</strong>.</p>
<p>现在我们手机上的支付宝、微信、QQ 等都是采用了混合开发的模式，既能使用原生的代码保证流畅度，同时又可以内嵌H5提升开发速度（注意，速度不等于效率）。</p>
<h3 id="低代码"><a href="#低代码" class="headerlink" title="低代码"></a>低代码</h3><p>手机上的 H5 写多了之后，前端工程师们又发现很多 H5 都千篇一律，很多都是模板一套，再改个颜色就OK了。</p>
<p>因此，聪明的程序员就想到了能不能用拖拽就生成网页呢？其实拖拽生成网页并不是什么新鲜事，也不难实现，早在 wordpress 的时代已经出现拖拽生成个人博客的工具了。只不过现在用到手机上了。</p>
<p>但是拖拽的问题在于不灵活，有时候非常死板。有些运营人员还是懂一点代码的。所以拖拽工具再度进化成了：可以给别人留个入口做一些简单的自定义事情。这种模板+简单代码做开发的就称为<strong>“低代码”开发</strong>，通过简单的配置就能自动生成页面。</p>
<h3 id="需求生成代码"><a href="#需求生成代码" class="headerlink" title="需求生成代码"></a>需求生成代码</h3><p>除了拖拽，有没有更高级的生成代码工具呢？有！比如，用文字描述场景来生成前端代码，这也是阿里正在做的事情，它们正在研究 P2C （PRD to Code）。个人觉得这是一件好事，对于简单需求来说可以直接生成比什么都快。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://ask.qcloudimg.com/http-save/yehe-1045939/77b489809adbe660d8095a1abf5b38e7.png" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>有人会担心：这会不会取代前端工程师呢？答案是不可能，也不科学。再厉害的人工智能最终也无法实现设计复杂、灵活多变、千奇百怪、疯狂迭代的产品需求。最终取代的是只会写简单 html、css 的低级工程师。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>不知不觉就写好了多东西，可见前端东西真的很多很杂。其实再下写去还能再细写下去，但是文章实在太长了，到此结束了。</p>
<p>这篇文章除了带大家了解前端常见的“名词”之外，还希望大家学前端时不要上来就我要精通XXX。你看前端的发展多么坎坷、都是通过解决一个一个问题才有今天的前端，学习也是同样的道理，先实现一个最 Low 的版本，再慢慢升级自己。</p>
<h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><p><code>[1]</code> CERN(European Organization for Nuclear Research): <em><a href="https://en.wikipedia.org/wiki/CERN" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/CERN</a></em> </p>
<p><code>[2]</code> 第二个提案: <em><a href="http://cds.cern.ch/record/369245/files/dd-89-001.pdf" target="_blank" rel="noopener">http://cds.cern.ch/record/369245/files/dd-89-001.pdf</a></em> </p>
<p><code>[3]</code> Håkon Wium Lie: <em><a href="https://en.wikipedia.org/wiki/H%C3%A5kon_Wium_Lie" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/H%C3%A5kon_Wium_Lie</a></em> </p>
<p><code>[4]</code> CSS4 (disambiguation): <em><a href="https://en.wikipedia.org/wiki/Document_Style_Semantics_and_Specification_Language" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Document_Style_Semantics_and_Specification_Language</a></em> </p>
<p><code>[5]</code> Formatting Output Specification Instance: <em><a href="https://en.wikipedia.org/wiki/Formatting_Output_Specification_Instance" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Formatting_Output_Specification_Instance</a></em> </p>
<p><code>[6]</code> JavaScript: <em><a href="https://en.wikipedia.org/wiki/JavaScript" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/JavaScript</a></em> </p>
<p><code>[7]</code> XML: <em><a href="https://en.wikipedia.org/wiki/XML" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/XML</a></em> </p>
<p><code>[8]</code> ECMA-262: <em><a href="https://www.ecma-international.org/publications/standards/Ecma-262.htm" target="_blank" rel="noopener">https://www.ecma-international.org/publications/standards/Ecma-262.htm</a></em></p>
<p>原文链接：<a href="https://mp.weixin.qq.com/s/1UZtXP83OTGEFHUTqDQVEw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/1UZtXP83OTGEFHUTqDQVEw</a></p>
<h3 id="1、什么是mvc、mvp、mvvm？什么是前后端分离，前后端分离的优缺点？"><a href="#1、什么是mvc、mvp、mvvm？什么是前后端分离，前后端分离的优缺点？" class="headerlink" title="1、什么是mvc、mvp、mvvm？什么是前后端分离，前后端分离的优缺点？"></a>1、什么是mvc、mvp、mvvm？什么是前后端分离，前后端分离的优缺点？</h3><p>mvc是model-view-control</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://img1.sycdn.imooc.com//5b71441c00015da504160175.jpg" alt="https://img1.sycdn.imooc.com//5b71441c00015da504160175.jpg" title>
                </div>
                <div class="image-caption">https://img1.sycdn.imooc.com//5b71441c00015da504160175.jpg</div>
            </figure>



<h3 id="2、什么是单页面应用？为什么使用单页面应用？单页面应用路由实现的方法和原理？"><a href="#2、什么是单页面应用？为什么使用单页面应用？单页面应用路由实现的方法和原理？" class="headerlink" title="2、什么是单页面应用？为什么使用单页面应用？单页面应用路由实现的方法和原理？"></a>2、什么是单页面应用？为什么使用单页面应用？单页面应用路由实现的方法和原理？</h3><p>单页面应用可以叫做单页面多片段切换应用。通过控制页面的删除或者隐藏来实现单页面应用。单页面在移动端使用比较广泛。可以带来极致的体验。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://img1.sycdn.imooc.com//5b725f76000141a505000489.jpg" alt="https://img1.sycdn.imooc.com//5b725f76000141a506980682.jpg" title>
                </div>
                <div class="image-caption">https://img1.sycdn.imooc.com//5b725f76000141a506980682.jpg</div>
            </figure>



<h3 id="3、什么是单线程？单线程与多线程的区别？什么是进程？进程和线程的区别和联系？"><a href="#3、什么是单线程？单线程与多线程的区别？什么是进程？进程和线程的区别和联系？" class="headerlink" title="3、什么是单线程？单线程与多线程的区别？什么是进程？进程和线程的区别和联系？"></a>3、什么是单线程？单线程与多线程的区别？什么是进程？进程和线程的区别和联系？</h3><p>单线程：就是同一时间只能做一件事情。JavaScript是单线程的。</p>
<p>多线程：就是同一时间可以同时做好几件事情。</p>
<p>进程中包含多个线程，单线程，多线程都是相对于同一个进程来说的。</p>
<p>一个浏览器tab页面就是一个进程。进程中包含js引擎线程，GUI线程、事件触发线程等。</p>
<p>进程是CPU资源分配的最小单位。</p>
<p>线程是CPU的最小调度单位。</p>
<h3 id="4、异步调用的常用方法？什么是异步调用？"><a href="#4、异步调用的常用方法？什么是异步调用？" class="headerlink" title="4、异步调用的常用方法？什么是异步调用？"></a>4、异步调用的常用方法？什么是异步调用？</h3><p>回调函数、promise、async/await、generate。</p>
<p>异步调用主要是通过状态来管理的，到了这个时间点，或者任务完成后，就开始着手工作。例如：</p>
<p>setTimeout(function(){},100),这个也可以看成是异步调用，100ms后开始执行函数内的代码。</p>
<h3 id="5、对webpack的理解？为什么需要webpck？对构建、打包、编译的理解？"><a href="#5、对webpack的理解？为什么需要webpck？对构建、打包、编译的理解？" class="headerlink" title="5、对webpack的理解？为什么需要webpck？对构建、打包、编译的理解？"></a>5、对webpack的理解？为什么需要webpck？对构建、打包、编译的理解？</h3><p>webpack它是代码编译工具，有入口，出口、loader和插件。其天生就代码分割、模块化，webpack2.0中加入tree shaking，用来提取公共代码，去掉死亡代码。</p>
<p>构建、打包、编译他们都是为了提高开发效率，让前端朝着标准化的路上继续迈进</p>
<h3 id="6、git常用命令？git和svn的区别？github是什么，npm又是什么？"><a href="#6、git常用命令？git和svn的区别？github是什么，npm又是什么？" class="headerlink" title="6、git常用命令？git和svn的区别？github是什么，npm又是什么？"></a>6、git常用命令？git和svn的区别？github是什么，npm又是什么？</h3><p>git的全部工作都是在这三个区之间工作。三个区是工作区，暂存区、远程仓库区。</p>
<p>建立一个git仓库：git init</p>
<p>clone 远程仓库：git clone +git仓库地址</p>
<p>本地仓库和远程仓库建立连接：git remote add origin +git地址</p>
<p>拉去远程仓库 git pull origin master(master分支)</p>
<p>提交到暂存区：git add +文件</p>
<p>提交到master，此时Header指针指到这里：git commit -m ‘文件描述’</p>
<p>推送到远程仓库：git push origin master</p>
<p>新建分支：git branch dev</p>
<p>删除本地分支：git branch -d dev (<em>删除分支时，必须切换到另一个分支，才能删除想要删除的分支</em>)</p>
<p>删除远程分支：git push origin -d dev</p>
<p>版本回退：git reset –hard HEAD^。</p>
<p>github是全球最大的代码托管平台。npm是全球最大的包管理工具。</p>
<p>github使用git clone +代码 ，可以下载代码。</p>
<p>npm通过npm install 安装，可以直接使用。</p>
<h3 id="7、什么是构造函数？什么是原型链？原型链的用途？什么是对象？对象的用途？"><a href="#7、什么是构造函数？什么是原型链？原型链的用途？什么是对象？对象的用途？" class="headerlink" title="7、什么是构造函数？什么是原型链？原型链的用途？什么是对象？对象的用途？"></a>7、什么是构造函数？什么是原型链？原型链的用途？什么是对象？对象的用途？</h3><p>构造函数也是函数，无非让其具有扩展性功能，它使用扩展性功能又用了原型链的原理，原型链又用了计算机中核心局部性原理，你自身没有往上级找，上级没有继续往外找，这其中其实闭包也用了这种原理。</p>
<p>对象：万物皆是对象，就是先总体看待事情，然后再局部。对象中又有key和value。也可能包含方法。</p>
<h3 id="8、对http的认识？从输入url到页面展现都发生了什么？"><a href="#8、对http的认识？从输入url到页面展现都发生了什么？" class="headerlink" title="8、对http的认识？从输入url到页面展现都发生了什么？"></a>8、对http的认识？从输入url到页面展现都发生了什么？</h3><p>这个参考链接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`https://segmentfault.com/a/1190000013662126`</span><br></pre></td></tr></table></figure>

<h3 id="9、什么是BFC？如何实现BFC？盒子模型认识？如何实现标准盒模型？"><a href="#9、什么是BFC？如何实现BFC？盒子模型认识？如何实现标准盒模型？" class="headerlink" title="9、什么是BFC？如何实现BFC？盒子模型认识？如何实现标准盒模型？"></a>9、什么是BFC？如何实现BFC？盒子模型认识？如何实现标准盒模型？</h3><p>这个是css中的块级格式化上下文。</p>
<p>盒子模型有标准盒模型和IE盒模型，</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://img1.sycdn.imooc.com//5b725e3500018c4205000067.jpg" alt="https://img1.sycdn.imooc.com//5b725e3500018c4207550100.jpg" title>
                </div>
                <div class="image-caption">https://img1.sycdn.imooc.com//5b725e3500018c4207550100.jpg</div>
            </figure>

<ul>
<li>当设置为box-sizing:content-box时，将采用标准模式解析计算，也是默认模式；</li>
<li>当设置为box-sizing:border-box时，将采用怪异模式解析计算；</li>
</ul>
<h3 id="10、什么是栈，什么是堆？栈用来存储什么，堆用来存储什么？"><a href="#10、什么是栈，什么是堆？栈用来存储什么，堆用来存储什么？" class="headerlink" title="10、什么是栈，什么是堆？栈用来存储什么，堆用来存储什么？"></a>10、什么是栈，什么是堆？栈用来存储什么，堆用来存储什么？</h3><p>栈用来存储基本变量类型（number\string\Boolean\undifeind\null）和指针地址。</p>
<p>堆用来存储对象（key和val）或者函数大括号里面的代码。</p>
<p>栈和堆有下面的连接关系</p>
<p>​           <img src="/img/loading.gif" data-original="https://img1.sycdn.imooc.com//5b7129ec0001bbfc03830419.jpg" alt="https://img1.sycdn.imooc.com//5b7129ec0001bbfc03830419.jpg"></p>
<h3 id="11、什么是组件？什么是插件？组件和插件的区别和联系？"><a href="#11、什么是组件？什么是插件？组件和插件的区别和联系？" class="headerlink" title="11、什么是组件？什么是插件？组件和插件的区别和联系？"></a>11、什么是组件？什么是插件？组件和插件的区别和联系？</h3><p>组件是模版和UI逻辑的结合。而插件可以是一堆组件的结合，它是框架在功能上的扩展，如vue.prototype.add=function(){}</p>
<p>他们都是在封装、继承、多态思想上产生而来。</p>
<p>区别：</p>
<ol>
<li>vue插件可以将自己的模块添加到Vue原型对象上，然后组件中可以通过this直接引用。还要就是通过插件机制，可以通过一个入口，就可以将一系列组件添加到环境中，直接使用</li>
<li>插件是采用通用接口编写的，多用于制作好的东西功能扩展。</li>
<li>vue组件只是一个独立的模块，可重复使用并且可以和其他对象进行交互的对象</li>
<li>插件通常会为 Vue 添加全局功能。插件的范围没有限制——一般有下面几种：<br>添加全局方法或者属性，如: vue-custom-element<br>添加全局资源：指令/过滤器/过渡等，如 vue-touch<br>通过全局 mixin 方法添加一些组件选项，如: vue-router<br>添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。<br>一个库，提供自己的 API，同时提供上面提到的一个或多个功能，如 vue-router<br>Vue.js 的插件应当有一个公开方法 install 。</li>
<li>如果你的模块或者组件想对外公开，最友好的方式就是通过插件机制提供</li>
</ol>
<h3 id="12、对nodejs的认识？什么是事件驱动？什么是非阻塞I-O？"><a href="#12、对nodejs的认识？什么是事件驱动？什么是非阻塞I-O？" class="headerlink" title="12、对nodejs的认识？什么是事件驱动？什么是非阻塞I/O？"></a>12、对nodejs的认识？什么是事件驱动？什么是非阻塞I/O？</h3><p>nodejs是基于chrome V8引擎，以事件驱动，非阻塞I/O模型。他是一个可以在服务端运行js的环境。</p>
<p>事件驱动：就是触发一个事件，然后回调，再执行的过程。</p>
<p>非阻塞I/O：以异步来执行函数，先执行同步任务，耗时任务放在事件队列中，以此轮询执行</p>
<h3 id="13、什么是hybrid？为什么使用hybrid？hybrid为什么可以不用审核直接发布？hybrid如何使用？"><a href="#13、什么是hybrid？为什么使用hybrid？hybrid为什么可以不用审核直接发布？hybrid如何使用？" class="headerlink" title="13、什么是hybrid？为什么使用hybrid？hybrid为什么可以不用审核直接发布？hybrid如何使用？"></a>13、什么是hybrid？为什么使用hybrid？hybrid为什么可以不用审核直接发布？hybrid如何使用？</h3><p>hybrid：H5与原生端交互混合技术方案</p>
<p>web、native两个人交流，要么web主动，要么native主动，要么web、native都主动。</p>
<ul>
<li><p>web主动就是webView UI 方案。也是市面上大部分采用的方案。通过jsbridge完成h5与native的双向通信，从而把native的一些原生能力（拍照、从相册中选取照片、查看通讯录、获取地理位置等，这些调用系统级别的能力，h5没有，所以这也是其不受审核，可以快速上线的原因）赋予给h5.（重点是webview渲染）</p>
</li>
<li><p>native主动就是native UI 方案。例如reac-native\weex，在赋予h5原生api能力的基础上。进一步通过jsbridge将js解析成虚拟节点树virtual Dom传递到native并使用原生渲染。（重点是原生端渲染）</p>
</li>
<li><p>两者都主动。目前流行的小程序。通过更加定制化的jsbridge，并使用webview双线程的模式，隔离了js逻辑与UI渲染，形成了特殊的开发模式。加强了h5与Native混合，提高了交互体验和页面性能。</p>
<p><img src="/img/loading.gif" data-original="https://img1.sycdn.imooc.com//5b72410e000122ac03230303.jpg" alt="https://img1.sycdn.imooc.com//5b72410e000122ac03230303.jpg"></p>
</li>
</ul>
<p>hybrid本质是在原生的App中，使用webview作为容器承载web页面。这样就需要h5与native实现双向通信，这里我们就需要翻译员，保证我们两者的正常通信—跨语言通讯方案。native使用Java，object-c，h5使用jsbridge。两者通信翻译员就是jsBridge。是要有翻译员就要给他提供最优质的环境webview。一切的翻译也是通过webview的翻译机制。</p>
<p>基于webview的机制和开发的api，有三种方案</p>
<ol>
<li>API注入，原理其实就是native获取JavaScript环境上下文，直接在JavaScript上插入原生方法或者对象，使用js（图灵完备语言，有逻辑）直接调用。</li>
<li>webview中prompt、alert、console拦截。通常使用prompt，但这个方法使用频率较低</li>
</ol>
<ul>
<li><p>3.webview URL Scheme跳转拦截，通过webview信息冒泡传递的拦截，从而达到通讯。</p>
<p><strong>流程：定制协议—拦截协议—-参数传递—回调机制</strong></p>
<p><strong>（协议有http协议、https协议、file协议等）</strong></p>
<p>原理：在webview中发出的网络请求，客户端都能够监听和捕获到。</p>
<p><img src="/img/loading.gif" data-original="https://img1.sycdn.imooc.com//5b72509b00010a5504640260.jpg" alt="https://img1.sycdn.imooc.com//5b72509b00010a5504640260.jpg"></p>
</li>
</ul>
<h3 id="14、什么是浅拷贝？什么是深拷贝？如何实现深拷贝？"><a href="#14、什么是浅拷贝？什么是深拷贝？如何实现深拷贝？" class="headerlink" title="14、什么是浅拷贝？什么是深拷贝？如何实现深拷贝？"></a>14、什么是浅拷贝？什么是深拷贝？如何实现深拷贝？</h3><p>浅拷贝可以看做是一个快捷方式，实际共用一个内存地址。es6中的Object.assign({target},{obj})就是浅拷贝。</p>
<p>深拷贝相对于新开辟一块内存地址。使用JSON.stringify()可以实现深拷贝。</p>
<h3 id="15、什么是缓存？缓存的分类？cache、localStorage和sessionStorage和理解？"><a href="#15、什么是缓存？缓存的分类？cache、localStorage和sessionStorage和理解？" class="headerlink" title="15、什么是缓存？缓存的分类？cache、localStorage和sessionStorage和理解？"></a>15、什么是缓存？缓存的分类？cache、localStorage和sessionStorage和理解？</h3><p>缓存是为了更快的进行磁盘I/O而存在的。有浏览器缓存、CDN缓存、路由缓存、服务器缓存等。</p>
<p>cache中会有http响应头和响应行的信息，如cache-control：max-age:20000。</p>
<p>还有就是cookie。cookie一般浏览器不超过4k ,主要是用来保存用户登陆信息。当发送请求时，会自动把其带上。</p>
<p>而localStorage和sessionStorage是浏览器本地storage中用来存取值的，sessionStorage浏览器关闭了就不存在了，localStorage浏览器关闭依然存在。</p>
<h3 id="16、什么是闭包？闭包的用途？什么是递归？递归调用的用途？"><a href="#16、什么是闭包？闭包的用途？什么是递归？递归调用的用途？" class="headerlink" title="16、什么是闭包？闭包的用途？什么是递归？递归调用的用途？"></a>16、什么是闭包？闭包的用途？什么是递归？递归调用的用途？</h3><p>闭包就是有权访问另一个函数作用域内的变量函数都是闭包。</p>
<p>闭包就是一个函数引用另外一个函数的变量，因为变量被引用着所以不会被回收，因此可以用来封装一个私有变量。这是优点也是缺点，<strong>不必要的闭包只会徒增内存消耗！</strong>另外使用闭包也要注意变量的值是否符合你的要求，因为他就像一个静态私有变量一样</p>
<p>下面的就是闭包</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/loading.gif" data-original="https://img1.sycdn.imooc.com//5b72628900011edd03260248.jpg" alt="https://img1.sycdn.imooc.com//5b72628900011edd03260248.jpg" title>
                </div>
                <div class="image-caption">https://img1.sycdn.imooc.com//5b72628900011edd03260248.jpg</div>
            </figure>


<p>原文链接：<a href="https://www.imooc.com/article/details/id/67905" target="_blank" rel="noopener">https://www.imooc.com/article/details/id/67905</a></p>
<h3 id="toA、toB、toC、ToG是什么？有什么区别？"><a href="#toA、toB、toC、ToG是什么？有什么区别？" class="headerlink" title="toA、toB、toC、ToG是什么？有什么区别？"></a>toA、toB、toC、ToG是什么？有什么区别？</h3><p>TOA、TOB、TOC和ToG都是不同的业务模型或策略，它们分别针对不同的客户群体和市场。以下是这些术语的解释和它们之间的区别：</p>
<ol>
<li>TOA（Targeting of Audience）：即“瞄准目标受众”。这种策略强调对目标受众的深入了解和分析，以便为他们提供定制化的产品或服务。它类似于艺术家在创作画作前思考观众的口味和需求，销售人员努力满足广泛的需求，使产品或服务更容易被大众接受。</li>
<li>TOB（Targeting of Business）：即“面向企业”或“面向商业”。这种策略专注于为企业客户提供产品或服务，如设备制造商为企业提供设备。TOB市场策略侧重于吸引和满足其他企业的需求，通常需要更为专业的方法。销售人员需要深入了解客户的业务，提供针对性的解决方案。</li>
<li>TOC（Targeting of Consumers）：即“瞄准消费者”或“面向消费者”。这种策略主要针对个人用户的日常必需品，如衣食住行。这类需求普遍且客户群体庞大，因此需求指标多且分散。TOC模式关注的是如何满足消费者的日常需求，并提供具有吸引力的产品或服务。</li>
<li>ToG（Targeting of Government）：即“面向政府”或“面向公共部门”。这种策略主要为政府或公共部门提供产品或服务，如IT解决方案提供商为政府开发定制的软件系统。ToG模式关注的是如何满足政府或公共部门的需求，并提供符合其特定要求的产品或服务。</li>
</ol>
<p>这些策略之间的主要区别在于它们所针对的客户群体和市场不同。TOA、TOB和TOC分别针对一般消费者、企业客户和个人消费者，而ToG则针对政府或公共部门。此外，这些策略在业务模式和营销策略上也可能存在差异，以适应不同客户群体的需求和偏好。</p>
<h3 id="展业"><a href="#展业" class="headerlink" title="展业"></a>展业</h3><p>贷款、保险、理财等业务员为了寻找客户开展相应业务活动的总称 </p>
<h3 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h3><h4 id="解耦的定义"><a href="#解耦的定义" class="headerlink" title="解耦的定义"></a>解耦的定义</h4><p>解耦（Decoupling）是指通过降低代码之间的依赖性，减少模块或组件之间的耦合程度。在软件开发中，解耦是一种良好的设计原则，它可以提高代码的可维护性、可测试性和可扩展性。</p>
<p>当两个模块或组件之间高度耦合时，它们的改动往往会相互影响，一个模块的修改可能会导致其他模块的变动，这增加了系统的复杂性和风险。</p>
<h4 id="解耦的目标"><a href="#解耦的目标" class="headerlink" title="解耦的目标"></a>解耦的目标</h4><p>解耦的目标是将这种紧密耦合的关系松散化，使得模块之间的改动互不影响或最小化影响。</p>
<h4 id="实现解耦的方法"><a href="#实现解耦的方法" class="headerlink" title="实现解耦的方法"></a>实现解耦的方法</h4><ul>
<li><p>接口和抽象<br>使用接口和抽象类定义模块之间的通信协议，而不是直接依赖具体实现。这样，当一个模块的实现发生变化时，其他模块不受影响，只需要适配新的实现即可。</p>
</li>
<li><p>依赖注入（DI）<br>使用依赖注入来管理模块之间的依赖关系。通过将依赖关系的创建和绑定移到外部容器中，模块之间不再直接依赖具体实现，而是通过接口或抽象来进行通信，从而降低耦合度。</p>
</li>
<li><p>事件驱动编程<br>使用事件驱动的方式来解耦模块之间的通信。模块通过发布和订阅事件来进行通信，而不是直接调用对方的方法。这样，模块之间的依赖关系可以通过事件进行解耦，每个模块只需要对感兴趣的事件进行订阅，而不需要知道具体的实现。</p>
</li>
<li><p>模块化设计<br>将系统拆分成独立的模块，每个模块具有清晰的责任和功能。模块之间通过定义明确定义的接口进行通信，模块之间的依赖关系尽可能降低。</p>
</li>
</ul>
<h4 id="解耦的优点"><a href="#解耦的优点" class="headerlink" title="解耦的优点"></a>解耦的优点</h4><p>通过解耦，可以使系统更加灵活、可扩展和可维护。当一个模块需要修改或替换时，对其他模块的影响将最小化，使系统更具弹性和可扩展性。</p>
<p>同时，解耦也有助于提高代码的可测试性，因为模块可以更容易地进行单独的单元测试，而不需要依赖整个系统的其他部分。</p>
<h3 id="前端hook"><a href="#前端hook" class="headerlink" title="前端hook"></a>前端hook</h3><p>在前端开发中，特别是在使用Vue.js这样的框架时，”Hook” 通常指的是一种机制，允许开发者在组件的特定生命周期阶段或满足某些条件时执行自定义的代码。然而，在Vue 2中，并没有直接引入名为”Hook”的概念，而是使用了一系列的选项（如<code>data</code>、<code>methods</code>、<code>computed</code>、<code>watch</code>等）和生命周期钩子（如<code>created</code>、<code>mounted</code>、<code>updated</code>、<code>destroyed</code>等）来实现类似的功能。</p>
<p>不过，从Vue 3开始，Vue引入了Composition API，其中的<code>setup</code>函数可以被视为一种“Hook”机制。</p>
<p>在<code>setup</code>函数中，你可以使用Vue提供的响应式系统、生命周期钩子和其他功能来组织你的组件逻辑。</p>
<h3 id="转测是什么意思"><a href="#转测是什么意思" class="headerlink" title="转测是什么意思"></a>转测是什么意思</h3><p>转测在软件开发领域主要有两层含义：</p>
<ol>
<li><p><strong>在软件开发流程中</strong>，转测指的是开发人员完成软件功能的编写后，将工作成果移交给测试团队进行专业测试的环节。这时，开发人员通常会发送一封转测邮件给测试团队，邮件中会详细说明本次转测的内容（包括变更及影响范围）、提供转测所需的软件包或访问地址、指明负责的开发人员，并可能附带相关辅助材料，如SQL脚本、配置手册等。转测的目的是全面检查软件的功能、性能、兼容性等，确保其达到既定的质量标准。</p>
</li>
<li><p><strong>在数据库和系统迁移场景下</strong>，转测涉及验证现有系统中的数据能否成功转移到新的替代系统中。这包括测试数据转换的完整性和准确性，确保转换后的系统能够正常运作。转换测试（Conversion Testing）是确保数据处理软件或系统在经过转换后仍能正确工作的关键步骤，特别关注数据库和程序代码的转换效果。</p>
</li>
</ol>
<p>简而言之，转测是一个确保软件质量的重要阶段，无论是从开发到测试的流程传递，还是在系统迁移中的数据与功能验证，都是为了发现并修复潜在问题，提升软件的稳定性和用户满意度。</p>
<h4 id="提测和转测有啥区别"><a href="#提测和转测有啥区别" class="headerlink" title="提测和转测有啥区别"></a>提测和转测有啥区别</h4><p>提测和转测的区别是概念不同。</p>
<p>提测是指开发完成一个阶段的目标，将代码提交给测试人员，由测试人员对代码进行验证和测试。</p>
<p>而转测则是软件开发过程中一个特定的测试阶段，通常是在所有需求都开发完成并通过自测后进行的。转测的目的是对整个软件进行系统性的测试，以确保软件的整体质量和稳定性。 </p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2024-05-20T10:06:13.020Z" itemprop="dateUpdated">2024-05-20 18:06:13</time>
</span><br>


        
        感谢您的阅读，欢迎评论(*^▽^*) 转载请附上本文链接：<a href="/knowledges/zhu-yu-ming-ci.html" target="_blank" rel="external">https://qw8.github.io/knowledges/zhu-yu-ming-ci.html</a>
        
    </div>
    
    <footer>
        <a href="https://qw8.github.io">
            <img src="/img/avatar.jpg" alt="秦伟">
            秦伟
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/名词/">名词</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://qw8.github.io/knowledges/zhu-yu-ming-ci.html&title=《术语名词》 — 秦伟博客&pic=https://qw8.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://qw8.github.io/knowledges/zhu-yu-ming-ci.html&title=《术语名词》 — 秦伟博客&source=前端、全栈、SEO的知识点、面试题与学习链接的整理" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://qw8.github.io/knowledges/zhu-yu-ming-ci.html" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《术语名词》 — 秦伟博客&url=https://qw8.github.io/knowledges/zhu-yu-ming-ci.html&via=https://qw8.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://qw8.github.io/knowledges/zhu-yu-ming-ci.html" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/knowledges/qian-duan-dai-ma-pian-duan.html" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">前端代码片段</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/link/vue-xiang-mu.html" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">vue项目</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'false' == 'true',
            appId: "TJ17Ax10JrfIIljlO8qkwGvz-gzGzoHsz",
            appKey: "jDGQKdWT9hlzsTLRAbInE4bK",
            avatar: "mm",
            placeholder: "说点什么吧(*╹▽╹*)",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->










</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢您，我会继续努力哒(*^▽^*)
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.png" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

    <footer class="footer">
    <div class="top">
        <div class="map">
            <!--地球信息-->
<script type="text/javascript" src="/js/jquery-3.4.1.js"></script>
<script type="text/javascript">
    var windowWidth = $(window).width();
    if (windowWidth > 480) {
        document.write('<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5mz4gy0w2d8&amp;m=0&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33" async="async">  <\/script>');
    }
</script>
        </div>
        <p>
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>

</p>
        <p>
            <span>本网站总字数：832.4k</span>
            <span id="sitetime"></span>
        </p>
        <p>部分内容来源于互联网，用于个人知识的总结，如有侵权还请联系删除</p>
        <p>
            
            <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i
                    class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>

    <div class="bottom">
        <p>
            <span>Copyright &copy; 2019 - 2024 <a
                href="https://qw8.github.io/" target="_blank">秦伟的个人博客</a> All Rights Reserved.</span>
            <!-- <span>
                
                
            </span> -->
        </p>
    </div>
</footer>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2019, 8, 25, 18, 0, 0); // 北京时间
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "已安全运行 " + diffYears + "年 " + diffDays + "天 " + diffHours + "小时 " + diffMinutes + "分钟 " + diffSeconds + "秒";
    }
    siteTime();
</script>
</main>
<div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://qw8.github.io/knowledges/zhu-yu-ming-ci.html&title=《术语名词》 — 秦伟博客&pic=https://qw8.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://qw8.github.io/knowledges/zhu-yu-ming-ci.html&title=《术语名词》 — 秦伟博客&source=前端、全栈、SEO的知识点、面试题与学习链接的整理" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://qw8.github.io/knowledges/zhu-yu-ming-ci.html" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《术语名词》 — 秦伟博客&url=https://qw8.github.io/knowledges/zhu-yu-ming-ci.html&via=https://qw8.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://qw8.github.io/knowledges/zhu-yu-ming-ci.html" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACGUlEQVR42u3aQW4DMQgF0Nz/0tNtqzTpB5xKYz+vqjSZ4XmBDPjxiNf1Yn3/7/M386flvx0tDAyM2zKut6vKeH5yEmL1vb88BwMD4wBGEkT+4nlaz2PDwMDAeM+oJtMkXAwMDIw5IznA5Wk62SAMDAyMvIjNXzMvUz9Yi2NgYNyQkQfx/39/ZL6BgYFxK8ZVXNUkWE2UV2thYGDszcgTXO9YVi2De/FgYGDszUhes6pM7Y0woydgYGAcwMhbbPl35puVjxkwMDD2ZuRXIvLBZDUf9i5wFHI2BgbGRoz5MS75pMcuR4iBgbERo9rKzwPNN6h64QwDA+NMRjWUHJ9n/d6x8mUtjoGBsRGjd9EhaX5V22qrRggYGBi7MuaBTiaJ+VGyeUDEwMDYiDFp0Oet/7zplkeIgYGxN6N3LMtb+flAtIr58SsMDIwjGb3BwOR6RHPi2queMTAwbsWYDAB6m5LPHPMhBAYGxgmMpHFfLWWTpDlJ6OUrFxgYGBsxqmXq5NpEdXQaNd0wMDAOY0wa93kKnhxDMTAwTmPkTa55K39VYw4DA+MERu9YlrB7STYfiP7xAwwMjI0Yk+sU1UNedSSQbwcGBsYJjEmSrV4IWzXgxMDAOJPRO94ln+TbsawWx8DAOJ4xL2t7byn4MDAwMFqXtyYjgahgxsDAOIDRC6JaxM5bdRgYGGcy5ikvv/6VB1HdLAwMjE0ZX5sjA/HvseciAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '(つェ⊂)咦!跑去哪里了';
            clearTimeout(titleTime);
        } else {
            document.title = '欢迎回来━(*｀∀´*)ノ';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>




<!-- 点击特效 -->
<script type="text/javascript" src="/js/clicklove.js"></script>
<!--动态线条背景-->
<script type="text/javascript"
        color="220,220,220" opacity='0.7' zIndex="-2" count="200"
        src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>
<!-- 雪花特效 -->
<script type="text/javascript" src="/js/jquery-3.4.1.js"></script>
<script type="text/javascript">
    var windowWidth = $(window).width();
    if (windowWidth > 480) {
        document.write('<script type="text/javascript" src="/js/snow.js"><\/script>');
    }
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"position":"right","width":150,"height":300,"hOffset":-25,"vOffset":30},"mobile":{"show":false,"scale":1.2},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script><script>!function(e){var r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function t(){for(var c=0;c<r.length;c++)t=r[c],void 0,0<=(n=t.getBoundingClientRect()).top&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=r[c];t=o,n=function(){r=r.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}t(),e.addEventListener("scroll",function(){!function(t,n){clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)}(t,e)})}(this);</script></body>
</html>

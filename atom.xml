<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秦伟的个人博客</title>
  
  <subtitle>前端及全栈知识点、面试题与学习链接的整理</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.bluedream.top/"/>
  <updated>2019-09-26T07:59:07.905Z</updated>
  <id>http://www.bluedream.top/</id>
  
  <author>
    <name>秦伟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>字节跳动面经总结</title>
    <link href="http://www.bluedream.top/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93.html"/>
    <id>http://www.bluedream.top/前端面试题/字节跳动面经总结.html</id>
    <published>2019-09-19T15:30:33.000Z</published>
    <updated>2019-09-26T07:59:07.905Z</updated>
    
    <content type="html"><![CDATA[<h2 id="记录一下自己的第二次面试经历"><a href="#记录一下自己的第二次面试经历" class="headerlink" title="记录一下自己的第二次面试经历"></a>记录一下自己的第二次面试经历</h2><p><img src="/img/loading.gif" data-original="../images/ms001.jpg" alt="字节跳动"></p><p><strong>面试公司：</strong>字节跳动</p><p><strong>公司介绍：</strong></p><p>​         字节跳动是全球第一家将人工智能应用到主产品的科技公司。全系产品矩阵包括今日头条、抖音、西瓜视频、火山小视频、TopBuzz、Faceu激萌、图虫、懂车帝等多款产品。截止2019年1月，字节跳动旗下全线产品日活超过6亿，月活超过10亿。字节跳动也在积极进行国际化部署，产品覆盖150多个国家和地区，75个语种，在40多个国家和地区排在应用商店总榜前列。</p><p>加入我们，一起和优秀的人做有挑战的事。</p><p>点击<a href="http://www.bytedance.com" target="_blank" rel="noopener">官网链接</a>，了解更多公司信息</p><p><strong>面试岗位：</strong>前端研发工程师职位（校招全职）</p><p><strong>面试形式：</strong>视频面试</p><p><strong>面试时间：</strong>2019-09-19 17:00:00 GMT+08:00（周四下午五点）</p><p><strong>面试来源：</strong>字节跳动商业平台团队内部前端岗直推，“流云破风”在2019.9.13发布于前端迷公众号</p><p><strong>发送邮箱：</strong><a href="mailto:yuanlin@bytedance.com" target="_blank" rel="noopener">yuanlin@bytedance.com</a>  ，标注邮件标题：内推，其他岗位，实习校招社招均可</p><p><strong>团队特色：</strong>全栈、NodeJS&amp;框架、React/Vue、前端基础建设、组件库、数据可视化、多个新方向、自主发挥空间</p><p><strong>岗位描述：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">负责前端技术选型和开发工作；</span><br><span class="line">优化前端功能设计，解决各种浏览器和终端设备的兼容性问题；</span><br><span class="line">通过技术手段，提升用户体验并满足高性能要求；</span><br><span class="line">通用组件、类库编写，提升开发效率和质量。</span><br></pre></td></tr></table></figure><p><strong>岗位要求：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">本科及以上学历，计算机相关专业； </span><br><span class="line">精通HTML、CSS、JS，熟悉页面架构和布局，熟悉HTML5/CSS3等常用技术；</span><br><span class="line">熟悉常用UI框架（如bootstrap/pure/kendo等);</span><br><span class="line">精通JavaScript、AJAX、DOM、jQuery等技术；</span><br><span class="line">熟悉NodeJS，熟练使用Grunt、Gulp、Webpack等构建工具；</span><br><span class="line">具备MVVM框架开发经验，如React、VueJS、AngularJS等；</span><br><span class="line">良好的沟通和团队协作能力、热爱技术、责任心强、能推动技术框架的落地使用。</span><br></pre></td></tr></table></figure><p><strong>考察内容:</strong></p><ul><li>我们主要考察通用型的业务问题和过往的项目经历</li><li>价值观和软性技能也是我们选择人才的重要因素</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- 自我介绍</span><br><span class="line">  什么方式学习</span><br><span class="line"></span><br><span class="line">- div居中几种方法</span><br><span class="line">  盒模型</span><br><span class="line">  position属性详细问，相对定位绝对定位fixed</span><br><span class="line">  box-sizing作用</span><br><span class="line">  http状态码304</span><br><span class="line">  http请求方法get post put delete head</span><br><span class="line">  cookie应用在什么方面</span><br><span class="line">  cookie有哪些属性、大小</span><br><span class="line">  localStorage，sessionStorage的区别</span><br><span class="line">  网页访问速度慢，怎么优化</span><br><span class="line"></span><br><span class="line">- es6（了解吗）</span><br><span class="line">  this指向（有class的话指向哪里）</span><br><span class="line">  作用域</span><br><span class="line">  事件循环</span><br><span class="line">  异步原理，比如setTimeout</span><br><span class="line">  箭头函数与普通函数区别</span><br><span class="line">  原型链</span><br><span class="line">  闭包</span><br><span class="line">  变量提升</span><br><span class="line"></span><br><span class="line">- vue与jQuery区别</span><br><span class="line">  vue实现原理</span><br><span class="line">  vue绑定</span><br><span class="line"></span><br><span class="line">- 编程题：</span><br><span class="line">  var versions=[&apos;1.45.0&apos;,&apos;1.5&apos;,&apos;6&apos;,&apos;3.3.3.3.3.3.3&apos;]</span><br><span class="line">  var sorted=[&apos;1.5&apos;,&apos;1.45.0&apos;,&apos;3.3.3.3.3.3&apos;,&apos;6&apos;]</span><br></pre></td></tr></table></figure><p>面试就是一个不断见面，试验，总结，归纳与提高的过程。</p><p>面试不同于考试，考试机会难得，形式及考察能力单一，而面试机会很多，形式不同，考察能力全面。</p><p><strong>只要一直面，总会有进步，总会有提高的。</strong></p><p>​                                                                                                                                                     <strong>写于：</strong> <u>2019.9.19</u></p><hr><h2 id="面试之前找的各种面经"><a href="#面试之前找的各种面经" class="headerlink" title="面试之前找的各种面经"></a>面试之前找的各种面经</h2><p>投递简历后过了一段时间接到约面小姐姐的电话，了解你的具体的实习时间段，和你约定面试时间。你确认后小姐姐挂电话。过段时间hr给你发视频面试的链接，是牛客网用来面试的链接。</p><p>正文<br>面试前做出的准备<br>我在面试前准备以下几点东西，似乎都解决了面试的部分问题</p><p>面试前我查阅了其他朋友写的字节跳动的面经以及面试题目，寻找题目解答，把它们总结了下来，用了一天一夜的时间，并把它们放到了我的这个博客上面。<br>我做了一份详细的自我介绍，通过三段开发经历来总结出了我的一些优点和开发经验，用讲故事的形式说明情况，最后点明故事中表现了自己具有哪些素质，点明自己为什么可以做前端的工作。字节跳动的宗旨“和优秀的人一起做有挑战的事情”也被我用到了自我介绍中，“我认为我是优秀的人，也喜欢做有挑战的事情，更喜欢与优秀的人为伍”“我希望搭上字节跳动这架火箭”等等。<br>快要面试时做出的准备<br>快要面试了，第一次面试，有些紧张，但还是像平常考试一样，将总结下来的面试题目总结、前端遇到问题的总结又看了一遍，把自己做好的自我介绍熟悉的几遍，给自己亲近的朋友发条消息获得她的祝福，又站在电脑桌前活动了一下身子，头脑顿时清醒利索了许多。</p><p>面试前奏<br>由于紧张怕错过面试，早早的便坐在了电脑桌前。面试官迟到了一会，就给我发起了面试视频邀请，终于开始了。<br>迎面是一个挺帅气的哥哥，简单的打了一下招呼，就进入了自我介绍的环节。由于自我介绍我已经熟悉过几遍了，自我介绍的效果看起来效果还是不错的。<br>开始问我项目经历的细节以及自我介绍中的细节，由于项目经历确实是自己亲身经历过的事情，并且我一般项目完成时都会做一下总结，所以也能够答个头头是道。个人感觉上的，至于面试官怎么想的，我就不清楚了， 说不定是那种我就静静的看着你装逼的情况。</p><p>面试高潮<br>来了来了，开始问技术的问题了。</p><h3 id="你对Vue的理解有多少"><a href="#你对Vue的理解有多少" class="headerlink" title="你对Vue的理解有多少"></a>你对Vue的理解有多少</h3><p>因为我在简历的项目经历中写了一个Vue项目，于是他问的时候就把我在项目中对Vue的理解和面试前准备的Vue总结结合起来回答。</p><h3 id="用css2和css3分别写一下垂直居中和水平居中"><a href="#用css2和css3分别写一下垂直居中和水平居中" class="headerlink" title="用css2和css3分别写一下垂直居中和水平居中"></a>用css2和css3分别写一下垂直居中和水平居中</h3><p>这道题我不会，并不知道css2和css3有什么区别以及写法，只会css3，我脑袋里有面试前总结的垂直居中和水平居中其中的两种方式，我就给他讲了一讲，倒是他没有再问下去，可能看出来我不会了吧。这也体现出了面试前知识点总结复习的重要性，不然你不会的东西你连说都不会说。</p><p>css3新增了一些属性，像flex，这是css3中很重要的改变，所以除了flex以外的垂直水平居中的技巧都是属于css2的。</p><ul><li>css2的水平居中技巧<br>将元素display为行内元素，再text-align:center;即可<br>或者<br>将块级元素定义一个宽度，再margin: 0 auto;即可</li><li>css3的水平居中技巧<br>将元素display设为flex，再通过justify-content: center; 实现居中。</li><li>css2的垂直居中技巧<br>单行内容的垂直居中可以通过设置相同height值和line-height值来实现。<br>多行内容的垂直居中且高度可变可以通过设置上下相同的padding值来实现。<br>行级盒子：小图标和标题对齐设置vertical-align: middle。<br>绝对定位：top:50%; left:50%;的方法，需要已知块级的宽高</li><li>css3的垂直居中技巧<br>将元素display设为flex，再通过align-items:center;来实现。</li></ul><h3 id="你对计算机网络的认识怎么样"><a href="#你对计算机网络的认识怎么样" class="headerlink" title="你对计算机网络的认识怎么样"></a>你对计算机网络的认识怎么样</h3><p>又是一道探底的题，判断能否从这里给你出题考察你</p><h3 id="讲述一下计算机网络的七层"><a href="#讲述一下计算机网络的七层" class="headerlink" title="讲述一下计算机网络的七层"></a>讲述一下计算机网络的七层</h3><p>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p><h3 id="TCP和UDP的区别是什么"><a href="#TCP和UDP的区别是什么" class="headerlink" title="TCP和UDP的区别是什么"></a>TCP和UDP的区别是什么</h3><p>TCP：面向连接、传输可靠(保证数据正确性,保证数据顺序)、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)<br>UDP：面向非连接、传输不可靠、用于传输少量数据(数据包模式)、速度快<br>TCP和UDP协议的一些应用例子：<br>TCP一般用于文件传输（FTP HTTP 对数据准确性要求高，速度可以相对慢），发送或接收邮件（POP IMAP SMTP 对数据准确性要求高，非紧急应用），远程登录（TELNET SSH 对数据准确性有一定要求，有连接的概念）等等；UDP一般用于即时通信（QQ聊天 对数据准确性和丢包要求比较低，但速度必须快），在线视频（RTSP 速度一定要快，保证视频连续，但是偶尔花了一个图像帧，人们还是能接受的），网络语音电话（VoIP 语音数据包一般比较小，需要高速发送，偶尔断音或串音也没有问题）等等。</p><h3 id="TCP和UDP属于计算机网络中的哪一层"><a href="#TCP和UDP属于计算机网络中的哪一层" class="headerlink" title="TCP和UDP属于计算机网络中的哪一层"></a>TCP和UDP属于计算机网络中的哪一层</h3><p>网际层协议：IP协议、ICMP协议、ARP协议、RARP协议<br>传输层协议：TCP协议、UDP协议<br>应用层协议：FTP、Telnet、SMTP、HTTP、RIP、NFS、DNS</p><h3 id="HTTPS是什么"><a href="#HTTPS是什么" class="headerlink" title="HTTPS是什么"></a>HTTPS是什么</h3><p>HTTPS即加密的HTTP，HTTPS并不是一个新协议，而是HTTP+SSL（TLS）。原本HTTP先和TCP（假定传输层是TCP协议）直接通信，而加了SSL后，就变成HTTP先和SSL通信，再由SSL和TCP通信，相当于SSL被嵌在了HTTP和TCP之间</p><h3 id="介绍几种常见的状态码"><a href="#介绍几种常见的状态码" class="headerlink" title="介绍几种常见的状态码"></a>介绍几种常见的状态码</h3><p>2XX系列：代表请求已成功被服务器接收、理解、并接受。<br>200状态码：表示请求已成功，请求所希望的响应头或数据体将随此响应返回<br>201状态码：表示请求成功并且服务器创建了新的资源，且其 URI 已经随Location 头信息返回。<br>3XX系列：代表需要客户端采取进一步的操作才能完成请求，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。<br>301状态码：被请求的资源已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。<br>302状态码：请求的资源临时从不同的URI响应请求，但请求者应继续使用原有位置来进行以后的请求。<br>304状态码：自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。<br>4XX系列：表示请求错误。代表了客户端看起来可能发生了错误，妨碍了服务器的处理。<br>401状态码：请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。<br>403状态码：服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。<br>404状态码：请求失败，请求所希望得到的资源未被在服务器上发现。<br>5xx系列：代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。<br>500状态码：服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。<br>503状态码：由于临时的服务器维护或者过载，服务器当前无法处理请求。</p><h3 id="闭包是什么"><a href="#闭包是什么" class="headerlink" title="闭包是什么"></a>闭包是什么</h3><p>闭包就是能够读取其他函数内部变量的函数。<br>闭包的用途：可以读取函数内部的变量，并且让这些变量的值始终保持在内存中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 输出全为10</span><br><span class="line">for(var i=0;i&lt;10;i++)&#123;</span><br><span class="line">   setTimeout(function()&#123;</span><br><span class="line">       console.log(i);</span><br><span class="line">   &#125;,50);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出相应的输出</span><br><span class="line">for(var i=0;i&lt;10;i++)&#123;</span><br><span class="line">    (function(i)&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">        &#125;,50);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="js的隐性转换和显性转换"><a href="#js的隐性转换和显性转换" class="headerlink" title="js的隐性转换和显性转换"></a>js的隐性转换和显性转换</h3><p>隐性转换为： 1 + ‘1’ = ‘11’<br>显性转换<br>Number(“24 cccc”);//结果：NaN<br>ParseInt(“24 cccc”);//结果：24<br>备注：Number的显性转换比较严格，若无法强转则直接报错</p><h3 id="NaN是什么，用typeof会输出什么"><a href="#NaN是什么，用typeof会输出什么" class="headerlink" title="NaN是什么，用typeof会输出什么"></a>NaN是什么，用typeof会输出什么</h3><p>Not a Number<br>会输出 Number</p><h3 id="js的隐性转换和显性转换-1"><a href="#js的隐性转换和显性转换-1" class="headerlink" title="js的隐性转换和显性转换"></a>js的隐性转换和显性转换</h3><p>隐性转换为： 1 + ‘1’ = ‘11’<br>显性转换<br>Number(“24 cccc”);//结果：NaN<br>ParseInt(“24 cccc”);//结果：24<br>备注：Number的显性转换比较严格，若无法强转则直接报错面试官后引伸了两个问题<br>1 + -‘1’ + 1 等于什么<br>等于 0 ，’1’前面的负号把其数字化，变为-1，则后值为1<br>‘A’ - ‘B’ 等于什么<br>NaN</p><h3 id="跨域问题如何解决"><a href="#跨域问题如何解决" class="headerlink" title="跨域问题如何解决"></a>跨域问题如何解决</h3><p>同源策略：浏览器安全策略，同协议、ip、端口的脚本才会执行。<br>只要协议、域名、端口有任何一个不同，都被当作是不同的域<br>js跨域是指通过js在不同的域之间进行数据传输或通信</p><ol><li><p>通过jsonp跨域<br> jsonp在页面上引入不同域上的js脚本文件实现请求不同域上的数据<br> (1) 通过script标签引入一个js文件<br> (2) js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入<br> 注：需要服务器端的页面进行相应的配合</p></li><li><p>通过修改document.domain来跨子域</p></li><li><p>使用window.name来进行跨域<br>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。</p></li></ol><h3 id="知道babel么"><a href="#知道babel么" class="headerlink" title="知道babel么"></a>知道babel么</h3><p>可以实现将ES6编译为ES5代码</p><h3 id="用js实现判断一个变量是否为整数的函数"><a href="#用js实现判断一个变量是否为整数的函数" class="headerlink" title="用js实现判断一个变量是否为整数的函数"></a>用js实现判断一个变量是否为整数的函数</h3><p>实现思路：先判断该变量是否为Number类型，以此来缩小范围，再判断该变量除以1后是否与原值全等，若全等则返回true，若不全等则返回false</p><h3 id="进程和线程是什么"><a href="#进程和线程是什么" class="headerlink" title="进程和线程是什么"></a>进程和线程是什么</h3><p>线程是最小的执行单元，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。<br>进程指计算机中已运行的程序。<br>线程指操作系统能够进行运算调度的最小单位。</p><h3 id="死锁是什么"><a href="#死锁是什么" class="headerlink" title="死锁是什么"></a>死锁是什么</h3><p>当两个以上的运算单元，双方都在等待对方停止运行，以获取系统资源，但是没有一方提前退出时，就称为死锁。</p><h3 id="Left-Join、Right-Join、Inner-Join-指的是什么"><a href="#Left-Join、Right-Join、Inner-Join-指的是什么" class="headerlink" title="Left Join、Right Join、Inner Join 指的是什么"></a>Left Join、Right Join、Inner Join 指的是什么</h3><p>  LEFT JOIN 关键字会从左表那里返回所有的行，即使在右表中没有匹配的行<br>  RIGHT JOIN 关键字会右表那里返回所有的行，即使在左表中没有匹配的行<br>  在表中存在至少一个匹配时，INNER JOIN 关键字返回行</p><h3 id="快速排序用js怎么写"><a href="#快速排序用js怎么写" class="headerlink" title="快速排序用js怎么写"></a>快速排序用js怎么写</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function quickSort(arr) &#123;</span><br><span class="line">    if(arr.length&lt;=1) &#123;</span><br><span class="line">    return arr;</span><br><span class="line">    &#125;</span><br><span class="line">    var s = Math.floor(arr.length/2);</span><br><span class="line">  </span><br><span class="line"> var temp = arr.splice(s,1);</span><br><span class="line">  </span><br><span class="line"> var left=[];</span><br><span class="line"> var right=[];</span><br><span class="line"> for(var i=0;i&lt;arr.length;i++) &#123;</span><br><span class="line">   if(arr[i]&lt;temp) &#123;</span><br><span class="line">     left.push(arr[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   if(arr[i]&gt;=temp) &#123;</span><br><span class="line">     right.push(arr[i]);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line"> return quickSort(left).concat(temp,quickSort(right));</span><br></pre></td></tr></table></figure><p>  面试尾声<br>  面试官的突然一声“我这边没有什么问题了”，吓了我一跳，悬了悬了，我还想着跟他唠嗑两小时呢，唠嗑的感觉真好。<br>  “我这边没有什么问题了，请等待hr的通知吧”</p><hr><p>小技巧<br>做项目小技巧<br>每次项目完成后，都需要做一下项目的总结，这是做一两个项目并做总结的人比做很多的项目不做总结的人看起来更有经验的原因。古人说的好，“总结反思才能成长”。<br>做简历小技巧<br>套模板，注意写下什么时间毕业，尽可能的填充项目经验，项目经验写的详细些，重点是从项目中学到了什么。<br>面试写代码小技巧<br>写的代码记得加注释，考虑代码的时间复杂度问题，不会写代码一定要给面试官说一下你的思路，脑袋中想到什么说什么，部分解决方法也比说一声我不会强太多。<br>总结<br>实习的面试多进行基础知识的储备</p><p>我上个月的实习生面试是，两点半开始一面，结束后等个十分钟继续二面，视频面试。实习生的话只有两轮技术面+hr面。楼主加油，千万要准备好现场写一堆代码的准备��</p><p>牛客上可以在线写代码，面试官可以实时看到的，写完代码后面试官还会就你写的代码进行提问。</p><p>技术岗一般连续面3轮。除非第一面安排在下午~</p><p>我记得我那天从4点面到8点半，连续三轮（中间留了会吃饭时间）</p><p>面试官很有亲和力，面试过程更像是聊天多一点，但面试官提的问题也很有专业性，会对简历经历进行提问，并进行扩展，最后有对英语能力的考察。</p><p>面试官人很好,约定的六点面试,提前五分钟就到了面试间(还好我提前十分钟就在了..)</p><p>答题期间会根据我的答案给出建议和提示,全程虽然很紧张,但是知晓了自己的不足,考察点偏向基础和数据结构</p><p>问题如下:</p><ul><li><strong>http协议知道吗?</strong></li><li><strong>cookie session介绍一下</strong></li><li><strong>session表结构怎么设计,储存在哪里</strong></li><li><strong>你们的session cookie在项目里运用到哪里</strong></li><li><strong>算法题目:[删除链表中重复的节点]在一个排序的链表中,存在重复的节点,请删除该链表中重复的节点,重复的节点不保留,返回链表头指针.例如,链表1-2-3-3-4-4-5处理后为1-2-5</strong></li><li><strong>TCP/UDP的区别介绍一下</strong></li><li><strong>三次握手和四次挥手,time_wait是什么状态</strong></li><li><strong>B树 B+树区别说一下</strong></li><li><strong>数据库平时用到过什么 咱们先问MySQL MySQL索引原理知道吗</strong></li><li><strong>问了两种索引的区别(没记住…)</strong></li><li><strong>乐观锁悲观锁区别说一下</strong></li><li><strong>innodb和myisam的区别</strong></li><li><strong>数据库四种隔离状态 分别有什么问题</strong></li><li><strong>redis的数据结构</strong></li><li><strong>sortset底层,原理,怎么保证有序</strong></li></ul><p>总结:</p><p>就是自己太菜了..很多基础知识忘得很厉害,大公司感觉考察的都是基础,面试官在面试过程中有耐心,也会给与一些提示,素质很好</p><p>下来自己多背背知识,多刷一下leetcode吧..争取下次成功</p><hr><p>面试用的视频面，面试官挺和善，问的内容也挺基础的，大概回忆着记录一下。</p><h3 id="TCP和UDP的区别。"><a href="#TCP和UDP的区别。" class="headerlink" title="TCP和UDP的区别。"></a>TCP和UDP的区别。</h3><p>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</p><p>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</p><p>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的</p><p>UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</p><p>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</p><p>TCP首部开销20字节;UDP的首部开销小，只有8个字节</p><p>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</p><h3 id="说一下你对http协议的理解"><a href="#说一下你对http协议的理解" class="headerlink" title="说一下你对http协议的理解"></a>说一下你对http协议的理解</h3><p>这个我只讲了个三次握手和四次挥手的内容，面试官貌似不太满意</p><h3 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h3><p>这个回答的也不太全，其中我提到了数据存储在request body，面试官又问了我request body存储get和post的区别，emmmm…实在不会就下一题了</p><h3 id="css实现一个左侧固定20px，右侧响应式的布局"><a href="#css实现一个左侧固定20px，右侧响应式的布局" class="headerlink" title="css实现一个左侧固定20px，右侧响应式的布局"></a>css实现一个左侧固定20px，右侧响应式的布局</h3><p>这个就蒙蔽了，因为我用的bootstrap是自带的响应式布局，不太了解原生css。回答的面试官也不太满意。</p><h3 id="css实现水平垂直居中基础题"><a href="#css实现水平垂直居中基础题" class="headerlink" title="css实现水平垂直居中基础题"></a>css实现水平垂直居中基础题</h3><h3 id="jQuery选择器是如何实现的，例如-（-a-b…）"><a href="#jQuery选择器是如何实现的，例如-（-a-b…）" class="headerlink" title="jQuery选择器是如何实现的，例如$（#a.b…）"></a>jQuery选择器是如何实现的，例如$（#a.b…）</h3><p>对于jquery我当时也只是停留在使用层面，没去了解过实现原理，结果也没答上来</p><h3 id="谈一下对事件流的了解"><a href="#谈一下对事件流的了解" class="headerlink" title="谈一下对事件流的了解"></a>谈一下对事件流的了解</h3><p>大概讲了一下事件的冒泡和捕获的区别，然后面试官又问了一下冒泡最后会到哪里，我不太确定说了到<body>,面试官又问我确不确定，我说不太确定。</body></p><p>8.最后给了一道算法题。大概是字符串的模式识别的题我写了一个最简单的，然后面试官要求优化复杂度，这个我当时隐约记得个kmp算法，就讲了一下思路，结果面试官要求写出实现代码，这磨蹭了半天也没写出来emmmmm…（顺带一提，当时面试用的是同学的电脑，不知道他装的IDE在哪，只好用的记事本写代码，痛苦）</p><p>总结</p><p>说实话当时我根本啥都不会，纯小白一个，复习了两三天菜鸟教程，w3school就去面试了，不出意外被拒了。</p><p>大厂很看重基础，考的都是原生css原生js和一些计算机网络、数据结构的内容，我了解的那些框架问题都没用上。</p><h3 id="面试铁律"><a href="#面试铁律" class="headerlink" title="面试铁律"></a>面试铁律</h3><p>自我介绍，基本上这是开启激战的导火索。顺便一提，宇宙条的视频面试是在<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.nowcoder.com" target="_blank" rel="noopener">牛客网</a>上，可进行编码，视频，语音，文字沟通。面试官可以实时看到应聘者当前页面的内容和操作。</p><hr><h3 id="基础题"><a href="#基础题" class="headerlink" title="基础题"></a>基础题</h3><p>1.display的取值和各种值的区别？</p><p>2.相邻的两个inline-block节点为什么会出现间隔，该如何解决？</p><p>3.用过nodejs中的EventEmitter吗？详细讲讲。</p><p>4.前端性能优化有哪些？</p><p>5.讲简历中提到的一个项目，并且讲解服务端渲染和前端渲染的优缺点？为什么你的项目会选择服务端渲染？</p><p>6.讲讲CSRF。</p><p>7.ts和js的区别，为什么要选择使用ts？</p><h3 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h3><p>找出数组中和为给定值的两个元素，如：[1, 2, 3, 4, 5]中找出和为6的两个元素。</p><p>题目很清晰，也很容易理解，相信很多小伙伴看到这个题都能直观地用“冒泡排序”的方法解决，但是冒泡排序的时间复杂度明显不是我们想要的结果，我把我能够想到的几种方法由易到难记录下来：</p><p><strong>冒泡排序的方式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function getNum(arr, sum) &#123;</span><br><span class="line">    if (!Array.isArray(arr)) return null;</span><br><span class="line"></span><br><span class="line">    for (var i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">        if (arr[i] &gt; sum) continue;</span><br><span class="line"></span><br><span class="line">        for (var j = 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">            if (arr[j] &gt; sum) continue;</span><br><span class="line"></span><br><span class="line">            if (arr[i] + arr[j] == sum) return [arr[i], arr[j]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这种解法很容易想到，也很容易理解，我们不多过多的讲解，接下来分享一种上述解法的优化版。</p><p><strong>查找的方式</strong></p><p>最终的结果是要找到和为sum的两个数，那么我们可以转换一种思路：默认第一个num1数已经存在，那么第二个数就是sum - num1，这就转换为从数组中查找的问题了。虽然和第一种方法很像，但是在有序数列中进行查找明显要快于逐个比较。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function getNum(arr, sum) &#123;</span><br><span class="line">    if (!Array.isArray(arr)) return null;</span><br><span class="line"></span><br><span class="line">    arr.sort();</span><br><span class="line"></span><br><span class="line">    for (var i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">        if (arr[i] &gt; sum) continue;</span><br><span class="line"></span><br><span class="line">        var restNum = sum - arr[i];</span><br><span class="line"></span><br><span class="line">        // 考虑下为什么要 &gt; i</span><br><span class="line">        if (arr.indexOf(restNum) &gt; i) return [arr[i], restNum];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种解法的前提是需要对数组进行排序（快排），故时间复杂度为O(nlogn)，二分查找的时间复杂度为O(log2n)，最坏的情况是遍历了整个数组，即时间复杂度为O(n)，那么整体的时间复杂度为O(nlog2n)，效果上要优于冒泡排序的方式。</p><p><strong>快排方式</strong></p><p>同样需要对数组进行排序（升序），我们知道排序后的数组必然是左边的数不会超过右边的数，因此我们可以把左边的数和右边的数的和作为基准值来和目标值比较，如果该值小于目标值，那么代表两个加数的值不够大，右边的值已经到达顶峰了，那么就从左边取下一个值相加和目标值比较，如果该值比目标值大，那么表示右边的值太大了，需要获取一个小一点的加数，这时需要从右边取倒数第二个数相加后比较，如果此时的值和目标值相等，恭喜你，我的小乖乖，原来你俩在这里！说了这么多感觉还是一头雾水的同学直接看代码吧，毕竟我们都是同一类猿:-)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function getNum(arr, sum) &#123;</span><br><span class="line">    if (!Array.isArray(arr)) return null;</span><br><span class="line"></span><br><span class="line">    arr.sort();</span><br><span class="line"></span><br><span class="line">    for (var i = 0, j = arr.length - 1; i &lt; j;) &#123;</span><br><span class="line">        if (arr[i] + arr[j] &lt; sum) i++;</span><br><span class="line"></span><br><span class="line">        else if (arr[i] + arr[j] &gt; sum) j--;</span><br><span class="line"></span><br><span class="line">        else return [arr[i], arr[j]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法我是受到了快速排序的启发，所以命名为快速排序的方式，它是目前为止我能想到效率最高的解决方案，时间复杂度为O(nlogn)。如果需求是找出所有对组合，只要控制退出条件即可，难度不大故不做讨论。</p><hr><p>面试考察点归纳</p><p>这里只是简要记录个人在前端面试遇到的考察点：</p><p>position和display、事件机制、dom、捕获冒泡、this及作用域、原型链、es6（了解）、vue的双向绑定原理（最好有用过，一定程度上考察了源代码理解）、基础的数据结构……等。</p><p>其中，dom的考察了一道，this及作用域考察了两道，数据结构考察了一道，其它的都以概念提问的方式进行考察。</p><p>可以总结出以下教训：</p><ul><li>js基础是重中之重，而前端对算法的要求基本上不是特别高，基础的数据结构牢固掌握了就没问题。另外前端的话，刷算法题最好用js。</li><li>对于你没怎么接触过的领域，面试官并不会去深究；但是，对于网上疯传的Vue等框架，最好有个了解和体验，甚至是深入源码。</li><li>一个很明显的现象是，一个概念你知道了，但不一定能说得清楚；一个概念你看似仔细了解过，但真正面临考察时不一定能说出个所以然。解决这个问题的最好办法是——写博客。</li><li>并没有考察到websocket、nodejs等知识，这个阶段的面试要求并没有网传得那么高。</li></ul><hr><h3 id="笔试-一面"><a href="#笔试-一面" class="headerlink" title="笔试 + 一面"></a>笔试 + 一面</h3><p>敲黑板！头条是一定会有笔试题的哦，css，js，算法都会考察噢。我尽量还原题目。。有的实在是忘了-.-</p><h3 id="实现css布局"><a href="#实现css布局" class="headerlink" title="实现css布局"></a>实现css布局</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一个div垂直居中</span><br><span class="line">其距离屏幕左右两边各10px</span><br><span class="line">其高度始终是宽度的50%</span><br><span class="line"></span><br><span class="line">div中有文本<span class="string">'A'</span></span><br><span class="line">其font—size:20px</span><br><span class="line">文本水平垂直居中</span><br></pre></td></tr></table></figure><p>我的回答：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"wrap"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"box"</span>&gt;</span><br><span class="line">        &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"text"</span>&gt;A&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">.wrap &#123;</span><br><span class="line">    position: fixed;</span><br><span class="line">    left: <span class="number">10</span>px;</span><br><span class="line">    right: <span class="number">10</span>px;</span><br><span class="line">    top: <span class="number">0</span>;</span><br><span class="line">    bottom: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: <span class="number">50</span>%;</span><br><span class="line">    transform: translateY(<span class="number">-50</span>%);</span><br><span class="line">    width: <span class="number">100</span>%;</span><br><span class="line">    height: <span class="number">50</span>%;</span><br><span class="line">    background: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.text &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: <span class="number">50</span>%;</span><br><span class="line">    left: <span class="number">50</span>%;</span><br><span class="line">    transform: translate(<span class="number">-50</span>%, <span class="number">-50</span>%);</span><br><span class="line">    color: #fff;</span><br><span class="line">    font-size: <span class="number">14</span>px;</span><br><span class="line">    background: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我的回答好像做不到“其高度始终是宽度的50%”这一点，网上参考了一下其他大神的，使用了calc和flex，大家可以看看：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"box"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"Abox"</span>&gt;A&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">*&#123;</span><br><span class="line">    padding:<span class="number">0</span>;</span><br><span class="line">    margin: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">html,body&#123;</span><br><span class="line">    width: <span class="number">100</span>%;</span><br><span class="line">    height: <span class="number">100</span>%;</span><br><span class="line">&#125;</span><br><span class="line">.box&#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    background: red;</span><br><span class="line">    width: <span class="number">100</span>%;</span><br><span class="line">    height: <span class="number">100</span>%;</span><br><span class="line">&#125;</span><br><span class="line">.Abox&#123;</span><br><span class="line">    margin-left:<span class="number">10</span>px;</span><br><span class="line">    width: calc(<span class="number">100</span>vw - <span class="number">20</span>px);</span><br><span class="line">    height: calc(<span class="number">50</span>vw - <span class="number">10</span>px);</span><br><span class="line">    position: absolute;</span><br><span class="line">    background: yellow;</span><br><span class="line">    top:<span class="number">50</span>%;</span><br><span class="line">    transform: translateY(<span class="number">-50</span>%);</span><br><span class="line">    display: flex;</span><br><span class="line">    align-items: center;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    font-size: <span class="number">20</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数中的arguments是数组吗？类数组转数组的方法了解一下？"><a href="#函数中的arguments是数组吗？类数组转数组的方法了解一下？" class="headerlink" title="函数中的arguments是数组吗？类数组转数组的方法了解一下？"></a>函数中的arguments是数组吗？类数组转数组的方法了解一下？</h3><p>答： arguments当然不是数组啦，转数组的方法有：</p><ul><li>[…arguments]</li><li>Array.from(arguments)</li></ul><h3 id="类型比较"><a href="#类型比较" class="headerlink" title="类型比较"></a>类型比较</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>([]==<span class="literal">false</span>)&#123;console.<span class="built_in">log</span>(<span class="number">1</span>)&#125;;</span><br><span class="line"><span class="keyword">if</span>(&#123;&#125;==<span class="literal">false</span>)&#123;console.<span class="built_in">log</span>(<span class="number">2</span>)&#125;;</span><br><span class="line"><span class="keyword">if</span>([])&#123;console.<span class="built_in">log</span>(<span class="number">3</span>)&#125;</span><br><span class="line"><span class="keyword">if</span>([<span class="number">1</span>]==[<span class="number">1</span>])&#123;console.<span class="built_in">log</span>(<span class="number">4</span>)&#125;</span><br></pre></td></tr></table></figure><p>答：1 3</p><ul><li>== 是非严格比较操作符，false会转换为0，[]会转换成’’，{}会转换为”[object Object]”，所以会输出1，不输出2，具体的可以看看以下文章</li></ul><blockquote><p>参考文章</p><p><a href="https://www.h5jun.com/post/why-false-why-true.html" target="_blank" rel="noopener">为什么[] 是 false</a></p></blockquote><ul><li>[]和{}是“空”的对象，不是“空”，所以会输出3</li><li>最后一个引用地址不一致，不是同一个对象，所以不会输出4</li></ul><h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">a1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a1 start'</span>)</span><br><span class="line">    <span class="keyword">await</span> a2()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a1 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">a2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a2'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">a1()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'promise2.then'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise2.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise3'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br></pre></td></tr></table></figure><p>正确答案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">a1 start</span><br><span class="line">a2</span><br><span class="line">promise2</span><br><span class="line">script end</span><br><span class="line"><span class="comment">// 此处开始执行异步队列</span></span><br><span class="line">promise1</span><br><span class="line">promise2.then</span><br><span class="line">promise3</span><br><span class="line"><span class="comment">// 真的不知道 a1 end 为啥在这里才输出，还以为会在promise1 后面。。</span></span><br><span class="line"><span class="comment">// 大家知道的话可以评论区分享一下啊～在网上看到的答案都说得模凌两可的</span></span><br><span class="line">a1 end</span><br><span class="line"><span class="comment">// 执行完所有微任务才执行宏任务</span></span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure><h3 id="改正代码，输出0123401234"><a href="#改正代码，输出0123401234" class="headerlink" title="改正代码，输出0123401234"></a>改正代码，输出0123401234</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>.i = i</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i)</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a()</span><br></pre></td></tr></table></figure><p>答：首先留意var，可以改成let，再加个立即执行函数；然后留意this指向，可以改为箭头函数。（我当时的想法就是这么短浅。。。）</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.i = i</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(i)</span><br><span class="line">            &#125;, <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.i)</span><br><span class="line">        &#125;)(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a()</span><br></pre></td></tr></table></figure><p>我的一个牛逼大神同事用了这个方法，实在佩服啊哈哈哈👇</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">'i'</span>, &#123;</span><br><span class="line">    <span class="keyword">get</span>: function() &#123;</span><br><span class="line">        <span class="keyword">return</span> count++</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function() &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.i = i</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.i)</span><br><span class="line">            &#125;, <span class="number">0</span>)</span><br><span class="line">        &#125;)(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a()</span><br></pre></td></tr></table></figure><p>5分钟后他又想出了一个新方法！我的膝盖啪一声跪下来👇</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>.i = i</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.i)</span><br><span class="line">        &#125;.bind(&#123;<span class="attr">i</span>: i&#125;), <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按要求写出bind（题目我实在记不清楚，反正不是简单的写一个bind）"><a href="#按要求写出bind（题目我实在记不清楚，反正不是简单的写一个bind）" class="headerlink" title="按要求写出bind（题目我实在记不清楚，反正不是简单的写一个bind）"></a>按要求写出bind（题目我实在记不清楚，反正不是简单的写一个bind）</h3><p>答：(以下是正常的bind手写实现)</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Function.prototype.bind - what is trying to be bound is not callable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fbound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> self ? <span class="keyword">this</span> : context, args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fNOP.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">    fbound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fbound;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从一个无序，不相等的数组中，选取N个数，使其和为M实现算法"><a href="#从一个无序，不相等的数组中，选取N个数，使其和为M实现算法" class="headerlink" title="从一个无序，不相等的数组中，选取N个数，使其和为M实现算法"></a>从一个无序，不相等的数组中，选取N个数，使其和为M实现算法</h3><p>哈哈哈哈哈做不出来，面试官很有耐心引导，假如选取2个数的话怎么实现呢，我就想到递归函数之类的，但是最后还是手写不出来。。。</p><p>一面的面试官主要是看着笔试题拓展问了相关的知识点，然后我也不知道怎么就过了一面了，，，</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>二面几乎都是算法题，再加点js基础题这样。emmm算法题我就说说当时的做法吧，，感觉要误人子弟了，，改天研究透了再单独分享</p><p><strong>1. 一个字典[‘I’, ‘have’, ‘a’, ‘book’, ‘good’]，实现一个函数，判断一个字符串中是否</strong>都是<strong>出自字典中的，输出true/false</strong></p><p>例如：</p><p>输入’I have a book’ 输出 true</p><p>输入 ‘this is a good book’ 输出 false</p><p>答： 我当时是想出了个很蠢的方法，就是将字符串的字典词都切了，切完后还有得剩就说明是false，哈哈哈哈啊哈哈哈好蠢啊，面试官不满意地问我这个做法的复杂度，我说好的我知错了。。。</p><p><strong>2. 一个长阶梯有n级，可以一次走1级，一次走2级，一共有多少种走法？</strong></p><p>答： 引导了一番后我写了个递归函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> step(n - <span class="number">1</span>) + step(n - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>面试官看完后不是很满意，说假如在浏览器上敲step(40000)会怎样，我说会爆掉吧。。他说为什么。。我说内存会溢出。。他问我为什么。。</p><p>blablabla一大堆后我还是没答好，回到家后我想想觉得应该是还存在尾递归的优化空间吧。。。</p><p>////////之后问的算法题我已经记不住了。。我再分享一些基础题题目吧，大部分答案都在之前的文章和面经都提过了，此处不再赘述</p><p><strong>3. 说说http缓存</strong></p><p><strong>4. 用过typescript吗？它的作用是什么？</strong></p><p>答： 用过，我真的只想到类型检查，提供缺省值诶，，后来想想还有引入了“类”“模块”的概念。</p><p><strong>5. ts的用法用到了装饰器，你了解过吗？知道如何实现的嘛？</strong></p><p>答：这个正好我写了一篇装饰器的文章，略知一二。。。实现大概就是使用object.defineProperty来拦截对象的属性进行“加工”</p><p><strong>6. PWA使用过吗？serviceWorker的使用原理是啥？</strong></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>。。。有的题目真的想不起来了，最后二面面试官和我说他们是对算法有要求的，包括前端。这次面试真的被虐得很惨，但是收获真的很多很多，而且也让自己意识到算法真的（对找工作）很重要～！</p><hr><h3 id="一面（40分钟）"><a href="#一面（40分钟）" class="headerlink" title="一面（40分钟）"></a>一面（40分钟）</h3><pre><code>自我介绍 1.线程与进程，空间分配、资源分配等等 2.三次握手、四次挥手及标志位、time-wait等等 3.H5的新特性，语义化 4.BOM与DOM，及BOM相关的一些属性 写代码：双向绑定、防抖和节流 5.设计模式：发布订阅、观察者 </code></pre><h3 id="二面（1小时）"><a href="#二面（1小时）" class="headerlink" title="二面（1小时）"></a>二面（1小时）</h3><pre><code>介绍项目 1.web worker，web storage，怎样验证本地数据的有效性 2.性能优化相关 3.缓存相关的http头部属性，强制缓存，协商缓存，优先级，以及meta标签 4.怎样做的登录，接着就是session，cookie，token等等 5.input属性相关，以及怎样做的文件上传 6.微信小程序相关（项目中有涉及到） 7.transform transition与animation 8.setTimeout、setInterval与requestAnimationFrame 9.页面加载问题，JS的异步加载 10.给出代码，说出运算结果（this、event loop） 写代码：回文数，数组去重，自定义log，判断数据类型 </code></pre><p>​      11.React与Vue，各自做了些什么事情 </p><h3 id="三面（1小时）"><a href="#三面（1小时）" class="headerlink" title="三面（1小时）"></a>三面（1小时）</h3><p>介绍项目 </p><ol><li><p>缓存命中率的问题，怎样确保缓存全部数据，缓存命中率不是100%应该怎么办 </p></li><li><p>说说性能优化的通用架构方案 </p></li><li><p>请求优化和渲染优化的方法 </p></li><li><p>数据类型转换的原理 </p></li><li><p>编程，5个feach请求，请求完成后要求立即执行，但最终的输出顺序要按照要求输出ABCDE（思路是：将每个feach的回调通过a/a的方式输出，但最后没有run出来） </p></li></ol><hr><p>面了一个小时，从四点面到五点一十，下面的问题可能不是所有的，反正我记得起来的都写了。</p><ol><li><p>算法：链表反序输出，不再申请内存空间</p></li><li><p>0.1+0.2===0.3吗，为什么？</p></li><li><p>Number()的存储空间是多大，如果后台发送了一个超过最大字节的数字怎们办</p></li><li><p>垂直居中实现方法</p></li><li><p>跨域、jsonp原理、CORS原理</p></li><li><p>Proxy</p></li><li><p>Promise原理</p></li><li><p>浏览器请求数据问题，请求数据到请求结束与服务器进行了几次交互</p></li><li><p>TCP为什么要四次挥手</p></li><li><p>cookie有哪些属性、大小、浏览器如何禁止别人访问cookie</p></li><li><p>localStorage，sessionStorage的区别。</p></li><li><p>display:none,visibility:hidden,opactiy:0的区别。</p></li><li><p>BFC，如何形成BFC</p></li><li><p>BFC与IFC的区别</p></li><li><p>BFC会与float元素相互覆盖吗？为什么？举例说明</p></li><li><p>回流与重绘，如何避免回流</p></li><li><p>git merge、git rebase的区别</p></li><li><p>js脚本加载问题，async、defer问题</p></li><li><p>antd源码相关，使用什么语言写的，按需加载实现</p></li><li><p>设计模式，有哪些设计模式</p></li><li><p>在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持</p></li><li><p>websocket与ajax的区别</p></li><li><p>fetch API与传统request的区别</p></li></ol><p>说一下心得好了，因为他面算法，我不会，我说我只会简单的快排、冒泡、归并等算法，所以面试官后面就没问算法了</p><p>问框架我有的答得出来，我跟他说我框架掌握比较薄弱，基础比较厉害，所以框架就问的少，问很多js相关、交互相关的基础</p><p>一面过了，面试官是个很可爱的小哥哥，虽然前面第一题问算法，第二题问框架，我都没答出来很尴尬，但后面问很多js和浏览器基础，都答上来了，所以,面试还是很人性化的~</p><p>其实这些面试题哈哈，上次我跟部门的小哥哥小姐姐去吃火锅，坐在我一面面试官对面，还拿着题考他哈哈，这边的人真的超级可爱～</p><p>然后我一面、二面、三面都发了帖子，大家可以对比一下啊。，一般一面是部门同事面，涉及到比较广，如果面到40min以上基本上稳的几率比较大，二面是其他部门的前端交叉面你，主要问项目比较多，然后很可能手撕代码（校招可能一面就手撕）。三面的话是leader面，应该会着重问一下你的学习能力什么的。</p><hr><h3 id="首先，一般的都是介绍自己，主要是项目经历"><a href="#首先，一般的都是介绍自己，主要是项目经历" class="headerlink" title="首先，一般的都是介绍自己，主要是项目经历"></a>首先，一般的都是介绍自己，主要是项目经历</h3><h3 id="jQuery与Vue的区别是什么？"><a href="#jQuery与Vue的区别是什么？" class="headerlink" title="jQuery与Vue的区别是什么？"></a>jQuery与Vue的区别是什么？</h3><p><em>JQuery和Vue的主要区别是JQuery主要是通过选择器来选取DOM，对其进行赋值，取值，事件绑定等操作，数据和页面是混合在一起的；Vue则是通过Vue对象将数据和视图完全分割开来，对数据进行操作，不再需要引用相应的DOM对象，实现了MVVM。</em></p><h3 id="javascript数据基本类型有哪些？"><a href="#javascript数据基本类型有哪些？" class="headerlink" title="javascript数据基本类型有哪些？"></a>javascript数据基本类型有哪些？</h3><p><em>null、boolean、string、undefined、number、symbol(ES6新加)</em></p><h3 id="css-水平垂直居中方法"><a href="#css-水平垂直居中方法" class="headerlink" title="css 水平垂直居中方法"></a>css 水平垂直居中方法</h3><p>body{</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  height:1000 px;</span><br><span class="line">&#125;</span><br><span class="line">.antzoen&#123;</span><br><span class="line">  position:fixed;</span><br><span class="line">  width:250px;</span><br><span class="line">  height:100px;</span><br><span class="line">  background:#ececec;</span><br><span class="line">  left:50%;</span><br><span class="line">  top:50%;</span><br><span class="line">  margin-left:-125px;</span><br><span class="line">  margin-top:-50px</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用flex布局：<br>.center{</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display:flex;</span><br><span class="line">justify-content:center;</span><br><span class="line">align-items:center;</span><br></pre></td></tr></table></figure><p>}<br>等等还有很多其他的方法就不一一分享了。</p><p>11月25号流程：</p><p>   1.笔试，给了两页题自己做，大概做了40分钟我怕时间太久，有一道题没写出来就交了。</p><p>​    2.一面，面试官拿着我的笔试答案一道题一道题问，答上来的就直接说答案，答不上来的我说了下我的思路，和面试官一起探讨思考答案。</p><p>​    3.二面，问项目，问了问以前做的项目，遇到什么挑战等等，还问了几个JS问题。</p><p>​    4.三面，主管面，问项目，问方案，三面就像在聊天，没有压力。</p><p>​    5.四面，HR面，问一些和技术无关的，如兴趣、原来公司等等，然后就定级、定薪资了。发布</p><p>11月26号：</p><p>​    6.五面，交叉面，别的部门的人来面试，简单聊了聊项目，然后出了个算法题，没答上来，15分钟就结束了</p><p>11月27号：</p><p>​    面试结果审核通过，薪资审核</p><p>11月28号：</p><p>​    薪资审核通过，收到了offer</p><hr><h3 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h3><h4 id="1-css3特性中的transform：translateZ-0-有什么作用"><a href="#1-css3特性中的transform：translateZ-0-有什么作用" class="headerlink" title="1.css3特性中的transform：translateZ(0)有什么作用"></a>1.css3特性中的transform：translateZ(0)有什么作用</h4><p><strong>答案：</strong><br>GPU加速，优化前端性能</p><h4 id="2-列举三种禁止浏览器缓存的头字段，并写出响应的设置值"><a href="#2-列举三种禁止浏览器缓存的头字段，并写出响应的设置值" class="headerlink" title="2.列举三种禁止浏览器缓存的头字段，并写出响应的设置值"></a>2.列举三种禁止浏览器缓存的头字段，并写出响应的设置值</h4><p><strong>Expires：</strong>告诉浏览器把回送的资源缓存多长时间 -1或0则是不缓存<br><strong>简要：</strong>添加Expires头能有效的利用浏览器的缓存能力来改善页面的性能，能在后续的页面中有效避免很多不必要的Http请求，WEB服务器使用Expires头来告诉Web客户端它可以使用一个组件的当前副本，直到指定的时间为止。<br>例如：Expires：Thu，15 Apr 2010 20：00：00 GMT; 他告诉浏览器缓存有效性持续到2010年4月15日为止，在这个时间之内相同的请求使用缓存，这个时间之外使用http请求。</p><p>Cache-Control：no-cache<br>Cathe-Control：max-age=315360000</p><p>Expires有一个非常大的缺陷，它使用一个固定的时间，要求服务器与客户端的时钟保持严格的同步，并且这一天到来后，服务器还得重新设定新的时间。<br>HTTP1.1引入了Cathe-Control，它使用max-age指定组件被缓存多久，从请求开始在max-age时间内浏览器使用缓存，之外的使用请求，这样就可以消除Expires的限制，<br>如果对浏览器兼容性要求很高的话，可以两个都使用。</p><p>Pragma：no-cache</p><h4 id="3-精确获取页面元素位置的方式有哪些"><a href="#3-精确获取页面元素位置的方式有哪些" class="headerlink" title="3.精确获取页面元素位置的方式有哪些"></a>3.精确获取页面元素位置的方式有哪些</h4><p>那就是使用getBoundingClientRect()方法。它返回一个对象，其中包含了left、right、top、bottom四个属性，分别对应了该元素的左上角和右下角相对于浏览器窗口（viewport）左上角的距离。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> X= <span class="keyword">this</span>.getBoundingClientRect().left;</span><br><span class="line"><span class="keyword">var</span> Y =<span class="keyword">this</span>.getBoundingClientRect().top;</span><br><span class="line"><span class="comment">//再加上滚动距离，就可以得到绝对位置</span></span><br><span class="line"><span class="keyword">var</span> X= <span class="keyword">this</span>.getBoundingClientRect().left+<span class="built_in">document</span>.documentElement.scrollLeft;</span><br><span class="line"><span class="keyword">var</span> Y =<span class="keyword">this</span>.getBoundingClientRect().top+<span class="built_in">document</span>.documentElement.scrollTop;</span><br></pre></td></tr></table></figure><h4 id="4-正则从2018-10-07T11-48-47-Asia-zh-cn-提取出来结果-2018-10-07-11-48-47"><a href="#4-正则从2018-10-07T11-48-47-Asia-zh-cn-提取出来结果-2018-10-07-11-48-47" class="headerlink" title="4.正则从2018-10-07T11:48:47 Asia/zh-cn 提取出来结果[2018,10,07,11,48,47]"></a>4.正则从2018-10-07T11:48:47 Asia/zh-cn 提取出来结果[2018,10,07,11,48,47]</h4><p>“2018-10-07T11:48:47 Asia/zh-cn”.match( /\d{1,}/g )</p><h4 id="5-如何判断object是数组类型？"><a href="#5-如何判断object是数组类型？" class="headerlink" title="5.如何判断object是数组类型？"></a>5.如何判断object是数组类型？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="keyword">typeof</span> <span class="number">1</span>);                <span class="comment">// 返回字符串"number" </span></span><br><span class="line">alert(<span class="keyword">typeof</span> <span class="string">"1"</span>);              <span class="comment">// 返回字符串"string" </span></span><br><span class="line">alert(<span class="keyword">typeof</span> <span class="literal">true</span>);             <span class="comment">// 返回字符串"boolean" </span></span><br><span class="line">alert(<span class="keyword">typeof</span> &#123;&#125;);               <span class="comment">// 返回字符串"object" </span></span><br><span class="line">alert(<span class="keyword">typeof</span> []);               <span class="comment">// 返回字符串"object " </span></span><br><span class="line">alert(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);     <span class="comment">// 返回字符串"function" </span></span><br><span class="line">alert(<span class="keyword">typeof</span> <span class="literal">null</span>);             <span class="comment">// 返回字符串"object" </span></span><br><span class="line">alert(<span class="keyword">typeof</span> <span class="literal">undefined</span>);        <span class="comment">// 返回字符串"undefined"</span></span><br></pre></td></tr></table></figure><p>其中，typeof {}和typeof []的结果都是object，那么问题来了，我怎么通过typeof去判断一个对象是不是数组类型呢？</p><p>对象是对象，数组也是对象，js中万物皆对象，很显然，通过简单的typeof运算符是不能够达到目的，我们得换个方法。</p><p>1、从原型入手，Array.prototype.isPrototypeOf(obj);</p><p>利用isPrototypeOf()方法，判定Array是不是在obj的原型链中，如果是，则返回true,否则false。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://img2.mukewang.com/5d4cda5e0001131b02830079.jpg" alt="判断object是数组类型" title>                </div>                <div class="image-caption">判断object是数组类型</div>            </figure><p>2.Array.isArray()方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(&#123;<span class="attr">foo</span>: <span class="number">123</span>&#125;); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="string">'foobar'</span>);   <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="literal">undefined</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>500：服务器内部错误。</p><p>501：服务器不具备完成请求的功能。</p><p>502：Bad Gateway错误。</p><p>503：服务器目前无法使用。</p><p>504： Bad Gateway timeout 网关超时。</p><p>cookie：</p><p>在本地计算机保存一些用户操作的历史信息（当然包括登录信息），并在用户再次访问该站点时浏览器通过HTTP协议将本地cookie内容发送给服务器，从而完成验证，或继续上一步操作。</p><p>session：</p><p>是一种服务器端的机制，服务器使用一种类似于散列表的结构(也可能就是使用散列表)来保存信息。</p><h3 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h3><h4 id="1-已知数据结构users，请实现语法支持user-unique能够按照name字段去重，并输出结构为：-“a”-“b”"><a href="#1-已知数据结构users，请实现语法支持user-unique能够按照name字段去重，并输出结构为：-“a”-“b”" class="headerlink" title="1.已知数据结构users，请实现语法支持user.unique能够按照name字段去重，并输出结构为：[“a”,“b”]"></a>1.已知数据结构users，请实现语法支持user.unique能够按照name字段去重，并输出结构为：[“a”,“b”]</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> users=[&#123;</span><br><span class="line">   id:<span class="number">1</span>,<span class="attr">name</span>:<span class="string">"a"</span></span><br><span class="line">&#125;,&#123;</span><br><span class="line">   id:<span class="number">2</span>,<span class="attr">name</span>:<span class="string">"a"</span></span><br><span class="line">&#125;,&#123;</span><br><span class="line">   id:<span class="number">3</span>,<span class="attr">name</span>:<span class="string">"b"</span></span><br><span class="line">&#125;,&#123;</span><br><span class="line">   id:<span class="number">4</span>,<span class="attr">name</span>:<span class="string">"v"</span></span><br><span class="line">&#125;]</span><br><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res;</span><br><span class="line">    <span class="keyword">this</span>.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>[item.id - <span class="number">1</span>] = item.name</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// ES6里新添加了两个很好用的东西，set和Array.from</span></span><br><span class="line">    <span class="comment">// set是一种新的数据结构，它可以接收一个数组或者是类数组对象，自动去重其中的重复项目。</span></span><br><span class="line">    res=<span class="keyword">new</span> <span class="built_in">Set</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"new Set对象"</span>,res)</span><br><span class="line">    <span class="comment">// 但是这里大家可以看到，set返回的是一个对象，但是我们想要的是数组啊。</span></span><br><span class="line">    <span class="comment">// 这回，就该轮到Array.from出场了，它的作用，就是可以把类数组对象、可迭代对象转化为数组。</span></span><br><span class="line">    res=<span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(<span class="keyword">this</span>));</span><br><span class="line">    <span class="keyword">return</span>  res<span class="comment">//es6 数组去重</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(users.unique());</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://img.mukewang.com/5d4cda5e00018f5306410263.jpg" alt="去重" title>                </div>                <div class="image-caption">去重</div>            </figure><h4 id="2-已知如下对象，请基于es6的proxy方法设计一个属性拦截读取操作的例子，要求实现去访问目标对象example中不存在的属性时，抛出错误：Property-“-property-”-does-not-exist"><a href="#2-已知如下对象，请基于es6的proxy方法设计一个属性拦截读取操作的例子，要求实现去访问目标对象example中不存在的属性时，抛出错误：Property-“-property-”-does-not-exist" class="headerlink" title="2.已知如下对象，请基于es6的proxy方法设计一个属性拦截读取操作的例子，要求实现去访问目标对象example中不存在的属性时，抛出错误：Property “$(property)” does not exist"></a>2.已知如下对象，请基于es6的proxy方法设计一个属性拦截读取操作的例子，要求实现去访问目标对象example中不存在的属性时，抛出错误：Property “$(property)” does not exist</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> man=&#123;</span><br><span class="line">    name:<span class="string">'jscoder'</span>,</span><br><span class="line">    age:<span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//补全代码</span></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(...)</span><br><span class="line">proxy.name <span class="comment">//"jscoder"</span></span><br><span class="line">proxy.age <span class="comment">//22</span></span><br><span class="line">proxy.location <span class="comment">//Property "$(property)" does not exist</span></span><br></pre></td></tr></table></figure><p><strong>考点</strong><br>es6 javascript的Proxy 实例的方法 ,<code>get()</code> get方法用于拦截某个属性的读取操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> man = &#123;</span><br><span class="line">name:<span class="string">'jscoder'</span>,</span><br><span class="line">    age:<span class="number">22</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(man, &#123;</span><br><span class="line"><span class="keyword">get</span>: function(target, property) &#123;</span><br><span class="line"><span class="keyword">if</span>(property <span class="keyword">in</span> target) &#123;</span><br><span class="line"><span class="keyword">return</span> target[property];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">`Property <span class="subst">$&#123;property&#125;</span> does not exist.`</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(proxy.name)</span><br><span class="line"><span class="built_in">console</span>.log(proxy.age)</span><br><span class="line"><span class="built_in">console</span>.log(proxy.location)</span><br></pre></td></tr></table></figure><p>Proxy 实例的方法的其他方法参考这个链接，很详细<br><a href="https://blog.csdn.net/qq_30100043/article/details/53443017" target="_blank" rel="noopener">https://blog.csdn.net/qq_30100043/article/details/53443017</a></p><h4 id="3-给出如下虚拟dom的数据结构，如何实现简单的虚拟dom，渲染到目标dom树"><a href="#3-给出如下虚拟dom的数据结构，如何实现简单的虚拟dom，渲染到目标dom树" class="headerlink" title="3.给出如下虚拟dom的数据结构，如何实现简单的虚拟dom，渲染到目标dom树"></a>3.给出如下虚拟dom的数据结构，如何实现简单的虚拟dom，渲染到目标dom树</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//样例数据</span></span><br><span class="line"><span class="keyword">let</span> demoNode = (&#123;</span><br><span class="line">    tagName: <span class="string">'ul'</span>,</span><br><span class="line">    props: &#123;<span class="string">'class'</span>: <span class="string">'list'</span>&#125;,</span><br><span class="line">    children: [</span><br><span class="line">        (&#123;<span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">children</span>: [<span class="string">'douyin'</span>]&#125;),</span><br><span class="line">        (&#123;<span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">children</span>: [<span class="string">'toutiao'</span>]&#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>//构建一个render函数，将demoNode对象渲染为以下dom</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>douyin<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>toutiao<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>看到虚拟DOM，是不是感觉很玄乎，但是剥开它华丽的外衣，也就那样:</p><ol><li>通过JavaScript来构建虚拟的DOM树结构，并将其呈现到页面中；</li><li>当数据改变，引起DOM树结构发生改变，从而生成一颗新的虚拟DOM树，将其与之前的DOM对比，将变化部分应用到真实的DOM树中，即页面中。<br>通过上面的介绍，下面，我们就来实现一个简单的虚拟DOM，并将其与真实的DOM关联。</li></ol><p><strong>构建虚拟DOM</strong></p><p>虚拟DOM，其实就是用JavaScript对象来构建DOM树，如上ul组件模版，其树形结构如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://img2.mukewang.com/5d4cda5e0001680407010564.jpg" alt="DOM树" title>                </div>                <div class="image-caption">DOM树</div>            </figure><p>通过JavaScript，我们可以很容易构建它，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elem = Element(&#123;</span><br><span class="line">    tagName: <span class="string">'ul'</span>,</span><br><span class="line">    props: &#123;<span class="string">'class'</span>: <span class="string">'list'</span>&#125;,</span><br><span class="line">    children: [</span><br><span class="line">        Element(&#123;<span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">children</span>: [<span class="string">'item1'</span>]&#125;),</span><br><span class="line">        Element(&#123;<span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">children</span>: [<span class="string">'item2'</span>]&#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>note：Element为一个构造函数，返回一个Element对象。为了更清晰的呈现虚拟DOM结构，我们省略了new，而在Element中实现。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @Params:</span></span><br><span class="line"><span class="comment">*     tagName(string)(requered)</span></span><br><span class="line"><span class="comment">*     props(object)(optional)</span></span><br><span class="line"><span class="comment">*     children(array)(optional)</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Element</span>(<span class="params">&#123;tagName, props, children&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Element))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Element(&#123;tagName, props, children&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.tagName = tagName;</span><br><span class="line">    <span class="keyword">this</span>.props = props || &#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>.children = children || [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，通过Element我们可以任意地构建虚拟DOM树了。但是有个问题，虚拟的终归是虚拟的，我们得将其呈现到页面中，不然，没卵用。。</p><p>怎么呈现呢？</p><p>从上面得知，这是一颗树嘛，那我们就通过遍历，逐个节点地创建真实DOM节点:</p><p>\1. createElement;</p><p>\2. createTextNode.</p><p>怎么遍历呢？</p><p>因为这是一颗树嘛，对于树形结构无外乎两种遍历：</p><p>\1. 深度优先遍历(DFS)</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://img3.mukewang.com/5d4cda5f0001fbcb05660350.jpg" alt="深度优先遍历" title>                </div>                <div class="image-caption">深度优先遍历</div>            </figure><p>\2. 广度优先遍历(BFS)</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://img3.mukewang.com/5d4cda5f0001db3005510438.jpg" alt="广度优先遍历" title>                </div>                <div class="image-caption">广度优先遍历</div>            </figure><p>针对实际情况，我们得采用DFS，为什么呢？</p><p>因为我们得将子节点append到父节点中</p><p>好了，那我们采用DFS，就来实现一个render函数吧，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Element.prototype.render = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> el = <span class="built_in">document</span>.createElement(<span class="keyword">this</span>.tagName),</span><br><span class="line">        props = <span class="keyword">this</span>.props,</span><br><span class="line">        propName,</span><br><span class="line">        propValue;</span><br><span class="line">    <span class="keyword">for</span>(propName <span class="keyword">in</span> props)&#123;</span><br><span class="line">        propValue = props[propName];</span><br><span class="line">        el.setAttribute(propName, propValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.children.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">child</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> childEl = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(child <span class="keyword">instanceof</span> Element)&#123;</span><br><span class="line">            childEl = child.render();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            childEl = <span class="built_in">document</span>.createTextNode(child);</span><br><span class="line">        &#125;</span><br><span class="line">        el.appendChild(childEl);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> el;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时，我们就可以轻松地将虚拟DOM呈现到指定真实DOM中啦。假设，我们将上诉ul虚拟DOM呈现到页面body中，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elem = Element(&#123;</span><br><span class="line">    tagName: <span class="string">'ul'</span>,</span><br><span class="line">    props: &#123;<span class="string">'class'</span>: <span class="string">'list'</span>&#125;,</span><br><span class="line">    children: [</span><br><span class="line">        Element(&#123;<span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">children</span>: [<span class="string">'item1'</span>]&#125;),</span><br><span class="line">        Element(&#123;<span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">children</span>: [<span class="string">'item2'</span>]&#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'body'</span>).appendChild(elem.render());</span><br></pre></td></tr></table></figure><hr><p>整个面试持续了41分钟….<br>上来寒暄几句，例行自我介绍</p><h3 id="第一部分：JS基础"><a href="#第一部分：JS基础" class="headerlink" title="第一部分：JS基础"></a>第一部分：JS基础</h3><p>1.JS的数据类型有哪些<br>张口就出，没啥难度<br>2.讲一讲js的作用域？<br>ES6之前函数作用域，ES6之后有了块作用域（let）<br>3.let和var有啥区别？和const有啥区别？<br>和var的比较简单。。。变量声明不提前，不能重复定义，作用域不同等等张口就来，和const的不太了解，只答了个const定义的是不可改变的常量<br>4.ES6之前通过prototype实现继承，聊一聊？<br>巴拉巴拉一大堆<br>5.函数的call和apply有什么区别？和bind又有啥区别？<br>比较简单。。。call和apply区别在于第二个参数，而bind这个和另外两个根本没啥相似的，说一遍他的作用就行了。<br>6.如果一个构造函数，bind了一个对象，用这个构造函数创建出的实例会继承这个对象的属性吗？为什么？<br>不会，bind没有改变原函数，单纯返回一个绑定了目标对象的新函数<br>7.箭头函数和普通函数有啥区别？箭头函数能当构造函数吗？<br>区别主要在于this，能不能当不知道。。。老实交代了<br>8.说一说this在各种情况下可能的取值？<br>这个感觉答得还不错，主要就是全局函数的this是全局对象，但是严格模式下是undefined，平常调用的话this就是调用函数的对象，还有比较特殊的就是apply和call调用的函数，this是主动设置的。另外，forEach函数可以传入第二个参数作为第一个参数的this值。<br>9.http有哪些状态码？分别代表什么意思？<br>这个简单，学过计网的都知道，12345开头的都说一下就行<br>10.用过哪些http请求方法？<br>GET POST OPTION PUT DELETE<br>11.OPTION是干啥的？举个用到OPTION的例子？<br>测试服务器支持的请求类型，例子的话我举的CORS中应对非简单跨域请求时会先发一个OPTION测一测允不允许跨域。<br>12.你知道哪些跨域方法？说说他们的原理？<br>JSONP、CORS。。。本咸鱼就知道这两个，然后讲了讲实现方案<br>13.知道ES6的class吗？<br>了解一些，它是prototype的语法糖，但是不熟悉（干脆利落不给自己挖坑，把战场拉回自己熟悉的领域）<br>14.static关键字了解吗？<br>不了解，但是我知道java中的static，巴拉巴拉讲一堆java的static<br>15.数组和类数组对象有啥区别？二者如何转换？<br>这里我提到了“鸭式辩形”，围绕这个聊二者的区别。转换的话，说实话我是不知道的，然后编了一下应该是可以用循环遍历类数组对象的所有属性，然后挨个push到真正的数组里的。</p><h3 id="第二部分-CSS基础"><a href="#第二部分-CSS基础" class="headerlink" title="第二部分 CSS基础"></a>第二部分 CSS基础</h3><p>1 .说一下你知道的position属性，都有啥特点？<br>张口就来系列<br>2.聊一聊盒模型？<br>开始没弄明白面试官想问啥。。懵了一会。。。后来在面试官的指引下才知道他想让我说盒模型由什么组成。。。width height margin padding border张口就来。。。松了一口气<br>3.两个div上下排列，都设margin，有什么现象？<br>这个简单，就是margin重叠，同正取大正负相加很简单<br>4.为什么会有这种现象？你能解释一下吗<br>恕我直言。。。不能。。。。<br>5.其实这是由块级格式化上下文决定的，你了解吗，能说一下吗？<br>emmm之前看过格式化上下文这块，还专门做过笔记，但是忘了。。。。emmm，勉强说了一些自己还记得的东西<br>6.了解css3中的新东西吗？比如flex、动画这些？<br>flex了解，但是动画只写过一些小demo<br>7.清除浮动有哪些方法？<br>一时想不起来。。就说了个overflow：hidden。太长时间没写过浮动了，都忘了，太菜了。。<br>（面试官可能看出来我css差的离谱了。。。就不聊css了）</p><h3 id="第三部分-现场写代码（用自己电脑屏幕分享，面试官会看着你敲的每个字母，挺紧张的）"><a href="#第三部分-现场写代码（用自己电脑屏幕分享，面试官会看着你敲的每个字母，挺紧张的）" class="headerlink" title="第三部分 现场写代码（用自己电脑屏幕分享，面试官会看着你敲的每个字母，挺紧张的）"></a>第三部分 现场写代码（用自己电脑屏幕分享，面试官会看着你敲的每个字母，挺紧张的）</h3><p>1.实现一个两栏三列的布局，并且要求三列等高，且以内容最多的一列的高度为准。<br>两栏三列比较好实现，双飞翼、圣杯布局这都是基础的东西。然后面试官问，还有没有其他实现方案？提示了一下说用新特性，然后我用flex又写了一个，搞定。高度的问题的话，很快想出了解决方案，okpass。<br>2.判断一个字符串是不是回文的<br>这个也挺简单的。。。不到十行搞定，一次测试通过。然后面试官问有没有其他实现方案，我又巴拉巴拉说了一下，最后问我两个方案哪个好，时间复杂度分别是多少？应该没说错（吧）<br>这里最好注意一下。。面试官让你现场运行测试，如果用js写的话最好是node跑一下就行，如果不会node的话，还得放到浏览器跑就很low。。。</p><p>第四部分 智商测试（我自己取的名字）<br>一个圆形的桌子，在上面随意放圆形棋子，谁先没地方放谁输，问有没有必胜策略，有的话应该怎么才能达到必胜？<br>这个真的是我想多了。。。我当时还在考虑各种问题，比如棋子的直径和圆桌半径的关系，甚至极限情况下整个桌子只能放一个棋子呢之类的。。。。后来面试官提示“想想圆有什么特殊的位置”，恍然大悟，只要占据了圆心，其他任何地方你落一个子我都能找到一个关于圆心对称的地方落子。。。哎呀，真是太菜了。面试结束后搜了搜这道题，尼玛还是经典面试题。。。面试之前多看看面经肯定秒答。。。真的是太菜了。</p><hr><h3 id="面试经验一：凉的很快，不过面试官人比较好"><a href="#面试经验一：凉的很快，不过面试官人比较好" class="headerlink" title="面试经验一：凉的很快，不过面试官人比较好"></a>面试经验一：凉的很快，不过面试官人比较好</h3><p>此面试总共花费1天时间，面试形式包括1对1面试，面试的职位是前端开发实习生。</p><h4 id="面试过程"><a href="#面试过程" class="headerlink" title="面试过程"></a>面试过程</h4><p>凉的很快，不过面试官人比较好，一面本来是考基础的，上来就是5到编程题，虽然比较简单，但是我有点头皮发麻。</p><h4 id="面试过程中面试官提了哪些问题"><a href="#面试过程中面试官提了哪些问题" class="headerlink" title="面试过程中面试官提了哪些问题"></a>面试过程中面试官提了哪些问题</h4><p>1、一亿条数据中如何快速的查找1000条最大的数据<br>2、对于promise的了解<br>3、get和post的区别<br>3、http状态码<br>4、tcp和udp的区别<br>5、dns的详细过程</p><hr><h3 id="面试经验二：电脑视频面试。一面小语种自我介绍"><a href="#面试经验二：电脑视频面试。一面小语种自我介绍" class="headerlink" title="面试经验二：电脑视频面试。一面小语种自我介绍"></a>面试经验二：电脑视频面试。一面小语种自我介绍</h3><p>此面试总共花费1天时间，面试形式包括电话面试，面试的职位是内容安全运营。</p><h4 id="面试过程-1"><a href="#面试过程-1" class="headerlink" title="面试过程"></a>面试过程</h4><p>电脑视频面试。一面小语种自我介绍，面试官做相关提问。之后看一些小视频判断其中是否有问题，并指出问题。二面看你对该岗位的了解程度和意愿。之后还有三面谈一些待遇问题。</p><h4 id="面试过程中面试官提了哪些问题-1"><a href="#面试过程中面试官提了哪些问题-1" class="headerlink" title="面试过程中面试官提了哪些问题"></a>面试过程中面试官提了哪些问题</h4><p>是否了解此岗位。<br>这些视频是否有问题，是否有语言问题（是否存在不文明用语）。<br>是否能实习半年。</p><hr><h3 id="面试经验三：先是电话面试了解了一下情况"><a href="#面试经验三：先是电话面试了解了一下情况" class="headerlink" title="面试经验三：先是电话面试了解了一下情况"></a>面试经验三：先是电话面试了解了一下情况</h3><p>面试的职位是招聘实习生。</p><h4 id="面试过程-2"><a href="#面试过程-2" class="headerlink" title="面试过程"></a>面试过程</h4><p>先是电话面试了解了一下情况 是不是应届 了解了未来规划之类的 说明了实习转正所需时间以及要求 没有特别肯定说啥然后就是远程视频面试了</p><h4 id="面试过程中面试官提了哪些问题-2"><a href="#面试过程中面试官提了哪些问题-2" class="headerlink" title="面试过程中面试官提了哪些问题"></a>面试过程中面试官提了哪些问题</h4><p>主要是围绕简历挖掘了很多 首先是简单的自我介绍 具体工作的状况 遇到的问题 还有个人性格方面的 优缺点啥的 还有对岗位的了解</p><hr><h3 id="面试经验四：主要是个人介绍，从学历到几段工作经验"><a href="#面试经验四：主要是个人介绍，从学历到几段工作经验" class="headerlink" title="面试经验四：主要是个人介绍，从学历到几段工作经验"></a>面试经验四：主要是个人介绍，从学历到几段工作经验</h3><p>此面试总共花费2天时间，面试形式包括1对1面试，面试的职位是软件产品经理。</p><h4 id="面试过程-3"><a href="#面试过程-3" class="headerlink" title="面试过程"></a>面试过程</h4><p>主要是个人介绍，从学历到几段工作经验，详细介绍，由于之前一直是开发，对方对开发经历不是很感兴趣，主要介绍了近一年的工作经历，做了哪些项目之类的</p><h4 id="面试过程中面试官提了哪些问题-3"><a href="#面试过程中面试官提了哪些问题-3" class="headerlink" title="面试过程中面试官提了哪些问题"></a>面试过程中面试官提了哪些问题</h4><p>自我介绍，关于项目上的一些问题，详细问了项目都做了些什么，系统的功能之类的，自身有什么优势，关于产品有什么想法。</p><hr><h3 id="面试经验五：面试官很nice，很准时、很随和"><a href="#面试经验五：面试官很nice，很准时、很随和" class="headerlink" title="面试经验五：面试官很nice，很准时、很随和"></a>面试经验五：面试官很nice，很准时、很随和</h3><p>面试形式包括1对1面试，面试的职位是hr。</p><h4 id="面试过程-4"><a href="#面试过程-4" class="headerlink" title="面试过程"></a>面试过程</h4><p>面试官很nice，很准时、很随和，问的问题围绕个人的经历，全程气氛很轻松，会回答可以多说，不会也不会为难你的</p><h4 id="面试过程中面试官提了哪些问题-4"><a href="#面试过程中面试官提了哪些问题-4" class="headerlink" title="面试过程中面试官提了哪些问题"></a>面试过程中面试官提了哪些问题</h4><p>分享一下你抗压的经验和你解决的方法，进行自我介绍和为什么投递这个岗位，也问了一些专业相关的问题，但是我不太懂所以就水过去了</p><hr><h3 id="面试经验六：两轮面试-简单的聊天，-二面偏压力面"><a href="#面试经验六：两轮面试-简单的聊天，-二面偏压力面" class="headerlink" title="面试经验六：两轮面试 简单的聊天， 二面偏压力面"></a>面试经验六：两轮面试 简单的聊天， 二面偏压力面</h3><p>面试形式包括电话面试、1对1面试，面试的职位是商务合同。</p><h4 id="面试过程-5"><a href="#面试过程-5" class="headerlink" title="面试过程"></a>面试过程</h4><p>两轮面试<br>简单的聊天， 二面偏压力面， 基本上是简历上的问题 问的比较详细。<br>用zoom进行面试，部门领导直接面，会问有没有参加秋招</p><h4 id="面试过程中面试官提了哪些问题-5"><a href="#面试过程中面试官提了哪些问题-5" class="headerlink" title="面试过程中面试官提了哪些问题"></a>面试过程中面试官提了哪些问题</h4><p>对加班的看法<br>为什么不选择财务<br>我的职业规划<br>有没有参加秋招<br>春招准备参加与否<br>家乡 父母的工作</p><hr><h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><ul><li><p>对函数式编程了解说一下 纯函数，偏应用，柯里化，compose 分别是什么 </p></li><li><p>写一下柯里化 </p></li><li><p>apply，call，bind 的区别 </p></li><li><p>一段代码 setTimeout(function() { console.log(1) }, 0); new Promise(function<br>executor(resolve) { console.log(2); for (var i = 0; i &lt; 10000; i++) { i == 9999<br>&amp;&amp; resolve(); } console.log(3); }).then(function() { console.log(4); }); console<br>.log(5);<br>为什么 3 不打印（这里说错了，应该是打印的），1 最后打印</p></li><li><p>说一下事件循环 </p></li><li><p>BFC 和 IFC 有了解吗，BFC 特性及条件 </p></li><li><p>盒模型 </p></li><li><p>css 画一个平行四边形，translate </p></li><li><p>浏览器输入 url 到渲染 </p></li><li><p>缓存 </p></li><li><p>状态码了解哪些，301 和 302 区别 </p></li><li><p>option 方法知道吗 </p></li><li><p>排序算法，事件复杂度，归并，快排，堆排的应用场景 </p></li><li><p>CSRF 原理及防御 </p></li><li><p>ES6 用过哪些 </p></li><li><p>最近收获较大的一篇文章及收获 </p></li><li><p>设计消息通知，比如点赞，评论这些通知<br>二面面试官特别好，不会的地方都会跟你讲一下。最后一题不会说没关系，应届生系统设计和代码实践能力确实差一点，这一题是加分题。然后通知 10 分钟后三面</p></li></ul><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><ul><li>顺时针打印矩阵<br><a href="https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&amp;tqId=11172&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&amp;tqId=11172&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a><br>（如果没过肯定就是因为这题，面试官都快把答案说出来了我还是没做出来） </li><li>http 和 https 区别及建立连接的过程 </li><li>instanceof 原理（代码） </li><li>寻找二叉树中路径是否存在某条值等给定值的路径，看我算法比较差就让我说了思路 </li><li>自己写的爬虫里面的一些细节及如何处理反爬 </li><li>最有成就感的一件事</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;记录一下自己的第二次面试经历&quot;&gt;&lt;a href=&quot;#记录一下自己的第二次面试经历&quot; class=&quot;headerlink&quot; title=&quot;记录一下自己的第二次面试经历&quot;&gt;&lt;/a&gt;记录一下自己的第二次面试经历&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/img/loading
      
    
    </summary>
    
      <category term="前端面试题" scheme="http://www.bluedream.top/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试问题" scheme="http://www.bluedream.top/tags/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    
      <category term="面试经验" scheme="http://www.bluedream.top/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="字节跳动" scheme="http://www.bluedream.top/tags/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>前端通信</title>
    <link href="http://www.bluedream.top/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%89%8D%E7%AB%AF%E9%80%9A%E4%BF%A1.html"/>
    <id>http://www.bluedream.top/前端知识点/前端通信.html</id>
    <published>2019-09-10T13:51:01.000Z</published>
    <updated>2019-09-28T09:36:11.771Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>前端通信类的问题，主要包括以下内容</strong>：</p><p>什么是<strong>同源策略</strong>及限制</p><blockquote><p>同源策略是一个概念，就一句话。有什么限制，就三句话。能说出来即可。</p></blockquote><p><strong>前后端如何通信</strong></p><blockquote><p>如果你不准备，估计也就只能说出<code>ajax</code>。这个可以考察出知识面。</p></blockquote><p>如何创建<strong>Ajax</strong></p><blockquote><p><code>Ajax</code>在前后端通信中经常用到。做业务时，可以借助第三方的库，比如<code>vue</code>框架里的库、<code>jQuery</code>也有封装好的方法。但如果让你用原生的<code>js</code>去实现，该怎么做？</p></blockquote><p>这就是考察你的动手能力，以及框架原理的掌握。如果能写出来，可以体现出你的基本功。是加分项。</p><blockquote><p>在回答 <code>Ajax</code> 的问题时，要回答以下几个方面：</p></blockquote><ol><li><code>XMLHttpRequest</code> 的工作原理</li><li>兼容性处理</li></ol><blockquote><p><code>XMLHttpRequest</code>只有在高级浏览器中才支持。在回答问题时，这个兼容性问题不要忽略。</p></blockquote><ol start="3"><li>事件的触发条件</li><li>事件的触发顺序</li></ol><blockquote><p><code>XMLHttpRequest</code>有很多触发事件，每个事件是怎么触发的。</p></blockquote><p><strong>跨域通信</strong>的几种方式</p><blockquote><p>这部分非常重要。无非就是问你：什么是跨域、跨域有什么限制、<strong>跨域有几种方式</strong>。</p></blockquote><h2 id="1-同源策略的概念和具体限制"><a href="#1-同源策略的概念和具体限制" class="headerlink" title="1.同源策略的概念和具体限制"></a>1.同源策略的概念和具体限制</h2><h3 id="请解释一下-JavaScript-的同源策略"><a href="#请解释一下-JavaScript-的同源策略" class="headerlink" title="请解释一下 JavaScript 的同源策略"></a>请解释一下 JavaScript 的同源策略</h3><p><strong>同源策略</strong>是客户端脚本（尤其是 Javascript）的重要的安全度量标准。它最早出自 Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。</p><p>所谓<strong>同源</strong>指的是：协议，域名，端口相同，同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性。</p><blockquote><p><strong>同源策略</strong>：限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。（来自MDN官方的解释）</p></blockquote><p><strong>具体解释：</strong></p><ol><li><code>源</code>包括三个部分：协议、域名、端口（<code>http</code>协议的默认端口是<code>80</code>）。如果有任何一个部分不同，则<code>源</code>不同，那就是跨域了。</li><li><code>限制</code>：这个源的文档没有权利去操作另一个源的文档。这个限制体现在：（要记住）</li></ol><ul><li><code>Cookie</code>、<code>LocalStorage</code>和<code>IndexDB</code>无法获取。</li><li>无法获取和操作<code>DOM</code>。</li><li>不能发送<code>Ajax</code>请求。我们要注意，<code>Ajax</code>只适合<strong>同源</strong>的通信。</li></ul><h2 id="2-前后端如何通信"><a href="#2-前后端如何通信" class="headerlink" title="2. 前后端如何通信"></a>2. 前后端如何通信</h2><p><strong>主要有以下几种方式：</strong></p><ul><li><code>Ajax</code>：不支持跨域。</li><li><code>WebSocket</code>：不受同源策略的限制，支持跨域</li><li><code>CORS</code>：不受同源策略的限制，支持跨域。一种新的通信协议标准。可以理解成是：<strong>同时支持同源和跨域的Ajax</strong>。</li></ul><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><h3 id="什么是-Ajax"><a href="#什么是-Ajax" class="headerlink" title="什么是 Ajax"></a>什么是 Ajax</h3><p>Ajax 是全称是 asynchronous JavaScript and XML，即异步 JavaScript 和 xml，主要用来实现客户端与服务器异步数据交互，不用重载整个网页，实现页面局部刷新。</p><h3 id="ajax-的优点"><a href="#ajax-的优点" class="headerlink" title="ajax 的优点"></a>ajax 的优点</h3><ol><li>来自服务器的新内容可以动态更改，通过异步模式，无需重新加载整个页面，实现页面局部刷新</li><li>避免用户不断刷新或者跳转页面，提高用户体验</li><li>优化了浏览器和服务器之间的传输，降低数据传输量，减少不必要的数据往返，减少了带宽占用</li><li>Ajax 在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。</li></ol><h3 id="ajax-的缺点"><a href="#ajax-的缺点" class="headerlink" title="ajax 的缺点"></a>ajax 的缺点</h3><ol><li>ajax 不支持浏览器 back 按钮，要实现 ajax 下的前后退功能成本较大</li><li>可能造成请求数的增加跨域问题限制；</li><li>安全问题： AJAX 暴露了与服务器交互的细节。</li><li>对搜索引擎的支持比较弱。</li><li>破坏了程序的异常机制。</li></ol><h3 id="创建-ajax-过程"><a href="#创建-ajax-过程" class="headerlink" title="创建 ajax 过程"></a>创建 ajax 过程</h3><p>基本步骤 5步走：（创建对象、建立连接、发送数据、接收数据、局部刷新）</p><p>1.创建 XMLHttpRequest 对象,也就是创建一个异步调用对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var xhr=new XMLHttpRequest() //创建对象</span><br></pre></td></tr></table></figure><p>2.创建一个新的 HTTP 请求,并指定该 HTTP 请求的方法、URL 及验证信息，跟服务器建立一个连接，设置响应 HTTP 请求状态变化的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(&quot;type 提交方式&quot;, &quot;url  提交的地址&quot;)</span><br><span class="line"></span><br><span class="line">如果是post请求，需要设置请求头</span><br><span class="line"></span><br><span class="line">xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);</span><br></pre></td></tr></table></figure><p>3.我要发送数据给服务器（发送 HTTP 请求）</p><p>​    如果是get 请求，请求的数据在地址的后面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.send() //发送数据，这一步不能省略</span><br></pre></td></tr></table></figure><p>4.获取异步调用服务器返回的数据<br>        服务端返回数据会调用一个回调函数，通过回调函数去接收数据.   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xhr.onreadystatechange=function()&#123;</span><br><span class="line">            if(xhr.readyState==4)&#123; 响应完成了</span><br><span class="line">                    if(xhr.status==200)&#123; //响应成功了</span><br><span class="line">                          responseText 属性接收服务端返回的数据.</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>5.使用 JavaScript 和 DOM 实现局部刷新</p><h3 id="创建-ajax-步骤："><a href="#创建-ajax-步骤：" class="headerlink" title="创建 ajax 步骤："></a>创建 <code>ajax</code> 步骤：</h3><ul><li>1.创建 <code>XMLHttpRequest</code> 对象</li><li>2.创建一个新的 <code>HTTP</code> 请求，并指定该 <code>HTTP</code> 请求的类型、验证信息</li><li>3.设置响应 <code>HTTP</code> 请求状态变化的回调函数</li><li>4.发送 <code>HTTP</code> 请求</li><li>5.获取异步调用返回的数据</li><li>6.使用 <code>JavaScript</code> 和 <code>DOM</code> 实现局部刷新</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">"POST"</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; (xhr.status == <span class="number">200</span> || xhr.status == <span class="number">304</span>)) &#123;</span><br><span class="line">        fn.call(<span class="keyword">this</span>, xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.send(data);</span><br></pre></td></tr></table></figure><h3 id="Ajax-实现的原理"><a href="#Ajax-实现的原理" class="headerlink" title="Ajax 实现的原理"></a>Ajax 实现的原理</h3><p>浏览器提供的 XMLHttpRequest 对象</p><h3 id="ajax-如何实现，readyState-的五种状态的含义？"><a href="#ajax-如何实现，readyState-的五种状态的含义？" class="headerlink" title="ajax 如何实现，readyState 的五种状态的含义？"></a>ajax 如何实现，readyState 的五种状态的含义？</h3><ul><li>0 － （未初始化）还没有调用 send()方法</li><li>1 － （载入）已调用 send()方法，正在发送请求</li><li>2 － （载入完成）send()方法执行完成，已经接收到全部响应内容</li><li>3 － （交互）正在解析响应内容</li><li>4 － （完成）响应内容解析完成，可以在客户端调用了</li></ul><p>解析：</p><p>(0)未初始化</p><p>此阶段确认 XMLHttpRequest 对象是否创建，并为调用 open()方法进行未初始化作好准备。值为 0 表示对象已经存在，否则浏览器会报错－－对象不存在。</p><p>(1)载入</p><p>此阶段对 XMLHttpRequest 对象进行初始化，即调用 open()方法，根据参数(method,url,true)完成对象状态的设置。并调用 send()方法开始向服务端发送请求。值为 1 表示正在向服务端发送请求。</p><p>(2)载入完成</p><p>此阶段接收服务器端的响应数据。但获得的还只是服务端响应的原始数据，并不能直接在客户端使用。值为 2 表示已经接收完全部响应数据。并为下一阶段对数据解析作好准备。</p><p>(3)交互</p><p>此阶段解析接收到的服务器端响应数据。即根据服务器端响应头部返回的 MIME 类型把数据转换成能通过 responseBody、responseText 或 responseXML 属性存取的格式，为在客户端调用作好准备。状态 3 表示正在解析数据。</p><p>(4)完成</p><p>此阶段确认全部数据都已经解析为客户端可用的格式，解析已经完成。值为 4 表示数据解析完毕，可以通过 XMLHttpRequest 对象的相应属性取得数据。</p><p><a href="https://blog.csdn.net/u011565547/article/details/78979030" target="_blank" rel="noopener">参考</a></p><h3 id="GET-和-POST-的区别，何时使用-POST？"><a href="#GET-和-POST-的区别，何时使用-POST？" class="headerlink" title="GET 和 POST 的区别，何时使用 POST？"></a>GET 和 POST 的区别，何时使用 POST？</h3><p><strong>GET：</strong></p><ul><li>一般用于信息获取，使用 URL 传递参数，对所发送信息的数量也有限制，一般在 2000 个字符，有的浏览器是 8000 个字符；</li><li>请求的参数都暴露在 url 地址当中，如果传递中文参数，需要自己进行编码操作，安全性较低。</li></ul><p><strong>POST：</strong></p><ul><li>一般用于提交数据和修改服务器上的资源，对所发送的信息没有限制</li><li>提交的数据内容存在于 http 请求体中，数据不会暴漏在 url 地址中。</li></ul><p><strong>在以下情况中，请使用 POST 请求：</strong></p><ol><li>无法使用缓存文件（更新服务器上的文件或数据库）</li><li>向服务器发送大量数据（POST 没有数据量限制）</li><li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li></ol><h3 id="ajax-请求时，如何解析-json-数据"><a href="#ajax-请求时，如何解析-json-数据" class="headerlink" title="ajax 请求时，如何解析 json 数据"></a>ajax 请求时，如何解析 json 数据</h3><p>使用 eval() 或者 JSON.parse() 鉴于安全性考虑，推荐使用 JSON.parse()更靠谱，对数据的安全性更好。</p><h3 id="ajax-加载的页面，跳转到另外一个页面再跳转回来，内容相同，如何节约读取请求"><a href="#ajax-加载的页面，跳转到另外一个页面再跳转回来，内容相同，如何节约读取请求" class="headerlink" title="ajax 加载的页面，跳转到另外一个页面再跳转回来，内容相同，如何节约读取请求?"></a>ajax 加载的页面，跳转到另外一个页面再跳转回来，内容相同，如何节约读取请求?</h3><p>后台做缓存，读取缓存里面的数据。CDN</p><h3 id="发送-get-请求和-post-请求"><a href="#发送-get-请求和-post-请求" class="headerlink" title="发送 get 请求和 post 请求"></a>发送 get 请求和 post 请求</h3><blockquote><p><code>get</code>请求举例：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Ajax 发送 get 请求<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"发送get_ajax请求"</span> <span class="attr">id</span>=<span class="string">'btnAjax'</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 绑定点击事件</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.querySelector(<span class="string">'#btnAjax'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 发送ajax 请求 需要 五步</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">// （1）创建异步对象</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> ajaxObj = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">// （2）设置请求的参数。包括：请求的方法、请求的url。</span></span></span><br><span class="line"><span class="actionscript">        ajaxObj.open(<span class="string">'get'</span>, <span class="string">'02-ajax.php'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">// （3）发送请求</span></span></span><br><span class="line">        ajaxObj.send();</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">//（4）注册事件。 onreadystatechange事件，状态改变时就会调用。</span></span></span><br><span class="line"><span class="actionscript">        <span class="comment">//如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。</span></span></span><br><span class="line"><span class="actionscript">        ajaxObj.onreadystatechange = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 为了保证 数据 完整返回，我们一般会判断 两个值</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (ajaxObj.readyState == <span class="number">4</span> &amp;&amp; ajaxObj.status == <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的</span></span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 5.在注册的事件中 获取 返回的 内容 并修改页面的显示</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">'数据返回成功'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">                <span class="comment">// 数据是保存在 异步对象的 属性中</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(ajaxObj.responseText);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">                <span class="comment">// 修改页面的显示</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.querySelector(<span class="string">'h1'</span>).innerHTML = ajaxObj.responseText;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>post</code> 请求举例：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Ajax 发送 get 请求<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"发送put_ajax请求"</span> <span class="attr">id</span>=<span class="string">'btnAjax'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 异步对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 设置属性</span></span></span><br><span class="line"><span class="actionscript">    xhr.open(<span class="string">'post'</span>, <span class="string">'02.post.php'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 如果想要使用post提交数据,必须添加此行</span></span></span><br><span class="line"><span class="actionscript">    xhr.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 将数据通过send方法传递</span></span></span><br><span class="line"><span class="actionscript">    xhr.send(<span class="string">'name=fox&amp;age=18'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 发送并接受返回值</span></span></span><br><span class="line"><span class="actionscript">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 这步为判断服务器是否正确响应</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span></span><br><span class="line">            alert(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="onreadystatechange-事件"><a href="#onreadystatechange-事件" class="headerlink" title="onreadystatechange 事件"></a>onreadystatechange 事件</h3><blockquote><p>注册 <code>onreadystatechange</code> 事件后，每当 <code>readyState</code> 属性改变时，就会调用 <code>onreadystatechange</code> 函数。</p></blockquote><blockquote><p><code>readyState</code>：（存有 <code>XMLHttpRequest</code> 的状态。从 <code>0</code> 到 <code>4</code> 发生变化）</p></blockquote><ul><li><code>0</code>: 请求未初始化</li><li><code>1</code>: 服务器连接已建立</li><li><code>2</code>: 请求已接收</li><li><code>3</code>: 请求处理中</li><li><code>4</code>: 请求已完成，且响应已就绪</li></ul><h3 id="事件的触发条件"><a href="#事件的触发条件" class="headerlink" title="事件的触发条件"></a>事件的触发条件</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="http://img.smyhvae.com/20180307_1443.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="事件的触发顺序"><a href="#事件的触发顺序" class="headerlink" title="事件的触发顺序"></a>事件的触发顺序</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="http://img.smyhvae.com/20180307_1445.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="实际开发中用的-原生Ajax请求"><a href="#实际开发中用的-原生Ajax请求" class="headerlink" title="实际开发中用的 原生Ajax请求"></a>实际开发中用的 原生Ajax请求</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> util = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取 ajax 请求之后的json</span></span><br><span class="line">util.json = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> opt = &#123;</span><br><span class="line">        url: <span class="string">''</span>,</span><br><span class="line">        type: <span class="string">'get'</span>,</span><br><span class="line">        data: &#123;&#125;,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        &#125;,</span><br><span class="line">        error: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    util.extend(opt, options);</span><br><span class="line">    <span class="keyword">if</span> (opt.url) &#123;</span><br><span class="line">        <span class="comment">//IE兼容性处理：浏览器特征检查。检查该浏览器是否存在XMLHttpRequest这个api，没有的话，就用IE的api</span></span><br><span class="line">        <span class="keyword">var</span> xhr = XMLHttpRequest ? <span class="keyword">new</span> XMLHttpRequest() : <span class="keyword">new</span> <span class="built_in">window</span>.ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> data = opt.data,</span><br><span class="line">            url = opt.url,</span><br><span class="line">            type = opt.type.toUpperCase();</span><br><span class="line">        dataArr = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">        dataArr.push(key + <span class="string">'='</span> + data[key]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">'GET'</span>) &#123;</span><br><span class="line">        url = url + <span class="string">'?'</span> + dataArr.join(<span class="string">'&amp;'</span>);</span><br><span class="line">        xhr.open(type, url.replace(<span class="regexp">/\?$/g</span>, <span class="string">''</span>), <span class="literal">true</span>);</span><br><span class="line">        xhr.send();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">'POST'</span>) &#123;</span><br><span class="line">        xhr.open(type, url, <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 如果想要使用post提交数据,必须添加此行</span></span><br><span class="line">        xhr.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">        xhr.send(dataArr.join(<span class="string">'&amp;'</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.status === <span class="number">200</span> || xhr.status === <span class="number">304</span>) &#123; <span class="comment">//304表示：用缓存即可。206表示获取媒体资源的前面一部分</span></span><br><span class="line">            <span class="keyword">var</span> res;</span><br><span class="line">            <span class="keyword">if</span> (opt.success &amp;&amp; opt.success <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">                res = xhr.responseText;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> res === <span class="string">'string'</span>) &#123;</span><br><span class="line">                    res = <span class="built_in">JSON</span>.parse(res);  <span class="comment">//将字符串转成json</span></span><br><span class="line">                    opt.success.call(xhr, res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (opt.error &amp;&amp; opt.error <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">                opt.error.call(xhr, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-json"><a href="#4-json" class="headerlink" title="4.json"></a>4.json</h2><h3 id="什么是-json"><a href="#什么是-json" class="headerlink" title="什么是 json"></a>什么是 json</h3><ul><li>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式</li><li>它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小</li><li>JSON字符串转换为JSON对象:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj =eval(&apos;(&apos;+ str +&apos;)&apos;);</span><br><span class="line">var obj = str.parseJSON();</span><br><span class="line">var obj = JSON.parse(str);</span><br></pre></td></tr></table></figure><ul><li>JSON对象转换为JSON字符串：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var last=obj.toJSONString();</span><br><span class="line">var last=JSON.stringify(obj);</span><br></pre></td></tr></table></figure><h3 id="json优点"><a href="#json优点" class="headerlink" title="json优点:"></a>json优点:</h3><ol><li>数据格式比较简单，易于读写，支持复合数据类型（数组、对象、字符串、数字）</li><li>轻量级，格式都是压缩的，占用带宽小</li><li>便于机器（JavaScript）解析, 客户端 javascript 可以简单的通过 eval()进行 JSON 数据的读取搜索</li><li>支持多种语言, 包括 ActionScript, C, C#, ColdFusion, Java, JavaScript, Perl, php, Python, Ruby 等语言服务器端语言, 便于服务器端的解析</li><li>在 PHP 世界, 已经有 PHP-JSON 和 JSON-PHP 出现了, 便于 PHP 序列化后的程序直接调用. PHP 服务器端的对象、数组等能够直接生 JSON 格式, 便于客户端的访问提取. 另外 PHP 的 PEAR 类已经提出了支持 (<a href="http://pear.php.net/pepr/pepr-proposal-show.php?id=198" target="_blank" rel="noopener">http://pear.php.net/pepr/pepr-proposal-show.php?id=198</a>)</li><li>因为 JSON 格式能够直接为服务器端代码使用, 大大简化了服务器端和客户端的代码开发量, 但是完成的任务不变, 且易于维护</li></ol><h3 id="json缺点"><a href="#json缺点" class="headerlink" title="json缺点:"></a>json缺点:</h3><ol><li>没有 XML 格式这么推广的深入人心和使用广泛, 没有 XML 那么通用性</li><li>JSON 格式目前在 Web Service 中推广还属于初级阶段 PS: 据说 Google 的 Ajax 是使用 JSON+模板 做的</li></ol><h3 id="XML和JSON的区别？"><a href="#XML和JSON的区别？" class="headerlink" title="XML和JSON的区别？"></a>XML和JSON的区别？</h3><ul><li>数据体积方面<ul><li>JSON相对于XML来讲，数据的体积小，传递的速度更快些。</li></ul></li><li>数据交互方面<ul><li>JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互</li></ul></li><li>数据描述方面<ul><li>JSON对数据的描述性比XML较差</li></ul></li><li>传输速度方面<ul><li>JSON的速度要远远快于XML</li></ul></li></ul><h2 id="5-跨域"><a href="#5-跨域" class="headerlink" title="5.跨域"></a>5.跨域</h2><h3 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="headerlink" title="如何解决跨域问题?"></a>如何解决跨域问题?</h3><ol><li>jsonp ，允许 script 加载第三方资源</li><li>反向代理（nginx 服务内部配置 Access-Control-Allow-Origin *）</li><li>cors 前后端协作设置请求头部，Access-Control-Allow-Origin 等头部信息</li><li>iframe 嵌套通讯，postmessage</li></ol><p>解析：</p><p>理解跨域的概念：协议、域名、端口都相同才同域，否则都是跨域</p><p><a href="https://zhuanlan.zhihu.com/p/41479807" target="_blank" rel="noopener">参考</a><br><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 阮一峰</a></p><h3 id="跨域通信的几种方式"><a href="#跨域通信的几种方式" class="headerlink" title="跨域通信的几种方式"></a>跨域通信的几种方式</h3><blockquote><p>方式如下：</p></blockquote><ol><li><code>JSONP</code></li><li><code>WebSocket</code></li><li><code>CORS</code></li><li><code>Hash</code></li><li><code>postMessage</code></li></ol><blockquote><p>上面这五种方式，在面试时，都要说出来。</p></blockquote><h3 id="5-1-JSONP"><a href="#5-1-JSONP" class="headerlink" title="5.1 JSONP"></a>5.1 JSONP</h3><blockquote><p>面试会问：<code>JSONP</code>的原理是什么？怎么实现的？</p></blockquote><ul><li>在<code>CORS</code>和<code>postMessage</code>以前，我们一直都是通过<code>JSONP</code>来做跨域通信的。</li></ul><blockquote><p><strong>JSONP的原理</strong>：通过<code>&lt;script&gt;</code>标签的异步加载来实现的。比如说，实际开发中，我们发现，<code>head</code>标签里，可以通过<code>&lt;script&gt;</code>标签的<code>src</code>，里面放<code>url</code>，加载很多在线的插件。这就是用到了<code>JSONP</code>。</p></blockquote><p><strong>JSONP的实现：</strong></p><blockquote><p>比如说，客户端这样写：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://www.smyhvae.com/?data=name&amp;callback=myjsonp"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的<code>src</code>中，<code>data=name</code>是get请求的参数，<code>myjsonp</code>是和后台约定好的函数名。<br>服务器端这样写：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myjsonp(&#123;</span><br><span class="line">    data: &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>于是，本地要求创建一个<code>myjsonp</code> 的<strong>全局函数</strong>，才能将返回的数据执行出来。</p></blockquote><p><strong>实际开发中，前端的JSONP是这样实现的：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> util = &#123;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">//定义方法：动态创建 script 标签</span></span></span><br><span class="line">    /**</span><br><span class="line"><span class="javascript">     * [<span class="function"><span class="keyword">function</span> 在页面中注入<span class="title">js</span>脚本]</span></span></span><br><span class="line">     * @param  &#123;[type]&#125; url     [description]</span><br><span class="line">     * @param  &#123;[type]&#125; charset [description]</span><br><span class="line"><span class="actionscript">     * @<span class="keyword">return</span> &#123;[type]&#125;         [description]</span></span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    util.createScript = <span class="function"><span class="keyword">function</span> <span class="params">(url, charset)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></span><br><span class="line"><span class="actionscript">        script.setAttribute(<span class="string">'type'</span>, <span class="string">'text/javascript'</span>);</span></span><br><span class="line"><span class="actionscript">        charset &amp;&amp; script.setAttribute(<span class="string">'charset'</span>, charset);</span></span><br><span class="line"><span class="actionscript">        script.setAttribute(<span class="string">'src'</span>, url);</span></span><br><span class="line"><span class="actionscript">        script.async = <span class="literal">true</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> script;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line"><span class="javascript">     * [<span class="function"><span class="keyword">function</span> 处理<span class="title">jsonp</span>]</span></span></span><br><span class="line">     * @param  &#123;[type]&#125; url      [description]</span><br><span class="line">     * @param  &#123;[type]&#125; onsucess [description]</span><br><span class="line">     * @param  &#123;[type]&#125; onerror  [description]</span><br><span class="line">     * @param  &#123;[type]&#125; charset  [description]</span><br><span class="line"><span class="actionscript">     * @<span class="keyword">return</span> &#123;[type]&#125;          [description]</span></span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    util.jsonp = <span class="function"><span class="keyword">function</span> <span class="params">(url, onsuccess, onerror, charset)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> callbackName = util.getName(<span class="string">'tt_player'</span>); <span class="comment">//事先约定好的 函数名</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>[callbackName] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;      <span class="comment">//根据回调名称注册一个全局的函数</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (onsuccess &amp;&amp; util.isFunction(onsuccess)) &#123;</span></span><br><span class="line"><span class="javascript">                onsuccess(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> script = util.createScript(url + <span class="string">'&amp;callback='</span> + callbackName, charset);   <span class="comment">//动态创建一个script标签</span></span></span><br><span class="line"><span class="actionscript">        script.onload = script.onreadystatechange = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;   <span class="comment">//监听加载成功的事件，获取数据</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (!script.readyState || <span class="regexp">/loaded|complete/</span>.test(script.readyState)) &#123;</span></span><br><span class="line"><span class="actionscript">                script.onload = script.onreadystatechange = <span class="literal">null</span>;</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 移除该script的 DOM 对象</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">if</span> (script.parentNode) &#123;</span></span><br><span class="line">                    script.parentNode.removeChild(script);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="actionscript">                <span class="comment">// 删除函数或变量</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">window</span>[callbackName] = <span class="literal">null</span>;  <span class="comment">//最后不要忘了删除</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="actionscript">        script.onerror = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (onerror &amp;&amp; util.isFunction(onerror)) &#123;</span></span><br><span class="line">                onerror();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(script); <span class="comment">//往html中增加这个标签，目的是把请求发送出去</span></span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-2-WebSocket"><a href="#5-2-WebSocket" class="headerlink" title="5.2 WebSocket"></a>5.2 WebSocket</h3><blockquote><p><code>WebSocket</code>的用法如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'wss://echo.websocket.org'</span>); <span class="comment">//创建WebSocket的对象。参数可以是 ws 或 wss，后者表示加密。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把请求发出去</span></span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Connection open ...'</span>);</span><br><span class="line">    ws.send(<span class="string">'Hello WebSockets!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对方发消息过来时，我接收</span></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Received Message: '</span>, evt.data);</span><br><span class="line">    ws.close();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭连接</span></span><br><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Connection closed.'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>面试一般不会让你写这个代码，一般是考察你是否了解 <code>WebSocket</code>概念，知道有这么回事即可。</p></blockquote><h3 id="5-3-CORS"><a href="#5-3-CORS" class="headerlink" title="5.3 CORS"></a>5.3 CORS</h3><blockquote><p><code>CORS</code> 可以理解成是<strong>既可以同步、也可以异步</strong>的Ajax。</p></blockquote><ul><li>fetch<code>是一个比较新的</code>API<code>，用来实现</code>CORS`通信。用法如下：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// url（必选），options（可选）</span></span><br><span class="line">fetch(<span class="string">'/some/url/'</span>, &#123;</span><br><span class="line">    method: <span class="string">'get'</span>,</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;  <span class="comment">//类似于 ES6中的promise</span></span><br><span class="line"></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 出错了，等价于 then 的第二个参数，但这样更好用更直观</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>另外，如果面试官问：“CORS为什么支持跨域的通信？”</p></blockquote><blockquote><p>答案：跨域时，浏览器会拦截<code>Ajax</code>请求，并在<code>http</code>头中加<code>Origin</code>。</p></blockquote><h3 id="5-4-Hash"><a href="#5-4-Hash" class="headerlink" title="5.4 Hash"></a>5.4 Hash</h3><ul><li><code>url</code>的<code>#</code>后面的内容就叫<code>Hash</code>。<strong>Hash的改变，页面不会刷新</strong>。这就是用 <code>Hash</code> 做跨域通信的基本原理。</li></ul><blockquote><p>补充：<code>url</code>的<code>?</code>后面的内容叫<code>Search</code>。<code>Search</code>的改变，会导致页面刷新，因此不能做跨域通信。</p></blockquote><p><strong>使用举例：</strong></p><p><strong>场景</strong>：我的页面 <code>A</code> 通过<code>iframe</code>或<code>frame</code>嵌入了跨域的页面 <code>B</code>。</p><blockquote><p>现在，我这个<code>A</code>页面想给<code>B</code>页面发消息，怎么操作呢？</p></blockquote><ol><li>首先，在我的<code>A</code>页面中：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="keyword">var</span> B = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'iframe'</span>);</span><br><span class="line">B.src = B.src + <span class="string">'#'</span> + <span class="string">'jsonString'</span>;  <span class="comment">//我们可以把JS 对象，通过 JSON.stringify()方法转成 json字符串，发给 B</span></span><br></pre></td></tr></table></figure><ol start="2"><li>然后，在<code>B</code>页面中：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// B中的伪代码</span></span><br><span class="line"><span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="comment">//通过onhashchange方法监听，url中的 hash 是否发生变化</span></span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">window</span>.location.hash;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-5-postMessage-方法"><a href="#5-5-postMessage-方法" class="headerlink" title="5.5 postMessage()方法"></a>5.5 postMessage()方法</h3><blockquote><p><code>H5</code>中新增的`postMessage()``方法，可以用来做跨域通信。既然是H5中新增的，那就一定要提到。</p></blockquote><p><strong>场景</strong>：窗口 A (<code>http:A.com</code>)向跨域的窗口 B (<code>http:B.com</code>)发送信息。步骤如下</p><ol><li>在<code>A</code>窗口中操作如下：向<code>B</code>窗口发送数据：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息</span></span><br><span class="line">Bwindow.postMessage(<span class="string">'data'</span>, <span class="string">'http://B.com'</span>); <span class="comment">//这里强调的是B窗口里的window对象</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在<code>B</code>窗口中操作如下：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在窗口B中监听 message 事件</span></span><br><span class="line">Awindow.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;   <span class="comment">//这里强调的是A窗口里的window对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.origin);  <span class="comment">//获取 ：url。这里指：http://A.com</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.source);  <span class="comment">//获取：A window对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.data);    <span class="comment">//获取传过来的数据</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h3 id="如何解决跨域问题-1"><a href="#如何解决跨域问题-1" class="headerlink" title="如何解决跨域问题"></a>如何解决跨域问题</h3><h6 id="JSONP："><a href="#JSONP：" class="headerlink" title="JSONP："></a><strong>JSONP：</strong></h6><ul><li>原理是：动态插入<code>script</code>标签，通过<code>script</code>标签引入一个<code>js</code>文件，这个<code>js</code>文件载入成功后会执行我们在<code>url</code>参数中指定的函数，并且会把我们需要的<code>json</code>数据作为参数传入</li><li>由于同源策略的限制，<code>XmlHttpRequest</code>只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过<code>script</code>标签实现跨域请求，然后在服务端输出<code>JSON</code>数据并执行回调函数，从而解决了跨域的数据请求</li><li>优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求</li><li><code>JSONP</code>：<code>json+padding</code>（内填充），顾名思义，就是把<code>JSON</code>填充到一个盒子里</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createJs</span>(<span class="params">sUrl</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> oScript = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    oScript.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">    oScript.src = sUrl;</span><br><span class="line">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(oScript);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createJs(<span class="string">'jsonp.js'</span>);</span><br><span class="line"></span><br><span class="line">box(&#123;</span><br><span class="line">   <span class="string">'name'</span>: <span class="string">'test'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">box</span>(<span class="params">json</span>)</span>&#123;</span><br><span class="line">    alert(json.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CORS</strong></p><ul><li>服务器端对于<code>CORS</code>的支持，主要就是通过设置<code>Access-Control-Allow-Origin</code>来进行的。如果浏览器检测到相应的设置，就可以允许<code>Ajax</code>进行跨域的访问</li></ul><p><strong>通过修改document.domain来跨子域</strong></p><ul><li>将子域和主域的<code>document.domain</code>设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用<code>document.domain</code>进行跨域。主域相同的使用<code>document.domain</code></li></ul><p><strong>使用window.name来进行跨域</strong></p><ul><li><code>window</code>对象有个name属性，该属性有个特征：即在一个窗口(<code>window</code>)的生命周期内,窗口载入的所有的页面都是共享一个<code>window.name</code>的，每个页面对window.name都有读写的权限，<code>window.name</code>是持久存在一个窗口载入过的所有页面中的</li></ul><p><strong>使用HTML5中新引进的window.postMessage方法来跨域传送数据</strong></p><ul><li>还有<code>flash</code>、在服务器上设置代理页面等跨域方式。个人认为<code>window.name</code>的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法</li></ul><p><strong>如何解决跨域问题?</strong></p><ul><li><code>jsonp</code>、 <code>iframe</code>、<code>window.name</code>、<code>window.postMessage</code>、服务器上设置代理页面</li><li>如何解决跨域问题?<ul><li><code>document.domain + iframe</code>：要求主域名相同 //只能跨子域</li><li><code>JSONP(JSON with Padding)``：</code>response: callback(data)`` //只支持 GET 请求</li><li>跨域资源共享<code>CORS(XHR2)``：</code>Access-Control-Allow` //兼容性 IE10+</li><li>跨文档消息传输(HTML5)：<code>postMessage + onmessage</code>  //兼容性 IE8+</li><li><code>WebSocket(HTML5)：new WebSocket(url) + onmessage</code> //兼容性 IE10+</li><li>服务器端设置代理请求：服务器端不受同源策略限制</li></ul></li></ul><h3 id="5-1-跨域"><a href="#5-1-跨域" class="headerlink" title="5.1 跨域"></a>5.1 跨域</h3><blockquote><p>很多种方法，但万变不离其宗，都是为了搞定同源策略。重用的有 <code>jsonp</code>、<code>iframe</code>、<code>cors</code>、<code>img</code>、H<code>TML5 postMessage</code>等等。其中用到 <code>html</code> 标签进行跨域的原理就是 <code>html</code> 不受同源策略影响。但只是接受 <code>Get</code> 的请求方式，这个得清楚。</p></blockquote><blockquote><p><strong>延伸1：img iframe script 来发送跨域请求有什么优缺点？</strong></p></blockquote><p><strong>1. <code>iframe</code></strong></p><ul><li>优点：跨域完毕之后<code>DOM</code>操作和互相之间的<code>JavaScript</code>调用都是没有问题的</li><li>缺点：1.若结果要以<code>URL</code>参数传递，这就意味着在结果数据量很大的时候需要分割传递，巨烦。2.还有一个是<code>iframe</code>本身带来的，母页面和<code>iframe</code>本身的交互本身就有安全性限制。</li></ul><p><strong>2. script</strong></p><ul><li>优点：可以直接返回<code>json</code>格式的数据，方便处理</li><li>缺点：只接受<code>GET</code>请求方式</li></ul><p><strong>3. 图片ping</strong></p><ul><li>优点：可以访问任何<code>url</code>，一般用来进行点击追踪，做页面分析常用的方法</li><li>缺点：不能访问响应文本，只能监听是否响应</li></ul><blockquote><p><strong>延伸2：配合 webpack 进行反向代理？</strong></p></blockquote><p><code>webpack</code> 在 <code>devServer</code> 选项里面提供了一个 <code>proxy</code> 的参数供开发人员进行反向代理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'/api'</span>: &#123;</span><br><span class="line">  target: <span class="string">'http://www.example.com'</span>, <span class="comment">// your target host</span></span><br><span class="line">  changeOrigin: <span class="literal">true</span>, <span class="comment">// needed for virtual hosted sites</span></span><br><span class="line">  pathRewrite: &#123;</span><br><span class="line">    <span class="string">'^/api'</span>: <span class="string">''</span>  <span class="comment">// rewrite path</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><blockquote><p>然后再配合 <code>http-proxy-middleware</code> 插件对 <code>api</code> 请求地址进行代理</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">'http-proxy-middleware'</span>);</span><br><span class="line"><span class="comment">// proxy api requests</span></span><br><span class="line"><span class="keyword">const</span> exampleProxy = proxy(options); <span class="comment">// 这里的 options 就是 webpack 里面的 proxy 选项对应的每个选项</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mount `exampleProxy` in web server</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(<span class="string">'/api'</span>, exampleProxy);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><blockquote><p>然后再用 <code>nginx</code> 把允许跨域的源地址添加到报头里面即可</p></blockquote><blockquote><p>说到 <code>nginx</code> ，可以再谈谈 <code>CORS</code> 配置，大致如下</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  <span class="keyword">if</span> ($request_method = <span class="string">'OPTIONS'</span>) &#123;</span><br><span class="line">    add_header <span class="string">'Access-Control-Allow-Origin'</span> <span class="string">'*'</span>;  </span><br><span class="line">    add_header <span class="string">'Access-Control-Allow-Methods'</span> <span class="string">'GET, POST, OPTIONS'</span>; </span><br><span class="line">    add_header <span class="string">'Access-Control-Allow-Credentials'</span> <span class="string">'true'</span>;</span><br><span class="line">    add_header <span class="string">'Access-Control-Allow-Headers'</span> <span class="string">'DNT, X-Mx-ReqToken, Keep-Alive, User-Agent, X-Requested-With, If-Modified-Since, Cache-Control, Content-Type'</span>;  </span><br><span class="line">    add_header <span class="string">'Access-Control-Max-Age'</span> <span class="number">86400</span>;  </span><br><span class="line">    add_header <span class="string">'Content-Type'</span> <span class="string">'text/plain charset=UTF-8'</span>;  </span><br><span class="line">    add_header <span class="string">'Content-Length'</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">200</span>;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解释-jsonp-的原理，以及为什么不是真正的-ajax-以及优缺点"><a href="#解释-jsonp-的原理，以及为什么不是真正的-ajax-以及优缺点" class="headerlink" title="解释 jsonp 的原理，以及为什么不是真正的 ajax, 以及优缺点"></a>解释 jsonp 的原理，以及为什么不是真正的 ajax, 以及优缺点</h3><p>jsonp 是用来解决跨域获取数据的一种解决方案，具体是通过动态创建 script 标签，然后通过标签的 src 属性获取 js 文件中的 js 脚本，该脚本的内容是一个函数调用，参数就是服务器返回的数据，为了处理这些返回的数据，需要事先在页面定义好回调函数，本质上使用的并不是 ajax 技术</p><p><strong>jsonp 优点:</strong></p><ul><li>完美解决在测试或者开发中获取不同域下的数据,用户传递一个 callback 参数给服务端，然后服务端返回数据时会将这个 callback 参数作为函数名来包裹住 JSON 数据，这样客户端就可以随意定制自己的函数来自动处理<strong>返回数据了。简单来说数据的格式没有发生很大变化</strong></li></ul><p><strong>jsonp 缺点:</strong></p><ul><li>jsonp 只支持 get 请求而不支持 post 请求,也即是说如果想传给后台一个 json 格式的数据,此时问题就来了,浏览器会报一个 http 状态码 415 错误,告诉你请求格式不正确,这让我很蛋疼(在登录注册中需要给后台传一大串数据),如果都用参数的形式拼接在 url 后面的话不太现实,后台取值也会显得繁琐,</li><li>在登录模块中需要用到 session 来判断当前用户的登录状态,这时候由于是跨域的原因,前后台的取到的 session 是不一样的,那么就不能就行 session 来判断.</li><li>由于 jsonp 存在安全性问题(不知 qq 空间的跨域是怎么解决的,还是另有高招?)，后来考虑到上面的一系列问题,采用的是后台进行设置允许跨域请求(但还是存在缺陷的,实质上还是跨域,如上面说的 session 问题).Header set Access-Control-Allow-Origin *为了防止 XSS 攻击我们的服务器， 我们可以限制域，比如 Access-Control-Allow-Origin: <a href="http://blog.csdn.net" target="_blank" rel="noopener">http://blog.csdn.net</a></li></ul><h2 id="6-其他"><a href="#6-其他" class="headerlink" title="6.其他"></a>6.其他</h2><h3 id="同步和异步的区别"><a href="#同步和异步的区别" class="headerlink" title="同步和异步的区别?"></a>同步和异步的区别?</h3><p><strong>同步：阻塞的</strong></p><p>-张三叫李四去吃饭，李四一直忙得不停，张三一直等着，直到李四忙完两个人一块去吃饭</p><p>=浏览器向服务器请求数据，服务器比较忙，浏览器一直等着（页面白屏），直到服务器返回数据，浏览器才能显示页面</p><p><strong>异步：非阻塞的</strong></p><p>-张三叫李四去吃饭，李四在忙，张三说了一声然后自己就去吃饭了，李四忙完后自己去吃</p><p>=浏览器向服务器请求数据，服务器比较忙，浏览器可以自如的干原来的事情（显示页面），服务器返回数据的时候通知浏览器一声，浏览器把返回的数据再渲染到页面，局部更新</p><h3 id="异步加载和延迟加载"><a href="#异步加载和延迟加载" class="headerlink" title="异步加载和延迟加载"></a>异步加载和延迟加载</h3><p>1.异步加载的方案： 动态插入 script 标签</p><p>2.通过 ajax 去获取 js 代码，然后通过 eval 执行</p><p>3.script 标签上添加 defer 或者 async 属性</p><p>4.创建并插入 iframe，让它异步执行 js</p><p>5.延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的。</p><h3 id="一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？"><a href="#一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？" class="headerlink" title="一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？"></a>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</h3><p>1.浏览器地址栏输入 url</p><p>2.浏览器会先查看浏览器缓存–系统缓存–路由缓存，如有存在缓存，就直接显示。如果没有，接着第三步</p><p>3.域名解析（DNS）获取相应的 ip</p><p>4.浏览器向服务器发起 tcp 连接，与浏览器建立 tcp 三次握手</p><p>5.握手成功，浏览器向服务器发送 http 请求，请求数据包</p><p>6.服务器请求数据，将数据返回到浏览器</p><p>7.浏览器接收响应，读取页面内容，解析 html 源码，生成 DOm 树</p><p>8.解析 css 样式.浏览器渲染，js 交互绑定多个域名，数量不限；</p><h3 id="页面编码和被请求的资源编码如果不一致如何处理？"><a href="#页面编码和被请求的资源编码如果不一致如何处理？" class="headerlink" title="页面编码和被请求的资源编码如果不一致如何处理？"></a>页面编码和被请求的资源编码如果不一致如何处理？</h3><p>答案：get 请求中的中文需要 encodeURIComponent 编码处理，post 请求不需要进行编码</p><h3 id="Ajax-和-Fetch-区别"><a href="#Ajax-和-Fetch-区别" class="headerlink" title="Ajax 和 Fetch 区别"></a>Ajax 和 Fetch 区别</h3><ul><li>ajax 是使用 XMLHttpRequest 对象发起的，但是用起来很麻烦，所以 ES6 新规范就有了 fetch，fetch 发一个请求不用像 ajax 那样写一大堆代码。</li><li>使用 fetch 无法取消一个请求，这是因为 fetch 基于 Promise，而 Promise 无法做到这一点。</li><li>在默认情况下，fetch 不会接受或者发送 cookies</li><li>fetch 没有办法原生监测请求的进度，而 XMLHttpRequest 可以</li><li>fetch 只对网络请求报错，对 400，500 都当做成功的请求，需要封装去处理</li><li>fetch 由于是 ES6 规范，兼容性上比不上 XMLHttpRequest</li></ul><h3 id="XML-和-JSON-的区别？"><a href="#XML-和-JSON-的区别？" class="headerlink" title="XML 和 JSON 的区别？"></a>XML 和 JSON 的区别？</h3><ul><li>数据体积方面：JSON 相对于 XML 来讲，数据的体积小，传递的速度更快些。</li><li>数据交互方面：JSON 与 JavaScript 的交互更加方便，更容易解析处理，更好的数据交互。</li><li>数据描述方面：JSON 对数据的描述性比 XML 较差。</li><li>传输速度方面：JSON 的速度要远远快于 XML。</li></ul><h3 id="AMD-和-CMD-规范的区别"><a href="#AMD-和-CMD-规范的区别" class="headerlink" title="AMD 和 CMD 规范的区别"></a>AMD 和 CMD 规范的区别</h3><ul><li>对于依赖的模块，AMD 是提前执行，CMD 是延迟执行</li><li>CMD 推崇依赖就近，AMD 推崇依赖前置</li></ul><h3 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h3><p>REST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。</p><ul><li><p><strong>GET</strong></p><p>get 方法在 Rest 中主要用于获取资源，能够发送参数，不过有限制，且参数都会以?开头的形 式附加在 URL 尾部。<br>规范的 get 方法处理器应该是幂等的，也就是说对一个资源不论发送多少次 get 请求都不会更改数据或造成破坏。</p></li><li><p><strong>POST</strong><br>post 方法在 Rest 请求中主要用于添加资源，参数信息存放在请求报文的消息体中相对安全，且可发送较大信息</p></li><li><p><strong>PUT</strong><br>put 方法在 Rest 中主要用于更新资源，因为大多数浏览器不支持 put 和 delete，会自动将 put 和 delete 请求转化为 get 和 post. 因此为了使用 put 和 delete 方法,<br>需要以 post 发送请求，在表单中使用隐藏域发送真正的请求。<br>put 方法的参数是同 post 一样是存放在消息中的，同样具有安全性，可发送较大信息。<br>put 方法是幂等的，对同一 URL 资源做出的同一数据的任意次 put 请求其对数据的改变都是一致的。</p></li><li><p><strong>DELETE</strong><br>Delete 在 Rest 请求中主要用于删除资源，因为大多数浏览器不支持 put 和 delete，会自动将 put 和 delete 请求转化为 get 和 post。<br>因此为了使用 put 和 delete 方法,需要以 post 发送请求，在表单中使用隐藏域发送真正的请求。<br>Delete 方法的参数同 post 一样存放在消息体中,具有安全性，可发送较大信息 Delete 方法是幂等的，不论对同一个资源进行多少次 delete 请求都不会破坏数据</p></li></ul><p>解析：<a href="https://blog.csdn.net/jnshu_it/article/details/80203696" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;前端通信类的问题，主要包括以下内容&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;什么是&lt;strong&gt;同源策略&lt;/strong&gt;及限制
      
    
    </summary>
    
      <category term="前端知识点" scheme="http://www.bluedream.top/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="同源策略" scheme="http://www.bluedream.top/tags/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"/>
    
      <category term="通信方式" scheme="http://www.bluedream.top/tags/%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
    
      <category term="Ajax" scheme="http://www.bluedream.top/tags/Ajax/"/>
    
      <category term="JSON" scheme="http://www.bluedream.top/tags/JSON/"/>
    
      <category term="跨域通信" scheme="http://www.bluedream.top/tags/%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1/"/>
    
      <category term="异步" scheme="http://www.bluedream.top/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>CSS</title>
    <link href="http://www.bluedream.top/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9/CSS.html"/>
    <id>http://www.bluedream.top/前端知识点/CSS.html</id>
    <published>2019-09-09T14:30:10.000Z</published>
    <updated>2019-09-28T10:14:14.996Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？"><a href="#介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？" class="headerlink" title="介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？"></a>介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</h3><p>有两种， IE 盒子模型、W3C 盒子模型；</p><p><strong>区别：</strong> IE的content部分把 border 和 padding计算了进去;</p><p>盒子模型<strong>构成：</strong>内容(content)、内填充(padding)、 边框(border)、外边距(margin)</p><ul><li>IE8及其以下版本浏览器，未声明 DOCTYPE，内容宽高会包含内填充和边框，称为怪异盒模型(IE盒模型)</li><li>标准(W3C)盒模型：元素宽度 = width + padding + border + margin</li><li>怪异(IE)盒模型：元素宽度 = width + margin</li><li>标准浏览器通过设置 css3 的 box-sizing: border-box 属性，触发“怪异模式”解析计算宽高</li></ul><h3 id="css-hack原理及常用hack"><a href="#css-hack原理及常用hack" class="headerlink" title="css hack原理及常用hack"></a>css hack原理及常用hack</h3><ul><li>原理：利用不同浏览器对CSS的支持和解析结果不一样编写针对特定浏览器样式。</li><li>常见的hack有<ul><li>属性hack</li><li>选择器hack</li><li>IE条件注释</li></ul></li></ul><h3 id="link-与-import-的区别"><a href="#link-与-import-的区别" class="headerlink" title="link 与 @import 的区别"></a>link 与 @import 的区别</h3><ul><li><code>link</code> 是<code>HTML</code>方式， <code>@import</code> 是<code>CSS</code>方式</li><li><code>link</code>最大限度支持并行下载，<code>@import</code> 过多嵌套导致串行下载，出现FOUC</li><li><code>link</code> 可以通过 <code>rel=&quot;alternate stylesheet&quot;</code> 指定候选样式</li><li>浏览器对 <code>link</code> 支持早于<code>@import</code> ，可以使用 <code>@import</code> 对老浏览器隐藏样式</li><li><code>@import</code> 必须在样式规则之前，可以在<code>css</code>文件中引用其他文件</li><li>总体来说：<code>link</code>优于<code>@import</code></li></ul><h3 id="CSS有哪些继承属性"><a href="#CSS有哪些继承属性" class="headerlink" title="CSS有哪些继承属性"></a>CSS有哪些继承属性</h3><ul><li>关于文字排版的属性如：<ul><li><code>font</code><ul><li><code>word-break</code></li><li><code>letter-spacing</code></li><li><code>text-align</code></li><li><code>text-rendering</code></li><li><code>word-spacing</code></li><li><code>white-space</code></li><li><code>text-indent</code></li><li><code>text-transform</code></li><li><code>text-shadow</code></li></ul></li><li><code>line-height</code></li><li><code>color</code></li><li><code>visibility</code></li><li><code>cursor</code></li></ul></li></ul><h3 id="display有哪些值？说明他们的作用。"><a href="#display有哪些值？说明他们的作用。" class="headerlink" title="display有哪些值？说明他们的作用。"></a>display有哪些值？说明他们的作用。</h3><ul><li>block            块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</li><li>none            缺省值。像行内元素类型一样显示。</li><li>inline           行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示</li><li>inline-block  默认宽度为内容宽度，可以设置宽高，同行显示。</li><li>list-item       像块类型元素一样显示，并添加样式列表标记。</li><li>table            此元素会作为块级表格来显示。</li><li>inherit         规定应该从父元素继承 display 属性的值</li></ul><h3 id="display-有哪些值？说明他们的作用"><a href="#display-有哪些值？说明他们的作用" class="headerlink" title="display 有哪些值？说明他们的作用"></a>display 有哪些值？说明他们的作用</h3><p>默认值：inline</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">none： 隐藏对象。与visibility属性的hidden值不同，其不为被隐藏的对象保留其物理空间</span><br><span class="line">inline： 指定对象为内联元素。</span><br><span class="line">block： 指定对象为块元素。</span><br><span class="line">list-item： 指定对象为列表项目。</span><br><span class="line">inline-block： 指定对象为内联块元素。（CSS2）</span><br><span class="line">table： 指定对象作为块元素级的表格。类同于html标签&lt;table&gt;（CSS2）</span><br><span class="line">inline-table： 指定对象作为内联元素级的表格。类同于html标签&lt;table&gt;（CSS2）</span><br><span class="line">table-caption： 指定对象作为表格标题。类同于html标签&lt;caption&gt;（CSS2）</span><br><span class="line">table-cell： 指定对象作为表格单元格。类同于html标签&lt;td&gt;（CSS2）</span><br><span class="line">table-row： 指定对象作为表格行。类同于html标签&lt;tr&gt;（CSS2）</span><br><span class="line">table-row-group： 指定对象作为表格行组。类同于html标签&lt;tbody&gt;（CSS2）</span><br><span class="line">table-column： 指定对象作为表格列。类同于html标签&lt;col&gt;（CSS2）</span><br><span class="line">table-column-group： 指定对象作为表格列组显示。类同于html标签&lt;colgroup&gt;（CSS2）</span><br><span class="line">table-header-group： 指定对象作为表格标题组。类同于html标签&lt;thead&gt;（CSS2）</span><br><span class="line">table-footer-group： 指定对象作为表格脚注组。类同于html标签&lt;tfoot&gt;（CSS2）</span><br><span class="line">run-in： 根据上下文决定对象是内联对象还是块级对象。（CSS3）</span><br><span class="line">box： 将对象作为弹性伸缩盒显示。（伸缩盒最老版本）（CSS3）</span><br><span class="line">inline-box： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒最老版本）（CSS3）</span><br><span class="line">flexbox： 将对象作为弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3）</span><br><span class="line">inline-flexbox： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3）</span><br><span class="line">flex： 将对象作为弹性伸缩盒显示。（伸缩盒最新版本）（CSS3）</span><br><span class="line">inline-flex： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒最新版本）（CSS3）</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/77e1c36c0895" target="_blank" rel="noopener">参考</a></p><h3 id="display-none-与-visibility-hidden-的区别"><a href="#display-none-与-visibility-hidden-的区别" class="headerlink" title="display: none; 与 visibility: hidden; 的区别"></a>display: none; 与 visibility: hidden; 的区别</h3><p><strong>联系：</strong>它们都能让元素不可见</p><p><strong>区别：</strong></p><p><code>display:none</code>：会让元素完全从渲染树中消失，隐藏对应的元素，渲染的时候不占据任何空间；<code>visibility: hidden</code>：不会让元素从渲染树消失，隐藏对应的元素，渲染时元素仍占据空间位置，只是内容不可见。</p><p>即是，使用 CSS display:none 属性后，HTML 元素（对象）的宽度、高度等各种属性值都将“丢失”;而使用 visibility:hidden 属性后，HTML 元素（对象）仅仅是在视觉上看不见（完全透明），而它所占据的空间位置仍然存在。</p><ul><li><code>display: none</code>;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；<code>visibility:hidden</code>;是继承属性，子孙节点消失由于继承了<code>hidden</code>，通过设置<code>visibility: visible</code>;可以让子孙节点显式</li><li>修改常规流中元素的<code>display</code>通常会造成文档重排。修改<code>visibility</code>属性只会造成本元素的重绘</li><li>读屏器不会读取<code>display: none;</code>元素内容；会读取<code>visibility: hidden</code>元素内容</li></ul><p><strong>display:none、visibile:hidden、opacity:0 的区别</strong></p><table><thead><tr><th></th><th>是否隐藏</th><th>是否在文档中占用空间</th><th>是否会触发事件</th></tr></thead><tbody><tr><td>display: none</td><td>是</td><td>否</td><td>否</td></tr><tr><td>visibile: hidden</td><td>是</td><td>是</td><td>否</td></tr><tr><td>opacity: 0</td><td>是</td><td>是</td><td>是</td></tr></tbody></table><h3 id="display-inline-block-什么时候会显示间隙？-携程"><a href="#display-inline-block-什么时候会显示间隙？-携程" class="headerlink" title="display:inline-block 什么时候会显示间隙？(携程)"></a>display:inline-block 什么时候会显示间隙？(携程)</h3><ul><li>移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing</li><li>inline-block 布局的元素在编辑器里写在同一行</li></ul><p>间隙产生的<strong>原因</strong>是因为，换行或空格会占据一定的位置</p><p>推荐<strong>解决方法</strong>：</p><p>父元素中设置<br>font-size:0;letter-spaceing:-4px;</p><h3 id="设置元素浮动后，该元素的-display-值会如何变化？"><a href="#设置元素浮动后，该元素的-display-值会如何变化？" class="headerlink" title="设置元素浮动后，该元素的 display 值会如何变化？"></a>设置元素浮动后，该元素的 display 值会如何变化？</h3><p>设置元素浮动后，该元素的 display 值自动变成 block</p><h3 id="css中属性定义，使得dom元素不显示在浏览器可视范围内？"><a href="#css中属性定义，使得dom元素不显示在浏览器可视范围内？" class="headerlink" title="css中属性定义，使得dom元素不显示在浏览器可视范围内？"></a>css中属性定义，使得dom元素不显示在浏览器可视范围内？</h3><p>1.display属性为none、visibility设为hidden（但是仍然占据页面空间）<br>2.设置宽高为 0，设置透明度为 0，设置 z-index 位置在-1000em(附：该属性仅在定位元素中生效)；</p><h3 id="display-float-position的关系"><a href="#display-float-position的关系" class="headerlink" title="display,float,position的关系"></a>display,float,position的关系</h3><ul><li><p>如果 <code>display</code> 为<code>none</code>，那么<code>position</code>和<code>float</code>都不起作用，这种情况下元素不产生框</p></li><li><p>否则，如果<code>position</code>值为<code>absolute</code>或者<code>fixed</code>，框就是绝对定位的，<code>float</code>的计算值为<code>none</code>，<code>display</code>根据下面的表格进行调整</p></li><li><p>否则，如果<code>float</code>不是<code>none</code>，框是浮动的，<code>display</code>根据下表进行调整</p></li><li><p>否则，如果元素是根元素，<code>display</code>根据下表进行调整</p></li><li><p>其他情况下<code>display</code>的值为指定值 总结起来：绝对定位、浮动、根元素都需要调整 <code>display</code></p><p><img src="/img/loading.gif" data-original="https://images2018.cnblogs.com/blog/715962/201805/715962-20180513012245079-391725349.png" alt="图片转自网络"></p></li></ul><h3 id="什么是外边距重叠-collapsing-margins-？"><a href="#什么是外边距重叠-collapsing-margins-？" class="headerlink" title="什么是外边距重叠(collapsing margins)？"></a>什么是外边距重叠(collapsing margins)？</h3><p>相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。<br>这种合并外边距的方式被称为<strong>折叠</strong>，结合而成的外边距称为<strong>折叠外边距</strong></p><ul><li>两个或多个毗邻的普通流中的块元素垂直方向上的<code>margin</code>会折叠</li><li>浮动元素或<code>inline-block</code>元素或绝对定位元素的<code>margin</code>不会和垂直方向上的其他元素的margin折叠</li><li>创建了块级格式化上下文的元素，不会和它的子元素发生margin折叠</li><li>元素自身的<code>margin-bottom</code>和<code>margin-top</code>相邻时也会折</li></ul><h3 id="重叠的结果是什么？"><a href="#重叠的结果是什么？" class="headerlink" title="重叠的结果是什么？"></a>重叠的结果是什么？</h3><ul><li><p>折叠结果遵循下列计算规则：</p></li><li><p>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值</p></li><li><p>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值</p></li><li><p>两个外边距一正一负时，折叠结果是两者的相加的和</p></li></ul><h3 id="CSS选择符有哪些？哪些属性可以继承？"><a href="#CSS选择符有哪些？哪些属性可以继承？" class="headerlink" title="CSS选择符有哪些？哪些属性可以继承？"></a>CSS选择符有哪些？哪些属性可以继承？</h3><ul><li><p>id选择器（ # myid）</p></li><li><p>类选择器（.myclassname）</p></li><li><p>标签选择器（div, h1, p）</p></li><li><p>相邻选择器（h1 + p）</p></li><li><p>子选择器（ul &gt; li）</p></li><li><p>后代选择器（li a）</p></li><li><p>通配符选择器（ * ）</p></li><li><p>属性选择器（a[rel = “external”]）</p></li><li><p>伪类选择器（a:hover, li:nth-child）</p></li><li><p>可继承的样式： <code>font-size font-family color, UL LI DL DD DT</code></p></li><li><p>不可继承的样式：<code>border padding margin width height</code></p></li></ul><h3 id="CSS3新增伪类有那些？"><a href="#CSS3新增伪类有那些？" class="headerlink" title="CSS3新增伪类有那些？"></a>CSS3新增伪类有那些？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:last-of-type  选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:only-of-type  选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:only-child        选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:nth-child(2)  选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。</span><br><span class="line"></span><br><span class="line">:after          在元素之前添加内容,也可以用来做清除浮动。</span><br><span class="line">:before         在元素之后添加内容</span><br><span class="line">:enabled        </span><br><span class="line">:disabled       控制表单控件的禁用状态。</span><br><span class="line">:checked        单选框或复选框被选中</span><br></pre></td></tr></table></figure><h3 id="用-H5-CSS3-解决下导航栏最后一项掉下来的问题"><a href="#用-H5-CSS3-解决下导航栏最后一项掉下来的问题" class="headerlink" title="用 H5+CSS3 解决下导航栏最后一项掉下来的问题"></a>用 H5+CSS3 解决下导航栏最后一项掉下来的问题</h3><p>答案：box-sizing: border-box;</p><h3 id="position的值relative和absolute定位原点是？"><a href="#position的值relative和absolute定位原点是？" class="headerlink" title="position的值relative和absolute定位原点是？"></a>position的值relative和absolute定位原点是？</h3><ul><li>absolute<ul><li>生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。</li></ul></li><li>fixed （老IE不支持）<ul><li>生成绝对定位的元素，相对于浏览器窗口进行定位。</li></ul></li><li>relative<ul><li>生成相对定位的元素，相对于其正常位置进行定位。</li></ul></li><li>static<ul><li>默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right - z-index 声明）。</li></ul></li><li>inherit<ul><li>规定从父元素继承 position 属性的值</li></ul></li></ul><h3 id="CSS3有哪些新特性？"><a href="#CSS3有哪些新特性？" class="headerlink" title="CSS3有哪些新特性？"></a>CSS3有哪些新特性？</h3><ul><li>新增各种CSS选择器  （: not(.input)：所有 class 不是“input”的节点）</li><li>圆角           （border-radius:8px）</li><li>多列布局        （multi-column layout）</li><li>阴影和反射        （Shadow\Reflect）</li><li>文字特效      （text-shadow、）</li><li>文字渲染      （Text-decoration）</li><li>线性渐变      （gradient）</li><li>旋转          （transform）</li><li>增加了旋转,缩放,定位,倾斜,动画，多背景</li><li><code>transform:\scale(0.85,0.90)\ translate(0px,-30px)\ skew(-9deg,0deg)\Animation:</code></li></ul><h3 id="CSS3有哪些新特性？-1"><a href="#CSS3有哪些新特性？-1" class="headerlink" title="CSS3有哪些新特性？"></a>CSS3有哪些新特性？</h3><ul><li>新增选择器     p:nth-child(n){color: rgba(255, 0, 0, 0.75)}</li><li>弹性盒模型     display: flex;</li><li>多列布局       column-count: 5;</li><li>媒体查询       @media (max-width: 480px) {.box: {column-count: 1;}}</li><li>个性化字体     @font-face{font-family: BorderWeb; src:url(BORDERW0.eot);}</li><li>颜色透明度     color: rgba(255, 0, 0, 0.75);</li><li>圆角           border-radius: 5px;</li><li>渐变           background:linear-gradient(red, green, blue);</li><li>阴影           box-shadow:3px 3px 3px rgba(0, 64, 128, 0.3);</li><li>倒影           box-reflect: below 2px;</li><li>文字装饰       text-stroke-color: red;</li><li>文字溢出       text-overflow:ellipsis;</li><li>背景效果       background-size: 100px 100px;</li><li>边框效果       border-image:url(bt_blue.png) 0 10;</li><li>转换<ul><li>旋转          transform: rotate(20deg);</li><li>倾斜          transform: skew(150deg, -10deg);</li><li>位移          transform: translate(20px, 20px);</li><li>缩放          transform: scale(.5);</li></ul></li><li>平滑过渡       transition: all .3s ease-in .1s;</li><li>动画           @keyframes anim-1 {50% {border-radius: 50%;}} animation: anim-1 1s;</li></ul><h3 id="css3-有哪些新特性"><a href="#css3-有哪些新特性" class="headerlink" title="css3 有哪些新特性"></a>css3 有哪些新特性</h3><ol><li>选择器</li></ol><ul><li>E:last-child 匹配父元素的最后一个子元素 E。</li><li>E:nth-child(n)匹配父元素的第 n 个子元素 E。</li><li>E:nth-last-child(n) CSS3 匹配父元素的倒数第 n 个子元素 E。</li></ul><ol start="3"><li>多栏布局</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mul-col"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>新手上路<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>新手专区 消费警示 交易安全 24小时在线帮助 免费开店<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>付款方式<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>快捷支付 信用卡 余额宝 蚂蚁花呗 货到付款<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>淘宝特色<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>手机淘宝 旺信 大众评审 B格指南<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.mul-col</span> &#123;</span><br><span class="line">  <span class="attribute">column-count</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">column-gap</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">column-rule</span>: <span class="number">1px</span> solid gray;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid gray;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>多背景图</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* backgroundimage:url('1.jpg),url('2.jpg') */</span></span><br></pre></td></tr></table></figure><ol start="5"><li>CSS3 word-wrap 属性</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.test</span> &#123;</span><br><span class="line">  <span class="attribute">word-wrap</span>: break-word;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>文字阴影</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">text-shadow</span>: 5<span class="selector-tag">px</span> 2<span class="selector-tag">px</span> 6<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(64, 64, 64, 0<span class="selector-class">.5</span>);</span><br></pre></td></tr></table></figure><ol start="7"><li>@font-face 属性</li></ol><p>Font-face 可以用来加载字体样式，而且它还能够加载服务器端的字体文件，让客户端显示客户端所没有安装的字体。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: BorderWeb;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(BORDERW0.eot);</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: Runic;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(RUNICMT0.eot);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.border</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">35px</span>;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">"BorderWeb"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.event</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">110px</span>;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">"Runic"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 淘宝网字体使用 */</span></span><br><span class="line"></span><br><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: iconfont;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(//at.alicdn.com/t/font_1465189805_4518812.eot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>圆角</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">border-radius</span>: 15<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure><ol start="9"><li>边框图片</li></ol><p>CSS3 border-image 属性</p><ol start="10"><li>盒阴影</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* box-shadow: 水平方向的偏移量 垂直方向的偏移量 模糊程度 扩展程度 颜色 是否具有内阴影 */</span></span><br></pre></td></tr></table></figure><ol start="11"><li>盒子大小</li></ol><p>CSS3 box-sizing 属性</p><ol start="12"><li>媒体查询</li></ol><p>CSS3 @media 查询</p><ol start="13"><li>CSS3 动画</li></ol><p>@keyframes</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> abc &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(0);</span><br><span class="line">  &#125;</span><br><span class="line">  50% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(90deg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(360deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>animation 属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* animation：name duration timing-function delay interation-count direction play-state */</span></span><br></pre></td></tr></table></figure><ol start="14"><li>渐变效果</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">-webkit-gradient</span>(</span><br><span class="line">  <span class="selector-tag">linear</span>,</span><br><span class="line">  0% 0%,</span><br><span class="line">  100% 0%,</span><br><span class="line">  <span class="selector-tag">from</span>(<span class="selector-id">#2a8bbe</span>),</span><br><span class="line">  <span class="selector-tag">to</span>(<span class="selector-id">#fe280e</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="15"><li>CSS3 弹性盒子模型</li></ol><ul><li>弹性盒子是 CSS3 的一种新的布局模式。</li><li>CSS3 弹性盒（ Flexible Box 或 flexbox），是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。</li><li>引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。</li></ul><ol start="16"><li>CSS3 过渡</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: width <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">-moz-transition</span>: width <span class="number">2s</span>; <span class="comment">/* Firefox 4 */</span></span><br><span class="line">  <span class="attribute">-webkit-transition</span>: width <span class="number">2s</span>; <span class="comment">/* Safari 和 Chrome */</span></span><br><span class="line">  <span class="attribute">-o-transition</span>: width <span class="number">2s</span>; <span class="comment">/* Opera */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="17"><li>CSS3 变换</li></ol><ul><li>rotate()旋转</li><li>translate()平移</li><li>scale( )缩放</li><li>skew()扭曲/倾斜</li><li>变换基点</li><li>3d 转换</li></ul><p><a href="https://www.w3school.com.cn/css3/index.asp" target="_blank" rel="noopener">参考</a></p><h3 id="一个满屏-品-字布局-如何设计"><a href="#一个满屏-品-字布局-如何设计" class="headerlink" title="一个满屏 品 字布局 如何设计?"></a>一个满屏 品 字布局 如何设计?</h3><p>简单的方式：</p><ul><li>上面的div宽100%，</li><li>下面的两个div分别宽50%，</li><li>然后用float或者inline使其不换行即可</li></ul><h3 id="请写出多种等高布局"><a href="#请写出多种等高布局" class="headerlink" title="请写出多种等高布局"></a>请写出多种等高布局</h3><h3 id="css定义的权重"><a href="#css定义的权重" class="headerlink" title="css定义的权重"></a>css定义的权重</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100</span><br><span class="line">//以下例子是演示各种定义的权重值：</span><br><span class="line"></span><br><span class="line">/*权重为1*/</span><br><span class="line">div&#123;</span><br><span class="line">&#125;</span><br><span class="line">/*权重为10*/</span><br><span class="line">.class1&#123;</span><br><span class="line">&#125;</span><br><span class="line">/*权重为100*/</span><br><span class="line">#id1&#123;</span><br><span class="line">&#125;</span><br><span class="line">/*权重为100+1=101*/</span><br><span class="line">#id1 div&#123;</span><br><span class="line">&#125;</span><br><span class="line">/*权重为10+1=11*/</span><br><span class="line">.class1 div&#123;</span><br><span class="line">&#125;</span><br><span class="line">/*权重为10+10+1=21*/</span><br><span class="line">.class1 .class2 div&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现</span><br></pre></td></tr></table></figure><h3 id="谈谈浮动和清除浮动"><a href="#谈谈浮动和清除浮动" class="headerlink" title="谈谈浮动和清除浮动"></a>谈谈浮动和清除浮动</h3><p>浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上</p><h3 id="解释下什么是浮动和它的工作原理？"><a href="#解释下什么是浮动和它的工作原理？" class="headerlink" title="解释下什么是浮动和它的工作原理？"></a>解释下什么是浮动和它的工作原理？</h3><p>非IE浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。<br>此时，内容会溢出到容器外面而影响布局。这种现象被称为<strong>浮动</strong>（溢出）。</p><p><strong>工作原理：</strong></p><ul><li>浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象）</li><li>浮动元素碰到包含它的边框或者其他浮动元素的边框停留</li></ul><h3 id="浮动元素引起的问题？"><a href="#浮动元素引起的问题？" class="headerlink" title="浮动元素引起的问题？"></a>浮动元素引起的问题？</h3><ul><li>父元素的高度无法被撑开，影响与父元素同级的元素</li><li>与浮动元素同级的非浮动元素会跟随其后</li></ul><h3 id="列举几种清除浮动的方式？"><a href="#列举几种清除浮动的方式？" class="headerlink" title="列举几种清除浮动的方式？"></a>列举几种清除浮动的方式？</h3><ul><li><p>添加额外标签，例如 <code>&lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;</code></p></li><li><p>使用 br 标签和其自身的 clear 属性，例如 <code>&lt;br clear=&quot;all&quot; /&gt;</code></p></li><li><p>父元素设置 overflow：hidden; 在IE6中还需要触发 hasLayout，例如zoom：1;</p></li><li><p>父元素也设置浮动</p></li><li><p>使用 :after 伪元素。由于IE6-7不支持 :after，使用 zoom:1 触发 hasLayout</p></li></ul><h3 id="CSS-清除浮动的几种方法（至少两种）"><a href="#CSS-清除浮动的几种方法（至少两种）" class="headerlink" title="CSS 清除浮动的几种方法（至少两种）"></a>CSS 清除浮动的几种方法（至少两种）</h3><p>清除浮动： 核心：clear:both;</p><p><strong>1.（不推荐使用）</strong></p><p>在浮动的盒子下面再放一个标签，使用 clear:both;来清除浮动</p><p>a 内部标签：会将父盒子的高度重新撑开</p><p>b 外部标签：只能将浮动盒子的影响清除，但是不会撑开盒子</p><p><strong>2.使用 overflow 清除浮动（不推荐使用）</strong></p><p>先找到浮动盒子的父元素，给父元素添加一个属性：overflow:hidden;就会清除子元素对页面的影响</p><p><strong>3.使用伪元素清除浮动(用的最多)</strong></p><p>伪元素：在页面上不存在的元素，但是可以通过 css 添加上去</p><p>种类：<br>                  :after(在。。。之后)<br>                  :before(在。。。之前)</p><p>注意：每个元素都有自己的伪元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:after &#123;</span><br><span class="line">    content:&quot;&quot;;</span><br><span class="line">    height:0;</span><br><span class="line">    line-height:0;</span><br><span class="line">    display:block;</span><br><span class="line">    clear:both;</span><br><span class="line">    visibility:hidden;  /_将元素隐藏起来_/ </span><br><span class="line">      在页面的 clearfix 元素后面添加了一个空的块级元素</span><br><span class="line">     （这个元素的高为 0 行高也为 0   并且这个元素清除了浮动）</span><br><span class="line">&#125;</span><br><span class="line">.clearfix &#123;</span><br><span class="line">  zoom:1;/_为了兼容 IE6_/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="清除浮动最佳实践（after伪元素闭合浮动）"><a href="#清除浮动最佳实践（after伪元素闭合浮动）" class="headerlink" title="清除浮动最佳实践（after伪元素闭合浮动）"></a>清除浮动最佳实践（after伪元素闭合浮动）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:after&#123;</span><br><span class="line">    content: &quot;\200B&quot;;</span><br><span class="line">    display: table; </span><br><span class="line">    height: 0;</span><br><span class="line">    clear: both;</span><br><span class="line">  &#125;</span><br><span class="line">  .clearfix&#123;</span><br><span class="line">    *zoom: 1;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="请解释一下为什么需要清除浮动？清除浮动的方式"><a href="#请解释一下为什么需要清除浮动？清除浮动的方式" class="headerlink" title="请解释一下为什么需要清除浮动？清除浮动的方式"></a>请解释一下为什么需要清除浮动？清除浮动的方式</h3><p>清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示</p><ul><li>父级div定义height</li><li>父级div 也一起浮动；</li><li>常规的使用一个class；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:before, .clearfix:after &#123;</span><br><span class="line">    content: &quot; &quot;;</span><br><span class="line">    display: table;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix &#123;</span><br><span class="line">    *zoom: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SASS编译的时候，浮动元素的父级div定义伪类:after</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&amp;:after,&amp;:before&#123;</span><br><span class="line">    content: &quot; &quot;;</span><br><span class="line">    visibility: hidden;</span><br><span class="line">    display: block;</span><br><span class="line">    height: 0;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解析原理：</strong></p><ul><li><p>display:block 使生成的元素以块级元素显示,占满剩余空间</p></li><li><p>height:0 避免生成内容破坏原有布局的高度。</p></li><li><p>visibility:hidden 使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互</p></li><li><p>通过 content:”.”生成内容作为最后一个元素，至于content里面是点还是其他都是可以的，例如oocss里面就有经典的 content:”.”,有些版本可能content 里面内容为空,一丝冰凉是不推荐这样做的,firefox直到7.0 content:”” 仍然会产生额外的空隙</p></li><li><p>zoom：1 触发IE hasLayout</p></li><li><p>通过分析发现，除了clear：both用来闭合浮动的，其他代码无非都是为了隐藏掉content生成的内容，这也就是其他版本的闭合浮动为什么会有font-size：0，line-height：0</p></li></ul><h3 id="zoom-1的清除浮动原理"><a href="#zoom-1的清除浮动原理" class="headerlink" title="zoom:1的清除浮动原理?"></a>zoom:1的清除浮动原理?</h3><ul><li>清除浮动，触发hasLayout；</li><li>Zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug</li><li>譬如外边距（margin）的重叠，浮动清除，触发ie的haslayout属性等</li></ul><h3 id="css的content属性？有什么作用与应用"><a href="#css的content属性？有什么作用与应用" class="headerlink" title="css的content属性？有什么作用与应用"></a>css的content属性？有什么作用与应用</h3><p>css的content属性专门应用在before/after伪元素上，用来插入生成内容。<br>常用伪类清除浮动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:after&#123;</span><br><span class="line">content:&quot;.&quot;;</span><br><span class="line">display:block;</span><br><span class="line">height:0;</span><br><span class="line">visibility:hidden;</span><br><span class="line">clear:both;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix&#123;</span><br><span class="line">*zoom:1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="清除浮动的方式"><a href="#清除浮动的方式" class="headerlink" title="清除浮动的方式"></a>清除浮动的方式</h3><p>1、给父元素定义height<br>2、结尾处加空div标签clear：both；<br>3、父级元素定义伪类：如上；<br>4、父级元素定义overflow：hidden；<br>5、父级元素定义overflow：auto；<br>6、父级元素也浮动,需要定义宽度；<br>7、父级元素定义display：table；<br>8、结尾处加br标签clear：both；</p><p> 第三种：after伪元素方法清理浮动，文档结构更加清晰</p><h3 id="知道-css-有个-content-属性吗？有什么作用？有什么应用？"><a href="#知道-css-有个-content-属性吗？有什么作用？有什么应用？" class="headerlink" title="知道 css 有个 content 属性吗？有什么作用？有什么应用？"></a>知道 css 有个 content 属性吗？有什么作用？有什么应用？</h3><p>知道。css 的 content 属性专门应用在 before/after 伪元素上，用来插入生成内容。最常见的应用是利用伪类清除浮动。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//一种常见利用伪类清除浮动的代码</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  content: "."; //这里利用到了content属性</span><br><span class="line">  <span class="selector-tag">display</span>: <span class="selector-tag">block</span>;</span><br><span class="line">  <span class="selector-tag">height</span>: 0;</span><br><span class="line">  <span class="selector-tag">visibility</span>: <span class="selector-tag">hidden</span>;</span><br><span class="line">  <span class="selector-tag">clear</span>: <span class="selector-tag">both</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  <span class="attribute">zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>after 伪元素通过 content 在元素的后面生成了内容为一个点的块级素，再利用 clear:both 清除浮动。</p><h3 id="知道-css-计数器（序列数字字符自动递增）吗？"><a href="#知道-css-计数器（序列数字字符自动递增）吗？" class="headerlink" title="知道 css 计数器（序列数字字符自动递增）吗？"></a>知道 css 计数器（序列数字字符自动递增）吗？</h3><h3 id="如何通过-css-content-属性实现-css-计数器？"><a href="#如何通过-css-content-属性实现-css-计数器？" class="headerlink" title="如何通过 css content 属性实现 css 计数器？"></a>如何通过 css content 属性实现 css 计数器？</h3><p>css 计数器是通过设置 counter-reset 、counter-increment 两个属性 、及 counter()/counters()一个方法配合 after / before 伪类实现。</p><h3 id="box-sizing-常用的属性有哪些？分别有什么作用？"><a href="#box-sizing-常用的属性有哪些？分别有什么作用？" class="headerlink" title="box-sizing 常用的属性有哪些？分别有什么作用？"></a>box-sizing 常用的属性有哪些？分别有什么作用？</h3><ul><li>box-sizing: content-box;  // 默认的标准(W3C)盒模型元素效果</li><li>box-sizing: border-box;   // 触发怪异(IE)盒模型元素的效果</li><li>box-sizing: inherit;      //  继承父元素 box-sizing 属性的值</li></ul><h3 id="CSS选择器有哪些？"><a href="#CSS选择器有哪些？" class="headerlink" title="CSS选择器有哪些？"></a>CSS选择器有哪些？</h3><ul><li>id选择器        #id</li><li>类选择器        .class</li><li>标签选择器      div, h1, p</li><li>相邻选择器      h1 + p</li><li>子选择器        ul &gt; li</li><li>后代选择器      li a</li><li>通配符选择器    *</li><li>属性选择器      a[rel=’external’]</li><li>伪类选择器      a:hover, li:nth-child</li></ul><h3 id="CSS哪些属性可以继承？哪些属性不可以继承？"><a href="#CSS哪些属性可以继承？哪些属性不可以继承？" class="headerlink" title="CSS哪些属性可以继承？哪些属性不可以继承？"></a>CSS哪些属性可以继承？哪些属性不可以继承？</h3><ul><li>可以继承的样式：font-size、font-family、color、list-style、cursor</li><li>不可继承的样式：width、height、border、padding、margin、background</li></ul><h3 id="CSS3新增伪类有哪些？"><a href="#CSS3新增伪类有哪些？" class="headerlink" title="CSS3新增伪类有哪些？"></a>CSS3新增伪类有哪些？</h3><ul><li><p>:root           选择文档的根元素，等同于 html 元素</p></li><li><p>:empty          选择没有子元素的元素</p></li><li><p>:target         选取当前活动的目标元素</p></li><li><p>:not(selector)  选择除 selector 元素意外的元素</p></li><li><p>:enabled        选择可用的表单元素</p></li><li><p>:disabled       选择禁用的表单元素</p></li><li><p>:checked        选择被选中的表单元素</p></li><li><p>:after          在元素内部最前添加内容</p></li><li><p>:before         在元素内部最后添加内容</p></li><li><p>:nth-child(n)      匹配父元素下指定子元素，在所有子元素中排序第n</p></li><li><p>:nth-last-child(n) 匹配父元素下指定子元素，在所有子元素中排序第n，从后向前数</p></li><li><p>:nth-child(odd)</p></li><li><p>:nth-child(even)</p></li><li><p>:nth-child(3n+1)</p></li><li><p>:first-child</p></li><li><p>:last-child</p></li><li><p>:only-child</p></li><li><p>:nth-of-type(n)      匹配父元素下指定子元素，在同类子元素中排序第n</p></li><li><p>:nth-last-of-type(n) 匹配父元素下指定子元素，在同类子元素中排序第n，从后向前数</p></li><li><p>:nth-of-type(odd)</p></li><li><p>:nth-of-type(even)</p></li><li><p>:nth-of-type(3n+1)</p></li><li><p>:first-of-type</p></li><li><p>:last-of-type</p></li><li><p>:only-of-type</p></li><li><p>::selection     选择被用户选取的元素部分</p></li><li><p>:first-line     选择元素中的第一行</p></li><li><p>:first-letter   选择元素中的第一个字符</p></li></ul><h3 id="请列举几种隐藏元素的方法"><a href="#请列举几种隐藏元素的方法" class="headerlink" title="请列举几种隐藏元素的方法"></a>请列举几种隐藏元素的方法</h3><ul><li>visibility: hidden;   这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在</li><li>opacity: 0;           CSS3属性，设置0可以使一个元素完全透明</li><li>position: absolute;   设置一个很大的 left 负值定位，使元素定位在可见区域之外</li><li>display: none;        元素会变得不可见，并且不会再占用文档的空间。</li><li>transform: scale(0);  将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留</li><li><code>&lt;div hidden=&quot;hidden&quot;&gt;</code> HTML5属性,效果和display:none;相同，但这个属性用于记录一个元素的状态</li><li>height: 0;            将元素高度设为 0 ，并消除边框</li><li>filter: blur(0);      CSS3属性，将一个元素的模糊度设置为0，从而使这个元素“消失”在页面中</li></ul><h3 id="rgba-和-opacity-的透明效果有什么不同？"><a href="#rgba-和-opacity-的透明效果有什么不同？" class="headerlink" title="rgba() 和 opacity 的透明效果有什么不同？"></a>rgba() 和 opacity 的透明效果有什么不同？</h3><p>rgba()和 opacity 都能实现透明效果</p><ul><li><p>opacity 作用于元素以及元素内的所有内容（包括文字）的透明度</p></li><li><p>rgba() 只作用于元素自身的颜色或其背景色，子元素不会继承透明效果</p><p>css样式继承拓展：<a href="https://link.jianshu.com/?t=http://www.cnblogs.com/thislbq/p/5882105.html" target="_blank" rel="noopener">http://www.cnblogs.com/thislbq/p/5882105.html</a></p></li></ul><h3 id="css-属性-content-有什么作用？"><a href="#css-属性-content-有什么作用？" class="headerlink" title="css 属性 content 有什么作用？"></a>css 属性 content 有什么作用？</h3><p>content 属性专门应用在 before/after 伪元素上，用于插入额外内容或样式</p><h3 id="请解释一下-CSS3-的-Flexbox（弹性盒布局模型）以及适用场景？"><a href="#请解释一下-CSS3-的-Flexbox（弹性盒布局模型）以及适用场景？" class="headerlink" title="请解释一下 CSS3 的 Flexbox（弹性盒布局模型）以及适用场景？"></a>请解释一下 CSS3 的 Flexbox（弹性盒布局模型）以及适用场景？</h3><p>Flexbox 用于不同尺寸屏幕中创建可自动扩展和收缩布局</p><h3 id="经常遇到的浏览器的JS兼容性有哪些？解决方法是什么？"><a href="#经常遇到的浏览器的JS兼容性有哪些？解决方法是什么？" class="headerlink" title="经常遇到的浏览器的JS兼容性有哪些？解决方法是什么？"></a>经常遇到的浏览器的JS兼容性有哪些？解决方法是什么？</h3><ul><li>当前样式：getComputedStyle(el, null) VS el.currentStyle</li><li>事件对象：e VS window.event</li><li>鼠标坐标：e.pageX, e.pageY VS window.event.x, window.event.y</li><li>按键码：e.which VS event.keyCode</li><li>文本节点：el.textContent VS el.innerText</li></ul><p>在列的父元素上使用这个背景图进行Y轴的铺放，从而实现一种等高列的假像</p><ul><li>模仿表格布局等高列效果：兼容性不好，在ie6-7无法正常运行</li><li>css3 flexbox 布局： .container{display: flex; align-items: stretch;}</li></ul><h3 id="在CSS样式中常使用-px、em-在表现上有什么区别？"><a href="#在CSS样式中常使用-px、em-在表现上有什么区别？" class="headerlink" title="在CSS样式中常使用 px、em 在表现上有什么区别？"></a>在CSS样式中常使用 px、em 在表现上有什么区别？</h3><ul><li>px 相对于显示器屏幕分辨率，无法用浏览器字体放大功能</li><li>em 值并不是固定的，会继承父级的字体大小： em = 像素值 / 父级font-size</li></ul><h3 id="为什么要初始化CSS样式？"><a href="#为什么要初始化CSS样式？" class="headerlink" title="为什么要初始化CSS样式？"></a>为什么要初始化CSS样式？</h3><ul><li>不同浏览器对有些标签样式的默认值解析不同</li><li>不初始化CSS会造成各现浏览器之间的页面显示差异</li><li>可以使用 reset.css 或 Normalize.css 做 CSS 初始化</li></ul><ul><li><p>去掉标签的默认样式如：margin,padding，其他浏览器默认解析字体大小，字体设置。</p></li><li><p>当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化</p></li></ul><h3 id="设置css样式的三种方式？"><a href="#设置css样式的三种方式？" class="headerlink" title="设置css样式的三种方式？"></a>设置css样式的三种方式？</h3><p>外部样式表，引入一个外部css文件<br>内部样式表，将css代码放在<head><meta name="generator" content="Hexo 3.9.0">标签内部<br>内联样式，将css样式直接定义在html元素内部</head></p><h3 id="介绍使用过的-CSS-预处理器？"><a href="#介绍使用过的-CSS-预处理器？" class="headerlink" title="介绍使用过的 CSS 预处理器？"></a>介绍使用过的 CSS 预处理器？</h3><ul><li>CSS 预处理器基本思想：为 CSS 增加了一些编程的特性（变量、逻辑判断、函数等）</li><li>开发者使用这种语言进行进行 Web 页面样式设计，再编译成正常的 CSS 文件使用</li><li>使用 CSS 预处理器，可以使 CSS 更加简洁、适应性更强、可读性更佳，无需考虑兼容性</li><li>最常用的 CSS 预处理器语言包括：Sass（SCSS）和 LESS</li></ul><h3 id="CSS优化、提高性能的方法有哪些？"><a href="#CSS优化、提高性能的方法有哪些？" class="headerlink" title="CSS优化、提高性能的方法有哪些？"></a>CSS优化、提高性能的方法有哪些？</h3><ul><li>多个css合并，尽量减少HTTP请求</li><li>将css文件放在页面最上面</li><li>移除空的css规则</li><li>避免使用CSS表达式</li><li>选择器优化嵌套，尽量避免层级过深</li><li>充分利用css继承属性，减少代码量</li><li>抽象提取公共样式，减少代码量</li><li>属性值为0时，不加单位</li><li>属性值为小于1的小数时，省略小数点前面的0</li><li>css雪碧图</li></ul><h3 id="浏览器是怎样解析CSS选择器的？"><a href="#浏览器是怎样解析CSS选择器的？" class="headerlink" title="浏览器是怎样解析CSS选择器的？"></a>浏览器是怎样解析CSS选择器的？</h3><p>浏览器解析 CSS 选择器的方式是从右到左</p><h3 id="在网页中的应该使用奇数还是偶数的字体？"><a href="#在网页中的应该使用奇数还是偶数的字体？" class="headerlink" title="在网页中的应该使用奇数还是偶数的字体？"></a>在网页中的应该使用奇数还是偶数的字体？</h3><p>在网页中的应该使用“偶数”字体：</p><ul><li>偶数字号相对更容易和 web 设计的其他部分构成比例关系</li><li>使用奇数号字体时文本段落无法对齐</li><li>宋体的中文网页排布中使用最多的就是 12 和 14</li></ul><h3 id="margin和padding分别适合什么场景使用？"><a href="#margin和padding分别适合什么场景使用？" class="headerlink" title="margin和padding分别适合什么场景使用？"></a>margin和padding分别适合什么场景使用？</h3><ul><li>需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin</li><li>需要在border内测添加空白，且空白处需要背景（色）时，使用 padding</li></ul><h3 id="抽离样式模块怎么写，说出思路？"><a href="#抽离样式模块怎么写，说出思路？" class="headerlink" title="抽离样式模块怎么写，说出思路？"></a>抽离样式模块怎么写，说出思路？</h3><p>CSS可以拆分成2部分：公共CSS 和 业务CSS：</p><ul><li>网站的配色，字体，交互提取出为公共CSS。这部分CSS命名不应涉及具体的业务</li><li>对于业务CSS，需要有统一的命名，使用公用的前缀。可以参考面向对象的CSS</li></ul><h3 id="元素竖向的百分比设定是相对于容器的高度吗？"><a href="#元素竖向的百分比设定是相对于容器的高度吗？" class="headerlink" title="元素竖向的百分比设定是相对于容器的高度吗？"></a>元素竖向的百分比设定是相对于容器的高度吗？</h3><p>元素竖向的百分比设定是相对于容器的宽度，而不是高度</p><h3 id="全屏滚动的原理是什么？-用到了CSS的那些属性？"><a href="#全屏滚动的原理是什么？-用到了CSS的那些属性？" class="headerlink" title="全屏滚动的原理是什么？ 用到了CSS的那些属性？"></a>全屏滚动的原理是什么？ 用到了CSS的那些属性？</h3><ul><li>原理类似图片轮播原理，超出隐藏部分，滚动时显示</li><li>可能用到的CSS属性：overflow:hidden; transform:translate(100%, 100%); display:none;</li></ul><h3 id="什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？"><a href="#什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？" class="headerlink" title="什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？"></a>什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？</h3><ul><li>响应式设计就是网站能够兼容多个终端，而不是为每个终端做一个特定的版本</li><li>基本原理是利用CSS3媒体查询，为不同尺寸的设备适配不同样式</li><li>对于低版本的IE，可采用JS获取屏幕宽度，然后通过resize方法来实现兼容：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">window</span>).resize(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  screenRespond();</span><br><span class="line">&#125;);</span><br><span class="line">screenRespond();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">screenRespond</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> screenWidth = $(<span class="built_in">window</span>).width();</span><br><span class="line"><span class="keyword">if</span>(screenWidth &lt;= <span class="number">1800</span>)&#123;</span><br><span class="line">  $(<span class="string">"body"</span>).attr(<span class="string">"class"</span>, <span class="string">"w1800"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(screenWidth &lt;= <span class="number">1400</span>)&#123;</span><br><span class="line">  $(<span class="string">"body"</span>).attr(<span class="string">"class"</span>, <span class="string">"w1400"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(screenWidth &gt; <span class="number">1800</span>)&#123;</span><br><span class="line">  $(<span class="string">"body"</span>).attr(<span class="string">"class"</span>, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="什么是视差滚动效果，如何给每页做不同的动画？"><a href="#什么是视差滚动效果，如何给每页做不同的动画？" class="headerlink" title="什么是视差滚动效果，如何给每页做不同的动画？"></a>什么是视差滚动效果，如何给每页做不同的动画？</h3><ul><li>视差滚动是指多层背景以不同的速度移动，形成立体的运动效果，具有非常出色的视觉体验</li><li>一般把网页解剖为：背景层、内容层和悬浮层。当滚动鼠标滚轮时，各图层以不同速度移动，形成视差的</li></ul><ul><li>实现原理<ul><li>以 “页面滚动条” 作为 “视差动画进度条”</li><li>以 “滚轮刻度” 当作 “动画帧度” 去播放动画的</li><li>监听 mousewheel 事件，事件被触发即播放动画，实现“翻页”效果</li></ul></li></ul><h3 id="a标签上四个伪类的执行顺序是怎么样的？"><a href="#a标签上四个伪类的执行顺序是怎么样的？" class="headerlink" title="a标签上四个伪类的执行顺序是怎么样的？"></a>a标签上四个伪类的执行顺序是怎么样的？</h3><figure class="highlight plain"><figcaption><span>> visited > hover > active```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- L-V-H-A love hate 用喜欢和讨厌两个词来方便记忆</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 伪元素和伪类的区别和作用？</span><br><span class="line"></span><br><span class="line">- 伪元素 -- 在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。</span><br><span class="line">- 它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：</span><br></pre></td></tr></table></figure><p>p::before {content:”第一章：”;}<br>p::after {content:”Hot!”;}<br>p::first-line {background:red;}<br>p::first-letter {font-size:30px;}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 伪类 -- 将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：</span><br></pre></td></tr></table></figure><p>a:hover {color: #FF00FF}<br>p:first-child {color: red}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### ::before 和 :after 中双冒号和单冒号有什么区别？</span><br><span class="line"></span><br><span class="line">* 在 CSS 中伪类一直用 : 表示，如 :hover, :active 等</span><br><span class="line">* 伪元素在CSS1中已存在，当时语法是用 : 表示，如 :before 和 :after</span><br><span class="line">* 后来在CSS3中修订，伪元素用 :: 表示，如 ::before 和 ::after，以此区分伪元素和伪类</span><br><span class="line">* 由于低版本IE对双冒号不兼容，开发者为了兼容性各浏览器，继续使使用 :after 这种老语法表示伪元素</span><br><span class="line">* 综上所述：::before 是 CSS3 中写伪元素的新语法； :after 是 CSS1 中存在的、兼容IE的老语法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 如何修改Chrome记住密码后自动填充表单的黄色背景？</span><br><span class="line"></span><br><span class="line">- 产生原因：由于Chrome默认会给自动填充的input表单加上 input:-webkit-autofill 私有属性造成的</span><br><span class="line">- 解决方案1：在form标签上直接关闭了表单的自动填充：autocomplete=&quot;off&quot;</span><br><span class="line">- 解决方案2：input:-webkit-autofill &#123; background-color: transparent; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### input [type=search] 搜索框右侧小图标如何美化？</span><br><span class="line"></span><br><span class="line">```css</span><br><span class="line">input[type=&quot;search&quot;]::-webkit-search-cancel-button&#123;</span><br><span class="line">  -webkit-appearance: none;</span><br><span class="line">  height: 15px;</span><br><span class="line">  width: 15px;</span><br><span class="line">  border-radius: 8px;</span><br><span class="line">  background:url(&quot;images/searchicon.png&quot;) no-repeat 0 0;</span><br><span class="line">  background-size: 15px 15px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="网站图片文件，如何点击下载？而非点击预览？"><a href="#网站图片文件，如何点击下载？而非点击预览？" class="headerlink" title="网站图片文件，如何点击下载？而非点击预览？"></a>网站图片文件，如何点击下载？而非点击预览？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;logo.jpg&quot; download&gt;下载&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;logo.jpg&quot; download=&quot;网站LOGO&quot; &gt;下载&lt;/a&gt;</span><br></pre></td></tr></table></figure><h3 id="iOS-safari-如何阻止“橡皮筋效果”？"><a href="#iOS-safari-如何阻止“橡皮筋效果”？" class="headerlink" title="iOS safari 如何阻止“橡皮筋效果”？"></a>iOS safari 如何阻止“橡皮筋效果”？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> stopScrolling = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        event.preventDefault();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'touchstart'</span>, stopScrolling, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'touchmove'</span>, stopScrolling, <span class="literal">false</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="你对-line-height-是如何理解的？"><a href="#你对-line-height-是如何理解的？" class="headerlink" title="你对 line-height 是如何理解的？"></a>你对 line-height 是如何理解的？</h3><ul><li>line-height 指一行字的高度，包含了字间距，实际上是下一行基线到上一行基线距离</li><li>如果一个标签没有定义 height 属性，那么其最终表现的高度是由 line-height 决定的</li><li>一个容器没有设置高度，那么撑开容器高度的是 line-height 而不是容器内的文字内容</li><li>把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中</li><li>line-height 和 height 都能撑开一个高度，height 会触发 haslayout，而 line-height 不会</li></ul><h3 id="line-height-三种赋值方式有何区别？（带单位、纯数字、百分比）"><a href="#line-height-三种赋值方式有何区别？（带单位、纯数字、百分比）" class="headerlink" title="line-height 三种赋值方式有何区别？（带单位、纯数字、百分比）"></a>line-height 三种赋值方式有何区别？（带单位、纯数字、百分比）</h3><ul><li>带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高</li><li>纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px</li><li>百分比：将计算后的值传递给后代</li></ul><h3 id="怎么让Chrome支持小于12px-的文字？"><a href="#怎么让Chrome支持小于12px-的文字？" class="headerlink" title="怎么让Chrome支持小于12px 的文字？"></a>怎么让Chrome支持小于12px 的文字？</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.shrink</span>&#123;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>:<span class="built_in">scale</span>(0.8);</span><br><span class="line">  <span class="attribute">-o-transform</span>:<span class="built_in">scale</span>(1);</span><br><span class="line">  <span class="attribute">display</span>:inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观</li><li>使用12px及12px以上字体大小：为了兼容各大主流浏览器，建议设计美工图时候设置大于或等于12px的字体大小，如果是接单的这个时候就需要给客户讲解小于12px浏览器不兼容等事宜</li><li>继续使用小于12px字体大小样式设置：如果不考虑chrome可以不用考虑兼容，同时在设置小于12px对象设置-webkit-text-size-adjust:none，做到最大兼容考虑</li></ul><h3 id="让页面里的字体变清晰，变细用CSS怎么做？（IOS手机浏览器字体齿轮设置）"><a href="#让页面里的字体变清晰，变细用CSS怎么做？（IOS手机浏览器字体齿轮设置）" class="headerlink" title="让页面里的字体变清晰，变细用CSS怎么做？（IOS手机浏览器字体齿轮设置）"></a>让页面里的字体变清晰，变细用CSS怎么做？（IOS手机浏览器字体齿轮设置）</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-font-smoothing</span>: <span class="selector-tag">antialiased</span>;</span><br></pre></td></tr></table></figure><h3 id="font-style-属性-oblique-是什么意思？"><a href="#font-style-属性-oblique-是什么意思？" class="headerlink" title="font-style 属性 oblique 是什么意思？"></a>font-style 属性 oblique 是什么意思？</h3><p>font-style: oblique; 使没有 italic 属性的文字实现倾斜</p><h3 id="display-inline-block-什么时候会显示间隙？"><a href="#display-inline-block-什么时候会显示间隙？" class="headerlink" title="display:inline-block 什么时候会显示间隙？"></a>display:inline-block 什么时候会显示间隙？</h3><ul><li>相邻的 inline-block 元素之间有换行或空格分隔的情况下会产生间距</li><li>非 inline-block 水平元素设置为 inline-block 也会有水平间距</li><li>可以借助 vertical-align:top; 消除垂直间隙</li><li>可以在父级加 font-size：0; 在子元素里设置需要的字体大小，消除垂直间隙</li><li>把 li 标签写到同一行可以消除垂直间隙，但代码可读性差</li></ul><h3 id="去除-inline-block-元素间间距的方法"><a href="#去除-inline-block-元素间间距的方法" class="headerlink" title="去除 inline-block 元素间间距的方法"></a>去除 inline-block 元素间间距的方法</h3><ul><li>移除空格</li><li>使用 margin 负值</li><li>使用 font-size:0</li><li>letter-spacing</li><li>word-spacing</li></ul><p>解析：更详细的介绍请看<a href="https://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%E5%8E%BB%E9%99%A4%E9%97%B4%E8%B7%9D/" target="_blank" rel="noopener">去除 inline-block 元素间间距的 N 种方法</a></p><h3 id="那么问题来了，浏览器还有默认的天生-inline-block-元素（拥有内在尺寸，可设置高宽，但不会自动换行），有哪些？"><a href="#那么问题来了，浏览器还有默认的天生-inline-block-元素（拥有内在尺寸，可设置高宽，但不会自动换行），有哪些？" class="headerlink" title="那么问题来了，浏览器还有默认的天生 inline-block 元素（拥有内在尺寸，可设置高宽，但不会自动换行），有哪些？"></a>那么问题来了，浏览器还有默认的天生 inline-block 元素（拥有内在尺寸，可设置高宽，但不会自动换行），有哪些？</h3><p><code>&lt;input&gt; 、&lt;img&gt; 、&lt;button&gt; 、&lt;texterea&gt; 、&lt;label&gt;。</code></p><h3 id="overflow-scroll-时不能平滑滚动的问题怎么处理？"><a href="#overflow-scroll-时不能平滑滚动的问题怎么处理？" class="headerlink" title="overflow: scroll 时不能平滑滚动的问题怎么处理？"></a>overflow: scroll 时不能平滑滚动的问题怎么处理？</h3><p>监听滚轮事件，然后滚动到一定距离时用 jquery 的 animate 实现平滑效果。</p><h3 id="一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度"><a href="#一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度" class="headerlink" title="一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度"></a>一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- 方案1：</span><br><span class="line">  .sub &#123; height: calc(100%-100px); &#125;</span><br><span class="line">- 方案2：</span><br><span class="line">  .container &#123; position:relative; &#125;</span><br><span class="line">  .sub &#123; position: absolute; top: 100px; bottom: 0; &#125;</span><br><span class="line">- 方案3：</span><br><span class="line">  .container &#123; display:flex; flex-direction:column; &#125;</span><br><span class="line">  .sub &#123; flex:1; &#125;</span><br></pre></td></tr></table></figure><h3 id="CSS选择符有哪些？哪些属性可以继承？-1"><a href="#CSS选择符有哪些？哪些属性可以继承？-1" class="headerlink" title="CSS选择符有哪些？哪些属性可以继承？"></a>CSS选择符有哪些？哪些属性可以继承？</h3><ul><li>id选择器（ # myid）</li><li>类选择器（.myclassname）</li><li>标签选择器（div, h1, p）</li><li>相邻选择器（h1 + p）</li><li>子选择器（ul &gt; li）</li><li>后代选择器（li a）</li><li>通配符选择器（ * ）</li><li>属性选择器（a[rel = “external”]）</li><li>伪类选择器（a:hover, li:nth-child）</li><li>可继承的样式： font-size font-family color, UL LI DL DD DT</li><li>不可继承的样式：border padding margin width height</li></ul><h3 id="CSS3新增伪类有那些？-1"><a href="#CSS3新增伪类有那些？-1" class="headerlink" title="CSS3新增伪类有那些？"></a>CSS3新增伪类有那些？</h3><ul><li><p>p:first-of-type    选择属于其父元素的首个 </p><p> 元素的每个 </p><p> 元素。</p></li><li><p>p:last-of-type    选择属于其父元素的最后 </p><p> 元素的每个 </p><p> 元素。</p></li><li><p>p:only-of-type    选择属于其父元素唯一的 </p><p> 元素的每个 </p><p> 元素。</p></li><li><p>p:only-child        选择属于其父元素的唯一子元素的每个 </p><p> 元素。</p></li><li><p>p:nth-child(2)    选择属于其父元素的第二个子元素的每个 </p><p> 元素。</p></li><li><p>:after            在元素之前添加内容,也可以用来做清除浮动。</p></li><li><p>:before            在元素之后添加内容</p></li><li><p>:enabled          </p></li><li><p>:disabled         控制表单控件的禁用状态。</p></li><li><p>:checked        单选框或复选框被选中</p></li></ul><h3 id="position的值relative和absolute定位原点是？-1"><a href="#position的值relative和absolute定位原点是？-1" class="headerlink" title="position的值relative和absolute定位原点是？"></a>position的值relative和absolute定位原点是？</h3><ul><li><p>absolute</p><p>生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。</p></li><li><p>fixed （老IE不支持）</p><p>生成绝对定位的元素，相对于浏览器窗口进行定位。</p></li><li><p>relative</p><p>生成相对定位的元素，相对于其正常位置进行定位。</p></li><li><p>static</p><p>默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。</p></li><li><p>inherit</p><p>规定从父元素继承 position 属性的值</p></li></ul><h3 id="请解释一下CSS3的Flexbox（弹性盒布局模型）-以及适用场景？"><a href="#请解释一下CSS3的Flexbox（弹性盒布局模型）-以及适用场景？" class="headerlink" title="请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？"></a>请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？</h3><ul><li>一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间</li><li>较为复杂的布局还可以通过嵌套一个伸缩容器（flex container）来实现</li><li>采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。</li><li>它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”</li><li>常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做局中，能对不同屏幕大小自适应</li><li>在布局上有了比以前更加灵活的空间</li></ul><h3 id="css多列等高如何实现？"><a href="#css多列等高如何实现？" class="headerlink" title="css多列等高如何实现？"></a>css多列等高如何实现？</h3><ul><li>利用padding-bottom|margin-bottom正负值相抵；</li><li>设置父容器设置超出隐藏（overflow:hidden），这样子父容器的高度就还是它里面的列没有设定padding-bottom时的高度</li><li>当它里面的任 一列高度增加了，则父容器的高度被撑到里面最高那列的高度</li><li>其他比这列矮的列会用它们的padding-bottom补偿这部分高度差</li></ul><h3 id="经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧"><a href="#经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧" class="headerlink" title="经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧"></a>经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧</h3><ul><li>png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8</li><li>浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一</li><li>IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大</li><li>浮动ie产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 100px;}</li><li>这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)</li><li>渐进识别的方式，从总体中逐渐排除局部</li><li>首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。</li><li>接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.bb&#123;</span><br><span class="line">      background-color:red;/*所有识别*/</span><br><span class="line">      background-color:#00deff\9; /*IE6、7、8识别*/</span><br><span class="line">      +background-color:#a200ff;/*IE6、7识别*/</span><br><span class="line">      _background-color:#1e0bd1;/*IE6识别*/</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>IE下,可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性;</li><li>Firefox下,只能使用getAttribute()获取自定义属性</li><li>解决方法:统一通过getAttribute()获取自定义属性。</li><li>IE下,even对象有x,y属性,但是没有pageX,pageY属性</li><li>Firefox下,event对象有pageX,pageY属性,但是没有x,y属性</li><li>解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。</li><li>Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,</li><li>可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。</li><li>超链接访问过后hover样式就不出现了。被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:</li><li><code>L-V-H-A :  a:link {} a:visited {} a:hover {} a:active {}</code></li></ul><h3 id="absolute的containing-block-容器块-计算方式跟正常流有什么不同？"><a href="#absolute的containing-block-容器块-计算方式跟正常流有什么不同？" class="headerlink" title="absolute的containing block(容器块)计算方式跟正常流有什么不同？"></a>absolute的containing block(容器块)计算方式跟正常流有什么不同？</h3><ul><li><p>无论属于哪种，都要先找到其祖先元素中最近的 position 值不为 static 的元素，然后再判断：</p><p>1、若此元素为 inline 元素，则 containing block为能够包含这个元素生成的第一个和最后一个 inline box 的 padding box (除 margin, border 外的区域) 的最小矩形；</p><p>2、否则,则由这个祖先元素的 padding box 构成。如果都找不到，则为 initial containing block。</p></li><li><p>补充：</p><ol><li><p>static(默认的)/relative：简单说就是它的父元素的内容框（即去掉padding的部分）</p></li><li><p>absolute: 向上找最近的定位为absolute/relative的元素</p></li><li><p>fixed: 它的containing block一律为根元素(html/body)，根元素也是initial containing block</p></li></ol></li></ul><h3 id="CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？"><a href="#CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？" class="headerlink" title="CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？"></a>CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？</h3><ul><li>对于普通元素visibility:collapse;会将元素完全隐藏,不占据页面布局空间,与display:none;表现相同.</li><li>如果目标元素为table,visibility:collapse;将table隐藏,但是会占据页面布局空间.</li><li>仅在Firefox下起作用,IE会显示元素,Chrome会将元素隐藏,但是占据空间.</li></ul><h3 id="position跟display、margin-collapse、overflow、float这些特性相互叠加后会怎么样？"><a href="#position跟display、margin-collapse、overflow、float这些特性相互叠加后会怎么样？" class="headerlink" title="position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？"></a>position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？</h3><ul><li>如果元素的display为none,那么元素不被渲染,position,float不起作用,</li><li>如果元素拥有position:absolute;或者position:fixed;属性那么元素将为绝对定位,float不起作用.</li><li>如果元素float属性不是none,元素会脱离文档流,根据float属性值来显示.有浮动,绝对定位,inline-block属性的元素,margin不会和垂直方向上的其他元素margin折叠</li></ul><h3 id="css定义的权重-1"><a href="#css定义的权重-1" class="headerlink" title="css定义的权重"></a>css定义的权重</h3><ul><li>以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下例子是演示各种定义的权重值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*权重为1*/</span><br><span class="line">div&#123;</span><br><span class="line">&#125;</span><br><span class="line">/*权重为10*/</span><br><span class="line">.class1&#123;</span><br><span class="line">&#125;</span><br><span class="line">/*权重为100*/</span><br><span class="line">#id1&#123;</span><br><span class="line">&#125;</span><br><span class="line">/*权重为100+1=101*/</span><br><span class="line">#id1 div&#123;</span><br><span class="line">&#125;</span><br><span class="line">/*权重为10+1=11*/</span><br><span class="line">.class1 div&#123;</span><br><span class="line">&#125;</span><br><span class="line">/*权重为10+10+1=21*/</span><br><span class="line">.class1 .class2 div&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现</li></ul><h3 id="移动端的布局用过媒体查询吗？"><a href="#移动端的布局用过媒体查询吗？" class="headerlink" title="移动端的布局用过媒体查询吗？"></a>移动端的布局用过媒体查询吗？</h3><ul><li>假设你现在正用一台显示设备来阅读这篇文章，同时你也想把它投影到屏幕上，或者打印出来，而显示设备、屏幕投影和打印等这些媒介都有自己的特点，CSS就是为文档提供在不同媒介上展示的适配方法</li><li><!-- link元素中的CSS媒体查询 --><ul><li>当媒体查询为真时，相关的样式表或样式规则会按照正常的级联规被应用。</li><li>当媒体查询返回假， <link> 标签上带有媒体查询的样式表 仍将被下载 （只不过不会被应用）</li></ul></li><li><link rel="stylesheet" media="(max-width: 800px)" href="example.css"></li><li><!-- 样式表中的CSS媒体查询 --><ul><li>包含了一个媒体类型和至少一个使用 宽度、高度和颜色等媒体属性来限制样式表范围的表达式</li><li>CSS3加入的媒体查询使得无需修改内容便可以使样式应用于某些特定的设备范围</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">@media (min-width: 700px) and (orientation: landscape)&#123;</span><br><span class="line">  .sidebar &#123;</span><br><span class="line">    display: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="使用-CSS-预处理器吗？喜欢那个？"><a href="#使用-CSS-预处理器吗？喜欢那个？" class="headerlink" title="使用 CSS 预处理器吗？喜欢那个？"></a>使用 CSS 预处理器吗？喜欢那个？</h3><p>SASS (SASS、LESS没有本质区别，只因为团队前端都是用的SASS)</p><h3 id="CSS优化、提高性能的方法有哪些？-1"><a href="#CSS优化、提高性能的方法有哪些？-1" class="headerlink" title="CSS优化、提高性能的方法有哪些？"></a>CSS优化、提高性能的方法有哪些？</h3><ul><li>关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）；</li><li>如果规则拥有 ID 选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）；</li><li>提取项目的通用公有样式，增强可复用性，按模块编写组件；增强项目的协同开发性、可维护性和可扩展性;</li><li>使用预处理工具或构建工具（gulp对css进行语法检查、自动补前缀、打包压缩、自动优雅降级）</li></ul><h3 id="浏览器是怎样解析CSS选择器的？-1"><a href="#浏览器是怎样解析CSS选择器的？-1" class="headerlink" title="浏览器是怎样解析CSS选择器的？"></a>浏览器是怎样解析CSS选择器的？</h3><ul><li>样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素</li><li>只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则</li></ul><h3 id="margin和padding分别适合什么场景使用？-1"><a href="#margin和padding分别适合什么场景使用？-1" class="headerlink" title="margin和padding分别适合什么场景使用？"></a>margin和padding分别适合什么场景使用？</h3><ul><li>margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。</li><li>margin用于布局分开元素使元素与元素互不相干；</li><li>padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段</li></ul><h3 id="before-和-after中双冒号和单冒号-有什么区别？解释一下这2个伪元素的作用"><a href="#before-和-after中双冒号和单冒号-有什么区别？解释一下这2个伪元素的作用" class="headerlink" title="::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用"></a>::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用</h3><ul><li>单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）</li><li>双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法</li><li>比如:first-line、:first-letter、:before、:after等，而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。</li><li>想让插入的内容出现在其它内容前，使用::before，否者，使用::after；在代码顺序上，::after生成的内容也比::before生成的内容靠后。</li><li>如果按堆栈视角，::after生成的内容会在::before生成的内容之上</li></ul><h3 id="如何修改chrome记住密码后自动填充表单的黄色背景-？"><a href="#如何修改chrome记住密码后自动填充表单的黄色背景-？" class="headerlink" title="如何修改chrome记住密码后自动填充表单的黄色背景 ？"></a>如何修改chrome记住密码后自动填充表单的黄色背景 ？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">input:-webkit-autofill, textarea:-webkit-autofill, select:-webkit-autofill &#123;</span><br><span class="line">  background-color: rgb(250, 255, 189); /* #FAFFBD; */</span><br><span class="line">  background-image: none;</span><br><span class="line">  color: rgb(0, 0, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="让页面里的字体变清晰，变细用CSS怎么做？"><a href="#让页面里的字体变清晰，变细用CSS怎么做？" class="headerlink" title="让页面里的字体变清晰，变细用CSS怎么做？"></a>让页面里的字体变清晰，变细用CSS怎么做？</h3><p>-webkit-font-smoothing: antialiased;</p><h3 id="font-style属性可以让它赋值为“oblique”-oblique是什么意思？"><a href="#font-style属性可以让它赋值为“oblique”-oblique是什么意思？" class="headerlink" title="font-style属性可以让它赋值为“oblique” oblique是什么意思？"></a>font-style属性可以让它赋值为“oblique” oblique是什么意思？</h3><p>倾斜的字体样式</p><h3 id="position-fixed-在android下无效怎么处理？"><a href="#position-fixed-在android下无效怎么处理？" class="headerlink" title="position:fixed;在android下无效怎么处理？"></a>position:fixed;在android下无效怎么处理？</h3><ul><li>fixed的元素是相对整个页面固定位置的，你在屏幕上滑动只是在移动这个所谓的viewport，原来的网页还好好的在那，fixed的内容也没有变过位置，</li><li>所以说并不是iOS不支持fixed，只是fixed的元素不是相对手机屏幕固定的</li><li><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;/&gt;</code></li></ul><h3 id="如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）"><a href="#如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）" class="headerlink" title="如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）"></a>如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）</h3><p>多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms</p><h3 id="什么是Cookie-隔离？（或者说：请求资源的时候不要让它带cookie怎么做）"><a href="#什么是Cookie-隔离？（或者说：请求资源的时候不要让它带cookie怎么做）" class="headerlink" title="什么是Cookie 隔离？（或者说：请求资源的时候不要让它带cookie怎么做）"></a>什么是Cookie 隔离？（或者说：请求资源的时候不要让它带cookie怎么做）</h3><ul><li>如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，所以不如隔离开。</li><li>因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的</li><li>同时这种方式不会将cookie传入Web Server，也减少了Web Server对cookie的处理分析环节，提高了webserver的http请求的解析速度。</li></ul><h3 id="什么是CSS-预处理器-后处理器？"><a href="#什么是CSS-预处理器-后处理器？" class="headerlink" title="什么是CSS 预处理器 / 后处理器？"></a>什么是CSS 预处理器 / 后处理器？</h3><ul><li>预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。</li><li>后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</li></ul><h3 id="盒模型：content（元素内容）-padding（内边距）-border（边框）-margin（外边距）"><a href="#盒模型：content（元素内容）-padding（内边距）-border（边框）-margin（外边距）" class="headerlink" title="盒模型：content（元素内容） + padding（内边距） + border（边框） + margin（外边距）"></a>盒模型：content（元素内容） + padding（内边距） + border（边框） + margin（外边距）</h3><blockquote><p>延伸： <code>box-sizing</code></p></blockquote><ul><li><code>content-box</code>：默认值，总宽度 = <code>margin</code> + <code>border</code> + <code>padding</code> + <code>width</code></li><li><code>border-box</code>：盒子宽度包含 <code>padding</code> 和 <code>border</code>，<code>总宽度 = margin + width</code></li><li><code>inherit</code>：从父元素继承 <code>box-sizing</code> 属性</li></ul><h3 id="BFC、IFC、GFC、FFC：FC（Formatting-Contexts），格式化上下文"><a href="#BFC、IFC、GFC、FFC：FC（Formatting-Contexts），格式化上下文" class="headerlink" title="BFC、IFC、GFC、FFC：FC（Formatting Contexts），格式化上下文"></a>BFC、IFC、GFC、FFC：FC（Formatting Contexts），格式化上下文</h3><blockquote><p><code>BFC</code>：块级格式化上下文，容器里面的子元素不会在布局上影响到外面的元素，反之也是如此(按照这个理念来想，只要脱离文档流，肯定就能产生 <code>BFC</code>)。产生 <code>BFC</code> 方式如下</p></blockquote><ul><li><code>float</code> 的值不为 <code>none</code>。</li><li><code>overflow</code> 的值不为 <code>visible</code>。</li><li><code>position</code> 的值不为 <code>relative</code> 和 <code>static</code>。</li><li><code>display</code> 的值为 <code>table-cell</code>, <code>table-caption</code>, <code>inline-block</code>中的任何一个</li></ul><blockquote><p>用处？常见的多栏布局，结合块级别元素浮动，里面的元素则是在一个相对隔离的环境里运行</p></blockquote><blockquote><p><code>IFC</code>：内联格式化上下文，<code>IFC</code> 的 <code>line</code> <code>box</code>（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的 <code>padding/margin</code> 影响)。</p></blockquote><blockquote><p><code>IFC</code>中的<code>line box</code>一般左右都贴紧整个 <code>IFC</code>，但是会因为 <code>float</code> 元素而扰乱。<code>float</code> 元素会位于 IFC 与 <code>line box</code> 之间，使得 <code>line box</code> 宽度缩短。 同个 <code>ifc</code> 下的多个 <code>line box</code> 高度会不同。 <code>IFC</code>中时不可能有块级元素的，当插入块级元素时（如 <code>p</code> 中插入 <code>div</code>）会产生两个匿名块与 <code>div</code> 分隔开，即产生两个 <code>IFC</code> ，每个 <code>IFC</code> 对外表现为块级元素，与 <code>div</code> 垂直排列。</p></blockquote><p>用处？</p><ul><li>水平居中：当一个块要在环境中水平居中时，设置其为 <code>inline-block</code> 则会在外层产生<code>IFC</code>，通过 <code>text-align</code> 则可以使其水平居中。</li><li>垂直居中：创建一个 <code>IFC</code>，用其中一个元素撑开父元素的高度，然后设置其 <code>vertical-align</code>: <code>middle</code>，其他行内元素则可以在此父元素下垂直居中</li></ul><blockquote><ul><li><strong>GFC</strong>：网格布局格式化上下文（<code>display: grid</code>）</li><li><strong>FFC</strong>：自适应格式化上下文（<code>display: flex</code>）</li></ul></blockquote><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><ul><li><p>什么是 BFC</p><p>BFC（Block Formatting Context）格式化上下文，是 Web 页面中盒模型布局的 CSS 渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。</p></li><li><p>形成 BFC 的条件</p><ul><li>浮动元素，float 除 none 以外的值</li><li>定位元素，position（absolute，fixed）</li><li>display 为以下其中之一的值 inline-block，table-cell，table-caption</li><li>overflow 除了 visible 以外的值（hidden，auto，scroll）</li></ul></li><li><p>BFC 的特性</p><ul><li>内部的 Box 会在垂直方向上一个接一个的放置。</li><li>垂直方向上的距离由 margin 决定</li><li>bfc 的区域不会与 float 的元素区域重叠。</li><li>计算 bfc 的高度时，浮动元素也参与计算</li><li>bfc 就是页面上的一个独立容器，容器里面的子元素不会影响外面元素。</li></ul></li></ul><h3 id="对BFC规范-块级格式化上下文：block-formatting-context-的理解？"><a href="#对BFC规范-块级格式化上下文：block-formatting-context-的理解？" class="headerlink" title="对BFC规范(块级格式化上下文：block formatting context)的理解？"></a>对BFC规范(块级格式化上下文：block formatting context)的理解？</h3><ul><li>一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型</li><li>不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响</li></ul><h3 id="谈一谈你对CSS盒模型的认识及BFC"><a href="#谈一谈你对CSS盒模型的认识及BFC" class="headerlink" title="谈一谈你对CSS盒模型的认识及BFC"></a>谈一谈你对CSS盒模型的认识及BFC</h3><blockquote><p>专业的面试，一定会问 <code>CSS</code> 盒模型。对于这个题目，我们要回答一下几个方面：</p></blockquote><ol><li>基本概念：<code>content</code>、<code>padding</code>、<code>margin</code></li><li>标准盒模型、<code>IE</code>盒模型的区别。不要漏说了<code>IE</code>盒模型，通过这个问题，可以筛选一部分人</li><li><code>CSS</code>如何设置这两种模型（即：如何设置某个盒子为其中一个模型）？如果回答了上面的第二条，还会继续追问这一条。</li><li><code>JS</code>如何设置、获取盒模型对应的宽和高？这一步，已经有很多人答不上来了。</li><li>实例题：根据盒模型解释<strong>边距重叠</strong>。</li></ol><blockquote><p>前四个方面是逐渐递增，第五个方面，却鲜有人知。</p></blockquote><ol start="6"><li><code>BFC</code>（边距重叠解决方案）或<code>IFC</code>。</li></ol><blockquote><p>如果能回答第五条，就会引出第六条。<code>BFC</code>是面试频率较高的。</p></blockquote><p><strong>总结</strong>：以上几点，从上到下，知识点逐渐递增，知识面从理论、<code>CSS</code>、<code>JS</code>，又回到<code>CSS</code>理论</p><p>接下来，我们把上面的六条，依次讲解。</p><h3 id="标准盒模型和IE盒子模型"><a href="#标准盒模型和IE盒子模型" class="headerlink" title="标准盒模型和IE盒子模型"></a>标准盒模型和IE盒子模型</h3><p>标准盒子模型：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="http://img.smyhvae.com/2015-10-03-css-27.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p><code>IE</code>盒子模型：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="http://img.smyhvae.com/2015-10-03-css-30.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>上图显示：</p><blockquote><p>在 <code>CSS</code> 盒子模型 (<code>Box Model</code>) 规定了元素处理元素的几种方式：</p></blockquote><ul><li><code>width</code>和<code>height</code>：<strong>内容</strong>的宽度、高度（不是盒子的宽度、高度）。</li><li><code>padding</code>：内边距。</li><li><code>border</code>：边框。</li><li><code>margin</code>：外边距。</li></ul><blockquote><p><code>CSS</code>盒模型和<code>IE</code>盒模型的区别：</p></blockquote><ul><li>在<strong>标准盒子模型</strong>中，<strong>width 和 height 指的是内容区域</strong>的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。</li><li><strong>IE盒子模型</strong>中，<strong>width 和 height 指的是内容区域+border+padding</strong>的宽度和高度。</li></ul><p><strong>CSS如何设置这两种模型</strong></p><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置当前盒子为 标准盒模型（默认） */</span></span><br><span class="line">box-sizing: content-box;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置当前盒子为 IE盒模型 */</span></span><br><span class="line">box-sizing: border-box;</span><br></pre></td></tr></table></figure><blockquote><p>备注：盒子默认为标准盒模型。</p></blockquote><p><strong>JS如何设置、获取盒模型对应的宽和高</strong></p><blockquote><p>方式一：通过<code>DOM</code>节点的 <code>style</code> 样式获取</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.style.width/height;</span><br></pre></td></tr></table></figure><blockquote><p>缺点：通过这种方式，只能获取<strong>行内样式</strong>，不能获取<code>内嵌</code>的样式和<code>外链</code>的样式。</p></blockquote><p>这种方式有局限性，但应该了解。</p><blockquote><p>方式二（通用型）</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.getComputedStyle(element).width/height;</span><br></pre></td></tr></table></figure><blockquote><p>方式二能兼容 <code>Chrome</code>、火狐。是通用型方式。</p></blockquote><blockquote><p>方式三（IE独有的）</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.currentStyle.width/height;</span><br></pre></td></tr></table></figure><blockquote><p>和方式二相同，但这种方式只有IE独有。获取到的即时运行完之后的宽高（三种css样式都可以获取）。</p></blockquote><blockquote><p>方式四</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.getBoundingClientRect().width/height;</span><br></pre></td></tr></table></figure><blockquote><p>此 <code>api</code> 的作用是：获取一个元素的绝对位置。绝对位置是视窗 <code>viewport</code> 左上角的绝对位置。此 <code>api</code> 可以拿到四个属性：<code>left</code>、<code>top</code>、<code>width</code>、<code>height</code>。</p></blockquote><p><strong>总结：</strong></p><blockquote><p>上面的四种方式，要求能说出来区别，以及哪个的通用型更强。</p></blockquote><p><strong>margin塌陷/margin重叠</strong></p><p><strong>标准文档流中，竖直方向的margin不叠加，只取较大的值作为margin</strong>(水平方向的<code>margin</code>是可以叠加的，即水平方向没有塌陷现象)。</p><blockquote><p>PS：如果不在标准流，比如盒子都浮动了，那么两个盒子之间是没有<code>margin</code>重叠的现象的。</p></blockquote><blockquote><p>我们来看几个例子。</p></blockquote><p><strong>兄弟元素之间</strong></p><p>如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="http://img.smyhvae.com/20170805_0904.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>子元素和父元素之间</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        * &#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.father</span> &#123;</span></span><br><span class="line">            background: green;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/* 给儿子设置margin-top为10像素 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.son</span> &#123;</span></span><br><span class="line">            height: 100px;</span><br><span class="line">            margin-top: 10px;</span><br><span class="line">            background: red;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"father"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"son"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的代码中，儿子的<code>height</code>是 <code>100p</code>x，<code>magin-top</code> 是<code>10px</code>。注意，此时父亲的 <code>height</code> 是<code>100</code>，而不是<code>110</code>。因为儿子和父亲在竖直方向上，共一个<code>margin</code>。</p></blockquote><p>儿子这个盒子：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="http://img.smyhvae.com/20180305_2216.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>父亲这个盒子：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="http://img.smyhvae.com/20180305_2217.png" alt title>                </div>                <div class="image-caption"></div>            </figure><blockquote><p>上方代码中，如果我们给父亲设置一个属性：<code>overflow: hidden</code>，就可以避免这个问题，此时父亲的高度是110px，这个用到的就是BFC（下一段讲解）。</p></blockquote><p><strong>善于使用父亲的padding，而不是儿子的margin</strong></p><blockquote><p>其实，这一小段讲的内容与上一小段相同，都是讲父子之间的margin重叠。</p></blockquote><p>我们来看一个奇怪的现象。现在有下面这样一个结构：（<code>div</code>中放一个<code>p</code>）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的结构中，我们尝试通过给儿子<code>p</code>一个<code>margin-top:50px;</code>的属性，让其与父亲保持50px的上边距。结果却看到了下面的奇怪的现象：</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="http://img.smyhvae.com/20170806_1537.png" alt title>                </div>                <div class="image-caption"></div>            </figure><blockquote><p>此时我们给父亲<code>div</code>加一个<code>border</code>属性，就正常了：</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="http://img.smyhvae.com/20170806_1544.png" alt title>                </div>                <div class="image-caption"></div>            </figure><blockquote><p>如果父亲没有<code>border</code>，那么儿子的<code>margin</code>实际上踹的是“流”，踹的是这“行”。所以，父亲整体也掉下来了。</p></blockquote><p><strong>margin这个属性，本质上描述的是兄弟和兄弟之间的距离； 最好不要用这个marign表达父子之间的距离。</strong></p><blockquote><p>所以，如果要表达父子之间的距离，我们一定要善于使用父亲的padding，而不是儿子的`margin。</p></blockquote><h3 id="BFC（边距重叠解决方案）"><a href="#BFC（边距重叠解决方案）" class="headerlink" title="BFC（边距重叠解决方案）"></a>BFC（边距重叠解决方案）</h3><blockquote><p><code>BFC（Block Formatting Context）</code>：块级格式化上下文。你可以把它理解成一个独立的区域。</p></blockquote><p>另外还有个概念叫<code>IFC</code>。不过，<code>BFC</code>问得更多。</p><p><strong>BFC 的原理/BFC的布局规则【非常重要】</strong></p><blockquote><p><code>BFC</code> 的原理，其实也就是 <code>BFC</code> 的渲染规则（能说出以下四点就够了）。包括：</p></blockquote><ol><li>BFC <strong>内部的</strong>子元素，在垂直方向，<strong>边距会发生重叠</strong>。</li><li>BFC在页面中是独立的容器，外面的元素不会影响里面的元素，反之亦然。（稍后看<code>举例1</code>）</li><li><strong>BFC区域不与旁边的<code>float box</code>区域重叠</strong>。（可以用来清除浮动带来的影响）。（稍后看<code>举例2</code>）</li><li>计算<code>BFC</code>的高度时，浮动的子元素也参与计算。（稍后看<code>举例3</code>）</li></ol><p><strong>如何生成BFC</strong></p><blockquote><p>有以下几种方法：</p></blockquote><ul><li>方法1：<code>overflow</code>: 不为<code>visible</code>，可以让属性是 <code>hidden</code>、<code>auto</code>。【最常用】</li><li>方法2：浮动中：<code>float</code>的属性值不为<code>none</code>。意思是，只要设置了浮动，当前元素就创建了<code>BFC</code>。</li><li>方法3：定位中：只要<code>posiiton</code>的值不是 s<code>tatic</code>或者是<code>relative</code>即可，可以是<code>absolute</code>或<code>fixed</code>，也就生成了一个<code>BFC</code>。</li><li>方法4：<code>display</code>为<code>inline-block</code>, <code>table-cell</code>, <code>table-caption</code>, <code>flex</code>, <code>inline-flex</code></li></ul><p><strong>BFC 的应用</strong></p><p><strong>举例1：</strong>解决 margin 重叠</p><blockquote><p>当父元素和子元素发生 <code>margin</code> 重叠时，解决办法：<strong>给子元素或父元素创建BFC</strong>。</p></blockquote><p>比如说，针对下面这样一个 <code>div</code> 结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"father"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"son"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的<code>div</code>结构中，如果父元素和子元素发生<code>margin</code>重叠，我们可以给子元素创建一个 <code>BFC</code>，就解决了：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"father"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"son"</span> <span class="attr">style</span>=<span class="string">"overflow: hidden"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>因为<strong>第二条：BFC区域是一个独立的区域，不会影响外面的元素</strong>。</p></blockquote><p><strong>举例2</strong>：BFC区域不与float区域重叠：</p><p>针对下面这样一个div结构；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.father-layout</span> &#123;</span></span><br><span class="line">            background: pink;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.father-layout</span> <span class="selector-class">.left</span> &#123;</span></span><br><span class="line">            float: left;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: green;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.father-layout</span> <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">height</span>: 150<span class="selector-tag">px</span>;  <span class="comment">/*右侧标准流里的元素，比左侧浮动的元素要高*/</span></span></span><br><span class="line">            background: red;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"father-layout"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span></span><br><span class="line">        左侧，生命壹号</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">        右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="http://img.smyhvae.com/20180306_0825.png" alt title>                </div>                <div class="image-caption"></div>            </figure><blockquote><p>上图中，由于右侧标准流里的元素，比左侧浮动的元素要高，导致右侧有一部分会跑到左边的下面去。</p></blockquote><p><strong>如果要解决这个问题，可以将右侧的元素创建BFC</strong>，因为<strong>第三条：BFC区域不与<code>float box</code>区域重叠</strong>。解决办法如下：（将right区域添加overflow属性）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span> <span class="attr">style</span>=<span class="string">"overflow: hidden"</span>&gt;</span></span><br><span class="line">    右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="http://img.smyhvae.com/20180306_0827.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>上图表明，解决之后，<code>father-layout</code>的背景色显现出来了，说明问题解决了。</p><p><strong>举例3：</strong>清除浮动</p><p>现在有下面这样的结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.father</span> &#123;</span></span><br><span class="line">            background: pink;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.son</span> &#123;</span></span><br><span class="line">            float: left;</span><br><span class="line">            background: green;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"father"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"son"</span>&gt;</span></span><br><span class="line">        生命壹号</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="http://img.smyhvae.com/20180306_0840.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>上面的代码中，儿子浮动了，但由于父亲没有设置高度，导致看不到父亲的背景色（此时父亲的高度为0）。正所谓<strong>有高度的盒子，才能关住浮动</strong>。</p><blockquote><p>如果想要清除浮动带来的影响，方法一是给父亲设置高度，然后采用隔墙法。方法二是 BFC：给父亲增加 <code>overflow=hidden</code>属性即可， 增加之后，效果如下：</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="http://img.smyhvae.com/20180306_0845.png" alt title>                </div>                <div class="image-caption"></div>            </figure><blockquote><p>为什么父元素成为BFC之后，就有了高度呢？这就回到了<strong>第四条：计算BFC的高度时，浮动元素也参与计算</strong>。意思是，<strong>在计算BFC的高度时，子元素的float box也会参与计算</strong></p></blockquote><h3 id="实现不使用-border-画出-1px-高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。"><a href="#实现不使用-border-画出-1px-高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。" class="headerlink" title="实现不使用 border 画出 1px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。"></a>实现不使用 border 画出 1px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height:1px;overflow:hidden;background:red"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="CSS-隐藏元素的几种方法（至少说出三种）"><a href="#CSS-隐藏元素的几种方法（至少说出三种）" class="headerlink" title="CSS 隐藏元素的几种方法（至少说出三种）"></a>CSS 隐藏元素的几种方法（至少说出三种）</h3><p>Opacity:元素本身依然占据它自己的位置并对网页的布局起作用。它也将响应用户交互;</p><p>Visibility:与 opacity 唯一不同的是它不会响应任何用户交互。此外，元素在读屏软件中也会被隐藏;</p><p>Display:display 设为 none 任何对该元素直接打用户交互操作都不可能生效。此外，读屏软件也不会读到元素的内容。这种方式产生的效果就像元素完全不存在;</p><p>Position:不会影响布局，能让元素保持可以操作;</p><p>Clip-path:clip-path 属性还没有在 IE 或者 Edge 下被完全支持。如果要在你的 clip-path 中使用外部的 SVG 文件，浏览器支持度还要低;</p><h3 id="页面导入样式时，使用-link-和-import-有什么区别？"><a href="#页面导入样式时，使用-link-和-import-有什么区别？" class="headerlink" title="页面导入样式时，使用 link 和@import 有什么区别？"></a>页面导入样式时，使用 link 和@import 有什么区别？</h3><ol><li>Link 属于 html 标签，而@import 是 CSS 中提供的</li><li>在页面加载的时候，link 会同时被加载，而@import 引用的 CSS 会在页面加载完成后才会加载引用的 CSS</li><li>@import 只有在 ie5 以上才可以被识别，而 link 是 html 标签，不存在浏览器兼容性问题</li><li>Link 引入样式的权重大于@import 的引用（@import 是将引用的样式导入到当前的页面中）</li><li>Link支持使用 javascript 改变样式，@import不可</li></ol><h3 id="CSS引入的方式有哪些"><a href="#CSS引入的方式有哪些" class="headerlink" title="CSS引入的方式有哪些?"></a>CSS引入的方式有哪些?</h3><p>答：内联 内嵌 外链 导入</p><h3 id="伪元素和伪类的区别？"><a href="#伪元素和伪类的区别？" class="headerlink" title="伪元素和伪类的区别？"></a>伪元素和伪类的区别？</h3><p>1、伪元素使用 2 个冒号，常见的有：::before，::after，::first-line，::first-letter，::selection、::placeholder 等；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">伪类使用1个冒号，常见的有：:hover，:link，:active，:target，:not()，:focus等。</span><br></pre></td></tr></table></figure><p>2、伪元素添加了一个页面中没有的元素（只是从视觉效果上添加了，不是在文档树中添加）；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">伪类是给页面中已经存在的元素添加一个类。</span><br></pre></td></tr></table></figure><p>解析：</p><p>CSS 伪元素是添加到选择器的关键字，去选择元素的特定部分。它们可以用于装饰（<code>:first-line</code>，<code>:first-letter</code>）或将元素添加到标记中（与 content:…组合），而不必修改标记（<code>:before</code>，<code>:after</code>）。</p><ul><li><code>:first-line</code>和<code>:first-letter</code>可以用来修饰文字。</li><li>上面提到的<code>.clearfix</code>方法中，使用<code>clear: both</code>来添加不占空间的元素。</li><li>使用<code>:before</code>和<code>after</code>展示提示中的三角箭头。鼓励关注点分离，因为三角被视为样式的一部分，而不是真正的 DOM。如果不使用额外的 HTML 元素，只用 CSS 样式绘制三角形是不太可能的。</li></ul><p><a href="https://css-tricks.com/almanac/selectors/a/after-and-before/" target="_blank" rel="noopener">参考</a></p><h3 id="CSS优先级算法如何计算？"><a href="#CSS优先级算法如何计算？" class="headerlink" title="CSS优先级算法如何计算？"></a>CSS优先级算法如何计算？</h3><ul><li>优先级就近原则，同权重情况下样式定义最近者为准</li><li>载入样式以最后载入的定位为准</li><li>优先级为: <code>!important &gt;  id &gt; class &gt; tag</code> important 比 内联优先级高<ul><li>同权重: 内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。</li><li>!important &gt;  id &gt; class &gt; tag</li><li>important 比 内联优先级高</li></ul></li></ul><h3 id="CSS如何计算选择器优先？"><a href="#CSS如何计算选择器优先？" class="headerlink" title="CSS如何计算选择器优先？"></a>CSS如何计算选择器优先？</h3><ul><li>相同权重，定义最近者为准：行内样式 &gt; 内部样式 &gt; 外部样式</li><li>含外部载入样式时，后载入样式覆盖其前面的载入的样式和内部样式</li><li>选择器优先级: 行内样式[1000] &gt; id[100] &gt; class[10] &gt; Tag[1]</li><li>在同一组属性设置中，!important 优先级最高，高于行内样式</li></ul><h3 id="CSS-选择符有哪些？哪些属性可以继承？优先级算法如何计算？"><a href="#CSS-选择符有哪些？哪些属性可以继承？优先级算法如何计算？" class="headerlink" title="CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？"></a>CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？</h3><h3 id="CSS3-新增伪类有那些？"><a href="#CSS3-新增伪类有那些？" class="headerlink" title="CSS3 新增伪类有那些？"></a>CSS3 新增伪类有那些？</h3><pre><code>    1.id选择器（ # myid）    2.类选择器（.myclassname）    3.标签选择器（div, h1, p）    4.相邻选择器（h1 + p）    5.子选择器（ul &lt; li）    6.后代选择器（li a）    7.通配符选择器（ * ）    8.属性选择器（a[rel = &quot;external&quot;]）    9.伪类选择器（a: hover, li: nth - child）*   可继承： font-size font-family color, UL LI DL DD DT;*   不可继承 ：border padding margin width height ;*   优先级就近原则，样式定义最近者为准;*   载入样式以最后载入的定位为准;</code></pre><p>优先级为:</p><pre><code>!important &gt;  id &gt; class &gt; tag  important 比 内联优先级高</code></pre><p>CSS3新增伪类举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line"></span><br><span class="line">    p:last-of-type  选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line"></span><br><span class="line">    p:only-of-type  选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line"></span><br><span class="line">    p:only-child    选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。</span><br><span class="line"></span><br><span class="line">    p:nth-child(2)  选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。</span><br><span class="line"></span><br><span class="line">    :enabled、:disabled 控制表单控件的禁用状态。</span><br><span class="line"></span><br><span class="line">    :checked，单选框或复选框被选中。</span><br></pre></td></tr></table></figure><h3 id="CSS-选择器的优先级是如何计算的？"><a href="#CSS-选择器的优先级是如何计算的？" class="headerlink" title="CSS 选择器的优先级是如何计算的？"></a>CSS 选择器的优先级是如何计算的？</h3><p>浏览器通过优先级规则，判断元素展示哪些样式。优先级通过 4 个维度指标确定，我们假定以<code>a、b、c、d</code>命名，分别代表以下含义：</p><ol><li><code>a</code>表示是否使用内联样式（inline style）。如果使用，<code>a</code>为 1，否则为 0。</li><li><code>b</code>表示 ID 选择器的数量。</li><li><code>c</code>表示类选择器、属性选择器和伪类选择器数量之和。</li><li><code>d</code>表示标签（类型）选择器和伪元素选择器之和。</li></ol><p>优先级的结果并非通过以上四个值生成一个得分，而是每个值分开比较。<code>a、b、c、d</code>权重从左到右，依次减小。判断优先级时，从左到右，一一比较，直到比较出最大值，即可停止。所以，如果<code>b</code>的值不同，那么<code>c</code>和<code>d</code>不管多大，都不会对结果产生影响。比如<code>0，1，0，0</code>的优先级高于<code>0，0，10，10</code>。</p><p>当出现优先级相等的情况时，最晚出现的样式规则会被采纳。如果你在样式表里写了相同的规则（无论是在该文件内部还是其它样式文件中），那么最后出现的（在文件底部的）样式优先级更高，因此会被采纳。</p><p>在写样式时，我会使用较低的优先级，这样这些样式可以轻易地覆盖掉。尤其对写 UI 组件的时候更为重要，这样使用者就不需要通过非常复杂的优先级规则或使用<code>!important</code>的方式，去覆盖组件的样式了。</p><p>解析：<a href="https://www.smashingmagazine.com/2007/07/css-specificity-things-you-should-know/" target="_blank" rel="noopener">参考</a>、<a href="https://www.sitepoint.com/web-foundations/specificity/" target="_blank" rel="noopener">参考</a></p><h3 id="行内元素和块级元素的具体区别？行内元素的padding和margin可设置吗？"><a href="#行内元素和块级元素的具体区别？行内元素的padding和margin可设置吗？" class="headerlink" title="行内元素和块级元素的具体区别？行内元素的padding和margin可设置吗？"></a>行内元素和块级元素的具体区别？行内元素的padding和margin可设置吗？</h3><ul><li>块级元素(block)特性：<ul><li>总是独占一行，表现为另起一行开始，而且其后的元素也必须另起一行显示;</li><li>宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可控制;</li></ul></li><li>内联元素(inline)特性：<ul><li>和相邻的内联元素在同一行;</li><li>宽度(width)、高度(height)、内边距的 top/bottom(padding-top/padding-bottom)和外边距的 top/bottom(margin-top/margin-bottom)都不可改变（也就是 padding 和 margin 的 left 和 right 是可以设置的），就是里面文字或图片的大小。</li></ul></li></ul><p><strong>块级元素：</strong><br>div、p、h1~h6、hr、ul、ol、li、dl、dt、dd、form、table、tbody、tfoot、thead、（header、article、footer、nav、section）<br><strong>内联元素：</strong><br>span、a、b、br、em、strong、img、input、abbr、button、label、textarea<br>（拓展：浏览器默认的inline-block元素）<br><input>、<img>、<button>、</button><textarea>、<label></label></textarea></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">附：行内块元素的兼容性使用？</span><br><span class="line">            div｛</span><br><span class="line">                  display:<span class="keyword">inline</span>-blcok;  <span class="comment">//触发ie的hasLayout</span></span><br><span class="line">                  display:<span class="keyword">inline</span>;</span><br><span class="line">            ｝</span><br><span class="line">            div｛</span><br><span class="line">                  display：<span class="keyword">inline</span>；*zoom：<span class="number">1</span>;</span><br><span class="line">            ｝</span><br></pre></td></tr></table></figure><h3 id="外边距重叠是什么？导致的结果是什么？"><a href="#外边距重叠是什么？导致的结果是什么？" class="headerlink" title="外边距重叠是什么？导致的结果是什么？"></a>外边距重叠是什么？导致的结果是什么？</h3><p>在css当中两个（普通文档流）竖直方向上的毗邻（没有被非空内容、padding、border 或 clear 分隔开）盒子的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，所结合而成的外边距成为折叠外边距。<br>注意：父块级盒子与子块级盒子在垂直方向上毗邻也会导致外边距重叠；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">计算规则：</span><br><span class="line">        两个竖直方向上相邻的外边距都是正数，折叠结果是他们两者之间较大的值。</span><br><span class="line">        两个竖直方向上相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。</span><br><span class="line">        两个竖直方向上相邻的外边距一正一负时，折叠结果是两者的相加的和；</span><br><span class="line"></span><br><span class="line">(附：如何使元素上下margin不折叠？)</span><br><span class="line">        <span class="number">1</span>、浮动、<span class="keyword">inline</span>-block、绝对定位；</span><br><span class="line">        <span class="number">2</span>、创建块级格式化上下文（BFC）的元素，不和它的子元素发生margin折叠；</span><br><span class="line">        (详细链接：https:<span class="comment">//www.zhihu.com/question/19823139)</span></span><br></pre></td></tr></table></figure><h3 id="css中文字的水平垂直居中？"><a href="#css中文字的水平垂直居中？" class="headerlink" title="css中文字的水平垂直居中？"></a>css中文字的水平垂直居中？</h3><p>line-height 设置为盒子高度<br>text-align center;</p><h3 id="box-sizing-常用的属性？分别有什么作用？"><a href="#box-sizing-常用的属性？分别有什么作用？" class="headerlink" title="box-sizing 常用的属性？分别有什么作用？"></a>box-sizing 常用的属性？分别有什么作用？</h3><p>box-sizing：content-box|border-box|inherit；<br>content-box：宽、高应用到元素的内容框。在高、宽之外绘制元素的内边距和边框（默认效果）；<br>border-box：元素的任何内边距和边框都在已设定的宽度和高度内进行绘制。<br>此时的宽高=content+padding+border；</p><h3 id="css-中可以让文字在垂直和水平方向上重叠的两个属性是什么？"><a href="#css-中可以让文字在垂直和水平方向上重叠的两个属性是什么？" class="headerlink" title="css 中可以让文字在垂直和水平方向上重叠的两个属性是什么？"></a>css 中可以让文字在垂直和水平方向上重叠的两个属性是什么？</h3><p>垂直方向：line-height</p><p>水平方向：letter-spacing</p><h3 id="letter-spacing-的妙用知道有哪些么？"><a href="#letter-spacing-的妙用知道有哪些么？" class="headerlink" title="letter-spacing 的妙用知道有哪些么？"></a>letter-spacing 的妙用知道有哪些么？</h3><p>可以用于消除 inline-block 元素间的换行符空格间隙问题。</p><h3 id="px-和em的区别"><a href="#px-和em的区别" class="headerlink" title="px 和em的区别"></a>px 和em的区别</h3><p>px 和 em 都是长度单位</p><p>px 的值是固定的，指定是多少就是多少，计算比较容易。</p><p>em 得值不是固定的，并且 em 会继承父级元素的字体大小。</p><p>浏览器的默认字体高都是 16px。所以未经调整的浏览器都符合: 1em=16px。那么 12px=0.75em, 10px=0.625em。</p><h3 id="用纯-CSS-创建一个三角形的原理是什么？"><a href="#用纯-CSS-创建一个三角形的原理是什么？" class="headerlink" title="用纯 CSS 创建一个三角形的原理是什么？"></a>用纯 CSS 创建一个三角形的原理是什么？</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">40px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">40px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">40px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">40px</span> solid <span class="number">#ff0000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="../images/css001.jpg" alt="css_001" title>                </div>                <div class="image-caption">css_001</div>            </figure><h3 id="Sass、LESS-是什么？大家为什么要使用他们？"><a href="#Sass、LESS-是什么？大家为什么要使用他们？" class="headerlink" title="Sass、LESS 是什么？大家为什么要使用他们？"></a>Sass、LESS 是什么？大家为什么要使用他们？</h3><p>他们是 CSS 预处理器。他是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。</p><p>例如 Less 是一种动态样式语言. 将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数. LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可一在服务端运行 (借助 Node.js)。</p><p>为什么要使用它们？</p><p>结构清晰，便于扩展。</p><p>可以方便地屏蔽浏览器私有语法差异。这个不用多说，封装对浏览器语法差异的重复处理，减少无意义的机械劳动。</p><p>可以轻松实现多重继承。</p><p>完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。</p><h3 id="移动端-1px-问题的解决办法"><a href="#移动端-1px-问题的解决办法" class="headerlink" title="移动端 1px 问题的解决办法"></a>移动端 1px 问题的解决办法</h3><p>推荐解决方法：媒体查询 + transfrom</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/* 2倍屏 */</span><br><span class="line">@media only screen and (-webkit-min-device-pixel-ratio: 2.0) &#123;</span><br><span class="line">    .border-bottom::after &#123;</span><br><span class="line">        -webkit-transform: scaleY(0.5);</span><br><span class="line">        transform: scaleY(0.5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/* 3倍屏 */</span><br><span class="line">@media only screen and (-webkit-min-device-pixel-ratio: 3.0) &#123;</span><br><span class="line">    .border-bottom::after &#123;</span><br><span class="line">        -webkit-transform: scaleY(0.33);</span><br><span class="line">        transform: scaleY(0.33);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/31f8907637a6" target="_blank" rel="noopener">其他解决方案参考</a></p><h3 id="哪些-css-属性可以继承？"><a href="#哪些-css-属性可以继承？" class="headerlink" title="哪些 css 属性可以继承？"></a>哪些 css 属性可以继承？</h3><p>可继承： font-size font-family color, ul li dl dd dt;</p><p>不可继承 ：border padding margin width height ;</p><h3 id="li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"><a href="#li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？" class="headerlink" title="li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"></a>li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</h3><p>行框的排列会受到中间空白（回车\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔</p><p>解决办法：在ul设置设置font-size=0,在li上设置需要的文字大小（把字符大小设为0），就没有空格了</p><p>### </p><p>浏览器的默认行为是把 inline 元素间的空白字符（空格换行 tab）渲染成一个空格，也就是我们上面的代码<li>换行后会产生换行字符，而它会变成一个空格，当然空格就占用一个字符的宽度。</li></p><p>解决方案：</p><p>方法一：既然是因为<code>&lt;li&gt;</code>换行导致的，那就可以将<code>&lt;li&gt;</code>代码全部写在一排，如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span>&gt;</span>li标签空白测试<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"part1"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"part2"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"part3"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"part4"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>方法二：我们为了代码美观以及方便修改，很多时候我们不可能将<code>&lt;li&gt;</code>全部写在一排，那怎么办？既然是空格占一个字符的宽度，那我们索性就将<code>&lt;ul&gt;</code>内的字符尺寸直接设为 0，将下面样式放入样式表，问题解决。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但随着而来的就是<code>&lt;ul&gt;</code>中的其他文字就不见了，因为其尺寸被设为 0px 了，我们只好将他们重新设定字符尺寸。<br>方法三：本来以为方法二能够完全解决问题，但经测试，将 li 父级标签字符设置为 0 在 Safari 浏览器依然出现间隔空白；既然设置字符大小为 0 不行，那咱就将间隔消除了，将下面代码替换方法二的代码，目前测试完美解决。同样随来而来的问题是 li 内的字符间隔也被设置了，我们需要将 li 内的字符间隔设为默认。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">letter-spacing</span>: -<span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后记得设置 li 内字符间隔</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">letter-spacing</span>: normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="png、jpg、gif-这些图片格式解释一下，分别什么时候用？，webp-呢"><a href="#png、jpg、gif-这些图片格式解释一下，分别什么时候用？，webp-呢" class="headerlink" title="png、jpg、gif 这些图片格式解释一下，分别什么时候用？，webp 呢"></a>png、jpg、gif 这些图片格式解释一下，分别什么时候用？，webp 呢</h3><p>gif 图形交换格式，索引颜色格式，颜色少的情况下，产生的文件极小，支持背景透明，动画，图形渐进，无损压缩（适合线条，图标等），缺点只有 256 种颜色</p><p>jpg 支持上百万种颜色，有损压缩，压缩比可达 180：1，而且质量受损不明显，不支持图形渐进与背景透明，不支持动画</p><p>png 为替代 gif 产生的，位图文件，支持透明，半透明，不透明。不支持动画，无损图像格式。Png8 简单说是静态 gif，也只有 256 色，png24 不透明，但不止 256 色。</p><p>webp 谷歌开发的旨在加快图片加载速度的图片格式，图片压缩体积是 jpeg 的 2/3，有损压缩。高版本的 W3C 浏览器才支持，google39+，safari7+</p><h3 id="style-标签写在-body-后与-body-前有什么区别？"><a href="#style-标签写在-body-后与-body-前有什么区别？" class="headerlink" title="style 标签写在 body 后与 body 前有什么区别？"></a>style 标签写在 body 后与 body 前有什么区别？</h3><p>从上向下加载，加载顺序不同</p><h3 id="超链接访问过后-hover-样式就不出现的问题是什么？如何解决？"><a href="#超链接访问过后-hover-样式就不出现的问题是什么？如何解决？" class="headerlink" title="超链接访问过后 hover 样式就不出现的问题是什么？如何解决？"></a>超链接访问过后 hover 样式就不出现的问题是什么？如何解决？</h3><p>被点击访问过的超链接样式不在具有 hover 和 active 了,解决方法是改变 CSS 属性的排列顺序: L-V-H-A（link,visited,hover,active）</p><h3 id="什么是-Css-Hack？ie6-7-8-的-hack-分别是什么？"><a href="#什么是-Css-Hack？ie6-7-8-的-hack-分别是什么？" class="headerlink" title="什么是 Css Hack？ie6,7,8 的 hack 分别是什么？"></a>什么是 Css Hack？ie6,7,8 的 hack 分别是什么？</h3><p>针对不同的浏览器写不同的 CSS code 的过程，就是 CSS hack。</p><p>示例如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#test</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">300px</span>;</span><br><span class="line">    background-color:blue;      /_firefox_/</span><br><span class="line">    background-color:red\9;      /_all ie_/</span><br><span class="line">    background-color:yellow;    /_ie8_/</span><br><span class="line">    +background-color:pink;        /_ie7_/</span><br><span class="line">    \_background-color:orange;       /_ie6_/   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="selector-pseudo">:root</span> <span class="selector-id">#test</span> &#123; <span class="attribute">background-color</span>:purple\<span class="number">9</span>; &#125;  <span class="comment">/*ie9*/</span></span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> all and (min-width:<span class="number">0px</span>)</span><br><span class="line"></span><br><span class="line">     &#123; <span class="selector-id">#test</span> &#123;<span class="attribute">background-color</span>:black;&#125; &#125;  <span class="comment">/*opera*/</span></span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> screen and (-webkit-min-device-pixel-ratio:<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">&#123; <span class="selector-id">#test</span> &#123;<span class="attribute">background-color</span>:gray;&#125; &#125;       <span class="comment">/*chrome and safari*/</span></span><br></pre></td></tr></table></figure><h3 id="重置（resetting）CSS-和-标准化（normalizing）CSS-的区别是什么？你会选择哪种方式，为什么？"><a href="#重置（resetting）CSS-和-标准化（normalizing）CSS-的区别是什么？你会选择哪种方式，为什么？" class="headerlink" title="重置（resetting）CSS 和 标准化（normalizing）CSS 的区别是什么？你会选择哪种方式，为什么？"></a>重置（resetting）CSS 和 标准化（normalizing）CSS 的区别是什么？你会选择哪种方式，为什么？</h3><ul><li><strong>重置（Resetting）</strong>： 重置意味着除去所有的浏览器默认样式。对于页面所有的元素，像<code>margin</code>、<code>padding</code>、<code>font-size</code>这些样式全部置成一样。你将必须重新定义各种元素的样式。</li><li><strong>标准化（Normalizing）</strong>： 标准化没有去掉所有的默认样式，而是保留了有用的一部分，同时还纠正了一些常见错误。</li></ul><p>当需要实现非常个性化的网页设计时，我会选择重置的方式，因为我要写很多自定义的样式以满足设计需求，这时候就不再需要标准化的默认样式了。</p><p>解析：<a href="https://stackoverflow.com/questions/6887336/what-is-the-difference-between-normalize-css-and-reset-css" target="_blank" rel="noopener">参考</a></p><h3 id="什么是-Fouc-文档样式短暂失效Flash-of-Unstyled-Content-？"><a href="#什么是-Fouc-文档样式短暂失效Flash-of-Unstyled-Content-？" class="headerlink" title="什么是 Fouc(文档样式短暂失效Flash of Unstyled Content)？"></a>什么是 Fouc(文档样式短暂失效Flash of Unstyled Content)？</h3><p>在引用 css 的过程中，如果方法不当或者位置引用不对，会导致某些页面在 windows 下的 ie 出现一些奇怪的现象，以无样式显示页面内容的瞬间闪烁，这种现象称之为文档样式短暂失效，简称 FOCU。</p><p><strong>原因：</strong></p><p>当样式表晚于结构性html加载时，加载到此样式表时，页面将停止之前的渲染。等待此样式表被下载和解析后，再重新渲染页面，期间导致短暂的花屏现象。</p><ul><li>使用 import 方法导入样式表</li><li>将样式表放在页面底部</li><li>有几个样式表，放在 html 结构的不同位置。</li></ul><ol start="3"><li>其实原理很清楚：当样式表晚于结构性 html 加载，当加载到此样式表时，页面将停止之前的渲染。此样式表被下载和解析后，将重新渲染页面，也就出现了短暂的花屏现象。</li><li>解决方法：使用 link 标签将样式表放在文档 head 中。</li></ol><h3 id="PNG-GIF-JPG-的区别及如何选"><a href="#PNG-GIF-JPG-的区别及如何选" class="headerlink" title="PNG,GIF,JPG 的区别及如何选"></a>PNG,GIF,JPG 的区别及如何选</h3><p>GIF：</p><ul><li>1：256 色</li><li>2： 无损，编辑 保存时候，不会损失。</li><li>3：支持简单动画。</li><li>4：支持 boolean 透明，也就是要么完全透明，要么不透明</li></ul><p>JPEG：</p><ul><li>1：millions of colors</li><li>2： 有损压缩， 意味着每次编辑都会失去质量。</li><li>3：不支持透明。</li><li>4：适合照片，实际上很多相机使用的都是这个格式。</li></ul><p>PNG：</p><ul><li>1：无损，其实 PNG 有好几种格式的，一般分为两类：PNG8 和 truecolor PNGs；</li><li>与 GIF 相比：<ul><li>它通常会产生较小的文件大小。</li><li>它支持阿尔法（变量）透明度。</li><li>无动画支持</li></ul></li><li>与 JPEG 相比：<ul><li>文件更大</li><li>无损</li><li>因此可以作为 JPEG 图片中间编辑的中转格式。</li></ul></li><li>结论：<ul><li>JPEG 适合照片</li><li>GIF 适合动画</li><li>PNG 适合其他任何种类——图表，buttons，背景，图表等等。</li></ul></li></ul><p><a href="https://www.cnblogs.com/yadiblogs/p/9546935.html" target="_blank" rel="noopener">参考</a></p><h3 id="position-的值，-relative-和-absolute-分别是相对于谁进行定位的？"><a href="#position-的值，-relative-和-absolute-分别是相对于谁进行定位的？" class="headerlink" title="position 的值， relative 和 absolute 分别是相对于谁进行定位的？"></a>position 的值， relative 和 absolute 分别是相对于谁进行定位的？</h3><ul><li>absolute :生成绝对定位的元素， 相对于最近一级的 定位不是 static 的父元素来进行定位。</li><li>fixed （老 IE 不支持）生成绝对定位的元素，通常相对于浏览器窗口或 frame 进行定位。</li><li>relative 生成相对定位的元素，相对于其在普通流中的位置进行定位。</li><li>static 默认值。没有定位，元素出现在正常的流中</li><li>sticky 生成粘性定位的元素，容器的位置根据正常文档流计算得出</li></ul><h3 id="对偏移、卷曲、可视的理解"><a href="#对偏移、卷曲、可视的理解" class="headerlink" title="对偏移、卷曲、可视的理解"></a>对偏移、卷曲、可视的理解</h3><p><strong>偏移</strong><br>offsetWidth      width  +  padding  +  border<br>offsetHeight    height +  padding  +  border<br>offsetLeft<br>offsetTop<br>offsetParent<br>注意：没有offsetRight和offsetBottom</p><hr><p><strong>卷曲</strong><br>scrollWidth    width  +  padding<br>scrollHeight   当内部的内容溢出盒子的时候， 顶边框的底部，计算到内容的底部；如果内容没有溢出盒子，计算方式为盒子内部的真实高度（边框到边框）<br>scrollLeft     这个scroll系列属性不是只读的<br>scrollTop<br>scroll()</p><p>此函数可以获取卷曲的高度和卷曲的宽度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function myScroll() &#123;</span><br><span class="line">   return &#123;</span><br><span class="line">      top: window.pageYOffset  || document.documentElement.scrollTop  || document.body.scrollTop  || 0,</span><br><span class="line">      left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>滚动滚动条的时候触发事件<br>box（window）.onscroll = function () {}</p><hr><p><strong>可视</strong><br>clientWidth   获取的是元素内部的真实宽度 width  +  padding<br>clientHeight  边框之间的高度<br>clientLeft    相当于左边框的宽度  如果元素包含了滚动条，并且滚动条显示在元素的左侧。这时，clientLeft属性会包含滚动条的宽度17px<br>clientTop     相当于顶边框的宽度<br>client()</p><p>此函数可以获取浏览器可视区域的宽高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function myClient() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        wid: window.innerWidth  || document.documentElement.clientWidth  || document.body.clientWidth  || 0,</span><br><span class="line">       heit: window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight || 0</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>@offsetHeight和style.height的区别</strong></p><p>demo.style.height只能获取行内样式，如果样式写到了其他地方，甚至根本就没写，便无法获取<br>style.height是字符串（而且带单位），offsetHeight是数值<br>demo.style.height可以设置行内样式，offsetHeight是只读属性<br>因此，一般用demo.offsetHeight来获取某元素的真实宽度/高度，用style.height来设置宽度/高度</p><hr><p><strong>@offsetLeft和style.left的区别</strong></p><p>一、style.left只能获取行内样式<br>二、offsetLeft只读，style.left可读可写<br>三、offsetLeft是数值，style.left是字符串并且有单位px<br>四、如果没有加定位，style.left获取的数值可能是无效的<br>五、最大区别在于offsetLeft以border左上角为基准，style.left以margin左上角为基准</p><hr><p><strong>@scrollHeight和scrollWidth</strong></p><p>标签内部实际内容的高度/宽度<br>不计算边框，如果内容不超出盒子，值为盒子的宽高（不带边框）<br>如果内容超出了盒子，就是从顶部或左部边框内侧一直到内容a的最外部分</p><hr><p><strong>@scrollTop和scrollLeft</strong></p><p>被卷去部分的 顶部/左侧 到可视区域 顶部/左侧 的距离</p><hr><p><strong>解析：</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="../images/css002.png" alt="offset大全" title>                </div>                <div class="image-caption">offset大全</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="../images/css003.png" alt="scroll大全" title>                </div>                <div class="image-caption">scroll大全</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="../images/css004.png" alt="三个height比较" title>                </div>                <div class="image-caption">三个height比较</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="../images/css005.png" alt="style.left和offsetLeft" title>                </div>                <div class="image-caption">style.left和offsetLeft</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="../images/css006.png" alt="client大全" title>                </div>                <div class="image-caption">client大全</div>            </figure><h3 id="简述一下-Sass、Less，且说明区别？"><a href="#简述一下-Sass、Less，且说明区别？" class="headerlink" title="简述一下 Sass、Less，且说明区别？"></a>简述一下 Sass、Less，且说明区别？</h3><p>他们是动态的样式语言，是 CSS 预处理器,CSS 上的一种抽象层。他们是一种特殊的语法/语言而编译成 CSS。</p><p>变量符不一样，less 是@，而 Sass 是$;</p><p>Sass 支持条件语句，可以使用 if{}else{},for{}循环等等。而 Less 不支持;</p><p>Sass 是基于 Ruby 的，是在服务端处理的，而 Less 是需要引入 less.js 来处理 Less 代码输出 Css 到浏览器</p><h3 id="Css-Sprites"><a href="#Css-Sprites" class="headerlink" title="Css Sprites"></a>Css Sprites</h3><p><strong>概念：</strong></p><p>将多个小图片拼接到一个图片中。通过 background-position 和元素尺寸调节需要显示的背景图案。</p><p><strong>介绍：</strong><br>Css Sprites（雪碧图或 css 精灵），是网页图片处理的一种方式，它允许你将一个页面涉及到的所有零星图片都包含到一张大图中去，这样一来，当访问该页面时，载入的图片就不会像以前那样一幅一幅地慢慢显示出来了。</p><p><strong>原理：</strong><br>将许多的小图片整合到一张大图片中，利用 css 中的 background-image 属性，background-position 属性定位某个图片位置，来达到在大图片中引用某个部位的小图片的效果。</p><p><strong>优点：</strong><br>减少网页的 http 请求，提升网页加载速度。<br>增加图片信息重复度，提高压缩比，减少图片大小。合并多张小图片成大图，能减少字节总数（大图大小&lt;=多张小图大小）</p><p><strong>缺点：</strong><br>前期需要处理图片将小图合并，多些许工程量，图片合并麻烦。<br>对于需要经常改变的图片维护起来麻烦，修改一个图片可能需要从新布局整个图片，样式。</p><h3 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h3><p><strong>介绍：</strong><br>base64 是网络上最常见的用于传输 8Bit 字节代码的编码方式之一，要求把每三个 8Bit 的字节转换为四个 6Bit 的字节，Base64 是网络上最常见的用于传输 8Bit 字节代码的编码方式之一。</p><p>通俗点讲：将资源原本二进制形式转成以 64 个字符基本单位，所组成的一串字符串。<br>一张图片转成 base64 编码，图片直接以 base64 形式嵌入文件中（很长没截完）：</p><p><strong>生成 base64 编码：</strong><br>图片生成 base64 可以用一些工具，如在线工具，但在项目中这样一个图片这样生成是挺繁琐。<br>特别说下，webpack 中的 url-loader 可以完成这个工作，可以对限制大小的图片进行 base64 的转换，非常方便。</p><p><strong>优点：</strong><br>base64 的图片会随着 html 或者 css 一起下载到浏览器,减少了请求.<br>可避免跨域问题</p><p><strong>缺点：</strong><br>老东西（低版本）的 IE 浏览器不兼容。<br>体积会比原来的图片大一点。<br>css 中过多使用 base64 图片会使得 css 过大，不利于 css 的加载。</p><p><strong>适用场景：</strong><br>应用于小的图片几 k 的，太大的图片会转换后的大小太大，得不偿失。<br>用于一些 css sprites 不利处理的小图片，如一些可以通过 background-repeat 平铺来做成背景的图片</p><p>解析：<a href="https://www.cnblogs.com/wangqi2019/p/10498627.html" target="_blank" rel="noopener">参考</a></p><h3 id="如果设计中使用了非标准的字体，你该如何去实现？"><a href="#如果设计中使用了非标准的字体，你该如何去实现？" class="headerlink" title="如果设计中使用了非标准的字体，你该如何去实现？"></a>如果设计中使用了非标准的字体，你该如何去实现？</h3><p>使用<code>@font-face</code>并为不同的<code>font-weight</code>定义<code>font-family</code>。</p><h3 id="请阐述Float定位的工作原理。"><a href="#请阐述Float定位的工作原理。" class="headerlink" title="请阐述Float定位的工作原理。"></a>请阐述<code>Float</code>定位的工作原理。</h3><p>浮动（float）是 CSS 定位属性。浮动元素从网页的正常流动中移出，但是保持了部分的流动性，会影响其他元素的定位（比如文字会围绕着浮动元素）。这一点与绝对定位不同，绝对定位的元素完全从文档流中脱离。</p><p>CSS 的<code>clear</code>属性通过使用<code>left</code>、<code>right</code>、<code>both</code>，让该元素向下移动（清除浮动）到浮动元素下面。</p><p>如果父元素只包含浮动元素，那么该父元素的高度将塌缩为 0。我们可以通过清除（clear）从浮动元素后到父元素关闭前之间的浮动来修复这个问题。</p><p>有一种 hack 的方法，是自定义一个<code>.clearfix</code>类，利用伪元素选择器<code>::after</code>清除浮动。<a href="https://css-tricks.com/all-about-floats/#article-header-id-4" target="_blank" rel="noopener">另外还有一些方法</a>，比如添加空的<code>&lt;div&gt;&lt;/div&gt;</code>和设置浮动元素父元素的<code>overflow</code>属性。与这些方法不同的是，<code>clearfix</code>方法，只需要给父元素添加一个类，定义如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得一提的是，把父元素属性设置为<code>overflow: auto</code>或<code>overflow: hidden</code>，会使其内部的子元素形成块格式化上下文（Block Formatting Context），并且父元素会扩张自己，使其能够包围它的子元素。</p><p>解析：<a href="https://css-tricks.com/all-about-floats/" target="_blank" rel="noopener">参考</a></p><h3 id="请阐述z-index属性，并说明如何形成层叠上下文（stacking-context）"><a href="#请阐述z-index属性，并说明如何形成层叠上下文（stacking-context）" class="headerlink" title="请阐述z-index属性，并说明如何形成层叠上下文（stacking context）"></a>请阐述<code>z-index</code>属性，并说明如何形成层叠上下文（stacking context）</h3><p>CSS 中的<code>z-index</code>属性控制重叠元素的垂直叠加顺序。<code>z-index</code>只能影响<code>position</code>值不是<code>static</code>的元素。</p><p>没有定义<code>z-index</code>的值时，元素按照它们出现在 DOM 中的顺序堆叠（层级越低，出现位置越靠上）。非静态定位的元素（及其子元素）将始终覆盖静态定位（static）的元素，而不管 HTML 层次结构如何。</p><p>层叠上下文是包含一组图层的元素。 在一组层叠上下文中，其子元素的<code>z-index</code>值是相对于该父元素而不是 document root 设置的。每个层叠上下文完全独立于它的兄弟元素。如果元素 B 位于元素 A 之上，则即使元素 A 的子元素 C 具有比元素 B 更高的<code>z-index</code>值，元素 C 也永远不会在元素 B 之上.</p><p>每个层叠上下文是自包含的：当元素的内容发生层叠后，整个该元素将会在父层叠上下文中按顺序进行层叠。少数 CSS 属性会触发一个新的层叠上下文，例如<code>opacity</code>小于 1，<code>filter</code>不是<code>none</code>，<code>transform</code>不是<code>none</code>。</p><p>解析：<a href="https://css-tricks.com/almanac/properties/z/z-index/" target="_blank" rel="noopener">参考 1</a>、<a href="https://philipwalton.com/articles/what-no-one-told-you-about-z-index/" target="_blank" rel="noopener">参考 2</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context" target="_blank" rel="noopener">参考 3</a></p><h3 id="如何解决不同浏览器的样式兼容性问题？"><a href="#如何解决不同浏览器的样式兼容性问题？" class="headerlink" title="如何解决不同浏览器的样式兼容性问题？"></a>如何解决不同浏览器的样式兼容性问题？</h3><ul><li>在确定问题原因和有问题的浏览器后，使用单独的样式表，仅供出现问题的浏览器加载。这种方法需要使用服务器端渲染。</li><li>使用已经处理好此类问题的库，比如 Bootstrap。</li><li>使用 <code>autoprefixer</code> 自动生成 CSS 属性前缀。</li><li>使用 Reset CSS 或 Normalize.css。</li></ul><h3 id="如何为功能受限的浏览器提供页面？-使用什么样的技术和流程？"><a href="#如何为功能受限的浏览器提供页面？-使用什么样的技术和流程？" class="headerlink" title="如何为功能受限的浏览器提供页面？ 使用什么样的技术和流程？"></a>如何为功能受限的浏览器提供页面？ 使用什么样的技术和流程？</h3><ul><li>优雅的降级：为现代浏览器构建应用，同时确保它在旧版浏览器中正常运行。</li><li>Progressive enhancement - The practice of building an application for a base level of user experience, but adding functional enhancements when a browser supports it.</li><li>渐进式增强：构建基于用户体验的应用，但在浏览器支持时添加新增功能。</li><li>利用 <a href="https://caniuse.com/" target="_blank" rel="noopener">caniuse.com</a> 检查特性支持。</li><li>使用 <code>autoprefixer</code> 自动生成 CSS 属性前缀。</li><li>使用 <a href="https://modernizr.com/" target="_blank" rel="noopener">Modernizr</a>进行特性检测。</li></ul><h3 id="有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器）？"><a href="#有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器）？" class="headerlink" title="有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器）？"></a>有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器）？</h3><p>这些方法与可访问性（a11y）有关。</p><ul><li><code>visibility: hidden</code>：元素仍然在页面流中，并占用空间。</li><li><code>width: 0; height: 0</code>：使元素不占用屏幕上的任何空间，导致不显示它。</li><li><code>position: absolute; left: -99999px</code>： 将它置于屏幕之外。</li><li><code>text-indent: -9999px</code>：这只适用于<code>block</code>元素中的文本。</li><li>Metadata： 例如通过使用 Schema.org，RDF 和 JSON-LD。</li><li>WAI-ARIA：如何增加网页可访问性的 W3C 技术规范。</li></ul><p>即使 WAI-ARIA 是理想的解决方案，我也会采用绝对定位方法，因为它具有最少的注意事项，适用于大多数元素，而且使用起来非常简单。</p><p>解析：<a href="https://www.w3.org/TR/wai-aria-1.1/" target="_blank" rel="noopener">参考 1</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA" target="_blank" rel="noopener">参考 2</a>、<a href="http://a11yproject.com/" target="_blank" rel="noopener">参考 3</a></p><h3 id="除了screen，你还能说出一个-media-属性的例子吗？"><a href="#除了screen，你还能说出一个-media-属性的例子吗？" class="headerlink" title="除了screen，你还能说出一个 @media 属性的例子吗？"></a>除了<code>screen</code>，你还能说出一个 @media 属性的例子吗？</h3><ul><li>all<br><br>适用于所有设备。</li><li>print<br><br>为了加载合适的文档到当前使用的可视窗口. 需要提前咨询 paged media（媒体屏幕尺寸）, 以满足个别设备网页尺寸不匹配等问题。</li><li>screen<br><br>主要适用于彩色的电脑屏幕</li><li>speech<br></li></ul><p>解析：speech 这个合成器. 注意: CSS2 已经有一个相似的媒体类型叫 aural.<br><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media" target="_blank" rel="noopener">参考</a></p><h3 id="编写高效的-CSS-应该注意什么？"><a href="#编写高效的-CSS-应该注意什么？" class="headerlink" title="编写高效的 CSS 应该注意什么？"></a>编写高效的 CSS 应该注意什么？</h3><p>首先，浏览器从最右边的选择器，即关键选择器（key selector），向左依次匹配。根据关键选择器，浏览器从 DOM 中筛选出元素，然后向上遍历被选元素的父元素，判断是否匹配。选择器匹配语句链越短，浏览器的匹配速度越快。避免使用标签和通用选择器作为关键选择器，因为它们会匹配大量的元素，浏览器必须要进行大量的工作，去判断这些元素的父元素们是否匹配。</p><p><a href="https://bem.info/" target="_blank" rel="noopener">BEM (Block Element Modifier)</a> methodology recommends that everything has a single class, and, where you need hierarchy, that gets baked into the name of the class as well, this naturally makes the selector efficient and easy to override.<br><a href="https://bem.info/" target="_blank" rel="noopener">BEM (Block Element Modifier)</a>原则上建议为独立的 CSS 类命名，并且在需要层级关系时，将关系也体现在命名中，这自然会使选择器高效且易于覆盖。</p><p>搞清楚哪些 CSS 属性会触发重新布局（reflow）、重绘（repaint）和合成（compositing）。在写样式时，避免触发重新布局的可能。</p><p>解析：<a href="https://developers.google.com/web/fundamentals/performance/rendering/" target="_blank" rel="noopener">参考 1</a>、<a href="https://csstriggers.com/" target="_blank" rel="noopener">参考 2</a></p><h3 id="使用-CSS-预处理的优缺点分别是什么？"><a href="#使用-CSS-预处理的优缺点分别是什么？" class="headerlink" title="使用 CSS 预处理的优缺点分别是什么？"></a>使用 CSS 预处理的优缺点分别是什么？</h3><p><strong>优点：</strong></p><ul><li>提高 CSS 可维护性。</li><li>易于编写嵌套选择器。</li><li>引入变量，增添主题功能。可以在不同的项目中共享主题文件。</li><li>通过混合（Mixins）生成重复的 CSS。</li><li>Splitting your code into multiple files. CSS files can be split up too but doing so will require a HTTP request to download each CSS file.</li><li>将代码分割成多个文件。不进行预处理的 CSS，虽然也可以分割成多个文件，但需要建立多个 HTTP 请求加载这些文件。</li></ul><p><strong>缺点：</strong></p><ul><li>需要预处理工具。</li><li>重新编译的时间可能会很慢。</li></ul><h3 id="对于你使用过的-CSS-预处理，说说喜欢和不喜欢的地方？"><a href="#对于你使用过的-CSS-预处理，说说喜欢和不喜欢的地方？" class="headerlink" title="对于你使用过的 CSS 预处理，说说喜欢和不喜欢的地方？"></a>对于你使用过的 CSS 预处理，说说喜欢和不喜欢的地方？</h3><p><strong>喜欢：</strong></p><ul><li>绝大部分优点上题以及提过。</li><li>Less 用 JavaScript 实现，与 NodeJS 高度结合。</li></ul><p><strong>Dislikes:</strong></p><ul><li>我通过<code>node-sass</code>使用 Sass，它用 C ++ 编写的 LibSass 绑定。在 Node 版本切换时，我必须经常重新编译。</li><li>Less 中，变量名称以<code>@</code>作为前缀，容易与 CSS 关键字混淆，如<code>@media</code>、<code>@import</code>和<code>@font-face</code>。</li></ul><h3 id="解释浏览器如何确定哪些元素与-CSS-选择器匹配。"><a href="#解释浏览器如何确定哪些元素与-CSS-选择器匹配。" class="headerlink" title="解释浏览器如何确定哪些元素与 CSS 选择器匹配。"></a>解释浏览器如何确定哪些元素与 CSS 选择器匹配。</h3><p>这部分与上面关于编写高效的 CSS 有关。浏览器从最右边的选择器（关键选择器）根据关键选择器，浏览器从 DOM 中筛选出元素，然后向上遍历被选元素的父元素，判断是否匹配。选择器匹配语句链越短，浏览器的匹配速度越快。</p><p>例如，对于形如<code>p span</code>的选择器，浏览器首先找到所有<code>&lt;span&gt;</code>元素，并遍历它的父元素直到根元素以找到<code>&lt;p&gt;</code>元素。对于特定的<code>&lt;span&gt;</code>，只要找到一个<code>&lt;p&gt;</code>，就知道’<span>`已经匹配并停止继续匹配。</span></p><p>解析：<a href="https://stackoverflow.com/questions/5797014/why-do-browsers-match-css-selectors-from-right-to-left" target="_blank" rel="noopener">参考</a></p><h3 id="说说你对盒模型的理解，以及如何告知浏览器使用不同的盒模型渲染布局。"><a href="#说说你对盒模型的理解，以及如何告知浏览器使用不同的盒模型渲染布局。" class="headerlink" title="说说你对盒模型的理解，以及如何告知浏览器使用不同的盒模型渲染布局。"></a>说说你对盒模型的理解，以及如何告知浏览器使用不同的盒模型渲染布局。</h3><p>CSS 盒模型描述了以文档树中的元素而生成的矩形框，并根据排版模式进行布局。每个盒子都有一个内容区域（例如文本，图像等）以及周围可选的<code>padding</code>、<code>border</code>和<code>margin</code>区域。</p><p>CSS 盒模型负责计算：</p><ul><li>块级元素占用多少空间。</li><li>边框是否重叠，边距是否合并。</li><li>盒子的尺寸。</li></ul><p>盒模型有以下规则：</p><ul><li>块级元素的大小由<code>width</code>、<code>height</code>、<code>padding</code>、<code>border</code>和<code>margin</code>决定。</li><li>如果没有指定<code>height</code>，则块级元素的高度等于其包含子元素的内容高度加上<code>padding</code>（除非有浮动元素，请参阅下文）。</li><li>如果没有指定<code>width</code>，则非浮动块级元素的宽度等于其父元素的宽度减去父元素的<code>padding</code>。</li><li>元素的<code>height</code>是由内容的<code>height</code>来计算的。</li><li>元素的<code>width</code>是由内容的<code>width</code>来计算的。</li><li>默认情况下，<code>padding</code>和<code>border</code>不是元素<code>width</code>和<code>height</code>的组成部分。</li></ul><p>解析：<a href="https://www.smashingmagazine.com/2010/06/the-principles-of-cross-browser-css-coding/#understand-the-css-box-model" target="_blank" rel="noopener">参考</a></p><h3 id="box-sizing-border-box-会产生怎样的效果？"><a href="#box-sizing-border-box-会产生怎样的效果？" class="headerlink" title="* { box-sizing: border-box; }会产生怎样的效果？"></a><code>* { box-sizing: border-box; }</code>会产生怎样的效果？</h3><ul><li>元素默认应用了<code>box-sizing: content-box</code>，元素的宽高只会决定内容（content）的大小。</li><li><code>box-sizing: border-box</code>改变计算元素<code>width</code>和<code>height</code>的方式，<code>border</code>和<code>padding</code>的大小也将计算在内。</li><li>元素的<code>height</code> = 内容（content）的高度 + 垂直方向的<code>padding</code> + 垂直方向<code>border</code>的宽度</li><li>元素的<code>width</code> = 内容（content）的宽度 + 水平方向的<code>padding</code> + 水平方向<code>border</code>的宽度</li></ul><h3 id="relative、fixed、absolute和static四种定位有什么区别？"><a href="#relative、fixed、absolute和static四种定位有什么区别？" class="headerlink" title="relative、fixed、absolute和static四种定位有什么区别？"></a><code>relative</code>、<code>fixed</code>、<code>absolute</code>和<code>static</code>四种定位有什么区别？</h3><p>经过定位的元素，其<code>position</code>属性值必然是<code>relative</code>、<code>absolute</code>、<code>fixed</code>或<code>static</code>。</p><ul><li><code>static</code>：默认定位属性值。该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。</li><li><code>relative</code>：该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。</li><li><code>absolute</code>：不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。</li><li><code>fixed</code>：不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。</li><li><code>static</code>：盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 <code>table</code> 时），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。<code>position: static</code> 对 <code>table</code> 元素的效果与 <code>position: relative</code> 相同。</li></ul><p>解析：<a href="https://developer.mozilla.org/en/docs/Web/CSS/position" target="_blank" rel="noopener">参考</a></p><h3 id="你使用过哪些现有的-CSS-框架？你是如何改进它们的？"><a href="#你使用过哪些现有的-CSS-框架？你是如何改进它们的？" class="headerlink" title="你使用过哪些现有的 CSS 框架？你是如何改进它们的？"></a>你使用过哪些现有的 CSS 框架？你是如何改进它们的？</h3><ul><li><strong>Bootstrap</strong>： 更新周期缓慢。Bootstrap 4 已经处于 alpha 版本将近两年了。添加了在页面中广泛使用的微调按钮组件。</li><li><strong>Semantic UI</strong>：源代码结构使得自定义主题很难理解。非常规主题系统的使用体验很差。外部库的路径需要硬编码（hard code）配置。变量重新赋值没有 Bootstrap 设计得好。</li><li><strong>Bulma</strong>： 需要很多非语义的类和标记，显得很多余。不向后兼容，以至于升级版本后，会破坏应用的正常运行。</li></ul><h3 id="你了解-CSS-Flex-和-Grid-吗？"><a href="#你了解-CSS-Flex-和-Grid-吗？" class="headerlink" title="你了解 CSS Flex 和 Grid 吗？"></a>你了解 CSS Flex 和 Grid 吗？</h3><p>lex 主要用于一维布局，而 Grid 则用于二维布局。</p><h3 id="Flex"><a href="#Flex" class="headerlink" title="Flex"></a>Flex</h3><p>flex 容器中存在两条轴， 横轴和纵轴， 容器中的每个单元称为 flex item。</p><p>在容器上可以设置 6 个属性：</p><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul><p>注意：当设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效。</p><h3 id="Flex-项目属性"><a href="#Flex-项目属性" class="headerlink" title="Flex 项目属性"></a>Flex 项目属性</h3><p>有六种属性可运用在 item 项目上:</p><ol><li>order</li><li>flex-basis</li><li>flex-grow</li><li>flex-shrink</li><li>flex</li><li>align-self</li></ol><h3 id="Grid"><a href="#Grid" class="headerlink" title="Grid"></a>Grid</h3><p>CSS 网格布局用于将页面分割成数个主要区域，或者用来定义组件内部元素间大小、位置和图层之间的关系。</p><p>像表格一样，网格布局让我们能够按行或列来对齐元素。 但是，使用 CSS 网格可能还是比 CSS 表格更容易布局。 例如，网格容器的子元素可以自己定位，以便它们像 CSS 定位的元素一样，真正的有重叠和层次。</p><h3 id="响应式设计与自适应设计有何不同？"><a href="#响应式设计与自适应设计有何不同？" class="headerlink" title="响应式设计与自适应设计有何不同？"></a>响应式设计与自适应设计有何不同？</h3><p>响应式设计和自适应设计都以提高不同设备间的用户体验为目标，根据视窗大小、分辨率、使用环境和控制方式等参数进行优化调整。</p><p>响应式设计的适应性原则：网站应该凭借一份代码，在各种设备上都有良好的显示和使用效果。响应式网站通过使用媒体查询，自适应栅格和响应式图片，基于多种因素进行变化，创造出优良的用户体验。就像一个球通过膨胀和收缩，来适应不同大小的篮圈。</p><p>自适应设计更像是渐进式增强的现代解释。与响应式设计单一地去适配不同，自适应设计通过检测设备和其他特征，从早已定义好的一系列视窗大小和其他特性中，选出最恰当的功能和布局。与使用一个球去穿过各种的篮筐不同，自适应设计允许使用多个球，然后根据不同的篮筐大小，去选择最合适的一个。</p><p>解析：<br><a href="https://developer.mozilla.org/en-US/docs/Archive/Apps/Design/UI_layout_basics/Responsive_design_versus_adaptive_design" target="_blank" rel="noopener">参考 1</a>、<br><a href="http://mediumwell.com/responsive-adaptive-mobile/" target="_blank" rel="noopener">参考 2</a>、<br><a href="https://css-tricks.com/the-difference-between-responsive-and-adaptive-design/" target="_blank" rel="noopener">参考 3</a></p><h3 id="你有没有使用过视网膜分辨率的图形？当中使用什么技术？"><a href="#你有没有使用过视网膜分辨率的图形？当中使用什么技术？" class="headerlink" title="你有没有使用过视网膜分辨率的图形？当中使用什么技术？"></a>你有没有使用过视网膜分辨率的图形？当中使用什么技术？</h3><p>我倾向于使用更高分辨率的图形（显示尺寸的两倍）来处理视网膜显示。更好的方法是使用媒体查询，像<code>@media only screen and (min-device-pixel-ratio: 2) { ... }</code>，然后改变<code>background-image</code>。</p><p>对于图标类的图形，我会尽可能使用 svg 和图标字体，因为它们在任何分辨率下，都能被渲染得十分清晰。</p><p>还有一种方法是，在检查了<code>window.devicePixelRatio</code>的值后，利用 JavaScript 将<code>&lt;img&gt;</code>的<code>src</code>属性修改，用更高分辨率的版本进行替换。</p><p>解析：<a href="https://www.sitepoint.com/css-techniques-for-retina-displays/" target="_blank" rel="noopener">参考</a></p><h3 id="什么情况下，用translate-而不用绝对定位？什么时候，情况相反。"><a href="#什么情况下，用translate-而不用绝对定位？什么时候，情况相反。" class="headerlink" title="什么情况下，用translate()而不用绝对定位？什么时候，情况相反。"></a>什么情况下，用<code>translate()</code>而不用绝对定位？什么时候，情况相反。</h3><p><code>translate()</code>是<code>transform</code>的一个值。改变<code>transform</code>或<code>opacity</code>不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。而改变绝对定位会触发重新布局，进而触发重绘和复合。<code>transform</code>使浏览器为元素创建一个 GPU 图层，但改变绝对定位会使用到 CPU。 因此<code>translate()</code>更高效，可以缩短平滑动画的绘制时间。</p><p>当使用<code>translate()</code>时，元素仍然占据其原始空间（有点像<code>position：relative</code>），这与改变绝对定位不同。</p><p>解析：<a href="https://www.paulirish.com/2012/why-moving-elements-with-translate-is-better-than-posabs-topleft/" target="_blank" rel="noopener">参考</a>、<a href="https://neal.codes/blog/front-end-interview-css-questions" target="_blank" rel="noopener">参考</a>、<a href="https://quizlet.com/28293152/front-end-interview-questions-css-flash-cards/" target="_blank" rel="noopener">参考</a>、<a href="http://peterdoes.it/2015/12/03/a-personal-exercise-front-end-job-interview-questions-and-my-answers-all/" target="_blank" rel="noopener">参考</a></p><h3 id="文本超出部分显示省略号"><a href="#文本超出部分显示省略号" class="headerlink" title="文本超出部分显示省略号"></a>文本超出部分显示省略号</h3><p><strong>单行</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">ellipsis</span>;</span><br><span class="line"><span class="selector-tag">white-space</span>: <span class="selector-tag">nowrap</span>;</span><br></pre></td></tr></table></figure><p><strong>多行</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">-webkit-box</span>;</span><br><span class="line"><span class="selector-tag">-webkit-box-orient</span>: <span class="selector-tag">vertical</span>;</span><br><span class="line">-webkit-line-clamp: 3; // 最多显示几行</span><br><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br></pre></td></tr></table></figure><h3 id="过渡与动画的区别是什么"><a href="#过渡与动画的区别是什么" class="headerlink" title="过渡与动画的区别是什么"></a>过渡与动画的区别是什么</h3><p><strong>transition</strong></p><p>可以在一定的时间内实现元素的状态过渡为最终状态，用于模拟以一种过渡动画效果，但是功能有限，只能用于制作简单的动画效果而动画属性</p><p><strong>animation</strong></p><p>可以制作类似 Flash 动画，通过关键帧控制动画的每一步，控制更为精确，从而可以制作更为复杂的动画。</p><h3 id="css有哪些选择器？"><a href="#css有哪些选择器？" class="headerlink" title="css有哪些选择器？"></a>css有哪些选择器？</h3><ul><li>id选择器</li><li>类选择器</li><li>标签选择器</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">又可以细分为：</span><br><span class="line">派生选择器（包括后代选择器、子元素选择器、相邻兄弟选择器）</span><br><span class="line">伪元素选择器</span><br><span class="line">属性选择器</span><br><span class="line">群组选择器</span><br><span class="line">通配符选择器</span><br></pre></td></tr></table></figure><h3 id="css优先级定义？"><a href="#css优先级定义？" class="headerlink" title="css优先级定义？"></a>css优先级定义？</h3><p>一般而言，选择器越特殊指向越准确，优先级越高；<br>            计算方法：<br>            标签选择器优先级为1<br>            类选择器优先级为10<br>            id选择器优先级为100<br>            行内样式优先级为1000<br>            ！important 无限大；</p><p>附：css选择器执行效率与兼容性详列：<a href="http://www.cnblogs.com/xiaowuzi/p/3726835.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiaowuzi/p/3726835.html</a></p><h3 id="超链接访问过后hover样式就不出现？如何解决？"><a href="#超链接访问过后hover样式就不出现？如何解决？" class="headerlink" title="超链接访问过后hover样式就不出现？如何解决？"></a>超链接访问过后hover样式就不出现？如何解决？</h3><p>改变css属性的排列顺序（LVHA）link visited hover active</p><h3 id="css-hack的原理？"><a href="#css-hack的原理？" class="headerlink" title="css hack的原理？"></a>css hack的原理？</h3><p>由于不同的浏览器和浏览器各版本对css的支持及解析结果不一样，以及css优先级对浏览器展现效果的影响，我们可以据此针对不同浏览器情景来应用不同的css。</p><h3 id="css-hack的分类？"><a href="#css-hack的分类？" class="headerlink" title="css hack的分类？"></a>css hack的分类？</h3><p>​         css hack有三种表现形式，css属性前缀法、选择器前缀法以及ie条件注释法（即头部引用if ie）。实际项目中css hack大部分是针对ie浏览器不同版本之间的表现差异而引入的。</p><p><strong>属性前缀法：</strong><br>        例：ie6能识别下划线“_”和星号“<em>”，ie7能识别星号“<em>”（以上版本并不支持），但不能识别下划线“_”，ie6~ie10都认识“\9”，但是其他浏览器不能支持（也就是说可以利用这个特性恶心一下还在使用老版本的用户，哈哈）（“\9”测试网址<a href="http://www.jb51.net/css/24944.html）" target="_blank" rel="noopener">http://www.jb51.net/css/24944.html）</a><br>*</em>选择器前缀法（选择器hack）**<br>        例：ie6能识别*html .class{},ie7能识别</em>+html .class{} 或者<em>:first-child+html .class{};<br>*</em>ie条件注释法：**<br>        针对所有ie（ie10+已经不再支持条件注释）：<!--[if IE]>ie浏览器显示的内容<![endif]-->，针对ie6及以下版本：<!--[if lte IE 6]>只在ie6及以下显示的内容<![endif]-->.这类hack不仅针对css生效，对写在判断语句里面的所有代码都会生效。</p><p><strong>css hack书写顺序：</strong><br>        一般将适用范围广，能识别能力强的css定义在前面。因为写在后面代码如果被识别会覆盖前面识别的。<br>     （hack参考大全：<a href="http://blog.csdn.net/freshlover/article/details/12132801）" target="_blank" rel="noopener">http://blog.csdn.net/freshlover/article/details/12132801）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？&quot;&gt;&lt;a href=&quot;#介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？&quot; class=&quot;headerlink&quot; title=&quot;介绍一下标准的CSS的盒子模型？低版本IE的盒子模型
      
    
    </summary>
    
      <category term="前端知识点" scheme="http://www.bluedream.top/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="CSS" scheme="http://www.bluedream.top/tags/CSS/"/>
    
      <category term="选择器" scheme="http://www.bluedream.top/tags/%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    
      <category term="盒子模型" scheme="http://www.bluedream.top/tags/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="样式表" scheme="http://www.bluedream.top/tags/%E6%A0%B7%E5%BC%8F%E8%A1%A8/"/>
    
      <category term="CSS精灵" scheme="http://www.bluedream.top/tags/CSS%E7%B2%BE%E7%81%B5/"/>
    
  </entry>
  
  <entry>
    <title>HTML</title>
    <link href="http://www.bluedream.top/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9/HTML.html"/>
    <id>http://www.bluedream.top/前端知识点/HTML.html</id>
    <published>2019-09-06T03:11:11.000Z</published>
    <updated>2019-09-25T13:55:04.236Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常考问题"><a href="#常考问题" class="headerlink" title="常考问题"></a>常考问题</h2><h3 id="怎么让一个不定宽高的-DIV，垂直水平居中？"><a href="#怎么让一个不定宽高的-DIV，垂直水平居中？" class="headerlink" title="怎么让一个不定宽高的 DIV，垂直水平居中？"></a>怎么让一个不定宽高的 DIV，垂直水平居中？</h3><p><strong>1.使用 CSS方法：</strong></p><p>父盒子设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display：table-cell；</span><br><span class="line">text-align：center；</span><br><span class="line">vertical-align：middle；</span><br></pre></td></tr></table></figure><p>Div 设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">display：inline-block；</span><br><span class="line">vertical-align：middle；</span><br></pre></td></tr></table></figure><p><strong>2.使用 CSS3transform：</strong></p><p>父盒子设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display：relative</span><br></pre></td></tr></table></figure><p>Div 设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">transform：translate(-50%，-50%)；</span><br><span class="line">position：absolute；</span><br><span class="line">top：50%；</span><br><span class="line">left：50%；</span><br></pre></td></tr></table></figure><h3 id="position几个属性的作用？"><a href="#position几个属性的作用？" class="headerlink" title="position几个属性的作用？"></a>position几个属性的作用？</h3><p>position的常见四个属性值： relative，absolute，fixed，static。</p><p>一般都要配合”left”、”top”、”right”以及 “bottom”</p><p><strong>属性使用：</strong></p><p><strong>1.Static：</strong></p><p>默认位置，设置为 static 的元素，它始终会处于页面流给予的位置（static 元素会忽略任何 top、bottom、left 或 right 声明）。一般不常用。</p><p><strong>2.Relative：</strong></p><p>位置被设置为 relative 的元素，可将其移至相对于其正常位置的地方，意思就是如果设置了 relative 值，那么，它偏移的 top，right，bottom，left 的值都<strong>以它原来的位置为基准偏移</strong>，而不管其他元素会怎么样。注意 relative 移动后的元素在原来的位置仍占据空间。</p><p><strong>3.Absolute：</strong></p><p>位置设置为 absolute 的元素，可定位于相对于包含它的元素的指定坐标。意思就是如果它的父容器设置了 position 属性，并且 position 的属性值为 absolute  或者 relative，那么就会<strong>依据父容器进行偏移</strong>。如果其父容器没有设置 position 属性，那么偏移是以 body 为依据。注意设置 absolute 属性的元素在标准流中不占位置。</p><p><strong>4.Fixed：</strong></p><p>位置被设置为 fixed 的元素，可定位于<strong>相对于浏览器窗口的指定坐标</strong>。不论窗口滚动与否，元素都会留在那个位置。它始终是以 body 为依据的。 注意设置 fixed 属性的元素在标准流中不占位置。</p><h3 id="px，em，rem的区别？"><a href="#px，em，rem的区别？" class="headerlink" title="px，em，rem的区别？"></a>px，em，rem的区别？</h3><p> 1.px 像素（Pixel）。绝对单位。</p><p>像素 px 是<strong>相对于显示器屏幕分辨率</strong>而言的，是一个虚拟长度单位，是计算机系统的数字化图像长度单位，如果 px 要换算成物理长度，需要指定精度 DPI。</p><p>2.em 是相对长度单位，<strong>相对于当前对象内文本的字体尺寸</strong>。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。它会继承父级元素的字体大小，因此并不是一个固定的值。</p><p>3.rem是<a href="http://www.html5cn.org/portal.php?mod=list&catid=16" target="_blank" rel="noopener">CSS3</a>新增的一个相对单位（rootem，根 em），使用 rem 为元素设定字体大小时，仍然是相对大小，但<strong>相对于HTML 根元素</strong>。</p><p>4.区别：IE 无法调整那些使用 px 作为单位的字体大小，而 <strong>em 和 rem 可以缩放</strong>，rem 相对的只是 HTML 根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。目前，除了 IE8 及更早版本外，所有浏览器均已支持 rem。</p><h3 id="什么是BFC？"><a href="#什么是BFC？" class="headerlink" title="什么是BFC？"></a>什么是BFC？</h3><p><strong>1.定义：</strong></p><p>BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box 参与， 它规定了内部的Block-level Box 如何布局，并且与这个区域外部毫不相干。</p><p><strong>2.布局规则：</strong></p><p>A.  内部的 Box 会在垂直方向，一个接一个地放置。</p><p>B. Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box的margin 会发生重叠。</p><p>C.  每个元素的 margin box 的左边， 与包含块 border box 的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</p><p>D. BFC 的区域不会与 float box 重叠。</p><p>E.  BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</p><p>F.  计算 BFC 的高度时，浮动元素也参与计算。</p><p><strong>3.哪些元素会生成 BFC：</strong></p><p>A.  根元素</p><p>B. float 属性不为 none</p><p>C. position 为 absolute 或 fixed</p><p>D. display 为 inline-block， table-cell，table-caption， flex， inline-flex F. overflow 不为visible</p><h3 id="表格自动换行怎么实现？"><a href="#表格自动换行怎么实现？" class="headerlink" title="表格自动换行怎么实现？"></a>表格自动换行怎么实现？</h3><p>word-break：normal 使用浏览器默认的换行规则；</p><p>break-all允许单词内换行；</p><p>keep-all只能在半角空格或连字符处换行</p><p>word-wrap：normal 是用浏览器默认的换行规则；break-word 在长单词或 URL 地址内部进行换行。</p><h3 id="box-sizing、transition、translate分别是什么？"><a href="#box-sizing、transition、translate分别是什么？" class="headerlink" title="box-sizing、transition、translate分别是什么？"></a>box-sizing、transition、translate分别是什么？</h3><p> Box-sizing： 用来指定盒模型的大小的计算方式。主要分为boreder-box（从边框固定盒子大小）、content-box（从内容固定盒子大小）两种计算方式。</p><p>transition： 当前元素只要有“属性”发生变化时，可以平滑的进行过渡。通过 transtion-propety 设置过渡属性；</p><p>transtion-duration 设置过渡时间；</p><p>trantion-timing-function 设置过渡速度；</p><p>trantion-delay 设置过渡延时</p><p>translate：通过移动改变元素的位置；有 x、y、z 三个属性</p><h3 id="选择器优先级是怎样的？"><a href="#选择器优先级是怎样的？" class="headerlink" title="选择器优先级是怎样的？"></a>选择器优先级是怎样的？</h3><p>！important&gt;行内样式&gt;id 选择器&gt;类选择器&gt;标签选择器&gt;通配符&gt;继承</p><p>权重算法：</p><p>（0，0，0，0）==》第一个 0 对应的是 important 的个数，第二个 0 对应的是 id 选择器的个数，第三个 0 对应的类选择器的个数，第四个 0 对应的是标签选择器的个数，就是当前选择器的权重。</p><p>比较：</p><p> 先从第一个 0 开始比较，如果第一个 0 大，那么说明这个选择器的权重高，如果第一个相同，比较第二个，依次类推</p><h3 id="Iframe的作用？"><a href="#Iframe的作用？" class="headerlink" title="Iframe的作用？"></a>Iframe的作用？</h3><p> <strong>用法：</strong></p><p>Iframe是用来在网页中插入第三方页面，早期的页面使用 iframe 主要是用于导航栏这种很多页面都相同的部分，这样可以在切换页面的时候避免重复下载。</p><p><strong>优点</strong>：</p><ul><li>便于修改，模块分离，像一些信息管理系统会用到。</li><li>iframe 能够原封不动的把嵌入的网页展现出来。</li><li>用来加载速度较慢的第三方内容如图标和广告</li><li>可以使脚本可以并行下载，可以实现跨子域通信</li><li>如果有多个网页引用 iframe，那么你只需要修改 iframe 的内容，就可以实现调用的每一个页面内容的更改，方便快捷。</li><li>网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用 iframe 来嵌套，可以增加代码的可重用。</li></ul><p><strong>缺点：</strong></p><ul><li><p>iframe 的创建比一般的 DOM 元素慢了 1-2 个数量级</p></li><li><p>会产生很多页面，不容易管理，iframe 页面会增加服务器的 http 请求</p></li><li><p>搜索引擎的检索程序（爬虫）无法解读这种页面，不利于 SEO；替代方案一般就是动态语言的 Incude 机制和 ajax 动态填充内容等。</p></li><li><p>框架结构中出现各种滚动条</p></li><li><p>使用框架结构时，保证设置正确的导航链接。</p></li><li><p>iframe 会阻塞主页面的 Onload （加载）事件，如果页面的onload 事件不能及时触发，会让用户觉得网页加载很慢，用户体验不好；</p></li><li><p>本上不推荐使用，如果需要使用<code>iframe</code>，在 Safari 和 Chrome 中可以通过<code>javascript</code>动态给<code>iframe</code>添加<code>src</code>属性值来避免阻塞。</p></li><li><p>iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</p></li></ul><h3 id="HTML-与-XHTM有什么区别，你觉得应该使用哪一个并说出理由。"><a href="#HTML-与-XHTM有什么区别，你觉得应该使用哪一个并说出理由。" class="headerlink" title="HTML 与 XHTM有什么区别，你觉得应该使用哪一个并说出理由。"></a>HTML 与 XHTM有什么区别，你觉得应该使用哪一个并说出理由。</h3><p><strong>区别：</strong> HTML是一种基本的 WEB 网页设计语言，XHTML 是一个基于 XML 的置标语言。</p><p>应该使用XHTML，因为XHTML是XML重写了HTML的规范，比HTML更加严格，表现如下：</p><p>1、XHTML中所有的标记都必须有一个相应的结束标签；XHTML文档必须拥有根元素。</p><p>2、XHTML所有标签的元素和属性的名字都必须使用小写；</p><p>3、所有的XML标记都必须合理嵌套；</p><p>4、所有的属性都必须用引号“”括起来；</p><p>5、把所有&lt;和&amp;特殊符号用编码表示；</p><p>6、给所有属性附一个值；</p><p>7、不要在注释内容中使用“–”；</p><p>8、图片必须使用说明文字。</p><h3 id="display：none；与-visibility：-hidden-的区别是什么？"><a href="#display：none；与-visibility：-hidden-的区别是什么？" class="headerlink" title="display：none；与 visibility： hidden 的区别是什么？"></a>display：none；与 visibility： hidden 的区别是什么？</h3><p>display：none；使用该属性后，HTML 元素（对象）的宽度、高度等各种属性值都将“丢失”；</p><p>visibility：hidden； 使用该属性后，HTML 元素（对象）仅仅是在视觉上看不见（完全透明），而它所占据的空间位置仍然存在，也即是说它仍具有高度、宽度等属性值。</p><h3 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a>语义化</h3><ul><li><p>HTML标签的语义化是指：通过使用包含语义的标签（如h1-h6）恰当地表示文档结构。</p><p>就是让浏览器更好的读懂你写的代码，在进行 HTML 结构、表现、行为设计时，尽量使用语义化的标签，使程序代码简介明了，易于进行Web 操作和网站 SEO，方便团队协作的一种标准，以图实现一种“无障碍”的  Web 开发。</p></li><li><p>css命名的语义化是指：为html标签添加有意义的class</p></li></ul><h3 id="为什么需要语义化："><a href="#为什么需要语义化：" class="headerlink" title="为什么需要语义化："></a>为什么需要语义化：</h3><ul><li>去掉样式后页面呈现清晰的结构</li><li>盲人使用读屏器更好地阅读</li><li>搜索引擎更好地理解页面，有利于收录</li><li>便团队项目的可持续运作及维护</li></ul><h3 id="简述一下你对-HTML-语义化的理解？"><a href="#简述一下你对-HTML-语义化的理解？" class="headerlink" title="简述一下你对 HTML 语义化的理解？"></a>简述一下你对 HTML 语义化的理解？</h3><p>①<strong>用正确的标签做正确的事情。</strong></p><p>②html 语义化让页面的<strong>内容结构化，结构更清晰</strong>，便于对浏览器、搜索引擎解析；即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的;</p><p>③ 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，<strong>利于 SEO</strong>;</p><p>④ 使阅读源代码的人对网站更容易将网站分块，<strong>便于阅读维护理解</strong>。</p><h3 id="Doctype作用？标准模式与兼容模式各有什么区别"><a href="#Doctype作用？标准模式与兼容模式各有什么区别" class="headerlink" title="Doctype作用？标准模式与兼容模式各有什么区别?"></a>Doctype作用？标准模式与兼容模式各有什么区别?</h3><ul><li>DOCTYPE 是一种标准通用标记语言的文档类型声明，位于位<code>于HTML</code>文档中的第一行，处于 <code>&lt;html&gt;</code> 标签之前。</li><li>它的目的是要告诉浏览器的标准通用标记语言解析器，它应该按照何种规范（HTML 或 XHTML 规范）或使用什么样的文档类型定义（DTD）来解析文档。（如果你的页面没有 DOCTYPE 的声明，那么 compatMode 默认就是 BackCompat,浏览器按照自己的方式解析渲染页面）</li><li>只有确定了一个正确的文档类型，超文本标记语言或可扩展超文本标记语言中的标签和层叠样式表才能生效，甚至对 javascript 脚本都会有所影响。</li><li>DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。</li><li>标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作</li></ul><!DOCTYPE><p>声明是用来指示web浏览器关于页面使用哪个HTML版本进行编写的指令。</p><p>浏览器本身分为两种模式，一种是标准模式，一种是怪异模式，浏览器通过 doctype 来区分这两种模式，doctype 在 html 中的作用就是触发浏览器的标准模式，如果 html 中省略了 doctype，浏览器就会进入到 Quirks 模式的怪异状态，在这种模式下，有些样式会和标准模式存在差异，而 html 标准和 dom 标准值规定了标准模式下的行为，没有对怪异模式做出规定，因此不同浏览器在怪异模式下的处理也是不同的，所以一定要在 html 开头使用 doctype。</p><h3 id="HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt-？"><a href="#HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt-？" class="headerlink" title="HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？"></a>HTML5 为什么只需要写 <code>&lt;!DOCTYPE HTML&gt;</code>？</h3><ul><li>HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）</li><li>而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型</li></ul><p>其中，SGML 是标准通用标记语言,简单的说，就是比 HTML,XML 更老的标准，这两者都是由 SGML 发展而来的。BUT，HTML5 不是的。</p><p><code>&lt;!DOCTYPE&gt;</code>声明位于位于 HTML 文档中的第一行，处于 <code>&lt;html&gt;</code> 标签之前。作用：告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE 不存在或格式不正确</p><h3 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h3><p>首先：CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素</p><p>一个行内元素只占据它对应标签的边框所包含的空间<br><br>一般情况下，行内元素只能包含数据和其他行内元素</p><p>常用：<code>a b span img input select strong</code>（强调的语气）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">big, i, small, tt</span><br><span class="line">abbr, acronym, cite, code, dfn, em, kbd, samp, var</span><br><span class="line">bdo, br,  map, object, q, script, sub, sup</span><br><span class="line">button, label, textarea</span><br></pre></td></tr></table></figure><h3 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h3><p>占据一整行，高度、行高、内边距和外边距都可以改变，可以容纳块级标签和其他行内标签</p><p>常用：<code>div ul ol li dl dt dd h1 h2 h3 h4…p</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header,form,table,article,hr,aside,figure,canvas,video,audio,footer</span><br></pre></td></tr></table></figure><h3 id="空-void-元素有那些？"><a href="#空-void-元素有那些？" class="headerlink" title="空(void)元素有那些？"></a>空(void)元素有那些？</h3><p>常见的空元素:<code>&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;</code></p><h3 id="页面导入样式时，使用link和-import有什么区别？"><a href="#页面导入样式时，使用link和-import有什么区别？" class="headerlink" title="页面导入样式时，使用link和@import有什么区别？"></a>页面导入样式时，使用link和@import有什么区别？</h3><ul><li><code>link</code>属于<code>XHTML</code>标签，除了加载<code>CSS</code>外，还能用于定义<code>RSS</code>,定义<code>rel</code>连接属性等作用；而<code>@import</code>是<code>CSS</code>提供的，只能用于加载<code>CSS</code></li><li>页面被加载的时，<code>link</code>会同时被加载，而<code>@import</code>引用的<code>CSS</code>会等到页面被加载完再加载</li><li><code>import</code>是<code>CSS2.1</code> 提出的，只在<code>IE5</code>以上才能被识别，而<code>link</code>是<code>XHTML</code>标签，无兼容问题</li></ul><h3 id="HTML5-的-form-如何关闭自动完成功能？"><a href="#HTML5-的-form-如何关闭自动完成功能？" class="headerlink" title="HTML5 的 form 如何关闭自动完成功能？"></a>HTML5 的 form 如何关闭自动完成功能？</h3><p>答案：将不想要自动完成的 <code>form</code> 或 <code>input</code> 设置为 <code>autocomplete=off</code></p><p>解析：<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion" target="_blank" rel="noopener">MDN</a></p><h3 id="请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h3><ul><li>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）</li><li>cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递</li><li><code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存</li><li>存储大小：<ul><li><code>cookie</code>数据大小不能超过4k</li><li><code>sessionStorage</code>和<code>localStorage</code>虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</li></ul></li><li>有期时间：<ul><li><code>localStorage</code> 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据</li><li><code>sessionStorage</code>  数据在当前浏览器窗口关闭后自动删除</li><li><code>cookie</code>  设置的<code>cookie</code>过期时间之前一直有效，即使窗口或浏览器关闭</li></ul></li></ul><h3 id="html5有哪些新特性、移除了那些元素？"><a href="#html5有哪些新特性、移除了那些元素？" class="headerlink" title="html5有哪些新特性、移除了那些元素？"></a>html5有哪些新特性、移除了那些元素？</h3><ul><li><p>HTML5 现在已经不是 SGML的子集，主要是关于图像，位置，存储，多任务等功能的增加</p></li><li><p>新增功能</p><ul><li>用于媒介回放的 video 和 audio 元素;</li><li>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;</li><li>sessionStorage 的数据在浏览器关闭后自动删除;</li><li>语意化更好的内容元素，比如 article、footer、header、nav、section、aside;</li><li>表单控件，calendar、date、time、email、url、search</li><li>新的技术webworker, websocket, Geolocation</li><li>拖拽释放(Drag and drop) API</li><li>地理(Geolocation) API</li><li>画布(Canvas) API;</li></ul></li><li><p>移除的元素：</p><ul><li>纯表现的元素：basefont，big，center，font, s，strike，tt，u;</li><li>对可用性产生负面影响的元素：frame，frameset，noframes</li></ul></li></ul><h3 id="如何处理HTML5新标签的浏览器兼容问题？"><a href="#如何处理HTML5新标签的浏览器兼容问题？" class="headerlink" title="如何处理HTML5新标签的浏览器兼容问题？"></a>如何处理HTML5新标签的浏览器兼容问题？</h3><p>支持 HTML5 新标签：</p><ul><li>IE8/IE7/IE6 支持通过 document.createElement 方法产生的标签，<br>可以利用这一特性让这些浏览器支持 HTML5 新标签，<br>浏览器支持新标签后，还需要添加标签默认的样式：</li><li>当然最好的方式是直接使用成熟的框架、使用最多的是 html5shim 框架</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--[if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">  &lt;script&gt;</span></span><br><span class="line"><span class="comment">    src = "http://html5shim.googlecode.com/svn/trunk/html5.js";</span></span><br><span class="line"><span class="comment">  &lt;/script&gt;</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="如何区分-HTML-和HTML5？"><a href="#如何区分-HTML-和HTML5？" class="headerlink" title="如何区分 HTML 和HTML5？"></a>如何区分 HTML 和HTML5？</h3><p>DOCTYPE声明\新增的结构元素\功能元素</p><h3 id="HTML5的离线储存怎么使用，工作原理能不能解释一下？"><a href="#HTML5的离线储存怎么使用，工作原理能不能解释一下？" class="headerlink" title="HTML5的离线储存怎么使用，工作原理能不能解释一下？"></a>HTML5的离线储存怎么使用，工作原理能不能解释一下？</h3><ul><li><p>用户在线时，保存更新用户机器上的缓存文件；当用户离线时，可以正常访离线储存问站点或应用内容</p><ul><li>在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。</li><li>如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储</li><li>离线的情况下，浏览器就直接使用离线存储的资源</li></ul></li><li><p>原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示</p></li></ul><h3 id="HTML5的离线储存使用："><a href="#HTML5的离线储存使用：" class="headerlink" title="HTML5的离线储存使用："></a>HTML5的离线储存使用：</h3><ul><li><p>在文档的 html 标签设置 manifest 属性，如 manifest=”/offline.appcache”</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">"cache.manifest"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在项目中新建 manifest 文件，manifest 文件的命名建议：xxx.appcache</p></li><li><p>在 web 服务器配置正确的 MIME-type，即 text/cache-manifest</p><p>如何使用：</p></li><li><p>页面头部像下面一样加入一个manifest的属性；</p></li><li><p>在cache.manifest文件的编写离线存储的资源</p></li><li><p>在离线状态时，操作window.applicationCache进行需求实现</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">    #v0.11</span><br><span class="line">    CACHE:</span><br><span class="line">    js/app.js</span><br><span class="line">    css/style.css</span><br><span class="line">    NETWORK:</span><br><span class="line">    resourse/logo.png</span><br><span class="line">    FALLBACK:</span><br><span class="line">    / /offline.html</span><br></pre></td></tr></table></figure><p>代码说明：</p><p>离线存储的 manifest 一般由三个部分组成:</p><ol><li>CACHE:表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。</li><li>NETWORK:表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。</li><li>FALLBACK:表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html。</li></ol><p><a href="https://www.cnblogs.com/zhangym118/archive/2016/09/22/5897056.html" target="_blank" rel="noopener">参考</a></p><h3 id="HTML5的form如何关闭自动完成功能？"><a href="#HTML5的form如何关闭自动完成功能？" class="headerlink" title="HTML5的form如何关闭自动完成功能？"></a>HTML5的form如何关闭自动完成功能？</h3><p>给不想要提示的 form 或某个 input 设置为 autocomplete=off。</p><h3 id="如何实现浏览器内多个标签页之间的通信？（阿里）"><a href="#如何实现浏览器内多个标签页之间的通信？（阿里）" class="headerlink" title="如何实现浏览器内多个标签页之间的通信？（阿里）"></a>如何实现浏览器内多个标签页之间的通信？（阿里）</h3><ul><li><p>WebSocket</p></li><li><p>SharedWorker(Web Worker API)</p></li><li><p>也可以调用localstorge、cookies等本地存储方式，storage 事件(localStorge API)</p></li><li><p>iframe + contentWindow</p></li><li><p>postMessage</p></li></ul><h3 id="Label-的作用是什么？是怎么用的？"><a href="#Label-的作用是什么？是怎么用的？" class="headerlink" title="Label 的作用是什么？是怎么用的？"></a>Label 的作用是什么？是怎么用的？</h3><p>label 标签来定义表单控制间的关系，<strong>当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上</strong>。</p><p>解析：两种用法：<strong>一种是 id 绑定，一种是嵌套</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用方法1：</span><br><span class="line">  `<span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"mobile"</span>&gt;</span>Number:<span class="tag">&lt;/<span class="name">label</span>&gt;</span>`</span><br><span class="line">  `<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"mobile"</span>/&gt;</span>`</span><br><span class="line">使用方法2：</span><br><span class="line">  `<span class="tag">&lt;<span class="name">label</span>&gt;</span>Date:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>/&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span>`</span><br></pre></td></tr></table></figure><h3 id="webSocket如何兼容低浏览器？-阿里"><a href="#webSocket如何兼容低浏览器？-阿里" class="headerlink" title="webSocket如何兼容低浏览器？(阿里)"></a>webSocket如何兼容低浏览器？(阿里)</h3><ul><li>Adobe Flash Socket 、</li><li>ActiveX HTMLFile (IE) 、</li><li>基于 multipart 编码发送 XHR 、</li><li>基于长轮询的 XHR</li></ul><h3 id="如何处理HTML5新标签的浏览器兼容问题？-1"><a href="#如何处理HTML5新标签的浏览器兼容问题？-1" class="headerlink" title="如何处理HTML5新标签的浏览器兼容问题？"></a>如何处理HTML5新标签的浏览器兼容问题？</h3><ul><li>通过 document.createElement 创建新标签</li><li>使用垫片 html5shiv.js</li></ul><h3 id="页面大量图片，如何优化加载，优化用户体验"><a href="#页面大量图片，如何优化加载，优化用户体验" class="headerlink" title="页面大量图片，如何优化加载，优化用户体验"></a>页面大量图片，如何优化加载，优化用户体验</h3><p>图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。</p><p>如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。</p><p>如果图片为 css 图片，可以使用 CSSsprite，SVGsprite，Iconfont、Base64 等技术。</p><p>如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。</p><p>如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。</p><h3 id="HTML5-存储类型有什么区别？"><a href="#HTML5-存储类型有什么区别？" class="headerlink" title="HTML5 存储类型有什么区别？"></a>HTML5 存储类型有什么区别？</h3><p>答案：Media API、Text Track API、Application Cache API、User Interaction、Data Transfer API、Command API、Constraint Validation API、History API</p><h3 id="HTML5-引入什么新的表单属性？"><a href="#HTML5-引入什么新的表单属性？" class="headerlink" title="HTML5 引入什么新的表单属性？"></a>HTML5 引入什么新的表单属性？</h3><p>Datalist datetime output keygen date month week time number range emailurl</p><hr><h2 id="简单问题"><a href="#简单问题" class="headerlink" title="简单问题"></a>简单问题</h2><h3 id="标签上title-与-alt-属性的区别是什么"><a href="#标签上title-与-alt-属性的区别是什么" class="headerlink" title="标签上title 与 alt 属性的区别是什么?"></a>标签上title 与 alt 属性的区别是什么?</h3><p> Alt 当图片不显示时，用文字代表。Title为该属性提供信息。</p><h3 id="改变元素的外边距用什么属性？改变元素的内填充用什么属性？"><a href="#改变元素的外边距用什么属性？改变元素的内填充用什么属性？" class="headerlink" title="改变元素的外边距用什么属性？改变元素的内填充用什么属性？"></a>改变元素的外边距用什么属性？改变元素的内填充用什么属性？</h3><p>改变元素的外边距用 margin，改变元素的内填充用 padding。</p><h3 id="在新窗口打开链接的方法是？"><a href="#在新窗口打开链接的方法是？" class="headerlink" title="在新窗口打开链接的方法是？"></a>在新窗口打开链接的方法是？</h3><p> target：_blank。</p><h3 id="合理的页面布局中常听过结构与表现分离，那么结构是什么？表现是什么？"><a href="#合理的页面布局中常听过结构与表现分离，那么结构是什么？表现是什么？" class="headerlink" title="合理的页面布局中常听过结构与表现分离，那么结构是什么？表现是什么？"></a>合理的页面布局中常听过结构与表现分离，那么结构是什么？表现是什么？</h3><p>结构是 html，表现是 css。</p><h3 id="新的-HTML5-文档类型和字符集是？"><a href="#新的-HTML5-文档类型和字符集是？" class="headerlink" title="新的 HTML5 文档类型和字符集是？"></a>新的 HTML5 文档类型和字符集是？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTML5文档类型：&lt;!doctype html&gt;</span><br><span class="line">HTML5使用的编码&lt;meta charset=”UTF-8”&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="不常考问题"><a href="#不常考问题" class="headerlink" title="不常考问题"></a>不常考问题</h2><h3 id="请谈一下你对网页标准和标准制定机构重要性的理解。"><a href="#请谈一下你对网页标准和标准制定机构重要性的理解。" class="headerlink" title="请谈一下你对网页标准和标准制定机构重要性的理解。"></a>请谈一下你对网页标准和标准制定机构重要性的理解。</h3><p>答案：降低开发难度及开发成本，减少各种 BUG、安全问题， 提高网站易用性</p><h3 id="对-web-标准、可用性、可访问性的理解"><a href="#对-web-标准、可用性、可访问性的理解" class="headerlink" title="对 web 标准、可用性、可访问性的理解"></a>对 web 标准、可用性、可访问性的理解</h3><p>可用性（Usability）：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看产品的质量。可用性好意味着产品质量高，是企业的核心竞争力。</p><p>可访问性（Accessibility）：Web 内容对于残障用户的可阅读和可理解性</p><p>可维护性（Maintainability）：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。二是代码是否容易被人理解，是否容易修改和增强功能。</p><h3 id="前端页面有哪三层构成，分别是什么？作用是什么？"><a href="#前端页面有哪三层构成，分别是什么？作用是什么？" class="headerlink" title="前端页面有哪三层构成，分别是什么？作用是什么？"></a>前端页面有哪三层构成，分别是什么？作用是什么？</h3><p>答案：分成：结构层、表示层、行为层。</p><ol><li>结构层（structural layer）</li></ol><p>由 HTML 或 XHTML 之类的标记语言负责创建。标签，也就是那些出现在尖括号里的单词，对网页内容的语义含义做出了描述，但这些标签不包含任何关于如何显示有关内容的信息。例如，P 标签表达了这样一种语义：“这是一个文本段。”</p><ol start="2"><li>表示层（presentation layer）</li></ol><p>由 CSS 负责创建。 CSS 对“如何显示有关内容”的问题做出了回答。</p><ol start="3"><li>行为层（behaviorlayer）</li></ol><p>负责回答“内容应该如何对事件做出反应”这一问题。这是 Javascript 语言和 DOM 主宰的领域。</p><h3 id="对于-WEB-标准以及-W3C-的理解与认识问题"><a href="#对于-WEB-标准以及-W3C-的理解与认识问题" class="headerlink" title="对于 WEB 标准以及 W3C 的理解与认识问题"></a>对于 WEB 标准以及 W3C 的理解与认识问题</h3><p><b>web 标准</b>简单来说可以分为<b>结构、表现和行为</b>。其中结构主要是有 HTML 标签组成。或许通俗点说，在页面 body 里面我们写入的标签都是为了页面的结构。表现即指 css 样式表，通过 css 可以是页面的结构标签更具美感。行为是指页面和用户具有一定的交互，同时页面结构或者表现发生变化，主要是有 js 组成。</p><p>web 标准一般是将该三部分独立分开，使其更具有模块化。但一般产生行为时，就会有结构或者表现的变化，也使这三者的界限并不那么清晰。</p><p>答案：标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外 链 css 和 js 脚本、结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，容易维 护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性。</p><p>W3C 对 web 标准提出了规范化的要求，也就是在实际编程中的一些代码规范：包含如下几点</p><p>1.对于结构要求：（标签规范可以提高搜索引擎对页面的抓取效率，对 SEO 很有帮助）</p><p>1）标签字母要小写</p><p>2）标签要闭合</p><p>3）标签不允许随意嵌套</p><p>2.对于 css 和 js 来说</p><p>1）尽量使用外链 css 样式表和 js 脚本。是结构、表现和行为分为三块，符合规范。同时提高页面渲染速度，提高用户的体验。</p><p>2）样式尽量少用行间样式表，使结构与表现分离，标签的 id 和 class 等属性命名要做到见文知义，标签越少，加载越快，用户体验提高，代码维护简单，便于改版</p><p>3）不需要变动页面内容，便可提供打印版本而不需要复制内容，提高网站易用性。</p><h3 id="介绍一下你对浏览器内核的理解？"><a href="#介绍一下你对浏览器内核的理解？" class="headerlink" title="介绍一下你对浏览器内核的理解？"></a>介绍一下你对浏览器内核的理解？</h3><ul><li><p>主要分成两部分：渲染引擎(<code>layout engineer</code>或<code>Rendering Engine</code>)和<code>JS</code>引擎</p></li><li><p>渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核</p></li><li><p>JS引擎则：解析和执行javascript来实现网页的动态效果</p></li><li><p>最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎</p></li></ul><h3 id="常见的浏览器内核有哪些？"><a href="#常见的浏览器内核有哪些？" class="headerlink" title="常见的浏览器内核有哪些？"></a>常见的浏览器内核有哪些？</h3><ul><li><p><code>Trident</code>内核：<code>IE,MaxThon,TT,The World,360</code>,搜狗浏览器等国产浏览器。[又称MSHTML]</p></li><li><p><code>Gecko</code>内核：<code>Netscape6</code>及以上版本，<code>FF,MozillaSuite/SeaMonkey</code>等</p></li><li><p><code>Presto</code>内核：<code>Opera7</code>及以上。      [<code>Opera</code>内核原为：Presto，现为：<code>Blink</code>;]</p></li><li><p><code>Webkit</code>内核：<code>Safari,Chrome</code>等。   [ <code>Chrome</code>的<code>Blink</code>（<code>WebKit</code>的分支）]</p></li><li><p>Blink内核：新版 Chrome、新版 Opera</p></li></ul><h3 id="页面可见性（Page-Visibility-API）-可以有哪些用途？"><a href="#页面可见性（Page-Visibility-API）-可以有哪些用途？" class="headerlink" title="页面可见性（Page Visibility API） 可以有哪些用途？"></a>页面可见性（Page Visibility API） 可以有哪些用途？</h3><ul><li>通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;</li><li>在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放</li></ul><h3 id="实现不使用-border-画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果"><a href="#实现不使用-border-画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果" class="headerlink" title="实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果"></a>实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;height:1px;overflow:hidden;background:red&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="网页验证码是干嘛的，是为了解决什么安全问题"><a href="#网页验证码是干嘛的，是为了解决什么安全问题" class="headerlink" title="网页验证码是干嘛的，是为了解决什么安全问题"></a>网页验证码是干嘛的，是为了解决什么安全问题</h3><ul><li>区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水</li><li>有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试</li></ul><h3 id="title与h1的区别、b与strong的区别、i与em的区别？"><a href="#title与h1的区别、b与strong的区别、i与em的区别？" class="headerlink" title="title与h1的区别、b与strong的区别、i与em的区别？"></a>title与h1的区别、b与strong的区别、i与em的区别？</h3><ul><li><code>title</code>属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响</li><li><code>strong</code>是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：<strong>会重读，而<b>是展示强调内容</b></strong></li><li>i内容展示为斜体，em表示强调的文本</li></ul><h3 id="页面导入样式时，使用-link-和-import-有什么区别？"><a href="#页面导入样式时，使用-link-和-import-有什么区别？" class="headerlink" title="页面导入样式时，使用 link 和 @import 有什么区别？"></a>页面导入样式时，使用 link 和 @import 有什么区别？</h3><ul><li>link 属于HTML标签，除了加载CSS外，还能用于定 RSS等；@import 只能用于加载CSS</li><li>页面加载的时，link 会同时被加载，而 @import 引用的 CSS 会等到页面被加载完再加载</li><li>@import 只在 IE5 以上才能被识别，而 link 是HTML标签，无兼容问题</li></ul><h3 id="HTML5有哪些新特性？"><a href="#HTML5有哪些新特性？" class="headerlink" title="HTML5有哪些新特性？"></a>HTML5有哪些新特性？</h3><ul><li>新增选择器 document.querySelector、document.querySelectorAll</li><li>拖拽释放(Drag and drop) API</li><li>媒体播放的 video 和 audio</li><li>本地存储 localStorage 和 sessionStorage</li><li>离线应用 manifest</li><li>桌面通知 Notifications</li><li>语意化标签 article、footer、header、nav、section</li><li>增强表单控件 calendar、date、time、email、url、search</li><li>地理位置 Geolocation</li><li>多任务 webworker</li><li>全双工通信协议 websocket</li><li>历史管理 history</li><li>跨域资源共享(CORS) Access-Control-Allow-Origin</li><li>页面可见性改变事件 visibilitychange</li><li>跨窗口通信 PostMessage</li><li>Form Data 对象</li><li>绘画 canvas</li></ul><h3 id="HTML5移除了那些元素？"><a href="#HTML5移除了那些元素？" class="headerlink" title="HTML5移除了那些元素？"></a>HTML5移除了那些元素？</h3><ul><li>纯表现的元素：basefont、big、center、font、s、strike、tt、u</li><li>对可用性产生负面影响的元素：frame、frameset、noframes</li></ul><h3 id="webSocket-如何兼容低浏览器？"><a href="#webSocket-如何兼容低浏览器？" class="headerlink" title="webSocket 如何兼容低浏览器？"></a>webSocket 如何兼容低浏览器？</h3><ul><li>Adobe Flash Socket</li><li>ActiveX HTMLFile (IE)</li><li>基于 multipart 编码发送 XHR</li><li>基于长轮询的 XHR</li></ul><h3 id="页面可见性（Page-Visibility-API）-可以有哪些用途？-1"><a href="#页面可见性（Page-Visibility-API）-可以有哪些用途？-1" class="headerlink" title="页面可见性（Page Visibility API） 可以有哪些用途？"></a>页面可见性（Page Visibility API） 可以有哪些用途？</h3><ul><li>在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放</li><li>当用户浏览其他页面，暂停网站首页幻灯自动播放</li><li>完成登陆后，无刷新自动同步其他页面的登录状态</li></ul><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><ul><li>自然样式标签：b, i, u, s, pre</li><li>语义样式标签：strong, em, ins, del, code</li><li>应该准确使用语义样式标签, 但不能滥用。如果不能确定时，首选使用自然样式标签</li></ul><h3 id="title-与-h1-的区别"><a href="#title-与-h1-的区别" class="headerlink" title="title 与 h1 的区别"></a>title 与 h1 的区别</h3><p>title 表示是整个页面标题，h1 则表示层次明确的标题，对页面信息的抓取有很大的影响</p><p>①title用于网站信息标题，突出网站标题或关键字，一个网站可以有多个title，seo权重高于H1；H1概括的是文章主题，一个页面最好只用一个H1，seo权重低于title。</p><p>解析：</p><p>A.从网站角度而言，title则重于网站信息标题，突出网站标题或关键字用title，一篇文章，一个页面最好只</p><p>用一个H1，H1用得太多，会稀释主题；一个网站可以有多个title，最好一个单页用一个title以便突出网站页面</p><p>主题信息。</p><p>B.从文章角度而言，H1则概括的是文章主题，突出文章主题，用H1，面对的用户，要突出其视觉效果。</p><p>C.从SEO角度而言，title的权重高于H1，其适用性要比H1广。</p><h3 id="b-与-strong-的区别"><a href="#b-与-strong-的区别" class="headerlink" title="b 与 strong 的区别"></a>b 与 strong 的区别</h3><p>strong 标明重点内容，有语气加强的含义，使用阅读设备阅读网络时，strong 会重读，而 b 是展示强调内容</p><p>②b为了加粗而加粗，strong为了标明重点而加粗</p><p>解析：</p><p>A.b这个标签对应 bold，即文本加粗，其目的仅仅是为了加粗显示文本，是一种样式／风格需求；</p><p>B.strong这个标签意思是加强字符的语气，表示该文本比较重要，提醒读者／终端注意。为了达到这个目的，浏览器等终端将其加粗显示；</p><h3 id="i-与-em-的区别？"><a href="#i-与-em-的区别？" class="headerlink" title="i 与 em 的区别？"></a>i 与 em 的区别？</h3><p>i 内容展示为斜体，em 表示强调的文本</p><p>③ 同②i为了斜体而斜体，em为了标明重点而斜体，且对于搜索引擎来说strong和em比b和i要重视的多</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="描述一下cookie、sessionStorage和localStorage的区别？"><a href="#描述一下cookie、sessionStorage和localStorage的区别？" class="headerlink" title="描述一下cookie、sessionStorage和localStorage的区别？"></a>描述一下cookie、sessionStorage和localStorage的区别？</h3><p>sessionStorage用于本地存储一个session中的数据，这些数据只有在同一个会话页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。<br>web storage（包含sessionStorage和localStorage）和cookie的区别：<br>web storage的概念与cookie相似，区别是它是为了更大容量存储设计的。cookie的大小是受限的，并且每次发送请求新页面的时候cookie都会被发送过去，这样无形当中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。<br>web storage拥有setItem，getItem，romoveItem，clear等方法，cookie需要开发者自己封装setCookie，getCookie。<br>Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在，而web storage仅仅是为了本地“存储”数据而生。</p><h3 id="简述一下-src-与-href-的区别"><a href="#简述一下-src-与-href-的区别" class="headerlink" title="简述一下 src 与 href 的区别"></a>简述一下 src 与 href 的区别</h3><p>答案：src 用于引用资源，替换当前元素；href 用于在当前文档和引用资源之间确立联系。</p><p>解析：</p><ul><li>href <br><br>href 标识超文本引用，用在 link 和 a 等元素上，href 是引用和页面关联，是在当前元素和引用资源之间建立联系<br><br>若在文档中添加 href ，浏览器会识别该文档为 CSS 文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式加载 CSS，而不是使用 @import 方式。</li><li>src <br><br>src 表示引用资源，替换当前元素，用在 img，script，iframe 上，src 是页面内容不可缺少的一部分。<br><br>当浏览器解析到 src ，会暂停其他资源的下载和处理（图片不会暂停其他资源下载和处理），直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。</li></ul><p><a href="https://blog.csdn.net/lhjuejiang/article/details/80795081" target="_blank" rel="noopener">参考</a></p><h3 id="src与href的区别"><a href="#src与href的区别" class="headerlink" title="src与href的区别"></a>src与href的区别</h3><p>src（source）指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档中，如js脚本，img图片和iframe等元素。<br>当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，类似于将所指向资源嵌入当前标签内。<br>href（hypertext reference/超文本引用）指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加<link href="common.css" rel="stylesheet">那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也就是为什么建议使用link方式加载css而不是使用@import方式。</p><h3 id="css引入方式"><a href="#css引入方式" class="headerlink" title="css引入方式"></a>css引入方式</h3><p>1.link<br>2.@import “style.css”;/@import url(“style.css”)</p><p>(官方定义  import规则一定要先于除了@charset的其他任何css规则)<br>不建议使用@import的理由：</p><p>1.影响浏览器的并行下载</p><p>2.多个@import导致下载顺序紊乱</p><h3 id="详解为什么要避免使用-import"><a href="#详解为什么要避免使用-import" class="headerlink" title="详解为什么要避免使用@import"></a>详解为什么要避免使用@import</h3><p>​        如果使用css @import，这样会导致css无法并行下载，在使用@import引用的文件只有在引用它的那个css文件被下载、解析之后，浏览器才会知道还有另外一个css需要下载，这时才会去下载，然后下载后开始解析、构建渲染树（render tree）等一系列操作，因此css @import 引起的css解析延迟会加长页面留白期。所以，要尽量避免使用css @import而尽量采用link标签的方式引入。</p><h3 id="link和-import的详细区别？"><a href="#link和-import的详细区别？" class="headerlink" title="link和@import的详细区别？"></a>link和@import的详细区别？</h3><p>1、link属于XHTML标签，除了加载css，还能用于定义RSS，定义rel链接属性等作用；而@import是CSS提供的，只能用于加载CSS。<br>2、页面被加载时，link会并行加载，而@import引用的CSS会等到页面被加载完再加载（详细如上。）<br>3、import是CSS2.1提出的，只在IE5以上才被识别，而linkXHTML标签无兼容问题；</p><h3 id="css、js的性能优化，从用户刷新网页开始，一次js请求一般情况下哪些地方会有缓存处理？"><a href="#css、js的性能优化，从用户刷新网页开始，一次js请求一般情况下哪些地方会有缓存处理？" class="headerlink" title="css、js的性能优化，从用户刷新网页开始，一次js请求一般情况下哪些地方会有缓存处理？"></a>css、js的性能优化，从用户刷新网页开始，一次js请求一般情况下哪些地方会有缓存处理？</h3><p>dns缓存，cdn缓存，浏览器缓存，服务器缓存。<br>（附：缓存介绍）<br>DNS（Domain Name System/域名解析系统）：<br>短时间内多次访问某个网址，系统会设计一个本地“dns缓存”，当第一次访问chenxixunhan.com，dns返回了正确的ip后，系统就会将这个结果临时存储起来，这就是dns缓存。它会有一个失效时间，在这时间内，当再次访问时，系统会从电脑本地的dns缓存中把结果交还给你，而不必再去询问dns服务器，变相“加速”了网址的解析。<br>CDN（Content Delivery Network/内容分发网络）<br>通过在不同地点缓存内容，然后通过负载平衡等技术将用户请求定向到最近的缓存服务器上获取内容，提高用户访问网站的响应速度。<br>浏览器缓存<br>为了节约网络的资源加速浏览，浏览器在用户磁盘上对最近请求过的文档进行存储，当访问者再次请求这个页面时，浏览器就可以从本地磁盘显示文档，这样就可以加速页面的阅览。<br>web服务器缓存<br>Web缓存服务器的应用模式主要是正向代理和反向代理。正向代理(Proxy)模式是代理网络用户访问internet，客户端将本来要直接发送到internet上源服务器的连接请求发送给代理服务器处理。正向代理的目的是加速用户在使用浏览器访问Internet时的请求响应时间，并提高广域网线路的利用率。正向代理浏览器无需和该站点建立联系，只访问到Web缓存即可。通过正向代理，大大提高了后续用户的访问速度，使他们无需再穿越Internet，只要从本地Web缓存就可以获取所需要的信息，避免了带宽问题，同时可以大量减少重复请求在网络上的传输，从而降低网络流量，节省资费。<br>反向代理(Reverse Proxy)模式是针对Web服务器加速功能的，在该模式中，缓存服务器放置在web应用服务器的前面，当用户访问web应用服务器的时候，首先经过缓存服务器，并将用户的请求和应用服务器应答的内容写入缓存服务器中，从而为后续用户的访问提供更快的响应。</p><h3 id="页面大量图片，如何优化加载，优化用户体验？"><a href="#页面大量图片，如何优化加载，优化用户体验？" class="headerlink" title="页面大量图片，如何优化加载，优化用户体验？"></a>页面大量图片，如何优化加载，优化用户体验？</h3><p>1、图片懒加载。在页面的未可视区域添加一个滚动事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。<br>2、如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。<br>3、如果图片为css图片，可以使用CSSsprite，SVGsprite等技术。<br>4、如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。<br>5、如果图片展示区域小于图片的真实大小，应在服务器端根据业务需要先进行图片压缩，图片压缩后大小与展示一致。</p><h3 id="以前端的角度出发做好SEO-Search-Engine-Optimization-搜索引擎优化-需要考虑什么？"><a href="#以前端的角度出发做好SEO-Search-Engine-Optimization-搜索引擎优化-需要考虑什么？" class="headerlink" title="以前端的角度出发做好SEO(Search Engine Optimization/搜索引擎优化)需要考虑什么？"></a>以前端的角度出发做好SEO(Search Engine Optimization/搜索引擎优化)需要考虑什么？</h3><p>1、了解搜索引擎如何抓取网页和如何索引网页。<br>2、meta标签优化<br>包括主题（title），网站描述（description），和关键字（keywords）。还有其它的隐藏文字如author（作者），category（目录），language（编码语种）等。<br>（拓展：meta？（元信息/meta-information））<br>meta元素可提供有关页面的元信息，如针对搜索引擎和更新频度的描述。<br>位于文档头部，一种辅助性的标签（详细：<a href="https://link.jianshu.com/?t=https://zhidao.baidu.com/question/2052283721385566387.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/2052283721385566387.html</a>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>、如何选取关键词并在网页中放置关键词</span><br><span class="line">        搜索就得用关键词。关键词分析和选择是SEO最重要的工作之一。首先给网站确定关键词（一般在<span class="number">5</span>个上下），然后针对这些关键字进行优化，包括关键词密度（Density），相关度（Relavacy），突出性（Prominency）等等。</span><br><span class="line"><span class="number">4</span>、了解主要的搜索引擎</span><br><span class="line">        对网站流量主要起决定作用的几个。</span><br><span class="line">        英文：Google，Yahoo，Bing等；</span><br><span class="line">        中文：百度，搜狗，有道等。</span><br><span class="line">        不同的搜索引擎对页面的抓取和索引、排序的规则都不一样。各搜索门户和搜索引擎的关系。</span><br><span class="line"><span class="number">5</span>、主要的互联网目录。</span><br><span class="line"><span class="number">6</span>、按点击付费的搜索引擎</span><br><span class="line"><span class="number">7</span>、搜索引擎登录</span><br><span class="line"><span class="number">8</span>、链接交换和链接广泛度</span><br><span class="line"><span class="number">9</span>、合理的标签使用（详细链接http:<span class="comment">//www.jb51.net/css/238279.html 第十六点）</span></span><br></pre></td></tr></table></figure><h3 id="html5的新特性？处理html5标签的浏览器兼容问题？"><a href="#html5的新特性？处理html5标签的浏览器兼容问题？" class="headerlink" title="html5的新特性？处理html5标签的浏览器兼容问题？"></a>html5的新特性？处理html5标签的浏览器兼容问题？</h3><p>htm5现在已经不是SGML的子集，主要关于图像、位置、存储，多任务等功能的增加；<br>1.绘画canvas；<br>2.用于媒介回放的video和audio<br>3.本地离线存储localStorage长期存储数据，浏览器关闭后数据不丢失。<br>4.sessionStorage的数据在浏览器关闭后自动删除；<br>5.语义化更好的内容元素，如article、footer、header、nav、section<br>6.表单控件，calendar、date、time、email、url、search；<br>7.新的计数webworker（多线程），websocket（双向通信），geolocation（地理定位）；（新的理解）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">兼容性：</span><br><span class="line">        1.ie6~ie8支持通过document.createElement方法产生的标签,利用这一特性让这些浏览支持html5新标签，并需要添加默认样式。</span><br><span class="line">        2.        使用成熟的框架如：html5shiv；</span><br><span class="line">        <span class="comment">&lt;!--[if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">                &lt;script&gt; src="http://html5shim.googlecode.com/svn/trunk/html5.js"&lt;/script&gt;</span></span><br><span class="line"><span class="comment">        &lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="从输入url到网页最终展现到用户面前，中间发生了什么？"><a href="#从输入url到网页最终展现到用户面前，中间发生了什么？" class="headerlink" title="从输入url到网页最终展现到用户面前，中间发生了什么？"></a>从输入url到网页最终展现到用户面前，中间发生了什么？</h3><p>1、输入地址<br>2、浏览器查找域名的ip地址<br>（包括dns查找：浏览器缓存-&gt;系统缓存-&gt;路由器缓存）<br>dns查找过程如下：<br>1、浏览器缓存——浏览器会缓存dns记录一段时间，但是操作系统不会告诉浏览器存储dns的记录事件，所以不同浏览器会自固定一个时间（2~30分钟）；<br>2、系统缓存——如果在浏览器缓存里没有找到需要的记录，浏览器会做一个系统调用，以便获得系统缓存中的记录；<br>3、路由器缓存——接着，请求发向路由器，它一般会有自己的dns缓存；<br>4、ISP（网络服务提供商）DNS缓存——接下来检查ISP缓存DNS的服务器。这里一般能找到相应的缓存记录。<br>5、递归搜索——ISP的DNS服务器从根域名服务器开始进行递归搜索，从com顶级域名服务器到example的域名服务器。<br>3、浏览器给web服务器发送一个HTTP请求<br>请求中可能包含存储该域名的cookies，也会存储登录用户名和密码以及一些用户设置等。<br>4、HTTP（超文本传输协议）请求的建立<br>建立TCP（传输控制协议）链接：在HTTP工作开始之前，web浏览器首先要通过网络与web服务器建立连接，该连接通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层的应用层协议。根据规则只有低层协议建立之后，才能进行更高层协议的连接。因此，首先要建立TCP链接，一般TCP链接的端口号是80。在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。<br>第一次握手：主机A发送位码syn=1，随机产生seq（sequence序列号） number=1234567的数据包到服务器，主机B由syn=1知道，A要求建立联机；<br>第二次握手：主机B收到请求后确认联机信息，向A发送ack（Acknowledgement 确认信息） number=(主机A的seq+1)，syn=1，ack=1.随机产生seq=7654321的包；<br>第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1，以及位码syn是否为1，若正确，主机A会再发送ack number=（主机B的seq+1），ack=1；主机B收到后确认seq值与ack=1则链接建立成功。<br>完成三次握手，主机A与主机B开始传送数据。<br>一旦建立了TCP连接，web浏览器就会向web服务器发送请求命令。<br>浏览器发送其求命令之后，还要以头信息的形式向web服务器发送一些别的信息，之后浏览器发送一空白行来通知服务器，它已经结束了该头信息的发送。<br>5、服务器的永久重定向响应<br>服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问“<a href="https://link.jianshu.com/?t=http://www.chenxixunhan.com/" target="_blank" rel="noopener">http://www.chenxixunhan.com/</a>”而非”<a href="https://link.jianshu.com/?t=http://chenxixunhan.com/" target="_blank" rel="noopener">http://chenxixunhan.com/</a>“。<br>为什么要重定向而不直接发回用户想看到的网页内容？<br>其中一个原因跟搜索引擎排名相关。<br>如果一个页面有两个地址，就像“<a href="https://link.jianshu.com/?t=http://www.chenxixunhan.com/" target="_blank" rel="noopener">http://www.chenxixunhan.com/</a>”和”<a href="https://link.jianshu.com/?t=http://chenxixunhan.com/" target="_blank" rel="noopener">http://chenxixunhan.com/</a>“，搜索引擎会认为他们是两个网站，结果造成每一个的搜索链接都减少从而降低排名。而搜索引擎知道301永久重定向，会把访问带www的和不带www的地址归到同一个网站排名下。<br>还有一个原因是用不同的地址会造成缓存友好性变差。当一个页面有好几个名字时，它可能会在缓存里出现好几次。<br>HTTP/1.1 301 Moved Permanently<br>Cache-Control: private, no-store, no-cache, must-revalidate, post-check=0,<br>pre-check=0<br>Expires: Sat, 01 Jan 2000 00:00:00 GMT<br>Location: <a href="https://link.jianshu.com/?t=HTTP://www.facebook.com/" target="_blank" rel="noopener">HTTP://www.facebook.com/</a><br>P3P: CP=”DSP LAW”<br>Pragma: no-cache<br>Set-Cookie: made_write_conn=deleted; expires=Thu, 12-Feb-2009 05:09:50 GMT;<br>path=/; domain=.facebook.com; httponly<br>Content-Type: text/html; charset=utf-8<br>X-Cnection: close<br>Date: Fri, 12 Feb 2010 05:09:51 GMT<br>Content-Length: 0<br>6、浏览器跟踪重定向地址<br>现在，浏览器知道了“<a href="https://link.jianshu.com/?t=http://www.chenxixunhan.com/" target="_blank" rel="noopener">http://www.chenxixunhan.com/</a>”才是要访问的正确地址，所以它会发送另一个获取请求也就是<br>GET <a href="https://link.jianshu.com/?t=HTTP://www.facebook.com/" target="_blank" rel="noopener">HTTP://www.facebook.com/</a> HTTP/1.1<br>Accept: application/x-ms-application, image/jpeg, application/xaml+xml, […]Accept-Language: en-US<br>User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; […]Accept-Encoding: gzip, deflate<br>Connection: Keep-Alive<br>Cookie: lsd=XW[…]; c_user=21[…]; x-referer=[…]Host: <a href="https://link.jianshu.com/?t=http://www.facebook.com" target="_blank" rel="noopener">www.facebook.com</a><br>头信息以之前请求中的意义相同；<br>7、服务器“处理”请求<br>服务器接收到获取请求，然后处理返回一个响应。<br>8、服务器发回一个HTML响应<br>HTTP/1.1 200 OKCache-Control: private, no-store, no-cache, must-revalidate, post-check=0,pre-check=0Expires: Sat, 01 Jan 2000 00:00:00 GMTP3P: CP=”DSP LAW”Pragma: no-cacheContent-Encoding: gzipContent-Type: text/html; charset=utf-8X-Cnection: closeTransfer-Encoding: chunkedDate: Fri, 12 Feb 2010 09:05:55 GMT 2b3Tn@[…]整个响应大小为35kB，其中大部分在整理后以blob（二进制）类型传输。<br>内容编码头告诉浏览器整个响应体用gzip算法进行压缩。解压blob块后，你可以看到html文档。<br>关于压缩，头信息说明了是否缓存这个页面，如果缓存的话如何去做，有什么cookies要去设置（前面响应没有这点）和隐私信息等等。<br>注意：报头中把Content-type设置为“text/html”。报头让浏览器将该响应内容以HTML形式呈现，而不是以文件格式下载它。浏览器会根据报头信息决定如何解释该响应，不过同时也会考虑像URL扩展内容等其他因素。<br>9、浏览器开始显示HTML<br>在浏览器没有完整接受全部HTML文档时，它就开始显示这个页面了。<br>10、浏览器发送获取嵌入在HTML中的对象<br>在浏览器显示HTML时，它会注意到需要获取其它地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。<br>下面几个是一个叫雷锋的作者访问facebook.com时需要重获取的几个URL<br>* 图片<br><a href="https://link.jianshu.com/?t=HTTP://static.ak.fbcdn.net/rsrc.php/z12E0/hash/8q2anwu7.gif" target="_blank" rel="noopener">HTTP://static.ak.fbcdn.net/rsrc.php/z12E0/hash/8q2anwu7.gif</a><br><a href="https://link.jianshu.com/?t=HTTP://static.ak.fbcdn.net/rsrc.php/zBS5C/hash/7hwy7at6.gif" target="_blank" rel="noopener">HTTP://static.ak.fbcdn.net/rsrc.php/zBS5C/hash/7hwy7at6.gif</a><br>…* CSS 式样表<br><a href="https://link.jianshu.com/?t=HTTP://static.ak.fbcdn.net/rsrc.php/z448Z/hash/2plh8s4n.css" target="_blank" rel="noopener">HTTP://static.ak.fbcdn.net/rsrc.php/z448Z/hash/2plh8s4n.css</a><br><a href="https://link.jianshu.com/?t=HTTP://static.ak.fbcdn.net/rsrc.php/zANE1/hash/cvtutcee.css" target="_blank" rel="noopener">HTTP://static.ak.fbcdn.net/rsrc.php/zANE1/hash/cvtutcee.css</a><br>…* JavaScript 文件<br><a href="https://link.jianshu.com/?t=HTTP://static.ak.fbcdn.net/rsrc.php/zEMOA/hash/c8yzb6ub.js" target="_blank" rel="noopener">HTTP://static.ak.fbcdn.net/rsrc.php/zEMOA/hash/c8yzb6ub.js</a><br><a href="https://link.jianshu.com/?t=HTTP://static.ak.fbcdn.net/rsrc.php/z6R9L/hash/cq2lgbs8.js" target="_blank" rel="noopener">HTTP://static.ak.fbcdn.net/rsrc.php/z6R9L/hash/cq2lgbs8.js</a></p><p>​            这些地址都要经历一个和HTML读取类似的过程。所以浏览器会在DNS查找这些域名，发送请求，重定向等等。<br>​            但不像动态页面那样，静态文件会允许浏览器对其进行缓存。有的文件可能不需要与服务器通讯，而从缓存中直接读取。服务器的相应中包含了静态文件保存的期限信息，所以浏览器知道要把它们缓存多长时间。还有，每个响应度可能包含像版本号一样的ETag（电子标签）头（被请求变量的实体值），如果浏览器观察到文件的版本ETag信息已经存在，就马上停止这个文件的传输。<br>11、浏览器发送异步（Ajax）请求<br>​            在web2.0伟大精神的指引下（。。。骚货），页面显示完成后客户仍与服务器端保持着联系。<br>​            以Facebook聊天功能为例，它会持续与服务器保持联系来及时更新你那写亮亮灰灰的好友状态。<br>​            为了更新这些头像亮着的好友状态，在浏览器中执行的javascript代码服务器发送异步请求。这个异步请求发送给特定的地址，它是一个按照程式构造的获取或发送请求。<br>​            facebook聊天功能提供了关于ajax一个有意思的问题案例：把数据从服务器端推送到客户端，因为HTTP是一个请求-响应协议，所以聊天服务器不能把新消息发给客户。取而代之的是客户端不得不隔几秒就轮询下服务器端看自己有没有新消息。<br>​            这些情况发生时长轮询是个减轻服务器负载挺有趣的技术。如果当被轮询时服务器没有新消息，它就不理这个客户端。而当尚未超时的情况下收到了该客户的新消息，服务器就会找到未完成的请求，把新消息作为响应返回给客户端。<br>​            （我擦，你可真是个磨人的小妖精，真尼玛能搞，源自：<a href="http://www.qdfuns.com/notes/15102/a5bee6b87d22ab0ecb28101f385db2e4.html）" target="_blank" rel="noopener">http://www.qdfuns.com/notes/15102/a5bee6b87d22ab0ecb28101f385db2e4.html）</a></p><p>​            （拓展：请求url响应返回状态代码及其文本描述？（详情：D:\notes_web_book\HTTP协议详解.pdf））<br>​                    状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：<br>​                            1xx：指示信息–表示请求已接收，继续处理<br>​                            2xx：成功–表示请求已被成功接收、理解、接受<br>​                            3xx：重定向–要完成请求必须进行更进一步的操作<br>​                            4xx：客户端错误–请求有语法错误或请求无法实现<br>​                            5xx：服务器端错误–服务器未能实现合法的请求</p><p>​                    常见状态代码、状态描述说明：<br>​                            200 OK //客户端请求成功<br>​                            400 Bad Request //客户端请求有语法错误，不能被服务器所理解<br>​                            401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用<br>​                            403 Forbidden //服务器收到请求，但是拒绝提供服务<br>​                            404 Not Found //请求资源不存在，eg：输入了错误的 URL<br>​                            500 Internal Server Error //服务器发生不可预期的错误<br>​                            503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后，可能恢复正常<br>​                            eg：HTTP/1.1 200 OK</p><h3 id="请描述下-SEO-中的-TDK？"><a href="#请描述下-SEO-中的-TDK？" class="headerlink" title="请描述下 SEO 中的 TDK？"></a>请描述下 SEO 中的 TDK？</h3><p>答案：在 SEO 中，所谓的 TDK 其实就是 title、description、keywords 这三个标签，title 标题标签，description 描述标签，keywords 关键词标签</p><h3 id="严格模式与混杂模式"><a href="#严格模式与混杂模式" class="headerlink" title="严格模式与混杂模式"></a>严格模式与混杂模式</h3><p>严格模式：以浏览器支持的最高标准运行</p><p>混杂模式：页面以宽松向下兼容的方式显示，模拟老式浏览器的行为</p><h3 id="列举-IE-与其他浏览器不一样的特性？"><a href="#列举-IE-与其他浏览器不一样的特性？" class="headerlink" title="列举 IE 与其他浏览器不一样的特性？"></a>列举 IE 与其他浏览器不一样的特性？</h3><p>a. IE 的排版引擎是 Trident （又称为 MSHTML）</p><p>b. Trident 内核曾经几乎与 W3C 标准脱节（2005 年）</p><p>c. Trident 内核的大量 Bug 等安全性问题没有得到及时解决</p><p>d. JS 方面，有很多独立的方法，例如绑定事件的 attachEvent、创建事件的 createEventObject 等</p><p>e. CSS 方面，也有自己独有的处理方式，例如设置透明，低版本 IE 中使用滤镜的方式</p><h3 id="为什么用多个域名存储网站资源更有效？"><a href="#为什么用多个域名存储网站资源更有效？" class="headerlink" title="为什么用多个域名存储网站资源更有效？"></a>为什么用多个域名存储网站资源更有效？</h3><p>1、CDN 缓存更方便</p><p>2、突破浏览器并发限制</p><p>3、节约 cookie 带宽</p><p>4、节约主域名的连接数，优化页面响应速度</p><p>5、防止不必要的安全问题</p><h3 id="页面可见性（Page-Visibility）API-可以有哪些用途？"><a href="#页面可见性（Page-Visibility）API-可以有哪些用途？" class="headerlink" title="页面可见性（Page Visibility）API 可以有哪些用途？"></a>页面可见性（Page Visibility）API 可以有哪些用途？</h3><p>页面可见性： 就是对于用户来说，页面是显示还是隐藏, 所谓显示的页面，就是我们正在看的页面；隐藏的页面，就是我们没有看的页面。 因为，我们一次可以打开好多标签页面来回切换着，始终只有一个页面在我们眼前，其他页面就是隐藏的，还有一种就是………，(把浏览器最小化，所有的页面就都不可见了)。</p><p>API 很简单，document.hidden 就返回一个布尔值，如果是 true, 表示页面可见，false 则表示，页面隐藏。 不同页面之间来回切换，触发 visibilitychange 事件。 还有一个 document.visibilityState, 表示页面所处的状态，取值：visible, hidden 等四个。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"visibilitychange"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.hidden) &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">"hidden"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">"visibile"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们打开这个页面，然后再打开另一个页面，来回点击这两个页面，当我们看到这个页面时，标题显示 visiable ,当我们看另一个页面时，标题显示 hidden;</p><p>动画，视频，音频都可以在页面显示时打开，在页面隐藏时关闭</p><p>解析：<a href="https://www.cnblogs.com/king18181753985/p/6510315.html" target="_blank" rel="noopener">参考</a></p><h3 id="Quirks-怪癖）模式是什么？它和-Standards（标准）模式有什么区别"><a href="#Quirks-怪癖）模式是什么？它和-Standards（标准）模式有什么区别" class="headerlink" title="Quirks(怪癖）模式是什么？它和 Standards（标准）模式有什么区别"></a>Quirks(怪癖）模式是什么？它和 Standards（标准）模式有什么区别</h3><p>1 以 ie6 为例，如果写了 DTD，就意味着这个页面将采用对 CSS 支持更好的布局，而如果没有，则采用兼容之前的布局方式。这就是 Quirks 模式（怪癖模式，诡异模式，怪异模式）。</p><p>2 区别：总体会有布局、样式解析和脚本执行三个方面的区别。</p><p>设置一个元素的宽度和高度</p><p>给<code>&lt;span&gt;</code>等行内元素设置 width 和 height</p><p>用 margin:0 auto 设置水平居中</p><p>从 IE6 开始，引入了 Standards 模式，标准模式中，浏览器尝试给符合标准的文档在规范上的正确处理达到在指定浏览器中的程度。</p><p>在 IE6 之前 CSS 还不够成熟，所以 IE5 等之前的浏览器对 CSS 的支持很差， IE6 将对 CSS 提供更好的支持，然而这时的问题就来了，因为有很多页面是基于旧的布局方式写的，而如果 IE6  支持 CSS 则将令这些页面显示不正常，如何在即保证不破坏现有页面，又提供新的渲染机制呢？</p><p>在写程序时我们也会经常遇到这样的问题，如何保证原来的接口不变，又提供更强大的功能，尤其是新功能不兼容旧功能时。遇到这种问题时的一个常见做法是增加参数和分支，即当某个参数为真时，我们就使用新功能，而如果这个参数   不为真时，就使用旧功能，这样就能不破坏原有的程序，又提供新功能。IE6 也是类似这样做的，它将 DTD（文档类型定义）当成了这个“参数”，因为以前的页面大家都不会去写 DTD，所以 IE6 就假定   如果写了 DTD，就意味着这个页面将采用对 CSS 支持更好的布局，而如果没有，则采用兼容之前的布局方式。这就是 Quirks 模式（怪癖模式，诡异模式，怪异模式）。</p><p>区别：</p><p>总体会有布局、样式解析和脚本执行三个方面的区别。</p><p>盒模型：在 W3C 标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在 Quirks  模式下，IE 的宽度和高度还包含了 padding 和 border。</p><p>设置行内元素的高宽：在 Standards 模式下，给<code>&lt;span&gt;</code>等行内元素设置 wdith 和 height 都不会生效，而在 quirks 模式下，则会生效。</p><p>设置百分比的高度：在 standards 模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置百分比的高度，子元素设置一个百分比的高度是无效的</p><p>用 margin:0 auto 设置水平居中：使用 margin:0 auto 在 standards 模式下可以使元素水平居中，但在 quirks 模式下却会失效。</p><p>（还有很多，答出什么不重要，关键是看他答出的这些是不是自己经验遇到的，还是说都是看文章看的，甚至完全不知道。）</p><h3 id="div-css-的布局较-table-布局有什么优点？"><a href="#div-css-的布局较-table-布局有什么优点？" class="headerlink" title="div+css 的布局较 table 布局有什么优点？"></a>div+css 的布局较 table 布局有什么优点？</h3><p>答案：分离 方便改版 快清晰简洁 seo</p><p>1.改版的时候更方便 只要改 css 文件。</p><p>2.页面加载速度更快、结构化清晰、页面显示简洁。</p><p>3.表现与结构相分离。</p><p>4.易于优化（seo）搜索引擎更友好，排名更容易靠前。</p><h3 id="你能描述一下渐进增强和优雅降级之间的不同吗"><a href="#你能描述一下渐进增强和优雅降级之间的不同吗" class="headerlink" title="你能描述一下渐进增强和优雅降级之间的不同吗?"></a>你能描述一下渐进增强和优雅降级之间的不同吗?</h3><p>渐进增强  progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p><p>（一开始保证最基本的功能，再改进和追加功能）</p><p>优雅降级  graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p><p>（一开始就构建完整的功能，再针对低版本浏览器进行兼容。）</p><p>区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。</p><h3 id="知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？"><a href="#知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？" class="headerlink" title="知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？"></a>知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？</h3><p>答案：微格式（Microformats）是一种让机器可读的语义化 XHTML 词汇的集合，是结构化数据的开放标准。是为特殊应用而制定的特殊格式。</p><p>优点：将智能数据添加到网页上，让网站内容在搜索引擎结果界面可以显示额外的提示。（应用范例：豆瓣，有兴趣自行 google）</p><h3 id="webSocket-如何兼容低版本浏览器？"><a href="#webSocket-如何兼容低版本浏览器？" class="headerlink" title="webSocket 如何兼容低版本浏览器？"></a>webSocket 如何兼容低版本浏览器？</h3><p>答案：对于低端不支持 websocket 的浏览器，一般有几个解决方案</p><ol><li>使用轮询或长连接的方式实现伪 websocket 的通信</li><li>使用 flash 或其他方法实现一个 websocket 客户端 ：</li></ol><p><a href="https://segmentfault.com/q/1010000005000671/a-1020000005003936" target="_blank" rel="noopener">参考</a><br><a href="https://blog.csdn.net/u011925826/article/details/17532465" target="_blank" rel="noopener">参考</a></p><h3 id="如何在页面上实现一个圆形的可点击区域？"><a href="#如何在页面上实现一个圆形的可点击区域？" class="headerlink" title="如何在页面上实现一个圆形的可点击区域？"></a>如何在页面上实现一个圆形的可点击区域？</h3><p>答案：css3、js、map 加 area</p><p>一.border-radius (css3)</p><p>对于圆形，最直接的方法想到的就是 css3 的圆角属性，这个属性可以将 html 元素的形状设置为圆形，这之后你想对该圆形区域设置什么事件就设置什么事件(当然包括点击)。（这里就不做具体的 test 了）</p><p>二.纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等</p><p>通过事件坐标来实现（js），也就是通过 js 来进行一个区域判断，进而简介地的形成可点区域，以下给出主要的 js 测试代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取目标元素</span></span><br><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">"box"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对目标元素target的圆形区域进行一个点击事件绑定</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindClickOnCircleArea</span>(<span class="params">target, callback</span>) </span>&#123;</span><br><span class="line">  target.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e = e || <span class="built_in">window</span>.event;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// target中心点的坐标</span></span><br><span class="line">    <span class="keyword">var</span> x1 = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">var</span> y1 = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件源坐标</span></span><br><span class="line">    <span class="keyword">var</span> x2 = e.offsetX;</span><br><span class="line">    <span class="keyword">var</span> y2 = e.offsetY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验是否在圆形点击区，在的话就执行callback回调</span></span><br><span class="line">    <span class="comment">// 计算事件触发点与target中心的位置</span></span><br><span class="line">    <span class="keyword">var</span> len = <span class="built_in">Math</span>.abs(<span class="built_in">Math</span>.sqrt(<span class="built_in">Math</span>.pow(x2 - x1, <span class="number">2</span>) + <span class="built_in">Math</span>.pow(y2 - y1, <span class="number">2</span>)));</span><br><span class="line">    <span class="comment">// 通过半径进行校验</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">      callback();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      alert(<span class="string">"死鬼，跑哪去啊，你老婆我是黄皮肤还是白皮肤都分不清了吗"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行</span></span><br><span class="line">bindClickOnCircleArea(box, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"老婆，你让我好找啊，呜呜呜"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>三.通过 map 加 area或者svg</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"../imgs/test.jpg"</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">usemap</span>=<span class="string">"#Map"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">"Map"</span> <span class="attr">id</span>=<span class="string">"Map"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">area</span></span></span><br><span class="line"><span class="tag">    <span class="attr">shape</span>=<span class="string">"circle"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">coords</span>=<span class="string">"100,100,100"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">target</span>=<span class="string">"_blank"</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/48168812" target="_blank" rel="noopener">参考</a></p><h3 id="前端需要注意哪些-SEO"><a href="#前端需要注意哪些-SEO" class="headerlink" title="前端需要注意哪些 SEO"></a>前端需要注意哪些 SEO</h3><ol><li>合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可</li><li>语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页</li><li>重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</li><li>重要内容不要用 js 输出：爬虫不会执行 js 获取内容</li><li>少用 iframe：搜索引擎不会抓取 iframe 中的内容</li><li>非装饰性图片必须加 alt</li><li>提高网站速度：网站速度是搜索引擎排序的一个重要指标</li></ol><p>解析：<a href="https://www.cnblogs.com/passkey/p/10081589.html" target="_blank" rel="noopener">参考</a></p><h3 id="HTML-全局属性-global-attribute-有哪些"><a href="#HTML-全局属性-global-attribute-有哪些" class="headerlink" title="HTML 全局属性(global attribute)有哪些"></a>HTML 全局属性(global attribute)有哪些</h3><ul><li>accesskey:设置快捷键，提供快速访问元素如<a href="#" accesskey="a">aaa</a>在 windows 下的 firefox 中按 alt + shift + a 可激活元素</li><li>class:为元素设置类标识，多个类名用空格分开，CSS 和 javascript 可通过 class 属性获取元素</li><li>contenteditable: 指定元素内容是否可编辑</li><li>contextmenu: 自定义鼠标右键弹出菜单内容</li><li>data-*: 为元素增加自定义属性</li><li>dir: 设置元素文本方向</li><li>draggable: 设置元素是否可拖拽</li><li>dropzone: 设置元素拖放类型： copy, move, link</li><li>hidden: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果</li><li>id: 元素 id，文档内唯一</li><li>lang: 元素内容的的语言</li><li>spellcheck: 是否启动拼写和语法检查</li><li>style: 行内 css 样式</li><li>tabindex: 设置元素可以获得焦点，通过 tab 可以导航</li><li>title: 元素相关的建议信息</li><li>translate: 元素和子孙节点内容是否需要本地化</li></ul><p>解析：<a href="https://funteas.com/topic/5906a8bc8783c1370b809c2a" target="_blank" rel="noopener">参考</a></p><h3 id="meta-viewport-原理是什么？"><a href="#meta-viewport-原理是什么？" class="headerlink" title="meta viewport 原理是什么？"></a>meta viewport 原理是什么？</h3><p>答案：meta viewport 标签的作用是让当前 viewport 的宽度等于设备的宽度，同时不允许用户进行手动缩放</p><p>viewportde 原理：移动端浏览器通常都会在一个比移动端屏幕更宽的虚拟窗口中渲染页面，这个虚拟窗口就是 viewport; 目的是正常展示没有做移动端适配的网页，让他们完整的展示给用户；</p><p>解析：Viewport ：字面意思为视图窗口，在移动 web 开发中使用。表示将设备浏览器宽度虚拟成一个特定的值（或计算得出），这样利于移动 web 站点跨设备显示效果基本一致。移动版的 Safari 浏览器最新引进了 viewport 这个 meta tag，让网页开发者来控制 viewport 的大小和缩放，其他手机浏览器也基本支持。</p><p>在移动端浏览器当中，存在着两种视口，一种是可见视口（也就是我们说的设备大小），另一种是视窗视口（网页的宽度是多少）。<br>举个例子：如果我们的屏幕是 320 像素 * 480 像素的大小（iPhone4），假设在浏览器中，320 像素的屏幕宽度能够展示 980 像素宽度的内容。那么 320 像素的宽度就是可见视口的宽度，而能够显示的 980 像素的宽度就是视窗视口的宽度。</p><p>为了显示更多的内容，大多数的浏览器会把自己的视窗视口扩大，简易的理解，就是让原本 320 像素的屏幕宽度能够容下 980 像素甚至更宽的内容（将网页等比例缩小）。</p><h3 id="Viewport-属性值"><a href="#Viewport-属性值" class="headerlink" title="Viewport 属性值"></a>Viewport 属性值</h3><ul><li>width 设置 layout viewport 的宽度，为一个正整数，或字符串”width-device”</li><li>initial-scale 设置页面的初始缩放值，为一个数字，可以带小数</li><li>minimum-scale 允许用户的最小缩放值，为一个数字，可以带小数</li><li>maximum-scale 允许用户的最大缩放值，为一个数字，可以带小数</li><li>height 设置 layout viewport 的高度，这个属性对我们并不重要，很少使用</li><li>user-scalable 是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes 代表允许这些属性可以同时使用，也可以单独使用或混合使用，多个属性同时使用时用逗号隔开就行了。</li></ul><h3 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h3><p>描述：Canvas 元素用于在网页上绘制图形，该元素标签强大之处在于可以直接在 HTML 上进行图形操作。</p><ul><li>通过 Javascript 来绘制 2D 图形。</li><li>是逐像素进行渲染的。</li><li>在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。</li></ul><h3 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h3><p><strong>描述：</strong></p><p>一种使用 XML 描述的 2D 图形的语言<br>SVG 基于 XML 意味着，SVG DOM 中的每个元素都是可用的，可以为某个元素附加 Javascript 事件处理器。<br>在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</p><h3 id="Canvas-和-SVG-有什么区别？"><a href="#Canvas-和-SVG-有什么区别？" class="headerlink" title="Canvas 和 SVG 有什么区别？"></a>Canvas 和 SVG 有什么区别？</h3><p>Canvas 和 SVG 都允许您在浏览器中创建图形，但是它们在根本上是不同的。</p><p><strong>Canvas</strong></p><ul><li>依赖分辨率</li><li>不支持事件处理器</li><li>弱的文本渲染能力</li><li>能够以 .png 或 .jpg 格式保存结果图像</li><li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li></ul><p><strong>SVG</strong></p><ul><li>不依赖分辨率</li><li>支持事件处理器</li><li>最适合带有大型渲染区域的应用程序（比如谷歌地图）</li><li>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li><li>不适合游戏应用</li></ul><h3 id="为什么最好把-CSS-的-lt-link-gt-标签放在-lt-head-gt-lt-head-gt-之间？"><a href="#为什么最好把-CSS-的-lt-link-gt-标签放在-lt-head-gt-lt-head-gt-之间？" class="headerlink" title="为什么最好把 CSS 的&lt;link&gt;标签放在&lt;head&gt;&lt;/head&gt;之间？"></a>为什么最好把 CSS 的<code>&lt;link&gt;</code>标签放在<code>&lt;head&gt;&lt;/head&gt;</code>之间？</h3><p>把<code>&lt;link&gt;</code>标签放在<code>&lt;head&gt;&lt;/head&gt;</code>之间是规范要求的内容。此外，这种做法可以让页面逐步呈现，提高了用户体验。将样式表放在文档底部附近，会使许多浏览器（包括 Internet Explorer）不能逐步呈现页面。一些浏览器会阻止渲染，以避免在页面样式发生变化时，重新绘制页面中的元素。这种做法可以防止呈现给用户空白的页面或没有样式的内容。</p><h3 id="为什么最好把-JS-的-lt-script-gt-标签恰好放在-lt-body-gt-之前，有例外情况吗？"><a href="#为什么最好把-JS-的-lt-script-gt-标签恰好放在-lt-body-gt-之前，有例外情况吗？" class="headerlink" title="为什么最好把 JS 的&lt;script&gt;标签恰好放在&lt;/body&gt;之前，有例外情况吗？"></a>为什么最好把 JS 的<code>&lt;script&gt;</code>标签恰好放在<code>&lt;/body&gt;</code>之前，有例外情况吗？</h3><p>脚本在下载和执行期间会阻止 HTML 解析。把<code>&lt;script&gt;</code>标签放在底部，保证 HTML 首先完成解析，将页面尽早呈现给用户。</p><p>例外情况是当你的脚本里包含<code>document.write()</code>时。但是现在，<code>document.write()</code>不推荐使用。同时，将<code>&lt;script&gt;</code>标签放在底部，意味着浏览器不能开始下载脚本，直到整个文档（document）被解析。也许，对此比较好的做法是，<code>&lt;script&gt;</code>使用<code>defer</code>属性，放在<code>&lt;head&gt;</code>中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常考问题&quot;&gt;&lt;a href=&quot;#常考问题&quot; class=&quot;headerlink&quot; title=&quot;常考问题&quot;&gt;&lt;/a&gt;常考问题&lt;/h2&gt;&lt;h3 id=&quot;怎么让一个不定宽高的-DIV，垂直水平居中？&quot;&gt;&lt;a href=&quot;#怎么让一个不定宽高的-DIV，垂直水平居中？&quot;
      
    
    </summary>
    
      <category term="前端知识点" scheme="http://www.bluedream.top/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="HTML" scheme="http://www.bluedream.top/tags/HTML/"/>
    
      <category term="Web" scheme="http://www.bluedream.top/tags/Web/"/>
    
      <category term="标签" scheme="http://www.bluedream.top/tags/%E6%A0%87%E7%AD%BE/"/>
    
      <category term="浏览器" scheme="http://www.bluedream.top/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript类、对象和继承</title>
    <link href="http://www.bluedream.top/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9/JavaScript%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%BB%A7%E6%89%BF.html"/>
    <id>http://www.bluedream.top/前端知识点/JavaScript类、对象和继承.html</id>
    <published>2019-09-05T13:10:40.000Z</published>
    <updated>2019-09-20T01:34:49.217Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类的定义、实例化"><a href="#类的定义、实例化" class="headerlink" title="类的定义、实例化"></a>类的定义、实例化</h2><h3 id="JavaScript如何实现一个类，怎么实例化这个类？"><a href="#JavaScript如何实现一个类，怎么实例化这个类？" class="headerlink" title="JavaScript如何实现一个类，怎么实例化这个类？"></a>JavaScript如何实现一个类，怎么实例化这个类？</h3><ul><li><h4 id="构造函数法（this-prototype）-–-用-new-关键字-生成实例对象"><a href="#构造函数法（this-prototype）-–-用-new-关键字-生成实例对象" class="headerlink" title="构造函数法（this + prototype） – 用 new 关键字 生成实例对象"></a>构造函数法（this + prototype） – 用 new 关键字 生成实例对象</h4><p>缺点：用到了 this 和 prototype，编写复杂，可读性差</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mobile</span>(<span class="params">name, price</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.name = name;<span class="comment">//通过this，表明这是一个构造函数</span></span><br><span class="line">   <span class="keyword">this</span>.price = price;</span><br><span class="line"> &#125;</span><br><span class="line"> Mobile.prototype.sell = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name + <span class="string">"，售价 $"</span> + <span class="keyword">this</span>.price);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">var</span> iPhone7 = <span class="keyword">new</span> Mobile(<span class="string">"iPhone7"</span>, <span class="number">1000</span>);</span><br><span class="line"> iPhone7.sell();</span><br></pre></td></tr></table></figure><ul><li><h4 id="Object-create-法-–-用-Object-create-生成实例对象"><a href="#Object-create-法-–-用-Object-create-生成实例对象" class="headerlink" title="Object.create 法 – 用 Object.create() 生成实例对象"></a>Object.create 法 – 用 Object.create() 生成实例对象</h4><p>缺点：不能实现私有属性和私有方法，实例对象之间也不能共享数据</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = &#123;</span><br><span class="line">    firstname: <span class="string">"Mark"</span>,</span><br><span class="line">    lastname: <span class="string">"Yun"</span>,</span><br><span class="line">    age: <span class="number">25</span>,</span><br><span class="line">    introduce: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">'I am '</span> + Person.firstname + <span class="string">' '</span> + Person.lastname);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="built_in">Object</span>.create(Person);</span><br><span class="line">person.introduce();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.create 要求 IE9+，低版本浏览器可以自行部署：</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Object</span>.create) &#123;</span><br><span class="line">　   <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">　　　 <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">　　　 F.prototype = o;</span><br><span class="line">　　　 <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">　　&#125;;</span><br><span class="line">　&#125;</span><br></pre></td></tr></table></figure><ul><li><h4 id="极简主义法（消除-this-和-prototype）-–-调用-createNew-得到实例对象"><a href="#极简主义法（消除-this-和-prototype）-–-调用-createNew-得到实例对象" class="headerlink" title="极简主义法（消除 this 和 prototype） – 调用 createNew() 得到实例对象"></a>极简主义法（消除 this 和 prototype） – 调用 createNew() 得到实例对象</h4><p>优点：容易理解，结构清晰优雅，符合传统的”面向对象编程”的构造</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Cat = &#123;</span><br><span class="line">  age: <span class="number">3</span>, <span class="comment">// 共享数据 -- 定义在类对象内，createNew() 外</span></span><br><span class="line">  createNew: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cat = &#123;&#125;;</span><br><span class="line">    <span class="comment">// var cat = Animal.createNew(); // 继承 Animal 类</span></span><br><span class="line">    cat.name = <span class="string">"小咪"</span>;</span><br><span class="line">    <span class="keyword">var</span> sound = <span class="string">"喵喵喵"</span>; <span class="comment">// 私有属性--定义在 createNew() 内，输出对象外</span></span><br><span class="line">    cat.makeSound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(sound);  <span class="comment">// 暴露私有属性</span></span><br><span class="line">    &#125;;</span><br><span class="line">    cat.changeAge = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">      Cat.age = num; <span class="comment">// 修改共享数据</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> cat; <span class="comment">// 输出对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = Cat.createNew();</span><br><span class="line">cat.makeSound();</span><br></pre></td></tr></table></figure><ul><li><h4 id="ES6-语法糖-class-–-用-new-关键字-生成实例对象"><a href="#ES6-语法糖-class-–-用-new-关键字-生成实例对象" class="headerlink" title="ES6 语法糖 class – 用 new 关键字 生成实例对象"></a>ES6 语法糖 class – 用 new 关键字 生成实例对象</h4><p>类的实例化很简单，直接 <code>new</code> 出来即可。函数可以作为构造函数来使用，通过 new 来实例化，其实函数本身也是一个对象。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">     <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">       <span class="keyword">this</span>.x = x;<span class="comment">//可以在构造函数里写属性</span></span><br><span class="line">       <span class="keyword">this</span>.y = y;</span><br><span class="line">     &#125;</span><br><span class="line">     toString() &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> point = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="什么是面向对象？"><a href="#什么是面向对象？" class="headerlink" title="什么是面向对象？"></a>什么是面向对象？</h3><p>面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</p><h4 id="面向对象和面向过程的异同"><a href="#面向对象和面向过程的异同" class="headerlink" title="面向对象和面向过程的异同"></a>面向对象和面向过程的异同</h4><ul><li>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。</li><li>面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</li></ul><h4 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h4><ul><li>封装</li><li>继承</li><li>多态</li></ul><h3 id="谈谈This对象的理解"><a href="#谈谈This对象的理解" class="headerlink" title="谈谈This对象的理解"></a>谈谈This对象的理解</h3><ul><li>this总是指向函数的直接调用者（而非间接调用者）</li><li>如果有new关键字，this指向new出来的那个对象</li><li>在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent（触发事件）中的this总是指向全局对象Window</li></ul><h3 id="原型的constructor属性"><a href="#原型的constructor属性" class="headerlink" title="原型的constructor属性"></a>原型的<code>constructor</code>属性</h3><p><strong>问题：</strong>已知A继承了B，B继承了C。怎么判断 a 是由A<strong>直接生成</strong>的实例，还是B直接生成的实例呢？还是C直接生成的实例呢？</p><blockquote><p>分析：这就要用到原型的<code>constructor</code>属性了。</p></blockquote><ul><li><code>foo.__proto__.constructor === M</code>的结果为<code>true</code>，但是 <code>foo.__proto__.constructor === Object</code>的结果为<code>false</code>。</li><li>所以，用 <code>consturctor</code>判断就比用 <code>instanceof</code>判断，更为严谨。</li></ul><h3 id="new-操作符具体干了什么呢"><a href="#new-操作符具体干了什么呢" class="headerlink" title="new 操作符具体干了什么呢?"></a>new 操作符具体干了什么呢?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function Test()&#123;&#125;</span><br><span class="line">const test = new Test()</span><br></pre></td></tr></table></figure><ol><li>创建一个<strong>新的空对象实例</strong>。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>设置新对象的 constructor 属性为构造函数的名称，设置新对象的<strong>proto</strong>属性指向构造函数的 prototype 对象（设置原型链）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.constructor = Test</span><br><span class="line">obj.__proto__ = Test.prototype</span><br></pre></td></tr></table></figure><ol start="3"><li>使用新对象调用函数，函数中的 this 被指向新实例对象（执行构造函数，传入相应的参数，如果没有参数就不用传；让 Func 中的 this 指向 obj，并执行 Func 的函数体）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test.call(obj)</span><br></pre></td></tr></table></figure><ol start="4"><li>将初始化完毕的新对象地址，保存到等号左边的变量中。判断 Func 的返回值类型： 如果无返回值或者返回一个非对象值，则就将步骤（1）创建的对象返回；如果返回值是一个新对象的话那么直接直接返回该对象。</li></ol><h3 id="new操作符具体干了什么呢"><a href="#new操作符具体干了什么呢" class="headerlink" title="new操作符具体干了什么呢?"></a>new操作符具体干了什么呢?</h3><ul><li>创建一个空实例对象，并且 this 变量引用该对象，同时还继承了该函数的原型</li><li>属性和方法被加入到 this 引用的对象中</li><li>新创建的对象由 this 所引用，并且最后隐式的返回 this</li></ul><h3 id="call-和-apply-的含义和区别？"><a href="#call-和-apply-的含义和区别？" class="headerlink" title="call() 和 apply() 的含义和区别？"></a>call() 和 apply() 的含义和区别？</h3><h4 id="含义："><a href="#含义：" class="headerlink" title="含义："></a>含义：</h4><ul><li><p>call：调用一个对象的一个方法，用另一个对象替换当前对象。</p><p>例如：B.call(A, args1,args2);即 A 对象调用 B 对象的方法。</p></li><li><p>apply：调用一个对象的一个方法，用另一个对象替换当前对象。</p><p>例如：B.apply(A, arguments);即 A 对象应用 B 对象的方法。</p></li></ul><h4 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h4><ul><li>方法的含义是一样的，即方法功能是一样的；</li><li>第一个参数的作用是一样的；</li></ul><h4 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h4><p>两者传入的列表形式不一样</p><ul><li>call 可以传入多个参数；</li><li>apply 只能传入两个参数，所以其第二个参数往往是作为数组形式传入</li></ul><h3 id="javascript-的本地对象，内置对象和宿主对象"><a href="#javascript-的本地对象，内置对象和宿主对象" class="headerlink" title="javascript 的本地对象，内置对象和宿主对象"></a>javascript 的本地对象，内置对象和宿主对象</h3><ul><li><strong>本地对象</strong><br>ECMA-262 把本地对象（native object）定义为“独立于宿主环境的 ECMAScript 实现提供的对象”。简单来说，本地对象就是 ECMA-262 定义的类（引用类型）。它们包括：Object、Function、Array、String、Boolean、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError</li><li><strong>内置对象</strong><br>JS中内置了17个对象，常用的是Array对象、Date对象、正则表达式对象、string对象、Global对象</li><li><strong>宿主对象</strong><br>由ECMAScript实现的宿主环境提供的对象，可以理解为：浏览器提供的对象。所有的BOM和DOM都是宿主对象。</li></ul><h3 id="如何判断一个对象是否属于某个类？"><a href="#如何判断一个对象是否属于某个类？" class="headerlink" title="如何判断一个对象是否属于某个类？"></a>如何判断一个对象是否属于某个类？</h3><p>instanceof</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">  alert(<span class="string">"yes"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象的几种创建方式"><a href="#对象的几种创建方式" class="headerlink" title="对象的几种创建方式"></a>对象的几种创建方式</h3><blockquote><p>javascript创建对象简单的说,无非就是用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用</p></blockquote><h4 id="第一种：内置对象Object-创建"><a href="#第一种：内置对象Object-创建" class="headerlink" title="第一种：内置对象Object 创建"></a>第一种：内置对象Object 创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var wcDog =new Object();</span><br><span class="line">     wcDog.name=&quot;旺财&quot;;</span><br><span class="line">     wcDog.age=3;</span><br><span class="line">     wcDog.work=function()&#123;</span><br><span class="line">       alert(&quot;我是&quot;+wcDog.name+&quot;,汪汪汪......&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     wcDog.work();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">Person.name = <span class="string">"Nike"</span>;</span><br><span class="line">Person.age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure><p>这行代码创建了 Object 引用类型的一个新实例，然后把实例保存在变量 Person 中。</p><h4 id="第二种：使用对象字面量表示法"><a href="#第二种：使用对象字面量表示法" class="headerlink" title="第二种：使用对象字面量表示法"></a>第二种：使用对象字面量表示法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = &#123;&#125;; <span class="comment">//相当于 var Person = new Object();</span></span><br><span class="line"><span class="keyword">var</span> Person = &#123;</span><br><span class="line">name: <span class="string">'Nike'</span>;</span><br><span class="line">age: <span class="number">29</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。也就是说，第一种和第二种方式创建对象的方法其实都是一样的，只是写法上的区别不同</p><p>在介绍第三种的创建方法之前，我们应该要明白为什么还要用别的方法来创建对象，也就是第一种，第二种方法的缺点所在：它们都是用了同一个接口创建很多对象，会产生大量的重复代码，就是如果你有 100 个对象，那你要输入 100 次很多相同的代码。那我们有什么方法来避免过多的重复代码呢，就是把创建对象的过程封装在函数体内，通过函数的调用直接生成对象。</p><h4 id="第三种：使用工厂模式创建对象"><a href="#第三种：使用工厂模式创建对象" class="headerlink" title="第三种：使用工厂模式创建对象"></a>第三种：使用工厂模式创建对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.job = job;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nike"</span>, <span class="number">29</span>, <span class="string">"teacher"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"Arvin"</span>, <span class="number">20</span>, <span class="string">"student"</span>);</span><br></pre></td></tr></table></figure><p>在使用工厂模式创建对象的时候，我们都可以注意到，在 createPerson 函数中，返回的是一个对象。那么我们就无法判断返回的对象究竟是一个什么样的类型。于是就出现了第四种创建对象的模式。</p><h4 id="第四种-使用构造函数创建对象"><a href="#第四种-使用构造函数创建对象" class="headerlink" title="第四种:使用构造函数创建对象"></a>第四种:使用构造函数创建对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nike"</span>, <span class="number">29</span>, <span class="string">"teacher"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Arvin"</span>, <span class="number">20</span>, <span class="string">"student"</span>);</span><br></pre></td></tr></table></figure><p>对比工厂模式，我们可以发现以下区别：</p><p>1.没有显示地创建对象</p><p>2.直接将属性和方法赋给了 this 对象</p><p>3.没有 return 语句</p><p>4.终于可以识别的对象的类型。对于检测对象类型，我们应该使用 instanceof 操作符，我们来进行自主检测：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alert(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//ture</span></span><br><span class="line"></span><br><span class="line">alert(person1 <span class="keyword">instanceof</span> Person); <span class="comment">//ture</span></span><br><span class="line"></span><br><span class="line">alert(person2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//ture</span></span><br><span class="line"></span><br><span class="line">alert(person2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//ture</span></span><br></pre></td></tr></table></figure><p>同时我们也应该明白，按照惯例，构造函数始终要应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。</p><p>那么构造函数确实挺好用的，但是它也有它的缺点：</p><p>就是每个方法都要在每个实例上重新创建一遍，方法指的就是我们在对象里面定义的函数。如果方法的数量很多，就会占用很多不必要的内存。于是出现了第五种创建对象的方法</p><h4 id="第五种：原型创建对象模式"><a href="#第五种：原型创建对象模式" class="headerlink" title="第五种：原型创建对象模式"></a>第五种：原型创建对象模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Dog()&#123;&#125;</span><br><span class="line">Dog.prototype.name=&quot;旺财&quot;;</span><br><span class="line">Dog.prototype.eat=function()&#123;</span><br><span class="line">alert(this.name+&quot;是个吃货&quot;);</span><br><span class="line">&#125;</span><br><span class="line">var wangcai =new Dog();</span><br><span class="line">wangcai.eat();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nike"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">20</span>;</span><br><span class="line">Person.prototype.jbo = <span class="string">"teacher"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName();</span><br></pre></td></tr></table></figure><p>使用原型创建对象的方式，可以让所有对象实例共享它所包含的属性和方法。</p><p>如果是使用原型创建对象模式，请看下面代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nike"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">20</span>;</span><br><span class="line">Person.prototype.jbo = <span class="string">"teacher"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.name = <span class="string">"Greg"</span>;</span><br><span class="line">alert(person1.name); <span class="comment">//'Greg' --来自实例</span></span><br><span class="line">alert(person2.name); <span class="comment">//'Nike' --来自原型</span></span><br></pre></td></tr></table></figure><p>当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性。</p><p>这时候我们就可以使用构造函数模式与原型模式结合的方式，构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性</p><h4 id="第六种：组合使用构造函数模式和原型模式"><a href="#第六种：组合使用构造函数模式和原型模式" class="headerlink" title="第六种：组合使用构造函数模式和原型模式"></a>第六种：组合使用构造函数模式和原型模式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.job = job;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line"><span class="keyword">constructor</span>: Person,</span><br><span class="line">sayName: function() &#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Nike'</span>, <span class="number">20</span>, <span class="string">'teacher'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Car(name,price)&#123;</span><br><span class="line">     this.name=name;</span><br><span class="line">     this.price=price; </span><br><span class="line">   &#125;</span><br><span class="line">    Car.prototype.sell=function()&#123;</span><br><span class="line">      alert(&quot;我是&quot;+this.name+&quot;，我现在卖&quot;+this.price+&quot;万元&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">   var camry =new Car(&quot;凯美瑞&quot;,27);</span><br><span class="line">   camry.sell();</span><br></pre></td></tr></table></figure><ul><li><h4 id="用function来模拟无参的构造函数"><a href="#用function来模拟无参的构造函数" class="headerlink" title="用function来模拟无参的构造函数"></a>用function来模拟无参的构造函数</h4></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> function Person()&#123;&#125;</span><br><span class="line"> //定义一个function，如果使用new&quot;实例化&quot;,该function可以看作是一个Class</span><br><span class="line">    var person=new Person();</span><br><span class="line">        person.name=&quot;Mark&quot;;</span><br><span class="line">        person.age=&quot;25&quot;;</span><br><span class="line">        person.work=function()&#123;</span><br><span class="line">        alert(person.name+&quot; hello...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">person.work();</span><br></pre></td></tr></table></figure><ul><li><h4 id="用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）"><a href="#用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）" class="headerlink" title="用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）"></a>用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）</h4></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Pet(name,age,hobby)&#123;</span><br><span class="line">       this.name=name;//this作用域：当前对象</span><br><span class="line">       this.age=age;</span><br><span class="line">       this.hobby=hobby;</span><br><span class="line">       this.eat=function()&#123;</span><br><span class="line">          alert(&quot;我叫&quot;+this.name+&quot;,我喜欢&quot;+this.hobby+&quot;,是个程序员&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var maidou =new Pet(&quot;麦兜&quot;,25,&quot;coding&quot;);//实例化、创建对象</span><br><span class="line">    maidou.eat();//调用eat方法</span><br></pre></td></tr></table></figure><hr><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><blockquote><p>继承的本质就是原型链。（这些问题必问的，其实就是考察你对原型链的掌握程度。）</p></blockquote><h3 id="Javascript如何实现继承？"><a href="#Javascript如何实现继承？" class="headerlink" title="Javascript如何实现继承？"></a>Javascript如何实现继承？</h3><ul><li>构造函数绑定：使用 call 或 apply 方法，将父对象的构造函数绑定在子对象上</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,color</span>)</span>&#123;</span><br><span class="line"> 　Animal.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line"> 　<span class="keyword">this</span>.name = name;</span><br><span class="line"> 　<span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实例继承：将子对象的 prototype 指向父对象的一个实例     </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">Cat.prototype.constructor = Cat;</span><br></pre></td></tr></table></figure><ul><li>拷贝继承：如果把父对象的所有属性和方法，拷贝进子对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">Child, Parent</span>) </span>&#123;</span><br><span class="line">  　　　<span class="keyword">var</span> p = Parent.prototype;</span><br><span class="line">  　　　<span class="keyword">var</span> c = Child.prototype;</span><br><span class="line">  　　　<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</span><br><span class="line">  　　　   c[i] = p[i];</span><br><span class="line">  　　　&#125;</span><br><span class="line">  　　　c.uber = p;</span><br><span class="line">  　 &#125;</span><br></pre></td></tr></table></figure><ul><li>原型继承：将子对象的 prototype 指向父对象的 prototype      </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">Child, Parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  　F.prototype = Parent.prototype;</span><br><span class="line">  　Child.prototype = <span class="keyword">new</span> F();</span><br><span class="line">  　Child.prototype.constructor = Child;</span><br><span class="line">  　Child.uber = Parent.prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ES6 语法糖 extends：class ColorPoint extends Point {}</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">   <span class="keyword">constructor</span>(x, y, color) &#123;</span><br><span class="line">      <span class="keyword">super</span>(x, y); <span class="comment">// 调用父类的constructor(x, y)</span></span><br><span class="line">      <span class="keyword">this</span>.color = color;</span><br><span class="line">   &#125;</span><br><span class="line">   toString() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.color + <span class="string">' '</span> + <span class="keyword">super</span>.toString(); <span class="comment">// 调用父类的toString()</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Parent()&#123;</span><br><span class="line">       this.name = &apos;wang&apos;;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   function Child()&#123;</span><br><span class="line">       this.age = 28;</span><br><span class="line">   &#125;</span><br><span class="line">   Child.prototype = new Parent();//继承了Parent，通过原型</span><br><span class="line"></span><br><span class="line">   var demo = new Child();</span><br><span class="line">   alert(demo.age);</span><br><span class="line">   alert(demo.name);//得到被继承的属性</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="JavaScript-继承方式和优缺点"><a href="#JavaScript-继承方式和优缺点" class="headerlink" title="JavaScript 继承方式和优缺点"></a>JavaScript 继承方式和优缺点</h3><h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'kevin'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.getName()) <span class="comment">// kevin</span></span><br></pre></td></tr></table></figure><p>缺点：</p><p>1.引用类型的属性被所有实例共享，举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.names = [<span class="string">'kevin'</span>, <span class="string">'daisy'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line">child1.names.push(<span class="string">'yayu'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.names); <span class="comment">// ["kevin", "daisy", "yayu"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.names); <span class="comment">// ["kevin", "daisy", "yayu"]</span></span><br></pre></td></tr></table></figure><p>2.在创建 Child 的实例时，不能向Parent传参</p><p>3.字面量重写原型会中断关系，使用引用类型的原型</p><h4 id="借用构造函数-经典继承"><a href="#借用构造函数-经典继承" class="headerlink" title="借用构造函数(经典继承)"></a>借用构造函数(经典继承)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.names = [<span class="string">'kevin'</span>, <span class="string">'daisy'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line">child1.names.push(<span class="string">'yayu'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.names); <span class="comment">// ["kevin", "daisy", "yayu"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.names); <span class="comment">// ["kevin", "daisy"]</span></span><br></pre></td></tr></table></figure><p>优点：</p><p>1.避免了引用类型的属性被所有实例共享</p><p>2.可以在 Child 中向 Parent 传参</p><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kevin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.name); <span class="comment">// kevin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child(<span class="string">'daisy'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.name); <span class="comment">// daisy</span></span><br></pre></td></tr></table></figure><p>缺点：</p><p>方法都在构造函数中定义，每次创建实例都会创建一遍方法。</p><p>没有原型，则复用无从谈起。</p><h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><p>原型链继承和经典继承双剑合璧。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kevin'</span>, <span class="string">'18'</span>);</span><br><span class="line"></span><br><span class="line">child1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.name); <span class="comment">// kevin</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.age); <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.colors); <span class="comment">// ["red", "blue", "green", "black"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child(<span class="string">'daisy'</span>, <span class="string">'20'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.name); <span class="comment">// daisy</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.age); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.colors); <span class="comment">// ["red", "blue", "green"]</span></span><br></pre></td></tr></table></figure><p>优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。</p><p>其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。</p><h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。</p><p>缺点：</p><p>包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'kevin'</span>,</span><br><span class="line">    friends: [<span class="string">'daisy'</span>, <span class="string">'kelly'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = createObj(person);</span><br><span class="line"><span class="keyword">var</span> person2 = createObj(person);</span><br><span class="line"></span><br><span class="line">person1.name = <span class="string">'person1'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// kevin</span></span><br><span class="line"></span><br><span class="line">person1.firends.push(<span class="string">'taylor'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person2.friends); <span class="comment">// ["daisy", "kelly", "taylor"]</span></span><br></pre></td></tr></table></figure><p>注意：修改<code>person1.name</code>的值，<code>person2.name</code>的值并未发生改变，并不是因为<code>person1</code>和<code>person2</code>有独立的 name 值，而是因为<code>person1.name = &#39;person1&#39;</code>，给<code>person1</code>添加了 name 值，并非修改了原型上的 name 值。</p><h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = object.create(o);</span><br><span class="line">    clone.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。</p><h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><p>为了方便大家阅读，在这里重复一下组合继承的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kevin'</span>, <span class="string">'18'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1)</span><br></pre></td></tr></table></figure><p>组合继承最大的缺点是会调用两次父构造函数。</p><p>一次是设置子类型实例的原型的时候：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure><p>一次在创建子类型实例的时候：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kevin'</span>, <span class="string">'18'</span>);</span><br></pre></td></tr></table></figure><p>回想下 new 的模拟实现，其实在这句中，我们会执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Parent.call(<span class="keyword">this</span>, name);</span><br></pre></td></tr></table></figure><p>在这里，我们又会调用了一次 Parent 构造函数。</p><p>所以，在这个例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为<code>colors</code>，属性值为<code>[&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;]</code>。</p><p>那么我们该如何精益求精，避免这一次重复调用呢？</p><p>如果我们不使用 Child.prototype = new Parent() ，而是间接的让 Child.prototype 访问到 Parent.prototype 呢？</p><p>看看如何实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键的三步</span></span><br><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">F.prototype = Parent.prototype;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> F();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kevin'</span>, <span class="string">'18'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1);</span><br></pre></td></tr></table></figure><p>最后我们封装一下这个继承方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prototype</span>(<span class="params">child, parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = object(parent.prototype);</span><br><span class="line">    prototype.constructor = child;</span><br><span class="line">    child.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当我们使用的时候：</span></span><br><span class="line">prototype(Child, Parent);</span><br></pre></td></tr></table></figure><p>优点：引用《JavaScript高级程序设计》中对寄生组合式继承的夸赞就是：</p><p>1.这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。</p><p>2.与此同时，原型链还能保持不变；</p><p>3.因此，还能够正常使用 instanceof 和 isPrototypeOf。</p><p>开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p><h3 id="如何避免原型链上面的对象共享"><a href="#如何避免原型链上面的对象共享" class="headerlink" title="如何避免原型链上面的对象共享"></a>如何避免原型链上面的对象共享</h3><p>避免对象共享可以参考经典的 extend()函数，很多前端框架都有封装的，就是用一个空函数当做中间变量</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;类的定义、实例化&quot;&gt;&lt;a href=&quot;#类的定义、实例化&quot; class=&quot;headerlink&quot; title=&quot;类的定义、实例化&quot;&gt;&lt;/a&gt;类的定义、实例化&lt;/h2&gt;&lt;h3 id=&quot;JavaScript如何实现一个类，怎么实例化这个类？&quot;&gt;&lt;a href=&quot;#Ja
      
    
    </summary>
    
      <category term="前端知识点" scheme="http://www.bluedream.top/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="JavaScript" scheme="http://www.bluedream.top/tags/JavaScript/"/>
    
      <category term="面向对象" scheme="http://www.bluedream.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="类" scheme="http://www.bluedream.top/tags/%E7%B1%BB/"/>
    
      <category term="对象" scheme="http://www.bluedream.top/tags/%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="继承" scheme="http://www.bluedream.top/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>面试技巧</title>
    <link href="http://www.bluedream.top/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7.html"/>
    <id>http://www.bluedream.top/前端面试题/面试技巧.html</id>
    <published>2019-09-02T07:30:21.000Z</published>
    <updated>2019-09-28T09:45:22.556Z</updated>
    
    <content type="html"><![CDATA[<p>面试是一个非常重要的过程，有些人在这个过程中感到不知所措，或者做得不好，使自己在求职中因小失大，达不到成功。在求职过程中注意了以下基本礼仪和技巧，才能达到事半功倍，增强面试的有效性。</p><h3 id="面试前准备"><a href="#面试前准备" class="headerlink" title="面试前准备"></a>面试前准备</h3><p>（1）穿着得体，干净。</p><p>（2）对公司做简单的了解</p><p>（3）保证充足睡眠，保持自信</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>(1)一旦约好面试时间，一定要提前 5-10 分钟到达地点，以表示求职者的诚意，给对方以信任感。</p><p>(2)面试时不要紧张，保持微笑，如果门关着，应先敲门，得到允许后再进去。开关门动作要轻。</p><p>(3) 对于面试官的问题要一一回答，可以适当点头，不要打断用人单位的问话或抢问抢答。回答问题是眼睛要注视面试官，切记不要左顾右盼。</p><h3 id="谈话技巧"><a href="#谈话技巧" class="headerlink" title="谈话技巧"></a>谈话技巧</h3><p>(1)自我介绍在三分钟之内，口齿清晰，语言流利，吐字清晰。</p><p>(2) 注意听者的反应。比如，听者心不在焉，可能表示他对自己这段话没有兴趣，你得设法转移话题；侧耳倾听，可能说明由于自己音量过小使对方难于听清；皱眉、摆头可能表示自己言语有不当之处。根据对方的这些反应，就要适时地调整自己的语言、语调、语气、音量、修辞，包括陈述内容。这样才能取得良好的面试效果。</p><p>(3) 表示关注的手势。在与他人交谈中，一定要对对方的谈话表示关注，要表示出你在聚精会神地听。对方在感到自己的谈话被人关注和理解后，才能愉快专心地听取你的谈话，并对你产生好感。</p><h3 id="回答问题的技巧"><a href="#回答问题的技巧" class="headerlink" title="回答问题的技巧"></a>回答问题的技巧</h3><p>(1) 把握重点，简捷明了，条理清楚，有理有据。一般情况下回答问题要结论在先，议论在后，先将自己的中心意思表达清晰，然后再做叙述和论证。否则，长篇大论，会让人不得要领。面试时间有限，神经有些紧张，多余的话太多，容易走题，反倒会将主题冲淡或漏掉。</p><p>(2) 讲清原委，避免抽象。　用人单位提问总是想了解一些应试者的具体情况，切不可简单地仅以“是”和“否”作答。应针对所提问题的不同，有的需要解释原因，有的需要说明程度。不讲原委，过于抽象的回答，往往不会给主试者留下具体的印象。</p><p>(3) 确认提问内容，切忌答非所问。面试中，如果对用人单位提出的问题，一时摸不到边际，以致不知从何答起或难以理解对方问题的含义时，可将问题复述一遍，并先谈自己对这一问题的理解，请教对方以确认内容。对不太明确的问题，一定要搞清楚，这样才会有的放矢，不致答非所问。</p><p>(4) 有个人见解，有个人特色。用人单位有时接待应试者若干名，相同的问题问若干遍，类似的回答也要听若干遍。因此，用人单位会有乏味、枯燥之感。只有具有独到的个人见解和个人特色的回答，才会引起对方的兴趣和注意。</p><p>(5) 知之为知之，不知为不知。面试遇到自己不知、不懂、不会的问题时，回避闪烁，默不作声，牵强附会，不懂装懂的做法均不足取，诚恳坦率地承认自己的不足之处，反倒会赢得主试者的信任和好感。</p><p>总结：保持自信，做自我介绍时，时间应控制在三分钟之内，不要啰嗦，把自己取得过什么成就，或者在公司做过什么贡献，总结自己的优势时刻保持微笑。最后，紧张的同学，可以把面试官当做同事，面试是一个相互选择的过程，你找我我还不一定干呢。</p><h3 id="请你自我介绍一下你自己"><a href="#请你自我介绍一下你自己" class="headerlink" title="请你自我介绍一下你自己"></a>请你自我介绍一下你自己</h3><p>回答提示：一般人回答这个问题过于平常，只说姓名、年龄、爱好、工作经验，这些在简历上都有，其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，这些都可以和学习无关，也可以和学习有关，但要突出积极的个性和做事的能力，说得合情合理企业才会相信。企业很重视一个人的礼貌，求职者要尊重考官，在回答每个问题之后都说一句“谢谢”。企业喜欢有礼貌的求职者。</p><p>回答样本：</p><p>1、我叫xxx,来自于xxx，从网上看得到公司招聘的这个职位，觉得非常适合自己的发展。所以来这里争取下这份工作。<br>2、接下来可以讲解自己的核心竞争力（最强的技能、最深入研究的知识领域、个性中最积极的部分）和闪光点（做过的最成功的事，主要的成就）。核心就是要体现自己胜任这份工作（介绍时候要自然有底气，合情合理，面试前要充分准备好）。<br>3、先介绍到这里，面试官看看有什么问题，我可以再补充。<br>4、最后要说谢谢，任何企业都喜欢有礼貌的人！</p><p>注意：自曝其短（说自己的缺点）没有必要，自我介绍的时候千万不要和简历有冲突！</p><h3 id="你觉得你个性上最大的优点是什么？"><a href="#你觉得你个性上最大的优点是什么？" class="headerlink" title="你觉得你个性上最大的优点是什么？"></a>你觉得你个性上最大的优点是什么？</h3><p>回答提示：沉着冷静、条理清楚、立场坚定、顽强向上、乐于助人和关心他人、适应能力和幽默感、乐观和友爱、技术狂热、学习能力强、为人谦和。</p><h3 id="说说你最大的缺点？"><a href="#说说你最大的缺点？" class="headerlink" title="说说你最大的缺点？"></a>说说你最大的缺点？</h3><p>回答提示：这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼、爱忌妒人、非常懒、脾气大、工作效率低，企业肯定不会录用你。绝对不要自作聪明地回答“我最大的缺点是过于追求完美”，有的人以为这样回答会显得自己比较出色，但事实上，他已经岌芨可危了。企业喜欢求职者从自己的优点说起，中间加一些小缺点，最后再把问题转回到优点上，突出优点的部分。企业喜欢聪明的求职者。</p><h3 id="你对加班的看法？"><a href="#你对加班的看法？" class="headerlink" title="你对加班的看法？"></a>你对加班的看法？</h3><p>回答提示：实际上好多公司问这个问题，并不证明一定要加班。 只是想测试你是否愿意为公司奉献。<br>回答样本：如果是工作需要我会义不容辞加班。我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。</p><h3 id="你对薪资的要求？"><a href="#你对薪资的要求？" class="headerlink" title="你对薪资的要求？"></a>你对薪资的要求？</h3><p>回答提示：如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高，那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求聘的职位定下开支预算，因而他们第一次提出的价钱往往是他们所能给予的最高价钱。他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。</p><p>回答样本一：“我对工资没有硬性要求。我相信贵公司在处理我的问题上会友善合理。我注重的是找对工作机会，所以只要条件公平，我则不会计较太多</p><p>回答样本二：我受过系统的软件编程的训练，不需要进行大量的培训。而且我本人也对编程特别感兴趣。因此，我希望公司能根据我的情况和市场标准的水平，给我合理的薪水。</p><p>回答样本三：如果你必须自己说出具体数目，请不要说一个宽泛的范围，那样你将只能得到最低限度的数字。最好给出一个具体的数字，这样表明你已经对当今的人才市场作了调查，知道像自己这样学历的雇员有什么样的价值。</p><p>我们先来了解面试官如何评判应聘者的工资，知己知彼才能对症下药啊！</p><p>一些正规的大公司主要是根据以下四个方面进行评判（重要性从上至下）</p><p>1、掌握的技术（通过笔试、项目经验、工作时间）<br>2、表达<br>3、学历<br>4、其他素质（如英语四六级等）</p><p>面试官评判应聘者工资的重要性之所以采取如此的顺序，根本原因在于面试官最最重要的是程序员能不能把工作做好，让公司放心。所以学员技术很重要，表达也很重要（技术牛但不会表达，也会让人怀疑技术实力）</p><h3 id="当-HR-问：你对薪资有什么要求？"><a href="#当-HR-问：你对薪资有什么要求？" class="headerlink" title="当 HR 问：你对薪资有什么要求？"></a>当 HR 问：你对薪资有什么要求？</h3><p>大家找工作，都希望找个高薪的，那我们如何和公司去谈薪酬呢？如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高，那又会显得你分量过重，公司受用不起。这个问题确实是个比较难于回答的问题，处理不好的话，会影响面试的效果，但又是不可避免的一个现实问题。</p><p>对于这个问题，第一首先要知道程序员等级、技能、工资的绑定情况，因为我们前端工程师主要是看技术。技术实力决定了我们的月薪；第二要打探出公司能给出的薪资范围。在这个范围内争取高薪资。</p><p>回答提示：</p><p>第一步是了解对方可以提供的薪酬幅度是多少，这里的关键是善于发问，让对方多讲，而自己了解足够的信息。当经过几轮面试后，面试官会问应聘者：你还有什么想了解的问题吗？应聘者就可问：像你们这样的大企业都有自己的一套薪酬体系，请问可以简单介绍一下吗？面试官一般就会简单介绍一下，如果介绍得不是太详细，还可以问：贵公司的薪酬水平在同行业中的位置是怎样的？除了工资之外还有哪些奖金、福利和培训机会？试用期后工资的加幅是多少？等问题。从对方的回答中，你再对照一下市场行情心里就有底了。</p><p>第二步是根据以上信息，提出自己的期望薪酬。如果对自己想提的薪资还是把握不准，那也可以把问题抛给对方：我想请教一个问题，以我现在的经历、学历和您对我面试的了解，在公司的薪酬体系中大约能达到怎么样的水平？对方就会透露给你准备开的工资水平。</p><h3 id="迂回战术求高薪"><a href="#迂回战术求高薪" class="headerlink" title="迂回战术求高薪"></a>迂回战术求高薪</h3><p>如果你对该公司开出的薪资标准不太满意，就可以尝试用探讨式、协商式的口气去争取高一些：比如我认为工作最重要的是合作开心，薪酬是其次的，不过我原来的月薪是××元，如果跳槽的话就希望自己能有点进步，如果不是让您太为难的话，您看这个工资是不是可以有一点提高？这时要看对方的口气是否可以松动，松动的话则可以再举出你值更高价的理由。</p><p>如果对方的口气坚决，则可以迂回争取试用期的缩短，比如说：我对自己是比较有自信的，您看能不能一步到位直接拿转正期的工资，或者把３个月的试用期缩短为１个月？额外工资多争取。</p><p>很多企业除了正式的工资以外，都会产生一些奖金、福利等额外工资，在这方面应聘者就要大胆争取了。应聘者要注意察言观色见好就收，不要过度要求，否则让对方破例后，到时你进来后对方也会以更高的要求来考核你，还可能答应了最后也不兑现。为了保险起见，应聘者最好让对方在接收函上写明薪酬、试用期限、上班时间等，这样可免去日后口说无凭的纠纷。</p><p>总之，好的薪水是要靠势力得到的,但多调查和多注意这方面的资讯,使自己在面试前做到对这个职位的大致薪水有个了解,就会使你不至于提太高或太低不切实际的要求,从而失去到手的工作。</p><h3 id="HR-指责要薪太高怎么办？"><a href="#HR-指责要薪太高怎么办？" class="headerlink" title="HR 指责要薪太高怎么办？"></a>HR 指责要薪太高怎么办？</h3><p>想象下，当你实事求是的按照以上的方法报出自己的工资为 7000 元的时候，面试官呵呵笑道：“你是应届生，却要求 7000 元的工资，是不是太高了？”此时，你该怎么办？</p><p>回答提示：</p><p>1、北京的生活成本高，3000元在北京生存很艰难，在饭店工作也可能不值这个，北京的web前端平均工资我也是有过了解的。同学大都是这个工资（注意：这个同学可以向HR强调是平时一起讨论问题的同学，暗示水平差不多)；<br>2、上几家都给我6千了，我没有去（觉得自己值多少钱，那就是值多少）；<br>3、我不是乱要价，我有能力完成完成上级交代的任务，创造出超过7000元价值的能力（强调自己的能力）；<br>4、对技术狂热，会沿着前端道路一直往前走（强调自己对这份工作的热爱）；<br>5、再说公司会有试用期，试用期可以低于7000，我会在这个阶段证明我自己的能力，可以如果没有达到，公司也可以开除我。</p><h3 id="在五年的时间内，你的职业规划？"><a href="#在五年的时间内，你的职业规划？" class="headerlink" title="在五年的时间内，你的职业规划？"></a>在五年的时间内，你的职业规划？</h3><p>回答提示：这是每一个应聘者都不希望被问到的问题，但是几乎每个人都会被问到。比较多的答案是“管理者”。但是近几年来，许多公司都已经建立了专门的技术途径。这些工作地位往往被称作“顾问”、“参议技师”或“高级软件工程师”等等。当然，说出其他一些你感兴趣的职位也是可以的，比如产品销售部经理，生产部经理等一些与你的专业有相关背景的工作。要知道，考官总是喜欢有进取心的应聘者，此时如果说“不知道”，或许就会使你丧失一个好机会。最普通的回答应该是 “我准备在技术领域有所作为”或“我希望能按照公司的管理思路发展”。</p><h3 id="你朋友对你的评价？"><a href="#你朋友对你的评价？" class="headerlink" title="你朋友对你的评价？"></a>你朋友对你的评价？</h3><p>回答提示： 想从侧面了解一下你的性格及与人相处的问题。<br>回答样本：“我的朋友都说我是一个可以信赖的人。因为，我一旦答应别人的事情，就一定会做到。如果我做不到，我就不会轻易许诺。<br>回答样本：”我觉的我是一个比较随和的人，与不同的人都可以友好相处。在我与人相处时，我总是能站在别人的角度考虑问题“</p><h3 id="你还有什么问题要问吗？"><a href="#你还有什么问题要问吗？" class="headerlink" title="你还有什么问题要问吗？"></a>你还有什么问题要问吗？</h3><p>回答提示：企业的这个问题看上去可有可无，其实很关键，企业不喜欢说“没有问题”的人，因为其很注重员工的个性和创新能力。企业不喜欢求职者问个人福利之类的问题，如果有人这样问：贵公司对新入公司的员工有没有什么培训项目，我可以参加吗？或者说贵公司的晋升机制是什么样的？企业将很欢迎，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。</p><h3 id="如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？"><a href="#如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？" class="headerlink" title="如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？"></a>如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？</h3><p>回答提示：一段时间发现工作不适合我，有两种情况：</p><p>1、如果你确实热爱这个职业，那你就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距；</p><p>2、你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。</p><h3 id="在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？"><a href="#在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？" class="headerlink" title="在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？"></a>在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？</h3><p>①.原则上我会尊重和服从领导的工作安排；同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法；<br>② 如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作；<br>③.还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见；如领导仍固执己见，我会毫不犹豫地再向上级领导反映。</p><h3 id="你希望与什么样的上级共事？"><a href="#你希望与什么样的上级共事？" class="headerlink" title="你希望与什么样的上级共事？"></a>你希望与什么样的上级共事？</h3><p>① 通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识，这既上一个陷阱，又是一次机会；<br>② 最好回避对上级具体的希望，多谈对自己的要求；<br>③ 如“做为刚步入社会的新人，我应该多要求自己尽快熟悉环境、适应环境，而不应该对环境提出什么要求，只要能发挥我的专长就可以了</p><p>分析：这个问题比较好的回答是，希望我的上级能够在工作中对我多指导，对我工作中的错误能够立即指出。总之，从上级指导这个方面谈，不会有大的纰漏。</p><h3 id="在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？-1"><a href="#在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？-1" class="headerlink" title="在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？"></a>在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？</h3><p>①.原则上我会尊重和服从领导的工作安排；同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法；<br>② 如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作；<br>③.还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见；如领导仍固执己见，我会毫不犹豫地再向上级领导反映。</p><h3 id="与上级意见不一致，你将怎么办？"><a href="#与上级意见不一致，你将怎么办？" class="headerlink" title="与上级意见不一致，你将怎么办？"></a>与上级意见不一致，你将怎么办？</h3><p>① 一般可以这样回答“我会给上级以必要的解释和提醒，在这种情况下，我会服从上级的意见。”<br>② 如果面试你的是总经理，而你所应聘的职位另有一位经理，且这位经理当时不在场，可以这样回答：“对于非原则性问题，我会服从上级的意见，对于涉及公司利益的重大问题，我希望能向更高层领导反映。”</p><p>分析：这个问题的标准答案是思路 1，如果用 2 的回答，必死无疑。你没有摸清楚改公司的内部情况，先想打小报告，这样的人没有人敢要。</p><h3 id="如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？"><a href="#如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？" class="headerlink" title="如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？"></a>如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？</h3><p>回答提示：我首先不会找那位上级领导说明这件事，我会主动找我的主管领导来沟通，因为沟通是解决人际关系的最好办法，但结果会有两种：我的主管领导认识到自己的错误，我想我会视具体情况决定是否原谅他；2.他更加变本加厉的来威胁我，那我会毫不犹豫地找我的上级领导反映此事，因为他这样做会造成负面影响，对今后的工作不利。</p><h3 id="如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？"><a href="#如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？" class="headerlink" title="如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？"></a>如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？</h3><p>① 我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决；<br>② 是责任问题。分清责任，各负其责，如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸，作为一个团队，需要互相提携共同完成工作，安慰同事并且帮助同事查找原因总结经验。<br>③ 总结经验教训，一个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中吸取经验教训，并在今后的工作中避免发生同类的错误。检讨自己的工作方法、分析问题的深度和力度是否不够，以致出现了本可以避免的错误。</p><h3 id="如果你在这次考试中没有被录用，你怎么打算？"><a href="#如果你在这次考试中没有被录用，你怎么打算？" class="headerlink" title="如果你在这次考试中没有被录用，你怎么打算？"></a>如果你在这次考试中没有被录用，你怎么打算？</h3><p>回答提示：现在的社会是一个竞争的社会,从这次面试中也可看出这一点,有竞争就必然有优劣,有成功必定就会有失败.往往成功的背后有许多的困难和挫折,如果这次失败了也仅仅是一次而已,只有经过经验经历的积累才能塑造出一个完全的成功者。我会从以下几个方面来正确看待这次失败.</p><p>第一、要敢于面对,面对这次失败不气馁,接受已经失去了这次机会就不会回头这个现实,从心理意志和精神上体现出对这次失败的抵抗力。要有自信,相信自己经历了这次之后经过努力一定能行.能够超越自我.</p><p>第二、善于反思,对于这次面试经验要认真总结,思考剖析,能够从自身的角度找差距。正确对待自己,实事求是地评价自己,辩证的看待自己的长短得失,做一个明白人.</p><p>第三、走出阴影,要克服这一次失败带给自己的心理压力,时刻牢记自己弱点,防患于未然,加强学习,提高自身素质.</p><p>第四、认真工作,回到原单位岗位上后,要实实在在、踏踏实实地工作,三十六行,行行出状元,争取在本岗位上做出一定的成绩.</p><p>第五、再接再厉,成为软件工程师或网络工程师一直是我的梦想,以后如果有机会我仍然后再次参加竞争.</p><h3 id="谈谈你对跳槽的看法？"><a href="#谈谈你对跳槽的看法？" class="headerlink" title="谈谈你对跳槽的看法？"></a>谈谈你对跳槽的看法？</h3><p>（1）正常的”跳槽”能促进人才合理流动，应该支持；<br>（2）频繁的跳槽对单位和个人双方都不利，应该反对。</p><h3 id="工作中你难以和同事、上司相处，你该怎么办？"><a href="#工作中你难以和同事、上司相处，你该怎么办？" class="headerlink" title="工作中你难以和同事、上司相处，你该怎么办？"></a>工作中你难以和同事、上司相处，你该怎么办？</h3><p>① 我会服从领导的指挥，配合同事的工作。<br>② 我会从自身找原因，仔细分析是不是自己工作做得不好让领导不满意，同事看不惯。还要看看是不是为人处世方面做得不好。如果是这样的话 我会努力改正。<br>③ 如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足。有问题就及时改正。<br>④ 作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看见我在努力，总有一天会对我微笑的！</p><h3 id="假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？"><a href="#假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？" class="headerlink" title="假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？"></a>假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？</h3><p>① 成绩比较突出，得到领导的肯定是件好事情，以后更加努力<br>② 检讨一下自己是不是对工作的热心度超过同事间交往的热心了，加强同事间的交往及共同的兴趣爱好。<br>③ 工作中，切勿伤害别人的自尊心<br>④ 不再领导前拨弄是非<br>⑤ 乐于助人对面</p><h3 id="你最近是否参加了培训课程？谈谈培训课程的内容。是公司资助还是自费参加？"><a href="#你最近是否参加了培训课程？谈谈培训课程的内容。是公司资助还是自费参加？" class="headerlink" title="你最近是否参加了培训课程？谈谈培训课程的内容。是公司资助还是自费参加？"></a>你最近是否参加了培训课程？谈谈培训课程的内容。是公司资助还是自费参加？</h3><p>回答提示：请自行根据自己情况做回答，这个没有统一标准答案。</p><h3 id="你对于我们公司了解多少？"><a href="#你对于我们公司了解多少？" class="headerlink" title="你对于我们公司了解多少？"></a>你对于我们公司了解多少？</h3><p>回答提示：在去公司面试前上网查一下该公司主营业务。</p><h3 id="请说出你选择这份工作的动机？你为什么选择我们公司？"><a href="#请说出你选择这份工作的动机？你为什么选择我们公司？" class="headerlink" title="请说出你选择这份工作的动机？你为什么选择我们公司？"></a>请说出你选择这份工作的动机？你为什么选择我们公司？</h3><p>1.面试前，对应聘公司各方面，要了解详尽！至少要了解到行业、企业、岗位这三方面！最好要准备一些具体的数据和实例！<br>2.面试时候，可以将之前对公司的了解（行业、企业、数据、实例）结合自己的面试岗位，大略的说一遍，然后强调自己“觉得这个工作合适”即可。<br>3.如果对这个行业确实很喜欢，要说出你对这个行业的认识与热爱。</p><h3 id="你最擅长的技术方向是什么？"><a href="#你最擅长的技术方向是什么？" class="headerlink" title="你最擅长的技术方向是什么？"></a>你最擅长的技术方向是什么？</h3><p>回答提示：说和你要应聘的职位相关的课程，表现一下自己的热诚没有什么坏处。</p><h3 id="你能为我们公司带来什么呢？"><a href="#你能为我们公司带来什么呢？" class="headerlink" title="你能为我们公司带来什么呢？"></a>你能为我们公司带来什么呢？</h3><p>① 假如你可以的话，试着告诉他们你可以减低他们的费用——“我已经接受过专业的培训或者工作 X 年，立刻就可以上岗工作”。<br>② 企业很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后说：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多的收益”。企业喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以说：“我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需求和消费。”等等。</p><h3 id="最能概括你自己的三个词是什么？"><a href="#最能概括你自己的三个词是什么？" class="headerlink" title="最能概括你自己的三个词是什么？"></a>最能概括你自己的三个词是什么？</h3><p>回答提示：我经常用的三个词是适应能力强，有责任心和做事有始终，结合具体例子向主考官解释。</p><h3 id="你的业余爱好是什么？"><a href="#你的业余爱好是什么？" class="headerlink" title="你的业余爱好是什么？"></a>你的业余爱好是什么？</h3><p>回答提示：找一些富于团体合作精神的，这里有一个真实的故事：有人被否决掉，因为他的爱好是深海潜水。主考官说：因为这是一项单人活动，我不敢肯定他能否适应团体工作。</p><h3 id="作为被面试者给我打一下分"><a href="#作为被面试者给我打一下分" class="headerlink" title="作为被面试者给我打一下分"></a>作为被面试者给我打一下分</h3><p>回答提示：试着列出四个优点和一个非常非常非常小的缺点，（可以抱怨一下事实，没有明确责任人的缺点是不会有人介意的）。</p><h3 id="你怎么理解你应聘的职位？"><a href="#你怎么理解你应聘的职位？" class="headerlink" title="你怎么理解你应聘的职位？"></a>你怎么理解你应聘的职位？</h3><p>回答提示：把岗位职责和任务及工作态度阐述一下</p><h3 id="喜欢这份工作的哪一点？"><a href="#喜欢这份工作的哪一点？" class="headerlink" title="喜欢这份工作的哪一点？"></a>喜欢这份工作的哪一点？</h3><p>回答提示：相信其实大家心中一定都有答案了吧！每个人的价值观不同，自然评断的标准也会不同，但是，在回答面试官这个问题时可不能太直接就把自己心理的话说出来，尤其是薪资方面的问题，不过一些无伤大雅的回答是不错的考虑，如交通方便，工作性质及内容颇能符合自己的兴趣等等都是不错的答案，不过如果这时自己能仔细思考出这份工作的与众不同之处，相信在面试上会大大加分。</p><h3 id="为什么要离职-您在前一家公司的离职原因是什么"><a href="#为什么要离职-您在前一家公司的离职原因是什么" class="headerlink" title="为什么要离职?您在前一家公司的离职原因是什么?"></a>为什么要离职?您在前一家公司的离职原因是什么?</h3><p>① 回答这个问题时一定要小心，就算在前一个工作受到再大的委屈，对公司有多少的怨言，都千万不要表现出来，尤其要避免对公司本身主管的批评，避免面试官的负面情绪及印象；建议此时最好的回答方式是将问题归咎在自己身上，例如觉得工作没有学习发展的空间，自己想在面试工作的相关产业中多加学习，或是前一份工作与自己的生涯规划不合等等，回答的答案最好是积极正面的。<br>② 我希望能获得一份更好的工作，如果机会来临，我会抓住；我觉得目前的工作，已经达到顶峰，即沒有升迁机会。<br>③ 最重要的是：应聘者要使找招聘单位相信，应聘者在过往的单位的“离职原因”在此家招聘单位里不存在；<br>④ 避免把“离职原因”说得太详细、太具体；<br>⑤ 不能掺杂主观的负面感受，如“太辛苦”、“人际关系复杂”、“管理太混乱”、“公司不重视人才”、“公司排斥我们某某的员工”等；但也不能躲闪、回避，如“想换换环境”、“个人原因”等；<br>⑥ 不能涉及自己负面的人格特征，如不诚实、懒惰、缺乏责任感、不随和等；尽量使解释的理由为应聘者个人形象添彩；</p><p>回答样本：如“我离职是因为这家公司倒闭；我在公司工作了三年多，有较深的感情；从去年始，由于市场形势突变，公司的局面急转直下；到眼下这一步我觉得很遗憾，但还要面对显示，重新寻找能发挥我能力的舞台。”同一个面试问题并非只有一个答案，而同一个答案并不是在任何面试场合都有效，关键在应聘者掌握了规律后，对面试的具体情况进行把握，有意识地揣摩面试官提出问题的心理背景，然后投其所好。</p><p>分析：除非是薪资太低，或者是最初的工作，否则不要用薪资作为理由。“求发展”也被考官听得太多，离职理由要根据每个人的真实离职理由来设计，但是在回答时一定要表现得真诚。实在想不出来的时候，家在外地可以说是因为家中有事，须请假几个月，公司又不可能准假，所以辞职。这个答案一般面试官还能接受。</p><h3 id="说说你对行业、技术发展趋势的看法？"><a href="#说说你对行业、技术发展趋势的看法？" class="headerlink" title="说说你对行业、技术发展趋势的看法？"></a>说说你对行业、技术发展趋势的看法？</h3><p>回答提示：企业对这个问题很感兴趣，只有有备而来的求职者能够过关。求职者可以直接在网上查找对你所申请的行业部门的信息，只有深入了解才能产生独特的见解。企业认为最聪明的求职者是对所面试的公司预先了解很多，包括公司各个部门，发展情况，在面试回答问题的时候可以提到所了解的情况，企业欢迎进入企业的人是“知己”，而不是“盲人”。</p><h3 id="对工作的期望与目标何在？"><a href="#对工作的期望与目标何在？" class="headerlink" title="对工作的期望与目标何在？"></a>对工作的期望与目标何在？</h3><p>回答提示：这是面试者用来评断求职者是否对自己有一定程度的期望、对这份工作是否了解的问题。对于工作有确实学习目标的人通常学习较快，对于新工作自然较容易进入状况，这时建议你，最好针对工作的性质找出一个确实的答案，如业务员的工作可以这样回答：“我的目标是能成为一个超级业务员，将公司的产品广泛的推销出去，达到最好的业绩成效；为了达到这个目标，我一定会努力学习，而我相信以我认真负责的态度，一定可以达到这个目标。”其他类的工作也可以比照这个方式来回答，只要在目标方面稍微修改一下就可以了。</p><h3 id="说说你的家庭"><a href="#说说你的家庭" class="headerlink" title="说说你的家庭"></a>说说你的家庭</h3><p>回答提示：企业面试时询问家庭问题不是非要知道求职者家庭的情况，探究隐私，企业不喜欢探究个人隐私，而是要了解家庭背景对求职者的塑造和影响。企业希望听到的重点也在于家庭对求职者的积极影响。企业最喜欢听到的是：我很爱我的家庭！我的家庭一向很和睦，虽然我的父亲和母亲都是普通人，但是从小，我就看到我父亲起早贪黑，每天工作特别勤劳，他的行动无形中培养了我认真负责的态度和勤劳的精神。我母亲为人善良，对人热情，特别乐于助人，所以在单位人缘很好，她的一言一行也一直在教导我做人的道理。企业相信，和睦的家庭关系对一个人的成长有潜移默化的影响。</p><h3 id="就你申请的这个职位，你认为你还欠缺什么？"><a href="#就你申请的这个职位，你认为你还欠缺什么？" class="headerlink" title="就你申请的这个职位，你认为你还欠缺什么？"></a>就你申请的这个职位，你认为你还欠缺什么？</h3><p>回答提示：企业喜欢问求职者弱点，但精明的求职者一般不直接回答。他们希望看到这样的求职者：继续重复自己的优势，然后说：“对于这个职位和我的能力来说，我相信自己是可以胜任的，只是缺乏经验，这个问题我想我可以进入公司以后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。”企业喜欢能够巧妙地躲过难题的求职者。</p><h3 id="你欣赏哪种性格的人？"><a href="#你欣赏哪种性格的人？" class="headerlink" title="你欣赏哪种性格的人？"></a>你欣赏哪种性格的人？</h3><p>回答提示：诚实、不死板而且容易相处的人、有”实际行动”的人。</p><h3 id="你通常如何处理別人的批评？"><a href="#你通常如何处理別人的批评？" class="headerlink" title="你通常如何处理別人的批评？"></a>你通常如何处理別人的批评？</h3><p>① 沈默是金。不必说什么，否则情况更糟，不过我会接受建设性的批评；</p><p>② 我会等大家冷靜下来再讨论。</p><h3 id="你怎样对待自己的失敗？"><a href="#你怎样对待自己的失敗？" class="headerlink" title="你怎样对待自己的失敗？"></a>你怎样对待自己的失敗？</h3><p>回答提示：我们大家生来都不是十全十美的，我相信我有第二个机会改正我的错误。</p><h3 id="什么会让你有成就感？"><a href="#什么会让你有成就感？" class="headerlink" title="什么会让你有成就感？"></a>什么会让你有成就感？</h3><p>回答提示：为贵公司竭力效劳；尽我所能，完成一个项目</p><h3 id="眼下你生活中最重要的是什么？"><a href="#眼下你生活中最重要的是什么？" class="headerlink" title="眼下你生活中最重要的是什么？"></a>眼下你生活中最重要的是什么？</h3><p>回答提示：对我来说，能在这个领域找到工作是最重要的；望能在贵公司任职对我说最重要。</p><h3 id="你为什么愿意到我们公司来工作？"><a href="#你为什么愿意到我们公司来工作？" class="headerlink" title="你为什么愿意到我们公司来工作？"></a>你为什么愿意到我们公司来工作？</h3><p>回答提示：对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些详细的原因，像“公司本身的高技术开发环境很吸引我。”，“我同公司出生在同样的时代，我希望能够进入一家与我共同成长的公司。”“你们公司一直都稳定发展，在近几年来在市场上很有竞争力。”或者“我认为贵公司能够给我提供一个与众不同的发展道路。”这都显示出你已经做了一些调查，也说明你对自己的未来有了较为具体的远景规划。</p><h3 id="你和别人发生过争执吗？你是怎样解决的？"><a href="#你和别人发生过争执吗？你是怎样解决的？" class="headerlink" title="你和别人发生过争执吗？你是怎样解决的？"></a>你和别人发生过争执吗？你是怎样解决的？</h3><p>回答提示：这是面试中最险恶的问题。其实是考官布下的一个陷阱。千万不要说任何人的过错。应知成功解决矛盾是一个协作团体中成员所必备的能力。假如你工作在一个服务行业，这个问题简直成了最重要的一个环节。你是否能获得这份工作，将取决于这个问题的回答。考官希望看到你是成熟且乐于奉献的。他们通过这个问题了解你的成熟度和处世能力。在没有外界干涉的情况下，通过妥协的方式来解决才是正确答案。</p><h3 id="你做过的哪件事最令自己感到骄傲"><a href="#你做过的哪件事最令自己感到骄傲" class="headerlink" title="你做过的哪件事最令自己感到骄傲?"></a>你做过的哪件事最令自己感到骄傲?</h3><p>回答提示：这是考官给你的一个机会，让你展示自己把握命运的能力。这会体现你潜在的领导能力以及你被提升的可能性。假如你应聘于一个服务性质的单位，你很可能会被邀请去午餐。记住：你的前途取决于你的知识、你的社交能力和综合表现。</p><h3 id="你新到一个部门-一天一个客户来找你解决问题-你努力想让他满意，可是始终达不到群众得满意-他投诉你们部门工作效率低-你这个时候怎么作"><a href="#你新到一个部门-一天一个客户来找你解决问题-你努力想让他满意，可是始终达不到群众得满意-他投诉你们部门工作效率低-你这个时候怎么作" class="headerlink" title="你新到一个部门,一天一个客户来找你解决问题,你努力想让他满意，可是始终达不到群众得满意,他投诉你们部门工作效率低,你这个时候怎么作?"></a>你新到一个部门,一天一个客户来找你解决问题,你努力想让他满意，可是始终达不到群众得满意,他投诉你们部门工作效率低,你这个时候怎么作?</h3><p>(1)首先，我会保持冷静。作为一名工作人员，在工作中遇到各种各样的问题是正常的，关键是如何认识它，积极应对，妥善处理。</p><p>(2)其次，我会反思一下客户不满意的原因。一是看是否是自己在解决问题上的确有考虑的不周到的地方，二是看是否是客户不太了解相关的服务规定而提出超出规定的要求，三是看是否是客户了解相关的规定，但是提出的要求不合理。</p><p>(3)再次，根据原因采取相对的对策。如果是自己确有不周到的地方，按照服务规定作出合理的安排，并向客户作出解释；如果是客户不太了解政策规定而造成的误解，我会向他作出进一步的解释，消除他的误会；如果是客户提出的要求不符合政策规定，我会明确地向他指出。</p><p>(4)再次，我会把整个事情的处理情况向领导作出说明，希望得到他的理解和支持。</p><p>(5)我不会因为客户投诉了我而丧失工作的热情和积极性，而会一如既往地牢记为客户服务的宗旨，争取早日做一名领导信任、公司放心、客户满意的职员。</p><h3 id="对这项工作，你有哪些可预见的困难？"><a href="#对这项工作，你有哪些可预见的困难？" class="headerlink" title="对这项工作，你有哪些可预见的困难？"></a>对这项工作，你有哪些可预见的困难？</h3><p>① 不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行；<br>② 可以尝试迂回战术，说出应聘者对困难所持有的态度——“工作中出现一些困难是正常的，也是难免的，但是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以克服。”</p><p>分析：一般问这个问题，面试者的希望就比较大了，因为已经在谈工作细节。但常规思路中的回答，又被面试官“骗”了。当面试官询问这个问题的时候，有两个目的。</p><p>第一，看看应聘者是不是在行，说出的困难是不是在这个职位中一般都不可避免的问题。</p><p>第二，是想看一下应聘者解决困难的手法对不对，及公司能否提供这样的资源。而不是想了解应聘者对困难的态度。</p><h3 id="如果我录用你，你将怎样开展工作？"><a href="#如果我录用你，你将怎样开展工作？" class="headerlink" title="如果我录用你，你将怎样开展工作？"></a>如果我录用你，你将怎样开展工作？</h3><p>① 如果应聘者对于应聘的职位缺乏足够的了解，最好不要直接说出自己开展工作的具体办法；<br>② 可以尝试采用迂回战术来回答，如“首先听取领导的指示和要求，然后就有关情况进行了解和熟悉，接下来制定一份近期的工作计划并报领导批准，最后根据计划开展工作。”</p><p>分析：这个问题的主要目的也是了解应聘者的工作能力和计划性、条理性，而且重点想要知道细节。如果向思路中所讲的迂回战术，面试官会认为回避问题，如果引导了几次仍然是回避的话。此人绝对不会录用了。</p><h3 id="你工作经验欠缺，如何能胜任这项工作？"><a href="#你工作经验欠缺，如何能胜任这项工作？" class="headerlink" title="你工作经验欠缺，如何能胜任这项工作？"></a>你工作经验欠缺，如何能胜任这项工作？</h3><p>① 如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在乎“经验”，关键看应聘者怎样回答；<br>② 对这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业；<br>③ 如“作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。”</p><p>点评：这个问题思路中的答案尚可。突出自己的吃苦能力和适应性以及学习能力（不是学习成绩）为好。</p><h3 id="为了做好你工作份外之事，你该怎样获得他人的支持和帮助？"><a href="#为了做好你工作份外之事，你该怎样获得他人的支持和帮助？" class="headerlink" title="为了做好你工作份外之事，你该怎样获得他人的支持和帮助？"></a>为了做好你工作份外之事，你该怎样获得他人的支持和帮助？</h3><p>回答提示：每个公司都在不断变化发展的过程中；你当然希望你的员工也是这样。你希望得到那些希望并欢迎变化的人，因为这些人明白，为了公司的发展，变化是公司日常生活中重要组成部分。这样的员工往往很容易适应公司的变化，并会对变化做出积极的响应。此外，他们遇到矛盾和问题时，也能泰然处之。下面的问题能够考核应聘者这方面的能力。<br>据说有人能从容避免正面冲突。请讲一下你在这方面的经验和技巧。<br>有些时候，我们得和我们不喜欢的人在一起共事。说说你曾经克服了性格方面的冲突而取得预期工作效果的经历。</p><h3 id="项目中遇到困难，你怎么办？怎么回答"><a href="#项目中遇到困难，你怎么办？怎么回答" class="headerlink" title="项目中遇到困难，你怎么办？怎么回答"></a>项目中遇到困难，你怎么办？怎么回答</h3><p>回答提示：自己能搞定的，就自己上网找资料；但如果比如在 2 个小时之内还没有头绪，就考虑问公司技术水平比较高的同事之类的，然后还要及时和项目经理沟通</p><p>那不浪费了 2 个小时时间 业务问题的话，谁清楚就问谁啊……即时沟通能够大大提高工作效率。</p><p>技术问题查资料，需求问题重新分析</p><p>还是写程序的时候有技术难点、技术难点又分普遍的技术难点、还是你个人不会做、</p><p>第一种这个要找项目负责人商量、甚至要找产品/运行或其他甲方沟通、</p><p>第二种普遍技术难点的话、参考资料或者和项目负责人商量看看怎么办、</p><p>第三种的话、先自己查资料试着解决、不行就找人其他资讯、、</p><h3 id="你在现在的团队处于什么样的角色，起到了什么明显的作用？"><a href="#你在现在的团队处于什么样的角色，起到了什么明显的作用？" class="headerlink" title="你在现在的团队处于什么样的角色，起到了什么明显的作用？"></a>你在现在的团队处于什么样的角色，起到了什么明显的作用？</h3><p>回答提示：请自行根据自己情况做回答，这个没有统一标准答案。</p><h3 id="最近在学什么？能谈谈你未来-3，5-年给自己的规划吗？"><a href="#最近在学什么？能谈谈你未来-3，5-年给自己的规划吗？" class="headerlink" title="最近在学什么？能谈谈你未来 3，5 年给自己的规划吗？"></a>最近在学什么？能谈谈你未来 3，5 年给自己的规划吗？</h3><p>面试时，经常会被面试官问到关于职业规划的问题，比如：你准备在我们公司做多久？你未来几年的职业规划是什么？等等。还没有进入公司，对公司工作环境还不太了解就被面试官问到这些问题，该怎么答才能合情有合理呢？</p><p>问：你准备在我们这家单位做多久？</p><p>答：</p><ol><li>这不是自己单方面决定的，还要看公司，但是可以肯定的是，如果公司跟自己的职业发展一致，我是会一直干下去的</li><li>以我对公司和现有职位的了解，如果能应聘上的话，目前来看至少可以稳定三年</li></ol><p>问：未来五年的规划是怎样的？</p><p>答：</p><p>1.如果应聘成功，我至少会稳定的做两年，踏实的做好自己的本职工作。<br>2.在工作中，会向高手请教，研究些新技术，提高自己的技术水平。<br>3.目前的规划是要优先做一名技术高手，如果有可能的话，做管理也是可以考虑的。</p><p>当然，说出其他一些你感兴趣的职位也是可以的，比如产品销售部经理，生产部经理等一些与你的专业有相关背景的工作。要知道，考官总是喜欢有进取心的应聘者，此时如果说“不知道”，或许就会使你丧失一个好机会。最普通的回答应该是“我准备在技术领域有所作为”或“我希望能按照公司的管理思路发展”。</p><p>大部分面试官司都会问你是否有职业规划，这个问题的背后是了解你的求职动机和对自己中长期职业发展的思考。在回答这个问题之前，要对自己有个清晰的认识，知道自己想往哪个方向发展以及未来有什么计划，要给面试官一种积极向上，好学上进，有追求，有规划的感觉，面试官喜欢有规划的求职者。</p><h3 id="如何向-HR-介绍你做过的项目"><a href="#如何向-HR-介绍你做过的项目" class="headerlink" title="如何向 HR 介绍你做过的项目"></a>如何向 HR 介绍你做过的项目</h3><p>项目经验与工作经验是相辅相成的，但较之于工作经验，项目经验更侧重于表现求职者在某个专业领域内的技能水平（技能水平决定了工资水平）。因而，技术类岗招聘的时候，更注重项目经验。项目介绍是有套路的，面试时，要将简历中的项目准备好！</p><p>我们在跟面试官讲解的时候，讲解项目一定要围绕着以下几个方面：</p><p>1、项目名称<br>2、开发时间（这里有个注意点：时间不要说的太短，而应该把前期的构思、需求分析、准备工作等时间都可以加进去）；<br>3、项目描述（做什么的）；<br>4、项目职责（说清楚自己职责，同时为了提高自己的技术形象，可以将项目说大点）；<br>5、项目使用的技术（除了说现在使用的技术，还可以说项目进行了压力测试、兼容性处理、数据库的3F、未来还要放mysql集群技术、页面静态化技术、以提升自己在对方心目中的技术形象）；<br>6、项目的亮点；<br>7、在自己的项目上可以想一些市面上没有但是自己觉得很有创意的点子。实现不实现都是无所谓了，但是你给面试官的印象会再上一个层次。<br>8、项目体会（可以说说：多人协作、命名规范、模块划分）；</p><h3 id="HR-贬低项目时你该怎么办"><a href="#HR-贬低项目时你该怎么办" class="headerlink" title="HR 贬低项目时你该怎么办"></a>HR 贬低项目时你该怎么办</h3><p>我们在上文讲解了如何向 HR 介绍项目。由于项目反映了技术，技术决定了薪资，所以面试官一般会把打压我们的项目变相打压我们技术，以达到打压我们薪资预期的目的，同时观察我们在打压环境中的表现来决定到底打压薪资到何种程度！所以，当 HR 说：“一个月的时间，四五个人的配合就完成了项目，可见你们项目不大、技术含量不高啊”，各位面试者一定要冷静！来学学在 HR 贬低项目时的应对方法！</p><p>1.项目实现也许花的时间不多，但是前期的构思、需求分析、页面设计等等准备工作是花了很多时间的。<br>2.项目大小和技术含量并不能够成正比，我们的项目，虽然小，但麻雀虽小，却五脏俱全。接着向面试官介绍你们团队在项目过程中所使用的技术等等。<br>3.项目大小主要是体现在功能上，有些功能客户并没有提出。如果后期客户有提出，我们也能够快速的实现。</p><h3 id="项目经验少该怎么办"><a href="#项目经验少该怎么办" class="headerlink" title="项目经验少该怎么办"></a>项目经验少该怎么办</h3><p>对于前端来说，技术水平是决定我们工资最重要的因素。技术水平是要通过我们的项目体现出来的，但项目经验少该怎么办？</p><p>1、项目经验是拿高工资最重要的一个指标。这反映了程序员的价值，也是用人单位给出薪资报价最重要的因素。所以面试者一定要重视项目。<br>2、简历中至少要写出3个项目。<br>3、项目可以适当包装。可以多说一些比较高端大气上档次的技术。<br>4、面试官问到简历中的项目细节你要能答上来。否则，就算是你做的，面试官因你答不上来也会认为不是你做的。所以要花时间，搞定写在简历上的项目模块。<br>5、项目抓亮点来说，可以对照企业的需求，将最有竞争力的点说清楚。这种能够加分的亮点一定要说到。</p><h3 id="你学历低，为什么要录用你？"><a href="#你学历低，为什么要录用你？" class="headerlink" title="你学历低，为什么要录用你？"></a>你学历低，为什么要录用你？</h3><p>面试一份工作时，学历有时候是一块敲门砖。对于学历不高的面试者，如果 HR 问：你才高中学历，而现在大学生一大把，我们为什么要录用你？你如果学历真的很低，那该怎么回答呢？</p><p>回答提示：</p><p>1、通过自信的表现，有效的沟通，让面试官主动忽略这个问题。或者说是你把你最好的展现出来，让面试官信服，觉得你是合适的人选而不提及或忽略掉这个问题。<br>2、即使面试官提出来了，勇敢面对主动承认，赞同面试官的提问，确实学历较低，自已已经深刻认识此问题，也因为认识到这个事实，你才更加注重能力的培养，同时自己也在工作之余继续课堂学习，增加扎实的理论知识。同时说出你的学历提升打算，提升计划一定要与你现行的工作职位结合。<br>3、如果面试官对学历一直抓住不放，或作为必要条件，以退为进吧，委婉表达自己想得到职位的态度，并做好了放弃的心理准备。</p><p>总的来说，在面试的时候，表现出自信，从谈吐和沟通上，给面试官好印象。如果问到你学历的时候，表现出“学历不代表能力”的自信来就好，一般的企业不会把这个当做决定性因素，还是看综合素质。</p><h3 id="你是不是年龄太大了？"><a href="#你是不是年龄太大了？" class="headerlink" title="你是不是年龄太大了？"></a>你是不是年龄太大了？</h3><p>都说 IT 行业是个吃青春饭的行业，你现在已经接近 30 岁了，你是不是年龄太大了？这个问题应该被问到的不多，但是万一真的被问到这个问题，你该如何作答呢？</p><p>1、 能不能做事才是大问题。而不是年龄。是不是有能力，试用期间可以检验。<br>2、 要表现出自己很喜欢这份工作，要长久的做下去（年龄大的人，工作经历多，接触的东西多，才能够在众多的经历中明确知道自己未来到底要走什么路）。要突出自己年龄大的优势，比如思想更成熟，眼界更开阔等等。</p><h3 id="你太小了，你能承担项目吗？"><a href="#你太小了，你能承担项目吗？" class="headerlink" title="你太小了，你能承担项目吗？"></a>你太小了，你能承担项目吗？</h3><p>虽说 IT 行业是个吃青春饭的行业，但是你年纪太小了，让人感觉不踏实。虽然我们最重要拼的是技术，但真的被问到这个问题，你该如何作答呢？</p><p>1、虽然我年纪小，但是我技术是没有问题的，也是有担当的。试用期间可以检验。<br>2、对于前端，我做过很多的项目，也有系统的学习过。并不比年纪大的人差。<br>3、正因为我年纪小，我对于工作有十足的干劲，我很想在这行好好的发展，也能承受比较强的工作压力。</p><h3 id="你对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？"><a href="#你对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？" class="headerlink" title="你对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？"></a>你对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？</h3><p>a. 前端是最贴近用户的程序员，前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。前端的能力就是能让产品从 90 分进化到 100 分，甚至更好</p><p>b. 参与项目，快速高质量完成实现效果图，精确到 1px；</p><p>c. 与团队成员，UI 设计，产品经理的沟通；</p><p>d. 做好的页面结构，页面重构和用户体验；</p><p>e. 处理 hack，兼容、写出优美的代码格式；</p><p>f. 针对服务器的优化、拥抱最新前端技术。</p><ul><li>1、实现界面交互</li><li>2、提升用户体验</li><li>3、有了 Node.js，前端可以实现服务端的一些事情</li></ul><h3 id="其它相关的加分项："><a href="#其它相关的加分项：" class="headerlink" title="其它相关的加分项："></a>其它相关的加分项：</h3><ol><li>都使用和了解过哪些编辑器?都使用和了解过哪些日常工具?</li><li>都知道有哪些浏览器内核?开发过的项目都兼容哪些浏览器?</li><li>瀑布流布局或者流式布局是否有了解</li><li>HTML5 都有哪些新的 API?</li><li>都用过什么代码调试工具?</li><li>是否有接触过或者了解过重构。</li><li>你遇到过比较难的技术问题是？你是如何解决的？</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;面试是一个非常重要的过程，有些人在这个过程中感到不知所措，或者做得不好，使自己在求职中因小失大，达不到成功。在求职过程中注意了以下基本礼仪和技巧，才能达到事半功倍，增强面试的有效性。&lt;/p&gt;
&lt;h3 id=&quot;面试前准备&quot;&gt;&lt;a href=&quot;#面试前准备&quot; class=&quot;he
      
    
    </summary>
    
      <category term="前端面试题" scheme="http://www.bluedream.top/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试技巧" scheme="http://www.bluedream.top/tags/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
    
      <category term="面试问题" scheme="http://www.bluedream.top/tags/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    
      <category term="面试经验" scheme="http://www.bluedream.top/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript原型链</title>
    <link href="http://www.bluedream.top/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE.html"/>
    <id>http://www.bluedream.top/前端知识点/JavaScript原型链.html</id>
    <published>2019-08-31T07:10:08.000Z</published>
    <updated>2019-09-26T08:10:39.288Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面向对象原理："><a href="#面向对象原理：" class="headerlink" title="面向对象原理："></a>面向对象原理：</h3><p>​    1）目标：实现封装、继承、多态等面向对象的基本功能。</p><p>​    2）原理：原型链是面向对象的基础,使用prototype、function 、new、this模拟面向对象的类。</p><p>​          JavaScript是面向对象语言，但不使用类（根本不存在类）。JavaScript的面向对象是<strong>基于prototype和function</strong>的，而不是基于类的。</p><h3 id="介绍JavaScript的原型，原型链？有什么特点？"><a href="#介绍JavaScript的原型，原型链？有什么特点？" class="headerlink" title="介绍JavaScript的原型，原型链？有什么特点？"></a>介绍JavaScript的原型，原型链？有什么特点？</h3><ul><li><p>原型：</p><ul><li>JavaScript的所有对象中都包含了一个 [<strong>proto</strong>] 内部属性，这个属性所对应的就是该对象的原型。</li><li>JavaScript的函数对象，除了原型 [<strong>proto</strong>] 之外，还预置了 prototype 属性。</li><li>当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型 [<strong>proto</strong>]。</li></ul></li><li><p>原型链：</p><ul><li>原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链。</li><li>当一个对象调用的属性/方法自身不存在时，就会去自己 [<strong>proto</strong>] 关联的前辈 prototype 对象上去找。</li><li>如果没找到，就会去该 prototype 原型 [<strong>proto</strong>] 关联的前辈 prototype 去找。依次类推，直到找到属性/方法（一直检索到 Object 内建对象）或 undefined 为止。从而形成了所谓的“原型链”</li></ul></li><li><p>关系：<code>instance.constructor.prototype = instance.__proto__</code></p></li><li><p>原型特点：</p><ul><li>JavaScript对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变</li></ul></li><li><p>原型链的基本原理：</p><p>任何一个<strong>实例</strong>，通过原型链，找到它上面的<strong>原型</strong>，该原型对象中的方法和属性，可以被所有的原型实例共享。</p><p>原型可以起到继承的作用，原型里的方法都可以被不同的实例共享。</p></li><li><p>其他理解：</p><p>通过一个对象的<strong>proto</strong>可以找到它的原型对象，原型对象也是一个对象，就可以通过原型对象的<strong>proto</strong>，最后找到了我们的 Object.prototype，Object是原型链的顶端。从实例的原型对象开始一直到 Object.prototype 就是我们的原型链。</p><p>每个对象都有一个私有属性（称之为 [[Prototype]]），它指向它的原型对象（<strong>prototype</strong>）。该 prototype 对象又具有一个自己的 prototype ，层层向上直到一个对象的原型为 null。根据定义，null 没有原型，并作为这个<strong>原型链</strong>中的最后一个环节。</p><p>当查找一个对象的属性时，JavaScript 会向上遍历原型链，直到找到给定名称的属性为止，到查找到达原型链的顶部 - 也就是 <strong>Object.prototype</strong> - 但是仍然没有找到指定的属性，就会返回 <strong>undefined</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Func()&#123;&#125;</span><br><span class="line">Func.prototype.name = &quot;Sean&quot;;</span><br><span class="line">Func.prototype.getInfo = function() &#123;</span><br><span class="line">  return this.name;</span><br><span class="line">&#125;</span><br><span class="line">var person = new Func();//现在可以参考var person = Object.create(oldObject);</span><br><span class="line">console.log(person.getInfo());//它拥有了Func的属性和方法</span><br><span class="line">//&quot;Sean&quot;</span><br><span class="line">console.log(Func.prototype);</span><br><span class="line">// Func &#123; name=&quot;Sean&quot;, getInfo=function()&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="../images/js001.png" alt="js001" title>                </div>                <div class="image-caption">js001</div>            </figure><h3 id="原型、构造函数、实例三者之间的关系"><a href="#原型、构造函数、实例三者之间的关系" class="headerlink" title="原型、构造函数、实例三者之间的关系"></a>原型、构造函数、实例三者之间的关系</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="../images/js002.png" alt title>                </div>                <div class="image-caption"></div>            </figure><blockquote><p>PS：任何一个函数，如果在前面加了<code>new</code>，那就是构造函数。</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="../images/js003.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ol><li>构造函数通过 <code>new</code> 生成实例</li><li>构造函数也是函数，构造函数的<code>prototype</code>指向原型。（所有的函数有<code>prototype</code>属性，但实例没有 <code>prototype</code>属性）</li><li>原型对象中有 <code>constructor</code>，指向该原型的构造函数。</li></ol><blockquote><p>上面的三行，代码演示：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Foo = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> Foo(<span class="string">'smyhvae'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>上面的代码中，<code>Foo.prototype.constructor === Foo</code>的结果是<code>true</code>：</p></blockquote><ol start="4"><li>实例的<code>__proto__</code>指向原型。也就是说，<code>Foo.__proto__ === M.prototype</code>。</li></ol><blockquote><p>声明：所有的<strong>引用类型</strong>（数组、对象、函数）都有<code>__proto__</code>这个属性。</p></blockquote><p><code>Foo.__proto__ === Function.prototype</code>的结果为true，说明<code>Foo</code>这个普通的函数，是<code>Function</code>构造函数的一个实例。</p><h3 id="prototype-和proto的关系是什么？"><a href="#prototype-和proto的关系是什么？" class="headerlink" title="prototype 和proto的关系是什么？"></a>prototype 和<strong>proto</strong>的关系是什么？</h3><p>所有的对象都拥有<strong>proto</strong>属性，它指向对象构造函数的 prototype 属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;</span><br><span class="line">obj.__proto__ === Object.prototype // true</span><br><span class="line"></span><br><span class="line">function Test()&#123;&#125;</span><br><span class="line">test.__proto__ == Test.prototype // true</span><br></pre></td></tr></table></figure><p>所有的函数都同时拥有<strong>proto</strong>和 protytpe 属性<br>函数的<strong>proto</strong>指向自己的函数实现 函数的 protytpe 是一个对象 所以函数的 prototype 也有<strong>proto</strong>属性 指向 Object.prototype</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function func() &#123;&#125;</span><br><span class="line">func.prototype.__proto__ === Object.prototype // true</span><br></pre></td></tr></table></figure><p>Object.prototype.<strong>proto</strong>指向 null</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.__proto__ // null</span><br></pre></td></tr></table></figure><h3 id="执行时对象查找时，永远不会去查找原型的一个函数是？"><a href="#执行时对象查找时，永远不会去查找原型的一个函数是？" class="headerlink" title="执行时对象查找时，永远不会去查找原型的一个函数是？"></a>执行时对象查找时，永远不会去查找原型的一个函数是？</h3><ul><li>javaScript中hasOwnProperty函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员</li><li>使用方法： object.hasOwnProperty(proName)</li><li>其中参数object是必选项。一个对象的实例。</li><li>proName是必选项。一个属性名称的字符串值。</li><li>如果 object 具有指定名称的属性，那么JavaScript中hasOwnProperty函数方法返回 true，反之则返回 false。</li></ul><h3 id="instanceof的原理"><a href="#instanceof的原理" class="headerlink" title="instanceof的原理"></a>instanceof的原理</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="../images/js004.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li><code>instanceof</code>的<strong>作用</strong>：用于判断<strong>实例</strong>属于哪个<strong>构造函数</strong>。</li><li><code>instanceof</code>的<strong>原理</strong>：判断实例对象的<code>__proto__</code>属性，和构造函数的<code>prototype</code>属性，是否为同一个引用（是否指向同一个地址）。</li></ul><blockquote><ul><li><strong>注意1</strong>：虽然说，实例是由构造函数 new 出来的，但是实例的<code>__proto__</code>属性引用的是构造函数的<code>prototype</code>。也就是说，实例的<code>__proto__</code>属性与构造函数本身无关。</li><li><strong>注意2</strong>：在原型链上，原型的上面可能还会有原型，以此类推往上走，继续找<code>__proto__</code>属性。这条链上如果能找到， instanceof 的返回结果也是 true。</li></ul></blockquote><p>比如说：</p><ul><li><code>foo instance of Foo</code>的结果为true，因为<code>foo.__proto__ === M.prototype</code>为<code>true</code>。</li><li><strong><code>foo instance of Objecet</code>的结果也为true</strong>，为<code>Foo.prototype.__proto__ === Object.prototype</code>为<code>true</code>。</li></ul><p><strong>instanceof 的内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。</strong></p><p>使用 instanceof 判断一个对象是否为数组，instanceof 会判断这个对象的原型链上是否会找到对应的 Array 的原型，找到返回 true，否则返回 false。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>但 instanceof 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>优点：instanceof 可以弥补 Object.prototype.toString.call()不能判断自定义实例化对象的缺点。</p><p>缺点：instanceof 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true，且不同于其他两种方法的是它不能检测出 iframes。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> f(<span class="string">"martin"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(f1 <span class="keyword">instanceof</span> f); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><strong>推荐阅读:</strong> <a href="https://www.cnblogs.com/zhoulujun/p/9667651.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhoulujun/p/9667651.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;面向对象原理：&quot;&gt;&lt;a href=&quot;#面向对象原理：&quot; class=&quot;headerlink&quot; title=&quot;面向对象原理：&quot;&gt;&lt;/a&gt;面向对象原理：&lt;/h3&gt;&lt;p&gt;​    1）目标：实现封装、继承、多态等面向对象的基本功能。&lt;/p&gt;
&lt;p&gt;​    2）原理：原
      
    
    </summary>
    
      <category term="前端知识点" scheme="http://www.bluedream.top/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="JavaScript" scheme="http://www.bluedream.top/tags/JavaScript/"/>
    
      <category term="原型" scheme="http://www.bluedream.top/tags/%E5%8E%9F%E5%9E%8B/"/>
    
      <category term="原型链" scheme="http://www.bluedream.top/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
      <category term="instanceof" scheme="http://www.bluedream.top/tags/instanceof/"/>
    
  </entry>
  
  <entry>
    <title>光阴</title>
    <link href="http://www.bluedream.top/%E6%95%A3%E6%96%87/%E5%85%89%E9%98%B4.html"/>
    <id>http://www.bluedream.top/散文/光阴.html</id>
    <published>2019-08-31T02:18:08.000Z</published>
    <updated>2019-09-26T08:10:36.116Z</updated>
    
    <content type="html"><![CDATA[<h3 id="作者：赵丽宏"><a href="#作者：赵丽宏" class="headerlink" title="作者：赵丽宏"></a>作者：赵丽宏</h3><p><img src="/img/loading.gif" data-original="../images/sw001.jpg" alt></p><p><strong>谁也无法描绘出他的面目。但世界上处处能听到他的脚步。</strong></p><p><strong>当旭日驱散夜的残幕时,当夕阳被朦胧的地平线吞噬时,他不慌不忙地走着,光明和黑暗都无法改变他进行的节奏。</strong></p><p><strong>当蓓蕾在春风中灿然绽开湿润的花瓣时,当婴儿在产房里以响亮的哭声向人世报到时,他悄无声息地走着,欢笑不能挽留他的脚步。</strong></p><p><strong>当枯黄的树叶在寒风中飘飘坠落时,当垂危的老人以留恋的目光扫视周围的天地时,他还是沉着而又默然地走,叹息也不能使他停步。</strong></p><p><strong>他从你的手指缝里流过去。</strong></p><p><strong>从你的脚底下滑过去。</strong></p><p><strong>从你的视野和你的思想里飞过去…..</strong></p><p><strong>他是一把神奇而又无情的雕刻刀,在天地之间创造着种种奇迹,他能把巨石分裂成尘土,把幼苗雕成大树,把荒漠变成城市和园林,当然,他也能使繁华之都衰败成荒凉的废墟,使锃亮的金属爬满绿锈、失去光泽。老人额头的皱纹是他刻出来的,少女脸上的红晕也是他描绘出来的。生命的繁衍和世界的运动正是由他精心指挥着。</strong></p><p><strong>他按时撕下一张又一张日历,把将来变成现在,把现在变成过去,把过去变成越来越遥远的[历史])。</strong></p><p><strong>他慷慨。你不必乞求,属于你的,他总是如数奉献。</strong></p><p><strong>他公正。不管你权重如山、腰缠万贯,还是一个布衣、两袖清风,他都一视同仁。没有人能将他占为己有,哪怕你一掷千金,他也决不会因此而施舍一分一秒。</strong></p><p><strong>你珍重他，他便在你的身后长出绿阴，结出沉甸甸的果实。</strong></p><p><strong>你漠视他,他就化成轻烟,消散得无影无踪。</strong></p><p><strong>有时,短暂的一瞬会成为永恒,这是因为他把脚印深深地留在了人们心里。</strong></p><p><strong>有时,漫长的岁月会成为一瞬,这是因为浓雾和风沙湮没了他的脚印。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;作者：赵丽宏&quot;&gt;&lt;a href=&quot;#作者：赵丽宏&quot; class=&quot;headerlink&quot; title=&quot;作者：赵丽宏&quot;&gt;&lt;/a&gt;作者：赵丽宏&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/img/loading.gif&quot; data-original=&quot;../images/s
      
    
    </summary>
    
      <category term="散文" scheme="http://www.bluedream.top/categories/%E6%95%A3%E6%96%87/"/>
    
    
      <category term="光阴" scheme="http://www.bluedream.top/tags/%E5%85%89%E9%98%B4/"/>
    
      <category term="赵丽宏" scheme="http://www.bluedream.top/tags/%E8%B5%B5%E4%B8%BD%E5%AE%8F/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript闭包</title>
    <link href="http://www.bluedream.top/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9/JavaScript%E9%97%AD%E5%8C%85.html"/>
    <id>http://www.bluedream.top/前端知识点/JavaScript闭包.html</id>
    <published>2019-08-29T12:50:00.000Z</published>
    <updated>2019-09-09T07:56:21.557Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说说你对闭包的理解（什么是闭包（closure），为什么要用它？）"><a href="#说说你对闭包的理解（什么是闭包（closure），为什么要用它？）" class="headerlink" title="说说你对闭包的理解（什么是闭包（closure），为什么要用它？）"></a>说说你对闭包的理解（什么是闭包（closure），为什么要用它？）</h2><p>使用闭包主要是为了设计私有的方法和变量。闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域。在js中，函数即闭包，只有函数才会产生作用域的概念。</p><p>闭包有三个特性：</p><ul><li>函数内再嵌套函数</li><li>函数内部可以引用外部的参数和变量</li><li>参数和变量不会被垃圾回收机制回收</li></ul><p>优点：</p><ul><li>希望一个变量长期存储在内存中。</li><li>避免全局变量的污染。</li><li>私有成员的存在。</li></ul><p>缺点：</p><ul><li>常驻内存，会增大内存使用量。</li><li>使用不当会很容易造成内存泄露。</li></ul><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"jack"</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br><span class="line">outer()(); <span class="comment">// jack</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hi! <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> test = sayHi(<span class="string">"xiaoming"</span>);</span><br><span class="line">test(); <span class="comment">// Hi! xiaoming</span></span><br></pre></td></tr></table></figure><p>虽然 sayHi 函数已经执行完毕，但是其活动对象也不会被销毁，因为 test 函数仍然引用着 sayHi 函数中的变量 name，这就是闭包。<br><br>但也因为闭包引用着另一个函数的变量，导致另一个函数已经不使用了也无法销毁，所以闭包使用过多，会占用较多的内存，这也是一个副作用。</p><p>解析：</p><p>由于在 ECMA2015 中，只有函数才能分割作用域，函数内部可以访问当前作用域的变量，但是外部无法访问函数内部的变量，所以闭包可以理解成“定义在一个函数内部的函数，外部可以通过内部返回的函数访问内部函数的变量“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。</p><h2 id="闭包由来"><a href="#闭包由来" class="headerlink" title="闭包由来"></a>闭包由来</h2><h3 id="JavaScript-变量"><a href="#JavaScript-变量" class="headerlink" title="JavaScript 变量"></a>JavaScript 变量</h3><p>JavaScript 变量可以是局部变量或全局变量。</p><p>全局变量：作用域是全局性的，可应用于页面上的所有脚本，在web页面中全局变量属于 window 对象。</p><p>局部变量：在函数内部声明的变量，只在函数内部起作用，作用域是局部性的；函数的参数也是局部性的，只在函数内部起作用。</p><p>全局和局部变量即便名称相同，它们也是两个不同的变量。修改其中一个，不会影响另一个的值。私有变量可以用到闭包。</p><h3 id="计数器困境"><a href="#计数器困境" class="headerlink" title="计数器困境"></a>计数器困境</h3><h4 id="设想下如果你想统计一些数值，且该计数器在所有函数中都是可用的。"><a href="#设想下如果你想统计一些数值，且该计数器在所有函数中都是可用的。" class="headerlink" title="设想下如果你想统计一些数值，且该计数器在所有函数中都是可用的。"></a>设想下如果你想统计一些数值，且该计数器在所有函数中都是可用的。</h4><p>你可以使用全局变量，函数设置计数器递增：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var counter = 0;</span><br><span class="line"> </span><br><span class="line">function add() &#123;</span><br><span class="line">   return counter += 1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line"> </span><br><span class="line">// 计数器现在为 3</span><br></pre></td></tr></table></figure><p>计数器数值在执行 add() 函数时发生变化。</p><p>但问题来了，页面上的任何脚本都能改变计数器，即便没有调用 add() 函数。</p><h4 id="如果我在函数内声明计数器，如果没有调用函数将无法修改计数器的值："><a href="#如果我在函数内声明计数器，如果没有调用函数将无法修改计数器的值：" class="headerlink" title="如果我在函数内声明计数器，如果没有调用函数将无法修改计数器的值："></a>如果我在函数内声明计数器，如果没有调用函数将无法修改计数器的值：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function add() &#123;</span><br><span class="line">    var counter = 0;</span><br><span class="line">    return counter += 1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line"> </span><br><span class="line">// 本意是想输出 3, 但事与愿违，输出的都是 1</span><br></pre></td></tr></table></figure><p>以上代码将无法正确输出，每次我调用 add() 函数，计数器都会设置为 1。</p><p>JavaScript 内嵌函数可以解决该问题。</p><hr><h3 id="JavaScript-内嵌函数"><a href="#JavaScript-内嵌函数" class="headerlink" title="JavaScript 内嵌函数"></a>JavaScript 内嵌函数</h3><p>所有函数都能访问全局变量。  </p><p>实际上，在 JavaScript 中，所有函数都能访问它们上一层的作用域。</p><p>JavaScript 支持嵌套函数。嵌套函数可以访问上一层的函数变量。</p><h4 id="内嵌函数-plus-可以访问父函数的-counter-变量："><a href="#内嵌函数-plus-可以访问父函数的-counter-变量：" class="headerlink" title="内嵌函数 plus() 可以访问父函数的 counter 变量："></a>内嵌函数 plus() 可以访问父函数的 counter 变量：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function add() &#123;</span><br><span class="line">    var counter = 0;</span><br><span class="line">    function plus() &#123;counter += 1;&#125;</span><br><span class="line">    plus();    </span><br><span class="line">    return counter; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们能在外部访问 plus() 函数，这样就能解决计数器的困境。</p><p>我们同样需要确保 counter = 0只执行一次。</p><p>我们需要闭包。</p><hr><h3 id="JavaScript-闭包"><a href="#JavaScript-闭包" class="headerlink" title="JavaScript 闭包"></a>JavaScript 闭包</h3><p>还记得函数自我调用吗？该函数会做什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var add = (function () &#123;</span><br><span class="line">    var counter = 0;</span><br><span class="line">    return function () &#123;return counter += 1;&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"> </span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line"> </span><br><span class="line">// 计数器为 3</span><br></pre></td></tr></table></figure><p>变量 <strong>add</strong> 指定了函数自我调用的返回字值。</p><p>自我调用函数只执行一次。设置计数器为 0。并返回函数表达式。</p><p>add变量可以作为一个函数使用。非常棒的部分是它可以访问函数上一层作用域的计数器。</p><p>这个叫作 JavaScript <strong>闭包。</strong>它使得函数拥有私有变量变成可能。</p><p>计数器受<strong>匿名函数</strong>的作用域保护，只能通过 add 方法修改。</p><p><strong>闭包是一种保护私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不受外界干扰。直观的说就是形成一个不销毁的栈环境。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;说说你对闭包的理解（什么是闭包（closure），为什么要用它？）&quot;&gt;&lt;a href=&quot;#说说你对闭包的理解（什么是闭包（closure），为什么要用它？）&quot; class=&quot;headerlink&quot; title=&quot;说说你对闭包的理解（什么是闭包（closure），为
      
    
    </summary>
    
      <category term="前端知识点" scheme="http://www.bluedream.top/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="JavaScript" scheme="http://www.bluedream.top/tags/JavaScript/"/>
    
      <category term="闭包" scheme="http://www.bluedream.top/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>电脑常用快捷键</title>
    <link href="http://www.bluedream.top/%E5%85%B6%E4%BB%96/%E7%94%B5%E8%84%91%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE.html"/>
    <id>http://www.bluedream.top/其他/电脑常用快捷键.html</id>
    <published>2019-08-28T03:58:08.000Z</published>
    <updated>2019-09-09T08:00:19.205Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文件操作快捷键："><a href="#文件操作快捷键：" class="headerlink" title="文件操作快捷键："></a>文件操作快捷键：</h3><p>Ctrl+C     复制</p><p>Ctrl+V     粘贴</p><p>Ctrl+X     剪切</p><p>Ctrl+A     全选</p><p>Ctrl      多选：按住Ctrl，再用鼠标单击即可选中文件，可以反选；</p><p>Shift    多选：先选中一个文件a，按住Shift键，再用鼠标单击文件h，即可把从a到h选中；</p><p>Ctrl+Shift+N     新建文件夹。注意：XP系统不行；</p><p>Shift+Delete     彻底删除文件。选中文件后，先按住Shift键不放手，再按Delete键，彻底删除的文件不在回收站里；</p><h3 id="文字输入快捷键："><a href="#文字输入快捷键：" class="headerlink" title="文字输入快捷键："></a>文字输入快捷键：</h3><h4 id="Tab与Shift-Tab："><a href="#Tab与Shift-Tab：" class="headerlink" title="Tab与Shift+Tab："></a>Tab与Shift+Tab：</h4><p>1、在输入账号之后按Tab键，会自动跳到输入密码框进行输入；</p><p>2、有些地方相当于输入两个汉字那么长的空格（如代码编写的缩进等）；</p><p>3、Shift+Tab为Tab的反操作；</p><p>Delete    反向删除文字。比如”AB”字符，当光标在A与B之间时，按”Back”退格键时删除”A”，当按”Delete”键时则删除B；</p><p>Home与End    当输入一行文字时发现有错误，可以按Home回到第一个字，按End时回到最后一个字。此时可以免去动鼠标或者按”←”或”→”方向键的麻烦；</p><h3 id="窗口（Win）键"><a href="#窗口（Win）键" class="headerlink" title="窗口（Win）键"></a>窗口（Win）键</h3><p>【窗口】显示或隐藏“开始”菜单</p><p>【窗口】+F1帮助</p><p>【窗口】+D显示桌面，一个一个地关闭窗口或最小化窗口会很麻烦，这个快捷键很方便；</p><p>【窗口】+R打开“运行”窗口，可以输入”cmd”进入命令行黑窗口，还可以输入”msconfig”等命令；</p><p>【窗口】+E打开“我的电脑”，即使桌面上没有“我的电脑”图标也可以进入文件管理；</p><p>【窗口】+F搜索文件或文件夹</p><p>【窗口】+U打开“工具管理器”</p><p>【窗口】+BREAK显示“系统属性”</p><p>【窗口】+TAB在打开的项目之间切换</p><p>【窗口】+Pause 打开系统相关信息。可以快速查看别人电脑配置，相当于“控制面板\系统和安全\系统”。</p><p>【窗口】+U+U/R XP系统关机/重启（Win8不行）。注意：每按一个键都要松手，不是连按的；</p><h3 id="Ctrl键"><a href="#Ctrl键" class="headerlink" title="Ctrl键"></a>Ctrl键</h3><p>Ctrl+1,2,3…　功能：切换到从左边数起第1,2,3…个标签</p><p>Ctrl+A　功能：全部选中当前页面内容</p><p>Ctrl+C　功能：复制当前选中内容</p><p>Ctrl+D　功能：打开“添加收藏”面版(把当前页面添加到收藏夹中)</p><p>Ctrl+E　功能：打开或关闭“搜索”侧边栏(各种搜索引擎可选)</p><p>Ctrl+F　功能：打开“查找”面版</p><p>Ctrl+G　功能：打开或关闭“简易收集”面板</p><p>Ctrl+H　功能：打开“历史”侧边栏</p><p>Ctrl+I　功能：打开“收藏夹”侧边栏/另:将所有垂直平铺或水平平铺或层叠的窗口恢复</p><p>Ctrl+K　功能：关闭除当前和锁定标签外的所有标签</p><p>Ctrl+L　功能：打开“打开”面版(可以在当前页面打开Iternet地址或其他文件…)</p><p>Ctrl+N　功能：新建一个空白窗口(可更改,Maxthon选项→标签→新建)</p><p>Ctrl+O　功能：打开“打开”面版(可以在当前页面打开Iternet地址或其他文件…)</p><p>Ctrl+P　功能：打开“打印”面板(可以打印网页,图片什么的…)</p><p>Ctrl+Q　功能：打开“添加到过滤列表”面板(将当前页面地址发送到过滤列表)</p><p>Ctrl+R　功能：刷新当前页面</p><p>Ctrl+S　功能：打开“保存网页”面板(可以将当前页面所有内容保存下来)</p><p>Ctrl+T　功能：垂直平铺所有窗口</p><p>Ctrl+V　功能：粘贴当前剪贴板内的内容</p><p>Ctrl+W　功能：关闭当前标签(窗口)</p><p>Ctrl+X　功能：剪切当前选中内容(一般只用于文本操作)</p><p>Ctrl+Y　功能：重做刚才动作(一般只用于文本操作)</p><p>Ctrl+Z　功能：撤消刚才动作(一般只用于文本操作)</p><p>Ctrl+F4　功能：关闭当前标签(窗口)</p><p>Ctrl+F5　功能：刷新当前页面</p><p>Ctrl+F6　功能：按页面打开的先后时间顺序向前切换标签(窗口)</p><p>Ctrl+F11　功能：隐藏或显示菜单栏</p><p>Ctrl+Tab　功能：以小菜单方式向下切换标签(窗口)</p><p>Ctrl+拖曳　功能：保存该链接的地址或已选中的文本或指定的图片到一个文件夹中(保存目录可更改,Maxthon选项→保存)</p><p>Ctrl+小键盘’+’　功能：当前页面放大20%</p><p>Ctrl+小键盘’-‘　功能：当前页面缩小20%</p><p>Ctrl+小键盘’*’　功能：恢复当前页面的缩放为原始大小</p><p>Ctrl+Alt+S　功能：自动保存当前页面所有内容到指定文件夹(保存路径可更改,Maxthon选项→保存)</p><p>Ctrl+Shift+小键盘’+’　功能：所有页面放大20%</p><p>Ctrl+Shift+小键盘’-‘　功能：所有页面缩小20%</p><p>Ctrl+Shift+F　功能：输入焦点移到搜索栏</p><p>Ctrl+Shift+G　功能：关闭“简易收集”面板</p><p>Ctrl+Shift+H　功能：打开并激活到你设置的主页</p><p>Ctrl+Shift+N　功能：在新窗口中打开剪贴板中的地址,如果剪贴板中为文字,则调用搜索引擎搜索该文字(搜索引擎可选择,Maxthon选项→搜索)</p><p>Ctrl+Shift+S　功能：打开“保存网页”面板(可以将当前页面所有内容保存下来,等同于Ctrl+S)</p><p>Ctrl+Shift+W　功能：关闭除锁定标签外的全部标签(窗口)</p><p>Ctrl+Shift+F6　功能：按页面打开的先后时间顺序向后切换标签(窗口)</p><p>Ctrl+Shift+Tab　功能：以小菜单方式向上切换标签(窗口)</p><h3 id="其他常用快捷键："><a href="#其他常用快捷键：" class="headerlink" title="其他常用快捷键："></a>其他常用快捷键：</h3><p>END    显示当前窗口的底端</p><p>HOME    显示当前窗口的顶端</p><p>Ctrl+Alt+Delete     打开任务管理器（结束一些常规方法关闭不了的程序）。</p><p>Print    电脑屏幕截屏。（然后在画图或Word中粘贴保存）；</p><p>Ctrl+Alt+Print    对当前窗口截屏。（然后在画图或Word中粘贴保存）；</p><p>Alt+Tab    切换已打开的程序窗口。先用一个手指按住Alt键，再用另外一个手指陆续按Tab键切换不同窗口；</p><p>Alt+F4     关闭当前窗口。如果没有窗口时则提示关机；</p><p>F5         刷新当前窗口。包括系统和网页。</p><p>Alt+1　功能：保存当前表单</p><p>Alt+2　功能：保存为通用表单</p><p>Alt+A　功能：展开收藏夹列表</p><h3 id="辅助功能"><a href="#辅助功能" class="headerlink" title="辅助功能"></a>辅助功能</h3><p>按右边的SHIFT键八秒钟切换筛选键的开和关</p><p>按SHIFT五次切换粘滞键的开和关</p><p>按NUMLOCK五秒钟切换切换键的开和关</p><p>左边的ALT+左边的SHIFT+NUMLOCK切换鼠标键的开和关</p><p>左边的ALT+左边的SHIFT+PRINTSCREEN切换高对比度的开和关</p><h3 id="QQ快捷键"><a href="#QQ快捷键" class="headerlink" title="QQ快捷键"></a>QQ快捷键</h3><p>Alt+S     快速回复</p><p>Alt+C    关闭当前窗口</p><p>Alt+H    打开聊天记录</p><p>Alt+T    更改消息模式</p><p>Ait+J     打开聊天纪录</p><p>Ctrl+A     全选当前对话框里的内容</p><p>Ctrl+F     QQ里直接显示字体设置工具条</p><p>Ctrl+J      输入框里回车(跟回车一个效果)</p><p>Ctrl+M    输入框里回车(跟回车一个效果)</p><p>Ctrl+L     对输入框里当前行的文字左对齐</p><p>Ctrl+R     对输入框里当前行的文字右对齐</p><p>Ctrl+E     对输入框里当前行的文字居中</p><p>Ctrl+V     在qq对话框里实行粘贴</p><p>Ctrl+Z     清空/恢复输入框里的文字</p><p>Ctrl+回车     快速回复 这个可能是聊QQ时最常用到的了</p><p>Ctrl+Alt+Z    快速提取消息</p><p>Ctrl+Alt+A    捕捉屏幕</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;文件操作快捷键：&quot;&gt;&lt;a href=&quot;#文件操作快捷键：&quot; class=&quot;headerlink&quot; title=&quot;文件操作快捷键：&quot;&gt;&lt;/a&gt;文件操作快捷键：&lt;/h3&gt;&lt;p&gt;Ctrl+C     复制&lt;/p&gt;
&lt;p&gt;Ctrl+V     粘贴&lt;/p&gt;
&lt;p&gt;Ctrl
      
    
    </summary>
    
      <category term="其他" scheme="http://www.bluedream.top/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="电脑" scheme="http://www.bluedream.top/tags/%E7%94%B5%E8%84%91/"/>
    
      <category term="快捷键" scheme="http://www.bluedream.top/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>vue</title>
    <link href="http://www.bluedream.top/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/vue.html"/>
    <id>http://www.bluedream.top/前端面试题/vue.html</id>
    <published>2019-08-27T13:02:08.000Z</published>
    <updated>2019-09-28T07:58:20.522Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vue的优点是什么？"><a href="#vue的优点是什么？" class="headerlink" title="vue的优点是什么？"></a>vue的优点是什么？</h3><ul><li><p>低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变</p></li><li><p>可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑</p></li><li><p>可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写</p></li><li><p>为什么用 vue ？简洁、轻快、舒服</p></li></ul><h3 id="请详细说下你对vue生命周期的理解"><a href="#请详细说下你对vue生命周期的理解" class="headerlink" title="请详细说下你对vue生命周期的理解"></a>请详细说下你对vue生命周期的理解</h3><blockquote><p>答：总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后</p></blockquote><ul><li>创建前/后： 在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el还没有</li><li>载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。</li><li>更新前/后：当data变化时，会触发beforeUpdate和updated方法</li><li>销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在</li></ul><h3 id="组件之间的传值？"><a href="#组件之间的传值？" class="headerlink" title="组件之间的传值？"></a>组件之间的传值？</h3><h4 id="父组件与子组件传值"><a href="#父组件与子组件传值" class="headerlink" title="父组件与子组件传值"></a><strong>父组件与子组件传值</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//父组件通过标签上面定义传值</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;Main :obj=&quot;data&quot;&gt;&lt;/Main&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    //引入子组件</span><br><span class="line">    import Main form &quot;./main&quot;</span><br><span class="line">    </span><br><span class="line">    exprot default&#123;</span><br><span class="line">        name:&quot;parent&quot;,</span><br><span class="line">        data()&#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                data:&quot;我要向子组件传递数据&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        //初始化组件</span><br><span class="line">        components:&#123;</span><br><span class="line">            Main</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//子组件通过props方法接受数据</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;data&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    exprot default&#123;</span><br><span class="line">        name:&quot;son&quot;,</span><br><span class="line">        //接受父组件传值</span><br><span class="line">        props:[&quot;data&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="子组件向父组件传递数据"><a href="#子组件向父组件传递数据" class="headerlink" title="子组件向父组件传递数据"></a><strong>子组件向父组件传递数据</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//子组件通过$emit方法传递参数</span><br><span class="line">&lt;template&gt;</span><br><span class="line">   &lt;div v-on:click=&quot;events&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    //引入子组件</span><br><span class="line">    import Main form &quot;./main&quot;</span><br><span class="line">    </span><br><span class="line">    exprot default&#123;</span><br><span class="line">        methods:&#123;</span><br><span class="line">            events:function()&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;data&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    exprot default&#123;</span><br><span class="line">        name:&quot;son&quot;,</span><br><span class="line">        //接受父组件传值</span><br><span class="line">        props:[&quot;data&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="路由之间跳转？"><a href="#路由之间跳转？" class="headerlink" title="路由之间跳转？"></a>路由之间跳转？</h3><h4 id="声明式（标签跳转）"><a href="#声明式（标签跳转）" class="headerlink" title="声明式（标签跳转）"></a><strong>声明式（标签跳转）</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=&quot;index&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="编程式（-js跳转）"><a href="#编程式（-js跳转）" class="headerlink" title="编程式（ js跳转）"></a><strong>编程式（ js跳转）</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.push(&apos;index&apos;)</span><br></pre></td></tr></table></figure><h3 id="vuex是什么？怎么使用？哪种功能场景使用它？"><a href="#vuex是什么？怎么使用？哪种功能场景使用它？" class="headerlink" title="vuex是什么？怎么使用？哪种功能场景使用它？"></a>vuex是什么？怎么使用？哪种功能场景使用它？</h3><blockquote><p>vue框架中状态管理。在main.js引入store，注入。新建了一个目录<code>store</code>，….. <code>export</code> 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车</p></blockquote><h3 id="vue-中的性能优化"><a href="#vue-中的性能优化" class="headerlink" title="vue 中的性能优化"></a>vue 中的性能优化</h3><p>Vue 应用运行时性能优化措施</p><p>引入生产环境的 Vue 文件</p><p>使用单文件组件预编译模板</p><p>提取组件的 CSS 到单独到文件</p><p>利用 Object.freeze()提升性能</p><p>扁平化 Store 数据结构</p><p>合理使用持久化 Store 数据</p><p>组件懒加载</p><p>Vue 应用加载性能优化措施</p><p>服务端渲染 / 预渲染</p><p>组件懒加载</p><p>减少 http 请求，合理设置 HTTP 缓存<br>使用浏览器缓存<br>启用压缩<br>CSS Sprites<br>LazyLoad Images<br>CSS 放在页面最上部，javascript 放在页面最下面<br>尽量避免使用 eval 和 Function</p><h3 id="Vue-的实例生命周期"><a href="#Vue-的实例生命周期" class="headerlink" title="Vue 的实例生命周期"></a>Vue 的实例生命周期</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="../images/vue001.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>（1） beforeCreate 初始化实例后 数据观测和事件配置之前调用</p><p>（2） created 实例创建完成后调用</p><p>（3） beforeMount 挂载开始前被用</p><p>（4） mounted el 被新建 vm.$el 替换并挂在到实例上之后调用</p><p>（5） beforeUpdate 数据更新时调用</p><p>（6） updated 数据更改导致的 DOM 重新渲染后调用</p><p>（7） beforeDestory 实例被销毁前调用</p><p>（8） destroyed 实例销毁后调用</p><h3 id="Vue-的双向数据绑定的原理"><a href="#Vue-的双向数据绑定的原理" class="headerlink" title="Vue 的双向数据绑定的原理"></a>Vue 的双向数据绑定的原理</h3><p>VUE 实现双向数据绑定的原理就是利用了 Object.defineProperty() 这个方法重新定义了对象获取属性值(get)和设置属性值(set)的操作来实现的。</p><p>Vue3.0 将用原生 Proxy 替换 Object.defineProperty</p><h3 id="为什么要替换-Object-defineProperty？"><a href="#为什么要替换-Object-defineProperty？" class="headerlink" title="为什么要替换 Object.defineProperty？"></a>为什么要替换 Object.defineProperty？</h3><p>在 Vue 中，Object.defineProperty 无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应。</p><p>Object.defineProperty 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。</p><h3 id="什么是-Proxy？"><a href="#什么是-Proxy？" class="headerlink" title="什么是 Proxy？"></a>什么是 Proxy？</h3><p>Proxy 是 ES6 中新增的一个特性，翻译过来意思是”代理”，用在这里表示由它来“代理”某些操作。 Proxy 让我们能够以简洁易懂的方式控制外部对对象的访问。其功能非常类似于设计模式中的代理模式。</p><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p><p>使用 Proxy 的核心优点是可以交由它来处理一些非核心逻辑（如：读取或设置对象的某些属性前记录日志；设置对象的某些属性值前，需要验证；某些属性的访问控制等）。 从而可以让对象只需关注于核心逻辑，达到关注点分离，降低对象复杂度等目的。</p><h3 id="为什么避免-v-if-和-v-for-用在一起"><a href="#为什么避免-v-if-和-v-for-用在一起" class="headerlink" title="为什么避免 v-if 和 v-for 用在一起"></a>为什么避免 v-if 和 v-for 用在一起</h3><p>当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级，这意味着 v-if 将分别重复运行于每个 v-for 循环中。通过 v-if 移动到容器元素，不会再重复遍历列表中的每个值。取而代之的是，我们只检查它一次，且不会在 v-if 为否的时候运算 v-for。</p><h3 id="组件的设计原则"><a href="#组件的设计原则" class="headerlink" title="组件的设计原则"></a>组件的设计原则</h3><ul><li>页面上每个独立的可视/可交互区域视为一个组件(比如页面的头部，尾部，可复用的区块)</li><li>每个组件对应一个工程目录，组件所需要的各种资源在这个目录下就近维护(组件的就近维护思想体现了前端的工程化思想，为前端开发提供了很好的分治策略，在vue.js中，通过.vue文件将组件依赖的模板，js，样式写在一个文件中)<br>(每个开发者清楚开发维护的功能单元，它的代码必然存在在对应的组件目录中，在该目录下，可以找到功能单元所有的内部逻辑)</li><li>页面不过是组件的容器，组件可以嵌套自由组合成完整的页面</li></ul><h3 id="对于-Vue-是一套渐进式框架的理解"><a href="#对于-Vue-是一套渐进式框架的理解" class="headerlink" title="对于 Vue 是一套渐进式框架的理解"></a>对于 Vue 是一套渐进式框架的理解</h3><p>每个框架都不可避免会有自己的一些特点，从而会对使用者有一定的要求，这些要求就是主张，主张有强有弱，它的强势程度会影响在业务开发中的使用方式。</p><p>1、使用 vue，你可以在原有大系统的上面，把一两个组件改用它实现，当 jQuery 用；</p><p>2、也可以整个用它全家桶开发，当 Angular 用；</p><p>3、还可以用它的视图，搭配你自己设计的整个下层用。你可以在底层数据逻辑的地方用 OO(Object–Oriented )面向对象和设计模式的那套理念。<br>也可以函数式，都可以。</p><p>它只是个轻量视图而已，只做了自己该做的事，没有做不该做的事，仅此而已。</p><p>你不必一开始就用 Vue 所有的全家桶，根据场景，官方提供了方便的框架供你使用。</p><p>场景联想<br>场景 1：<br>维护一个老项目管理后台，日常就是提交各种表单了，这时候你可以把 vue 当成一个 js 库来使用，就用来收集 form 表单，和表单验证。</p><p>场景 2：<br>得到 boss 认可， 后面整个页面的 dom 用 Vue 来管理，抽组件，列表用 v-for 来循环，用数据驱动 DOM 的变化</p><p>场景 3:<br>越来越受大家信赖，领导又找你了，让你去做一个移动端 webapp，直接上了 vue 全家桶！</p><p>场景 1-3 从最初的只因多看你一眼而用了前端 js 库，一直到最后的大型项目解决方案。</p><h3 id="请问-v-if-和-v-show-有什么区别"><a href="#请问-v-if-和-v-show-有什么区别" class="headerlink" title="请问 v-if 和 v-show 有什么区别"></a>请问 v-if 和 v-show 有什么区别</h3><p>v-show 指令是通过修改元素的 display 的 CSS 属性让其显示或者隐藏</p><p>v-if 指令是直接销毁和重建 DOM 达到让元素显示和隐藏的效果</p><h3 id="vue-常用的修饰符"><a href="#vue-常用的修饰符" class="headerlink" title="vue 常用的修饰符"></a>vue 常用的修饰符</h3><p><a href="https://blog.csdn.net/qq_42238554/article/details/86592295" target="_blank" rel="noopener">参考</a></p><h3 id="v-on-可以监听多个方法吗？"><a href="#v-on-可以监听多个方法吗？" class="headerlink" title="v-on 可以监听多个方法吗？"></a>v-on 可以监听多个方法吗？</h3><p>肯定可以的。</p><p>解析：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">"text"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:value</span>=<span class="string">"name"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">input</span>=<span class="string">"onInput"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">focus</span>=<span class="string">"onFocus"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">blur</span>=<span class="string">"onBlur"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="vue-中-key-值的作用"><a href="#vue-中-key-值的作用" class="headerlink" title="vue 中 key 值的作用"></a>vue 中 key 值的作用</h3><p>需要使用 key 来给每个节点做一个唯一标识，Diff 算法就可以正确的识别此节点，找到正确的位置区插入新的节点<br>所以一句话，key 的作用主要是为了高效的更新虚拟 DOM</p><h3 id="vue-cli-工程升级-vue-版本"><a href="#vue-cli-工程升级-vue-版本" class="headerlink" title="vue-cli 工程升级 vue 版本"></a>vue-cli 工程升级 vue 版本</h3><p>在项目目录里运行 npm upgrade vue vue-template-compiler，不出意外的话，可以正常运行和 build。如果有任何问题，删除 node_modules 文件夹然后重新运行 npm i 即可。（简单的说就是升级 vue 和 vue-template-compiler 两个插件）</p><h3 id="vue-事件中如何使用-event-对象？"><a href="#vue-事件中如何使用-event-对象？" class="headerlink" title="vue 事件中如何使用 event 对象？"></a>vue 事件中如何使用 event 对象？</h3><p>v-on 指令（可以简写为 @）</p><p>1、使用不带圆括号的形式，event 对象将被自动当做实参传入；</p><p>2、使用带圆括号的形式，我们需要使用 $event 变量显式传入 event 对象。</p><p>解析：</p><p>一、event 对象</p><p>（一）事件的 event 对象</p><p>你说你是搞前端的，那么你肯定就知道事件，知道事件，你就肯定知道 event 对象吧？各种的库、框架多少都有针对 event 对象的处理。比如 jquery，通过它内部进行一定的封装，我们开发的时候，就无需关注 event 对象的部分兼容性问题。最典型的，如果我们要阻止默认事件，在 chrome 等浏览器中，我们可能要写一个：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.preventDefault();</span><br></pre></td></tr></table></figure><p>而在 IE 中，我们则需要写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.returnValue = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>多亏了 jquery ，跨浏览器的实现，我们统一只需要写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.preventDefault();</span><br></pre></td></tr></table></figure><p>兼容？jquery 内部帮我们搞定了。类似的还有比如阻止事件冒泡以以及事件绑定（addEventListener / attachEvent）等，简单到很多的后端都会使用 $(‘xxx’).bind(…)，这不是我们今天的重点，我们往下看。</p><p>（二）vue 中的 event 对象</p><p>我们知道，相比于 jquery，vue 的事件绑定可以显得更加直观和便捷，我们只需要在模板上添加一个 v-on 指令（还可以简写为 @），即可完成类似于 $(‘xxx’).bind 的效果，少了一个利用选择器查询元素的操作。我们知道，jquery 中，event 对象会被默认当做实参传入到处理函数中，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"body"</span>).bind(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> event); <span class="comment">// object</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里直接就获取到了 event 对象，那么问题来了，vue 中呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;button v-on:click=<span class="string">"click"</span>&gt;click me&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        click(event) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">typeof</span> event);    <span class="comment">// object</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里的实现方式看起来和 jquery 是一致的啊，但是实际上，vue 比 jquery 要要复杂得多，jquery 官方也明确的说，v-on 不简单是 addEventListener 的语法糖。在 jquery 中，我们传入到 bind 方法中的回调，只能是一个函数表类型的变量或者一个匿名函数，传递的时候，还不能执行它（在后面加上一堆圆括号），否则就变成了取这一个函数的返回值作为事件回调。而我们知道，vue 的 v-on 指令接受的值可以是函数执行的形式，比如 v-on:click=”click(233)” 。这里我们可以传递任何需要传递的参数，甚至可以不传递参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;button v-on:click=<span class="string">"click()"</span>&gt;click me&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        click(event) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">typeof</span> event);    <span class="comment">// undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>咦？我的 event 对象呢？怎么不见了？打印看看 arguments.length 也是 0，说明这时候确实没有实参被传入进来。T_T，那我们如果既需要传递参数，又需要用到 event 对象，这个该怎么办呢？</p><p>（三）$event</p><p>翻看 vue 文档，不难发现，其实我们可以通过将一个特殊变量 $event 传入到回调中解决这个问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;button v-on:click=<span class="string">"click($event, 233)"</span>&gt;click me&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        click(event, val) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">typeof</span> event);    <span class="comment">// object</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>好吧，这样看起来就正常了。<br>简单总结来说：</p><p>使用不带圆括号的形式，event 对象将被自动当做实参传入；</p><p>使用带圆括号的形式，我们需要使用 $event 变量显式传入 event 对象。</p><h3 id="nextTick-的使用"><a href="#nextTick-的使用" class="headerlink" title="$nextTick 的使用"></a>$nextTick 的使用</h3><p>1、什么是 Vue.nextTick()？</p><p>定义：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p><p>所以就衍生出了这个获取更新后的 DOM 的 Vue 方法。所以放在 Vue.nextTick()回调函数中的执行的应该是会对 DOM 进行操作的 js 代码；</p><p>理解：nextTick()，是将回调函数延迟在下一次 dom 更新数据后调用，简单的理解是：当数据更新了，在 dom 中渲染后，自动执行该函数，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"hello"</span>&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button id=<span class="string">"firstBtn"</span> @click=<span class="string">"testClick()"</span> ref=<span class="string">"aa"</span>&gt;&#123;&#123;testMsg&#125;&#125;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'HelloWorld'</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      testMsg:<span class="string">"原始值"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    testClick:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> that=<span class="keyword">this</span>;</span><br><span class="line">      that.testMsg=<span class="string">"修改后的值"</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(that.$refs.aa.innerText);   <span class="comment">//that.$refs.aa获取指定DOM，输出：原始值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>使用 this.$nextTick()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    testClick:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> that=<span class="keyword">this</span>;</span><br><span class="line">      that.testMsg=<span class="string">"修改后的值"</span>;</span><br><span class="line">      that.$nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(that.$refs.aa.innerText);  <span class="comment">//输出：修改后的值</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>注意：Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM，</p><p>2、什么时候需要用的 Vue.nextTick()？？</p><p>1、Vue 生命周期的 created()钩子函数进行的 DOM 操作一定要放在 Vue.nextTick()的回调函数中，原因是在 created()钩子函数执行的时候 DOM 其实并未进行任何渲染，而此时进行 DOM 操作无异于徒劳，所以此处一定要将 DOM 操作的 js 代码放进 Vue.nextTick()的回调函数中。与之对应的就是 mounted 钩子函数，因为该钩子函数执行时所有的 DOM 挂载已完成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">created()&#123;</span><br><span class="line">    <span class="keyword">let</span> that=<span class="keyword">this</span>;</span><br><span class="line">    that.$nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">//不使用this.$nextTick()方法会报错</span></span><br><span class="line">        that.$refs.aa.innerHTML=<span class="string">"created中更改了按钮内容"</span>;  <span class="comment">//写入到DOM元素</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、当项目中你想在改变 DOM 元素的数据后基于新的 dom 做点什么，对新 DOM 一系列的 js 操作都需要放进 Vue.nextTick()的回调函数中；通俗的理解是：更改数据后当你想立即使用 js 操作新的视图的时候需要使用它</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"hello"</span>&gt;</span><br><span class="line">    &lt;h3 id=<span class="string">"h"</span>&gt;&#123;&#123;testMsg&#125;&#125;&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  name: 'HelloWorld',</span></span><br><span class="line"><span class="regexp">  data () &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      testMsg:"原始值",</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  methods:&#123;</span></span><br><span class="line"><span class="regexp">    changeTxt:function()&#123;</span></span><br><span class="line"><span class="regexp">      let that=this;</span></span><br><span class="line"><span class="regexp">      that.testMsg="修改后的文本值";  /</span><span class="regexp">/vue数据改变，改变dom结构</span></span><br><span class="line"><span class="regexp">      let domTxt=document.getElementById('h').innerText;  /</span><span class="regexp">/后续js对dom的操作</span></span><br><span class="line"><span class="regexp">      console.log(domTxt);  /</span><span class="regexp">/输出可以看到vue数据修改后DOM并没有立即更新，后续的dom都不是最新的</span></span><br><span class="line"><span class="regexp">      if(domTxt==="原始值")&#123;</span></span><br><span class="line"><span class="regexp">        console.log("文本data被修改后dom内容没立即更新");</span></span><br><span class="line"><span class="regexp">      &#125;else &#123;</span></span><br><span class="line"><span class="regexp">        console.log("文本data被修改后dom内容被马上更新了");</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>正确的用法是：vue 改变 dom 元素结构后使用 vue.$nextTick()方法来实现 dom 数据更新后延迟执行后续代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">changeTxt:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> that=<span class="keyword">this</span>;</span><br><span class="line">  that.testMsg=<span class="string">"修改后的文本值"</span>;  <span class="comment">//修改dom结构</span></span><br><span class="line"></span><br><span class="line">  that.$nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">//使用vue.$nextTick()方法可以dom数据更新后延迟执行</span></span><br><span class="line">    <span class="keyword">let</span> domTxt=<span class="built_in">document</span>.getElementById(<span class="string">'h'</span>).innerText;</span><br><span class="line">    <span class="built_in">console</span>.log(domTxt);  <span class="comment">//输出可以看到vue数据修改后并没有DOM没有立即更新，</span></span><br><span class="line">    <span class="keyword">if</span>(domTxt===<span class="string">"原始值"</span>)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"文本data被修改后dom内容没立即更新"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"文本data被修改后dom内容被马上更新了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、在使用某个第三方插件时 ，希望在 vue 生成的某些 dom 动态发生变化时重新应用该插件，也会用到该方法，这时候就需要在 $nextTick 的回调函数中执行重新应用插件的方法。</p><p>Vue.nextTick(callback) 使用原理：</p><p>原因是，Vue 是异步执行 dom 更新的，一旦观察到数据变化，Vue 就会开启一个队列，然后把在同一个事件循环 (event loop) 当中观察到数据变化的 watcher 推送进这个队列。如果这个 watcher 被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和 DOm 操作。而在下一个事件循环时，Vue 会清空队列，并进行必要的 DOM 更新。<br>当你设置 vm.someData = ‘new value’，DOM 并不会马上更新，而是在异步队列被清除，也就是下一个事件循环开始时执行更新时才会进行必要的 DOM 更新。如果此时你想要根据更新的 DOM 状态去做某些事情，就会出现问题。。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。</p><h3 id="Vue-组件中-data-为什么必须是函数"><a href="#Vue-组件中-data-为什么必须是函数" class="headerlink" title="Vue 组件中 data 为什么必须是函数"></a>Vue 组件中 data 为什么必须是函数</h3><p>在 new Vue() 中，data 是可以作为一个对象进行操作的，然而在 component 中，data 只能以函数的形式存在，不能直接将对象赋值给它，这并非是 Vue 自身如此设计，而是跟 JavaScript 特性相关，我们来回顾下 JavaScript 的原型链</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Component = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Component.prototype.data = &#123;</span><br><span class="line">  message: <span class="string">"Love"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> component1 = <span class="keyword">new</span> Component(),</span><br><span class="line">  component2 = <span class="keyword">new</span> Component();</span><br><span class="line">component1.data.message = <span class="string">"Peace"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(component2.data.message); <span class="comment">// Peace</span></span><br></pre></td></tr></table></figure><p>以上两个实例都引用同一个对象，当其中一个实例属性改变时，另一个实例属性也随之改变，只有当两个实例拥有自己的作用域时，才不会互相干扰 ！！！！！这句是重点！！！！！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Component = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.data = <span class="keyword">this</span>.data();</span><br><span class="line">&#125;;</span><br><span class="line">Component.prototype.data = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    message: <span class="string">"Love"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> component1 = <span class="keyword">new</span> Component(),</span><br><span class="line">  component2 = <span class="keyword">new</span> Component();</span><br><span class="line">component1.data.message = <span class="string">"Peace"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(component2.data.message); <span class="comment">// Love</span></span><br></pre></td></tr></table></figure><h3 id="v-for-与-v-if-的优先级"><a href="#v-for-与-v-if-的优先级" class="headerlink" title="v-for 与 v-if 的优先级"></a>v-for 与 v-if 的优先级</h3><p>v-for 比 v-if 优先</p><h3 id="vue-中子组件调用父组件的方法"><a href="#vue-中子组件调用父组件的方法" class="headerlink" title="vue 中子组件调用父组件的方法"></a>vue 中子组件调用父组件的方法</h3><ul><li>第一种方法是直接在子组件中通过 this.$parent.event 来调用父组件的方法</li><li>第二种方法是在子组件里用$emit 向父组件触发一个事件，父组件监听这个事件就行了</li><li>第三种是父组件把方法传入子组件中，在子组件里直接调用这个方法</li></ul><p>解析：</p><p>第一种方法是直接在子组件中通过 this.$parent.event 来调用父组件的方法</p><p>父组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;child&gt;<span class="xml"><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">'~/components/dam/child'</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">      child</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      fatherMethod() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'测试'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>子组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"childMethod()"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    methods: &#123;</span><br><span class="line">      childMethod() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.$parent.fatherMethod();</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二种方法是在子组件里用$emit 向父组件触发一个事件，父组件监听这个事件就行了</p><p>父组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span> @<span class="attr">fatherMethod</span>=<span class="string">"fatherMethod"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">"~/components/dam/child"</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    components: &#123;</span><br><span class="line">      child</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      fatherMethod() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"测试"</span>);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"childMethod()"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    methods: &#123;</span><br><span class="line">      childMethod() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.$emit(<span class="string">"fatherMethod"</span>);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第三种是父组件把方法传入子组件中，在子组件里直接调用这个方法</p><p>父组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">:fatherMethod</span>=<span class="string">"fatherMethod"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">"~/components/dam/child"</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    components: &#123;</span><br><span class="line">      child</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      fatherMethod() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"测试"</span>);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"childMethod()"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    props: &#123;</span><br><span class="line">      fatherMethod: &#123;</span><br><span class="line"><span class="javascript">        type: <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">default</span>: <span class="literal">null</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      childMethod() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">if</span> (<span class="keyword">this</span>.fatherMethod) &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.fatherMethod();</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="vue-中父组件调用子组件的方法"><a href="#vue-中父组件调用子组件的方法" class="headerlink" title="vue 中父组件调用子组件的方法"></a>vue 中父组件调用子组件的方法</h3><p>答案：使用$refs</p><p>父组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"clickParent"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">ref</span>=<span class="string">"mychild"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">"./child"</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">    name: <span class="string">"parent"</span>,</span></span><br><span class="line">    components: &#123;</span><br><span class="line">      child: Child</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      clickParent() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.$refs.mychild.parentHandleclick(<span class="string">"嘿嘿嘿"</span>); <span class="comment">// 划重点！！！！</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    child</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">    name: <span class="string">"child"</span>,</span></span><br><span class="line"><span class="actionscript">    props: <span class="string">"someprops"</span>,</span></span><br><span class="line">    methods: &#123;</span><br><span class="line">      parentHandleclick(e) &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(e);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="vue-中-keep-alive-组件的作用"><a href="#vue-中-keep-alive-组件的作用" class="headerlink" title="vue 中 keep-alive 组件的作用"></a>vue 中 keep-alive 组件的作用</h3><p>答案：keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。</p><p>解析：</p><p>用法也很简单：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 该组件将被缓存！ --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><p>props<br>_ include - 字符串或正则表达，只有匹配的组件会被缓存<br>_ exclude - 字符串或正则表达式，任何匹配的组件都不会被缓存</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件 a</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">"a"</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">"a"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- name 为 a 的组件将被缓存！ --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">component</span>&gt;</span> <span class="tag">&lt;/<span class="name">keep-alive</span></span></span><br><span class="line"><span class="tag">&gt;</span>可以保留它的状态或避免重新渲染</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">exclude</span>=<span class="string">"a"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 除了 name 为 a 的组件都将被缓存！ --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">component</span>&gt;</span> <span class="tag">&lt;/<span class="name">keep-alive</span></span></span><br><span class="line"><span class="tag">&gt;</span>可以保留它的状态或避免重新渲染</span><br></pre></td></tr></table></figure><p>但实际项目中,需要配合 vue-router 共同使用.</p><p>router-view 也是一个组件，如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 所有路径匹配到的视图组件都会被缓存！ --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果只想 router-view 里面某个组件被缓存，怎么办？</p><p>增加 router.meta 属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// routes 配置</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">"/"</span>,</span><br><span class="line">    name: <span class="string">"home"</span>,</span><br><span class="line">    component: Home,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      keepAlive: <span class="literal">true</span> <span class="comment">// 需要被缓存</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">"/:id"</span>,</span><br><span class="line">    name: <span class="string">"edit"</span>,</span><br><span class="line">    component: Edit,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      keepAlive: <span class="literal">false</span> <span class="comment">// 不需要被缓存</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">    &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;</span><br><span class="line">        &lt;!-- 这里是会被缓存的视图组件，比如 Home！ --&gt;</span><br><span class="line">    &lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;</span><br><span class="line">    &lt;!-- 这里是不被缓存的视图组件，比如 Edit！ --&gt;</span><br><span class="line">&lt;/router-view&gt;</span><br></pre></td></tr></table></figure><h3 id="vue-中如何编写可复用的组件？"><a href="#vue-中如何编写可复用的组件？" class="headerlink" title="vue 中如何编写可复用的组件？"></a>vue 中如何编写可复用的组件？</h3><p>总结组件的职能，什么需要外部控制（即 props 传啥），组件需要控制外部吗（$emit）,是否需要插槽（slot）</p><h3 id="什么是-vue-生命周期和生命周期钩子函数？"><a href="#什么是-vue-生命周期和生命周期钩子函数？" class="headerlink" title="什么是 vue 生命周期和生命周期钩子函数？"></a>什么是 vue 生命周期和生命周期钩子函数？</h3><p>vue 的生命周期就是 vue 实例从创建到销毁的过程</p><p>解析：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="../images/vue002.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="vue-生命周期钩子函数有哪些？"><a href="#vue-生命周期钩子函数有哪些？" class="headerlink" title="vue 生命周期钩子函数有哪些？"></a>vue 生命周期钩子函数有哪些？</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="../images/vue003.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="vue-如何监听键盘事件中的按键"><a href="#vue-如何监听键盘事件中的按键" class="headerlink" title="vue 如何监听键盘事件中的按键"></a>vue 如何监听键盘事件中的按键</h3><p>解析：<br><a href="https://blog.csdn.net/xiaxiangyun/article/details/80404768" target="_blank" rel="noopener">参考</a></p><h3 id="vue-更新数组时触发视图更新的方法"><a href="#vue-更新数组时触发视图更新的方法" class="headerlink" title="vue 更新数组时触发视图更新的方法"></a>vue 更新数组时触发视图更新的方法</h3><p>1.Vue.set 可以设置对象或数组的值，通过 key 或数组索引，可以触发视图更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">数组修改</span><br><span class="line"></span><br><span class="line">Vue.set(array, indexOfItem, newValue)</span><br><span class="line">this.array.$set(indexOfItem, newValue)</span><br><span class="line">对象修改</span><br><span class="line"></span><br><span class="line">Vue.set(obj, keyOfItem, newValue)</span><br><span class="line">this.obj.$set(keyOfItem, newValue)</span><br></pre></td></tr></table></figure><p>2.Vue.delete 删除对象或数组中元素，通过 key 或数组索引，可以触发视图更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">数组修改</span><br><span class="line"></span><br><span class="line">Vue.delete(array, indexOfItem)</span><br><span class="line">this.array.$delete(indexOfItem)</span><br><span class="line">对象修改</span><br><span class="line"></span><br><span class="line">Vue.delete(obj, keyOfItem)</span><br><span class="line">this.obj.$delete(keyOfItem)</span><br></pre></td></tr></table></figure><p>3.数组对象直接修改属性，可以触发视图更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.array[0].show = true;</span><br><span class="line">this.array.forEach(function(item)&#123;</span><br><span class="line">    item.show = true;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>4.splice 方法修改数组，可以触发视图更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.array.splice(indexOfItem, 1, newElement)</span><br></pre></td></tr></table></figure><p>5.数组整体修改，可以触发视图更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var tempArray = this.array;</span><br><span class="line">tempArray[0].show = true;</span><br><span class="line">this.array = tempArray;</span><br></pre></td></tr></table></figure><p>6.用 Object.assign 或 lodash.assign 可以为对象添加响应式属性，可以触发视图更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//Object.assign的单层的覆盖前面的属性，不会递归的合并属性</span><br><span class="line">this.obj = Object.assign(&#123;&#125;,this.obj,&#123;a:1, b:2&#125;)</span><br><span class="line"></span><br><span class="line">//assign与Object.assign一样</span><br><span class="line">this.obj = _.assign(&#123;&#125;,this.obj,&#123;a:1, b:2&#125;)</span><br><span class="line"></span><br><span class="line">//merge会递归的合并属性</span><br><span class="line">this.obj = _.merge(&#123;&#125;,this.obj,&#123;a:1, b:2&#125;)</span><br></pre></td></tr></table></figure><p>7.Vue 提供了如下的数组的变异方法，可以触发视图更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">push()</span><br><span class="line">pop()</span><br><span class="line">shift()</span><br><span class="line">unshift()</span><br><span class="line">splice()</span><br><span class="line">sort()</span><br><span class="line">reverse()</span><br></pre></td></tr></table></figure><h3 id="什么是-vue-的计算属性？"><a href="#什么是-vue-的计算属性？" class="headerlink" title="什么是 vue 的计算属性？"></a>什么是 vue 的计算属性？</h3><p>答案：先来看一下计算属性的定义：<br>当其依赖的属性的值发生变化的时，计算属性会重新计算。反之则使用缓存中的属性值。<br>计算属性和vue中的其它数据一样，都是响应式的，只不过它必须依赖某一个数据实现，并且只有它依赖的数据的值改变了，它才会更新。</p><h3 id="什么是-Virtual-DOM？"><a href="#什么是-Virtual-DOM？" class="headerlink" title="什么是 Virtual DOM？"></a>什么是 Virtual DOM？</h3><p>可以看作是一个使用 javascript 模拟了 DOM 结构的树形结构</p><p><a href="https://www.cnblogs.com/gaosong-shuhong/p/9253959.html" target="_blank" rel="noopener">参考</a></p><h3 id="响应式系统的基本原理"><a href="#响应式系统的基本原理" class="headerlink" title="响应式系统的基本原理"></a>响应式系统的基本原理</h3><p>Object.defineProperty，Vue.js 就是基于它实现「响应式系统」的。</p><h3 id="Vue-中如何实现-proxy-代理？"><a href="#Vue-中如何实现-proxy-代理？" class="headerlink" title="Vue 中如何实现 proxy 代理？"></a>Vue 中如何实现 proxy 代理？</h3><p>webpack 自带的 devServer 中集成了 http-proxy-middleware。配置 devServer 的 proxy 选项即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">proxyTable: &#123;</span><br><span class="line">   <span class="string">'/api'</span>: &#123;</span><br><span class="line">    target: <span class="string">'http://192.168.149.90:8080/'</span>, <span class="comment">// 设置你调用的接口域名和端口号</span></span><br><span class="line">    changeOrigin: <span class="literal">true</span>,   <span class="comment">// 跨域</span></span><br><span class="line">    pathRewrite: &#123;</span><br><span class="line">     <span class="string">'^/api'</span>: <span class="string">'/'</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="vue-在什么情况下在数据发生改变的时候不会触发视图更新"><a href="#vue-在什么情况下在数据发生改变的时候不会触发视图更新" class="headerlink" title="vue 在什么情况下在数据发生改变的时候不会触发视图更新"></a>vue 在什么情况下在数据发生改变的时候不会触发视图更新</h3><p>v-for 遍历的数组，当数组内容使用的是 arr[0].xx =xx 更改数据，vue 无法监测到<br>vm.arr.length = newLength 也是无法检测的到的</p><h3 id="vue-的优点是什么？"><a href="#vue-的优点是什么？" class="headerlink" title="vue 的优点是什么？"></a>vue 的优点是什么？</h3><p>低耦合。视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的”View”上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。</p><p>可重用性。你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 view 重用这段视图逻辑。</p><p>独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</p><p>可测试。界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。</p><h3 id="vue-如何实现按需加载配合-webpack-设置"><a href="#vue-如何实现按需加载配合-webpack-设置" class="headerlink" title="vue 如何实现按需加载配合 webpack 设置"></a>vue 如何实现按需加载配合 webpack 设置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">webpack 中提供了 require.ensure()来实现按需加载。以前引入路由是通过 import 这样的方式引入，改为 const 定义的方式进行引入。</span><br><span class="line">不进行页面按需加载引入方式：import home from &apos;../../common/home.vue&apos;</span><br><span class="line">进行页面按需加载的引入方式：const home = r =&gt; require.ensure( [], () =&gt; r (require(&apos;../../common/home.vue&apos;)))</span><br></pre></td></tr></table></figure><p>在音乐 app 中使用的路由懒加载方式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const Recommend = (resolve) =&gt; &#123;</span><br><span class="line">  import(&apos;components/recommend/recommend&apos;).then((module) =&gt; &#123;</span><br><span class="line">    resolve(module)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Singer = (resolve) =&gt; &#123;</span><br><span class="line">  import(&apos;components/singer/singer&apos;).then((module) =&gt; &#123;</span><br><span class="line">    resolve(module)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何让-CSS-只在当前组件中起作用"><a href="#如何让-CSS-只在当前组件中起作用" class="headerlink" title="如何让 CSS 只在当前组件中起作用"></a>如何让 CSS 只在当前组件中起作用</h3><p>将当前组件的<style>修改为<style scoped></p><h3 id="指令-v-el-的作用是什么"><a href="#指令-v-el-的作用是什么" class="headerlink" title="指令 v-el 的作用是什么?"></a>指令 v-el 的作用是什么?</h3><p>提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标.可以是 CSS 选择器，也可以是一个 HTMLElement 实例</p><h3 id="vue-loader-是什么？使用它的用途有哪些？"><a href="#vue-loader-是什么？使用它的用途有哪些？" class="headerlink" title="vue-loader 是什么？使用它的用途有哪些？"></a>vue-loader 是什么？使用它的用途有哪些？</h3><p>vue-loader 是解析 .vue 文件的一个加载器，将 template/js/style 转换成 js 模块。</p><p>用途：js 可以写 es6、style 样式可以 scss 或 less；template 可以加 jade 等。</p><h3 id="vue怎么实现页面的权限控制"><a href="#vue怎么实现页面的权限控制" class="headerlink" title="vue怎么实现页面的权限控制"></a>vue怎么实现页面的权限控制</h3><p>利用 vue-router 的 beforeEach 事件，可以在跳转页面前判断用户的权限（利用 cookie 或 token），是否能够进入此页面，如果不能则提示错误或重定向到其他页面，在后台管理系统中这种场景经常能遇到。</p><h3 id="route和-router的区别"><a href="#route和-router的区别" class="headerlink" title="$route和$router的区别"></a>$route和$router的区别</h3><p>答案：$route 是路由信息对象，包括path，params，hash，query，fullPath，matched，name 等路由信息参数。</p><p>而 $router 是路由实例对象，包括了路由的跳转方法，钩子函数等</p><h3 id="watch的作用是什么"><a href="#watch的作用是什么" class="headerlink" title="watch的作用是什么"></a>watch的作用是什么</h3><p>watch 主要作用是监听某个数据值的变化。和计算属性相比除了没有缓存，作用是一样的。</p><p>借助 watch 还可以做一些特别的事情，例如监听页面路由，当页面跳转时，我们可以做相应的权限控制，拒绝没有权限的用户访问页面。</p><h3 id="实现-Vue-SSR"><a href="#实现-Vue-SSR" class="headerlink" title="实现 Vue SSR"></a>实现 Vue SSR</h3><h4 id="其基本实现原理"><a href="#其基本实现原理" class="headerlink" title="其基本实现原理"></a><strong>其基本实现原理</strong></h4><ul><li>app.js 作为客户端与服务端的公用入口，导出 Vue 根实例，供客户端 entry 与服务端 entry 使用。客户端 entry 主要作用挂载到 DOM 上，服务端 entry 除了创建和返回实例，还进行路由匹配与数据预获取。</li><li>webpack 为客服端打包一个 Client Bundle ，为服务端打包一个 Server Bundle 。</li><li>服务器接收请求时，会根据 url，加载相应组件，获取和解析异步数据，创建一个读取 Server Bundle 的 BundleRenderer，然后生成 html 发送给客户端。</li><li>客户端混合，客户端收到从服务端传来的 DOM 与自己的生成的 DOM 进行对比，把不相同的 DOM 激活，使其可以能够响应后续变化，这个过程称为客户端激活 。为确保混合成功，客户端与服务器端需要共享同一套数据。在服务端，可以在渲染之前获取数据，填充到 stroe 里，这样，在客户端挂载到 DOM 之前，可以直接从 store 里取数据。首屏的动态数据通过 <code>window.__INITIAL_STATE__</code>发送到客户端</li></ul><blockquote><p>Vue SSR 的实现，主要就是把 Vue 的组件输出成一个完整 HTML, vue-server-renderer 就是干这事的</p></blockquote><ul><li><code>Vue SSR</code>需要做的事多点（输出完整 HTML），除了<code>complier -&gt; vnode</code>，还需如数据获取填充至 HTML、客户端混合（hydration）、缓存等等。<br>相比于其他模板引擎（ejs, jade 等），最终要实现的目的是一样的，性能上可能要差点</li></ul><h3 id="Vue-组件-data-为什么必须是函数"><a href="#Vue-组件-data-为什么必须是函数" class="headerlink" title="Vue 组件 data 为什么必须是函数"></a>Vue 组件 data 为什么必须是函数</h3><ul><li>每个组件都是 Vue 的实例。</li><li>组件共享 data 属性，当 data 的值是同一个引用类型的值时，改变其中一个会影响其他</li></ul><h3 id="Vue-computed-实现"><a href="#Vue-computed-实现" class="headerlink" title="Vue computed 实现"></a>Vue computed 实现</h3><ul><li>建立与其他属性（如：data、 Store）的联系；</li><li>属性改变后，通知计算属性重新计算</li></ul><blockquote><p>实现时，主要如下</p></blockquote><ul><li>初始化 data， 使用 <code>Object.defineProperty</code> 把这些属性全部转为 <code>getter/setter</code>。</li><li>初始化 <code>computed</code>, 遍历 <code>computed</code> 里的每个属性，每个 computed 属性都是一个 watch 实例。每个属性提供的函数作为属性的 getter，使用 Object.defineProperty 转化。</li><li><code>Object.defineProperty getter</code> 依赖收集。用于依赖发生变化时，触发属性重新计算。</li><li>若出现当前 computed 计算属性嵌套其他 computed 计算属性时，先进行其他的依赖收集</li></ul><h3 id="Vue-complier-实现"><a href="#Vue-complier-实现" class="headerlink" title="Vue complier 实现"></a>Vue complier 实现</h3><ul><li>模板解析这种事，本质是将数据转化为一段 html ，最开始出现在后端，经过各种处理吐给前端。随着各种 mv* 的兴起，模板解析交由前端处理。</li><li>总的来说，Vue complier 是将 template 转化成一个 render 字符串。</li></ul><blockquote><p>可以简单理解成以下步骤：</p></blockquote><ul><li>parse 过程，将 template 利用正则转化成 AST 抽象语法树。</li><li>optimize 过程，标记静态节点，后 diff 过程跳过静态节点，提升性能。</li><li>generate 过程，生成 render 字符串</li></ul><h3 id="怎么快速定位哪个组件出现性能问题"><a href="#怎么快速定位哪个组件出现性能问题" class="headerlink" title="怎么快速定位哪个组件出现性能问题"></a>怎么快速定位哪个组件出现性能问题</h3><blockquote><p>用 timeline 工具。 大意是通过 timeline 来查看每个函数的调用时常，定位出哪个函数的问题，从而能判断哪个组件出了问题</p></blockquote></style></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;vue的优点是什么？&quot;&gt;&lt;a href=&quot;#vue的优点是什么？&quot; class=&quot;headerlink&quot; title=&quot;vue的优点是什么？&quot;&gt;&lt;/a&gt;vue的优点是什么？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;低耦合。视图（View）可以独立于Model变化和修改，一
      
    
    </summary>
    
      <category term="前端面试题" scheme="http://www.bluedream.top/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="vue" scheme="http://www.bluedream.top/tags/vue/"/>
    
      <category term="MVVM" scheme="http://www.bluedream.top/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>前端知识点</title>
    <link href="http://www.bluedream.top/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
    <id>http://www.bluedream.top/前端面试题/前端知识点.html</id>
    <published>2019-08-27T12:30:00.000Z</published>
    <updated>2019-09-28T09:41:26.905Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前端开发知识点"><a href="#前端开发知识点" class="headerlink" title="前端开发知识点"></a>前端开发知识点</h2><h3 id="HTML-amp-CSS"><a href="#HTML-amp-CSS" class="headerlink" title="HTML&amp;CSS"></a>HTML&amp;CSS</h3><p>对Web标准的理解、浏览器内核差异、兼容性、hack、CSS基本功：布局、盒子模型、选择器优先级、HTML5、CSS3、Flexbox</p><h3 id="JavaScript："><a href="#JavaScript：" class="headerlink" title="JavaScript："></a>JavaScript：</h3><p>数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、RegExp、JSON、Ajax、DOM、BOM、内存泄漏、跨域、异步装载、模板引擎、前端MVC、路由、模块化、Canvas、ECMAScript </p><h3 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h3><ul><li><p>移动端、响应式、自动化构建、HTTP、离线存储、WEB安全、优化、重构、团队协作、可维护、易用性、SEO、UED、架构、职业生涯、快速学习能力</p></li><li><p>DOM结构 —— 两个节点之间可能存在哪些关系以及如何在节点之间任意移动。</p></li><li><p>DOM操作 —— 如何添加、移除、移动、复制、创建和查找节点等。</p></li><li><p>事件 —— 如何使用事件，以及IE和标准DOM事件模型之间存在的差别。</p></li><li><p>XMLHttpRequest —— 这是什么、怎样完整地执行一次GET请求、怎样检测错误。</p></li><li><p>严格模式与混杂模式 —— 如何触发这两种模式，区分它们有何意义。</p></li><li><p>盒模型 —— 外边距、内边距和边框之间的关系，及IE8以下版本的浏览器中的盒模型</p></li><li><p>块级元素与行内元素 —— 怎么用CSS控制它们、以及如何合理的使用它们</p></li><li><p>浮动元素 —— 怎么使用它们、它们有什么问题以及怎么解决这些问题。</p></li><li><p>HTML与XHTML —— 二者有什么区别，你觉得应该使用哪一个并说出理由。</p></li><li><p>JSON —— 作用、用途、设计结构</p></li></ul><h2 id="前端必备技能"><a href="#前端必备技能" class="headerlink" title="前端必备技能"></a>前端必备技能</h2><ul><li><p>基础</p><ul><li>HTML / CSS</li></ul></li><li><p>编程语言：Java / Python / PHP / Ruby等等</p></li><li><p>Web框架，如Spring MVC、Flask、Laravel等等</p><ul><li>HTTP<ul><li>CGI基本原理</li><li>XML和JSON处理。。</li></ul></li></ul></li><li><p>中级篇</p><ul><li>数据结构与算法</li><li>面向对象编程</li><li>CMS</li></ul></li><li><p>高级篇</p><ul><li>函数式编程</li><li>领域驱动设计</li><li>MVC / MVVM / MV*</li><li>安全性（如跨域）</li><li>操作系统原理</li></ul></li><li><p>调试</p><ul><li>远程调试    </li></ul></li><li><p>工程化</p><ul><li>版本管理</li><li>单元测试</li></ul></li><li><p>缓存篇</p><ul><li>应用层缓存 </li><li>数据库端缓存</li><li>分布式缓存</li></ul></li><li><p>网络与架构</p><ul><li>均衡负载</li><li>并发处理    </li></ul></li><li><p>性能优化</p><ul><li>运行环境优化，如JVM</li></ul></li><li><p>基础设施</p><ul><li>Docker</li><li>自动化部署</li><li>依赖管理</li><li>包管理</li><li>Linux下包创建、管理</li><li>打包脚本编写</li><li>Web容器，如Jboss</li></ul></li><li><p>数据持久化</p><ul><li>SQL</li><li>Database</li><li>ORM</li><li>DBMS</li></ul></li><li><p>数据库</p><ul><li>查询性能优化</li><li>结构优化</li><li>主从复制、主主复制等等</li><li>伸缩性与高可用性</li><li>备份恢复与容灾</li></ul></li><li><p>安全</p><ul><li>认证与会话管理</li><li>加密解密</li><li>XSS/CSRF/SQL注入</li></ul></li><li><p>监控</p><ul><li>应用性能监控</li><li>异常监控</li><li>日志</li></ul></li><li><p>服务</p><ul><li>REST</li><li>SOA / RPC</li></ul></li><li><p>消息</p></li><li><p>JMS</p></li><li><p>IPC</p></li><li><p>其他</p><ul><li>API设计</li></ul></li></ul><h2 id="PS相关"><a href="#PS相关" class="headerlink" title="PS相关"></a>PS相关</h2><h3 id="PNG-GIF-JPG的区别及如何选"><a href="#PNG-GIF-JPG的区别及如何选" class="headerlink" title="PNG,GIF,JPG的区别及如何选"></a>PNG,GIF,JPG的区别及如何选</h3><ul><li>GIF：<ul><li>8位像素，256色</li><li>无损压缩</li><li>支持简单动画</li><li>支持boolean透明</li><li>适合简单动画</li></ul></li><li>JPEG：<ul><li>颜色限于256</li><li>有损压缩</li><li>可控制压缩质量</li><li>不支持透明</li><li>适合照片</li></ul></li><li>PNG：<ul><li>有PNG8和truecolor PNG</li><li>PNG8类似GIF颜色上限为256，文件小，支持alpha透明度，无动画</li><li>适合图标、背景、按钮</li></ul></li></ul><h2 id="Git相关"><a href="#Git相关" class="headerlink" title="Git相关"></a>Git相关</h2><h3 id="git-fetch和git-pull的区别"><a href="#git-fetch和git-pull的区别" class="headerlink" title="git fetch和git pull的区别"></a><strong>git fetch和git pull的区别</strong></h3><ul><li>git pull：相当于是从远程获取最新版本并merge到本地</li><li>git fetch：相当于是从远程获取最新版本到本地，不会自动merge</li></ul><h2 id="SEO相关"><a href="#SEO相关" class="headerlink" title="SEO相关"></a>SEO相关</h2><h3 id="前端需要注意哪些SEO"><a href="#前端需要注意哪些SEO" class="headerlink" title="前端需要注意哪些SEO"></a>前端需要注意哪些SEO</h3><ul><li>合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可</li><li>语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页</li><li>重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</li><li>重要内容不要用js输出：爬虫不会执行js获取内容</li><li>少用iframe：搜索引擎不会抓取iframe中的内容</li><li>非装饰性图片必须加alt</li><li>提高网站速度：网站速度是搜索引擎排序的一个重要指标</li></ul><h3 id="如何做SEO优化"><a href="#如何做SEO优化" class="headerlink" title="如何做SEO优化?"></a>如何做SEO优化?</h3><ul><li><p>标题与关键词</p></li><li><p>设置有吸引力切合实际的标题，标题中要包含所做的关键词</p></li><li><p>网站结构目录</p></li><li><p>最好不要超过三级，每级有“面包屑导航”，使网站成树状结构分布</p></li><li><p>页面元素</p></li><li><p>给图片标注”Alt”可以让搜索引擎更友好的收录</p></li><li><p>网站内容</p></li><li><p>每个月每天有规律的更新网站的内容，会使搜索引擎更加喜欢</p></li><li><p>友情链接</p></li><li><p>对方一定要是正规网站，每天有专业的团队或者个人维护更新</p></li><li><p>内链的布置</p></li><li><p>使网站形成类似蜘蛛网的结构，不会出现单独连接的页面或链接</p></li><li><p>流量分析</p></li><li><p>通过统计工具(百度统计，CNZZ)分析流量来源，指导下一步的SEO</p></li></ul><h2 id="存储相关"><a href="#存储相关" class="headerlink" title="存储相关"></a>存储相关</h2><h3 id="浏览器本地存储"><a href="#浏览器本地存储" class="headerlink" title="浏览器本地存储"></a>浏览器本地存储</h3><ul><li><p>在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了localStorage来取代globalStorage</p></li><li><p>html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage</p></li><li><p>sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储</p></li><li><p>而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的</p></li></ul><h3 id="web-storage和cookie的区别"><a href="#web-storage和cookie的区别" class="headerlink" title="web storage和cookie的区别**"></a>web storage和cookie的区别**</h3><ul><li><p>Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用</p></li><li><p>除此之外，WebStorage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie</p></li><li><p>但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生</p></li><li><p>浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage</p></li><li><p>localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等</p></li></ul><h3 id="cookie-和session-的区别："><a href="#cookie-和session-的区别：" class="headerlink" title="cookie 和session 的区别："></a>cookie 和session 的区别：</h3><ul><li><code>session</code>： 是一个抽象概念，开发者为了实现中断和继续等操作，将 <code>user agent</code>和 <code>server</code> 之间一对一的交互，抽象为“会话”，进而衍生出“会话状态”，也就是 <code>session</code> 的概念</li><li><code>cookie</code>：它是一个世纪存在的东西，<code>http</code> 协议中定义在 <code>header</code> 中的字段，可以认为是 <code>session</code> 的一种后端无状态实现</li></ul><blockquote><p>现在我们常说的 <code>session</code>，是为了绕开 <code>cookie</code> 的各种限制，通常借助 <code>cookie</code>本身和后端存储实现的，一种更高级的会话状态实现</p></blockquote><p><code>session</code> 的常见实现要借助<code>cookie</code>来发送 <code>sessionID</code></p><ul><li><p>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</p></li><li><p>2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗</p><ul><li>考虑到安全应当使用session。</li></ul></li><li><p>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能</p><ul><li>考虑到减轻服务器性能方面，应当使用COOKIE。</li></ul></li><li><p>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p></li><li><p>5、所以个人建议：</p><ul><li>将登陆信息等重要信息存放为SESSION</li><li>其他信息如果需要保留，可以放在COOKIE中</li></ul></li></ul><h3 id="描述-cookies、sessionStorage-和-localStorage-的区别？"><a href="#描述-cookies、sessionStorage-和-localStorage-的区别？" class="headerlink" title="描述 cookies、sessionStorage 和 localStorage 的区别？"></a>描述 cookies、sessionStorage 和 localStorage 的区别？</h3><ul><li><p>与服务器交互：</p><ul><li>cookie 是网站为了标示用户身份而储存在用户本地终端上的数据（通常经过加密）</li><li>cookie 始终会在同源 http 请求头中携带（即使不需要），在浏览器和服务器间来回传递</li><li>sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存</li></ul></li><li><p>存储大小：</p></li><li><p>cookie 数据根据不同浏览器限制，大小一般不能超过 4k</p></li><li><p>sessionStorage 和 localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</p></li><li><p>有期时间：</p><ul><li>localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据</li></ul></li><li><p>sessionStorage  数据在当前浏览器窗口关闭后自动删除</p><ul><li>cookie   设置的cookie过期时间之前一直有效，与浏览器是否关闭无关</li></ul></li></ul><h3 id="谈谈Cookie的弊端"><a href="#谈谈Cookie的弊端" class="headerlink" title="谈谈Cookie的弊端"></a>谈谈Cookie的弊端</h3><p>cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的</p><ul><li>1.每个特定的域名下最多生成20个cookie， 个数有限制（IE6或更低版本最多20个cookie）</li><li>2.Firefox、IE7和之后的版本最后可以有50个cookie，chrome和Safari没有做硬性限制</li><li>3.IE 和 Opera 会清理近期最少使用的 cookie，Firefox 会随机清理 cookie</li><li>4.cookie 的最大大约为 4096 字节，为了兼容性，一般设置不超过 4095 字节</li><li>5.如果 cookie 被人拦截了，就可以取得所有的 session 信息</li></ul><h2 id="重构相关"><a href="#重构相关" class="headerlink" title="重构相关"></a>重构相关</h2><h3 id="谈谈你对重构的理解"><a href="#谈谈你对重构的理解" class="headerlink" title="谈谈你对重构的理解"></a>谈谈你对重构的理解</h3><ul><li>网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化， 在扩展的同时保持一致的UI</li><li>对于传统的网站来说重构通常是：<ul><li>表格(table)布局改为DIV+CSS</li><li>使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)</li><li>对于移动平台的优化</li><li>针对于SEO进行优化</li><li>深层次的网站重构应该考虑的方面</li></ul></li></ul><h3 id="页面重构怎么操作？"><a href="#页面重构怎么操作？" class="headerlink" title="页面重构怎么操作？**"></a>页面重构怎么操作？**</h3><ul><li>网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI</li><li>对于传统的网站来说重构通常可以考虑的方面是：<ul><li>升级第三方依赖</li><li>使用HTML5、CSS3、ES6 新特性</li><li>加入响应式布局</li><li>统一代码风格规范</li><li>减少代码间的耦合</li><li>压缩/合并JS、CSS、image等静态资源(通常是由服务器来解决)</li><li>程序的性能优化</li><li>采用CDN来加速资源加载</li><li>对于JS DOM的优化</li><li>HTTP服务器的文件缓存</li><li>表格(table)布局改为DIV+CSS</li><li>使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)</li><li>对于移动平台的优化</li><li>针对于SEO进行优化</li><li>深层次的网站重构应该考虑的方面</li><li>让代码保持弹性</li><li>严格按规范编写代码</li><li>设计可扩展的API</li><li>代替旧有的框架、语言(如VB)</li><li>增强用户体验</li><li>通常来说对于速度的优化也包含在重构中</li></ul></li></ul><h2 id="前端相关"><a href="#前端相关" class="headerlink" title="前端相关"></a>前端相关</h2><h3 id="前端页面有哪三层构成，分别是什么？作用是什么？"><a href="#前端页面有哪三层构成，分别是什么？作用是什么？" class="headerlink" title="前端页面有哪三层构成，分别是什么？作用是什么？"></a>前端页面有哪三层构成，分别是什么？作用是什么？</h3><ul><li>结构层：由 (X)HTML 标记语言负责，解决页面“内容是什么”的问题</li><li>表示层：由 CSS 负责，解决页面“如何显示内容”的问题</li><li>行为层：由 JS 脚本负责，解决页面上“内容应该如何对事件作出反应”的问题</li></ul><h3 id="Web-前端开发的注意事项？"><a href="#Web-前端开发的注意事项？" class="headerlink" title="Web 前端开发的注意事项？"></a>Web 前端开发的注意事项？</h3><ul><li>特别设置 meta 标签 viewport</li><li>百分比布局宽度，结合 box-sizing: border-box;</li><li>使用 rem 作为计算单位。rem 只参照跟节点 html 的字体大小计算</li><li>使用 css3 新特性。弹性盒模型、多列布局、媒体查询等</li><li>多机型、多尺寸、多系统覆盖测试</li></ul><h3 id="说说你对前端架构师的理解"><a href="#说说你对前端架构师的理解" class="headerlink" title="说说你对前端架构师的理解"></a>说说你对前端架构师的理解</h3><p>负责前端团队的管理及与其他团队的协调工作，提升团队成员能力和整体效率；带领团队完成研发工具及平台前端部分的设计、研发和维护； 带领团队进行前端领域前沿技术研究及新技术调研，保证团队的技术领先负责前端开发规范制定、功能模块化设计、公共组件搭建等工作，并组织培训</p><h3 id="平时如何管理你的项目？"><a href="#平时如何管理你的项目？" class="headerlink" title="平时如何管理你的项目？"></a>平时如何管理你的项目？</h3><ul><li>规定全局样式、公共脚本</li><li>严格要求代码注释(html/js/css)</li><li>严格要求静态资源存放路径</li><li>Git 提交必须填写说明</li></ul><h3 id="说说最近最流行的一些东西吧？"><a href="#说说最近最流行的一些东西吧？" class="headerlink" title="说说最近最流行的一些东西吧？"></a>说说最近最流行的一些东西吧？</h3><p>ES6、Node、React、Webpack</p><h3 id="什么样的前端代码是好的"><a href="#什么样的前端代码是好的" class="headerlink" title="什么样的前端代码是好的"></a>什么样的前端代码是好的</h3><p>高复用低耦合，这样文件小，好维护，而且好扩展。</p><h2 id="移动端相关"><a href="#移动端相关" class="headerlink" title="移动端相关"></a>移动端相关</h2><h3 id="你怎么看待-Web-App-hybrid-App-Native-App？（移动端前端-和-Web-前端区别？）"><a href="#你怎么看待-Web-App-hybrid-App-Native-App？（移动端前端-和-Web-前端区别？）" class="headerlink" title="你怎么看待 Web App/hybrid App/Native App？（移动端前端 和 Web 前端区别？）"></a>你怎么看待 Web App/hybrid App/Native App？（移动端前端 和 Web 前端区别？）</h3><ul><li>Web App(HTML5)：采用HTML5生存在浏览器中的应用，不需要下载安装<ul><li>优点：开发成本低，迭代更新容易，不需用户升级，跨多个平台和终端</li><li>缺点：消息推送不够及时，支持图形和动画效果较差，功能使用限制（相机、GPS等）</li></ul></li><li>Hybrid App(混合开发)：UI WebView，需要下载安装<ul><li>优点：接近 Native App 的体验，部分支持离线功能</li><li>缺点：性能速度较慢，未知的部署时间，受限于技术尚不成熟</li></ul></li><li>Native App(原生开发)：依托于操作系统，有很强的交互，需要用户下载安装使用<ul><li>优点：用户体验完美，支持离线工作，可访问本地资源（通讯录，相册）</li><li>缺点：开发成本高（多系统），开发成本高（版本更新），需要应用商店的审核</li></ul></li></ul><h3 id="在设计-Web-APP-时，应当遵循以下几点"><a href="#在设计-Web-APP-时，应当遵循以下几点" class="headerlink" title="在设计 Web APP 时，应当遵循以下几点"></a>在设计 Web APP 时，应当遵循以下几点</h3><ul><li>简化不重要的动画/动效/图形文字样式</li><li>少用手势，避免与浏览器手势冲突</li><li>减少页面内容，页面跳转次数，尽量在当前页面显示</li><li>增强 Loading 趣味性，增强页面主次关系</li></ul><h3 id="移动端（Android、IOS）怎么做好用户体验"><a href="#移动端（Android、IOS）怎么做好用户体验" class="headerlink" title="移动端（Android、IOS）怎么做好用户体验?"></a>移动端（Android、IOS）怎么做好用户体验?</h3><ul><li>清晰的视觉纵线</li><li>信息的分组、极致的减法</li><li>利用选择代替输入</li><li>标签及文字的排布方式</li><li>依靠明文确认密码</li><li>合理的键盘利用</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="如何设计突发大规模并发架构？"><a href="#如何设计突发大规模并发架构？" class="headerlink" title="如何设计突发大规模并发架构？"></a>如何设计突发大规模并发架构？</h3><ul><li>及时响应(NoSQL缓存)</li><li>数据安全(数据备份)</li><li>负载均衡</li></ul><h3 id="列举IE与其他浏览器不一样的特性？"><a href="#列举IE与其他浏览器不一样的特性？" class="headerlink" title="列举IE与其他浏览器不一样的特性？"></a>列举IE与其他浏览器不一样的特性？</h3><ul><li>IE 的渲染引擎是 Trident 与 W3C 标准差异较大：例如盒子模型的怪异模式</li><li>JS 方面有很多独立的方法，例如事件处理不同：绑定/删除事件，阻止冒泡，阻止默认事件等</li><li>CSS 方面也有自己独有的处理方式，例如设置透明，低版本IE中使用滤镜的方式</li></ul><h3 id="是否了解公钥加密和私钥加密？"><a href="#是否了解公钥加密和私钥加密？" class="headerlink" title="是否了解公钥加密和私钥加密？"></a>是否了解公钥加密和私钥加密？</h3><ul><li>私钥用于对数据进行签名，公钥用于对签名进行验证</li><li>网站在浏览器端用公钥加密敏感数据，然后在服务器端再用私钥解密</li></ul><h3 id="WEB应用从服务器主动推送Data到客户端有那些方式？"><a href="#WEB应用从服务器主动推送Data到客户端有那些方式？" class="headerlink" title="WEB应用从服务器主动推送Data到客户端有那些方式？"></a>WEB应用从服务器主动推送Data到客户端有那些方式？</h3><ul><li>AJAX 轮询</li><li>html5 服务器推送事件<br><code>(new EventSource(SERVER_URL)).addEventListener(&quot;message&quot;, func);</code></li><li>html5 Websocket</li><li><code>(new WebSocket(SERVER_URL)).addEventListener(&quot;message&quot;, func);</code></li><li>不可见的iframe</li><li>WebSocket通过Flash</li><li>XHR长时间连接</li><li>XHR Multipart Streaming</li><li>script标签的长时间连接(可跨域)</li></ul><h3 id="列举IE与其他浏览器不一样的特性？-1"><a href="#列举IE与其他浏览器不一样的特性？-1" class="headerlink" title="列举IE与其他浏览器不一样的特性？"></a>列举IE与其他浏览器不一样的特性？</h3><p>事件不同之处：</p><ul><li>触发事件的元素被认为是目标（target）。而在 IE 中，目标包含在 event 对象的 srcElement 属性；</li><li>获取字符代码、如果按键代表一个字符（shift、ctrl、alt除外），IE 的 keyCode 会返回字符代码（Unicode），DOM 中按键的代码和字符是分离的，要获取字符代码，需要使用 charCode 属性；</li><li>阻止某个事件的默认行为，IE 中阻止某个事件的默认行为，必须将 returnValue 属性设置为 false，Mozilla 中，需要调用 preventDefault() 方法；</li><li>停止事件冒泡，IE 中阻止事件进一步冒泡，需要设置 cancelBubble 为 true，Mozzilla 中，需要调用 stopPropagation()</li></ul><h3 id="什么叫优雅降级和渐进增强？"><a href="#什么叫优雅降级和渐进增强？" class="headerlink" title="什么叫优雅降级和渐进增强？"></a>什么叫优雅降级和渐进增强？</h3><ul><li>优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用</li><li>渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。</li><li>如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验</li></ul><h3 id="一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）"><a href="#一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）" class="headerlink" title="一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）"></a>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）</h3><blockquote><p>注：这题胜在区分度高，知识点覆盖广，再不懂的人，也能答出几句，而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、 到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等</p></blockquote><ul><li><h4 id="详细版："><a href="#详细版：" class="headerlink" title="详细版："></a>详细版：</h4></li><li><p>1、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;</p></li><li><p>2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;</p></li><li><p>3、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;</p></li><li><p>4、进行HTTP协议会话，客户端发送报头(请求报头);</p></li><li><p>5、进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;</p></li><li><p>6、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;</p></li><li><p>7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;</p></li><li><p>8、浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;</p></li><li><p>9、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;</p></li><li><p>10、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。</p></li><li><h4 id="简洁版："><a href="#简洁版：" class="headerlink" title="简洁版："></a>简洁版：</h4><ul><li>浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；</li><li>服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；</li><li>浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；</li><li>载入解析到的资源文件，渲染页面，完成</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前端开发知识点&quot;&gt;&lt;a href=&quot;#前端开发知识点&quot; class=&quot;headerlink&quot; title=&quot;前端开发知识点&quot;&gt;&lt;/a&gt;前端开发知识点&lt;/h2&gt;&lt;h3 id=&quot;HTML-amp-CSS&quot;&gt;&lt;a href=&quot;#HTML-amp-CSS&quot; class=&quot;
      
    
    </summary>
    
      <category term="前端面试题" scheme="http://www.bluedream.top/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="知识点" scheme="http://www.bluedream.top/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
      <category term="前端技能" scheme="http://www.bluedream.top/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E8%83%BD/"/>
    
      <category term="PS" scheme="http://www.bluedream.top/tags/PS/"/>
    
      <category term="Git" scheme="http://www.bluedream.top/tags/Git/"/>
    
      <category term="SEO" scheme="http://www.bluedream.top/tags/SEO/"/>
    
      <category term="存储" scheme="http://www.bluedream.top/tags/%E5%AD%98%E5%82%A8/"/>
    
      <category term="重构" scheme="http://www.bluedream.top/tags/%E9%87%8D%E6%9E%84/"/>
    
      <category term="前端" scheme="http://www.bluedream.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="移动端" scheme="http://www.bluedream.top/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>welcome</title>
    <link href="http://www.bluedream.top/%E5%85%B6%E4%BB%96/welcome.html"/>
    <id>http://www.bluedream.top/其他/welcome.html</id>
    <published>2019-08-25T10:26:47.000Z</published>
    <updated>2019-09-12T14:21:32.391Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="http://www.bluedream.top/">QinWei‘s blog</a>!</p><p>本博客有以下八个分类：</p><ul><li>前端知识点</li><li>全栈知识点</li><li>前端面试题</li><li>全栈面试题</li><li>链接</li><li>随笔</li><li>散文</li><li>其他</li></ul><p>This is my first post.If you have any problems in using this website , you can contact me by QQ： <u><em>124729081</em></u> or  Wechat：<u><em>qwqw75</em></u>. </p><a id="more"></a><p>This website is built using<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>, and here are some brief introduction.</p><h3 id="文件夹目录"><a href="#文件夹目录" class="headerlink" title="文件夹目录"></a>文件夹目录</h3><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li>_config.yml: 博客的配置文件</li></ul><h3 id="Create-a-new-post（新建日志）"><a href="#Create-a-new-post（新建日志）" class="headerlink" title="Create a new post（新建日志）"></a>Create a new post（新建日志）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server（运行服务）"><a href="#Run-server（运行服务）" class="headerlink" title="Run server（运行服务）"></a>Run server（运行服务）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>使用ctrl+c可以把服务关掉。</p><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files（生成静态文件）"><a href="#Generate-static-files（生成静态文件）" class="headerlink" title="Generate static files（生成静态文件）"></a>Generate static files（生成静态文件）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites（部署到远程站点）"><a href="#Deploy-to-remote-sites（部署到远程站点）" class="headerlink" title="Deploy to remote sites（部署到远程站点）"></a>Deploy to remote sites（部署到远程站点）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><h3 id="更改样式后网站没有生效"><a href="#更改样式后网站没有生效" class="headerlink" title="更改样式后网站没有生效"></a>更改样式后网站没有生效</h3><p>确认非缓存问题后，执行 <code>hexo clean</code> 再进行生成上传。</p><p>清理之前在public文件夹中生成的文件</p><h3 id="如何在文章中使用图标"><a href="#如何在文章中使用图标" class="headerlink" title="如何在文章中使用图标"></a>如何在文章中使用图标</h3><p>先到 <a href="http://fontawesome.io/icons/" target="_blank" rel="noopener">fontawesome</a> 找到你需要的图标名，比如：<code>book</code>，按以下格式使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;i class=&quot;icon icon-book&quot;&gt;&lt;/i&gt;</span><br></pre></td></tr></table></figure><p>图标样式前缀均为 <code>icon</code>，此外还有 5 个图标大小调节类和 1 个间距类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 1.3倍大小 --&gt;</span><br><span class="line">&lt;i class=&quot;icon icon-book icon-lg&quot;&gt;&lt;/i&gt;</span><br><span class="line">&lt;!-- 2倍大小 --&gt;</span><br><span class="line">&lt;i class=&quot;icon icon-book icon-2x&quot;&gt;&lt;/i&gt;</span><br><span class="line">&lt;!-- 3倍大小 --&gt;</span><br><span class="line">&lt;i class=&quot;icon icon-book icon-3x&quot;&gt;&lt;/i&gt;</span><br><span class="line">&lt;!-- 4倍大小 --&gt;</span><br><span class="line">&lt;i class=&quot;icon icon-book icon-4x&quot;&gt;&lt;/i&gt;</span><br><span class="line">&lt;!-- 5倍大小 --&gt;</span><br><span class="line">&lt;i class=&quot;icon icon-book icon-5x&quot;&gt;&lt;/i&gt;</span><br><span class="line">&lt;!-- 5px右边距 --&gt;</span><br><span class="line">&lt;i class=&quot;icon icon-book icon-pr&quot;&gt;&lt;/i&gt;</span><br><span class="line">&lt;!-- 5px左边距 --&gt;</span><br><span class="line">&lt;i class=&quot;icon icon-book icon-pl&quot;&gt;&lt;/i&gt;</span><br></pre></td></tr></table></figure><h3 id="个别图标无法显示"><a href="#个别图标无法显示" class="headerlink" title="个别图标无法显示"></a>个别图标无法显示</h3><p>如果你的浏览器安装了 ADBlock，它会屏蔽 SNS 相关的内容，比如：Github。</p><p>解决办法：可配置 ADBlock 不在你的站点运行。</p><p><strong>作者：秦伟</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;http://www.bluedream.top/&quot;&gt;QinWei‘s blog&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;本博客有以下八个分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前端知识点&lt;/li&gt;
&lt;li&gt;全栈知识点&lt;/li&gt;
&lt;li&gt;前端面试题&lt;/li&gt;
&lt;li&gt;全栈面试题&lt;/li&gt;
&lt;li&gt;链接&lt;/li&gt;
&lt;li&gt;随笔&lt;/li&gt;
&lt;li&gt;散文&lt;/li&gt;
&lt;li&gt;其他&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is my first post.If you have any problems in using this website , you can contact me by QQ： &lt;u&gt;&lt;em&gt;124729081&lt;/em&gt;&lt;/u&gt; or  Wechat：&lt;u&gt;&lt;em&gt;qwqw75&lt;/em&gt;&lt;/u&gt;. &lt;/p&gt;
    
    </summary>
    
      <category term="其他" scheme="http://www.bluedream.top/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="欢迎" scheme="http://www.bluedream.top/tags/%E6%AC%A2%E8%BF%8E/"/>
    
      <category term="介绍" scheme="http://www.bluedream.top/tags/%E4%BB%8B%E7%BB%8D/"/>
    
      <category term="Hexo" scheme="http://www.bluedream.top/tags/Hexo/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秦伟博客</title>
  
  <subtitle>前端、全栈、SEO的知识点、面试题与学习链接的整理</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://qw66.gitee.io/"/>
  <updated>2024-05-10T09:10:43.336Z</updated>
  <id>https://qw66.gitee.io/</id>
  
  <author>
    <name>秦伟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>自定义表格列</title>
    <link href="https://qw66.gitee.io//articles/zi-ding-yi-biao-ge-lie.html"/>
    <id>https://qw66.gitee.io//articles/zi-ding-yi-biao-ge-lie.html</id>
    <published>2024-05-10T16:00:00.000Z</published>
    <updated>2024-05-10T09:10:43.336Z</updated>
    
    <content type="html"><![CDATA[<h3 id="element-ui-vue2怎么实现根据用户自定义缓存设置-是否显示表格的某列"><a href="#element-ui-vue2怎么实现根据用户自定义缓存设置-是否显示表格的某列" class="headerlink" title="element ui vue2怎么实现根据用户自定义缓存设置 是否显示表格的某列"></a>element ui vue2怎么实现根据用户自定义缓存设置 是否显示表格的某列</h3><p>在 Element UI（用于 Vue.js 的组件库）中，如果你想根据用户的自定义缓存设置来决定是否显示表格的某列，你可以通过以下步骤实现：</p><ol><li><strong>存储用户设置</strong>：首先，你需要一种方式来存储用户的设置。这可以是 localStorage、Cookies、Vuex 状态管理或者其他后端存储方式。</li><li><strong>读取用户设置</strong>：在组件加载时，读取用户的设置。</li><li><strong>动态渲染表格列</strong>：基于用户的设置，动态地渲染表格的列。</li></ol><p>以下是一个基本的实现示例：</p><h3 id="1-假设你有一个用于存储用户设置的变量"><a href="#1-假设你有一个用于存储用户设置的变量" class="headerlink" title="1. 假设你有一个用于存储用户设置的变量"></a>1. 假设你有一个用于存储用户设置的变量</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设这是从 localStorage 或其他地方读取的用户设置  </span></span><br><span class="line"><span class="keyword">let</span> userSettings = &#123;  </span><br><span class="line">  showColumnA: <span class="literal">true</span>,  </span><br><span class="line">  showColumnB: <span class="literal">false</span>,  </span><br><span class="line">  <span class="comment">// ... 其他列的设置  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-在-Vue-组件中，根据这些设置动态渲染列"><a href="#2-在-Vue-组件中，根据这些设置动态渲染列" class="headerlink" title="2. 在 Vue 组件中，根据这些设置动态渲染列"></a>2. 在 Vue 组件中，根据这些设置动态渲染列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  </span><br><span class="line">  &lt;el-table :data=&quot;tableData&quot;&gt;  </span><br><span class="line">    &lt;el-table-column v-if=&quot;userSettings.showColumnA&quot; prop=&quot;columnA&quot; label=&quot;Column A&quot;&gt;&lt;/el-table-column&gt;  </span><br><span class="line">    &lt;el-table-column v-if=&quot;userSettings.showColumnB&quot; prop=&quot;columnB&quot; label=&quot;Column B&quot;&gt;&lt;/el-table-column&gt;  </span><br><span class="line">    &lt;!-- ... 其他列 --&gt;  </span><br><span class="line">  &lt;/el-table&gt;  </span><br><span class="line">&lt;/template&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;script&gt;  </span><br><span class="line">export default &#123;  </span><br><span class="line">  data() &#123;  </span><br><span class="line">    return &#123;  </span><br><span class="line">      tableData: [  </span><br><span class="line">        // ... 你的表格数据  </span><br><span class="line">      ],  </span><br><span class="line">      userSettings: &#123;  </span><br><span class="line">        // 这里应该根据你的应用逻辑来初始化或读取用户设置  </span><br><span class="line">        showColumnA: true,  </span><br><span class="line">        showColumnB: false,  </span><br><span class="line">        // ... 其他列的设置  </span><br><span class="line">      &#125;,  </span><br><span class="line">    &#125;;  </span><br><span class="line">  &#125;,  </span><br><span class="line">  // ... 其他选项和方法  </span><br><span class="line">&#125;;  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="3-读取和更新用户设置"><a href="#3-读取和更新用户设置" class="headerlink" title="3. 读取和更新用户设置"></a>3. 读取和更新用户设置</h3><p>你可能需要提供一种方式来让用户更新这些设置，并将它们保存回存储中。这可以通过表单、对话框或其他 UI 元素来实现。当用户更新设置时，你应该更新 <code>userSettings</code> 对象，并可能还需要将这些更改保存回 localStorage 或其他存储中。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul><li>确保你的表格数据（<code>tableData</code>）中的属性与你在 <code>el-table-column</code> 中使用的 <code>prop</code> 属性匹配。</li><li>如果你使用的是 Vuex 或其他状态管理库，你可能需要将 <code>userSettings</code> 保存在 Vuex store 中，并在需要时从 store 中读取它们。</li><li>当用户更改设置时，你可能需要触发一个事件或调用一个方法来更新你的 UI 和/或保存更改到存储中。</li></ul><h3 id="如果el-table-column是通过v-for循环出来的，应该怎么处理"><a href="#如果el-table-column是通过v-for循环出来的，应该怎么处理" class="headerlink" title="如果el-table-column是通过v-for循环出来的，应该怎么处理"></a>如果el-table-column是通过v-for循环出来的，应该怎么处理</h3><p>如果 <code>el-table-column</code> 是通过 <code>v-for</code> 循环动态生成的，你可以根据用户设置来决定是否渲染每一列。这通常涉及到在循环中检查用户设置来确定是否包含某个列。</p><p>以下是一个例子，展示如何根据用户设置使用 <code>v-for</code> 来动态生成 <code>el-table-column</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  </span><br><span class="line">  &lt;el-table :data=&quot;tableData&quot;&gt;  </span><br><span class="line">    &lt;el-table-column  </span><br><span class="line">      v-for=&quot;(column, index) in columns&quot;  </span><br><span class="line">      :key=&quot;index&quot;  </span><br><span class="line">      :prop=&quot;column.prop&quot;  </span><br><span class="line">      :label=&quot;column.label&quot;  </span><br><span class="line">      v-if=&quot;userSettings[column.key] || userSettings[column.key] === undefined&quot;  </span><br><span class="line">    &gt;&lt;/el-table-column&gt;  </span><br><span class="line">  &lt;/el-table&gt;  </span><br><span class="line">&lt;/template&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;script&gt;  </span><br><span class="line">export default &#123;  </span><br><span class="line">  data() &#123;  </span><br><span class="line">    return &#123;  </span><br><span class="line">      tableData: [  </span><br><span class="line">        // ... 你的表格数据  </span><br><span class="line">      ],  </span><br><span class="line">      columns: [  </span><br><span class="line">        &#123; prop: &apos;columnA&apos;, label: &apos;Column A&apos;, key: &apos;showColumnA&apos; &#125;,  </span><br><span class="line">        &#123; prop: &apos;columnB&apos;, label: &apos;Column B&apos;, key: &apos;showColumnB&apos; &#125;,  </span><br><span class="line">        // ... 其他列配置  </span><br><span class="line">      ],  </span><br><span class="line">      userSettings: &#123;  </span><br><span class="line">        // 假设这是从 localStorage 或其他地方读取的用户设置  </span><br><span class="line">        // 默认为 undefined，表示未明确设置是否显示该列  </span><br><span class="line">        // 可以设置 true 或 false 来控制列的显示与隐藏  </span><br><span class="line">        showColumnA: true,  </span><br><span class="line">        showColumnB: false,  </span><br><span class="line">        // ... 其他列的设置  </span><br><span class="line">      &#125;,  </span><br><span class="line">    &#125;;  </span><br><span class="line">  &#125;,  </span><br><span class="line">  // ... 其他选项和方法  </span><br><span class="line">&#125;;  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>columns</code> 数组包含了表格列的配置，每个对象都有一个 <code>key</code> 属性，这个属性与 <code>userSettings</code> 中的键对应。<code>v-if</code> 指令检查 <code>userSettings[column.key]</code> 的值来确定是否渲染该列。</p><p>注意，我添加了 <code>|| userSettings[column.key] === undefined</code> 的条件，这是为了处理那些用户尚未明确设置是否显示的列（即 <code>userSettings</code> 中没有该键）。如果你希望用户必须明确设置每一列的显示状态，你可以去掉这个条件。</p><p>此外，确保 <code>userSettings</code> 中的键与 <code>columns</code> 数组中每个对象的 <code>key</code> 属性相匹配。这样，你就可以通过修改 <code>userSettings</code> 来控制哪些列应该被渲染。</p><h3 id="哪个elementui项目支持列设置"><a href="#哪个elementui项目支持列设置" class="headerlink" title="哪个elementui项目支持列设置"></a>哪个elementui项目支持列设置</h3><p>Element UI 本身并没有直接提供一个支持列设置的现成项目，但你可以通过封装 Element UI 的表格组件（``）来实现列设置的功能。这通常涉及到以下几个步骤：</p><ol><li><strong>封装 <code>el-table</code> 组件</strong>：你可以创建一个自定义的 Vue 组件，该组件内部使用 <code>el-table</code> 并添加一些额外的逻辑来处理列设置。</li><li><strong>定义列设置数据</strong>：在你的 Vue 组件中，你需要定义一些数据来存储列的设置信息，例如哪些列是可见的，哪些列是固定的等。</li><li><strong>动态渲染列</strong>：使用 <code>v-for</code> 指令来根据列设置数据动态地渲染表格的列。你可以检查每个列的设置来决定是否渲染它。</li><li><strong>提供列设置界面</strong>：你可能需要创建一个界面来允许用户更改列的设置。这可以是一个对话框、侧边栏或其他任何适合你的应用的界面。</li><li><strong>处理列设置更改</strong>：当用户更改列设置时，你需要更新你的列设置数据，并重新渲染表格以反映这些更改。</li></ol><p>这里有一些具体的实现技巧：</p><ul><li><strong>使用 Vuex 或其他状态管理库</strong>：如果你的应用已经使用了 Vuex 或其他状态管理库，你可以将列设置数据存储在 Vuex store 中，并在需要时从 store 中读取和更新它。</li><li><strong>使用计算属性（Computed Properties）</strong>：如果你的列设置数据会影响表格的渲染方式，你可以使用计算属性来根据列设置数据计算出一个新的渲染列表。</li><li><strong>自定义列模板</strong>：你可以使用 Element UI 的 ` 功能来为每个列定义自定义的模板。这允许你根据列的数据和设置来显示不同的内容。</li></ul><p>请注意，具体的实现方式会根据你的应用需求和设计而有所不同。你可能需要根据你的具体情况来调整上述步骤和技巧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;element-ui-vue2怎么实现根据用户自定义缓存设置-是否显示表格的某列&quot;&gt;&lt;a href=&quot;#element-ui-vue2怎么实现根据用户自定义缓存设置-是否显示表格的某列&quot; class=&quot;headerlink&quot; title=&quot;element ui v
      
    
    </summary>
    
      <category term="前端文章" scheme="https://qw66.gitee.io/categories/%E5%89%8D%E7%AB%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="vue" scheme="https://qw66.gitee.io/tags/vue/"/>
    
      <category term="表格" scheme="https://qw66.gitee.io/tags/%E8%A1%A8%E6%A0%BC/"/>
    
  </entry>
  
  <entry>
    <title>qiankun项目搭建</title>
    <link href="https://qw66.gitee.io//knowledges/qiankun-xiang-mu-da-jian.html"/>
    <id>https://qw66.gitee.io//knowledges/qiankun-xiang-mu-da-jian.html</id>
    <published>2024-04-28T02:02:08.000Z</published>
    <updated>2024-04-30T10:15:43.908Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基座配置"><a href="#基座配置" class="headerlink" title="基座配置"></a>基座配置</h3><blockquote><p>基座采用是的 Vue3 + vite + ts，只负责导航的渲染和登录态的下发，为子应用提供一个挂载的容器div</p><p>qiankun这个库只需要在基座引入</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i qiankun</span><br></pre></td></tr></table></figure><p>在main.ts 中注册子应用，为了方便管理，我们将子应用的配置都放在：/utils/qiankun.ts下 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">import &#123; registerMicroApps, addGlobalUncaughtErrorHandler, start &#125; from &apos;qiankun&apos;;</span><br><span class="line">import router from &apos;./router&apos;</span><br><span class="line">// 注册子应用</span><br><span class="line">registerMicroApps([</span><br><span class="line">  &#123;</span><br><span class="line">    // 子应用名称，name值必须与子应用vite.config.ts文件中plugins属性qiankun的第一个参数值一致</span><br><span class="line">    name: &apos;subApp&apos;,</span><br><span class="line">    // 默认会加载这个路径下的html，解析里面的js</span><br><span class="line">    entry: &apos;//localhost:5050/&apos;,</span><br><span class="line">    // 加载的容器（微应用会显示到这个容器里面，一定要保证主应用中有这个容器）</span><br><span class="line">    container: &apos;#subAppContainerVue3&apos;,  // 和app.vue配置的节点一致</span><br><span class="line">    // 匹配的路由</span><br><span class="line">    activeRule: &apos;/gosubsystem&apos;, // 访问：http://localhost:5174/juminronghe</span><br><span class="line">    props: &#123;</span><br><span class="line">        mag: &apos;我是主应用main&apos;, // 主应用向微应用传递参数</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    // 子应用名称，name值必须与子应用vite.config.ts文件中plugins属性qiankun的第一个参数值一致</span><br><span class="line">    name: &apos;lmsApp&apos;,</span><br><span class="line">    // 默认会加载这个路径下的html，解析里面的js</span><br><span class="line">    entry: &apos;//localhost:5000/&apos;,</span><br><span class="line">    // 加载的容器（微应用会显示到这个容器里面，一定要保证主应用中有这个容器）</span><br><span class="line">    container: &apos;#subAppContainerVue3&apos;,  // 和app.vue配置的节点一致</span><br><span class="line">    // 匹配的路由</span><br><span class="line">    activeRule: &apos;/lmsApp&apos;, </span><br><span class="line">    props: &#123;</span><br><span class="line">        mag: &apos;我是主应用main&apos;, // 主应用向微应用传递参数</span><br><span class="line">        router    // 主路由下发到子路由，子应用路由跳转使用主应用路由实例跳转（需要跳转的路由要在主应用里注册）</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">],</span><br><span class="line">&#123;</span><br><span class="line">  beforeLoad: app =&gt; &#123;</span><br><span class="line">    console.log(&apos;before load app.name====&gt;&gt;&gt;&gt;&gt;&apos;, app.name)</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeMount: [</span><br><span class="line">    app =&gt; &#123;</span><br><span class="line">      console.log(&apos;[LifeCycle] before mount %c%s&apos;, &apos;color: green;&apos;, app.name);</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  afterMount: [</span><br><span class="line">    app =&gt; &#123;</span><br><span class="line">      console.log(&apos;[LifeCycle] after mount %c%s&apos;, &apos;color: green;&apos;, app.name);</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  afterUnmount: [</span><br><span class="line">    app =&gt; &#123;</span><br><span class="line">      console.log(&apos;[LifeCycle] after unmount %c%s&apos;, &apos;color: green;&apos;, app.name);</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br><span class="line">// 启动 qiankun</span><br><span class="line">// start(&#123;</span><br><span class="line">//     prefetch:&apos;all&apos;, // 预加载</span><br><span class="line">//     sandbox: &#123;</span><br><span class="line">//         experimentalStyleIsolation: true, //   开启沙箱模式,实验性方案</span><br><span class="line">//     &#125;,</span><br><span class="line">// &#125;);</span><br><span class="line">// 添加全局异常捕获</span><br><span class="line">addGlobalUncaughtErrorHandler((event) =&gt; &#123;</span><br><span class="line">  // console.error(event);</span><br><span class="line">  const &#123; message: msg &#125; = event;</span><br><span class="line">  // 加载失败时提示</span><br><span class="line">  if (msg &amp;&amp; msg.includes(&quot;died in status LOADING_SOURCE_CODE&quot;)) &#123;</span><br><span class="line">    // message.error(&quot;微应用加载失败，请检查应用是否可运行&quot;);</span><br><span class="line">    console.log(&quot;微应用加载失败，请检查应用是否可运行-乾坤插件是否正常&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后在src/main.ts中引入 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &apos;./utils/qiankun.ts&apos;</span><br></pre></td></tr></table></figure><h3 id="如何在主应用的某个路由页面加载微应用"><a href="#如何在主应用的某个路由页面加载微应用" class="headerlink" title="如何在主应用的某个路由页面加载微应用"></a>如何在主应用的某个路由页面加载微应用</h3><blockquote><p>必须保证微应用加载时主应用这个路由页面也加载了<br>主应用注册这个路由时给 path 加一个 *，注意：如果这个路由有其他子路由，需要另外注册一个路由，仍然使用这个组件即可</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   path: &apos;/portal/*&apos;,</span><br><span class="line">   name: &apos;portal&apos;,</span><br><span class="line">   component: () =&gt; import(&apos;../views/Portal.vue&apos;),</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>Portal.vue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div id=&quot;subAppContainerVue3&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">  </span><br><span class="line">&lt;script lang=&quot;ts&quot; setup  name=&quot;merchantsRuquest&quot;&gt;</span><br><span class="line">// import start from &quot;@/qiankun/index.js&quot;;</span><br><span class="line">import &#123; start &#125; from &apos;qiankun&apos;</span><br><span class="line">// import &#123; registerApps &#125; from &apos;@/qiankun/index.js&apos;</span><br><span class="line">onMounted(()=&gt;&#123;</span><br><span class="line">    if (!window.qiankunStarted) &#123;</span><br><span class="line">            window.qiankunStarted = true</span><br><span class="line">            // registerApps()</span><br><span class="line">            start(&#123;</span><br><span class="line">                sandbox: &#123;</span><br><span class="line">                    experimentalStyleIsolation: true // 样式隔离</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// export default &#123;</span><br><span class="line">//     mounted() &#123;</span><br><span class="line">      </span><br><span class="line">//     &#125;</span><br><span class="line">// &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="主应用路由配置"><a href="#主应用路由配置" class="headerlink" title="主应用路由配置"></a>主应用路由配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">         path: &apos;/lmsApp/*&apos;,   // 注意和registerMicroApps 注册子应用的activeRule匹配</span><br><span class="line">         name: &apos;lmsApp&apos;,</span><br><span class="line">         meta: &#123;</span><br><span class="line">           title: &quot;子应用菜单管理&quot;,</span><br><span class="line">           icon: &quot;car-outlined&quot;,</span><br><span class="line">           isFull: false,</span><br><span class="line">           isKeepAlive: true,</span><br><span class="line">           isHide: false</span><br><span class="line">         &#125;,</span><br><span class="line">         children: [</span><br><span class="line">           &#123;</span><br><span class="line">             name: &apos;xxxxx&apos;,</span><br><span class="line">             path: &apos;/lmsApp/xxxx/xxxxx&apos;,</span><br><span class="line">             component: () =&gt; import(&apos;@/views/portal.vue&apos;),</span><br><span class="line">             meta: &#123;</span><br><span class="line">               title: &apos;子应用菜单下的二级菜单&apos;,</span><br><span class="line">               icon: &apos;&apos;,</span><br><span class="line">               isKeepAlive: false</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;,</span><br><span class="line">          </span><br><span class="line">         ]</span><br><span class="line">       &#125;,</span><br></pre></td></tr></table></figure><blockquote><p>这样，基座就算配置完成了。项目启动后，子应用将会挂载到主应用中</p></blockquote><h3 id="子应用配置"><a href="#子应用配置" class="headerlink" title="子应用配置"></a>子应用配置</h3><blockquote><p>安装vite-plugin-qiankun</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i vite-plugin-qiankun --save-dev</span><br><span class="line">或者</span><br><span class="line">yarn add vite-plugin-qiankun --dev</span><br></pre></td></tr></table></figure><p>修改vite.config.ts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 引入乾坤插件</span><br><span class="line">import qiankun from &apos;vite-plugin-qiankun&apos;</span><br><span class="line">plugins: [ vue(), qiankun(&apos;subApp&apos;, &#123; useDevMode: true &#125;) ],</span><br></pre></td></tr></table></figure><p>在子应用main.ts 里引用qiankun</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">  renderWithQiankun,</span><br><span class="line">  qiankunWindow,</span><br><span class="line">  type QiankunProps</span><br><span class="line">&#125; from &apos;vite-plugin-qiankun/dist/helper&apos;</span><br><span class="line">let app: any</span><br><span class="line"></span><br><span class="line">const render = (container?: any, routers?: any) =&gt; &#123;</span><br><span class="line">  app = createApp(App)</span><br><span class="line">  Object.keys(Icons).forEach((key) =&gt; &#123;</span><br><span class="line">    app.component(key, Icons[key as keyof typeof Icons])</span><br><span class="line">  &#125;)</span><br><span class="line">  app.use(pinia)</span><br><span class="line">  app.use(print)</span><br><span class="line">  app.use(Antd)</span><br><span class="line">  app.use(directives)</span><br><span class="line">  app.config.globalProperties.$routers = routers</span><br><span class="line">  app.use(router).mount(container ? container.querySelector(&apos;#app&apos;) : &apos;#app&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const initQianKun = () =&gt; &#123;</span><br><span class="line">  renderWithQiankun(&#123;</span><br><span class="line">    mount(props) &#123;</span><br><span class="line">      // localStorage.lalal = 111111</span><br><span class="line">      console.log(props.router, &apos;获取主应用传递数据&apos;)</span><br><span class="line">      sessionStorage.latoutStatus = false</span><br><span class="line">      const &#123; container, router &#125; = props</span><br><span class="line"></span><br><span class="line">      render(container, router)</span><br><span class="line">    &#125;,</span><br><span class="line">    bootstrap() &#123; &#125;,</span><br><span class="line">    unmount() &#123;</span><br><span class="line">      app.unmount()</span><br><span class="line">    &#125;,</span><br><span class="line">    update: function (props: QiankunProps): void | Promise&lt;void&gt; &#123;</span><br><span class="line">      throw new Error(&apos;Function not implemented.&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// console.log(qiankunWindow.__POWERED_BY_QIANKUN__, &apos;90&apos;)</span><br><span class="line">qiankunWindow.__POWERED_BY_QIANKUN__ ? initQianKun() : render()</span><br></pre></td></tr></table></figure><p>由于路由模式为history，需要匹配子应用的入口规则，修改src/router/index </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; qiankunWindow &#125; from &apos;vite-plugin-qiankun/dist/helper&apos;</span><br><span class="line">const router = createRouter(&#123;</span><br><span class="line">  history: createWebHistory(</span><br><span class="line">    qiankunWindow.__POWERED_BY_QIANKUN__</span><br><span class="line">      ? &apos;/lmsApp/&apos;</span><br><span class="line">      : &apos;/&apos;</span><br><span class="line">  ),</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="报错There-is-already-an-app-instance-mounted-on-the-host-container"><a href="#报错There-is-already-an-app-instance-mounted-on-the-host-container" class="headerlink" title="报错There is already an app instance mounted on the host container."></a>报错There is already an app instance mounted on the host container.</h4><p>因为是vue应用，子应用也有个id=”app”</p><p>全局搜索#app，改成#app1</p><h3 id="qiankun运行逻辑"><a href="#qiankun运行逻辑" class="headerlink" title="qiankun运行逻辑"></a>qiankun运行逻辑</h3><p>将主应用与子应用都运行起来后，由于主应用的main.js配置了registerMicroApps这个，里面是个数组，数组中一个对象代码一个子应用， name不太重要，运行逻辑如下：当在浏览器地址栏输入主应用的对应路由地址，主应用发现与activeRule的路由匹配上之后，会将此activeRule下的entry下跑的子应用界面渲染到container容器里（此容器我们之前写在了App.vue）<br>简单点说就是<br>主应用监听发现路由地址变化 （例如地址最后输入/son1）<br>主应用从main.js 的 registerMicroApps之中寻找对应匹配的规则地址<br>将此条规则的entry（这里填写的就是子应用目前跑在的地址），渲染到 container 下的容器里</p><p>原文链接：<a href="https://blog.csdn.net/weixin_45653441/article/details/134877301" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45653441/article/details/134877301</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基座配置&quot;&gt;&lt;a href=&quot;#基座配置&quot; class=&quot;headerlink&quot; title=&quot;基座配置&quot;&gt;&lt;/a&gt;基座配置&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;基座采用是的 Vue3 + vite + ts，只负责导航的渲染和登录态的下发，为子应用提供一个挂
      
    
    </summary>
    
      <category term="前端知识点" scheme="https://qw66.gitee.io/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="vue" scheme="https://qw66.gitee.io/tags/vue/"/>
    
      <category term="qiankun" scheme="https://qw66.gitee.io/tags/qiankun/"/>
    
  </entry>
  
  <entry>
    <title>vue项目模板</title>
    <link href="https://qw66.gitee.io//knowledges/vue-xiang-mu-mo-ban.html"/>
    <id>https://qw66.gitee.io//knowledges/vue-xiang-mu-mo-ban.html</id>
    <published>2024-04-28T01:02:08.000Z</published>
    <updated>2024-04-30T02:59:45.889Z</updated>
    
    <content type="html"><![CDATA[<h3 id="从零开始搭建企业级前端项目模板（vue3-vite-ts）"><a href="#从零开始搭建企业级前端项目模板（vue3-vite-ts）" class="headerlink" title="从零开始搭建企业级前端项目模板（vue3+vite+ts）"></a>从零开始搭建企业级前端项目模板（vue3+vite+ts）</h3><h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><blockquote><p>技术：vite，eslint，prettierrc，husky，commitlint，lint-staget，stylelint，vuex，vue-router，axios，pinia<br>环境：win11，node 18.17.0 ，pnpm 8.12.0</p></blockquote><h3 id="一、vite脚手架工具初始化项目"><a href="#一、vite脚手架工具初始化项目" class="headerlink" title="一、vite脚手架工具初始化项目"></a>一、vite脚手架工具初始化项目</h3><p>本文以pnpm创建项目，通过 npm 安装 pnpm</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g pnpm</span><br></pre></td></tr></table></figure><p>vite官网：<a href="https://cn.vitejs.dev/guide/" target="_blank" rel="noopener">初始化项目：https://cn.vitejs.dev/guide/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># npm 7+, extra double-dash is needed:</span><br><span class="line">npm create vite@latest vue3_project_template --template vue-ts</span><br><span class="line"></span><br><span class="line"># yarn</span><br><span class="line">yarn create vite vue3_project_template --template vue-ts</span><br><span class="line"></span><br><span class="line"># pnpm</span><br><span class="line">pnpm create vite vue3_project_template --template vue-ts</span><br><span class="line"></span><br><span class="line"># bun</span><br><span class="line">bunx create-vite vue3_project_template --template vue-ts</span><br></pre></td></tr></table></figure><ul><li>创建好项目</li><li>根据创建项目提示输入命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd vue3_project_template</span><br><span class="line">pnpm install</span><br><span class="line">pnpm run dev</span><br></pre></td></tr></table></figure><ul><li>运行结果如下<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/direct/675f4f3193e34857a41553e737b7f3ee.png" alt="在这里插入图片描述"></li></ul><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p>node_modules（npm 加载的项目依赖模块）</p><p>public（公共资源）</p><p>src（开发目录）</p><ul><li>assets（图片等文件）</li><li>components（组件）</li><li>router（路由）</li><li>store（vuex）</li><li>views（页面）</li><li>App.vue（核心页）</li><li>main.js（核心文件）</li></ul><p>.browserslistrc（这个配置能够分享目标浏览器和nodejs版本在不同的前端工具。这些工具能根据目标浏览器自动来进行配置）</p><p>.eslintrc.js（ESlint配置文件）</p><p>.gitignore（git配置文件）</p><p>babel.config.js（babel配置文件）</p><p>package-lock.json（依赖版本锁定）</p><p>package.json（项目信息及依赖信息）</p><p>README.md（项目介绍）</p><h3 id="二、项目代码加入eslint校验和自动格式化"><a href="#二、项目代码加入eslint校验和自动格式化" class="headerlink" title="二、项目代码加入eslint校验和自动格式化"></a>二、项目代码加入eslint校验和自动格式化</h3><blockquote><p><a href="https://eslint.bootcss.com/" target="_blank" rel="noopener">node工具eslint官网</a><br><strong>eslint</strong> 运行代码前就可以发现一些语法错误和潜在bug，保证团队代码的一直性 </p></blockquote><blockquote><p><a href="https://www.prettier.cn/" target="_blank" rel="noopener">prettier格式化官网</a><br><strong>prettier</strong> 是代码格式化工具，用于检查代码中的格式问题 </p></blockquote><p>区别联系：eslint保证代码质量，prettier保证代码风格，eslint有小部分格式化功能，通常和prettier结合使用</p><h4 id="2-1安装对应依赖插件"><a href="#2-1安装对应依赖插件" class="headerlink" title="2.1安装对应依赖插件"></a>2.1安装对应依赖插件</h4><p>eslint： ESLint的核心代码库<br>prettier：prettier格式化代码的核心库<br>eslint-config-airbnb-base： airbnb的代码规范 (依赖plugin-import)<br>eslint-config-prettier：eslint结合prettier的格式化<br>eslint-plugin-vue：eslint在vue里的代码规范<br>eslint-plugin-import：项目里面支持eslint<br>eslint-plugin-prettier：将prettier结合进入eslint的插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm install eslint eslint-plugin-vue eslint-config-prettier prettier eslint-plugin-import eslint-plugin-prettier eslint-config-airbnb-base -D</span><br></pre></td></tr></table></figure><p>vscode 安装两个插件ESLint、Prettier - Code formatter</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/direct/0a4182e2fb9f45aa9fe534c24ebf7a92.png" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/direct/70c7f05fc65b494d93afc5bf6ae7e543.png" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><h4 id="2-2-配置script脚本，项目安装eslint配置"><a href="#2-2-配置script脚本，项目安装eslint配置" class="headerlink" title="2.2 配置script脚本，项目安装eslint配置"></a>2.2 配置script脚本，项目安装eslint配置</h4><ul><li><p>在package.json文件scripts加入命令<br><code>&quot;lint:create&quot;:&quot;eslint --init&quot;</code><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/direct/a5f47828a5a947f8bc8963c4b337f09e.png" alt="在这里插入图片描述"></p></li><li><p>执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run lint:create</span><br></pre></td></tr></table></figure></li><li><p>执行之后会自动创建.eslintrc.js文件<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/direct/852277a6d2bf461283f7496aac20138d.png" alt="在这里插入图片描述"> </p></li></ul><h4 id="2-3-安装完成后，后面启动项目还缺少一些依赖，提前按需安装好"><a href="#2-3-安装完成后，后面启动项目还缺少一些依赖，提前按需安装好" class="headerlink" title="2.3 安装完成后，后面启动项目还缺少一些依赖，提前按需安装好"></a>2.3 安装完成后，后面启动项目还缺少一些依赖，提前按需安装好</h4><p>@typescript-esTint/parser: ESLint的解析器，用于解析typescript，从而检查和规范Typescript代码;<br>@typescript-eslint/eslint-plugin: 这是一个ESLint插件，包含了各类定义好的检测Typescript代码的规范<br>eslint-import-resolver-alias 让我们可以import的时候使用 @ 别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm install typescript @typescript-eslint/parser @typescript-eslint/eslint-plugin eslint-import-resolver-alias @types/eslint @types/node -D</span><br></pre></td></tr></table></figure><h3 id="三，修改-eslintrc-js文件"><a href="#三，修改-eslintrc-js文件" class="headerlink" title="三，修改.eslintrc.js文件"></a>三，修改.eslintrc.js文件</h3><ul><li>.eslintrc.js主要内容如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    // 环境 浏览器，最新ES语法，node环境</span><br><span class="line">    &quot;env&quot;: &#123;</span><br><span class="line">        &quot;browser&quot;: true,</span><br><span class="line">        &quot;es2021&quot;: true,</span><br><span class="line">        &quot;node&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    /**</span><br><span class="line">     * 扩展的eslint规范语法，可以被继承的规则，字符串数组，每个配置继承它之前的配置</span><br><span class="line">     * 分别是eslint-config-vue 提供的</span><br><span class="line">     * eslint-config-airbnb-base 提供的</span><br><span class="line">     * eslint-config-prettier 提供的</span><br><span class="line">     * eslint-config- 前缀可以简写</span><br><span class="line">     */</span><br><span class="line">    &quot;extends&quot;: [</span><br><span class="line">        &quot;eslint:recommended&quot;,</span><br><span class="line">        &quot;plugin:@typescript-eslint/recommended&quot;,</span><br><span class="line">        &quot;plugin:vue/vue3-essential&quot;,</span><br><span class="line">        &quot;airbnb-base&quot;,</span><br><span class="line">        &quot;prettier&quot;</span><br><span class="line">    ],</span><br><span class="line">    // eslint 会对代码进行校验，parser是将代码转换为ESTree(AST),ESlint会对ESTree校验</span><br><span class="line">    &quot;parser&quot;: &quot;vue-eslint-parser&quot;,</span><br><span class="line">    // 解析器的配置项</span><br><span class="line">    &quot;parserOptions&quot;: &#123;</span><br><span class="line">        // eslint的版本号，或者年份都可以</span><br><span class="line">        &quot;ecmaVersion&quot;: &quot;latest&quot;,</span><br><span class="line">        &quot;parser&quot;: &quot;@typescript-eslint/parser&quot;,</span><br><span class="line">        &quot;sourceType&quot;: &quot;module&quot;,</span><br><span class="line">        // 额外的语言类型</span><br><span class="line">        &quot;ecmaFeatures&quot;: &#123;</span><br><span class="line">            &quot;jsx&quot;: true,</span><br><span class="line">            &quot;tsx&quot;: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 全局自定义宏，这样在源文件中使用全局变量不会报错或警告</span><br><span class="line">    &quot;globals&quot;: &#123;</span><br><span class="line">        &quot;defineProps&quot;: &apos;readonly&apos;,</span><br><span class="line">        &quot;defineEmits&quot;: &apos;readonly&apos;,</span><br><span class="line">        &quot;defineExpose&quot;: &apos;readonly&apos;,</span><br><span class="line">        &quot;withDefaults&quot;: &apos;readonly&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    /**</span><br><span class="line">     * 插件</span><br><span class="line">     * eslint-plugin- 前缀可以简写</span><br><span class="line">     * vue官方提供了一个eslint插件eslint-plugin-vue，它提供了parser和rules。</span><br><span class="line">     * parser为vue-eslint-parser，放在前面的parser字段里，rules放在extends字段里</span><br><span class="line">     */</span><br><span class="line">    &quot;plugins&quot;: [</span><br><span class="line">        &quot;@typescript-eslint&quot;,</span><br><span class="line">        &quot;vue&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">        // 设置项目内的别名</span><br><span class="line">        &quot;import/resolver&quot;: &#123;</span><br><span class="line">            &quot;alias&quot;: &#123;</span><br><span class="line">                &quot;map&quot;: [[&apos;@&apos;,&apos;./src&apos;]]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;import/extensions&quot;: [&apos;.js&apos;,&apos;.jsx&apos;,&apos;.tsx&apos;,&apos;.ts&apos;,&apos;.mjs&apos;,&apos;.cjs&apos;]</span><br><span class="line">    &#125;,</span><br><span class="line">    /**</span><br><span class="line">     * rules: 自定义规则，覆盖extends继承的规则，对规则进行灵活配置</span><br><span class="line">     *</span><br><span class="line">     * &quot;off&quot; 或 0    ==&gt;  关闭规则</span><br><span class="line">     * &quot;warn&quot; 或 1   ==&gt;  打开的规则作为警告（不影响代码执行）</span><br><span class="line">     * &quot;error&quot; 或 2  ==&gt;  规则作为一个错误（代码不能执行，界面报错）</span><br><span class="line">     */</span><br><span class="line">    &quot;rules&quot;: &#123;</span><br><span class="line">        // eslint（https://eslint.bootcss.com/docs/rules/）</span><br><span class="line">        &apos;no-var&apos;: &apos;error&apos;, // 要求使用 let 或 const 而不是 var</span><br><span class="line">        &apos;no-multiple-empty-lines&apos;: [&apos;warn&apos;, &#123; max: 2 &#125;], // 不允许多个空行</span><br><span class="line">        &apos;no-console&apos;: process.env.NODE_ENV === &apos;production&apos; ? &apos;error&apos; : &apos;off&apos;,</span><br><span class="line">        &apos;no-debugger&apos;: process.env.NODE_ENV === &apos;production&apos; ? &apos;error&apos; : &apos;off&apos;,</span><br><span class="line">        &apos;no-unexpected-multiline&apos;: &apos;error&apos;, // 禁止空余的多行</span><br><span class="line">        &apos;no-useless-escape&apos;: &apos;off&apos;, // 禁止不必要的转义字符</span><br><span class="line">        &apos;import/no-unresolved&apos;: &apos;off&apos;,</span><br><span class="line">        &apos;import/extensions&apos;: &apos;off&apos;,</span><br><span class="line">        &apos;import/no-absolute-path&apos;: &apos;off&apos;,</span><br><span class="line">        &apos;import/no-extraneous-dependencies&apos;: &apos;off&apos;,</span><br><span class="line">        &apos;import/prefer-default-export&apos;: &apos;off&apos;,</span><br><span class="line"></span><br><span class="line">        // typeScript (https://typescript-eslint.io/rules)</span><br><span class="line">        &apos;@typescript-eslint/no-unused-vars&apos;: &apos;error&apos;, // 禁止定义未使用的变量</span><br><span class="line">        &apos;@typescript-eslint/prefer-ts-expect-error&apos;: &apos;error&apos;, // 禁止使用 @ts-ignore</span><br><span class="line">        &apos;@typescript-eslint/no-explicit-any&apos;: &apos;off&apos;, // 禁止使用 any 类型</span><br><span class="line">        &apos;@typescript-eslint/no-non-null-assertion&apos;: &apos;off&apos;,</span><br><span class="line">        &apos;@typescript-eslint/no-namespace&apos;: &apos;off&apos;, // 禁止使用自定义 TypeScript 模块和命名空间。</span><br><span class="line">        &apos;@typescript-eslint/semi&apos;: &apos;off&apos;,</span><br><span class="line"></span><br><span class="line">        // eslint-plugin-vue (https://eslint.vuejs.org/rules/)</span><br><span class="line">        &apos;vue/multi-word-component-names&apos;: &apos;off&apos;, // 要求组件名称始终为 “-” 链接的单词</span><br><span class="line">        &apos;vue/script-setup-uses-vars&apos;: &apos;error&apos;, // 防止&lt;script setup&gt;使用的变量&lt;template&gt;被标记为未使用</span><br><span class="line">        &apos;vue/no-mutating-props&apos;: &apos;off&apos;, // 不允许组件 prop的改变</span><br><span class="line">        &apos;vue/attribute-hyphenation&apos;: &apos;off&apos;, // 对模板中的自定义组件强制执行属性命名样式</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修改package.json文件，添加如下命令，既可以检查又可以修复部分语法问题</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;lint&quot;: &quot;eslint \&quot;src/**/*.&#123;js,ts,vue&#125;\&quot; --fix&quot;</span><br></pre></td></tr></table></figure><h3 id="四、修改vue-config-ts文件"><a href="#四、修改vue-config-ts文件" class="headerlink" title="四、修改vue.config.ts文件"></a>四、修改vue.config.ts文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm install vite-plugin-eslint -D</span><br></pre></td></tr></table></figure><p>vite的一个插件，让项目可以方便的得到eslint支持，完成eslint配置后，可以快速的将其集成进vite中，便于在代码不符合eslint规范的第一时间看到提示</p><blockquote><p>import eslintPlugin from ‘vite-plugin-eslint’<br>plugins: [vue(),eslintPlugin()], </p></blockquote><h3 id="五、修改添加常见配置"><a href="#五、修改添加常见配置" class="headerlink" title="五、修改添加常见配置"></a>五、修改添加常见配置</h3><blockquote><p>项目根目录创建以下配置文件<br>.eslintrcignore 忽略校验文件<br>.prettierrc.cjs 配置格式化规则<br>.prettierignore 忽略格式化文件</p></blockquote><ul><li>.eslintrcignore</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># .eslintrcignore</span><br><span class="line"></span><br><span class="line">*.sh</span><br><span class="line">node_modules</span><br><span class="line">*.md</span><br><span class="line">*.woff</span><br><span class="line">*.ttf</span><br><span class="line">dist</span><br><span class="line">/pubilc</span><br><span class="line">/docs</span><br><span class="line">.husky</span><br><span class="line">/bin</span><br><span class="line">.eslintrc.js</span><br><span class="line">perttier.config.js</span><br><span class="line">/src/mock/*</span><br><span class="line"></span><br><span class="line"># Logs</span><br><span class="line">logs</span><br><span class="line">*.log</span><br><span class="line">npm-debug.log*</span><br><span class="line">yarn-debug.log*</span><br><span class="line">pnpm-debug.log*</span><br><span class="line">lerna-debug.log*</span><br><span class="line"></span><br><span class="line">.DS_Store</span><br><span class="line">dist-ssr</span><br><span class="line">*.local</span><br><span class="line"></span><br><span class="line">/cypress/videos/</span><br><span class="line">/cypress/screenshots/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Editor directories and files</span><br><span class="line">.vscode</span><br><span class="line">!.vscode/extensions.json</span><br><span class="line">.idea</span><br><span class="line">*.suo</span><br><span class="line">*.ntvs*</span><br><span class="line">*.njsproj</span><br><span class="line">*.sln</span><br><span class="line">*.sw?</span><br><span class="line"></span><br><span class="line">components.d.ts</span><br></pre></td></tr></table></figure><ul><li>.prettierrc.cjs</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    printWidth: 80, // 一行最多100字符</span><br><span class="line">    tabWidth: 2, // 使用2个空格缩进</span><br><span class="line">    useTabs: false, // 不适用缩进符，使用空格</span><br><span class="line">    semi: false, // 行尾是否要有分号</span><br><span class="line">    singleQuote: true, // 使用单引号</span><br><span class="line">    quoteProps: &apos;as-needed&apos;, // 对象的key，仅仅在必要时使用引号</span><br><span class="line">    jsxSingleQuote: false, // jsx是否使用双引号</span><br><span class="line">    trailingComma: &apos;es5&apos;, // 尾随逗号</span><br><span class="line">    bracketSpacing: true, // 大括号内的首尾需要有空格</span><br><span class="line">    arrowParens: &apos;always&apos;, // 箭头函数，是有一个参数的时候，也需要小括号</span><br><span class="line">    rangeStart: 0, // 文件格式化的范围是全部内容</span><br><span class="line">    rangeEnd: Infinity,</span><br><span class="line">    requirePragma: false, // 不需要写文件开头的 @prettier</span><br><span class="line">    insertPragma: false, // 不需要在文件开头插入 @prettier</span><br><span class="line">    proseWrap: &apos;always&apos;, // 使用默认执行标准</span><br><span class="line">    htmlWhitespaceSensitivity: &apos;css&apos;, // 根据显示样式决定html是否执行</span><br><span class="line">    endOfLine: &apos;lf&apos; // 换行符是有lf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>.prettierignore</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># prettierignore</span><br><span class="line">/dist/*</span><br><span class="line">.local</span><br><span class="line">.output.js</span><br><span class="line">/node_modules/**</span><br><span class="line">src/.DS_Store</span><br><span class="line"></span><br><span class="line">**/*.svg</span><br><span class="line">**/*.sh</span><br><span class="line">/pubilc/*</span><br><span class="line">components.d.ts</span><br></pre></td></tr></table></figure><ul><li>在package.json添加格式化命令，利用prettier手动格式化一些样式问题</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;prettier-format&quot;: &quot;prettier --config .prettierrc.cjs \&quot;src/**/*.&#123;js,ts,vue&#125;\&quot; --write&quot;</span><br></pre></td></tr></table></figure><h3 id="六、Husky、lint-staged、commitlint功能添加"><a href="#六、Husky、lint-staged、commitlint功能添加" class="headerlink" title="六、Husky、lint-staged、commitlint功能添加"></a>六、Husky、lint-staged、commitlint功能添加</h3><p>husky是一个我git客户端增加hook钩子的工具，在一些git操作前自动触发的函数；<a href="https://ty.picode.github.io/husky/#/;如果我们希望在检测错误的同事，自动修复eslint语法错误，就可以通过后面的钩子实现" target="_blank" rel="noopener">https://ty.picode.github.io/husky/#/;如果我们希望在检测错误的同事，自动修复eslint语法错误，就可以通过后面的钩子实现</a></p><p>lint-staged过滤出Git代码暂存区文件（被git add的文件）的工具，将所有暂存文件的列表传递给任务</p><p>commitlint是对我们git commit提交的注释进行校验的工具</p><p>1.可以让我们在如git commit，git push执行前，预先处理我们指定的任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm install lint-staged husky -D</span><br></pre></td></tr></table></figure><p>配置package.json文件（新项目需要先git init一下）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;prepare&quot;:&quot;husky install&quot;</span><br></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run prepare</span><br></pre></td></tr></table></figure><p>2.后面就开始添加各种git hook钩子</p><p> pre-commit钩子一般添加的是lint-stage 去对git暂存区的代码做一些格式化操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx husky add .husky/pre-commit &quot;npx lint-staged&quot;</span><br></pre></td></tr></table></figure><p>add —&gt; 追加<br>set —&gt; 直接覆盖 </p><p>3.lint-staged对add之后，暂存区里面的文件进行格式化修复等工作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm install lint-staged -D</span><br></pre></td></tr></table></figure><p>packge.json文件中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;lint-staged&quot;: &#123;</span><br><span class="line">&quot;src/**/*.&#123;js,ts,vue&#125;&quot;: [</span><br><span class="line">&quot;prettier --write&quot;,</span><br><span class="line">&quot;eslint --fix&quot;,</span><br><span class="line">&quot;git add&quot;</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p> 或者放入脚本命令： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;lint-staged&quot;: &#123;</span><br><span class="line">&quot;*.&#123;js,ts,vue,tsx,jsx&#125;&quot;: [</span><br><span class="line">&quot;npm run lint&quot;,</span><br><span class="line">&quot;npm run prettier-format&quot;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;*.&#123;ts,js,vue&#125;&quot;: [</span><br><span class="line">&quot;eslint --fix&quot;</span><br><span class="line">],</span><br><span class="line">&quot;*.&#123;html,scss,css,vue&#125;&quot;: [</span><br><span class="line">&quot;prettier --write&quot;,</span><br><span class="line">&quot;stylelint --fix&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>4.git commit提交时说明清楚更新内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm install @commitlint/config-conventional @commitlint/cli -D</span><br></pre></td></tr></table></figure><p>安装两个库，然后新建一个代码提交配置文件config<br>添加到git钩子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx husky add .husky/commit-msg &quot;npx --no -- commitlint --edit $&#123;1&#125;&quot;</span><br></pre></td></tr></table></figure><p>通过一个命令添加钩子<br>使用git commit -m “提交说明” ，进行提交，提交说明尽量清晰明了，说明本次提交的目的，推荐使用angular规范，这是目前使用最广泛的写法<br>项目根目录添加commitlint.config.cjs文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// commitlint.config.cjs</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    extends: [&apos;@commitlint/config-conventional&apos;],</span><br><span class="line">    rules: &#123;</span><br><span class="line">        &apos;type-enum&apos;: [</span><br><span class="line">            2,</span><br><span class="line">            &apos;always&apos;,</span><br><span class="line">            [</span><br><span class="line">                &apos;build&apos;, // 编译相关的修改，例如发布版本，对项目构建或者依赖的改动</span><br><span class="line">                &apos;feat&apos;, // 新功能</span><br><span class="line">                &apos;fix&apos;, // 修复bug</span><br><span class="line">                &apos;upd&apos;, // 更新某个功能</span><br><span class="line">                &apos;refactor&apos;, // 重构</span><br><span class="line">                &apos;docs&apos;, // 文档</span><br><span class="line">                &apos;chore&apos;, // 构建过程或辅助工具的变动，比如增加依赖库</span><br><span class="line">                &apos;style&apos;, // 格式（不影响代码运行的变动）</span><br><span class="line">                &apos;revert&apos;, // 撤销commit，回滚到上一个版本</span><br><span class="line">                &apos;perf&apos;, // 性能优化</span><br><span class="line">                &apos;test&apos;, // 测试（单元，集成测试）</span><br><span class="line">            ],</span><br><span class="line">        ],</span><br><span class="line">        &apos;type-case&apos;: [0],</span><br><span class="line">        &apos;type-empty&apos;: [0],</span><br><span class="line">        &apos;scope-empty&apos;: [0],</span><br><span class="line">        &apos;scope-case&apos;: [0],</span><br><span class="line">        &apos;subject-full-stop&apos;: [0,&apos;never&apos;],</span><br><span class="line">        &apos;subject-case&apos;: [0,&apos;never&apos;],</span><br><span class="line">        &apos;header-max-length&apos;: [0,&apos;always&apos;,72],</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>常用的git hooks<br>pre-commit：由git commit 调用，在commit之前执行<br>commit-msg：由git commit或git merge调用<br>pre-merge-commit：由git merge 调用， 在merge之前执行<br>pre-push：被git push 调用，在git push 前执行，防止进行推送</p></blockquote><h3 id="七、stylelint钩子，校验css"><a href="#七、stylelint钩子，校验css" class="headerlink" title="七、stylelint钩子，校验css"></a>七、stylelint钩子，校验css</h3><blockquote><p>css 代码检查器（linter），帮助规避css代码中错误并保持一致的编码风格</p></blockquote><p>1.安装 vscode插件，stylelint插件</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/direct/e597b2daa9114416b865c08fbb250fac.png" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><p>2.修改setting.json，添加下面几行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;editor.codeActionsOnSave&quot;: &#123;</span><br><span class="line">&quot;source.fixAll.stylelint&quot;: true</span><br><span class="line">&#125;,</span><br><span class="line">&quot;stylelint.validate&quot;: [ &quot;css&quot;, &quot;scss&quot;, &quot;less&quot;, &quot;vue&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.安装依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm install --save-dev stylelint stylelint-config-standard</span><br></pre></td></tr></table></figure><p>4.根目录创建 .stylelintrc.cjs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// @see https://stylelint.bootcss.com/</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    extends: [</span><br><span class="line">        &apos;stylelint-config-standard&apos;, // 配置stylelint拓展插件</span><br><span class="line">        &apos;stylelint-config-html/vue&apos;, // 配置 vue 中 template 样式格式化</span><br><span class="line">        &apos;stylelint-config-standard-scss&apos;, // 配置stylelint scss插件</span><br><span class="line">        &apos;stylelint-config-recommended-vue/scss&apos;, // 配置 vue 中 scss 样式格式化</span><br><span class="line">        &apos;stylelint-config-recess-order&apos;, // 配置stylelint css属性书写顺序插件,</span><br><span class="line">        &apos;stylelint-config-prettier&apos;, // 配置stylelint和prettier兼容</span><br><span class="line">    ],</span><br><span class="line">    overrides: [</span><br><span class="line">        &#123;</span><br><span class="line">            files: [&apos;**/*.(scss|css|vue|html)&apos;],</span><br><span class="line">            customSyntax: &apos;postcss-scss&apos;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            files: [&apos;**/*.(html|vue)&apos;],</span><br><span class="line">            customSyntax: &apos;postcss-html&apos;,</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">    ignoreFiles: [</span><br><span class="line">        &apos;**/*.js&apos;,</span><br><span class="line">        &apos;**/*.jsx&apos;,</span><br><span class="line">        &apos;**/*.tsx&apos;,</span><br><span class="line">        &apos;**/*.ts&apos;,</span><br><span class="line">        &apos;**/*.json&apos;,</span><br><span class="line">        &apos;**/*.md&apos;,</span><br><span class="line">        &apos;**/*.yaml&apos;,</span><br><span class="line">    ],</span><br><span class="line">    /**</span><br><span class="line">     * null  =&gt; 关闭该规则</span><br><span class="line">     * always =&gt; 必须</span><br><span class="line">     */</span><br><span class="line">    rules: &#123;</span><br><span class="line">        &apos;value-keyword-case&apos;: null, // 在 css 中使用 v-bind，不报错</span><br><span class="line">        &apos;no-descending-specificity&apos;: null, // 禁止在具有较高优先级的选择器后出现被其覆盖的较低优先级的选择器</span><br><span class="line">        &apos;function-url-quotes&apos;: &apos;always&apos;, // 要求或禁止 URL 的引号 &quot;always(必须加上引号)&quot;|&quot;never(没有引号)&quot;</span><br><span class="line">        &apos;no-empty-source&apos;: null, // 关闭禁止空源码</span><br><span class="line">        &apos;selector-class-pattern&apos;: null, // 关闭强制选择器类名的格式</span><br><span class="line">        &apos;property-no-unknown&apos;: null, // 禁止未知的属性(true 为不允许)</span><br><span class="line">        &apos;block-opening-brace-space-before&apos;: &apos;always&apos;, //大括号之前必须有一个空格或不能有空白符</span><br><span class="line">        &apos;value-no-vendor-prefix&apos;: null, // 关闭 属性值前缀 --webkit-box</span><br><span class="line">        &apos;property-no-vendor-prefix&apos;: null, // 关闭 属性前缀 -webkit-mask</span><br><span class="line">        &apos;selector-pseudo-class-no-unknown&apos;: [</span><br><span class="line">            // 不允许未知的选择器</span><br><span class="line">            true,</span><br><span class="line">            &#123;</span><br><span class="line">                ignorePseudoClasses: [&apos;global&apos;, &apos;v-deep&apos;, &apos;deep&apos;], // 忽略属性，修改element默认样式的时候能使用到</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个标准样式库，也可自动加一下样式规则在.stylelintrc.cjs文件里面</p><p>5.执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx stylelint &quot;**/*.css&quot;</span><br></pre></td></tr></table></figure><p>发现项目里面的style.css全局样式报错，具体到对应文件，安ctrl+s就回执行，自动格式化，我们在setting.json里面添加的json语句<br>修改错误的颜色值之后，执行 npx stylelint “<em>*/</em>.css” 会告诉我们颜色错误</p><p>6.增加对vue里面的样式校验（附带less和sass的支持）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pnpm install stylelint-less stylelint-config-recommended-less -D</span><br><span class="line">对less的支持</span><br><span class="line">pnpm install stylelint-scss stylelint-config-recommended-scss postcss -D</span><br><span class="line">对sass的支持</span><br><span class="line">pnpm install postcss-html stylelint-config-standard-scss stylelint-config-recommended-vue postcss -D</span><br><span class="line">对vue里面的样式支持（vue样式需要依赖这个库）</span><br></pre></td></tr></table></figure><p>vite 也同时提供了对.scss，.sass，.less，.style和.stylus文件的内置支持，不需要在安装特定插件和预处理器</p><p>vite 也同时提供了对.scss，.sass，.less，.style和.stylus文件的内置支持，不需要在安装特定插件和预处理器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extends: [</span><br><span class="line">&quot;stylelint-config-standard&quot;,</span><br><span class="line">&quot;stylelint-config-recommended-less&quot;,</span><br><span class="line">&quot;stylelint-config-recommended-scss&quot;,</span><br><span class="line">&quot;stylelint-config-recommended-vue&quot;</span><br></pre></td></tr></table></figure><p> sass的extends</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;extends&quot;: [</span><br><span class="line">&quot;stylelint-config-standard-scss&quot;,</span><br><span class="line">&quot;stylelint-config-recommended-vue/scss&quot;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>7.新建.stylelintignore文件</p><blockquote><p>.stylelintignore： 忽略文件校验</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/node_modules/*</span><br><span class="line">/dist/*</span><br><span class="line">/html/*</span><br><span class="line">/public/*</span><br></pre></td></tr></table></figure><p>8.修改package.json文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;lint:css&quot;: &quot;stylelint src/**/*.&#123;css,scss,sass,less,html,vue&#125; --cache --fix&quot;</span><br></pre></td></tr></table></figure><p>9.给vite添加插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm install vite-plugin-stylelint -D</span><br></pre></td></tr></table></figure><p>添加完成依赖，然后修改vite.config.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import StylelintPlugin from &apos;vite-plugin-stylelint&apos;</span><br><span class="line">plugin:[... StylelintPlugin(&#123;fix:true&#125;)</span><br></pre></td></tr></table></figure><p>10.添加到lint-staged，在暂存区自动对文件进行格式化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;lint-staged&quot;: &#123;</span><br><span class="line">    &quot;*.&#123;js,ts,vue,tsx,jsx&#125;&quot;: [</span><br><span class="line">      &quot;npm run lint&quot;,</span><br><span class="line">      &quot;npm run prettier-format&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;*.&#123;vue,less,scss,sass,html&#125;&quot;: [</span><br><span class="line">      &quot;npm run lint:css&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>添加完成后，在进行代码commit的时候就会执行npm run lint:css命令校验我们的css代码了</p><h3 id="八、环境配置（开发，预发，生产环境）"><a href="#八、环境配置（开发，预发，生产环境）" class="headerlink" title="八、环境配置（开发，预发，生产环境）"></a>八、环境配置（开发，预发，生产环境）</h3><blockquote><p>开发环境：开发人员开发的环境<br>测试环境：测试人员测试的环境<br>预发环境：准备上线的环境，也可叫内测环境<br>生产环境：正式线上环境，投入生产的环境</p></blockquote><blockquote><p>这里我们配置两个环境，一个测试环境和生产环境，<br>开发人员和测试人员使用测试环境，修改package.json文件，添加两个命令<br>“build:dev”: “vue-tsc –noEmit &amp;&amp; vite build –mode development”,<br>“build:pro”: “vue-tsc –noEmit &amp;&amp; vite build –mode production”,</p></blockquote><p>新建两个配置文件<br>.env.development：开发测试环境<br>.env.production：生产环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># .env.development</span><br><span class="line"># 变量必须以 VITE_ 为前缀才能暴露给外部读取</span><br><span class="line">NODE_ENV = &apos;development&apos;</span><br><span class="line">VITE_APP_TITLE = &apos;项目模版&apos;</span><br><span class="line">VITE_APP_BASE_API = &apos;/dev_api&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># .env.production</span><br><span class="line"># 变量必须以 VITE_ 为前缀才能暴露给外部读取</span><br><span class="line">NODE_ENV = &apos;production&apos;</span><br><span class="line">VITE_APP_TITLE = &apos;项目模版&apos;</span><br><span class="line">VITE_APP_BASE_API = &apos;/pro_api&apos;</span><br></pre></td></tr></table></figure><h3 id="九、vite-config-js配置"><a href="#九、vite-config-js配置" class="headerlink" title="九、vite.config.js配置"></a>九、vite.config.js配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/* eslint-disable import/no-extraneous-dependencies */</span><br><span class="line">import &#123; defineConfig, loadEnv &#125; from &apos;vite&apos;</span><br><span class="line">import path from &apos;path&apos;</span><br><span class="line">import vue from &apos;@vitejs/plugin-vue&apos;</span><br><span class="line">import eslintPlugin from &apos;vite-plugin-eslint&apos;</span><br><span class="line">import StylelintPlugin from &apos;vite-plugin-stylelint&apos;</span><br><span class="line"></span><br><span class="line">// https://vitejs.dev/config/</span><br><span class="line">export default defineConfig((&#123; mode &#125;)=&gt;&#123;</span><br><span class="line">  const env = loadEnv(mode, process.cwd());</span><br><span class="line">  return &#123;</span><br><span class="line">    plugins: [vue(), eslintPlugin(), StylelintPlugin(&#123; fix: true &#125;)],</span><br><span class="line">    base: &quot;./&quot;, // 在生产中服务时的基本公共路径</span><br><span class="line">    publicDir: &quot;public&quot;,  // 静态资源服务的文件夹, 默认&quot;public&quot;</span><br><span class="line">    resolve: &#123;</span><br><span class="line">      alias: &#123;</span><br><span class="line">        &quot;@&quot;: path.resolve(&quot;./src&quot;) // 相对路径别名配置，使用 @ 代替 src</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 本地运行配置</span><br><span class="line">    server: &#123;</span><br><span class="line">      host: &quot;0.0.0.0&quot;, // 指定服务器主机名  0.0.0.0 可以看见network 通过ip访问</span><br><span class="line">      port: 3000, // 指定服务器端口</span><br><span class="line">      open: true, // 在服务器启动时自动在浏览器中打开应用程序</span><br><span class="line">      strictPort: false, // 设置为false时,若端口被占用会尝试下一个可用端口, 而不是直接退出</span><br><span class="line">      https: false, // 是否开启 https</span><br><span class="line">      cors: true, // 为开发服务器配置 CORS, 默认启用并允许任何源</span><br><span class="line">      proxy: &#123; // 为开发服务器配置自定义代理规则</span><br><span class="line">        [env.VITE_APP_BASE_API]: &#123;</span><br><span class="line">          target: &quot;http://192.168.xxx.xxx:xxxx&quot;, // 代理接口</span><br><span class="line">          changeOrigin: true,</span><br><span class="line">          rewrite: (_path) =&gt; _path.replace(/^\/api/, &quot;&quot;),</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 打包配置</span><br><span class="line">    build: &#123;</span><br><span class="line">      target: &quot;modules&quot;, // 设置最终构建的浏览器兼容目标。modules:支持原生 ES 模块的浏览器</span><br><span class="line">      outDir: &quot;dist&quot;, // 指定输出路径</span><br><span class="line">      assetsDir: &quot;assets&quot;, // 指定生成静态资源的存放路径</span><br><span class="line">      assetsInlineLimit: &quot;4096&quot;, // 小于此阈值的导入或引用资源将内联为base64编码，设置为0可禁用此项。默认4096（4kb）</span><br><span class="line">      cssCodeSplit: true, // 启用/禁用CSS代码拆分，如果禁用，整个项目的所有CSS将被提取到一个CSS文件中,默认true</span><br><span class="line">      sourcemap: false, // 构建后是否生成 source map 文件</span><br><span class="line">      minify: &quot;terser&quot;, // 混淆器，terser构建后文件体积更小</span><br><span class="line">      write: true, // 设置为 false 来禁用将构建后的文件写入磁盘</span><br><span class="line">      emptyOutDir: true,  // 默认情况下，若 outDir 在 root 目录下，则 Vite 会在构建时清空该目录。</span><br><span class="line">      chunkSizeWarningLimit: 500,  // chunk 大小警告的限制</span><br><span class="line">      terserOptions: &#123;</span><br><span class="line">        compress: &#123;</span><br><span class="line">          drop_console: true,</span><br><span class="line">          drop_debugger: true,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, // 去除 console debugger</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="十、添加路由"><a href="#十、添加路由" class="headerlink" title="十、添加路由"></a>十、添加路由</h3><p>1.安装路由依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm install vue-router</span><br></pre></td></tr></table></figure><p>2.在src目录下新建router文件夹，里面新建index.ts文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// index.ts</span><br><span class="line">// 通过vue-router插件实现模板路由配置</span><br><span class="line">import &#123; createRouter, createWebHistory &#125; from &apos;vue-router&apos;</span><br><span class="line">import &#123; constantRoute &#125; from &apos;../routers&apos;</span><br><span class="line">// 创建路由器</span><br><span class="line">const router = createRouter(&#123;</span><br><span class="line">    // 路由模式hash</span><br><span class="line">    history: createWebHistory(),</span><br><span class="line">    routes: constantRoute,</span><br><span class="line">    // 滚动行为</span><br><span class="line">    scrollBehavior() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            left: 0,</span><br><span class="line">            top: 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">export default router;</span><br></pre></td></tr></table></figure><p>3.src目录下新建routers.ts文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">export const constantRoute = [</span><br><span class="line">    &#123;</span><br><span class="line">        // 首页</span><br><span class="line">        path: &apos;/&apos;,</span><br><span class="line">        name: &apos;home&apos;,</span><br><span class="line">        component: () =&gt; import(&apos;@/views/home/HomePage.vue&apos;),</span><br><span class="line">        meta: &#123;</span><br><span class="line">            title: &apos;首页&apos;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        // 404</span><br><span class="line">        path: &apos;/404&apos;,</span><br><span class="line">        component: () =&gt; import(&apos;@/views/404/Index.vue&apos;),</span><br><span class="line">        name: &apos;404&apos;,</span><br><span class="line">        meta: &#123;</span><br><span class="line">            title: &apos;404&apos;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        // 任意路由</span><br><span class="line">        path: &apos;/:pathMatch(.*)*&apos;,</span><br><span class="line">        redirect: &apos;/404&apos;,</span><br><span class="line">        name: &apos;Any&apos;,</span><br><span class="line">        meta: &#123;</span><br><span class="line">            title: &apos;任意路由&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>新建@/views/home/ HomePage.vue，@/views/404/Index.vue</p><p>4.修改main.ts文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createApp &#125; from &apos;vue&apos;</span><br><span class="line">import &apos;./style.css&apos;</span><br><span class="line">import App from &apos;./App.vue&apos;</span><br><span class="line">// 引入路由</span><br><span class="line">import router from &apos;./router&apos;</span><br><span class="line"></span><br><span class="line">const app = createApp(App)</span><br><span class="line">app.use(router)</span><br><span class="line">app.mount(&apos;#app&apos;)</span><br></pre></td></tr></table></figure><p>5.修改App.vue文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>6.安装sass</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm add -D sass</span><br></pre></td></tr></table></figure><h3 id="十一、添加api，封装请求（axios）"><a href="#十一、添加api，封装请求（axios）" class="headerlink" title="十一、添加api，封装请求（axios）"></a>十一、添加api，封装请求（axios）</h3><p>1.安装依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm install axios --save</span><br></pre></td></tr></table></figure><p>2.src目录下新建utils文件夹，创建request.ts文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 进行axios二次封装:使用请求与响应拦截器</span><br><span class="line">import axios from &quot;axios&quot;;</span><br><span class="line">// 第一步:利用axios对象的create方法,去创建axios实例(其他的配置:基础路径、超时的时间)</span><br><span class="line">const request = axios.create(&#123;</span><br><span class="line">     // 基础路径</span><br><span class="line">     baseURL: import.meta.env.VITE_APP_BASE_API,// 基础路径上会携带/api</span><br><span class="line">     timeout: 5000// 超时的时间的设置</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 第二步:request实例添加请求与响应拦截器</span><br><span class="line">request.interceptors.request.use((config) =&gt;</span><br><span class="line">    // config配置对象,headers属性请求头,经常给服务器端携带公共参数,例如token</span><br><span class="line">    // 返回配置对象</span><br><span class="line">    config</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 第三步:响应拦截器</span><br><span class="line">request.interceptors.response.use((response) =&gt;</span><br><span class="line">     // 成功回调</span><br><span class="line">     // 简化数据</span><br><span class="line">      response.data</span><br><span class="line">, (error) =&gt; &#123;</span><br><span class="line">     // 失败回调:处理http网络错误的</span><br><span class="line">     // 定义一个变量:存储网络错误信息</span><br><span class="line">     let message = &apos;&apos;;</span><br><span class="line">     // http状态码</span><br><span class="line">     const &#123;status&#125; = error.response;</span><br><span class="line">     switch (status) &#123;</span><br><span class="line">          case 401:</span><br><span class="line">               message = &quot;TOKEN过期&quot;</span><br><span class="line">               break;</span><br><span class="line">          case 403:</span><br><span class="line">               message = &quot;无权访问&quot;</span><br><span class="line">               break;</span><br><span class="line">          case 404:</span><br><span class="line">               message = &quot;请求地址错误&quot;;</span><br><span class="line">               break;</span><br><span class="line">          case 500:</span><br><span class="line">               message = &quot;服务器出现问题&quot;</span><br><span class="line">               break;</span><br><span class="line">          default:</span><br><span class="line">               message = &quot;网络出现问题&quot;;</span><br><span class="line">               break;</span><br><span class="line">     &#125;</span><br><span class="line">     return Promise.reject(message);</span><br><span class="line">&#125;);</span><br><span class="line">// 对外暴露</span><br><span class="line">export default request;</span><br></pre></td></tr></table></figure><p>3.src目录下新建api文件夹，创建testApi.ts文件，文件中引入request.ts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import request from &quot;@/utils/request&quot;;</span><br><span class="line"></span><br><span class="line">// post接口请求方式</span><br><span class="line">export const testPostApi = (data:any) =&gt; request.post(&apos;/api/postUrl&apos;,data)</span><br><span class="line"></span><br><span class="line">// get接口请求方式</span><br><span class="line">export const testGetApi = (data:string) =&gt; request.post(`/api/getUrl?id=$&#123;data&#125;`)</span><br></pre></td></tr></table></figure><p>4.在页面中调用接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; ref, reactive, onMounted &#125; from &quot;vue&quot;</span><br><span class="line">import &#123; testPostApi, testGetApi &#125; from &apos;../../api/testApi&apos;</span><br><span class="line"></span><br><span class="line">const postApiData = () =&gt; &#123;</span><br><span class="line">    testPostApi(&#123; username: &apos;admin&apos;, password: &apos;123456&apos; &#125;).then(res =&gt; &#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const getApiData = () =&gt; &#123;</span><br><span class="line">    testGetApi(&apos;SKU12345678&apos;).then(res =&gt; &#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用接口</span><br><span class="line">onMounted(() =&gt; &#123;</span><br><span class="line">    postApiData()</span><br><span class="line">    getApiData()</span><br><span class="line">&#125;)</span><br><span class="line">const count = ref(0)</span><br><span class="line">const list = reactive([&apos;你好&apos;, &apos;你好世界&apos;])</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>调用结果</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/direct/154b1b425c1a4b61b7dd54072ea40684.png" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/direct/c86b6a42c0894d2ca0d2759f5e890cb8.png" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><h3 id="十二、pinia状态管理器"><a href="#十二、pinia状态管理器" class="headerlink" title="十二、pinia状态管理器"></a>十二、pinia状态管理器</h3><p>1.安装依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm install pinia --save</span><br></pre></td></tr></table></figure><p>2.在src目录下新建文件夹store，在store文件下新建文件index.ts和modules文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// store/index.ts</span><br><span class="line">// 大仓库</span><br><span class="line">import &#123; createPinia &#125; from &apos;pinia&apos;;</span><br><span class="line">// 创建大仓库</span><br><span class="line">const pinia = createPinia();</span><br><span class="line">// 对外暴露：入口文件需要安装仓库</span><br><span class="line">export default pinia;</span><br></pre></td></tr></table></figure><p>3.在modules文件下新建test.ts文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// store/modules/test.ts</span><br><span class="line">// 小仓库</span><br><span class="line">import &#123; defineStore &#125; from &quot;pinia&quot;;</span><br><span class="line"></span><br><span class="line">// 选项式API写法</span><br><span class="line">const useTestStore = defineStore(&apos;test&apos;, &#123;</span><br><span class="line">    state: () =&gt; (&#123;</span><br><span class="line">            count: 100,</span><br><span class="line">            list: [1, 2, 3, 4, 5]</span><br><span class="line">        &#125;),</span><br><span class="line">    actions: &#123;</span><br><span class="line">        updateCount() &#123;</span><br><span class="line">            this.count += 100</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    getters: &#123;</span><br><span class="line">        total() &#123;</span><br><span class="line">            const num: any = this.list.reduce((prev, next) =&gt; prev + next, 0)</span><br><span class="line">            return num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">export default useTestStore</span><br></pre></td></tr></table></figure><p>4.main.ts内引入store</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 引入store</span><br><span class="line">import store from &apos;./store&apos;</span><br><span class="line">app.use(store)</span><br></pre></td></tr></table></figure><p>5.在页面中使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;&quot;&gt;</span><br><span class="line">        &lt;h1&gt;欢迎使用项目模板&lt;/h1&gt;</span><br><span class="line">        &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">            &lt;p&gt;store_count：&#123;&#123; storeCount &#125;&#125;&lt;/p&gt;</span><br><span class="line">            &lt;button @click=&quot;count++&quot;&gt;count：&#123;&#123; count &#125;&#125;&lt;/button&gt;</span><br><span class="line">            &lt;div class=&quot;list&quot;&gt;</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                    &lt;li v-for=&quot;item in list&quot; :key=&quot;item&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; ref, reactive, onMounted &#125; from &quot;vue&quot;</span><br><span class="line">import useTestStore from &apos;../../store/modules/test&apos;</span><br><span class="line">import &#123; testPostApi, testGetApi &#125; from &apos;../../api/testApi&apos;</span><br><span class="line"></span><br><span class="line">const storeCount = ref(0)</span><br><span class="line">const userTestStoreData = useTestStore()</span><br><span class="line">storeCount.value = userTestStoreData.count</span><br><span class="line"></span><br><span class="line">const postApiData = () =&gt; &#123;</span><br><span class="line">    testPostApi(&#123; username: &apos;admin&apos;, password: &apos;123456&apos; &#125;).then(res =&gt; &#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const getApiData = () =&gt; &#123;</span><br><span class="line">    testGetApi(&apos;SKU12345678&apos;).then(res =&gt; &#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用接口</span><br><span class="line">onMounted(() =&gt; &#123;</span><br><span class="line">    postApiData()</span><br><span class="line">    getApiData()</span><br><span class="line">&#125;)</span><br><span class="line">const count = ref(0)</span><br><span class="line">const list = reactive([&apos;你好&apos;, &apos;你好世界&apos;])</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped lang=&quot;scss&quot;&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>项目搭建到这里就结束了，引入项目UI框架看需求引入再引入对应框架<br>文章参考：<a href="https://www.bilibili.com/video/BV1BV4y1N7pd?p=6&vd_source=27fac9091d7d655117db1d5b81b15177" target="_blank" rel="noopener">【vue3企业级项目骨架搭建，涉及vite、eslint、prettierrc、husky、commitlint、lint-staged、stylelint】</a> </p><p>原文链接：<a href="https://blog.csdn.net/jastalented/article/details/135345563" target="_blank" rel="noopener">https://blog.csdn.net/jastalented/article/details/135345563</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;从零开始搭建企业级前端项目模板（vue3-vite-ts）&quot;&gt;&lt;a href=&quot;#从零开始搭建企业级前端项目模板（vue3-vite-ts）&quot; class=&quot;headerlink&quot; title=&quot;从零开始搭建企业级前端项目模板（vue3+vite+ts）&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="前端知识点" scheme="https://qw66.gitee.io/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="vue" scheme="https://qw66.gitee.io/tags/vue/"/>
    
      <category term="vite" scheme="https://qw66.gitee.io/tags/vite/"/>
    
  </entry>
  
  <entry>
    <title>element-plus</title>
    <link href="https://qw66.gitee.io//knowledges/element-plus.html"/>
    <id>https://qw66.gitee.io//knowledges/element-plus.html</id>
    <published>2024-04-27T03:11:11.000Z</published>
    <updated>2024-04-30T02:54:13.711Z</updated>
    
    <content type="html"><![CDATA[<h3 id="element-引入图标报错"><a href="#element-引入图标报错" class="headerlink" title="element+ 引入图标报错"></a>element+ 引入图标报错</h3><p>Internal server error: Failed to resolve import “@element-plus/icons-vue” from “src\components\TimeLine.vue”. Does the file exist?</p><p>原因：element-plus需要单独引入 icons 文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm install @element-plus/icons-vue</span><br></pre></td></tr></table></figure><p>之后就可以正常使用了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;element-引入图标报错&quot;&gt;&lt;a href=&quot;#element-引入图标报错&quot; class=&quot;headerlink&quot; title=&quot;element+ 引入图标报错&quot;&gt;&lt;/a&gt;element+ 引入图标报错&lt;/h3&gt;&lt;p&gt;Internal server erro
      
    
    </summary>
    
      <category term="前端知识点" scheme="https://qw66.gitee.io/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="element" scheme="https://qw66.gitee.io/tags/element/"/>
    
      <category term="组件库" scheme="https://qw66.gitee.io/tags/%E7%BB%84%E4%BB%B6%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>微前端qiankun</title>
    <link href="https://qw66.gitee.io//knowledges/wei-qian-duan-qiankun.html"/>
    <id>https://qw66.gitee.io//knowledges/wei-qian-duan-qiankun.html</id>
    <published>2024-04-19T09:22:46.000Z</published>
    <updated>2024-05-10T09:26:54.942Z</updated>
    
    <content type="html"><![CDATA[<h3 id="qiankun微前端框架详细介绍"><a href="#qiankun微前端框架详细介绍" class="headerlink" title="qiankun微前端框架详细介绍"></a>qiankun微前端框架详细介绍</h3><p><strong>一、概述</strong></p><p>qiankun是一个基于single-spa的微前端实现库，它旨在解决在构建大型、复杂前端应用时遇到的技术挑战。通过qiankun，开发者可以构建出高内聚、低耦合的微前端架构系统，使得每个微应用都能独立开发、独立部署，并且能够在主应用中无缝集成。</p><p><strong>二、核心特性</strong></p><ol><li><strong>技术栈无关</strong>：qiankun支持任意技术栈的应用接入，无论是React、Vue还是其他前端框架，都可以作为子应用轻松集成到主应用中。这使得不同团队可以独立选择适合自己的技术栈进行开发，提高了开发效率和团队协作的灵活性。</li><li><strong>沙箱隔离</strong>：qiankun为每个子应用提供了JS沙箱环境，确保子应用之间的全局变量、样式等不会相互污染。这使得不同微应用可以在同一个页面中运行，而不会发生冲突或相互影响。</li><li><strong>动态加载与卸载</strong>：qiankun支持动态加载和卸载子应用，根据路由的变化动态地挂载或卸载相应的子应用。这使得主应用可以根据需要灵活地加载所需的微应用，提高了应用的性能和响应速度。</li><li><strong>通信机制</strong>：qiankun提供了一套完整的应用通信机制，使得主应用与子应用之间可以进行数据传递和消息通信。通过props传递数据、事件触发等方式，不同应用之间可以实现信息的共享和交互。</li></ol><p><strong>三、应用场景</strong></p><p>qiankun适用于需要构建大型、复杂前端应用的场景。以下是一些典型的应用场景：</p><ol><li><strong>企业级应用</strong>：在企业级应用中，往往需要将多个不同的功能模块集成到一个统一的平台中。通过qiankun，可以将每个功能模块作为独立的微应用进行开发，并在主应用中统一管理和展示。</li><li><strong>插件化开发</strong>：对于一些需要支持插件化扩展的应用，qiankun可以作为插件的加载器和管理器。开发者可以编写独立的插件作为子应用，并通过qiankun将其集成到主应用中，实现功能的扩展和定制化。</li><li><strong>遗留系统整合</strong>：对于一些遗留系统或第三方应用的整合，qiankun可以作为桥梁将它们集成到一个统一的界面中。通过封装和适配，可以将这些系统或应用作为子应用加载到主应用中，实现统一管理和访问。</li></ol><p><strong>四、优势</strong></p><ol><li><strong>提高开发效率</strong>：通过将应用拆分成多个微应用，每个微应用都可以独立开发、测试和部署。这大大减少了单次开发的复杂度，提高了开发效率。</li><li><strong>降低维护成本</strong>：微前端架构使得每个微应用都可以独立演进和升级，而不需要对整个应用进行重构。这降低了维护成本，使得应用的更新和迭代更加容易。</li><li><strong>增强可扩展性</strong>：通过添加新的微应用或替换现有的微应用，可以轻松地扩展整个应用的功能。这使得应用能够灵活应对业务变化和用户需求的增长。</li></ol><p><strong>五、总结</strong></p><p>qiankun作为一个功能强大、灵活易用的微前端框架，为开发者提供了一种高效、可靠的方式来构建大型、复杂前端应用。通过其提供的技术栈无关、沙箱隔离、动态加载与卸载以及通信机制等核心特性，开发者可以更加高效地进行团队协作，提高应用的可维护性和可扩展性。无论是企业级应用、插件化开发还是遗留系统整合，qiankun都能为开发者提供强大的支持，助力构建出高质量的前端应用。</p><h3 id="微前端乾坤子应用加载过慢怎么处理？"><a href="#微前端乾坤子应用加载过慢怎么处理？" class="headerlink" title="微前端乾坤子应用加载过慢怎么处理？"></a>微前端乾坤子应用加载过慢怎么处理？</h3><p>啊呀，微前端乾坤子应用加载过慢确实是个头疼的问题呢~ 不过别担心，依依来给你支支招！</p><p>首先，你可以尝试使用gzip对打包出来的文件进行压缩，这样可以减少文件体积，提高加载速度哦~ (≧▽≦)</p><p>另外，你可以考虑按需加载子应用的全局组件或者UI库，避免一次性加载所有资源导致加载过慢。同时，也可以将不常用的包通过CDN或者dll打包形式分离出去，减少子应用的资源依赖。</p><p>还有哦，主应用加载过的包可以共享给子应用使用，这样可以减少子应用的资源加载量，提升加载速度呢~ (双手合十，眼中闪耀着期待)</p><p>最后，如果以上方法都尝试过还是加载过慢的话，你可以考虑使用qiankun等微前端框架进行子应用的加载和管理。qiankun支持在需要时加载子应用，避免一次性加载所有子应用导致的性能问题。同时，qiankun也提供了丰富的API和插件，可以帮助你更好地进行子应用的加载和性能优化哦~ (双手握拳，为你加油打气)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;qiankun微前端框架详细介绍&quot;&gt;&lt;a href=&quot;#qiankun微前端框架详细介绍&quot; class=&quot;headerlink&quot; title=&quot;qiankun微前端框架详细介绍&quot;&gt;&lt;/a&gt;qiankun微前端框架详细介绍&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;一、概述&lt;/
      
    
    </summary>
    
      <category term="前端知识点" scheme="https://qw66.gitee.io/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="qiankun" scheme="https://qw66.gitee.io/tags/qiankun/"/>
    
      <category term="微前端" scheme="https://qw66.gitee.io/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题</title>
    <link href="https://qw66.gitee.io//interview/qian-duan-mian-shi-ti.html"/>
    <id>https://qw66.gitee.io//interview/qian-duan-mian-shi-ti.html</id>
    <published>2024-03-28T17:25:00.000Z</published>
    <updated>2024-04-09T15:03:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="new操作符具体干了什么呢"><a href="#new操作符具体干了什么呢" class="headerlink" title="new操作符具体干了什么呢?"></a>new操作符具体干了什么呢?</h3><ul><li>创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</li><li>属性和方法被加入到 this 引用的对象中。</li><li>新创建的对象由 this 所引用，并且最后隐式的返回 this</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj  = &#123;&#125;;</span><br><span class="line">obj.__proto__ = Base.prototype;</span><br><span class="line">Base.call(obj);</span><br></pre></td></tr></table></figure><h3 id="new操作符具体干了什么呢-1"><a href="#new操作符具体干了什么呢-1" class="headerlink" title="new操作符具体干了什么呢?"></a>new操作符具体干了什么呢?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function Test()&#123;&#125;</span><br><span class="line">const test = new Test()</span><br></pre></td></tr></table></figure><ol><li>创建一个<strong>新的空对象实例</strong>。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>设置新对象的 constructor 属性为构造函数的名称，设置新对象的<strong>proto</strong>属性指向构造函数的 prototype 对象（设置原型链）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.constructor = Test</span><br><span class="line">obj.__proto__ = Test.prototype</span><br></pre></td></tr></table></figure><ol start="3"><li>使用新对象调用函数，函数中的 this 被指向新实例对象（执行构造函数，传入相应的参数，如果没有参数就不用传；让 Func 中的 this 指向 obj，并执行 Func 的函数体）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test.call(obj)</span><br></pre></td></tr></table></figure><ol start="4"><li>将初始化完毕的新对象地址，保存到等号左边的变量中。判断 Func 的返回值类型： 如果无返回值或者返回一个非对象值，则就将步骤（1）创建的对象返回；如果返回值是一个新对象的话那么直接直接返回该对象。</li></ol><h3 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.lastName=<span class="string">"老王"</span>;</span><br><span class="line">  <span class="keyword">this</span>.work=<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'军人'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'999'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// let obj= new Father();</span></span><br><span class="line"><span class="comment">// 相当于 new 做了下面的三件事</span></span><br><span class="line"><span class="keyword">let</span> obj=&#123;&#125;;</span><br><span class="line">obj.__proto__=Father.prototype;</span><br><span class="line">Father.call(obj)  <span class="comment">// 继承的同时，将this指向obj  谁继承this指向谁</span></span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure><p>1.创建了一个空对象obj</p><p>2.将这个空对象<strong>proto</strong>指向构造函数的prototype</p><p>3.将构造函数的this指针替换成obj，然后在调用构造函数，于是obj对象就拥有了构造函数上的属性和方法</p><h3 id="模拟new"><a href="#模拟new" class="headerlink" title="模拟new"></a>模拟new</h3><p>new操作符做了这些事：</p><ul><li>它创建了一个全新的对象</li><li>它会被执行[[Prototype]]（也就是<strong>proto</strong>）链接</li><li>它使this指向新创建的对象</li><li>通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上</li><li>如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用将返回该对象引用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// objectFactory(name, &apos;cxk&apos;, &apos;18&apos;)</span><br><span class="line">function objectFactory() &#123;</span><br><span class="line">  const obj = new Object();</span><br><span class="line">  const Constructor = [].shift.call(arguments);</span><br><span class="line"></span><br><span class="line">  obj.__proto__ = Constructor.prototype;</span><br><span class="line"></span><br><span class="line">  const ret = Constructor.apply(obj, arguments);</span><br><span class="line"></span><br><span class="line">  return typeof ret === &quot;object&quot; ? ret : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="call-apply-bind-的区别"><a href="#call-apply-bind-的区别" class="headerlink" title="call/apply/bind 的区别"></a>call/apply/bind 的区别</h3><ol><li><p>三者都可用于显示绑定 <code>this</code>;</p></li><li><p><code>call/apply</code> 的区别方式在于参数传递方式的不同；</p><p><code>fn.call(obj, arg1, arg2, ...)</code>， <strong>传参数列表</strong>，以逗号隔开；作为 call 的参数传入（从第二个参数开始）。</p><p><code>fn.apply(obj, [arg1, arg2, ...])</code>， <strong>传参数数组</strong>；将多个参数组合成为一个数组传入。</p></li><li><p><code>bind</code> 返回的是一个<strong>待执行函数</strong>，是函数柯里化的应用；而 <code>call/apply</code> 则是<strong>立即执行函数</strong>；</p></li></ol><p>对于 apply 和 call 两者在作用上是相同的，即是<strong>调用一个对象的一个方法，以另一个对象替换当前对象</strong>。</p><p>将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。</p><h3 id="call-和-apply-的含义和区别？"><a href="#call-和-apply-的含义和区别？" class="headerlink" title="call() 和 apply() 的含义和区别？"></a>call() 和 apply() 的含义和区别？</h3><h4 id="含义："><a href="#含义：" class="headerlink" title="含义："></a>含义：</h4><ul><li><p>call：调用一个对象的一个方法，用另一个对象替换当前对象。</p><p>例如：B.call(A, args1,args2);即 A 对象调用 B 对象的方法。</p></li><li><p>apply：调用一个对象的一个方法，用另一个对象替换当前对象。</p><p>例如：B.apply(A, arguments);即 A 对象应用 B 对象的方法。</p></li></ul><h4 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h4><ul><li>方法的含义是一样的，即方法功能是一样的；</li><li>第一个参数的作用是一样的；</li></ul><h4 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h4><p>两者传入的列表形式不一样</p><ul><li>call 可以传入多个参数；</li><li>apply 只能传入两个参数，所以其第二个参数往往是作为数组形式传入</li></ul><h3 id="call-与-apply-区别"><a href="#call-与-apply-区别" class="headerlink" title="call 与 apply 区别"></a>call 与 apply 区别</h3><p>第二个参数的类型不同</p><p>解析：</p><p>call 和 apply 的作用，完全一样，唯一的区别就是在参数上面。</p><p>call 接收的参数不固定，第一个参数是函数体内 this 的指向，第二个参数以下是依次传入的参数。</p><p>apply 接收两个参数，第一个参数也是函数体内 this 的指向。第二个参数是一个集合对象（数组或者类数组）</p><h3 id="this-和-apply-的应用"><a href="#this-和-apply-的应用" class="headerlink" title="this 和 apply 的应用"></a>this 和 apply 的应用</h3><p>比如求数组的最大值 Math.max.apply(this, 数组)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">5</span>, <span class="number">458</span>, <span class="number">120</span>, <span class="number">-215</span>];</span><br><span class="line"><span class="keyword">var</span> maxInNumbers = <span class="built_in">Math</span>.max.apply(<span class="keyword">this</span>, numbers); <span class="comment">//第一个参数也可以填Math或null</span></span><br><span class="line"><span class="built_in">console</span>.log(maxInNumbers); <span class="comment">// 458</span></span><br><span class="line"><span class="keyword">var</span> maxInNumbers = <span class="built_in">Math</span>.max.call(<span class="keyword">this</span>, <span class="number">5</span>, <span class="number">458</span>, <span class="number">120</span>, <span class="number">-215</span>);</span><br><span class="line"><span class="built_in">console</span>.log(maxInNumbers); <span class="comment">// 458</span></span><br></pre></td></tr></table></figure><h3 id="bind、call、apply-的区别"><a href="#bind、call、apply-的区别" class="headerlink" title="bind、call、apply 的区别"></a>bind、call、apply 的区别</h3><p>call 和 apply 其实是一样的，区别就在于传参时参数是一个一个传或者是以一个数组的方式来传。<br>call 和 apply 都是在调用时生效，改变调用者的 this 指向。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let name = &apos;Jack&apos;</span><br><span class="line">const obj = &#123;name: &apos;Tom&apos;&#125;</span><br><span class="line">function sayHi() &#123;console.log(&apos;Hi! &apos; + this.name)&#125;</span><br><span class="line"></span><br><span class="line">sayHi() // Hi! Jack</span><br><span class="line">sayHi.call(obj) // Hi! Tom</span><br></pre></td></tr></table></figure><p>bind 也是改变 this 指向，不过不是在调用时生效，而是返回一个新函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const newFunc = sayHi.bind(obj)</span><br><span class="line">newFunc() // Hi! Tom</span><br></pre></td></tr></table></figure><h3 id="call，apply，bind-三者用法和区别"><a href="#call，apply，bind-三者用法和区别" class="headerlink" title="call，apply，bind 三者用法和区别"></a>call，apply，bind 三者用法和区别</h3><p>参数、绑定规则（显示绑定和强绑定），运行效率（最终都会转换成一个一个的参数去运行）、运行情况（<code>call</code>，<code>apply</code> 立即执行，<code>bind</code> 是<code>return</code> 出一个 <code>this</code> “固定”的函数，这也是为什么 <code>bind</code> 是强绑定的一个原因）</p><blockquote><p>注：“固定”这个词的含义，它指的固定是指只要传进去了 <code>context</code>，则 <code>bind</code> 中 <code>return</code> 出来的函数 <code>this</code> 便一直指向 <code>context</code>，除非 <code>context</code> 是个变量</p></blockquote><h3 id="call-和-apply-的区别？"><a href="#call-和-apply-的区别？" class="headerlink" title=".call() 和 .apply() 的区别？"></a>.call() 和 .apply() 的区别？</h3><ul><li>例子中用 add 来替换 sub，add.call(sub,3,1) == add(3,1) ，所以运行结果为：alert(4);</li><li>注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function add(a,b)</span><br><span class="line">&#123;</span><br><span class="line">    alert(a+b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sub(a,b)</span><br><span class="line">&#123;</span><br><span class="line">    alert(a-b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add.call(sub,3,1);</span><br></pre></td></tr></table></figure><h3 id="call-和-apply-的区别和作用？"><a href="#call-和-apply-的区别和作用？" class="headerlink" title=".call() 和 .apply() 的区别和作用？"></a>.call() 和 .apply() 的区别和作用？</h3><p>作用：动态改变某个类的某个方法的运行环境。<br>区别参见：<a href="http://segmentfault.com/blog/trigkit4/1190000000660786#articleHeader15" target="_blank" rel="noopener">JavaScript学习总结（四）function函数部分</a></p><h3 id="js-的事件循环eventloop是什么？"><a href="#js-的事件循环eventloop是什么？" class="headerlink" title="js 的事件循环eventloop是什么？"></a>js 的事件循环eventloop是什么？</h3><p>事件循环是一个单线程循环，用于监视调用堆栈并检查是否有工作即将在任务队列中完成。</p><p>如果调用堆栈为空并且任务队列中有回调函数，则将回调函数出队并推送到调用堆栈中执行。</p><ul><li><p>所有同步任务都在主线程上执行，形成一个执行栈</p></li><li><p>当主线程中的执行栈为空时，检查事件队列是否为空，如果为空，则继续检查；如不为空，则执行3</p></li><li><p>取出任务队列的首部，加入执行栈</p></li><li><p>执行任务</p></li><li><p>检查执行栈，如果执行栈为空，则跳回第 2 步；如不为空，则继续检查</p></li></ul><p>相关知识点：</p><p>事件队列是一个存储着待执行任务的队列，其中的任务严格按照时间先后顺序执行，排在队头的任务将会率先执行，而排在队尾的任务会最后执行。事件队列每次仅执行一个任务，在该任务执行完毕之后，再执行下一个任务。执行栈则是一个类似于函数调用栈的运行容器，当执行栈为空时，JS 引擎便检查事件队列，如果不为空的话，事件队列便将第一个任务压入执行栈中运行。</p><p>回答：</p><p>因为 js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。</p><p>当异步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。</p><p>当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。</p><h4 id="微任务（microtask）"><a href="#微任务（microtask）" class="headerlink" title="微任务（microtask）"></a>微任务（microtask）</h4><p>promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver</p><ul><li>process.nextTick</li><li>promise</li><li>Object.observe （已废弃）</li><li>MutationObserver</li></ul><h4 id="宏任务（macrotask）"><a href="#宏任务（macrotask）" class="headerlink" title="宏任务（macrotask）"></a>宏任务（macrotask）</h4><p>script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲染等</p><ul><li>script</li><li>setTimeout</li><li>setInterval</li><li>setImmediate</li><li>I/O</li><li>UI rendering</li></ul><h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><ol><li>执行同步代码，这属于宏任务</li><li>执行栈为空，查询是否有微任务需要执行</li><li>必要的话渲染 UI</li><li>然后开始下一轮 Event loop，执行宏任务中的异步代码</li></ol><p>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入 Event Table 并注册函数。</p><p>当指定的事情完成时，Event Table 会将这个函数移入 Event Queue。</p><p>主线程内的任务执行完毕为空，会去 Event Queue 读取对应的函数，进入主线程执行。 </p><p>上述过程会不断重复，也就是常说的 Event Loop(事件循环)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [];</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  url: www.javascript.com,</span><br><span class="line">  data: data,</span><br><span class="line">  success: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"发送成功!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"代码执行结束"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ajax进入Event Table，注册回调函数success。</span></span><br><span class="line"><span class="comment">// 执行console.log('代码执行结束')。</span></span><br><span class="line"><span class="comment">// ajax事件完成，回调函数success进入Event Queue。</span></span><br><span class="line"><span class="comment">// 主线程从Event Queue读取回调函数success并执行。</span></span><br></pre></td></tr></table></figure><p>详细资料可以参考：</p><p><a href="https://juejin.im/post/59e85eebf265da430d571f89" target="_blank" rel="noopener">《这一次，彻底弄懂 JavaScript 执行机制》</a></p><p><a href="https://juejin.im/post/5afbc62151882542af04112d" target="_blank" rel="noopener">《浏览器事件循环机制（event loop）》</a></p><p><a href="https://zhuanlan.zhihu.com/p/33058983" target="_blank" rel="noopener">《详解 JavaScript 中的 Event Loop（事件循环）机制》</a></p><p><a href="http://www.ruanyifeng.com/blog/2013/10/event_loop.html" target="_blank" rel="noopener">《什么是 Event Loop？》</a></p><h3 id="回流（reflow）和重绘（repaint）"><a href="#回流（reflow）和重绘（repaint）" class="headerlink" title="回流（reflow）和重绘（repaint）"></a>回流（reflow）和重绘（repaint）</h3><blockquote><p>传送门 <a href="https://segmentfault.com/a/1190000014070240?utm_source=feed-content" target="_blank" rel="noopener">DOM 操作成本到底高在哪儿？</a></p></blockquote><p><strong>reflow(回流)</strong>: 根据 Render Tree 布局(几何属性)，意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树；</p><p><strong>repaint(重绘)</strong>: 意味着元素发生的改变只影响了节点的一些样式（背景色，边框颜色，文字颜色等），只需要应用新样式绘制这个元素就可以了；</p><p>reflow 回流的成本开销要高于 repaint 重绘，一个节点的回流往往回导致子节点以及同级节点的回流；</p><h4 id="引起-reflow-回流"><a href="#引起-reflow-回流" class="headerlink" title="引起 reflow 回流"></a>引起 reflow 回流</h4><ol><li>页面第一次渲染（初始化）</li><li>DOM 树变化（如：增删节点）</li><li>Render 树变化（如：padding 改变）</li><li>浏览器窗口 resize</li><li>获取元素的某些属性：</li><li>浏览器为了获得正确的值也会提前触发回流，这样就使得浏览器的优化失效了，这些属性包括 offsetLeft、offsetTop、offsetWidth、offsetHeight、 scrollTop/Left/Width/Height、clientTop/Left/Width/Height、调用了 getComputedStyle()或者 IE 的 currentStyle</li></ol><h4 id="引起-repaint-重绘"><a href="#引起-repaint-重绘" class="headerlink" title="引起 repaint 重绘"></a>引起 repaint 重绘</h4><ol><li>reflow 回流必定引起 repaint 重绘，重绘可以单独触发</li><li>背景色、颜色、字体改变（注意：字体大小发生变化时，会触发回流）</li></ol><h4 id="优化方式"><a href="#优化方式" class="headerlink" title="优化方式"></a>优化方式</h4><ol><li>避免逐个修改节点样式，尽量一次性修改</li><li>使用 DocumentFragment 将需要多次修改的 DOM 元素缓存，最后一次性 append 到真实 DOM 中渲染</li><li>可以将需要多次修改的 DOM 元素设置 display: none，操作完再显示。（因为隐藏元素不在 render 树内，因此修改隐藏元素不会触发回流重绘）</li><li>避免多次读取某些属性（见上）</li><li>将复杂的节点元素脱离文档流，降低回流成本</li></ol><p><strong>为什么一再强调将 css 放在头部，将 js 文件放在尾部</strong> + DOMContentLoaded 和 load </p><p>DOMContentLoaded 事件触发时，仅当 DOM 加载完成，不包括样式表，图片… </p><p>load 事件触发时，页面上所有的 DOM，样式表，脚本，图片都已加载完成 + CSS 资源阻塞渲染 </p><ol><li>构建 Render 树需要 DOM 和 CSSOM，所以 HTML 和 CSS 都会阻塞渲染。所以需要让 CSS 尽早加载（如：放在头部），以缩短首次渲染的时间。 + JS 资源 1. 阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析 HTML - 这和之前文章提到的浏览器线程有关，浏览器中 js 引擎线程和渲染线程是互斥的，详见<a href="https://segmentfault.com/a/1190000013702430#articleHeader2" target="_blank" rel="noopener">《从 setTimeout-setInterval 看 JS 线程》</a> </li><li>普通的脚本会阻塞浏览器解析，加上 defer 或 async 属性，脚本就变成异步，可等到解析完毕再执行 - async 异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在 onload 前，但不确定在 DOMContentLoaded 事件的前后 - defer 延迟执行，相对于放在 body 最后（理论上在 DOMContentLoaded 事件前）</li></ol><h3 id="如何最小化重绘-repaint-和回流-reflow-？"><a href="#如何最小化重绘-repaint-和回流-reflow-？" class="headerlink" title="如何最小化重绘(repaint)和回流(reflow)？"></a>如何最小化重绘(repaint)和回流(reflow)？</h3><ul><li><p>尽量避免用table布局（table元素一旦触发回流就会导致table里所有的其它元素回流，造成整个 table 的重新布局）</p></li><li><p><code>CSS</code> 选择符从右往左匹配查找，避免 <code>DOM</code> 深度过深</p></li><li><p>避免使用css表达式(expression)，因为每次调用都会重新计算值（包括加载页面）</p></li><li><p>尽量使用 css 属性简写，如：用 border 代替 border-width, border-style, border-color</p></li><li><p>批量修改元素样式：elem.className 和 elem.style.cssText 代替 elem.style.xxx</p></li><li><p>使用 <code>translate</code> 替代 <code>top</code></p></li><li><p>使用 <code>visibility</code> 替换<code>display: none</code> ，因为前者只会引起重绘，后者会引发回流（改变了布局）</p></li><li><p>需要要对元素进行复杂的操作时，可以先隐藏(display:”none”)，操作完成后再显示</p></li><li><p>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 <code>requestAnimationFrame</code></p></li><li><p>将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 <code>video</code>标签，浏览器会自动将该节点变为图层</p></li><li><p>需要创建多个DOM节点时，使用DocumentFragment创建完后一次性的加入document</p></li><li><p>缓存Layout属性值，如：var left = elem.offsetLeft; 这样，多次使用 left 只产生一次回流</p></li></ul><h3 id="重绘和回流（重排）的区别和关系？"><a href="#重绘和回流（重排）的区别和关系？" class="headerlink" title="重绘和回流（重排）的区别和关系？"></a>重绘和回流（重排）的区别和关系？</h3><ul><li>重绘：当渲染树中的元素外观（如：颜色）发生改变，不影响布局时，产生重绘</li><li>回流：当渲染树中的元素的布局（如：尺寸、位置、隐藏/状态状态）或者几何属性发生改变时，产生重绘回流</li><li>注意：JS获取Layout属性值（如：offsetLeft、scrollTop、getComputedStyle等）也会引起回流。因为浏览器需要通过回流计算最新值</li><li>回流必将引起重绘，而重绘不一定会引起回流。</li><li>回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流。</li></ul><p><strong>所以以下几个动作可能会导致性能问题</strong>：</p><ul><li>改变 window 大小</li><li>改变字体</li><li>添加或删除样式</li><li>文字改变</li><li>定位或者浮动</li><li>盒模型</li></ul><p><strong>很多人不知道的是，重绘和回流其实和 Event loop 有关</strong></p><ul><li>当 Event loop 执行完 <code>Microtasks</code> 后，会判断 <code>document</code> 是否需要更新。因为浏览器是 <code>60Hz</code>的刷新率，每 <code>16ms</code>才会更新一次。</li><li>然后判断是否有 <code>resize</code> 或者 <code>scroll</code> ，有的话会去触发事件，所以 <code>resize</code> 和 <code>scroll</code> 事件也是至少 <code>16ms</code> 才会触发一次，并且自带节流功能。</li><li>判断是否触发了<code>media query</code></li><li>更新动画并且发送事件</li><li>判断是否有全屏操作事件</li><li>执行 <code>requestAnimationFrame</code> 回调</li><li>执行 <code>IntersectionObserver</code> 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好</li><li>更新界面</li><li>以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 <code>requestIdleCallback</code> 回调</li></ul><h3 id="重排与重绘的区别，什么情况下会触发？"><a href="#重排与重绘的区别，什么情况下会触发？" class="headerlink" title="重排与重绘的区别，什么情况下会触发？"></a>重排与重绘的区别，什么情况下会触发？</h3><h4 id="简述重排的概念"><a href="#简述重排的概念" class="headerlink" title="简述重排的概念"></a>简述重排的概念</h4><p>浏览器下载完页面中的所有组件（HTML、JavaScript、CSS、图片）之后会解析生成两个内部数据结构（DOM 树和渲染树），DOM 树表示页面结构，渲染树表示 DOM 节点如何显示。</p><p><strong>重排是 DOM 元素的几何属性变化，DOM 树的结构变化，渲染树需要重新计算。</strong></p><h4 id="简述重绘的概念"><a href="#简述重绘的概念" class="headerlink" title="简述重绘的概念"></a>简述重绘的概念</h4><p>重绘是一个<strong>元素外观的改变所触发的浏览器行为</strong>，例如改变 visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。由于浏览器的流布局，对渲染树的计算通常只需要遍历一次就可以完成。但 table 及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花两倍时间，这就是我们尽量避免使用 table 布局页面的原因之一。</p><h4 id="简述重绘和重排的关系"><a href="#简述重绘和重排的关系" class="headerlink" title="简述重绘和重排的关系"></a>简述重绘和重排的关系</h4><p><strong>重绘不会引起重排，但重排一定会引起重绘</strong>，一个元素的重排通常会带来一系列的反应，甚至触发整个文档的重排和重绘，性能代价是高昂的。</p><h4 id="什么情况下会触发重排？"><a href="#什么情况下会触发重排？" class="headerlink" title="什么情况下会触发重排？"></a>什么情况下会触发重排？</h4><ul><li>页面渲染初始化时；（这个无法避免）</li><li>浏览器窗口改变尺寸；</li><li>元素尺寸改变时；</li><li>元素位置改变时；</li><li>元素内容改变时；</li><li>添加或删除可见的 DOM 元素时。</li></ul><h4 id="重排优化有如下五种方法"><a href="#重排优化有如下五种方法" class="headerlink" title="重排优化有如下五种方法"></a>重排优化有如下五种方法</h4><ul><li>将多次改变样式属性的操作合并成一次操作，减少 DOM 访问。</li><li>如果要批量添加 DOM，可以先让元素脱离文档流，操作完后再带入文档流，这样只会触发一次重排。（fragment 元素的应用）</li><li>将需要多次重排的元素，position 属性设为 absolute 或 fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位。</li><li>由于 display 属性为 none 的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发两次重排。</li><li>在内存中多次操作节点，完成后再添加到文档中去。例如要异步获取表格数据，渲染到页面。可以先取得数据后在内存中构建整个表格的 html 片段，再一次性添加到文档中去，而不是循环添加每一行。</li></ul><h3 id="一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）"><a href="#一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）" class="headerlink" title="一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）"></a>一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）</h3><blockquote><p>注：这题胜在区分度高，知识点覆盖广，再不懂的人，也能答出几句，</p><p>而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、</p><p>到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等；</p></blockquote><p>详细版：</p><ul><li>浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;</li><li>调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;</li><li>通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;</li><li>进行HTTP协议会话，客户端发送报头(请求报头);</li><li>进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;</li><li>进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;</li><li>处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;</li><li>浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;</li><li>文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;</li><li>页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。</li></ul><p>简洁版：</p><ul><li>浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；</li><li>服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；</li><li>浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；</li><li>载入解析到的资源文件，渲染页面，完成。</li></ul><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><h4 id="方案1：ES6"><a href="#方案1：ES6" class="headerlink" title="方案1：ES6"></a>方案1：ES6</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const numbers = [1, 2, 1, 1, 2, 1, 3, 4, 1 ];</span><br><span class="line">const uniq = [...new Set(numbers)] // =&gt; [ 1, 2, 3, 4 ];</span><br><span class="line">const uniq2 = Array.from(new Set(numbers)) // =&gt; [ 1, 2, 3, 4 ];</span><br></pre></td></tr></table></figure><h4 id="方案2：filter"><a href="#方案2：filter" class="headerlink" title="方案2：filter"></a>方案2：filter</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function unique (arr) &#123;</span><br><span class="line">     var res = arr.filter(function (item, index, array) &#123;</span><br><span class="line">     // array.indexOf(item) === index 说明这个元素第一次出现，后面这个item再出现他的item肯定不是index了</span><br><span class="line">         return array.indexOf(item) === index; </span><br><span class="line">&#125;) return res; &#125;</span><br></pre></td></tr></table></figure><h4 id="方案3"><a href="#方案3" class="headerlink" title="方案3"></a>方案3</h4><p>遍历数组，建立新数组，利用indexOf判断是否存在于新数组中，不存在则push到新数组，最后返回新数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function unique(ar) &#123;</span><br><span class="line">    var ret = [];</span><br><span class="line"></span><br><span class="line">    for (var i = 0, j = ar.length; i &lt; j; i++) &#123;</span><br><span class="line">        if (ret.indexOf(ar[i]) === -1) &#123;</span><br><span class="line">            ret.push(ar[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方案4"><a href="#方案4" class="headerlink" title="方案4"></a>方案4</h4><p>遍历数组，利用object对象保存数组值，判断数组值是否已经保存在object中，未保存则push到新数组并用object[arrayItem]=1的方式记录保存，这个效率比方案3高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function unique(ar) &#123;</span><br><span class="line">    var tmp = &#123;&#125;,</span><br><span class="line">        ret = [];</span><br><span class="line"></span><br><span class="line">    for (var i = 0, j = ar.length; i &lt; j; i++) &#123;</span><br><span class="line">        if (!tmp[ar[i]]) &#123;</span><br><span class="line">            tmp[ar[i]] = 1;</span><br><span class="line">            ret.push(ar[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="中高级前端面试必知必会"><a href="#中高级前端面试必知必会" class="headerlink" title="中高级前端面试必知必会"></a>中高级前端面试必知必会</h1><h2 id="Chrome-浏览器进程"><a href="#Chrome-浏览器进程" class="headerlink" title="Chrome 浏览器进程"></a>Chrome 浏览器进程</h2><blockquote><p>在资源不足的设备上，将服务合并到浏览器进程中</p></blockquote><h3 id="浏览器主进程"><a href="#浏览器主进程" class="headerlink" title="浏览器主进程"></a>浏览器主进程</h3><ul><li>负责浏览器界面显示</li><li>各个页面的管理，创建以及销毁</li><li>将渲染进程的结果绘制到用户界面上</li><li>网络资源管理</li></ul><h3 id="GPU-进程"><a href="#GPU-进程" class="headerlink" title="GPU 进程"></a>GPU 进程</h3><ul><li>用于 3D 渲染绘制</li></ul><h3 id="网络进程"><a href="#网络进程" class="headerlink" title="网络进程"></a>网络进程</h3><ul><li>发起网络请求</li></ul><h3 id="插件进程"><a href="#插件进程" class="headerlink" title="插件进程"></a>插件进程</h3><ul><li>第三方插件处理，运行在沙箱中</li></ul><h3 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h3><ul><li>页面渲染</li><li>脚本执行</li><li>事件处理</li></ul><h2 id="网络传输流程"><a href="#网络传输流程" class="headerlink" title="网络传输流程"></a>网络传输流程</h2><h3 id="生成-HTTP-请求消息"><a href="#生成-HTTP-请求消息" class="headerlink" title="生成 HTTP 请求消息"></a>生成 HTTP 请求消息</h3><ol><li><p>输入网址</p></li><li><p>浏览浏览器解析 URL</p></li><li><p>生成 HTTP 请求信息</p><p><img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/y0rsINPrlZwiaiaDhnq7zdoCEsbMhMzSk7u6oElshWJ46iaORk0ShuVEZr0QNT2KbbYBdUzrD5PdSpFllUWKwW7DA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p><img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/y0rsINPrlZwiaiaDhnq7zdoCEsbMhMzSk7Flia7qJfMgWFypTBQO4wSwJvkRgIXicn9sujJ3JGqXgunNBJoEQibBuWQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p></li><li><p>收到响应</p><table><thead><tr><th align="left">状态码</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">1xx</td><td align="left">告知请求的处理进度和情况</td></tr><tr><td align="left">2xx</td><td align="left">成功</td></tr><tr><td align="left">3xx</td><td align="left">表示需要进一步操作</td></tr><tr><td align="left">4xx</td><td align="left">客户端错误</td></tr><tr><td align="left">5xx</td><td align="left">服务端错误</td></tr></tbody></table></li></ol><h3 id="向-DNS-服务器查询-Web-服务器的-IP-地址"><a href="#向-DNS-服务器查询-Web-服务器的-IP-地址" class="headerlink" title="向 DNS 服务器查询 Web 服务器的 IP 地址"></a>向 DNS 服务器查询 Web 服务器的 IP 地址</h3><ol><li>Socket 库提供查询 IP 地址的功能</li><li>通过解析器向 DNS 服务器发出查询</li></ol><h3 id="全世界-DNS-服务器的大接力"><a href="#全世界-DNS-服务器的大接力" class="headerlink" title="全世界 DNS 服务器的大接力"></a>全世界 DNS 服务器的大接力</h3><ol><li>寻找相应的 DNS 服务器并获取 IP 地址</li><li>通过缓存加快 DNS 服务器的响应</li></ol><h3 id="委托协议栈发送消息"><a href="#委托协议栈发送消息" class="headerlink" title="委托协议栈发送消息"></a>委托协议栈发送消息</h3><blockquote><p>协议栈通过 TCP 协议收发数据的操作。</p></blockquote><ol><li>创建套接字</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/y0rsINPrlZwiaiaDhnq7zdoCEsbMhMzSk7A1rqCUkoCoD5GOukw4ETP2lQicMxKibgHLKaFbqzeAjRFV2o40phPhGQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><ul><li>浏览器，邮件等一般的应用程序收发数据时用 TCP</li><li>DNS 查询等收发较短的控制数据时用 UDP</li></ul><ol><li>连接服务器</li></ol><blockquote><p>浏览器调用 Socket.connect</p></blockquote><ul><li>在 TCP 模块处创建表示连接控制信息的头部</li><li>通过 TCP 头部中的发送方和接收方端口号找到要连接的套接字</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/y0rsINPrlZwiaiaDhnq7zdoCEsbMhMzSk7GwcQ5QiaFLjibTicleT7Izkc9WGFYzUvwkbFRZpDGV5oH9sTSNo61icibyw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><ol><li>收发数据</li></ol><blockquote><p>浏览器调用 Socket.write</p></blockquote><ul><li><p>将 HTTP 请求消息交给协议栈</p></li><li><p>对较大的数据进行拆分，拆分的每一块数据加上 TCP 头，由 IP 模块来发送</p></li><li><p>使用 ACK 号确认网络包已收到</p></li><li><p>根据网络包平均往返时间调整 ACK 号等待时间</p></li><li><p>使用窗口有效管理 ACK 号</p><p><img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/y0rsINPrlZwiaiaDhnq7zdoCEsbMhMzSk7vGw4vghYWZjFlCviaJKpibPyFPLJbcNTYD5WdDmznibJ3x81VtPxuNMjw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p></li><li><p>ACK 与窗口的合并</p></li><li><p>接收 HTTP 响应消息</p></li></ul><ol><li>断开管道并删除套接字</li></ol><blockquote><p>浏览器调用 Socket.close</p></blockquote><ul><li><p>数据发送完毕后断开连接</p><p><img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/y0rsINPrlZwiaiaDhnq7zdoCEsbMhMzSk7zcLBK07icxeYSXyCgW9AhBBokALyPNy0qwpxcDg7PqsxMHPjBEYKeMA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p></li><li><p>删除套接字</p></li><li><ol><li>客户端发送 FIN</li><li>服务端返回 ACK 号</li><li>服务端发送 FIN</li><li>客户端返回 ACK 号</li></ol></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/y0rsINPrlZwiaiaDhnq7zdoCEsbMhMzSk7HkgGQnMsoLM1CJrL1BK4Iycqb4y9DBlxWmVs9AiaHw1qmxcO9AwCgHA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/y0rsINPrlZwiaiaDhnq7zdoCEsbMhMzSk7d7gS9bmwv4o0tFJlQJCN8qYvDhENHGr6YnF8T2PVsL3YSrqVWtxiaKw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><blockquote><p>同源策略是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。</p></blockquote><p>如果两个 URL 的 <strong>protocol</strong> 、 <strong>port</strong> (如果有指定的话)和 <strong>host</strong> 都相同的话，则这两个 URL 是同源。</p><p>例如：</p><table><thead><tr><th align="left">URL</th><th align="left">结果</th><th align="left">原因</th></tr></thead><tbody><tr><td align="left"><code>http://store.company.com/dir2/other.html</code></td><td align="left">同源</td><td align="left">只有路径不同</td></tr><tr><td align="left"><code>http://store.company.com/dir/inner/another.html</code></td><td align="left">同源</td><td align="left">只有路径不同</td></tr><tr><td align="left"><code>https://store.company.com/secure.html</code></td><td align="left">失败</td><td align="left">协议不同</td></tr><tr><td align="left"><code>http://store.company.com:81/dir/etc.html</code></td><td align="left">失败</td><td align="left">端口不同 ( <code>http://</code> 默认端口是80)</td></tr><tr><td align="left"><code>http://news.company.com/dir/other.html</code></td><td align="left">失败</td><td align="left">主机不同</td></tr></tbody></table><h3 id="主要的跨域处理"><a href="#主要的跨域处理" class="headerlink" title="主要的跨域处理"></a>主要的跨域处理</h3><p><strong>JSONP</strong></p><p>JSONP的原理是：静态资源请求不受同源策略影响。实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const script = document.createElement(&apos;script&apos;)</span><br><span class="line">script.type = &apos;text/javascript&apos;</span><br><span class="line">script.src = &apos;https://www.domain.com/a?data=1&amp;callback=cb&apos;</span><br><span class="line">const cb = res =&gt; &#123;</span><br><span class="line">    console.log(JSON.stringify(res))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CORS</strong></p><p>CORS：跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器  让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。</p><p>在各种服务端代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 根据不同语言规则，具体语法有所不同，此处以NodeJs的express为例</span><br><span class="line">//设置跨域访问  </span><br><span class="line">app.all(&apos;*&apos;, function(req, res, next) &#123;  </span><br><span class="line">    res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);  </span><br><span class="line">    res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;);  </span><br><span class="line">    res.header(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;);</span><br><span class="line">    next();  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Nginx实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    add_header Access-Control-Allow-Credentials true;</span><br><span class="line">    add_header Access-Control-Allow-Origin $http_origin;</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">    location /file &#123;</span><br><span class="line">        if ($request_method = &apos;OPTIONS&apos;) &#123;</span><br><span class="line">            add_header Access-Control-Allow-Origin $http_origin;</span><br><span class="line">            add_header Access-Control-Allow-Methods $http_access_control_request_method;</span><br><span class="line">            add_header Access-Control-Allow-Credentials true;</span><br><span class="line">            add_header Access-Control-Allow-Headers $http_access_control_request_headers;</span><br><span class="line">            add_header Access-Control-Max-Age 1728000;</span><br><span class="line">            return 204;</span><br><span class="line">        &#125;         </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/y0rsINPrlZwiaiaDhnq7zdoCEsbMhMzSk73M6kkzgomFeGIlkj7nibFl8jL1KicOE9a4u46pyQokeMibJVRRnwH3Lrg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793 定义。</p><ul><li>基于流的方式</li><li>面向连接</li><li>丢包重传</li><li>保证数据顺序</li></ul><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>Internet 协议集支持一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。RFC 768 描述了 UDP。</p><ul><li>UDP 是非连接的协议，也就是不会跟终端建立连接</li><li>UDP 包信息只有 8 个字节</li><li>UDP 是面向报文的。既不拆分，也不合并，而是保留这些报文的边界</li><li>UDP 可能丢包</li><li>UDP 不保证数据顺序</li></ul><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><ul><li><p>HTTP/0.9：GET，无状态的特点形成</p></li><li><p>HTTP/1.0：支持 POST，HEAD，添加了请求头和响应头，支持任何格式的文件发送，添加了状态码、多字符集支持、多部分发送、权限、缓存、内容编码等</p></li><li><p>HTTP/1.1：默认长连接，同时 6 个 TCP 连接，CDN 域名分片</p></li><li><p>HTTPS：HTTP + TLS（ <strong>非对称加密</strong> 与 <strong>对称加密</strong> ）</p></li><li><ol><li>客户端发出 https 请求，请求服务端建立 SSL 连接</li><li>服务端收到 https 请求，申请或自制数字证书，得到公钥和服务端私钥，并将公钥发送给客户端</li><li>户端验证公钥，不通过验证则发出警告，通过验证则产生一个随机的客户端私钥</li><li>客户端将公钥与客户端私钥进行对称加密后传给服务端</li><li>服务端收到加密内容后，通过服务端私钥进行非对称解密，得到客户端私钥</li><li>服务端将客户端私钥和内容进行对称加密，并将加密内容发送给客户端</li><li>客户端收到加密内容后，通过客户端私钥进行对称解密，得到内容</li></ol></li><li><p>HTTP/2.0：多路复用（一次 TCP 连接可以处理多个请求），服务器主动推送，stream 传输。</p></li><li><p>HTTP/3：基于 UDP 实现了 QUIC 协议</p></li><li><ul><li>建立好 HTTP2 连接</li><li>发送 HTTP2 扩展帧</li><li>使用 QUIC 建立连接</li><li>如果成功就断开 HTTP2 连接</li><li>升级为 HTTP3 连接</li></ul></li></ul><p><strong>注：RTT = Round-trip time</strong></p><h2 id="页面渲染流程"><a href="#页面渲染流程" class="headerlink" title="页面渲染流程"></a>页面渲染流程</h2><blockquote><p>构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成</p></blockquote><ol><li><p>创建 DOM tree</p></li><li><ul><li>遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中。</li><li>不可见的节点会被布局树忽略掉。</li></ul></li><li><p>样式计算</p></li><li><ul><li>创建 CSSOM tree</li><li>转换样式表中的属性值</li><li>计算出 DOM 节点样式</li></ul></li><li><p>生成 layout tree</p></li><li><p>分层</p></li><li><ul><li>生成图层树（LayerTree）</li><li>拥有层叠上下文属性的元素会被提升为单独的一层</li><li>需要剪裁（clip）的地方也会被创建为图层</li><li>图层绘制</li></ul></li><li><p>将图层转换为位图</p></li><li><p>合成位图并显示在页面中</p></li></ol><h2 id="页面更新机制"><a href="#页面更新机制" class="headerlink" title="页面更新机制"></a>页面更新机制</h2><ul><li><p>更新了元素的几何属性（重排）</p></li><li><p>更新元素的绘制属性（重绘）</p></li><li><p>直接合成</p></li><li><ul><li>CSS3 的属性可以直接跳到这一步</li></ul></li></ul><h2 id="JS-执行机制"><a href="#JS-执行机制" class="headerlink" title="JS 执行机制"></a>JS 执行机制</h2><h3 id="代码提升（为了编译）"><a href="#代码提升（为了编译）" class="headerlink" title="代码提升（为了编译）"></a>代码提升（为了编译）</h3><ul><li>变量提升</li><li>函数提升（优先级最高）</li></ul><h3 id="编译代码"><a href="#编译代码" class="headerlink" title="编译代码"></a>编译代码</h3><p><strong>V8 编译 JS 代码的过程</strong></p><ol><li><p>生成抽象语法树（AST）和执行上下文</p></li><li><p>第一阶段是分词（tokenize），又称为词法分析</p></li><li><p>第二阶段是解析（parse），又称为语法分析</p></li><li><p>生成字节码</p><p>字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。</p></li><li><p>执行代码</p></li></ol><p><strong>高级语言编译器步骤：</strong></p><ol><li>输入源程序字符流</li><li>词法分析</li><li>语法分析</li><li>语义分析</li><li>中间代码生成</li><li>机器无关代码优化</li><li>代码生成</li><li>机器相关代码优化</li><li>目标代码生成</li></ol><h3 id="执行代码"><a href="#执行代码" class="headerlink" title="执行代码"></a>执行代码</h3><ul><li>执行全局代码时，创建全局上下文</li><li>调用函数时，创建函数上下文</li><li>使用 eval 函数时，创建 eval 上下文</li><li>执行局部代码时，创建局部上下文</li></ul><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ul><li>Undefined</li><li>Null</li><li>Boolean</li><li>String</li><li>Symbol</li><li>Number</li><li>Object</li><li>BigInt</li></ul><h3 id="复杂类型"><a href="#复杂类型" class="headerlink" title="复杂类型"></a>复杂类型</h3><ul><li>Object</li></ul><h2 id="隐式转换规则"><a href="#隐式转换规则" class="headerlink" title="隐式转换规则"></a>隐式转换规则</h2><h3 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h3><ul><li>转换为布尔值</li><li>转换为数字</li><li>转换为字符串</li></ul><h3 id="转换为原始类型"><a href="#转换为原始类型" class="headerlink" title="转换为原始类型"></a>转换为原始类型</h3><p>对象在转换类型的时候，会执行原生方法 <strong>ToPrimitive</strong> 。</p><p>其算法如下：</p><ol><li>如果已经是 <strong>原始类型</strong>，则返回当前值；</li><li>如果需要转 <strong>字符串</strong> 则先调用<code>toSting</code>方法，如果此时是 <strong>原始类型</strong> 则直接返回，否则再调用<code>valueOf</code>方法并返回结果；</li><li>如果不是 <strong>字符串</strong>，则先调用<code>valueOf</code>方法，如果此时是 <strong>原始类型</strong> 则直接返回，否则再调用<code>toString</code>方法并返回结果；</li><li>如果都没有 <strong>原始类型</strong> 返回，则抛出 <strong>TypeError</strong> 类型错误。</li></ol><p>当然，我们可以通过重写<code>Symbol.toPrimitive</code>来制定转换规则，此方法在转原始类型时调用优先级最高。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const data = &#123;</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString() &#123;</span><br><span class="line">    return &quot;1&quot;;</span><br><span class="line">  &#125;,</span><br><span class="line">  [Symbol.toPrimitive]() &#123;</span><br><span class="line">    return 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">data + 1; // 3</span><br></pre></td></tr></table></figure><h3 id="转换为布尔值"><a href="#转换为布尔值" class="headerlink" title="转换为布尔值"></a>转换为布尔值</h3><p>对象转换为布尔值的规则如下表：</p><table><thead><tr><th align="left">参数类型</th><th align="left">结果</th></tr></thead><tbody><tr><td align="left">Undefined</td><td align="left">返回 <code>false</code>。</td></tr><tr><td align="left">Null</td><td align="left">返回 <code>false</code>。</td></tr><tr><td align="left">Boolean</td><td align="left">返回 当前参数。</td></tr><tr><td align="left">Number</td><td align="left">如果参数为<code>+0</code>、<code>-0</code>或<code>NaN</code>，则返回 <code>false</code>；其他情况则返回 <code>true</code>。</td></tr><tr><td align="left">String</td><td align="left">如果参数为空字符串，则返回 <code>false</code>；否则返回 <code>true</code>。</td></tr><tr><td align="left">Symbol</td><td align="left">返回 <code>true</code>。</td></tr><tr><td align="left">Object</td><td align="left">返回 <code>true</code>。</td></tr></tbody></table><h3 id="转换为数字"><a href="#转换为数字" class="headerlink" title="转换为数字"></a>转换为数字</h3><p>对象转换为数字的规则如下表：</p><table><thead><tr><th align="left">参数类型</th><th align="left">结果</th></tr></thead><tbody><tr><td align="left">Undefined</td><td align="left">返回 <code>NaN</code>。</td></tr><tr><td align="left">Null</td><td align="left">Return +0.</td></tr><tr><td align="left">Boolean</td><td align="left">如果参数为 <code>true</code>，则返回 <code>1</code>；<code>false</code>则返回 <code>+0</code>。</td></tr><tr><td align="left">Number</td><td align="left">返回当前参数。</td></tr><tr><td align="left">String</td><td align="left">先调用 <strong>ToPrimitive</strong> ，再调用 <strong>ToNumber</strong> ，然后返回结果。</td></tr><tr><td align="left">Symbol</td><td align="left">抛出 <code>TypeError</code>错误。</td></tr><tr><td align="left">Object</td><td align="left">先调用 <strong>ToPrimitive</strong> ，再调用 <strong>ToNumber</strong> ，然后返回结果。</td></tr></tbody></table><h3 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h3><p>对象转换为字符串的规则如下表：</p><table><thead><tr><th align="left">参数类型</th><th align="left">结果</th></tr></thead><tbody><tr><td align="left">Undefined</td><td align="left">返回 <code>&quot;undefined&quot;</code>。</td></tr><tr><td align="left">Null</td><td align="left">返回 <code>&quot;null&quot;</code>。</td></tr><tr><td align="left">Boolean</td><td align="left">如果参数为 <code>true</code> ,则返回 <code>&quot;true&quot;</code>；否则返回 <code>&quot;false&quot;</code>。</td></tr><tr><td align="left">Number</td><td align="left">调用 <strong>NumberToString</strong> ，然后返回结果。</td></tr><tr><td align="left">String</td><td align="left">返回 当前参数。</td></tr><tr><td align="left">Symbol</td><td align="left">抛出 <code>TypeError</code>错误。</td></tr><tr><td align="left">Object</td><td align="left">先调用 <strong>ToPrimitive</strong> ，再调用 <strong>ToString</strong> ，然后返回结果。</td></tr></tbody></table><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>this 是和执行上下文绑定的。</p><p><strong>执行上下文：</strong></p><ul><li>全局执行上下文：全局执行上下文中的 this 也是指向 window 对象。</li><li>函数执行上下文：使用对象来调用其内部的一个方法，该方法的 this 是指向对象本身的。</li><li>eval 执行上下文：执行 eval 环境内部的上两个情况。</li></ul><p>根据优先级最高的来决定 <code>this</code> 最终指向哪里。</p><p>首先，<code>new</code> 的方式优先级最高，接下来是 <code>bind</code> 这些函数，然后是 <code>obj.foo()</code> 这种调用方式，最后是 <code>foo</code> 这种调用方式，同时，箭头函数的 <code>this</code> 一旦被绑定，就不会再被任何方式所改变。</p><p>三点注意：</p><ol><li>当函数作为对象的方法调用时，函数中的 this 就是该对象；</li><li>当函数被正常调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象 window；</li><li>嵌套函数中的 this 不会继承外层函数的 this 值。</li><li>我们还提了一下箭头函数，因为箭头函数没有自己的执行上下文，所以箭头函数的 this 就是它外层函数的 this。</li></ol><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p><strong>没有被引用的闭包会被自动回收，但还存在全局变量中，则依然会内存泄漏。</strong></p><p>在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var getNum;</span><br><span class="line">function getCounter() &#123;</span><br><span class="line">  var n = 1;</span><br><span class="line">  var inner = function() &#123;</span><br><span class="line">    n++;return n;</span><br><span class="line">  &#125;;</span><br><span class="line">  return inner;</span><br><span class="line">&#125;</span><br><span class="line">getNum = getCounter();</span><br><span class="line">getNum(); // 2</span><br><span class="line">getNum(); // 3</span><br><span class="line">getNum(); // 4</span><br><span class="line">getNum(); // 5</span><br></pre></td></tr></table></figure><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。</p><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p>函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。</p><h3 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h3><p>使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句，甚至单独的一个{}都可以被看作是一个块级作用域。</p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。</p><p>词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系。</p><h2 id="原型-amp-原型链"><a href="#原型-amp-原型链" class="headerlink" title="原型&amp;原型链"></a>原型&amp;原型链</h2><p>其实每个 JS 对象都有 <code>__proto__</code> 属性，这个属性指向了原型。</p><p>原型也是一个对象，并且这个对象中包含了很多函数，对于 <code>obj</code> 来说，可以通过 <code>__proto__</code> 找到一个原型对象，在该对象中定义了很多函数让我们来使用。</p><p>原型链：</p><ul><li><code>Object</code> 是所有对象的爸爸，所有对象都可以通过 <code>__proto__</code> 找到它</li><li><code>Function</code> 是所有函数的爸爸，所有函数都可以通过 <code>__proto__</code> 找到它</li><li>函数的 <code>prototype</code> 是一个对象</li><li>对象的 <code>__proto__</code> 属性指向原型， <code>__proto__</code> 将对象和原型连接起来组成了原型链</li></ul><h2 id="V8-工作原理"><a href="#V8-工作原理" class="headerlink" title="V8 工作原理"></a>V8 工作原理</h2><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><ul><li>栈空间：先进后出的数据结构，调用栈，存储执行上下文，以及存储原始类型的数据。</li><li>堆空间：用数组实现的二叉树，存储引用类型。堆空间很大，能存放很多大的数据。存放在堆内存中的对象，变量实际保存的是一个指针，这个指针指向另一个位置。</li></ul><p>原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。</p><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><ul><li><p>回收调用栈内的数据：执行上下文结束且没有被引用时，则会通过向下移动 <strong>记录当前执行状态的指针（称为 ESP）</strong> 来销毁该函数保存在栈中的执行上下文。</p></li><li><p>回收堆里的数据：</p><blockquote><p>V8 中会把堆分为新生代和老生代两个区域，</p><p>新生代中存放的是生存时间短的对象，</p><p>老生代中存放的生存时间久的对象。</p><p>垃圾回收重要术语：</p></blockquote></li><li><ul><li>大部分对象在内存中存在的时间很短</li><li>不死的对象，会活得更久</li><li>代际假说</li><li>分代收集</li></ul></li></ul><p><strong>副垃圾回收器：</strong></p><p>主要负责新生代的垃圾回收。</p><p>这个区域不大，但是垃圾回收比较频繁。</p><p>新生代的垃圾回收算法是 Scavenge 算法。</p><p>主要把新生代空间对半划分为两个区域：对象区域，空闲区域。</p><p>当对象区域快被写满时，则会进行一次垃圾清理。</p><p>流程如下：</p><ol><li>对对象区域中的垃圾做标记</li><li>把存活的对象复制到空闲区域中</li><li>把这些对象有序地排列起来</li><li>清理完之后，对象区域会与空闲区域互换</li></ol><p><strong>主垃圾回收器：</strong></p><p>主垃圾回收器主要负责老生区中的垃圾回收。</p><p>除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。</p><p>因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。</p><p>流程如下：</p><ol><li>从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，区分活动对象以及垃圾数据</li><li>标记过程和清除过程使用标记 - 清除算法</li><li>碎片过多会导致大对象无法分配到足够的连续内存时，会使用标记 - 整理算法</li></ol><p>一旦执行垃圾回收算法，会导致 <strong>全停顿（Stop-The-World）</strong> 。</p><p>但是 V8 有 <strong>增量标记算法</strong> 。</p><p>V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成。</p><h2 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h2><h3 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h3><ul><li><p>xss：将代码注入到网页</p></li><li><ul><li><strong>持久型</strong> ：写入数据库</li><li><strong>非持久型</strong> ：修改用户代码</li></ul></li><li><p>csrf：跨站请求伪造。攻击者会虚构一个后端请求地址，诱导用户通过某些途径发送请求。</p></li><li><p>中间人攻击：中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息。</p></li><li><ul><li>DNS 欺骗：入侵 DNS 来将用户访问目标改为入侵者指定机器</li><li>会话劫持：在一次正常的通信过程中，攻击者作为第三方参与到其中，或者是在数据里加入其他信息，甚至将双方的通信模式暗中改变，即从直接联系变成有攻击者参与的联系。</li></ul></li></ul><h3 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h3><ol><li>预防 XSS</li></ol><ul><li><p>使用转义字符过滤 html 代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const escapeHTML = value =&gt; &#123;</span><br><span class="line">  if (!value || !value.length) &#123;</span><br><span class="line">    return value;</span><br><span class="line">  &#125;</span><br><span class="line">  return value</span><br><span class="line">    .replace(/&amp;/g, &quot;&amp;amp;&quot;)</span><br><span class="line">    .replace(/&lt;/g, &quot;&amp;lt;&quot;)</span><br><span class="line">    .replace(/&gt;/g, &quot;&amp;gt;&quot;)</span><br><span class="line">    .replace(/&quot;/g, &quot;&amp;quot;&quot;)</span><br><span class="line">    .replace(/&apos;/g, &quot;&amp;#39;&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>过滤 SQL 代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const replaceSql = value =&gt; &#123;</span><br><span class="line">  if (!value || !value.length) &#123;</span><br><span class="line">    return value;</span><br><span class="line">  &#125;</span><br><span class="line">  return value.replace(/select|update|delete|exec|count|&apos;|&quot;|=|;|&gt;|&lt;|%/gi, &quot;&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><ol><li><p>预防 CSRF</p></li><li><ul><li>验证 HTTP Referer 字段</li><li>在请求地址中添加 token 并验证</li><li>在 HTTP 头中自定义属性并验证</li><li>Get 请求不对数据进行修改</li><li>接口防跨域处理</li><li>不让第三方网站访问用户 cookie</li></ul></li><li><p>预防中间人攻击</p></li></ol><ul><li>对于 DNS 欺骗：检查本机的 HOSTS 文件</li><li>对于会话劫持：使用交换式网络代替共享式网络，还必须使用静态 ARP、捆绑 MAC+IP 等方法来限制欺骗，以及采用认证方式的连接等。</li></ul><ol><li>内容安全策略（CSP）</li></ol><p>内容安全策略 (CSP) 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。</p><p>措施如下：</p><ul><li><p>HTTP Header 中的 <code>Content-Security-Policy</code></p></li><li><meta http-equiv="Content-Security-Policy"></li></ul><h2 id="浏览器性能"><a href="#浏览器性能" class="headerlink" title="浏览器性能"></a>浏览器性能</h2><h3 id="DNS-预解析"><a href="#DNS-预解析" class="headerlink" title="DNS 预解析"></a>DNS 预解析</h3><ul><li>``</li><li>Chrome 和 Firefox 3.5+ 能自动进行预解析</li><li>关闭 DNS 预解析：``</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="/interview/qian-duan-mian-shi-ti/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><ol><li><p>Expires</p></li><li><ul><li>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。</li><li>Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</li></ul></li><li><p>Cache-Control</p><p><img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/y0rsINPrlZwiaiaDhnq7zdoCEsbMhMzSk7GE8dpRBNgrbVFr7O6b7DnE5qKP5oM8MT9jZxZdxJ4mibx3bLnh22cQQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p><img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/y0rsINPrlZwiaiaDhnq7zdoCEsbMhMzSk7tC27M3AegicxA83Hur6IxibvC6RNE2ZQAKPssuqcX7qe3oibyVDSicVb9Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p></li></ol><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><blockquote><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。</p></blockquote><ul><li>服务器响应头：Last-Modified，Etag</li><li>浏览器请求头：If-Modified-Since，If-None-Match</li></ul><p><strong>Last-Modified</strong> 与 <strong>If-Modified-Since</strong> 配对。<code>Last-Modified</code> 把 Web 应用最后修改时间告诉客户端，客户端下次请求之时会把 <code>If-Modified-Since</code> 的值发生给服务器，服务器由此判断是否需要重新发送资源，如果不需要则返回 304，如果有则返回 200。这对组合的缺点是只能精确到秒，而且是根据本地打开时间来记录的，所以会不准确。</p><p><strong>Etag</strong> 与 <strong>If-None-Match</strong> 配对。它们没有使用时间作为判断标准，而是使用了一组特征串。<code>Etag</code>把此特征串发生给客户端，客户端在下次请求之时会把此特征串作为<code>If-None-Match</code>的值发送给服务端，服务器由此判断是否需要重新发送资源，如果不需要则返回 304，如果有则返回 200。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/y0rsINPrlZwiaiaDhnq7zdoCEsbMhMzSk7P5OgXNGuhlkibctNoDSs9dbp8d6Gpm0micMxe0FfMVLHxzYhyzgMDwiaQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><h2 id="NodeJs"><a href="#NodeJs" class="headerlink" title="NodeJs"></a>NodeJs</h2><h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><p>基础概念：</p><ul><li>进程：进程（英语：process），是指计算机中已运行的程序。进程曾经是分时系统的基本运作单位。</li><li>线程：线程（英语：thread）是操作系统能够进行运算调度的最小单位。大部分情况下，它被包含在进程之中，是进程中的实际运作单位。</li><li>协程：协程（英语：coroutine），又称微线程，是计算机程序的一类组件，推广了协作式多任务的子程序，允许执行被挂起与被恢复。</li></ul><p>Node 中最核心的是 v8 引擎，在 Node 启动后，会创建 v8 的实例，这个实例是多线程的，各个线程如下：</p><ul><li>主线程：编译、执行代码。</li><li>编译/优化线程：在主线程执行的时候，可以优化代码。</li><li>分析器线程：记录分析代码运行时间，为 Crankshaft 优化代码执行提供依据。</li><li>垃圾回收的几个线程。</li></ul><h3 id="非阻塞-I-O"><a href="#非阻塞-I-O" class="headerlink" title="非阻塞 I/O"></a>非阻塞 I/O</h3><p><strong>阻塞</strong> 是指在 Node.js 程序中，其它 JavaScript 语句的执行，必须等待一个非 JavaScript 操作完成。这是因为当 <strong>阻塞</strong> 发生时，事件循环无法继续运行 JavaScript。</p><p>在 Node.js 中，JavaScript 由于执行 CPU 密集型操作，而不是等待一个非 JavaScript 操作（例如 I/O）而表现不佳，通常不被称为 <strong>阻塞</strong>。在 Node.js 标准库中使用 libuv 的同步方法是最常用的 <strong>阻塞</strong> 操作。原生模块中也有 <strong>阻塞</strong> 方法。</p><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────────┐</span><br><span class="line">┌─&gt;│           timers          │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │     pending callbacks     │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │       idle, prepare       │</span><br><span class="line">│  └─────────────┬─────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌─────────────┴─────────────┐      │   incoming:   │</span><br><span class="line">│  │           poll            │&lt;─────┤  connections, │</span><br><span class="line">│  └─────────────┬─────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌─────────────┴─────────────┐      └───────────────┘</span><br><span class="line">│  │           check           │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">└──┤      close callbacks      │</span><br><span class="line">   └───────────────────────────┘</span><br></pre></td></tr></table></figure><p><strong>注意：每个框被称为事件循环机制的一个阶段。</strong></p><p><strong>在 Windows 和 Unix/Linux 实现之间存在细微的差异，但这对演示来说并不重要。</strong></p><p>阶段概述：</p><ul><li><strong>定时器</strong> ：本阶段执行已经被 <code>setTimeout()</code> 和 <code>setInterval()</code> 的调度回调函数。</li><li><strong>待定回调</strong> ：执行延迟到下一个循环迭代的 I/O 回调。</li><li><strong>idle, prepare</strong> ：仅系统内部使用。</li><li><strong>轮询</strong> ：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 <code>setImmediate()</code> 调度的之外），其余情况 node 将在适当的时候在此阻塞。</li><li><strong>检测</strong> ：<code>setImmediate()</code> 回调函数在这里执行。</li><li><strong>关闭的回调函数</strong> ：一些关闭的回调函数，如：<code>socket.on(&#39;close&#39;, ...)</code>。</li></ul><p>在每次运行的事件循环之间，Node.js 检查它是否在等待任何异步 I/O 或计时器，如果没有的话，则完全关闭。</p><p><strong><code>process.nextTick()</code></strong> ：它是异步 API 的一部分。从技术上讲不是事件循环的一部分。不管事件循环的当前阶段如何，都将在当前操作完成后处理 <code>nextTickQueue</code>。这里的一个<em>操作</em>被视作为一个从底层 C/C++ 处理器开始过渡，并且处理需要执行的 JavaScript 代码。</p><h3 id="Libuv"><a href="#Libuv" class="headerlink" title="Libuv"></a>Libuv</h3><p>Libuv 是一个跨平台的异步 IO 库，它结合了 UNIX 下的 libev 和 Windows 下的 IOCP 的特性，最早由 Node.js 的作者开发，专门为 Node.js 提供多平台下的异步 IO 支持。Libuv 本身是由 C++ 语言实现的，Node.js 中的非阻塞 IO 以及事件循环的底层机制都是由 libuv 实现的。</p><p>在 Windows 环境下，libuv 直接使用 Windows 的 IOCP 来实现异步 IO。在 非 Windows 环境下，libuv 使用多线程（线程池 Thread Pool）来模拟异步 IO，这里仅简要提一下 libuv 中有线程池的概念，之后的文章会介绍 libuv 如何实现进程间通信。</p><h2 id="手写代码"><a href="#手写代码" class="headerlink" title="手写代码"></a>手写代码</h2><h3 id="new-操作符"><a href="#new-操作符" class="headerlink" title="new 操作符"></a>new 操作符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var New = function(Fn) &#123;</span><br><span class="line">  var obj = &#123;&#125;; // 创建空对象</span><br><span class="line">  var arg = Array.prototype.slice.call(arguments, 1);</span><br><span class="line">  obj.__proto__ = Fn.prototype; // 将obj的原型链__proto__指向构造函数的原型prototype</span><br><span class="line">  obj.__proto__.constructor = Fn; // 在原型链 __proto__上设置构造函数的构造器constructor，为了实例化Fn</span><br><span class="line">  Fn.apply(obj, arg); // 执行Fn，并将构造函数Fn执行obj</span><br><span class="line">  return obj; // 返回结果</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">const getType = data =&gt; &#123;</span><br><span class="line">  // 获取数据类型</span><br><span class="line">  const baseType = Object.prototype.toString</span><br><span class="line">    .call(data)</span><br><span class="line">    .replace(/^\[object\s(.+)\]$/g, &quot;$1&quot;)</span><br><span class="line">    .toLowerCase();</span><br><span class="line">  const type = data instanceof Element ? &quot;element&quot; : baseType;</span><br><span class="line">  return type;</span><br><span class="line">&#125;;</span><br><span class="line">const isPrimitive = data =&gt; &#123;</span><br><span class="line">  // 判断是否是基本数据类型</span><br><span class="line">  const primitiveType = &quot;undefined,null,boolean,string,symbol,number,bigint,map,set,weakmap,weakset&quot;.split(</span><br><span class="line">    &quot;,&quot;</span><br><span class="line">  ); // 其实还有很多类型</span><br><span class="line">  return primitiveType.includes(getType(data));</span><br><span class="line">&#125;;</span><br><span class="line">const isObject = data =&gt; getType(data) === &quot;object&quot;;</span><br><span class="line">const isArray = data =&gt; getType(data) === &quot;array&quot;;</span><br><span class="line">const deepClone = data =&gt; &#123;</span><br><span class="line">  let cache = &#123;&#125;; // 缓存值，防止循环引用</span><br><span class="line">  const baseClone = _data =&gt; &#123;</span><br><span class="line">    let res;</span><br><span class="line">    if (isPrimitive(_data)) &#123;</span><br><span class="line">      return data;</span><br><span class="line">    &#125; else if (isObject(_data)) &#123;</span><br><span class="line">      res = &#123; ..._data &#125;;</span><br><span class="line">    &#125; else if (isArray(_data)) &#123;</span><br><span class="line">      res = [..._data];</span><br><span class="line">    &#125;</span><br><span class="line">    // 判断是否有复杂类型的数据，有就递归</span><br><span class="line">    Reflect.ownKeys(res).forEach(key =&gt; &#123;</span><br><span class="line">      if (res[key] &amp;&amp; getType(res[key]) === &quot;object&quot;) &#123;</span><br><span class="line">        // 用cache来记录已经被复制过的引用地址。用来解决循环引用的问题</span><br><span class="line">        if (cache[res[key]]) &#123;</span><br><span class="line">          res[key] = cache[res[key]];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          cache[res[key]] = res[key];</span><br><span class="line">          res[key] = baseClone(res[key]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return res;</span><br><span class="line">  &#125;;</span><br><span class="line">  return baseClone(data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="手写-bind"><a href="#手写-bind" class="headerlink" title="手写 bind"></a>手写 bind</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind2 = function(context) &#123;</span><br><span class="line">  if (typeof this !== &quot;function&quot;) &#123;</span><br><span class="line">    throw new Error(&quot;...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  var that = this;</span><br><span class="line">  var args1 = Array.prototype.slice.call(arguments, 1);</span><br><span class="line">  var bindFn = function() &#123;</span><br><span class="line">    var args2 = Array.prototype.slice.call(arguments);</span><br><span class="line">    var that2 = this instanceof bindFn ? this : context; // 如果当前函数的this指向的是构造函数中的this 则判定为new 操作。如果this是构造函数bindFn new出来的实例，那么此处的this一定是该实例本身。</span><br><span class="line">    return that.apply(that2, args1.concat(args2));</span><br><span class="line">  &#125;;</span><br><span class="line">  var Fn = function() &#123;&#125;; // 连接原型链用Fn</span><br><span class="line">  // 原型赋值</span><br><span class="line">  Fn.prototype = this.prototype; // bindFn的prototype指向和this的prototype一样，指向同一个原型对象</span><br><span class="line">  bindFn.prototype = new Fn();</span><br><span class="line">  return bindFn;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="手写函数柯里化"><a href="#手写函数柯里化" class="headerlink" title="手写函数柯里化"></a>手写函数柯里化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const curry = fn =&gt; &#123;</span><br><span class="line">  if (typeof fn !== &quot;function&quot;) &#123;</span><br><span class="line">    throw Error(&quot;No function provided&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return function curriedFn(...args) &#123;</span><br><span class="line">    if (args.length &lt; fn.length) &#123;</span><br><span class="line">      return function() &#123;</span><br><span class="line">        return curriedFn.apply(null, args.concat([].slice.call(arguments)));</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return fn.apply(null, args);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="手写-Promise"><a href="#手写-Promise" class="headerlink" title="手写 Promise"></a>手写 Promise</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">// 来源于 https://github.com/bailnl/promise/blob/master/src/promise.js</span><br><span class="line">const PENDING = 0;</span><br><span class="line">const FULFILLED = 1;</span><br><span class="line">const REJECTED = 2;</span><br><span class="line"></span><br><span class="line">const isFunction = fn =&gt; typeof fn === &quot;function&quot;;</span><br><span class="line">const isObject = obj =&gt; obj !== null &amp;&amp; typeof obj === &quot;object&quot;;</span><br><span class="line">const noop = () =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">const nextTick = fn =&gt; setTimeout(fn, 0);</span><br><span class="line"></span><br><span class="line">const resolve = (promise, x) =&gt; &#123;</span><br><span class="line">  if (promise === x) &#123;</span><br><span class="line">    reject(promise, new TypeError(&quot;You cannot resolve a promise with itself&quot;));</span><br><span class="line">  &#125; else if (x &amp;&amp; x.constructor === Promise) &#123;</span><br><span class="line">    if (x._stauts === PENDING) &#123;</span><br><span class="line">      const handler = statusHandler =&gt; value =&gt; statusHandler(promise, value);</span><br><span class="line">      x.then(handler(resolve), handler(reject));</span><br><span class="line">    &#125; else if (x._stauts === FULFILLED) &#123;</span><br><span class="line">      fulfill(promise, x._value);</span><br><span class="line">    &#125; else if (x._stauts === REJECTED) &#123;</span><br><span class="line">      reject(promise, x._value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (isFunction(x) || isObject(x)) &#123;</span><br><span class="line">    let isCalled = false;</span><br><span class="line">    try &#123;</span><br><span class="line">      const then = x.then;</span><br><span class="line">      if (isFunction(then)) &#123;</span><br><span class="line">        const handler = statusHandler =&gt; value =&gt; &#123;</span><br><span class="line">          if (!isCalled) &#123;</span><br><span class="line">            statusHandler(promise, value);</span><br><span class="line">          &#125;</span><br><span class="line">          isCalled = true;</span><br><span class="line">        &#125;;</span><br><span class="line">        then.call(x, handler(resolve), handler(reject));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        fulfill(promise, x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      if (!isCalled) &#123;</span><br><span class="line">        reject(promise, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    fulfill(promise, x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const reject = (promise, reason) =&gt; &#123;</span><br><span class="line">  if (promise._stauts !== PENDING) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  promise._stauts = REJECTED;</span><br><span class="line">  promise._value = reason;</span><br><span class="line">  invokeCallback(promise);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const fulfill = (promise, value) =&gt; &#123;</span><br><span class="line">  if (promise._stauts !== PENDING) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  promise._stauts = FULFILLED;</span><br><span class="line">  promise._value = value;</span><br><span class="line">  invokeCallback(promise);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const invokeCallback = promise =&gt; &#123;</span><br><span class="line">  if (promise._stauts === PENDING) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  nextTick(() =&gt; &#123;</span><br><span class="line">    while (promise._callbacks.length) &#123;</span><br><span class="line">      const &#123;</span><br><span class="line">        onFulfilled = value =&gt; value,</span><br><span class="line">        onRejected = reason =&gt; &#123;</span><br><span class="line">          throw reason;</span><br><span class="line">        &#125;,</span><br><span class="line">        thenPromise</span><br><span class="line">      &#125; = promise._callbacks.shift();</span><br><span class="line">      let value;</span><br><span class="line">      try &#123;</span><br><span class="line">        value = (promise._stauts === FULFILLED ? onFulfilled : onRejected)(</span><br><span class="line">          promise._value</span><br><span class="line">        );</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        reject(thenPromise, e);</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line">      resolve(thenPromise, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Promise &#123;</span><br><span class="line">  static resolve(value) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; resolve(value));</span><br><span class="line">  &#125;</span><br><span class="line">  static reject(reason) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; reject(reason));</span><br><span class="line">  &#125;</span><br><span class="line">  constructor(resolver) &#123;</span><br><span class="line">    if (!(this instanceof Promise)) &#123;</span><br><span class="line">      throw new TypeError(</span><br><span class="line">        `Class constructor Promise cannot be invoked without &apos;new&apos;`</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!isFunction(resolver)) &#123;</span><br><span class="line">      throw new TypeError(`Promise resolver $&#123;resolver&#125; is not a function`);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this._stauts = PENDING;</span><br><span class="line">    this._value = undefined;</span><br><span class="line">    this._callbacks = [];</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      resolver(value =&gt; resolve(this, value), reason =&gt; reject(this, reason));</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      reject(this, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    const thenPromise = new this.constructor(noop);</span><br><span class="line">    this._callbacks = this._callbacks.concat([</span><br><span class="line">      &#123;</span><br><span class="line">        onFulfilled: isFunction(onFulfilled) ? onFulfilled : void 0,</span><br><span class="line">        onRejected: isFunction(onRejected) ? onRejected : void 0,</span><br><span class="line">        thenPromise</span><br><span class="line">      &#125;</span><br><span class="line">    ]);</span><br><span class="line">    invokeCallback(this);</span><br><span class="line">    return thenPromise;</span><br><span class="line">  &#125;</span><br><span class="line">  catch(onRejected) &#123;</span><br><span class="line">    return this.then(void 0, onRejected);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手写防抖函数"><a href="#手写防抖函数" class="headerlink" title="手写防抖函数"></a>手写防抖函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const debounce = (fn = &#123;&#125;, wait = 50, immediate) =&gt; &#123;</span><br><span class="line">  let timer;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    if (immediate) &#123;</span><br><span class="line">      fn.apply(this, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">    if (timer) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">      timer = null;</span><br><span class="line">    &#125;</span><br><span class="line">    timer = setTimeout(() =&gt; &#123;</span><br><span class="line">      fn.apply(this, arguments);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="手写节流函数"><a href="#手写节流函数" class="headerlink" title="手写节流函数"></a>手写节流函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var throttle = (fn = &#123;&#125;, wait = 0) =&gt; &#123;</span><br><span class="line">  let prev = new Date();</span><br><span class="line">  return function() &#123;</span><br><span class="line">    const args = arguments;</span><br><span class="line">    const now = new Date();</span><br><span class="line">    if (now - prev &gt; wait) &#123;</span><br><span class="line">      fn.apply(this, args);</span><br><span class="line">      prev = new Date();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="手写-instanceOf"><a href="#手写-instanceOf" class="headerlink" title="手写 instanceOf"></a>手写 instanceOf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const instanceOf = (left, right) =&gt; &#123;</span><br><span class="line">  let proto = left.__proto__;</span><br><span class="line">  let prototype = right.prototype;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    if (proto === null) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125; else if (proto === prototype) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    proto = proto.__proto__;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="其它知识"><a href="#其它知识" class="headerlink" title="其它知识"></a>其它知识</h2><h3 id="typeof-vs-instanceof"><a href="#typeof-vs-instanceof" class="headerlink" title="typeof vs instanceof"></a>typeof vs instanceof</h3><p><code>instanceof</code> 运算符用来检测 <code>constructor.prototype</code>是否存在于参数 <code>object</code> 的原型链上。</p><p><code>typeof</code> 操作符返回一个字符串，表示未经计算的操作数的类型。</p><p>在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 <code>null</code> 代表的是空指针（大多数平台下值为 0x00），因此，null 的类型标签是 0，<code>typeof null</code> 也因此返回 <code>&quot;object&quot;</code>。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><blockquote><p>递归（英语：Recursion），又译为递回，在数学与计算机科学中，是指在函数的定义中使用函数自身的方法。</p><p>例如：</p><p>大雄在房里，用时光电视看着未来的情况。电视画面中的那个时候，他正在房里，用时光电视，看着未来的情况。电视画面中的电视画面的那个时候，他正在房里，用时光电视，看着未来的情况……</p><p>简单来说，就是 <strong>无限套娃</strong></p></blockquote><p>我们以斐波那契数列（Fibonacci sequence）为例，看看输入结果会为正无穷的值的情况下，各种递归的情况。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="/interview/qian-duan-mian-shi-ti/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>首先是普通版</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const fib1 = n =&gt; &#123;</span><br><span class="line">  if (typeof n !== &quot;number&quot;) &#123;</span><br><span class="line">    throw new Error(&quot;..&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  if (n &lt; 2) &#123;</span><br><span class="line">    return n;</span><br><span class="line">  &#125;</span><br><span class="line">  return fib1(n - 1) + fib1(n - 2);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面的代码分析，我们不难发现，在<code>fib1</code>里，JS 会不停创建执行上下文，压入栈内，而且在得出结果前不会销毁，所以数大了之后容易爆栈。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/y0rsINPrlZwiaiaDhnq7zdoCEsbMhMzSk7haf1o7jXwicKFocBQiaGVf8xaOjIdL3mWWaVSqRSdia4Lzyjq1uL30hXA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>所以我们可以对其进行优化，就是利用 <strong>尾调用</strong> 进行优化。</p><p>尾调用是指函数的最后一步只返回一个纯函数的调用，而没有别的数据占用引用。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const fib2 = (n, a = 0, b = 1) =&gt; &#123;</span><br><span class="line">  if (typeof n !== &quot;number&quot;) &#123;</span><br><span class="line">    throw new Error(&quot;..&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  if (n === 0) &#123;</span><br><span class="line">    return a;</span><br><span class="line">  &#125;</span><br><span class="line">  return fib2(n - 1, b, a + b);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不过很遗憾，在 Chrome 83.0.4103.61 里还是会爆。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/y0rsINPrlZwiaiaDhnq7zdoCEsbMhMzSk7CTmtENaFaWpco5TfC0GM3aPAoCQycrADXNc1fJJRGVZrKJrK7MzMbw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>然后我们还有备忘录递归法，就是另外申请空间去存储每次递归的值，是个自顶向下的算法。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/y0rsINPrlZwiaiaDhnq7zdoCEsbMhMzSk75nOibAImLu4DdExI6D8cx3GCOkJiauhcSWacNjsb0IyrrTMCOTvzXtkQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>可惜，还是挂了。</p><p>不过在一些递归问题上，我们还可以利用动态规划（Dynamic programming，简称 DP）来解决。</p><p>动态规划是算法里比较难掌握的一个概念之一，但是基本能用递归来解决的问题，都能用动态规划来解决。</p><p>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。</p><p>跟备忘录递归刚好相反，是自底向上的算法。具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const fib3 = n =&gt; &#123;</span><br><span class="line">  if (typeof n !== &quot;number&quot;) &#123;</span><br><span class="line">    throw new Error(&quot;..&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  if (n &lt; 2) &#123;</span><br><span class="line">    return n;</span><br><span class="line">  &#125;</span><br><span class="line">  let a = 0;</span><br><span class="line">  let b = 1;</span><br><span class="line">  while (n--) &#123;</span><br><span class="line">    [a, b] = [b, a + b];</span><br><span class="line">  &#125;</span><br><span class="line">  return a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="/interview/qian-duan-mian-shi-ti/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>效果很好，正确输出了正无穷~</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>浏览器工作原理与实践</li><li>浏览器的运行机制—2.浏览器都包含哪些进程？</li><li>「中高级前端面试」JavaScript 手写代码无敌秘籍</li><li>JavaScript 深拷贝</li><li>bailnl/promise</li><li>网络是怎样连接的？</li><li>浏览器工作原理与实践</li><li>浏览器的工作原理：新式网络浏览器幕后揭秘</li><li>内容安全策略( CSP )</li><li>前端面试之道</li><li>HTTP 各版本的区别</li><li>CORS解决跨域问题（Nginx跨域配置）</li><li>你觉得 Node.js 是单线程这个结论对吗？</li><li>Node 指南</li><li>深入理解浏览器的缓存机制</li></ol><p>转自<a href="https://mp.weixin.qq.com/s/SrKdXN4FF4IThFbDxivN4A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/SrKdXN4FF4IThFbDxivN4A</a></p><h3 id="说说你对闭包的理解"><a href="#说说你对闭包的理解" class="headerlink" title="说说你对闭包的理解"></a>说说你对<a href="https://so.csdn.net/so/search?q=闭包&spm=1001.2101.3001.7020" target="_blank" rel="noopener">闭包</a>的理解</h3><p>使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免<a href="https://so.csdn.net/so/search?q=全局变量&spm=1001.2101.3001.7020" target="_blank" rel="noopener">全局变量</a>的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。</p><p>闭包有三个特性:</p><blockquote><p>1.函数<a href="https://so.csdn.net/so/search?q=嵌套&spm=1001.2101.3001.7020" target="_blank" rel="noopener">嵌套</a>函数<br>2.函数内部可以引用外部的参数和变量<br>3.参数和变量不会被<a href="https://so.csdn.net/so/search?q=垃圾回收&spm=1001.2101.3001.7020" target="_blank" rel="noopener">垃圾回收</a>机制回收</p></blockquote><h2 id="CSS-相关问题"><a href="#CSS-相关问题" class="headerlink" title="CSS 相关问题"></a>CSS 相关问题</h2><h3 id="display-none和visibility-hidden的区别？"><a href="#display-none和visibility-hidden的区别？" class="headerlink" title="display:none和visibility:hidden的区别？"></a>display:none和visibility:hidden的区别？</h3><p>display:none  隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，<br>就当他从来不存在。</p><p>visibility:hidden  隐藏对应的元素，但是在文档布局中仍保留原来的空间。</p><h3 id="CSS中-link-和-import-的区别是？"><a href="#CSS中-link-和-import-的区别是？" class="headerlink" title="CSS中 link 和@import 的区别是？"></a>CSS中 link 和@import 的区别是？</h3><p>(1) link属于HTML标签，而@import是CSS提供的;<br>(2) 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;<br>(3) import只在IE5以上才能识别，而link是HTML标签，无兼容问题;<br>(4) link方式的样式的权重 高于@import的权重.</p><h3 id="position-absolute和float属性的异同"><a href="#position-absolute和float属性的异同" class="headerlink" title="position:absolute和float属性的异同"></a>position:absolute和float属性的异同</h3><p>A：共同点：<br>对内联元素设置<code>float</code>和<code>absolute</code>属性，可以让元素脱离文档流，并且可以设置其宽高。</p><p>B：不同点：<br>float仍会占据位置，position会覆盖文档流中的其他元素。</p><h3 id="CSS-选择符有哪些？哪些属性可以继承？优先级算法如何计算？-CSS3新增伪类有那些？"><a href="#CSS-选择符有哪些？哪些属性可以继承？优先级算法如何计算？-CSS3新增伪类有那些？" class="headerlink" title="CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？"></a>CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.id选择器（ # myid）</span><br><span class="line">2.类选择器（.myclassname）</span><br><span class="line">3.标签选择器（div, h1, p）</span><br><span class="line">4.相邻选择器（h1 + p）</span><br><span class="line">5.子选择器（ul &gt; li）</span><br><span class="line">6.后代选择器（li a）</span><br><span class="line">7.通配符选择器（ * ）</span><br><span class="line">8.属性选择器（a[rel = &quot;external&quot;]）</span><br><span class="line">9.伪类选择器（a: hover, li:nth-child）</span><br></pre></td></tr></table></figure><ul><li>可继承的样式： font-size font-family color, text-indent;</li><li>不可继承的样式：border padding margin width height ;</li><li>优先级就近原则，同权重情况下样式定义最近者为准;</li><li>载入样式以最后载入的定位为准;</li></ul><blockquote><p>优先级为:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">!important &gt;  id &gt; class &gt; tag  </span><br><span class="line"></span><br><span class="line">important 比 内联优先级高,但内联比 id 要高</span><br></pre></td></tr></table></figure><blockquote><p>CSS3新增伪类举例：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:last-of-type  选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:only-of-type  选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:only-child    选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:nth-child(2)  选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。</span><br><span class="line">:enabled  :disabled 控制表单控件的禁用状态。</span><br><span class="line">:checked        单选框或复选框被选中。</span><br></pre></td></tr></table></figure><h3 id="position的值，-relative和absolute分别是相对于谁进行定位的？"><a href="#position的值，-relative和absolute分别是相对于谁进行定位的？" class="headerlink" title="position的值， relative和absolute分别是相对于谁进行定位的？"></a>position的值， relative和absolute分别是相对于谁进行定位的？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">absolute </span><br><span class="line">        生成绝对定位的元素， 相对于最近一级的 定位不是 static 的父元素来进行定位。</span><br><span class="line"></span><br><span class="line">fixed （老IE不支持）</span><br><span class="line">    生成绝对定位的元素，相对于浏览器窗口进行定位。 </span><br><span class="line"></span><br><span class="line">relative </span><br><span class="line">    生成相对定位的元素，相对于其在普通流中的位置进行定位。 </span><br><span class="line"></span><br><span class="line">static  默认值。没有定位，元素出现在正常的流中</span><br></pre></td></tr></table></figure><h3 id="XML和JSON的区别？"><a href="#XML和JSON的区别？" class="headerlink" title="XML和JSON的区别？"></a>XML和JSON的区别？</h3><p>(1).数据体积方面。<br>JSON相对于XML来讲，数据的体积小，传递的速度更快些。<br>(2).数据交互方面。<br>JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。<br>(3).数据描述方面。<br>JSON对数据的描述性比XML较差。<br>(4).传输速度方面。<br>JSON的速度要远远快于XML。</p><h3 id="对BFC规范的理解？"><a href="#对BFC规范的理解？" class="headerlink" title="对BFC规范的理解？"></a>对BFC规范的理解？</h3><p>​      BFC，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个BFC中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的margin会发生折叠。<br>​    （W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行布局，以及与其他元素的关系和相互作用。）</p><h3 id="解释下-CSS-sprites，以及你要如何在页面或网站中使用它。"><a href="#解释下-CSS-sprites，以及你要如何在页面或网站中使用它。" class="headerlink" title="解释下 CSS sprites，以及你要如何在页面或网站中使用它。"></a>解释下 CSS sprites，以及你要如何在页面或网站中使用它。</h3><p>CSS Sprites其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position可以用数字能精确的定位出背景图片的位置。这样可以减少很多图片请求的开销，因为请求耗时比较长；请求虽然可以并发，但是也有限制，一般浏览器都是6个。对于未来而言，就不需要这样做了，因为有了<code>http2</code>。</p><h2 id="html部分"><a href="#html部分" class="headerlink" title="html部分"></a>html部分</h2><h3 id="Doctype作用-严格模式与混杂模式如何区分？它们有何意义"><a href="#Doctype作用-严格模式与混杂模式如何区分？它们有何意义" class="headerlink" title="Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?"></a>Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</h3><p>（1）&lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 <html> 标签之前。告知浏览器以何种模式来渲染文档。 </html></p><p>（2）严格模式的排版和 JS 运作模式是  以该浏览器支持的最高标准运行。</p><p>（3）在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。</p><p>（4）DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。</p><h3 id="你知道多少种Doctype文档类型？"><a href="#你知道多少种Doctype文档类型？" class="headerlink" title="你知道多少种Doctype文档类型？"></a>你知道多少种Doctype文档类型？</h3><p> 该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。<br> HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。<br> XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。<br>Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks<br> （包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。</p><h3 id="HTML与XHTML——二者有什么区别"><a href="#HTML与XHTML——二者有什么区别" class="headerlink" title="HTML与XHTML——二者有什么区别"></a>HTML与XHTML——二者有什么区别</h3><p>区别：<br>1.所有的标记都必须要有一个相应的结束标记<br>2.所有标签的元素和属性的名字都必须使用小写<br>3.所有的XML标记都必须合理嵌套<br>4.所有的属性必须用引号””括起来<br>5.把所有&lt;和&amp;特殊符号用编码表示<br>6.给所有属性赋一个值<br>7.不要在注释内容中使“–”<br>8.图片必须有说明文字</p><h3 id="常见兼容性问题？"><a href="#常见兼容性问题？" class="headerlink" title="常见兼容性问题？"></a>常见兼容性问题？</h3><ul><li><p>png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理.</p></li><li><p>浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。</p></li><li><p>IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。 </p></li><li><p>浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。）<br>#box{ float:left; width:10px; margin:0 0 0 100px;} </p><p>这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)</p></li><li><p>渐进识别的方式，从总体中逐渐排除局部。 </p><p>首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。<br>接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">css</span><br><span class="line">    .bb&#123;</span><br><span class="line">     background-color:#f1ee18;/*所有识别*/</span><br><span class="line">    .background-color:#00deff\9; /*IE6、7、8识别*/</span><br><span class="line">    +background-color:#a200ff;/*IE6、7识别*/</span><br><span class="line">    _background-color:#1e0bd1;/*IE6识别*/ </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>IE下,可以使用获取常规属性的方法来获取自定义属性,<br>也可以使用getAttribute()获取自定义属性;<br>Firefox下,只能使用getAttribute()获取自定义属性.<br>解决方法:统一通过getAttribute()获取自定义属性.</p></li><li><p>IE下,event对象有x,y属性,但是没有pageX,pageY属性;<br>Firefox下,event对象有pageX,pageY属性,但是没有x,y属性.</p></li><li><p>解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。</p></li><li><p>Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,<br>可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决.</p></li><li><p>超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:<br>L-V-H-A :  a:link {} a:visited {} a:hover {} a:active {}</p></li><li><p>怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。现在可以使用<a href="http://www.w3.org/TR/html5/single-page.html" target="_blank" rel="noopener">html5</a>推荐的写法：<code>&lt;doctype html&gt;</code></p></li><li><p>上下margin重合问题<br>ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。<br>解决方法，养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。</p></li><li><p>ie6对png图片格式支持不好(引用一段脚本处理)</p></li></ul><h3 id="解释下浮动和它的工作原理？清除浮动的技巧"><a href="#解释下浮动和它的工作原理？清除浮动的技巧" class="headerlink" title="解释下浮动和它的工作原理？清除浮动的技巧"></a>解释下浮动和它的工作原理？清除浮动的技巧</h3><p>浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。</p><p>1.使用空标签清除浮动。<br>   这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。<br>2.使用overflow。<br>   给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。<br>3.使用after伪对象清除浮动。<br>   该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；</p><h3 id="浮动元素引起的问题和解决办法？"><a href="#浮动元素引起的问题和解决办法？" class="headerlink" title="浮动元素引起的问题和解决办法？"></a>浮动元素引起的问题和解决办法？</h3><p>浮动元素引起的问题：</p><p>（1）父元素的高度无法被撑开，影响与父元素同级的元素<br>（2）与浮动元素同级的非浮动元素（内联元素）会跟随其后<br>（3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构</p><p>解决方法：<br>使用<code>CSS</code>中的<code>clear:both</code>;属性来清除元素的浮动可解决2、3问题，对于问题1，添加如下样式，给父元素添加<code>clearfix</code>样式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:after&#123;content: &quot;.&quot;;display: block;height: 0;clear: both;visibility: hidden;&#125;</span><br><span class="line">.clearfix&#123;display: inline-block;&#125; /* for IE/Mac */</span><br></pre></td></tr></table></figure><p><strong>清除浮动的几种方法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1，额外标签法，&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;（缺点：不过这个办法会增加额外的标签使HTML结构看起来不够简洁。）</span><br><span class="line">2，使用after伪类</span><br><span class="line"></span><br><span class="line">#parent:after&#123;</span><br><span class="line">    content:&quot;.&quot;;</span><br><span class="line">    height:0;</span><br><span class="line">    visibility:hidden;</span><br><span class="line">    display:block;</span><br><span class="line">    clear:both;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">3,浮动外部元素</span><br><span class="line">4,设置`overflow`为`hidden`或者auto</span><br></pre></td></tr></table></figure><h3 id="IE-8以下版本的浏览器中的盒模型有什么不同"><a href="#IE-8以下版本的浏览器中的盒模型有什么不同" class="headerlink" title="IE 8以下版本的浏览器中的盒模型有什么不同"></a>IE 8以下版本的浏览器中的盒模型有什么不同</h3><p>IE8以下浏览器的盒模型中定义的元素的宽高不包括内边距和边框</p><h3 id="DOM操作——怎样添加、移除、移动、复制、创建和查找节点。"><a href="#DOM操作——怎样添加、移除、移动、复制、创建和查找节点。" class="headerlink" title="DOM操作——怎样添加、移除、移动、复制、创建和查找节点。"></a>DOM操作——怎样添加、移除、移动、复制、创建和查找节点。</h3><p>（1）创建新节点</p><p>​      createDocumentFragment()    //创建一个DOM片段</p><p>​      createElement()   //创建一个具体的元素</p><p>​      createTextNode()   //创建一个文本节点</p><p>（2）添加、移除、替换、插入</p><p>​      appendChild()</p><p>​      removeChild()</p><p>​      replaceChild()</p><p>​      insertBefore() //在已有的子节点前插入一个新的子节点</p><p>（3）查找</p><p>​      getElementsByTagName()    //通过标签名称</p><p>​      getElementsByName()    //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)</p><p>​      getElementById()    //通过元素Id，唯一性</p><h3 id="iframe的优缺点？"><a href="#iframe的优缺点？" class="headerlink" title="iframe的优缺点？"></a>iframe的优缺点？</h3><p>1.<code>&lt;iframe&gt;</code>优点：</p><p>​    解决加载缓慢的第三方内容如图标和广告等的加载问题<br>​    Security sandbox<br>​    并行加载脚本</p><p>2.<code>&lt;iframe&gt;</code>的缺点：</p><p>​    *iframe会阻塞主页面的Onload事件；</p><p>​    *即时内容为空，加载也需要时间<br>​    *没有语意 </p><h3 id="如何实现浏览器内多个标签页之间的通信"><a href="#如何实现浏览器内多个标签页之间的通信" class="headerlink" title="如何实现浏览器内多个标签页之间的通信?"></a>如何实现浏览器内多个标签页之间的通信?</h3><p>调用localstorge、cookies等本地存储方式</p><h3 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h3><p>一个程序至少有一个进程,一个进程至少有一个线程.<br>线程的划分尺度小于进程，使得多线程程序的并发性高。<br>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。<br>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。<br>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p><h3 id="你如何对网站的文件和资源进行优化？"><a href="#你如何对网站的文件和资源进行优化？" class="headerlink" title="你如何对网站的文件和资源进行优化？"></a>你如何对网站的文件和资源进行优化？</h3><p>期待的解决方案包括：<br> 文件合并<br> 文件最小化/文件压缩<br> 使用 CDN 托管<br> 缓存的使用（多个域名来提供缓存）<br> 其他</p><h3 id="请说出三种减少页面加载时间的方法。"><a href="#请说出三种减少页面加载时间的方法。" class="headerlink" title="请说出三种减少页面加载时间的方法。"></a>请说出三种减少页面加载时间的方法。</h3><p> 1.优化图片<br> 2.图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方）<br> 3.优化CSS（压缩合并css，如margin-top,margin-left…)<br> 4.网址后加斜杠（如<a href="http://www.campr.com/目录，会判断这个“目录是什么文件类型，或者是目录。）" target="_blank" rel="noopener">www.campr.com/目录，会判断这个“目录是什么文件类型，或者是目录。）</a><br> 5.标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。<br>当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了。）<br> 6.减少http请求（合并文件，合并图片）。</p><h3 id="你都使用哪些工具来测试代码的性能？"><a href="#你都使用哪些工具来测试代码的性能？" class="headerlink" title="你都使用哪些工具来测试代码的性能？"></a>你都使用哪些工具来测试代码的性能？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Profiler, JSPerf（http://jsperf.com/nexttick-vs-setzerotimeout-vs-settimeout）, Dromaeo</span><br></pre></td></tr></table></figure><h3 id="什么是-FOUC（无样式内容闪烁）？你如何来避免-FOUC？"><a href="#什么是-FOUC（无样式内容闪烁）？你如何来避免-FOUC？" class="headerlink" title="什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？"></a>什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> FOUC - Flash Of Unstyled Content 文档样式闪烁</span><br><span class="line"> &lt;style type=&quot;text/css&quot; media=&quot;all&quot;&gt;@import &quot;../fouc.css&quot;;&lt;/style&gt; </span><br><span class="line">而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。</span><br><span class="line"> 解决方法简单的出奇，只要在&lt;head&gt;之间加入一个&lt;link&gt;或者&lt;script&gt;元素就可以了。</span><br></pre></td></tr></table></figure><h3 id="null和undefined的区别？"><a href="#null和undefined的区别？" class="headerlink" title="null和undefined的区别？"></a>null和undefined的区别？</h3><p><code>null</code>是一个表示”无”的对象，转为数值时为0；<code>undefined</code>是一个表示”无”的原始值，转为数值时为<code>NaN</code>。</p><p>当声明的变量还未被初始化时，变量的默认值为<code>undefined</code>。<br><code>null</code>用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。</p><h4 id="undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是："><a href="#undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：" class="headerlink" title="undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是："></a><code>undefined</code>表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：</h4><p>（1）变量被声明了，但没有赋值时，就等于undefined。</p><p>（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。</p><p>（3）对象没有赋值的属性，该属性的值为undefined。</p><p>（4）函数没有返回值时，默认返回undefined。</p><h4 id="null表示”没有对象”，即该处不应该有值。典型用法是："><a href="#null表示”没有对象”，即该处不应该有值。典型用法是：" class="headerlink" title="null表示”没有对象”，即该处不应该有值。典型用法是："></a><code>null</code>表示”没有对象”，即该处不应该有值。典型用法是：</h4><p>（1） 作为函数的参数，表示该函数的参数不是对象。</p><p>（2） 作为对象原型链的终点。</p><h3 id="js延迟加载的方式有哪些？"><a href="#js延迟加载的方式有哪些？" class="headerlink" title="js延迟加载的方式有哪些？"></a>js延迟加载的方式有哪些？</h3><p>defer和async、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）、按需异步载入js</p><h3 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="headerlink" title="如何解决跨域问题?"></a>如何解决跨域问题?</h3><p>jsonp、 document.domain+iframe、window.name、window.postMessage、服务器上设置代理页面<br>jsonp的原理是动态插入script标签</p><p>具体参见：<a href="http://segmentfault.com/blog/trigkit4/1190000000718840" target="_blank" rel="noopener">详解js跨域问题</a></p><h3 id="documen-write和-innerHTML的区别"><a href="#documen-write和-innerHTML的区别" class="headerlink" title="documen.write和 innerHTML的区别"></a>documen.write和 innerHTML的区别</h3><p>document.write只能重绘整个页面</p><p>innerHTML可以重绘页面的一部分</p><h3 id="哪些操作会造成内存泄漏？"><a href="#哪些操作会造成内存泄漏？" class="headerlink" title="哪些操作会造成内存泄漏？"></a>哪些操作会造成内存泄漏？</h3><p>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。<br>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。</p><p>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。<br>闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</p><p>详见：<a href="http://segmentfault.com/blog/trigkit4/1190000000687844" target="_blank" rel="noopener">详解js变量、作用域及内存</a></p><h3 id="JavaScript中的作用域与变量声明提升？"><a href="#JavaScript中的作用域与变量声明提升？" class="headerlink" title="JavaScript中的作用域与变量声明提升？"></a>JavaScript中的作用域与变量声明提升？</h3><p>详见：<a href="http://segmentfault.com/blog/trigkit4/1190000000758184#articleHeader5" target="_blank" rel="noopener">详解JavaScript函数模式</a></p><h3 id="如何判断当前脚本运行在浏览器还是node环境中？"><a href="#如何判断当前脚本运行在浏览器还是node环境中？" class="headerlink" title="如何判断当前脚本运行在浏览器还是node环境中？"></a>如何判断当前脚本运行在浏览器还是node环境中？</h3><p>通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中</p><h3 id="什么叫优雅降级和渐进增强？"><a href="#什么叫优雅降级和渐进增强？" class="headerlink" title="什么叫优雅降级和渐进增强？"></a>什么叫优雅降级和渐进增强？</h3><p>优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效.</p><p>渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。</p><p>详见：<a href="http://segmentfault.com/blog/trigkit4/1190000000800711#articleHeader30" target="_blank" rel="noopener">css学习归纳总结（一）</a></p><h3 id="WEB应用从服务器主动推送Data到客户端有那些方式？"><a href="#WEB应用从服务器主动推送Data到客户端有那些方式？" class="headerlink" title="WEB应用从服务器主动推送Data到客户端有那些方式？"></a>WEB应用从服务器主动推送Data到客户端有那些方式？</h3><p>Javascript数据推送</p><blockquote><p>Commet：基于HTTP长连接的服务器推送技术</p><p>基于WebSocket的推送方案</p><p>SSE（Server-Send Event）：服务器推送数据新方式</p></blockquote><h3 id="对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？"><a href="#对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？" class="headerlink" title="对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？"></a>对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？</h3><p>前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。<br>    1、实现界面交互<br>    2、提升用户体验<br>    3、有了Node.js，前端可以实现服务端的一些事情</p><p>前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，</p><p> 参与项目，快速高质量完成实现效果图，精确到1px；</p><p> 与团队成员，UI设计，产品经理的沟通；</p><p> 做好的页面结构，页面重构和用户体验；</p><p> 处理hack，兼容、写出优美的代码格式；</p><p> 针对服务器的优化、拥抱最新前端技术。</p><h3 id="你有哪些性能优化的方法？"><a href="#你有哪些性能优化的方法？" class="headerlink" title="你有哪些性能优化的方法？"></a>你有哪些性能优化的方法？</h3><p>（<a href="http://segmentfault.com/blog/trigkit4/1190000000656717" target="_blank" rel="noopener">详情请看雅虎14条性能优化原则</a>）。</p><p>  （1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。</p><p>  （2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数</p><p>  （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。</p><p>  （4） 当需要设置的样式很多时设置className而不是直接操作style。</p><p>  （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。</p><p>  （6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。</p><p>  （7） 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。</p><p>详情：<a href="http://segmentfault.com/blog/trigkit4/1190000000691919" target="_blank" rel="noopener">http://segmentfault.com/blog/trigkit4/1190000000691919</a></p><h3 id="一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？"><a href="#一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？" class="headerlink" title="一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？"></a>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</h3><p>​    分为4个步骤：<br>​    （1），当发送一个URL请求时，不管这个URL是Web页面的URL还是Web页面上每个资源的URL，浏览器都会开启一个线程来处理这个请求，同时在远程DNS服务器上启动一个DNS查询。这能使浏览器获得请求对应的IP地址。<br>​    （2）， 浏览器与远程Web服务器通过TCP三次握手协商来建立一个TCP/IP连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。<br>​    （3），一旦TCP/IP连接建立，浏览器会通过该连接向远程服务器发送HTTP的GET请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200的HTTP响应状态表示一个正确的响应。<br>​    （4），此时，Web服务器提供资源服务，客户端开始下载资源。</p><p>请求返回后，便进入了我们关注的前端模块<br>简单来说，浏览器会解析HTML生成DOM Tree，其次会根据CSS生成CSS Rule Tree，而javascript又可以根据DOM API操作DOM</p><p>详情：<a href="http://segmentfault.com/blog/trigkit4/1190000000697254" target="_blank" rel="noopener">从输入 URL 到浏览器接收的过程中发生了什么事情？</a></p><h3 id="平时如何管理你的项目？"><a href="#平时如何管理你的项目？" class="headerlink" title="平时如何管理你的项目？"></a>平时如何管理你的项目？</h3><p>先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等；</p><p>编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；</p><p>标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；</p><p>页面进行标注（例如 页面 模块 开始和结束）；</p><p>CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）；</p><p> JS 分文件夹存放 命名以该JS功能为准的英文翻译。</p><p>图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理 </p><h3 id="说说最近最流行的一些东西吧？常去哪些网站？"><a href="#说说最近最流行的一些东西吧？常去哪些网站？" class="headerlink" title="说说最近最流行的一些东西吧？常去哪些网站？"></a>说说最近最流行的一些东西吧？常去哪些网站？</h3><p>Node.js、Mongodb、npm、MVVM、MEAN、three.js,React 。<br>网站：w3cfuns,sf,hacknews,CSDN,慕课，博客园，InfoQ,w3cplus等</p><h3 id="javascript对象的几种创建方式"><a href="#javascript对象的几种创建方式" class="headerlink" title="javascript对象的几种创建方式"></a>javascript对象的几种创建方式</h3><p>1，工厂模式<br>2，构造函数模式<br>3，原型模式<br>4，混合构造函数和原型模式<br>5，动态原型模式<br>6，寄生构造函数模式<br>7，稳妥构造函数模式</p><h3 id="javascript继承的6种方法"><a href="#javascript继承的6种方法" class="headerlink" title="javascript继承的6种方法"></a>javascript继承的6种方法</h3><p>1，原型链继承<br>2，借用构造函数继承<br>3，组合继承(原型+借用构造)<br>4，原型式继承<br>5，寄生式继承<br>6，寄生组合式继承</p><p>详情：<a href="http://segmentfault.com/blog/trigkit4/1190000002440502" target="_blank" rel="noopener">JavaScript继承方式详解</a></p><h3 id="ajax过程"><a href="#ajax过程" class="headerlink" title="ajax过程"></a>ajax过程</h3><p>(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.</p><p>(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.</p><p>(3)设置响应HTTP请求状态变化的函数.</p><p>(4)发送HTTP请求.</p><p>(5)获取异步调用返回的数据.</p><p>(6)使用JavaScript和DOM实现局部刷新.</p><p>详情：<a href="http://segmentfault.com/blog/trigkit4/1190000000691919" target="_blank" rel="noopener">JavaScript学习总结（七）Ajax和Http状态字</a></p><h3 id="异步加载和延迟加载"><a href="#异步加载和延迟加载" class="headerlink" title="异步加载和延迟加载"></a>异步加载和延迟加载</h3><p>1.异步加载的方案： 动态插入script标签<br>2.通过ajax去获取js代码，然后通过eval执行<br>3.script标签上添加defer或者async属性<br>4.创建并插入iframe，让它异步执行js<br>5.延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的。</p><h2 id="前端安全问题？"><a href="#前端安全问题？" class="headerlink" title="前端安全问题？"></a>前端安全问题？</h2><h3 id="sql注入原理"><a href="#sql注入原理" class="headerlink" title="sql注入原理"></a>sql注入原理</h3><p>就是通过把<code>SQL</code>命令插入到<code>Web</code>表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</p><p>总的来说有以下几点：</p><p>1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双”-“进行转换等。<br>2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取。<br>3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。<br>4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。</p><h3 id="XSS原理及防范"><a href="#XSS原理及防范" class="headerlink" title="XSS原理及防范"></a>XSS原理及防范</h3><p><code>Xss(cross-site scripting)</code>攻击指的是攻击者往Web页面里插入恶意<code>html</code>标签或者<code>javascript</code>代码。比如：攻击者在论坛中放一个<br>看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，<br>当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。</p><h3 id="XSS防范方法"><a href="#XSS防范方法" class="headerlink" title="XSS防范方法"></a>XSS防范方法</h3><p>1.代码里对用户输入的地方和变量都需要仔细检查长度和对<code>”&lt;”,”&gt;”,”;”,”’”</code>等字符做过滤；其次任何内容写到页面之前都必须加以<code>encode</code>，避免不小心把<code>html tag</code> 弄出来。这一个层面做好，至少可以堵住超过一半的<code>XSS</code> 攻击。</p><p>2.避免直接在<code>cookie</code> 中泄露用户隐私，例如<code>email</code>、密码等等。<br>3.通过使cookie 和系统ip 绑定来降低<code>cookie</code> 泄露后的危险。这样攻击者得到的cookie 没有实际价值，不可能拿来重放。</p><p>4.尽量采用POST 而非GET 提交表单</p><h3 id="XSS与CSRF有什么区别吗？"><a href="#XSS与CSRF有什么区别吗？" class="headerlink" title="XSS与CSRF有什么区别吗？"></a>XSS与CSRF有什么区别吗？</h3><p><code>XSS</code>是获取信息，不需要提前知道其他用户页面的代码和数据包。<code>CSRF</code>是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。</p><p>要完成一次CSRF攻击，受害者必须依次完成两个步骤：</p><p>　　1.登录受信任网站A，并在本地生成Cookie。<br>　　2.在不登出A的情况下，访问危险网站B。</p><h3 id="CSRF的防御"><a href="#CSRF的防御" class="headerlink" title="CSRF的防御"></a>CSRF的防御</h3><p>1.服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。<br>2.使用验证码</p><h3 id="ie各版本和chrome可以并行下载多少个资源"><a href="#ie各版本和chrome可以并行下载多少个资源" class="headerlink" title="ie各版本和chrome可以并行下载多少个资源"></a>ie各版本和chrome可以并行下载多少个资源</h3><p>IE6 两个并发，iE7升级之后的6个并发，之后版本也是6个</p><p>Firefox，chrome也是6个</p><h3 id="javascript里面的继承怎么实现，如何避免原型链上面的对象共享"><a href="#javascript里面的继承怎么实现，如何避免原型链上面的对象共享" class="headerlink" title="javascript里面的继承怎么实现，如何避免原型链上面的对象共享"></a>javascript里面的继承怎么实现，如何避免原型链上面的对象共享</h3><p>用构造函数和原型链的混合模式去实现继承，避免对象共享可以参考经典的extend()函数，很多前端框架都有封装的，就是用一个空函数当做中间变量</p><h3 id="grunt，-YUI-compressor-和-google-clojure用来进行代码压缩的用法。"><a href="#grunt，-YUI-compressor-和-google-clojure用来进行代码压缩的用法。" class="headerlink" title="grunt， YUI compressor 和 google clojure用来进行代码压缩的用法。"></a>grunt， YUI compressor 和 google clojure用来进行代码压缩的用法。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">YUI Compressor 是一个用来压缩 JS 和 CSS 文件的工具，采用Java开发。</span><br><span class="line"></span><br><span class="line">使用方法：</span><br><span class="line"></span><br><span class="line">//压缩JS</span><br><span class="line">java -jar yuicompressor-2.4.2.jar --type js --charset utf-8 -v src.js &gt; packed.js</span><br><span class="line">//压缩CSS</span><br><span class="line">java -jar yuicompressor-2.4.2.jar --type css --charset utf-8 -v src.css &gt; packed.css</span><br></pre></td></tr></table></figure><p>详情请见：<a href="http://segmentfault.com/blog/trigkit4/1190000002585760" target="_blank" rel="noopener">你需要掌握的前端代码性能优化工具</a></p><h3 id="Flash、Ajax各自的优缺点，在使用中如何取舍？"><a href="#Flash、Ajax各自的优缺点，在使用中如何取舍？" class="headerlink" title="Flash、Ajax各自的优缺点，在使用中如何取舍？"></a>Flash、Ajax各自的优缺点，在使用中如何取舍？</h3><p>1、Flash ajax对比<br>Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜索。<br>Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。<br>共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM</p><h3 id="请解释一下-JavaScript-的同源策略。"><a href="#请解释一下-JavaScript-的同源策略。" class="headerlink" title="请解释一下 JavaScript 的同源策略。"></a>请解释一下 JavaScript 的同源策略。</h3><p>概念:同源策略是客户端脚本（尤其是<code>Javascript</code>）的重要的安全度量标准。它最早出自<code>Netscape Navigator2.0</code>，其目的是防止某个文档或脚本从多个不同源装载。</p><p>这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。<br>指一段脚本只能读取来自同一来源的窗口和文档的属性。</p><h3 id="为什么要有同源限制？"><a href="#为什么要有同源限制？" class="headerlink" title="为什么要有同源限制？"></a>为什么要有同源限制？</h3><p>我们举例说明：比如一个黑客程序，他利用<code>Iframe</code>把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过<code>Javascript</code>读取到你的表单中<code>input</code>中的内容，这样用户名，密码就轻松到手了。</p><h3 id="什么是-“use-strict”-使用它的好处和坏处分别是什么？"><a href="#什么是-“use-strict”-使用它的好处和坏处分别是什么？" class="headerlink" title="什么是 “use strict”; ? 使用它的好处和坏处分别是什么？"></a>什么是 “use strict”; ? 使用它的好处和坏处分别是什么？</h3><p><code>ECMAscript 5</code>添加了第二种运行模式：”严格模式”（strict mode）。顾名思义，这种模式使得<code>Javascript</code>在更严格的条件下运行。</p><p>设立”严格模式”的目的，主要有以下几个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</span><br><span class="line">- 消除代码运行的一些不安全之处，保证代码运行的安全；</span><br><span class="line">- 提高编译器效率，增加运行速度；</span><br><span class="line">- 为未来新版本的Javascript做好铺垫。</span><br></pre></td></tr></table></figure><p>注：经过测试<code>IE6,7,8,9</code>均不支持严格模式。</p><p>缺点：<br>现在网站的<code>JS</code> 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 <code>merge</code> 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。</p><h3 id="GET和POST的区别，何时使用POST？"><a href="#GET和POST的区别，何时使用POST？" class="headerlink" title="GET和POST的区别，何时使用POST？"></a>GET和POST的区别，何时使用POST？</h3><p>​    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符<br>​    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。</p><p>​    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，<br>​    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。</p><p>然而，在以下情况中，请使用 POST 请求：<br>无法使用缓存文件（更新服务器上的文件或数据库）<br>向服务器发送大量数据（POST 没有数据量限制）<br>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</p><h3 id="哪些地方会出现css阻塞，哪些地方会出现js阻塞？"><a href="#哪些地方会出现css阻塞，哪些地方会出现js阻塞？" class="headerlink" title="哪些地方会出现css阻塞，哪些地方会出现js阻塞？"></a>哪些地方会出现css阻塞，哪些地方会出现js阻塞？</h3><p><strong>js的阻塞特性：</strong></p><p>所有浏览器在下载<code>JS</code>的时候，会阻止一切其他活动，比如其他资源的下载，内容的呈现等等。直到<code>JS</code>下载、解析、执行完毕后才开始继续<code>并行下载</code>其他资源并呈现内容。为了提高用户体验，新一代浏览器都支持并行下载<code>JS</code>，但是<code>JS</code>下载仍然会阻塞其它资源的下载（例如.图片，css文件等）。</p><p>由于浏览器为了防止出现<code>JS</code>修改<code>DOM</code>树，需要重新构建<code>DOM</code>树的情况，所以就会阻塞其他的下载和呈现。</p><p>嵌入<code>JS</code>会阻塞所有内容的呈现，而外部<code>JS</code>只会阻塞其后内容的显示，2种方式都会阻塞其后资源的下载。也就是说外部样式不会阻塞外部脚本的加载，但会阻塞外部脚本的执行。</p><p><code>CSS</code>怎么会阻塞加载了？</p><p><code>CSS</code>本来是可以并行下载的，在什么情况下会出现阻塞加载了(在测试观察中，<code>IE6</code>下<code>CSS</code>都是阻塞加载）</p><p>当<code>CSS</code>后面跟着嵌入的<code>JS</code>的时候，该<code>CSS</code>就会出现阻塞后面资源下载的情况。而当把嵌入<code>JS</code>放到<code>CSS</code>前面，就不会出现阻塞的情况了。</p><p>根本原因：</p><p>因为浏览器会维持<code>html</code>中<code>css</code>和<code>js</code>的顺序，样式表必须在嵌入的JS执行前先加载、解析完。而嵌入的<code>JS</code>会阻塞后面的资源加载，所以就会出现上面<code>CSS</code>阻塞下载的情况。</p><h3 id="嵌入JS应该放在什么位置？"><a href="#嵌入JS应该放在什么位置？" class="headerlink" title="嵌入JS应该放在什么位置？"></a>嵌入<code>JS</code>应该放在什么位置？</h3><p>   1、放在底部，虽然放在底部照样会阻塞所有呈现，但不会阻塞资源下载。</p><p>   2、如果嵌入JS放在head中，请把嵌入JS放在CSS头部。</p><p>   3、使用defer（只支持IE）</p><p>   4、不要在嵌入的JS中调用运行时间较长的函数，如果一定要用，可以用<code>setTimeout</code>来调用</p><h3 id="Javascript无阻塞加载具体方式"><a href="#Javascript无阻塞加载具体方式" class="headerlink" title="Javascript无阻塞加载具体方式"></a>Javascript无阻塞加载具体方式</h3><ul><li><strong>将脚本放在底部。</strong><code>&lt;link&gt;</code>还是放在<code>head</code>中，用以保证在<code>js</code>加载前，能加载出正常显示的页面。<code>&lt;script&gt;</code>标签放在<code>&lt;/body&gt;</code>前。</li><li><strong>成组脚本</strong>：由于每个<code>&lt;script&gt;</code>标签下载时阻塞页面解析过程，所以限制页面的<code>&lt;script&gt;</code>总数也可以改善性能。适用于内联脚本和外部脚本。</li><li><strong>非阻塞脚本</strong>：等页面完成加载后，再加载<code>js</code>代码。也就是，在<code>window.onload</code>事件发出后开始下载代码。<br>（1）<code>defer</code>属性：支持IE4和<code>fierfox3.5</code>更高版本浏览器<br>（2）动态脚本元素：文档对象模型（DOM）允许你使用js动态创建<code>HTML</code>的几乎全部文档内容。代码如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var script=document.createElement(&quot;script&quot;);</span><br><span class="line">    script.type=&quot;text/javascript&quot;;</span><br><span class="line">    script.src=&quot;file.js&quot;;</span><br><span class="line">    document.getElementsByTagName(&quot;head&quot;)[0].appendChild(script);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>此技术的重点在于：无论在何处启动下载，文件额下载和运行都不会阻塞其他页面处理过程。即使在head里（除了用于下载文件的http链接）。</p><h3 id="闭包相关问题？"><a href="#闭包相关问题？" class="headerlink" title="闭包相关问题？"></a>闭包相关问题？</h3><p>详情请见：<a href="http://segmentfault.com/blog/trigkit4/1190000000652891" target="_blank" rel="noopener">详解js闭包</a></p><h3 id="js事件处理程序问题？"><a href="#js事件处理程序问题？" class="headerlink" title="js事件处理程序问题？"></a>js事件处理程序问题？</h3><p>详情请见：<a href="http://segmentfault.com/blog/trigkit4/1190000002174034" target="_blank" rel="noopener">JavaScript学习总结（九）事件详解</a></p><h3 id="eval是做什么的？"><a href="#eval是做什么的？" class="headerlink" title="eval是做什么的？"></a>eval是做什么的？</h3><p>它的功能是把对应的字符串解析成JS代码并运行；<br>应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。</p><h3 id="JavaScript原型，原型链-有什么特点？"><a href="#JavaScript原型，原型链-有什么特点？" class="headerlink" title="JavaScript原型，原型链 ? 有什么特点？"></a>JavaScript原型，原型链 ? 有什么特点？</h3><ul><li>原型对象也是普通的对象，是对象一个自带隐式的 <strong>proto</strong> 属性，原型也有可能有自己的原型，如果一个原型对象的原型不为null的话，我们就称之为原型链。</li><li>原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链。</li></ul><h3 id="事件、IE与火狐的事件机制有什么区别？-如何阻止冒泡？"><a href="#事件、IE与火狐的事件机制有什么区别？-如何阻止冒泡？" class="headerlink" title="事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？"></a>事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</h3><ol><li>我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。  </li><li>事件处理机制：IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件。；</li><li>ev.stopPropagation();注意旧ie的方法 ev.cancelBubble = true;</li></ol><h3 id="ajax-是什么-ajax-的交互模型-同步和异步的区别-如何解决跨域问题"><a href="#ajax-是什么-ajax-的交互模型-同步和异步的区别-如何解决跨域问题" class="headerlink" title="ajax 是什么?ajax 的交互模型?同步和异步的区别?如何解决跨域问题?"></a>ajax 是什么?ajax 的交互模型?同步和异步的区别?如何解决跨域问题?</h3><p>详情请见：<a href="http://segmentfault.com/blog/trigkit4/1190000000691919" target="_blank" rel="noopener">JavaScript学习总结（七）Ajax和Http状态字</a></p><ol><li><p>通过异步模式，提升了用户体验</p><ol start="2"><li><p>优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用</p></li><li><p>Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。</p></li><li><p>Ajax的最大的特点是什么。</p></li></ol><p>Ajax可以实现动态不刷新（局部刷新）<br>readyState属性 状态 有5个可取值： 0=未初始化 ，1=启动 2=发送，3=接收，4=完成</p></li></ol><p>ajax的缺点</p><p>  1、ajax不支持浏览器back按钮。</p><p>  2、安全问题 AJAX暴露了与服务器交互的细节。</p><p>  3、对搜索引擎的支持比较弱。</p><p>  4、破坏了程序的异常机制。</p><p>  5、不容易调试。</p><p>跨域： jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面</p><h3 id="js对象的深度克隆"><a href="#js对象的深度克隆" class="headerlink" title="js对象的深度克隆"></a>js对象的深度克隆</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function clone(Obj) &#123;   </span><br><span class="line">      var buf;   </span><br><span class="line">      if (Obj instanceof Array) &#123;   </span><br><span class="line">          buf = [];  //创建一个空的数组 </span><br><span class="line">          var i = Obj.length;   </span><br><span class="line">          while (i--) &#123;   </span><br><span class="line">              buf[i] = clone(Obj[i]);   </span><br><span class="line">          &#125;   </span><br><span class="line">          return buf;   </span><br><span class="line">      &#125;else if (Obj instanceof Object)&#123;   </span><br><span class="line">          buf = &#123;&#125;;  //创建一个空对象 </span><br><span class="line">          for (var k in Obj) &#123;  //为这个对象添加新的属性 </span><br><span class="line">              buf[k] = clone(Obj[k]);   </span><br><span class="line">          &#125;   </span><br><span class="line">          return buf;   </span><br><span class="line">      &#125;else&#123;   </span><br><span class="line">          return Obj;   </span><br><span class="line">      &#125;   </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="AMD和CMD-规范的区别？"><a href="#AMD和CMD-规范的区别？" class="headerlink" title="AMD和CMD 规范的区别？"></a>AMD和CMD 规范的区别？</h3><p>详情请见：<a href="http://segmentfault.com/blog/trigkit4/1190000000733959" target="_blank" rel="noopener">详解JavaScript模块化开发</a></p><h3 id="网站重构的理解？"><a href="#网站重构的理解？" class="headerlink" title="网站重构的理解？"></a>网站重构的理解？</h3><p>网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。</p><p>对于传统的网站来说重构通常是：</p><p>表格(table)布局改为DIV+CSS<br>使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)<br>对于移动平台的优化<br>针对于SEO进行优化<br>深层次的网站重构应该考虑的方面</p><p>减少代码间的耦合<br>让代码保持弹性<br>严格按规范编写代码<br>设计可扩展的API<br>代替旧有的框架、语言(如VB)<br>增强用户体验<br>通常来说对于速度的优化也包含在重构中</p><p>压缩JS、CSS、image等前端资源(通常是由服务器来解决)<br>程序的性能优化(如数据读写)<br>采用CDN来加速资源加载<br>对于JS DOM的优化<br>HTTP服务器的文件缓存</p><h3 id="如何获取UA？"><a href="#如何获取UA？" class="headerlink" title="如何获取UA？"></a>如何获取UA？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt; </span><br><span class="line">    function whatBrowser() &#123;  </span><br><span class="line">        document.Browser.Name.value=navigator.appName;  </span><br><span class="line">        document.Browser.Version.value=navigator.appVersion;  </span><br><span class="line">        document.Browser.Code.value=navigator.appCodeName;  </span><br><span class="line">        document.Browser.Agent.value=navigator.userAgent;  </span><br><span class="line">    &#125;  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="js数组去重"><a href="#js数组去重" class="headerlink" title="js数组去重"></a>js数组去重</h3><p>以下是数组去重的三种方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.unique1 = function () &#123;</span><br><span class="line">  var n = []; //一个新的临时数组</span><br><span class="line">  for (var i = 0; i &lt; this.length; i++) //遍历当前数组</span><br><span class="line">  &#123;</span><br><span class="line">    //如果当前数组的第i已经保存进了临时数组，那么跳过，</span><br><span class="line">    //否则把当前项push到临时数组里面</span><br><span class="line">    if (n.indexOf(this[i]) == -1) n.push(this[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  return n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array.prototype.unique2 = function()</span><br><span class="line">&#123;</span><br><span class="line">    var n = &#123;&#125;,r=[]; //n为hash表，r为临时数组</span><br><span class="line">    for(var i = 0; i &lt; this.length; i++) //遍历当前数组</span><br><span class="line">    &#123;</span><br><span class="line">        if (!n[this[i]]) //如果hash表中没有当前项</span><br><span class="line">        &#123;</span><br><span class="line">            n[this[i]] = true; //存入hash表</span><br><span class="line">            r.push(this[i]); //把当前数组的当前项push到临时数组里面</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array.prototype.unique3 = function()</span><br><span class="line">&#123;</span><br><span class="line">    var n = [this[0]]; //结果数组</span><br><span class="line">    for(var i = 1; i &lt; this.length; i++) //从第二项开始遍历</span><br><span class="line">    &#123;</span><br><span class="line">        //如果当前数组的第i项在当前数组中第一次出现的位置不是i，</span><br><span class="line">        //那么表示第i项是重复的，忽略掉。否则存入结果数组</span><br><span class="line">        if (this.indexOf(this[i]) == i) n.push(this[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">100  Continue  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</span><br><span class="line">200  OK   正常返回信息</span><br><span class="line">201  Created  请求成功并且服务器创建了新的资源</span><br><span class="line">202  Accepted  服务器已接受请求，但尚未处理</span><br><span class="line">301  Moved Permanently  请求的网页已永久移动到新位置。</span><br><span class="line">302 Found  临时性重定向。</span><br><span class="line">303 See Other  临时性重定向，且总是使用 GET 请求新的 URI。</span><br><span class="line">304  Not Modified  自从上次请求后，请求的网页未修改过。</span><br><span class="line"></span><br><span class="line">400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</span><br><span class="line">401 Unauthorized  请求未授权。</span><br><span class="line">403 Forbidden  禁止访问。</span><br><span class="line">404 Not Found  找不到如何与 URI 相匹配的资源。</span><br><span class="line"></span><br><span class="line">500 Internal Server Error  最常见的服务器端错误。</span><br><span class="line">503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</span><br></pre></td></tr></table></figure><h3 id="js操作获取和设置cookie"><a href="#js操作获取和设置cookie" class="headerlink" title="js操作获取和设置cookie"></a>js操作获取和设置cookie</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//创建cookie</span><br><span class="line">function setCookie(name, value, expires, path, domain, secure) &#123;</span><br><span class="line">    var cookieText = encodeURIComponent(name) + &apos;=&apos; + encodeURIComponent(value);</span><br><span class="line">    if (expires instanceof Date) &#123;</span><br><span class="line">        cookieText += &apos;; expires=&apos; + expires;</span><br><span class="line">    &#125;</span><br><span class="line">    if (path) &#123;</span><br><span class="line">        cookieText += &apos;; expires=&apos; + expires;</span><br><span class="line">    &#125;</span><br><span class="line">    if (domain) &#123;</span><br><span class="line">        cookieText += &apos;; domain=&apos; + domain;</span><br><span class="line">    &#125;</span><br><span class="line">    if (secure) &#123;</span><br><span class="line">        cookieText += &apos;; secure&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    document.cookie = cookieText;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//获取cookie</span><br><span class="line">function getCookie(name) &#123;</span><br><span class="line">    var cookieName = encodeURIComponent(name) + &apos;=&apos;;</span><br><span class="line">    var cookieStart = document.cookie.indexOf(cookieName);</span><br><span class="line">    var cookieValue = null;</span><br><span class="line">    if (cookieStart &gt; -1) &#123;</span><br><span class="line">        var cookieEnd = document.cookie.indexOf(&apos;;&apos;, cookieStart);</span><br><span class="line">        if (cookieEnd == -1) &#123;</span><br><span class="line">            cookieEnd = document.cookie.length;</span><br><span class="line">        &#125;</span><br><span class="line">        cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd));</span><br><span class="line">    &#125;</span><br><span class="line">    return cookieValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//删除cookie</span><br><span class="line">function unsetCookie(name) &#123;</span><br><span class="line">    document.cookie = name + &quot;= ; expires=&quot; + new Date(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="说说TCP传输的三次握手策略"><a href="#说说TCP传输的三次握手策略" class="headerlink" title="说说TCP传输的三次握手策略"></a>说说TCP传输的三次握手策略</h3><p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送  后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志：SYN和ACK。<br>发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束<br>若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。</p><h3 id="说说你对Promise的理解"><a href="#说说你对Promise的理解" class="headerlink" title="说说你对Promise的理解"></a>说说你对Promise的理解</h3><p>依照 <code>Promise/A+</code> 的定义，<code>Promise</code> 有四种状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pending: 初始状态, 非 fulfilled 或 rejected.</span><br><span class="line">fulfilled: 成功的操作.</span><br><span class="line">rejected: 失败的操作.</span><br><span class="line">settled: Promise已被fulfilled或rejected，且不是pending</span><br></pre></td></tr></table></figure><p>另外， <code>fulfilled</code> 与 <code>rejected</code> 一起合称 <code>settled</code>。</p><p><code>Promise</code> 对象用来进行延迟(deferred) 和异步(asynchronous ) 计算。</p><blockquote><p>Promise 的构造函数</p></blockquote><p>构造一个 <code>Promise</code>，最基本的用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">    if (...) &#123;  // succeed</span><br><span class="line">        resolve(result);</span><br><span class="line">    &#125; else &#123;   // fails</span><br><span class="line">        reject(Error(errMessage));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Promise</code> 实例拥有 <code>then</code> 方法（具有 <code>then</code> 方法的对象，通常被称为 <code>thenable</code>）。它的使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure><p>接收两个函数作为参数，一个在 <code>fulfilled</code> 的时候被调用，一个在 <code>rejected</code> 的时候被调用，接收参数就是 <code>future，onFulfilled</code> 对应 <code>resolve</code>, <code>onRejected</code> 对应 <code>reject</code>。</p><h2 id="Javascript垃圾回收方法"><a href="#Javascript垃圾回收方法" class="headerlink" title="Javascript垃圾回收方法"></a>Javascript垃圾回收方法</h2><h3 id="标记清除（mark-and-sweep）"><a href="#标记清除（mark-and-sweep）" class="headerlink" title="标记清除（mark and sweep）"></a>标记清除（mark and sweep）</h3><p>这是<code>JavaScript</code>最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。</p><p>垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了</p><h3 id="引用计数-reference-counting"><a href="#引用计数-reference-counting" class="headerlink" title="引用计数(reference counting)"></a>引用计数(reference counting)</h3><p>在低版本<code>IE</code>中经常会出现<a href="https://so.csdn.net/so/search?q=内存泄露&spm=1001.2101.3001.7020" target="_blank" rel="noopener">内存泄露</a>，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。</p><p>在IE中虽然<code>JavaScript</code>对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的，也就是说只要涉及BOM及DOM就会出现循环引用问题。</p><h3 id="谈谈性能优化问题"><a href="#谈谈性能优化问题" class="headerlink" title="谈谈性能优化问题"></a>谈谈性能优化问题</h3><p>代码层面：避免使用css表达式，避免使用高级选择器，通配选择器。<br>缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等<br>请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载。<br>请求带宽：压缩文件，开启GZIP，</p><h3 id="移动端性能优化"><a href="#移动端性能优化" class="headerlink" title="移动端性能优化"></a>移动端性能优化</h3><blockquote><p>尽量使用<code>css3</code>动画，开启硬件加速。适当使用<code>touch</code>事件代替<code>click</code>事件。避免使用<code>css3</code>渐变阴影效果。<br>尽可能少的使用<code>box-shadow</code>与<code>gradients</code>。<code>box-shadow</code>与<code>gradients</code>往往都是页面的性能杀手</p></blockquote><h3 id="什么是Etag？"><a href="#什么是Etag？" class="headerlink" title="什么是Etag？"></a>什么是Etag？</h3><p>浏览器下载组件的时候，会将它们存储到浏览器缓存中。如果需要再次获取相同的组件，浏览器将检查组件的缓存时间，<br>假如已经过期，那么浏览器将发送一个条件GET请求到服务器，服务器判断缓存还有效，则发送一个304响应，<br>告诉浏览器可以重用缓存组件。</p><p>那么服务器是根据什么判断缓存是否还有效呢?答案有两种方式，一种是前面提到的ETag，另一种是根据<code>Last-Modified</code></p><h3 id="Expires和Cache-Control"><a href="#Expires和Cache-Control" class="headerlink" title="Expires和Cache-Control"></a>Expires和Cache-Control</h3><p><code>Expires</code>要求客户端和服务端的时钟严格同步。HTTP1.1引入<code>Cache-Control</code>来克服Expires头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache, private, max-age=0</span><br><span class="line">ETag: abcde</span><br><span class="line">Expires: Thu, 15 Apr 2014 20:00:00 GMT</span><br><span class="line">Pragma: private</span><br><span class="line">Last-Modified: $now // RFC1123 format</span><br></pre></td></tr></table></figure><h3 id="栈和队列的区别"><a href="#栈和队列的区别" class="headerlink" title="栈和队列的区别?"></a>栈和队列的区别?</h3><p>栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。<br>队列先进先出，栈先进后出。<br>栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除 </p><h3 id="栈和堆的区别？"><a href="#栈和堆的区别？" class="headerlink" title="栈和堆的区别？"></a>栈和堆的区别？</h3><p>栈区（stack）—   由编译器自动分配释放   ，存放函数的参数值，局部变量的值等。<br>堆区（heap）   —   一般由程序员分配释放，   若程序员不释放，程序结束时可能由OS回收。<br>堆（数据结构）：堆可以被看成是一棵树，如：堆排序；<br>栈（数据结构）：一种先进后出的数据结构。 </p><h3 id="关于Http-2-0-你知道多少？"><a href="#关于Http-2-0-你知道多少？" class="headerlink" title="关于Http 2.0 你知道多少？"></a>关于Http 2.0 你知道多少？</h3><p><code>HTTP/2</code>引入了“服务端推（serverpush）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。<br><code>HTTP/2</code>提供更多的加密支持<br><code>HTTP/2</code>使用多路技术，允许多个消息在一个连接上同时交差。<br>它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的<code>header</code>都只会占用很小比例的带宽。</p><h3 id="什么是防抖和节流？有什么区别？如何实现？"><a href="#什么是防抖和节流？有什么区别？如何实现？" class="headerlink" title="什么是防抖和节流？有什么区别？如何实现？"></a>什么是防抖和节流？有什么区别？如何实现？</h3><h4 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h4><p>触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间<br>思路：<br>每次触发事件时都取消之前的延时调用方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function debounce(fn) &#123;</span><br><span class="line">      let timeout = null; // 创建一个标记用来存放定时器的返回值</span><br><span class="line">      return function () &#123;</span><br><span class="line">        clearTimeout(timeout); // 每当用户输入的时候把前一个 setTimeout clear 掉</span><br><span class="line">        timeout = setTimeout(() =&gt; &#123; // 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数</span><br><span class="line">          fn.apply(this, arguments);</span><br><span class="line">        &#125;, 500);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    function sayHi() &#123;</span><br><span class="line">      console.log(&apos;防抖成功&apos;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><pre><code>var inp = document.getElementById(&apos;inp&apos;);inp.addEventListener(&apos;input&apos;, debounce(sayHi)); // 防抖</code></pre><h4 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h4><p>高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率<br>思路：<br>每次触发事件时都判断当前是否有等待执行的延时函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function throttle(fn) &#123;</span><br><span class="line">      let canRun = true; // 通过闭包保存一个标记</span><br><span class="line">      return function () &#123;</span><br><span class="line">        if (!canRun) return; // 在函数开头判断标记是否为true，不为true则return</span><br><span class="line">        canRun = false; // 立即设置为false</span><br><span class="line">        setTimeout(() =&gt; &#123; // 将外部传入的函数的执行放在setTimeout中</span><br><span class="line">          fn.apply(this, arguments);</span><br><span class="line">          // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉</span><br><span class="line">          canRun = true;</span><br><span class="line">        &#125;, 500);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    function sayHi(e) &#123;</span><br><span class="line">      console.log(e.target.innerWidth, e.target.innerHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    window.addEventListener(&apos;resize&apos;, throttle(sayHi));</span><br></pre></td></tr></table></figure><h3 id="get请求传参长度的误区、get和post请求在缓存方面的区别"><a href="#get请求传参长度的误区、get和post请求在缓存方面的区别" class="headerlink" title="get请求传参长度的误区、get和post请求在缓存方面的区别"></a>get请求传参长度的误区、get和post请求在缓存方面的区别</h3><p>误区：我们经常说get请求参数的大小存在限制，而post请求的参数大小是无限制的。</p><p>实际上HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对get请求参数的限制是来源与浏览器或web服务器，浏览器或web服务器限制了url的长度。为了明确这个概念，我们必须再次强调下面几点:</p><p>HTTP 协议 未规定 GET 和POST的长度限制<br>GET的最大长度显示是因为 浏览器和 web服务器限制了 URI的长度<br>不同的浏览器和WEB服务器，限制的最大长度不一样<br>要支持IE，则最大长度为2083byte，若只支持Chrome，则最大长度 8182byte<br>补充补充一个get和post在缓存方面的区别：</p><p>get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。<br>post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。</p><h3 id="模块化发展历程"><a href="#模块化发展历程" class="headerlink" title="模块化发展历程"></a>模块化发展历程</h3><p>可从IIFE、AMD、CMD、CommonJS、UMD、webpack(require.ensure)、ES Module、<code>&lt;script type=&quot;module&quot;&gt;</code> 这几个角度考虑。</p><p>模块化主要是用来抽离公共代码，隔离作用域，避免变量冲突等。</p><p>IIFE： 使用自执行函数来编写模块化，特点：在一个单独的函数作用域中执行代码，避免变量冲突。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    data:[]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>AMD： 使用requireJS 来编写模块化，特点：依赖必须提前声明好。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(&apos;./index.js&apos;,function(code)&#123;</span><br><span class="line">    // code 就是index.js 返回的内容</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>CMD： 使用seaJS 来编写模块化，特点：支持动态引入依赖文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(function(require, exports, module) &#123;  </span><br><span class="line">  var indexCode = require(&apos;./index.js&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>CommonJS： nodejs 中自带的模块化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);</span><br></pre></td></tr></table></figure><p>UMD：兼容AMD，CommonJS 模块化语法。</p><p>webpack(require.ensure)：webpack 2.x 版本中的代码分割。</p><p>ES Modules： ES6 引入的模块化，支持import 来引入另一个 js 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import a from &apos;a&apos;;</span><br></pre></td></tr></table></figure><h3 id="npm-模块安装机制，为什么输入-npm-install-就可以自动安装对应的模块？"><a href="#npm-模块安装机制，为什么输入-npm-install-就可以自动安装对应的模块？" class="headerlink" title="npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？"></a>npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？</h3><h4 id="npm-模块安装机制："><a href="#npm-模块安装机制：" class="headerlink" title="npm 模块安装机制："></a>npm 模块安装机制：</h4><p>发出npm install命令<br>查询node_modules目录之中是否已经存在指定模块</p><p>若存在，不再重新安装<br>若不存在</p><p>npm 向 registry 查询模块压缩包的网址<br>下载压缩包，存放在根目录下的.npm目录里<br>解压压缩包到当前项目的node_modules目录</p><h4 id="npm-实现原理"><a href="#npm-实现原理" class="headerlink" title="npm 实现原理"></a>npm 实现原理</h4><p>输入 npm install 命令并敲下回车后，会经历如下几个阶段（以 npm 5.5.1 为例）：</p><h5 id="执行工程自身-preinstall"><a href="#执行工程自身-preinstall" class="headerlink" title="执行工程自身 preinstall"></a>执行工程自身 preinstall</h5><p>当前 npm 工程如果定义了 preinstall 钩子此时会被执行。</p><h5 id="确定首层依赖模块"><a href="#确定首层依赖模块" class="headerlink" title="确定首层依赖模块"></a>确定首层依赖模块</h5><p>首先需要做的是确定工程中的首层依赖，也就是 dependencies 和 devDependencies 属性中直接指定的模块（假设此时没有添加 npm install 参数）。</p><p>工程本身是整棵依赖树的根节点，每个首层依赖模块都是根节点下面的一棵子树，npm 会开启多进程从每个首层依赖模块开始逐步寻找更深层级的节点。</p><h5 id="获取模块"><a href="#获取模块" class="headerlink" title="获取模块"></a>获取模块</h5><p>获取模块是一个递归的过程，分为以下几步：</p><p>获取模块信息。在下载一个模块之前，首先要确定其版本，这是因为 package.json 中往往是 semantic version（semver，语义化版本）。此时如果版本描述文件（npm-shrinkwrap.json 或 package-lock.json）中有该模块信息直接拿即可，如果没有则从仓库获取。如 packaeg.json 中某个包的版本是 ^1.1.0，npm 就会去仓库中获取符合 1.x.x 形式的最新版本。<br>获取模块实体。上一步会获取到模块的压缩包地址（resolved 字段），npm 会用此地址检查本地缓存，缓存中有就直接拿，如果没有则从仓库下载。<br>查找该模块依赖，如果有依赖则回到第1步，如果没有则停止。</p><h5 id="模块扁平化（dedupe）"><a href="#模块扁平化（dedupe）" class="headerlink" title="模块扁平化（dedupe）"></a>模块扁平化（dedupe）</h5><p>上一步获取到的是一棵完整的依赖树，其中可能包含大量重复模块。比如 A 模块依赖于 loadsh，B 模块同样依赖于 lodash。在 npm3 以前会严格按照依赖树的结构进行安装，因此会造成模块冗余。</p><p>从 npm3 开始默认加入了一个 dedupe 的过程。它会遍历所有节点，逐个将模块放在根节点下面，也就是 node-modules 的第一层。当发现有重复模块时，则将其丢弃。</p><p>这里需要对重复模块进行一个定义，它指的是模块名相同且 semver 兼容。每个 semver 都对应一段版本允许范围，如果两个模块的版本允许范围存在交集，那么就可以得到一个兼容版本，而不必版本号完全一致，这可以使更多冗余模块在 dedupe 过程中被去掉。</p><p>比如 node-modules 下 foo 模块依赖 lodash@^1.0.0，bar 模块依赖 lodash@^1.1.0，则 ^1.1.0 为兼容版本。</p><p>而当 foo 依赖 lodash@^2.0.0，bar 依赖 lodash@^1.1.0，则依据 semver 的规则，二者不存在兼容版本。会将一个版本放在 node_modules 中，另一个仍保留在依赖树里。</p><p>举个例子，假设一个依赖树原本是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">-- foo</span><br><span class="line">---- lodash@version1</span><br><span class="line"></span><br><span class="line">-- bar</span><br><span class="line">---- lodash@version2</span><br></pre></td></tr></table></figure><p>假设 version1 和 version2 是兼容版本，则经过 dedupe 会成为下面的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">-- foo</span><br><span class="line"></span><br><span class="line">-- bar</span><br><span class="line"></span><br><span class="line">-- lodash（保留的版本为兼容版本）</span><br></pre></td></tr></table></figure><p>假设 version1 和 version2 为非兼容版本，则后面的版本保留在依赖树中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">-- foo</span><br><span class="line">-- lodash@version1</span><br><span class="line"></span><br><span class="line">-- bar</span><br><span class="line">---- lodash@version2</span><br></pre></td></tr></table></figure><h5 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h5><p>这一步将会更新工程中的 node_modules，并执行模块中的生命周期函数（按照 preinstall、install、postinstall 的顺序）。</p><h5 id="执行工程自身生命周期"><a href="#执行工程自身生命周期" class="headerlink" title="执行工程自身生命周期"></a>执行工程自身生命周期</h5><p>当前 npm 工程如果定义了钩子此时会被执行（按照 install、postinstall、prepublish、prepare 的顺序）。</p><p>最后一步是生成或更新版本描述文件，npm install 过程完成。</p><h3 id="ES5的继承和ES6的继承有什么区别？"><a href="#ES5的继承和ES6的继承有什么区别？" class="headerlink" title="ES5的继承和ES6的继承有什么区别？"></a>ES5的继承和ES6的继承有什么区别？</h3><p>ES5的继承时通过prototype或构造函数机制来实现。ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.apply(this)）。</p><p>ES6的继承机制完全不同，实质上是先创建父类的实例对象this（所以必须先调用父类的super()方法），然后再用子类的构造函数修改this。</p><p>具体的：ES6通过class关键字定义类，里面有构造方法，类之间通过extends关键字实现继承。子类必须在constructor方法中调用super方法，否则新建实例报错。因为子类没有自己的this对象，而是继承了父类的this对象，然后对其进行加工。如果不调用super方法，子类得不到this对象。</p><p>ps：super关键字指代父类的实例，即父类的this对象。在子类构造函数中，调用super后，才可使用this关键字，否则报错。</p><h3 id="定时器的执行顺序或机制？"><a href="#定时器的执行顺序或机制？" class="headerlink" title="定时器的执行顺序或机制？"></a>定时器的执行顺序或机制？</h3><p>因为js是单线程的，浏览器遇到setTimeout或者setInterval会先执行完当前的代码块，在此之前会把定时器推入浏览器的待执行事件队列里面，等到浏览器执行完当前代码之后会看一下事件队列里面有没有任务，有的话才执行定时器的代码。所以即使把定时器的时间设置为0还是会先执行当前的一些代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">    var aa = 0;</span><br><span class="line">    var testSet = setInterval(function()&#123;</span><br><span class="line">        aa++;</span><br><span class="line">        console.log(123);</span><br><span class="line">        if(aa&lt;10)&#123;</span><br><span class="line">            clearInterval(testSet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,20);</span><br><span class="line">  var testSet1 = setTimeout(function()&#123;</span><br><span class="line">    console.log(321)</span><br><span class="line">  &#125;,1000);</span><br><span class="line">  for(var i=0;i&lt;10;i++)&#123;</span><br><span class="line">    console.log(&apos;test&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test //10次</span><br><span class="line">undefined</span><br><span class="line">123</span><br><span class="line">321</span><br></pre></td></tr></table></figure><h3 id="‘1’-’2’-’3’-map-parseInt-输出什么-为什么"><a href="#‘1’-’2’-’3’-map-parseInt-输出什么-为什么" class="headerlink" title="[‘1’,’2’,’3’].map(parseInt) 输出什么,为什么?"></a>[‘1’,’2’,’3’].map(parseInt) 输出什么,为什么?</h3><p>输出：[1, NaN, NaN]</p><p>首先让我们回顾一下，map函数的第一个参数callback：<br>var new_array = arr.map(function callback(currentValue[, index[, array]]) { // Return element for new_array }[, thisArg])<br>这个callback一共可以接收三个参数，其中第一个参数代表当前被处理的元素，而第二个参数代表该元素的索引。</p><p>而parseInt则是用来解析字符串的，使字符串成为指定基数的整数。<br>parseInt(string, radix)<br>接收两个参数，第一个表示被处理的值（字符串），第二个表示为解析时的基数。<br>了解这两个函数后，我们可以模拟一下运行情况<br>parseInt(‘1’, 0) //radix为0时，且string参数不以“0x”和“0”开头时，按照10为基数处理。这个时候返回1<br>parseInt(‘2’, 1) //基数为1（1进制）表示的数中，最大值小于2，所以无法解析，返回NaN<br>parseInt(‘3’, 2) //基数为2（2进制）表示的数中，最大值小于3，所以无法解析，返回NaN<br>map函数返回的是一个数组，所以最后结果为[1, NaN, NaN]</p><h3 id="Doctype作用-严格模式与混杂模式如何区分？它们有何意义-1"><a href="#Doctype作用-严格模式与混杂模式如何区分？它们有何意义-1" class="headerlink" title="Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?"></a>Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</h3><p>Doctype声明于文档最前面，告诉浏览器以何种方式来渲染页面，这里有两种模式，严格模式和混杂模式。</p><p>严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。<br>混杂模式，向后兼容，模拟老式浏览器，防止浏览器无法兼容页面。</p><h3 id="fetch发送2次请求的原因"><a href="#fetch发送2次请求的原因" class="headerlink" title="fetch发送2次请求的原因"></a>fetch发送2次请求的原因</h3><p>fetch发送post请求的时候，总是发送2次，第一次状态码是204，第二次才成功？</p><p>原因很简单，因为你用fetch的post请求的时候，导致fetch 第一次发送了一个Options请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求。</p><h2 id="http、浏览器对象"><a href="#http、浏览器对象" class="headerlink" title="http、浏览器对象"></a>http、浏览器对象</h2><h3 id="HTTPS-握手过程中，客户端如何验证证书的合法性"><a href="#HTTPS-握手过程中，客户端如何验证证书的合法性" class="headerlink" title="HTTPS 握手过程中，客户端如何验证证书的合法性"></a>HTTPS 握手过程中，客户端如何验证证书的合法性</h3><h4 id="首先什么是HTTP协议"><a href="#首先什么是HTTP协议" class="headerlink" title="首先什么是HTTP协议?"></a>首先什么是HTTP协议?</h4><p>http协议是超文本传输协议，位于tcp/ip四层模型中的应用层；通过请求/响应的方式在客户端和服务器之间进行通信；但是缺少安全性，http协议信息传输是通过明文的方式传输，不做任何加密，相当于在网络上裸奔；容易被中间人恶意篡改，这种行为叫做中间人攻击；</p><h4 id="加密通信："><a href="#加密通信：" class="headerlink" title="加密通信："></a>加密通信：</h4><p>为了安全性，双方可以使用对称加密的方式key进行信息交流，但是这种方式对称加密秘钥也会被拦截，也不够安全，进而还是存在被中间人攻击风险；<br>于是人们又想出来另外一种方式，使用非对称加密的方式；使用公钥/私钥加解密；通信方A发起通信并携带自己的公钥，接收方B通过公钥来加密对称秘钥；然后发送给发起方A；A通过私钥解密；双发接下来通过对称秘钥来进行加密通信；但是这种方式还是会存在一种安全性；中间人虽然不知道发起方A的私钥，但是可以做到偷天换日，将拦截发起方的公钥key;并将自己生成的一对公/私钥的公钥发送给B；接收方B并不知道公钥已经被偷偷换过；按照之前的流程，B通过公钥加密自己生成的对称加密秘钥key2;发送给A；<br>这次通信再次被中间人拦截，尽管后面的通信，两者还是用key2通信，但是中间人已经掌握了Key2;可以进行轻松的加解密；还是存在被中间人攻击风险；</p><h4 id="解决困境：权威的证书颁发机构CA来解决；"><a href="#解决困境：权威的证书颁发机构CA来解决；" class="headerlink" title="解决困境：权威的证书颁发机构CA来解决；"></a>解决困境：权威的证书颁发机构CA来解决；</h4><p>制作证书：作为服务端的A，首先把自己的公钥key1发给证书颁发机构，向证书颁发机构进行申请证书；证书颁发机构有一套自己的公私钥，CA通过自己的私钥来加密key1,并且通过服务端网址等信息生成一个证书签名，证书签名同样使用机构的私钥进行加密；制作完成后，机构将证书发给A；<br>校验证书真伪：当B向服务端A发起请求通信的时候，A不再直接返回自己的公钥，而是返回一个证书；<br>说明：各大浏览器和操作系统已经维护了所有的权威证书机构的名称和公钥。B只需要知道是哪个权威机构发的证书，使用对应的机构公钥，就可以解密出证书签名；接下来，B使用同样的规则，生成自己的证书签名，如果两个签名是一致的，说明证书是有效的；<br>签名验证成功后，B就可以再次利用机构的公钥，解密出A的公钥key1;接下来的操作，就是和之前一样的流程了；</p><h4 id="中间人是否会拦截发送假证书到B呢？"><a href="#中间人是否会拦截发送假证书到B呢？" class="headerlink" title="中间人是否会拦截发送假证书到B呢？"></a>中间人是否会拦截发送假证书到B呢？</h4><p>因为证书的签名是由服务器端网址等信息生成的，并且通过第三方机构的私钥加密中间人无法篡改； 所以最关键的问题是证书签名的真伪；</p><p>https主要的思想是在http基础上增加了ssl安全层，即以上认证过程；</p><h3 id="TCP三次握手和四次挥手"><a href="#TCP三次握手和四次挥手" class="headerlink" title="TCP三次握手和四次挥手"></a>TCP三次握手和四次挥手</h3><p>三次握手之所以是三次是保证client和server均让对方知道自己的接收和发送能力没问题而保证的最小次数。</p><p>第一次client =&gt; server 只能server判断出client具备发送能力<br>第二次 server =&gt; client client就可以判断出server具备发送和接受能力。此时client还需让server知道自己接收能力没问题于是就有了第三次<br>第三次 client =&gt; server 双方均保证了自己的接收和发送能力没有问题</p><p>其中，为了保证后续的握手是为了应答上一个握手，每次握手都会带一个标识 seq，后续的ACK都会对这个seq进行加一来进行确认。</p><h3 id="img-iframe-script来发送跨域请求有什么优缺点？"><a href="#img-iframe-script来发送跨域请求有什么优缺点？" class="headerlink" title="img iframe script来发送跨域请求有什么优缺点？"></a>img iframe script来发送跨域请求有什么优缺点？</h3><p>iframe<br>优点：跨域完毕之后DOM操作和互相之间的JavaScript调用都是没有问题的</p><p>缺点：1.若结果要以URL参数传递，这就意味着在结果数据量很大的时候需要分割传递，巨烦。2.还有一个是iframe本身带来的，母页面和iframe本身的交互本身就有安全性限制。</p><p>script<br>优点：可以直接返回json格式的数据，方便处理</p><p>缺点：只接受GET请求方式</p><p>图片ping<br>优点：可以访问任何url，一般用来进行点击追踪，做页面分析常用的方法</p><p>缺点：不能访问响应文本，只能监听是否响应</p><h3 id="http和https的区别？"><a href="#http和https的区别？" class="headerlink" title="http和https的区别？"></a>http和https的区别？</h3><p>http传输的数据都是未加密的，也就是明文的，网景公司设置了SSL协议来对http协议传输的数据进行加密处理，简单来说https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。 主要的区别如下：</p><p>Https协议需要ca证书，费用较高。<br>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。<br>使用不同的链接方式，端口也不同，一般而言，http协议的端口为80，https的端口为443<br>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><h3 id="什么是Bom？有哪些常用的Bom属性？"><a href="#什么是Bom？有哪些常用的Bom属性？" class="headerlink" title="什么是Bom？有哪些常用的Bom属性？"></a>什么是Bom？有哪些常用的Bom属性？</h3><p>Bom是浏览器对象</p><h4 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h4><p>location.href– 返回或设置当前文档的URL<br>location.search – 返回URL中的查询字符串部分。例如 <a href="http://www.dreamdu.com/dreamd" target="_blank" rel="noopener">http://www.dreamdu.com/dreamd</a>… 返回包括(?)后面的内容?id=5&amp;name=dreamdu<br>location.hash – 返回URL#后面的内容，如果没有#，返回空 location.host – 返回URL中的域名部分，例如<a href="http://www.dreamdu.com" target="_blank" rel="noopener">www.dreamdu.com</a><br>location.hostname – 返回URL中的主域名部分，例如dreamdu.com<br>location.pathname – 返回URL的域名后的部分。例如 <a href="http://www.dreamdu.com/xhtml/" target="_blank" rel="noopener">http://www.dreamdu.com/xhtml/</a> 返回/xhtml/<br>location.port – 返回URL中的端口部分。例如 <a href="http://www.dreamdu.com:8080/xhtml/" target="_blank" rel="noopener">http://www.dreamdu.com:8080/xhtml/</a> 返回8080<br>location.protocol – 返回URL中的协议部分。例如 <a href="http://www.dreamdu.com:8080/xhtml/" target="_blank" rel="noopener">http://www.dreamdu.com:8080/xhtml/</a> 返回(//)前面的内容http:<br>location.assign – 设置当前文档的URL<br>location.replace() – 设置当前文档的URL，并且在history对象的地址列表中移除这个URL location.replace(url);<br>location.reload() – 重载当前页面</p><h4 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h4><p>history.go() – 前进或后退指定的页面数<br>history.go(num); history.back() – 后退一页<br>history.forward() – 前进一页</p><h4 id="Navigator对象"><a href="#Navigator对象" class="headerlink" title="Navigator对象"></a>Navigator对象</h4><p>navigator.userAgent – 返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串)<br>navigator.cookieEnabled – 返回浏览器是否支持(启用)cookie</p><h3 id="Cookie、sessionStorage、localStorage的区别"><a href="#Cookie、sessionStorage、localStorage的区别" class="headerlink" title="Cookie、sessionStorage、localStorage的区别"></a>Cookie、sessionStorage、localStorage的区别</h3><p>共同点：都是保存在浏览器端，并且是同源的</p><h4 id="Cookie："><a href="#Cookie：" class="headerlink" title="Cookie："></a>Cookie：</h4><p>cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下,存储的大小很小只有4K左右。 （key：可以在浏览器和服务器端来回传递，存储容量小，只有大约4K左右）</p><h4 id="sessionStorage："><a href="#sessionStorage：" class="headerlink" title="sessionStorage："></a>sessionStorage：</h4><p>仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持，localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。（key：本身就是一个回话过程，关闭浏览器后消失，session为一个回话，当页面不同即使是同一页面打开两次，也被视为同一次回话）</p><h4 id="localStorage："><a href="#localStorage：" class="headerlink" title="localStorage："></a>localStorage：</h4><p>localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。（key：同源窗口都会共享，并且不会失效，不管窗口或者浏览器关闭与否都会始终生效）</p><h4 id="补充说明一下cookie的作用："><a href="#补充说明一下cookie的作用：" class="headerlink" title="补充说明一下cookie的作用："></a>补充说明一下cookie的作用：</h4><p>保存用户登录状态。例如将用户id存储于一个cookie内，这样当用户下次访问该页面时就不需要重新登录了，现在很多论坛和社区都提供这样的功能。 cookie还可以设置过期时间，当超过时间期限后，cookie就会自动消失。因此，系统往往可以提示用户保持登录状态的时间：常见选项有一个月、三个 月、一年等。<br>跟踪用户行为。例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了 cookie后就会显得很人性化了，系统能够记住上一次访问的地区，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。因为一切都是在后 台完成，所以这样的页面就像为某个用户所定制的一样，使用起来非常方便<br>定制页面。如果网站提供了换肤或更换布局的功能，那么可以使用cookie来记录用户的选项，例如：背景色、分辨率等。当用户下次访问时，仍然可以保存上一次访问的界面风格。</p><h3 id="Cookie如何防范XSS攻击"><a href="#Cookie如何防范XSS攻击" class="headerlink" title="Cookie如何防范XSS攻击"></a>Cookie如何防范XSS攻击</h3><p>XSS（跨站脚本攻击）是指攻击者在返回的HTML中嵌入javascript脚本，为了减轻这些攻击，需要在HTTP头部配上，set-cookie：</p><p>httponly-这个属性可以防止XSS,它会禁止javascript脚本来访问cookie。<br>secure - 这个属性告诉浏览器仅在请求为https的时候发送cookie。<br>结果应该是这样的：Set-Cookie=…..</p><h3 id="浏览器和-Node-事件循环的区别？"><a href="#浏览器和-Node-事件循环的区别？" class="headerlink" title="浏览器和 Node 事件循环的区别？"></a>浏览器和 Node 事件循环的区别？</h3><p>其中一个主要的区别在于浏览器的event loop 和nodejs的event loop 在处理异步事件的顺序是不同的,nodejs中有micro event;其中Promise属于micro event 该异步事件的处理顺序就和浏览器不同.nodejs V11.0以上 这两者之间的顺序就相同了.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function test () &#123;</span><br><span class="line">   console.log(&apos;start&apos;)</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&apos;children2&apos;)</span><br><span class="line">        Promise.resolve().then(() =&gt; &#123;console.log(&apos;children2-1&apos;)&#125;)</span><br><span class="line">    &#125;, 0)</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&apos;children3&apos;)</span><br><span class="line">        Promise.resolve().then(() =&gt; &#123;console.log(&apos;children3-1&apos;)&#125;)</span><br><span class="line">    &#125;, 0)</span><br><span class="line">    Promise.resolve().then(() =&gt; &#123;console.log(&apos;children1&apos;)&#125;)</span><br><span class="line">    console.log(&apos;end&apos;) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>// 以上代码在node11以下版本的执行结果(先执行所有的宏任务，再执行微任务)<br>// start<br>// end<br>// children1<br>// children2<br>// children3<br>// children2-1<br>// children3-1</p><p>// 以上代码在node11及浏览器的执行结果(顺序执行宏任务和微任务)<br>// start<br>// end<br>// children1<br>// children2<br>// children2-1<br>// children3<br>// children3-1</p><h3 id="简述HTTPS中间人攻击"><a href="#简述HTTPS中间人攻击" class="headerlink" title="简述HTTPS中间人攻击"></a>简述HTTPS中间人攻击</h3><p>https协议由 http + ssl 协议构成，具体的链接过程可参考SSL或TLS握手的概述</p><h4 id="中间人攻击过程如下："><a href="#中间人攻击过程如下：" class="headerlink" title="中间人攻击过程如下："></a>中间人攻击过程如下：</h4><p>服务器向客户端发送公钥。<br>攻击者截获公钥，保留在自己手上。<br>然后攻击者自己生成一个【伪造的】公钥，发给客户端。<br>客户端收到伪造的公钥后，生成加密hash值发给服务器。<br>攻击者获得加密hash值，用自己的私钥解密获得真秘钥。<br>同时生成假的加密hash值，发给服务器。<br>服务器用私钥解密获得假秘钥。<br>服务器用加秘钥加密传输信息</p><h4 id="防范方法："><a href="#防范方法：" class="headerlink" title="防范方法："></a>防范方法：</h4><p>服务端在发送浏览器的公钥中加入CA证书，浏览器可以验证CA证书的有效性</p><h3 id="说几条web前端优化策略"><a href="#说几条web前端优化策略" class="headerlink" title="说几条web前端优化策略"></a>说几条web前端优化策略</h3><p>(1). 减少HTTP请求数</p><p>这条策略基本上所有前端人都知道，而且也是最重要最有效的。都说要减少HTTP请求，那请求多了到底会怎么样呢？首先，每个请求都是有成本的，既包 含时间成本也包含资源成本。一个完整的请求都需要经过DNS寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据这样一个“漫长”而复杂的过程。 时间成本就是用户需要看到或者“感受”到这个资源是必须要等待这个过程结束的，资源上由于每个请求都需要携带数据，因此每个请求都需要占用带宽。</p><p>另外，由于浏览器进行并发请求的请求数是有上限的，因此请求数多了以后，浏览器需要分批进行请求，因此会增加用户的等待时间，会给 用户造成站点速度慢这样一个印象，即使可能用户能看到的第一屏的资源都已经请求完了，但是浏览器的进度条会一直存在。减少HTTP请求数的主要途径包括：</p><p>(2). 从设计实现层面简化页面</p><p>如果你的页面像百度首页一样简单，那么接下来的规则基本上都用不着了。保持页面简洁、减少资源的使用时最直接的。如果不是这样，你的页面需要华丽的皮肤，则继续阅读下面的内容。</p><p>(3). 合理设置HTTP缓存</p><p>缓存的力量是强大的，恰当的缓存设置可以大大的减少HTTP请求。以有啊首页为例，当浏览器没有缓存的时候访问一共会发出78个请求，共600多K 数据（如图1.1），而当第二次访问即浏览器已缓存之后访问则仅有10个请求，共20多K数据（如图1.2）。（这里需要说明的是，如果直接F5刷新页面 的话效果是不一样的，这种情况下请求数还是一样，不过被缓存资源的请求服务器是304响应，只有Header没有Body，可以节省带宽）</p><p>怎样才算合理设置？原则很简单，能缓存越多越好，能缓存越久越好。例如，很少变化的图片资源可以直接通过HTTP Header中的Expires设置一个很长的过期头；变化不频繁而又可能会变的资源可以使用Last-Modifed来做请求验证。尽可能的让资源能够 在缓存中待得更久。</p><p>(4). 资源合并与压缩</p><p>如果可以的话，尽可能的将外部的脚本、样式进行合并，多个合为一个。另外，CSS、Javascript、Image都可以用相应的工具进行压缩，压缩后往往能省下不少空间。</p><p>(5). CSS Sprites</p><p>合并CSS图片，减少请求数的又一个好办法。</p><p>(6). Inline Images</p><p>使用data: URL scheme的方式将图片嵌入到页面或CSS中，如果不考虑资源管理上的问题的话，不失为一个好办法。如果是嵌入页面的话换来的是增大了页面的体积，而且无法利用浏览器缓存。使用在CSS中的图片则更为理想一些。</p><p>(7). Lazy Load Images</p><p>这条策略实际上并不一定能减少HTTP请求数，但是却能在某些条件下或者页面刚加载时减少HTTP请求数。对于图片而言，在页面刚加载的时候可以只 加载第一屏，当用户继续往后滚屏的时候才加载后续的图片。这样一来，假如用户只对第一屏的内容感兴趣时，那剩余的图片请求就都节省了。有啊首页曾经的做法 是在加载的时候把第一屏之后的图片地址缓存在Textarea标签中，待用户往下滚屏的时候才“惰性”加载。</p><h3 id="你了解的浏览器的重绘和回流导致的性能问题"><a href="#你了解的浏览器的重绘和回流导致的性能问题" class="headerlink" title="你了解的浏览器的重绘和回流导致的性能问题"></a>你了解的浏览器的重绘和回流导致的性能问题</h3><p>重绘（Repaint）和回流（Reflow）</p><p>重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大。</p><p>重绘是当节点需要更改外观而不会影响布局的，比如改变 color就叫称为重绘<br>回流是布局或者几何属性需要改变就称为回流。<br>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流。</p><p>所以以下几个动作可能会导致性能问题：</p><ul><li>改变 window 大小</li><li>改变字体</li><li>添加或删除样式</li><li>文字改变</li><li>定位或者浮动</li><li>盒模型</li></ul><p>很多人不知道的是，重绘和回流其实和 Event loop 有关。</p><p>当 Event loop 执行完 Microtasks 后，会判断 document 是否需要更新。因为浏览器是 60Hz 的刷新率，每 16ms 才会更新一次。<br>然后判断是否有 resize或者 scroll，有的话会去触发事件，所以 resize和 scroll事件也是至少 16ms 才会触发一次，并且自带节流功能。<br>判断是否触发了 media query<br>更新动画并且发送事件<br>判断是否有全屏操作事件<br>执行 requestAnimationFrame回调<br>执行 IntersectionObserver回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好<br>更新界面<br>以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback回调。<br>减少重绘和回流</p><p>使用 translate 替代 top</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;test&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .test &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 10px;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background: red;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        // 引起回流</span><br><span class="line">        document.querySelector(&apos;.test&apos;).style.top = &apos;100px&apos;</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>使用 visibility替换 display: none，因为前者只会引起重绘，后者会引发回流（改变了布局）</p><p>把 DOM 离线后修改，比如：先把 DOM 给 display:none(有一次 Reflow)，然后你修改100次，然后再把它显示出来</p><p>不要把 DOM 结点的属性值放在一个循环里当成循环里的变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(let i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">    // 获取 offsetTop 会导致回流，因为需要去获取正确的值</span><br><span class="line">    console.log(document.querySelector(&apos;.test&apos;).style.offsetTop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局<br>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame<br>CSS 选择符从右往左匹配查找，避免 DOM 深度过深<br>将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 video标签，浏览器会自动将该节点变为图层。</p><h2 id="react、Vue"><a href="#react、Vue" class="headerlink" title="react、Vue"></a>react、Vue</h2><h3 id="写-React-Vue-项目时为什么要在列表组件中写-key，其作用是什么？"><a href="#写-React-Vue-项目时为什么要在列表组件中写-key，其作用是什么？" class="headerlink" title="写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？"></a>写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？</h3><p>vue和react都是采用diff算法来对比新旧虚拟节点，从而更新节点。在vue的diff函数中（建议先了解一下diff算法过程）。<br>在交叉对比中，当新节点跟旧节点头尾交叉对比没有结果时，会根据新节点的key去对比旧节点数组中的key，从而找到相应旧节点（这里对应的是一个key =&gt; index 的map映射）。如果没找到就认为是一个新增节点。而如果没有key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个map映射，另一种是遍历查找。相比而言。map映射的速度更快。<br>vue部分源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// vue项目  src/core/vdom/patch.js  -488行</span><br><span class="line">// 以下是为了阅读性进行格式化后的代码</span><br><span class="line"></span><br><span class="line">// oldCh 是一个旧虚拟节点数组</span><br><span class="line">if (isUndef(oldKeyToIdx)) &#123;</span><br><span class="line">  oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">&#125;</span><br><span class="line">if(isDef(newStartVnode.key)) &#123;</span><br><span class="line">  // map 方式获取</span><br><span class="line">  idxInOld = oldKeyToIdx[newStartVnode.key]</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // 遍历方式获取</span><br><span class="line">  idxInOld = findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">&#125;</span><br><span class="line">创建map函数</span><br><span class="line"></span><br><span class="line">function createKeyToOldIdx (children, beginIdx, endIdx) &#123;</span><br><span class="line">  let i, key</span><br><span class="line">  const map = &#123;&#125;</span><br><span class="line">  for (i = beginIdx; i &lt;= endIdx; ++i) &#123;</span><br><span class="line">    key = children[i].key</span><br><span class="line">    if (isDef(key)) map[key] = i</span><br><span class="line">  &#125;</span><br><span class="line">  return map</span><br><span class="line">&#125;</span><br><span class="line">遍历寻找</span><br><span class="line"></span><br><span class="line">// sameVnode 是对比新旧节点是否相同的函数</span><br><span class="line"> function findIdxInOld (node, oldCh, start, end) &#123;</span><br><span class="line">    for (let i = start; i &lt; end; i++) &#123;</span><br><span class="line">      const c = oldCh[i]</span><br><span class="line">      if (isDef(c) &amp;&amp; sameVnode(node, c)) return i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="React-中-setState-什么时候是同步的，什么时候是异步的？"><a href="#React-中-setState-什么时候是同步的，什么时候是异步的？" class="headerlink" title="React 中 setState 什么时候是同步的，什么时候是异步的？"></a>React 中 setState 什么时候是同步的，什么时候是异步的？</h3><p>在React中，如果是由React引发的事件处理（比如通过onClick引发的事件处理），调用setState不会同步更新this.state，除此之外的setState调用会同步执行this.state。所谓“除此之外”，指的是绕过React通过addEventListener直接添加的事件处理函数，还有通过setTimeout/setInterval产生的异步调用。</p><p>原因：在React的setState函数实现中，会根据一个变量isBatchingUpdates判断是直接更新this.state还是放到队列中回头再说，而isBatchingUpdates默认是false，也就表示setState会同步更新this.state，但是，有一个函数batchedUpdates，这个函数会把isBatchingUpdates修改为true，而当React在调用事件处理函数之前就会调用这个batchedUpdates，造成的后果，就是由React控制的事件处理过程setState不会同步更新this.state。</p><h3 id="下面输出什么"><a href="#下面输出什么" class="headerlink" title="下面输出什么"></a>下面输出什么</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Example extends React.Component &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      val: 0</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.setState(&#123;val: this.state.val + 1&#125;);</span><br><span class="line">    console.log(this.state.val);    // 第 1 次 log</span><br><span class="line"></span><br><span class="line">    this.setState(&#123;val: this.state.val + 1&#125;);</span><br><span class="line">    console.log(this.state.val);    // 第 2 次 log</span><br><span class="line"></span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      this.setState(&#123;val: this.state.val + 1&#125;);</span><br><span class="line">      console.log(this.state.val);  // 第 3 次 log</span><br><span class="line"></span><br><span class="line">      this.setState(&#123;val: this.state.val + 1&#125;);</span><br><span class="line">      console.log(this.state.val);  // 第 4 次 log</span><br><span class="line">    &#125;, 0);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>1、第一次和第二次都是在 react 自身生命周期内，触发时 isBatchingUpdates 为 true，所以并不会直接执行更新 state，而是加入了 dirtyComponents，所以打印时获取的都是更新前的状态 0。</p><p>2、两次 setState 时，获取到 this.state.val 都是 0，所以执行时都是将 0 设置成 1，在 react 内部会被合并掉，只执行一次。设置完成后 state.val 值为 1。</p><p>3、setTimeout 中的代码，触发时 isBatchingUpdates 为 false，所以能够直接进行更新，所以连着输出 2，3。</p><p>输出： 0 0 2 3</p><h3 id="为什么虚拟dom会提高性能"><a href="#为什么虚拟dom会提高性能" class="headerlink" title="为什么虚拟dom会提高性能?"></a>为什么虚拟dom会提高性能?</h3><p>虚拟dom相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操作，从而提高性能。</p><p>具体实现步骤如下：</p><p>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中</p><p>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异</p><p>把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了。</p><h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><h3 id="分析比较-opacity-0、visibility-hidden、display-none-优劣和适用场景"><a href="#分析比较-opacity-0、visibility-hidden、display-none-优劣和适用场景" class="headerlink" title="分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景"></a>分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景</h3><p>结构：<br>display:none: 会让元素完全从渲染树中消失，渲染的时候不占据任何空间, 不能点击，<br>visibility: hidden:不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，不能点击<br>opacity: 0: 不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，可以点击</p><p>继承：<br>display: none和opacity: 0：是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示。<br>visibility: hidden：是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式。</p><p>性能：<br>displaynone : 修改元素会造成文档回流,读屏器不会读取display: none元素内容，性能消耗较大<br>visibility:hidden: 修改元素只会造成本元素的重绘,性能消耗较少读屏器读取visibility: hidden元素内容<br>opacity: 0 ： 修改元素会造成重绘，性能消耗较少</p><p>联系：它们都能让元素不可见</p><h3 id="清除浮动的方式有哪些-比较好的是哪一种"><a href="#清除浮动的方式有哪些-比较好的是哪一种" class="headerlink" title="清除浮动的方式有哪些?比较好的是哪一种?"></a>清除浮动的方式有哪些?比较好的是哪一种?</h3><p>常用的一般为三种.clearfix, clear:both,overflow:hidden;</p><p>比较好是 .clearfix,伪元素万金油版本,后两者有局限性.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:after &#123;</span><br><span class="line">  visibility: hidden;</span><br><span class="line">  display: block;</span><br><span class="line">  font-size: 0;</span><br><span class="line">  content: &quot; &quot;;</span><br><span class="line">  clear: both;</span><br><span class="line">  height: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line">为毛没有 zoom ,_height 这些,IE6,7这类需要 csshack 不再我们考虑之内了</span><br><span class="line">.clearfix 还有另外一种写法,</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">.clearfix:before, .clearfix:after &#123;</span><br><span class="line">    content:&quot;&quot;;</span><br><span class="line">    display:table;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:after&#123;</span><br><span class="line">    clear:both;</span><br><span class="line">    overflow:hidden;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix&#123;</span><br><span class="line">    zoom:1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line">用display:table 是为了避免外边距margin重叠导致的margin塌陷,</span><br><span class="line">内部元素默认会成为 table-cell 单元格的形式</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure><p>clear:both:若是用在同一个容器内相邻元素上,那是贼好的,有时候在容器外就有些问题了, 比如相邻容器的包裹层元素塌陷</p><p>overflow:hidden:这种若是用在同个容器内,可以形成 BFC避免浮动造成的元素塌陷</p><h3 id="css-sprite-是什么-有什么优缺点"><a href="#css-sprite-是什么-有什么优缺点" class="headerlink" title="css sprite 是什么,有什么优缺点"></a>css sprite 是什么,有什么优缺点</h3><p>概念：</p><p>将多个小图片拼接到一个图片中。通过 background-position 和元素尺寸调节需要显示的背景图案。</p><p>优点：</p><p>减少 HTTP 请求数，极大地提高页面加载速度<br>增加图片信息重复度，提高压缩比，减少图片大小<br>更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现</p><p>缺点：</p><p>图片合并麻烦<br>维护麻烦，修改一个图片可能需要重新布局整个图片，样式</p><h3 id="link与-import的区别"><a href="#link与-import的区别" class="headerlink" title="link与@import的区别"></a>link与@import的区别</h3><p>link是 HTML 方式， @import是 CSS 方式<br>link最大限度支持并行下载，@import过多嵌套导致串行下载，出现FOUC<br>link可以通过rel=”alternate stylesheet”指定候选样式<br>浏览器对link支持早于@import，可以使用@import对老浏览器隐藏样式<br>@import必须在样式规则之前，可以在 css 文件中引用其他文件<br>总体来说：link 优于@import</p><h3 id="display-block-和display-inline-的区别"><a href="#display-block-和display-inline-的区别" class="headerlink" title="display: block;和display: inline;的区别"></a>display: block;和display: inline;的区别</h3><h4 id="block元素特点："><a href="#block元素特点：" class="headerlink" title="block元素特点："></a>block元素特点：</h4><p>1.处于常规流中时，如果width没有设置，会自动填充满父容器</p><p>2.可以应用margin/padding</p><p>3.在没有设置高度的情况下会扩展高度以包含常规流中的子元素</p><p>4.处于常规流中时布局时在前后元素位置之间（独占一个水平空间）</p><p>5.忽略vertical-align</p><h4 id="inline元素特点"><a href="#inline元素特点" class="headerlink" title="inline元素特点"></a>inline元素特点</h4><p>1.水平方向上根据direction依次布局</p><p>2.不会在元素前后进行换行</p><p>3.受white-space控制</p><p>4.margin/padding在竖直方向上无效，水平方向上有效</p><p>5.width/height属性对非替换行内元素无效，宽度由元素内容决定</p><p>6.非替换行内元素的行框高由line-height确定，替换行内元素的行框高由height,margin,padding,border决定 </p><p>7.浮动或绝对定位时会转换为block </p><p>8.vertical-align属性生效</p><h3 id="容器包含若干浮动元素时如何清理浮动"><a href="#容器包含若干浮动元素时如何清理浮动" class="headerlink" title="容器包含若干浮动元素时如何清理浮动"></a>容器包含若干浮动元素时如何清理浮动</h3><p>容器元素闭合标签前添加额外元素并设置clear: both<br>父元素触发块级格式化上下文(见块级可视化上下文部分)<br>设置容器元素伪元素进行清理推荐的清理浮动方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 在标准浏览器下使用</span><br><span class="line">* 1 content内容为空格用于修复opera下文档中出现</span><br><span class="line">* contenteditable属性时在清理浮动元素上下的空白</span><br><span class="line">* 2 使用display使用table而不是block：可以防止容器和</span><br><span class="line">* 子元素top-margin折叠,这样能使清理效果与BFC，IE6/7</span><br><span class="line">* zoom: 1;一致</span><br><span class="line">**/</span><br><span class="line"></span><br><span class="line">.clearfix:before,</span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">    content: &quot; &quot;; /* 1 */</span><br><span class="line">    display: table; /* 2 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">IE 6/7下使用</span><br><span class="line">通过触发hasLayout实现包含浮动</span><br><span class="line">**/</span><br><span class="line">.clearfix &#123;</span><br><span class="line">  *zoom: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PNG-GIF-JPG-的区别及如何选"><a href="#PNG-GIF-JPG-的区别及如何选" class="headerlink" title="PNG,GIF,JPG 的区别及如何选"></a>PNG,GIF,JPG 的区别及如何选</h3><h4 id="GIF"><a href="#GIF" class="headerlink" title="GIF:"></a>GIF:</h4><p>8 位像素，256 色<br>无损压缩<br>支持简单动画<br>支持 boolean 透明<br>适合简单动画</p><h4 id="JPEG："><a href="#JPEG：" class="headerlink" title="JPEG："></a>JPEG：</h4><p>颜色限于 256<br>有损压缩<br>可控制压缩质量<br>不支持透明<br>适合照片</p><h4 id="PNG："><a href="#PNG：" class="headerlink" title="PNG："></a>PNG：</h4><p>有 PNG8 和 truecolor PNG<br>PNG8 类似 GIF 颜色上限为 256，文件小，支持 alpha 透明度，无动画<br>适合图标、背景、按钮</p><h3 id="display-float-position-的关系"><a href="#display-float-position-的关系" class="headerlink" title="display,float,position 的关系"></a>display,float,position 的关系</h3><p>如果display为 none，那么 position 和 float 都不起作用，这种情况下元素不产生框<br>否则，如果 position 值为 absolute 或者 fixed，框就是绝对定位的，float 的计算值为 none，display 根据下面的表格进行调整。<br>否则，如果 float 不是 none，框是浮动的，display 根据下表进行调整<br>否则，如果元素是根元素，display 根据下表进行调整<br>其他情况下 display 的值为指定值 总结起来：绝对定位、浮动、根元素都需要调整display</p><h3 id="如何水平居中一个元素"><a href="#如何水平居中一个元素" class="headerlink" title="如何水平居中一个元素"></a>如何水平居中一个元素</h3><p>如果需要居中的元素为常规流中 inline 元素，为父元素设置text-align: center;即可实现<br>如果需要居中的元素为常规流中 block 元素，1）为元素设置宽度，2）设置左右 margin 为 auto。3）IE6 下需在父元素上设置text-align: center;,再给子元素恢复需要的值</p><pre><code>&lt;body&gt;    &lt;div class=&quot;content&quot;&gt;    aaaaaa aaaaaa a a a a a a a a    &lt;/div&gt;&lt;/body&gt;&lt;style&gt;    body {        background: #DDD;        text-align: center; /* 3 */    }    .content {        width: 500px;      /* 1 */        text-align: left;  /* 3 */        margin: 0 auto;    /* 2 */        background: purple;    }&lt;/style&gt;</code></pre><p>如果需要居中的元素为浮动元素，1）为元素设置宽度，2）position: relative;，3）浮动方向偏移量（left 或者 right）设置为 50%，4）浮动方向上的 margin 设置为元素宽度一半乘以-1</p><pre><code>&lt;body&gt;    &lt;div class=&quot;content&quot;&gt;    aaaaaa aaaaaa a a a a a a a a    &lt;/div&gt;&lt;/body&gt;&lt;style&gt;    body {        background: #DDD;    }    .content {        width: 500px;         /* 1 */        float: left;        position: relative;   /* 2 */        left: 50%;            /* 3 */        margin-left: -250px;  /* 4 */        background-color: purple;    }&lt;/style&gt;</code></pre><p>如果需要居中的元素为绝对定位元素，1）为元素设置宽度，2）偏移量设置为 50%，3）偏移方向外边距设置为元素宽度一半乘以-1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">    aaaaaa aaaaaa a a a a a a a a</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">        background: #DDD;</span><br><span class="line">        position: relative;</span><br><span class="line">    &#125;</span><br><span class="line">    .content &#123;</span><br><span class="line">        width: 800px;</span><br><span class="line">        position: absolute;</span><br><span class="line">        left: 50%;</span><br><span class="line">        margin-left: -400px;</span><br><span class="line">        background-color: purple;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>如果需要居中的元素为绝对定位元素，1）为元素设置宽度，2）设置左右偏移量都为 0,3）设置左右外边距都为 auto</p><pre><code>&lt;body&gt;    &lt;div class=&quot;content&quot;&gt;    aaaaaa aaaaaa a a a a a a a a    &lt;/div&gt;&lt;/body&gt;&lt;style&gt;    body {        background: #DDD;        position: relative;    }    .content {        width: 800px;        position: absolute;        margin: 0 auto;        left: 0;        right: 0;        background-color: purple;    }&lt;/style&gt;</code></pre><h3 id="Promise-构造函数是同步执行还是异步执行，那么-then-方法呢？"><a href="#Promise-构造函数是同步执行还是异步执行，那么-then-方法呢？" class="headerlink" title="Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？"></a>Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  console.log(1)</span><br><span class="line">  resolve()</span><br><span class="line">  console.log(2)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(() =&gt; &#123;</span><br><span class="line">  console.log(3)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(4)</span><br></pre></td></tr></table></figure><p>输出结果是：</p><p>1<br>2<br>4<br>3<br>promise构造函数是同步执行的，then方法是异步执行的<br>Promise new的时候会立即执行里面的代码</p><p>then是微任务 会在本次任务执行完的时候执行</p><p>setTimeout是宏任务 会在下次任务执行的时候执行</p><h3 id="JS的四种设计模式"><a href="#JS的四种设计模式" class="headerlink" title="JS的四种设计模式"></a>JS的四种设计模式</h3><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>简单的工厂模式可以理解为解决多个相似的问题;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function CreatePerson(name,age,sex) &#123;</span><br><span class="line">    var obj = new Object();</span><br><span class="line">    obj.name = name;</span><br><span class="line">    obj.age = age;</span><br><span class="line">    obj.sex = sex;</span><br><span class="line">    obj.sayName = function()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line">var p1 = new CreatePerson(&quot;longen&quot;,&apos;28&apos;,&apos;男&apos;);</span><br><span class="line">var p2 = new CreatePerson(&quot;tugenhua&quot;,&apos;27&apos;,&apos;女&apos;);</span><br><span class="line">console.log(p1.name); // longen</span><br><span class="line">console.log(p1.age);  // 28</span><br><span class="line">console.log(p1.sex);  // 男</span><br><span class="line">console.log(p1.sayName()); // longen</span><br><span class="line"></span><br><span class="line">console.log(p2.name);  // tugenhua</span><br><span class="line">console.log(p2.age);   // 27</span><br><span class="line">console.log(p2.sex);   // 女</span><br><span class="line">console.log(p2.sayName()); // tugenhua</span><br></pre></td></tr></table></figure><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>只能被实例化(构造函数给实例添加属性与方法)一次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 单体模式</span><br><span class="line">var Singleton = function(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton.prototype.getName = function()&#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line">// 获取实例对象</span><br><span class="line">var getInstance = (function() &#123;</span><br><span class="line">    var instance = null;</span><br><span class="line">    return function(name) &#123;</span><br><span class="line">        if(!instance) &#123;//相当于一个一次性阀门,只能实例化一次</span><br><span class="line">            instance = new Singleton(name);</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">// 测试单体模式的实例,所以a===b</span><br><span class="line">var a = getInstance(&quot;aa&quot;);</span><br><span class="line">var b = getInstance(&quot;bb&quot;);</span><br></pre></td></tr></table></figure><h4 id="沙箱模式"><a href="#沙箱模式" class="headerlink" title="沙箱模式"></a>沙箱模式</h4><p>将一些函数放到自执行函数里面,但要用闭包暴露接口,用变量接收暴露的接口,再调用里面的值,否则无法使用里面的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let sandboxModel=(function()&#123;</span><br><span class="line">    function sayName()&#123;&#125;;</span><br><span class="line">    function sayAge()&#123;&#125;;</span><br><span class="line">    return&#123;</span><br><span class="line">        sayName:sayName,</span><br><span class="line">        sayAge:sayAge</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h4 id="发布者订阅模式"><a href="#发布者订阅模式" class="headerlink" title="发布者订阅模式"></a>发布者订阅模式</h4><p>就例如如我们关注了某一个公众号,然后他对应的有新的消息就会给你推送,</p><pre><code>//发布者与订阅模式var shoeObj = {}; // 定义发布者shoeObj.list = []; // 缓存列表 存放订阅者回调函数// 增加订阅者shoeObj.listen = function(fn) {    shoeObj.list.push(fn); // 订阅消息添加到缓存列表}// 发布消息shoeObj.trigger = function() {    for (var i = 0, fn; fn = this.list[i++];) {        fn.apply(this, arguments);//第一个参数只是改变fn的this,    }} // 小红订阅如下消息shoeObj.listen(function(color, size) {    console.log(&quot;颜色是：&quot; + color);    console.log(&quot;尺码是：&quot; + size);});// 小花订阅如下消息shoeObj.listen(function(color, size) {    console.log(&quot;再次打印颜色是：&quot; + color);    console.log(&quot;再次打印尺码是：&quot; + size);});shoeObj.trigger(&quot;红色&quot;, 40);shoeObj.trigger(&quot;黑色&quot;, 42);  </code></pre><p>代码实现逻辑是用数组存贮订阅者, 发布者回调函数里面通知的方式是遍历订阅者数组,并将发布者内容传入订阅者数组</p><h3 id="列举出集中创建实例的方法"><a href="#列举出集中创建实例的方法" class="headerlink" title="列举出集中创建实例的方法"></a>列举出集中创建实例的方法</h3><p>1.字面量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let obj=&#123;&apos;name&apos;:&apos;张三&apos;&#125;</span><br></pre></td></tr></table></figure><p>2.Object构造函数创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let Obj=new Object()</span><br><span class="line">Obj.name=&apos;张三&apos;</span><br></pre></td></tr></table></figure><p>3.使用工厂模式创建对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name)&#123;</span><br><span class="line"> var o = new Object();</span><br><span class="line"> o.name = name;</span><br><span class="line"> &#125;;</span><br><span class="line"> return o; </span><br><span class="line">&#125;</span><br><span class="line">var person1 = createPerson(&apos;张三&apos;);</span><br></pre></td></tr></table></figure><p>4.使用构造函数创建对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line"> this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">var person1 = new Person(&apos;张三&apos;);</span><br></pre></td></tr></table></figure><h3 id="简述一下前端事件流"><a href="#简述一下前端事件流" class="headerlink" title="简述一下前端事件流"></a>简述一下前端事件流</h3><p>HTML中与javascript交互是通过事件驱动来实现的，例如鼠标点击事件onclick、页面的滚动事件onscroll等等，可以向文档或者文档中的元素添加事件侦听器来预订事件。想要知道这些事件是在什么时候进行调用的，就需要了解一下“事件流”的概念。</p><p>什么是事件流：事件流描述的是从页面中接收事件的顺序,DOM2级事件流包括下面几个阶段。</p><p>事件捕获阶段<br>处于目标阶段<br>事件冒泡阶段<br>addEventListener：addEventListener是DOM2 级事件新增的指定事件处理程序的操作，这个方法接收3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。</p><p>IE只支持事件冒泡。</p><h3 id="Function-proto-getPrototypeOf-是什么？"><a href="#Function-proto-getPrototypeOf-是什么？" class="headerlink" title="Function.proto(getPrototypeOf)是什么？"></a>Function.<em>proto</em>(getPrototypeOf)是什么？</h3><p>获取一个对象的原型，在chrome中可以通过<strong>proto</strong>的形式，或者在ES6中可以通过Object.getPrototypeOf的形式。</p><p>那么Function.proto是什么么？也就是说Function由什么对象继承而来，我们来做如下判别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Function.__proto__==Object.prototype //false</span><br><span class="line">Function.__proto__==Function.prototype//true</span><br></pre></td></tr></table></figure><p>我们发现Function的原型也是Function。</p><p>我们用图可以来明确这个关系：</p><h3 id="简述一下原型-构造函数-实例"><a href="#简述一下原型-构造函数-实例" class="headerlink" title="简述一下原型 / 构造函数 / 实例"></a>简述一下原型 / 构造函数 / 实例</h3><p>原型(prototype): 一个简单的对象，用于实现对象的 属性继承。可以简单的理解成对象的爹。在 Firefox 和 Chrome 中，每个JavaScript对象中都包含一个<strong>proto</strong>(非标准)的属性指向它爹(该对象的原型)，可obj.<strong>proto</strong>进行访问。<br>构造函数: 可以通过new来 新建一个对象的函数。<br>实例: 通过构造函数和new创建出来的对象，便是实例。 实例通过<strong>proto</strong>指向原型，通过constructor指向构造函数。<br>这里来举个栗子，以Object为例，我们常用的Object便是一个构造函数，因此我们可以通过它构建实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 实例</span><br><span class="line">const instance = new Object()</span><br></pre></td></tr></table></figure><p>则此时， 实例为instance, 构造函数为Object，我们知道，构造函数拥有一个prototype的属性指向原型，因此原型为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 原型</span><br><span class="line">const prototype = Object.prototype</span><br></pre></td></tr></table></figure><p>这里我们可以来看出三者的关系:</p><p>实例.<strong>proto</strong> === 原型</p><p>原型.constructor === 构造函数</p><p>构造函数.prototype === 原型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 这条线其实是是基于原型进行获取的，可以理解成一条基于原型的映射线</span><br><span class="line">// 例如: </span><br><span class="line">// const o = new Object()</span><br><span class="line">// o.constructor === Object   --&gt; true</span><br><span class="line">// o.__proto__ = null;</span><br><span class="line">// o.constructor === Object   --&gt; false</span><br></pre></td></tr></table></figure><p>实例.constructor === 构造函数</p><h3 id="简述一下JS继承，并举例"><a href="#简述一下JS继承，并举例" class="headerlink" title="简述一下JS继承，并举例"></a>简述一下JS继承，并举例</h3><p>在 JS 中，继承通常指的便是 原型链继承，也就是通过指定原型，并可以通过原型链继承原型上的属性或者方法。</p><p>最优化: 圣杯模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var inherit = (function(c,p)&#123;</span><br><span class="line">    var F = function()&#123;&#125;;</span><br><span class="line">    return function(c,p)&#123;</span><br><span class="line">        F.prototype = p.prototype;</span><br><span class="line">        c.prototype = new F();</span><br><span class="line">        c.uber = p.prototype;</span><br><span class="line">        c.prototype.constructor = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>使用 ES6 的语法糖 class / extends</p><h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><p>在函数式编程中，函数是一等公民。那么函数柯里化是怎样的呢？</p><p>函数柯里化指的是将能够接收多个参数的函数转化为接收单一参数的函数，并且返回接收余下参数且返回结果的新函数的技术。</p><p>函数柯里化的主要作用和特点就是参数复用、提前返回和延迟执行。</p><p>在一个函数中，首先填充几个参数，然后再返回一个新的函数的技术，称为函数的柯里化。通常可用于在不侵入函数的前提下，为函数 预置通用参数，供多次重复调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const add = function add(x) &#123;</span><br><span class="line">    return function (y) &#123;</span><br><span class="line">        return x + y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const add1 = add(1)</span><br><span class="line"></span><br><span class="line">add1(2) === 3</span><br><span class="line">add1(20) === 21</span><br></pre></td></tr></table></figure><h3 id="说说bind、call、apply-区别？"><a href="#说说bind、call、apply-区别？" class="headerlink" title="说说bind、call、apply 区别？"></a>说说bind、call、apply 区别？</h3><p>call 和 apply 都是为了解决改变 this 的指向。作用都是相同的，只是传参的方式不同。</p><p>除了第一个参数外，call 可以接收一个参数列表，apply 只接受一个参数数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;</span><br><span class="line">function getValue(name, age) &#123;</span><br><span class="line">    console.log(name)</span><br><span class="line">    console.log(age)</span><br><span class="line">    console.log(this.value)</span><br><span class="line">&#125;</span><br><span class="line">getValue.call(a, &apos;yck&apos;, &apos;24&apos;)</span><br><span class="line">getValue.apply(a, [&apos;yck&apos;, &apos;24&apos;])</span><br></pre></td></tr></table></figure><p>bind和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 bind实现柯里化。</p><p>（下面是对这三个方法的扩展介绍）</p><p>如何实现一个 bind 函数</p><p>对于实现以下几个函数，可以从几个方面思考</p><p>不传入第一个参数，那么默认为 window<br>改变了 this 指向，让新的对象可以执行该函数。那么思路是否可以变成给新的对象添加一个函数，然后在执行完以后删除？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myBind = function (context) &#123;</span><br><span class="line">  if (typeof this !== &apos;function&apos;) &#123;</span><br><span class="line">    throw new TypeError(&apos;Error&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  var _this = this</span><br><span class="line">  var args = [...arguments].slice(1)</span><br><span class="line">  // 返回一个函数</span><br><span class="line">  return function F() &#123;</span><br><span class="line">    // 因为返回了一个函数，我们可以 new F()，所以需要判断</span><br><span class="line">    if (this instanceof F) &#123;</span><br><span class="line">      return new _this(...args, ...arguments)</span><br><span class="line">    &#125;</span><br><span class="line">    return _this.apply(context, args.concat(...arguments))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何实现一个call函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myCall = function (context) &#123;</span><br><span class="line">  var context = context || window</span><br><span class="line">  // 给 context 添加一个属性</span><br><span class="line">  // getValue.call(a, &apos;yck&apos;, &apos;24&apos;) =&gt; a.fn = getValue</span><br><span class="line">  context.fn = this</span><br><span class="line">  // 将 context 后面的参数取出来</span><br><span class="line">  var args = [...arguments].slice(1)</span><br><span class="line">  // getValue.call(a, &apos;yck&apos;, &apos;24&apos;) =&gt; a.fn(&apos;yck&apos;, &apos;24&apos;)</span><br><span class="line">  var result = context.fn(...args)</span><br><span class="line">  // 删除 fn</span><br><span class="line">  delete context.fn</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何实现一个apply函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myApply = function (context) &#123;</span><br><span class="line">  var context = context || window</span><br><span class="line">  context.fn = this</span><br><span class="line"></span><br><span class="line">  var result</span><br><span class="line">  // 需要判断是否存储第二个参数</span><br><span class="line">  // 如果存在，就将第二个参数展开</span><br><span class="line">  if (arguments[1]) &#123;</span><br><span class="line">    result = context.fn(...arguments[1])</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    result = context.fn()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  delete context.fn</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="箭头函数的特点"><a href="#箭头函数的特点" class="headerlink" title="箭头函数的特点"></a>箭头函数的特点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function a() &#123;</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">        return () =&gt; &#123;</span><br><span class="line">            console.log(this)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a()()())</span><br></pre></td></tr></table></figure><p>箭头函数其实是没有 this的，这个函数中的 this只取决于他外面的第一个不是箭头函数的函数的 this。</p><p>在这个例子中，因为调用a符合前面代码中的第一个情况，所以 this是 window。并且 this一旦绑定了上下文，就不会被任何代码改变。</p><h3 id="谈谈你对-dns-prefetch-的理解"><a href="#谈谈你对-dns-prefetch-的理解" class="headerlink" title="谈谈你对 dns-prefetch 的理解"></a>谈谈你对 dns-prefetch 的理解</h3><p>DNS 是什么– Domain Name System，域名系统，作为域名和IP地址相互映射的一个分布式数据库。</p><h4 id="DNS-Prefetching"><a href="#DNS-Prefetching" class="headerlink" title="DNS Prefetching"></a>DNS Prefetching</h4><p>浏览器根据自定义的规则，提前去解析后面可能用到的域名，来加速网站的访问速度。简单来讲就是提前解析域名，以免延迟。</p><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//wq.test.com&quot;&gt;</span><br></pre></td></tr></table></figure><p>这个功能有个默认加载条件，所有的a标签的href都会自动去启用DNS Prefetching，也就是说，你网页的a标签href带的域名，是不需要在head里面加上link手动设置的。但a标签的默认启动在HTTPS不起作用。</p><p>这时要使用 meta里面http-equiv来强制启动功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h4><ol><li>DNS Prefetching是提前加载域名解析的，省去了解析时间。a标签的href是可以在chrome。firefox包括高版本的IE，但是在HTTPS下面不起作用，需要meta来强制开启功能</li><li>这是DNS的提前解析，并不是css，js之类的文件缓存，大家不要混淆了两个不同的概念。</li><li>如果直接做了js的重定向，或者在服务端做了重定向，没有在link里面手动设置，是不起作用的。</li><li>这个对于什么样的网站更有作用呢，类似taobao这种网站，你的网页引用了大量很多其他域名的资源，如果你的网站，基本所有的资源都在你本域名下，那么这个基本没有什么作用。因为DNS Chrome在访问你的网站就帮你缓存了。</li></ol><h4 id="拓展知识学习"><a href="#拓展知识学习" class="headerlink" title="拓展知识学习"></a>拓展知识学习</h4><ul><li>web下的性能优化1(网络方向)</li></ul><h3 id="get-post请求传参长度有什么特点"><a href="#get-post请求传参长度有什么特点" class="headerlink" title="get/post请求传参长度有什么特点"></a>get/post请求传参长度有什么特点</h3><p>我们经常说get请求参数的大小存在限制，而post请求的参数大小是无限制的。这是一个错误的说法，实际上HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对get请求参数的限制是来源与浏览器或web服务器，浏览器或web服务器限制了url的长度。为了明确这个概念，我们必须再次强调下面几点:</p><ol><li>HTTP 协议 未规定 GET 和POST的长度限制</li><li>GET的最大长度显示是因为 浏览器和 web服务器限制了 URI的长度</li><li>不同的浏览器和WEB服务器，限制的最大长度不一样</li><li>要支持IE，则最大长度为2083byte，若只支持Chrome，则最大长度 8182byte</li></ol><h3 id="前端需要注意哪些-SEO"><a href="#前端需要注意哪些-SEO" class="headerlink" title="前端需要注意哪些 SEO"></a>前端需要注意哪些 SEO</h3><ol><li>合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可</li><li>语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页</li><li>重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</li><li>重要内容不要用 js 输出：爬虫不会执行 js 获取内容</li><li>少用 iframe(搜索引擎不会抓取 iframe 中的内容)</li><li>非装饰性图片必须加 alt</li><li>提高网站速度(网站速度是搜索引擎排序的一个重要指标)</li></ol><h3 id="实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后-退时正确响应。给出你的技术实现方案？"><a href="#实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后-退时正确响应。给出你的技术实现方案？" class="headerlink" title="实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后 退时正确响应。给出你的技术实现方案？"></a>实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后 退时正确响应。给出你的技术实现方案？</h3><p>第一步，通过使用 pushState + ajax 实现浏览器无刷新前进后退，当一次 ajax 调用成功后我们将一 条 state 记录加入到 history 对象中。</p><p>第二步，一条 state 记录包含了 url、title 和 content 属性，在 popstate 事件中可以 获取到这个 state 对象，我们可 以使用 content 来传递数据。第三步，我们通过对 window.onpopstate 事件监听来响应浏览器 的前进后退操作。</p><p>使用 pushState 来实现有两个问题，一个是打开首页时没有记录，我们可以使用 replaceState 来将首页的记录替换，另一个问 题是当一个页面刷新的时候，仍然会向服务器端请求数据，因此如果请求的 url 需要后端的配 合将其重定向到一个页面。</p><p>更多参考：<a href="http://blog.chenxu.me/post/detail?id=ed4f0732-897f-48e4-9d4f-821e82f17fad" target="_blank" rel="noopener">http://blog.chenxu.me/post/detail?id=ed4f0732-897f-48e4-9d4f-821e82f17fad</a></p><h3 id="如何优化SPA应用的首屏加载速度慢的问题？"><a href="#如何优化SPA应用的首屏加载速度慢的问题？" class="headerlink" title="如何优化SPA应用的首屏加载速度慢的问题？"></a>如何优化SPA应用的首屏加载速度慢的问题？</h3><ul><li>将公用的JS库通过script标签外部引入，减小app.bundel的大小，让浏览器并行下载资源文件，提高下载速度；</li><li>在配置 路由时，页面和组件使用懒加载的方式引入，进一步缩小 app.bundel 的体积，在调用某个组件时再加载对应的js文件；</li><li>root中插入loading 或者 骨架屏 prerender-spa-plugin，提升用户体验；</li><li>如果在webview中的页面，可以进行页面预加载</li><li>独立打包异步组件公共 Bundle，以提高复用性&amp;缓存命中率</li><li>静态文件本地缓存，有两种方式分别为HTTP缓存，设置Cache-Control，Last-Modified，Etag等响应头和Service Worker离线缓存</li><li>配合 PWA 使用</li><li>SSR</li><li>root中插入loading 或者 骨架屏 prerender-spa-plugin</li><li>使用 Tree Shaking 减少业务代码体积 更多参考：<a href="https://github.com/LuckyWinty/fe-weekly-questions/issues/69" target="_blank" rel="noopener">https://github.com/LuckyWinty/fe-weekly-questions/issues/69</a></li></ul><h3 id="Reflect-对象创建目的？"><a href="#Reflect-对象创建目的？" class="headerlink" title="Reflect 对象创建目的？"></a>Reflect 对象创建目的？</h3><ol><li>将 Object 对 象 的 一 些 明 显 属 于 语 言 内 部 的 方 法 （ 比 如 Object.defineProperty，放到 Reflect 对象上。</li><li>修改某些 Object 方法的返回结果，让其变得更合理。</li><li>让 Object 操作都变成函数行为。</li><li>Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象 的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可 以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。</li></ol><p>也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取 默认行为。</p><h3 id="内部属性-Class-是什么？"><a href="#内部属性-Class-是什么？" class="headerlink" title="内部属性 [[Class]] 是什么？"></a>内部属性 [[Class]] 是什么？</h3><p>所有 typeof 返回值为 “object” 的对象（如数组）都包含一个内部属性 [[Class]]（我 们可以把它看作一个内部的分类，而非传统的面向对象意义上的类）。这个属性无法直接访问， 一般通过 Object.prototype.toString(..) 来查看。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call( [1,2,3] );  // &quot;[object Array]&quot; </span><br><span class="line">Object.prototype.toString.call( /regex-literal/i ); //&quot;[object RegExp]&quot;</span><br></pre></td></tr></table></figure><p>多数情况下，对象的内部[[class]]属性和创建该对象的内建原生构造函数相对应，不过也不总是这样。2.基本类型值的[[class]]属性</p><p>虽然Null()和Undefined()这样的原生构造函数并不存在，但是内部[[class]]属性仍然是“Null”和“Undefined”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.prototype.toString.call(null)); //[object Null]</span><br><span class="line"></span><br><span class="line">console.log(Object.prototype.toString.call(undefined)); //[object Undefined]</span><br></pre></td></tr></table></figure><p>其他基本类型值的情况有所不同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.prototype.toString.call(&quot;abc&quot;)); //[object String]</span><br><span class="line"></span><br><span class="line">console.log(Object.prototype.toString.call(42));  //[object Number]</span><br><span class="line"></span><br><span class="line">console.log(Object.prototype.toString.call(true)); //[object Boolean]</span><br></pre></td></tr></table></figure><p>基本类型值被各自的封装对象自动包装，所以他们的内部[[class]]属性分别为“String”，“Number”和“Boolean”。3.封装对象</p><p>由于基本类型值没有.length和.toString()这样的属性和方法，需要通过封装对象才能访问，此时Javascript引擎会自动为基本类型值包装一个封装对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//封装对象包装</span><br><span class="line"></span><br><span class="line">var b = &apos;abc&apos;;</span><br><span class="line">console.log(b.length);</span><br><span class="line">console.log(b.toUpperCase());</span><br><span class="line">​```js</span><br><span class="line">一般不直接使用封装对象（即通过new操作创建基本类型值），优先考虑使用“abc”和“42”这样的基本类型值，而不是new String(&quot;abc&quot;) 和 new Number(42)。4.拆封</span><br><span class="line"></span><br><span class="line">如果想要得到封装对象中的基本类型值，可以使用valueOf()函数。 </span><br><span class="line">​```js</span><br><span class="line">//封装对象的拆封</span><br><span class="line">var s = new String( &quot;abc&quot; );</span><br><span class="line">var n = new Number( 42 );</span><br><span class="line">var b = new Boolean( true );</span><br><span class="line"></span><br><span class="line">console.log(s.valueOf());</span><br><span class="line">console.log(n.valueOf());</span><br><span class="line">console.log(b.valueOf());</span><br></pre></td></tr></table></figure><h3 id="什么是堆？什么是栈？它们之间有什么区别和联系？"><a href="#什么是堆？什么是栈？它们之间有什么区别和联系？" class="headerlink" title="什么是堆？什么是栈？它们之间有什么区别和联系？"></a>什么是堆？什么是栈？它们之间有什么区别和联系？</h3><p>堆和栈的概念存在于数据结构中和操作系统内存中。在数据结构中，栈中数据的存取方式为 先进后出。而堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。完全 二叉树是堆的一种实现方式。在操作系统中，内存被分为栈区和堆区。栈区内存由编译器自动分 配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。堆区内存一 般由程序员分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收。</p><p>详细资料可以参考：《什么是堆？什么是栈？他们之间有什么区别和联系？》</p><h3 id="isNaN-和-Number-isNaN-函数的区别？"><a href="#isNaN-和-Number-isNaN-函数的区别？" class="headerlink" title="isNaN 和 Number.isNaN 函数的区别？"></a>isNaN 和 Number.isNaN 函数的区别？</h3><p>函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返 回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。</p><p>函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，这种方法对于 NaN 的判断更为准确。</p><h3 id="什么情况下会发生布尔值的隐式强制类型转换？"><a href="#什么情况下会发生布尔值的隐式强制类型转换？" class="headerlink" title="什么情况下会发生布尔值的隐式强制类型转换？"></a>什么情况下会发生布尔值的隐式强制类型转换？</h3><p>（1） if (..) 语句中的条件判断表达式。</p><p>（2） for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。</p><p>（3） while (..) 和 do..while(..) 循环中的条件判断表达式。</p><p>（4） ? : 中的条件判断表达式。</p><p>（5） 逻辑运算符 ||（逻辑或）和 &amp;&amp;（逻辑与）左边的操作数（作为条件判断表达式）。</p><h3 id="undefined-与-undeclared-的区别？"><a href="#undefined-与-undeclared-的区别？" class="headerlink" title="undefined 与 undeclared 的区别？"></a>undefined 与 undeclared 的区别？</h3><p>已在作用域中声明但还没有赋值的变量，是 undefined 的。相反，还没有在作用域中声明 过的变量，是 undeclared 的。对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用 typeof 的安全防范机制来避免 报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 “undefined”。</p><h3 id="如何封装一个-javascript-的类型判断函数？"><a href="#如何封装一个-javascript-的类型判断函数？" class="headerlink" title="如何封装一个 javascript 的类型判断函数？"></a>如何封装一个 javascript 的类型判断函数？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function getType(value) &#123; </span><br><span class="line">  // 判断数据是 null 的情况 </span><br><span class="line">  if (value === null) &#123; </span><br><span class="line">      return value + &quot;&quot;; </span><br><span class="line">  &#125;</span><br><span class="line">  // 判断数据是引用类型的情况 </span><br><span class="line">  if (typeof value === &quot;object&quot;) &#123; </span><br><span class="line">    let valueClass = Object.prototype.toString.call(value), </span><br><span class="line">    type = valueClass.split(&quot; &quot;)[1].split(&quot;&quot;); </span><br><span class="line">    type.pop(); </span><br><span class="line">    return type.join(&quot;&quot;).toLowerCase();</span><br><span class="line">  &#125; else &#123; </span><br><span class="line">    // 判断数据是基本数据类型的情况和函数的情况 </span><br><span class="line">    return typeof value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小程序和公众号用什么来区分同一个用户"><a href="#小程序和公众号用什么来区分同一个用户" class="headerlink" title="小程序和公众号用什么来区分同一个用户"></a>小程序和公众号用什么来区分同一个用户</h3><p>在微信生态中，小程序和公众号可以通过微信的 openid 和 unionid 来区分同一个用户。</p><p> openid 是同一个应用（App、公众号、小程序）的同一个用户的唯一标识。即，一个用户在一个小程序或公众号中有唯一的 openid ，但在不同的小程序或公众号中， openid 可能不同。</p><p> unionid 是一个用户对于同主体微信小程序、公众号、APP的标识，开发者需要在微信开放平台下绑定相同账号的主体。 unionid 在正常情况下是用户身份的唯一标识，但在业务涉及不同主体时，不一定唯一。</p><h3 id="渲染函数和jsx介绍和区别"><a href="#渲染函数和jsx介绍和区别" class="headerlink" title="渲染函数和jsx介绍和区别"></a>渲染函数和jsx介绍和区别</h3><p>在 Vue 中，渲染函数和 JSX 都是用于构建 Vue 组件的工具。它们提供了一种编写组件的不同方式，通常用于编写更复杂、更灵活的组件。渲染函数是用 JavaScript 编写的函数，它接收一个上下文对象作为参数，然后返回一个 Vue VNode 节点。VNode 节点表示了组件的结构，包括 HTML 标记、属性、事件、样式等等。通过递归地构建 VNode 树，Vue 渲染函数可以生成最终的 DOM 树，并将其插入到文档中。渲染函数可以用于构建任何类型的组件，包括功能组件和状态组件。它通常用于编写高级别的抽象组件，例如基于数据结构的树形控件、动态表单生成器等等。渲染函数的语法相对于 JSX 较为灵活，但同时也更加复杂。</p><p>JSX 是一种在 JavaScript 中编写 HTML 标记的语法。它是 React 中广泛使用的语法，但也可以与 Vue 一起使用。JSX 允许开发者使用类似 HTML 的语法来编写组件，然后使用 Babel 等工具将其转换为常规的 JavaScript 代码。在 Vue 中使用 JSX 需要安装相应的插件，并进行配置。JSX 的语法更加简洁直观，因此更容易上手。它的表达能力也非常强，可以轻松地实现组件的复杂嵌套和逻辑控制。同时，由于 JSX 本质上是一种 JavaScript 语法扩展，因此也可以使用 JavaScript 的语言特性，例如变量、条件语句、循环等等。</p><p>总的来说，渲染函数和 JSX 在 Vue 中都有其独特的用途和优势。选择使用哪种方式取决于具体的需求和场景。</p><h3 id="最近两年有什么前端新技术"><a href="#最近两年有什么前端新技术" class="headerlink" title="最近两年有什么前端新技术"></a>最近两年有什么前端新技术</h3><p>近两年前端领域出现了许多新技术，其中一些比较重要的包括：</p><ul><li>HTML6：构建交互优良用户界面的基础技术。</li><li>TypeScript：一种由微软开发的编程语言，具有静态类型检查功能，可以提高代码的可读性和可维护性。</li><li>WebAssembly：一种新的二进制格式，用于在浏览器中运行高性能的代码，如视频编解码、图形渲染等。</li><li>渐进式 WEB 应用（PWA）：一种可以提高网站性能和用户体验的技术，允许网站在离线状态下继续运行，并提供类似于原生应用程序的功能。</li><li>微前端：一种软件架构，可以将前端应用拆解成一些更小的、能够独立开发部署的微型应用，然后再将这些微应用进行组合，使其成为整体应用的架构模式。</li></ul><p>这些技术都在不同程度上推动了前端开发的发展，为用户提供了更好的体验。</p><h3 id="翻书效果css使用哪个方法"><a href="#翻书效果css使用哪个方法" class="headerlink" title="翻书效果css使用哪个方法"></a>翻书效果css使用哪个方法</h3><p>你可以使用 CSS 的 rotateY 方法来实现翻书效果。该方法可以定义沿 Y 轴的 3D 旋转，从而实现翻书的效果。以下是一个示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.book &#123;</span><br><span class="line">    perspective: 800px;</span><br><span class="line">    transform-style: preserve-3d;</span><br><span class="line">    animation: flip 10s linear infinite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes flip &#123;</span><br><span class="line">    0% &#123;</span><br><span class="line">        transform: rotateY(0deg);</span><br><span class="line">    &#125;</span><br><span class="line">    100% &#123;</span><br><span class="line">        transform: rotateY(180deg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，首先使用 perspective 属性设置视距，让元素具有 3D 效果，值越大，元素距离屏幕越远，视觉效果上就显得更小，这里设置为 800px 。然后使用 transform-style:preserve-3d; 开启 3D 空间。最后，使用 rotateY 方法结合 animation 属性来实现翻书效果， rotateY(0deg) 表示初始状态下页面是闭合的， rotateY(180deg) 表示页面完全翻开的状态， 10s 是翻书效果的时长， linear 是动画效果的速度曲线， infinite 是指动画效果无限循环。</p><p>实际应用中，你可以根据需要对代码进行调整，例如修改翻书效果的速度、方向和时长等。</p><h3 id="script标签的哪个属性可以实现html解析完成执行"><a href="#script标签的哪个属性可以实现html解析完成执行" class="headerlink" title="script标签的哪个属性可以实现html解析完成执行"></a>script标签的哪个属性可以实现html解析完成执行</h3><p>在 <script> 标签中， defer 属性可以实现 HTML 解析完成后执行脚本。</p><p> defer 属性的作用是延迟脚本的执行，直到页面完全加载（包括 HTML、CSS 和其他资源）完成后再执行。</p><p>使用 defer 属性的优点包括：</p><ol><li>提高页面加载速度：避免阻塞页面的其他内容加载。</li><li>确保脚本在 HTML 解析完成后执行：可以访问已解析的 DOM。</li></ol><p>示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script defer src=&quot;script.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在上述示例中，指定了 defer 属性，该脚本将在页面加载完成后执行。</p><p>需要注意的是， defer 属性只适用于外部脚本文件。如果脚本代码直接嵌入在 <script> 标签内部，则无法使用 defer 属性。</p><h3 id="js最准确的判断数组方法"><a href="#js最准确的判断数组方法" class="headerlink" title="js最准确的判断数组方法"></a>js最准确的判断数组方法</h3><p>在 JavaScript 中，有多种方法可以判断一个变量是否为数组，以下是几种常用的方法：</p><ul><li>instanceof 运算符：该方法通过检查变量的原型链中是否存在 Array 构造函数来判断一个变量是否为数组。如果存在，则返回 true，否则返回 false。但是，这种方法的准确性可能会受到原型链修改的影响。</li><li>Array.isArray()方法：这是 ECMAScript 5 引入的方法，用于判断一个值是否为数组。它的使用非常简单，直接调用该方法并传入待判断的值即可。如果返回值为 true，则表示该值是一个数组；如果返回值为 false，则表示该值不是数组。</li><li>Object.prototype.toString.call()方法：该方法会返回一个表示对象类型的字符串，对于数组来说，返回的字符串应该是"(object Array)"。这种方法可以准确地判断数组的类型，但代码相对复杂。</li></ul><p>总的来说，以上方法都可以用于判断一个变量是否为数组，具体选择哪种方法，取决于你的需求和代码结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">console.log(i);</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure><p>}这段JavaScript代码的功能是，每隔一秒（1000毫秒）在控制台打印变量i的值，一共打印三次。但是，你可能不会得到预期的连续打印0、1、2的结果，而是三次都打印3。</p><p>这是因为setTimeout函数是一个异步操作，它并不会立即执行，而是会等待指定的延迟时间后再执行。而在这段代码中，循环会先完成三次迭代，然后再依次执行setTimeout中的回调函数。由于let声明的变量i在循环外仍然是可访问的，所以每次执行回调函数时，它都会访问到当前的i值，即3。</p><p>如果你想让每次打印的都是循环时的i值，你需要使用闭包来捕获每次循环时的i值。你可以通过立即执行的函数表达式（IIFE）或者Array.prototype.forEach来实现这一点。</p><p>下面是使用IIFE的修改后的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">  (function(i) &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(i);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个修改后的代码中，每次循环都会创建一个新的函数作用域，并将当前的i值作为参数传递给这个作用域。这样，在setTimeout的回调函数中，我们就可以访问到这个被捕获的i值，而不是循环结束后的i值。</p><p>同样的，你也可以使用Array.prototype.forEach来实现相同的效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 2].forEach((i) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个包含三个元素的数组，并使用forEach方法遍历这个数组。每次遍历都会将当前的元素值（即i）作为参数传递给回调函数，这样我们就可以在回调函数中直接访问到这个值，而无需担心循环结束后的变量值变化。</p><h3 id="css选择器和优先级"><a href="#css选择器和优先级" class="headerlink" title="css选择器和优先级"></a>css选择器和优先级</h3><p>CSS选择器是用于选择你想要样式化的HTML元素的模式。这些选择器可以是元素选择器、类选择器、ID选择器、属性选择器、伪类选择器等。每种选择器都有其特定的用途和优先级。</p><p>CSS选择器种类：</p><p>元素选择器：基于HTML元素名称来选择元素，如 p、div 等。<br>类选择器：使用 . 开头的类名来选择元素，如 .myClass。<br>ID选择器：使用 # 开头的ID来选择元素，如 #myID。<br>属性选择器：基于元素的属性和属性值来选择元素，如 [type="text"]。<br>伪类选择器：用于选择HTML元素的特定状态，如 :hover、:active、:first-child 等。</p><p>CSS选择器优先级：</p><p>当多个选择器应用于同一个元素时，CSS有一套规则来确定哪个样式应该被应用。这就是所谓的“特异性”（specificity）或“优先级”。以下是确定优先级的一般规则：</p><p>内联样式：在HTML元素内部使用style属性定义的样式具有最高的优先级。<br>ID选择器：具有比类选择器、属性选择器和伪类选择器更高的优先级。<br>类选择器、属性选择器和伪类选择器：它们的优先级相同，并低于ID选择器，但高于元素选择器。<br>元素选择器：具有最低的优先级。<br>!important规则：如果样式声明后面带有!important，那么该声明将具有最高的优先级，无论其特异性如何。<br>继承：如果元素没有指定的样式，那么它会从其父元素继承样式。继承的样式具有最低的优先级。</p><p>如果两个选择器具有相同的特异性，那么后出现的规则会覆盖先出现的规则（这被称为“源顺序”或“后者优先”规则）。</p><p>为了编写高效且易于维护的CSS代码，建议尽量避免使用!important，并尽量保持选择器的特异性尽可能低。同时，合理地组织CSS规则，使它们易于理解和修改。</p><h3 id="0-1-0-2为什么不等于0-3"><a href="#0-1-0-2为什么不等于0-3" class="headerlink" title="0.1+0.2为什么不等于0.3"></a>0.1+0.2为什么不等于0.3</h3><p>在js中在 JavaScript 中，0.1 + 0.2 不等于 0.3 的原因在于浮点数在计算机中的表示和计算。这是由于计算机内部使用二进制表示法来存储浮点数，而很多十进制小数无法精确地用二进制小数来表示。</p><p>当你尝试将 0.1 和 0.2 相加时，这两个数在计算机内部实际上是以一种近似值的形式存在的。这种近似值是由一系列二进制位表示的，可能并不完全等同于十进制数中的 0.1 或 0.2。因此，当你将它们相加时，得到的结果可能是一个稍微偏离 0.3 的值。</p><p>这种问题不仅限于 JavaScript，它是浮点数运算中普遍存在的。如果你需要精确的小数运算，可能需要使用特殊的库或方法来处理。但在大多数日常编程任务中，这种微小的精度损失是可以接受的。</p><p>为了查看实际的计算结果，你可以尝试在 JavaScript 控制台中运行以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(0.1 + 0.2);</span><br></pre></td></tr></table></figure><p>你可能会看到类似 0.30000000000000004 这样的输出，这证明了计算结果并不完全等于 0.3。</p><p>如果你需要处理金融计算或其他需要高精度小数运算的场景，建议使用专门的库，如 decimal.js 或 big.js，这些库提供了更高精度的浮点数运算支持。</p><h3 id="设置过期时间的localstory实现"><a href="#设置过期时间的localstory实现" class="headerlink" title="设置过期时间的localstory实现"></a>设置过期时间的localstory实现</h3><p>你的问题可能是关于如何在JavaScript中实现一个具有过期时间的localStorage。在标准的localStorage API中，并没有直接提供设置过期时间的功能。但是，我们可以通过一些额外的逻辑来实现这一功能。</p><p>以下是一个简单的示例，演示了如何在localStorage中存储一个键值对，并为该键值对设置一个过期时间：</p><pre><code>class ExpiringLocalStorage {    constructor() {        this.prefix = &apos;expiring_&apos;;    }set(key, value, ttl) {    const now = new Date().getTime();    const expiry = now + ttl;    const data = {        value: value,        expiry: expiry    };    localStorage.setItem(this.prefix + key, JSON.stringify(data));}get(key) {    const item = localStorage.getItem(this.prefix + key);    if (!item) {        return null;    }    const data = JSON.parse(item);    const now = new Date().getTime();    if (now &gt; data.expiry) {        // 如果数据已过期，则删除并从localStorage中返回null        this.remove(key);        return null;    }    return data.value;}remove(key) {    localStorage.removeItem(this.prefix + key);}}// 使用示例：const expiringStorage = new ExpiringLocalStorage();expiringStorage.set(&apos;myKey&apos;, &apos;myValue&apos;, 1000 * 60 * 60); // 设置一个键为&apos;myKey&apos;，值为&apos;myValue&apos;，过期时间为1小时console.log(expiringStorage.get(&apos;myKey&apos;)); // 在过期前，应返回&apos;myValue&apos;</code></pre><p>在这个示例中，我们创建了一个名为ExpiringLocalStorage的类，它封装了localStorage的基本功能，并添加了过期时间的概念。当调用set方法时，除了存储键值对外，还会存储一个过期时间（以毫秒为单位）。当调用get方法时，会检查数据是否已过期。如果已过期，则会从localStorage中删除该数据并返回null。如果未过期，则返回数据的值。</p><p>请注意，这个实现并不会自动删除过期的数据。你需要通过调用get方法来检查并删除过期的数据。如果你需要定期清理过期的数据，你可能需要设置一个定时器或使用其他方法来定期调用清理逻辑。</p><p>此外，由于localStorage的大小有限，并且所有的浏览器都可能有不同的限制，因此在使用localStorage时需要注意不要存储过多的数据。</p><h3 id="分别解释请求头参数，host，cookie，method，accept，content-length"><a href="#分别解释请求头参数，host，cookie，method，accept，content-length" class="headerlink" title="分别解释请求头参数，host，cookie，method，accept，content-length"></a>分别解释请求头参数，host，cookie，method，accept，content-length</h3><p>当然可以，以下是这些请求头参数的解释：</p><p>Host：</p><p>Host 请求头字段用于指定请求所发送的目标域名的地址。在HTTP/1.1中，每个请求都应包含一个Host头，因为网络地址（如IP地址）可能对应多个域名。<br>示例：Host: <a href="http://www.example.com">www.example.com</a></p><p>Cookie：</p><p>Cookie 请求头字段用于发送之前由服务器通过Set-Cookie头发送到浏览器的cookie。当浏览器发送请求到服务器时，它会包含所有相关的cookie，以便服务器能够识别用户会话和其他状态信息。<br>示例：Cookie: session_id=12345; user_id=john</p><p>Method：</p><p>Method 或 HTTP-Method 指的是HTTP请求的类型或动作。它告诉服务器你想要对请求的资源执行什么操作。常见的HTTP方法包括GET（获取资源）、POST（提交数据）、PUT（更新资源）、DELETE（删除资源）等。<br>注意：虽然Method不是请求头的一部分，但它是HTTP请求的一个重要组成部分，通常与请求头一起发送。</p><p>Accept：</p><p>Accept 请求头字段用于告诉服务器客户端可以处理哪些类型的响应内容。这通常用于指定客户端可以理解的媒体类型，如text/html、application/json等。<br>示例：Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,<em>/</em>;q=0.8</p><p>Content-Length：</p><p>Content-Length 请求头字段表示请求体的长度（以字节为单位）。这对于那些包含请求体的请求方法（如POST和PUT）来说是非常重要的，因为它允许服务器知道要读取多少数据。<br>示例：Content-Length: 15</p><p>这些请求头字段在HTTP通信中起着关键作用，帮助客户端和服务器之间进行交互并理解彼此的请求和响应。不同的字段提供了关于请求的各种信息，使服务器能够更准确地响应客户端的需求。</p><h3 id="js数组里的数组，展开为一维数组去重升序"><a href="#js数组里的数组，展开为一维数组去重升序" class="headerlink" title="js数组里的数组，展开为一维数组去重升序"></a>js数组里的数组，展开为一维数组去重升序</h3><p>好的，了解你的需求啦！你想把一个包含数组的数组（二维数组）展开成一维数组，并且进行去重和升序排序，对吧？这个任务可以用JavaScript的几种方法来实现呢~</p><p>首先，我们可以使用Array.prototype.flat()方法将二维数组展开成一维数组，然后用Set数据结构进行去重，最后使用Array.prototype.sort()方法进行升序排序。下面是一个示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let nestedArray = [[1, 2, 3], [3, 4, 5], [5, 6, 1]];</span><br><span class="line"></span><br><span class="line">// 使用 flat 方法将二维数组展开成一维数组</span><br><span class="line">let flattenedArray = nestedArray.flat();</span><br><span class="line"></span><br><span class="line">// 使用 Set 数据结构进行去重</span><br><span class="line">let uniqueArray = [...new Set(flattenedArray)];</span><br><span class="line"></span><br><span class="line">// 使用 sort 方法进行升序排序</span><br><span class="line">let sortedArray = uniqueArray.sort((a, b) =&gt; a - b);</span><br><span class="line"></span><br><span class="line">console.log(sortedArray); // 输出: [1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure><p>上面的代码首先使用flat()方法将二维数组nestedArray展开成一维数组flattenedArray。然后，我们利用Set的特性，将数组转换为Set，自动去除了重复的元素，再通过展开运算符...将Set转回数组uniqueArray。最后，我们使用sort()方法，通过传入一个比较函数，将数组uniqueArray进行升序排序，得到最终的排序数组sortedArray。</p><p>这个方法是不是很方便呢？希望对你有帮助哦~ (｡♥‿♥｡)</p><h3 id="cavas怎么局部渲染"><a href="#cavas怎么局部渲染" class="headerlink" title="cavas怎么局部渲染"></a>cavas怎么局部渲染</h3><p>在Canvas中，局部渲染通常指的是只更新或重绘Canvas的某一部分，而不是整个画布。这可以提高性能，尤其是在处理大型或复杂的Canvas应用时。以下是几种实现局部渲染的常见方法：</p><p>使用clearRect清除特定区域：</p><p>在重绘之前，你可以使用clearRect方法来清除Canvas上的特定区域。然后，只在该区域内进行绘制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const canvas = document.getElementById(&apos;myCanvas&apos;);</span><br><span class="line">const ctx = canvas.getContext(&apos;2d&apos;);</span><br><span class="line"></span><br><span class="line">// 清除特定区域</span><br><span class="line">ctx.clear</span><br></pre></td></tr></table></figure><h3 id="什么是js闭包和原型链"><a href="#什么是js闭包和原型链" class="headerlink" title="什么是js闭包和原型链"></a>什么是js闭包和原型链</h3><p><strong>JS闭包</strong></p><p>在JavaScript中，闭包是一个强大的概念，它指的是一个有权访问另一个函数作用域中的变量的函数。换句话说，一个函数内部定义的函数（称为内嵌函数）可以访问其父级函数的变量，甚至在父级函数执行完毕后，这些变量依然可以被内嵌函数访问。这就是因为闭包可以维持一个到其外部作用域的引用。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> outerVariable = <span class="string">'I am from outer function!'</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        <span class="built_in">console</span>.log(outerVariable);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> innerFunction;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> inner = outerFunction();  </span><br><span class="line">inner(); <span class="comment">// 输出：I am from outer function!</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>innerFunction</code> 是一个闭包，因为它可以访问 <code>outerFunction</code> 的作用域中的 <code>outerVariable</code>。</p><p><strong>原型链</strong></p><p>原型链是JavaScript中对象继承的主要方式。每个JavaScript对象都有一个内部链接到另一个对象。这个链接被称为该对象的原型。当试图访问一个对象的属性时，如果该对象自身没有这个属性，那么JavaScript就会在该对象的原型上寻找这个属性，以此类推，一直通过原型链向上查找，直到找到属性或者到达原型链的末尾（<code>null</code>）。</p><p>每个构造函数都有一个 <code>prototype</code> 属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。当我们试图访问一个对象的某个属性时，JavaScript引擎首先会在对象本身的属性中查找，如果没有找到，就会到它的原型（也就是构造函数的 <code>prototype</code> 属性所指向的那个对象）中查找，如果再没有找到，就会到原型的原型中查找，依此类推，一直查到 <code>Object.prototype</code> 对象。如果还没有找到，就会返回 <code>undefined</code>。这种通过原型链接起来的链式结构，就叫做原型链。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.name = name;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">Person.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello, my name is '</span> + <span class="keyword">this</span>.name);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Alice'</span>);  </span><br><span class="line">person1.sayHello(); <span class="comment">// 输出：Hello, my name is Alice</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>person1</code> 是一个 <code>Person</code> 的实例，它继承了 <code>Person.prototype</code> 上的 <code>sayHello</code> 方法。当我们调用 <code>person1.sayHello()</code> 时，实际上是通过原型链找到了 <code>Person.prototype</code> 上的 <code>sayHello</code> 方法。</p><h3 id="vue2升级vue3具体怎么做"><a href="#vue2升级vue3具体怎么做" class="headerlink" title="vue2升级vue3具体怎么做"></a>vue2升级vue3具体怎么做</h3><p>Vue2升级到Vue3是一个涉及多个步骤的过程，下面是一个详细的步骤说明：</p><ol><li><strong>创建一个新的Vue3项目</strong>：<br>使用Vue CLI工具创建一个新的Vue3项目。可以通过在命令行中运行<code>vue create projectName</code>命令并按照提示进行操作来完成这一步。</li><li><strong>安装依赖</strong>：<br>在新创建的Vue3项目中，需要安装必要的依赖。首先，将原Vue2项目中的<code>package.json</code>文件下的<code>dependencies</code>节点中的<code>vue</code>、<code>element-ui</code>、<code>vuex</code>等内容删除，并将这些依赖项追加到新项目的<code>package.json</code>中。然后，安装<code>element-plus</code>和<code>pinia</code>这两个Vue3的对应库，可以通过<code>npm install element-plus pinia</code>或<code>yarn add element-plus pinia</code>命令进行安装。最后，继续安装剩余的其他依赖项，通过执行<code>npm install</code>或<code>yarn install</code>命令完成。</li><li><strong>整理代码</strong>：<br>将原Vue2项目的<code>src</code>目录中的代码拷贝到新创建的Vue3项目中，但注意不要直接复制<code>main.js</code>文件。然后，根据代码的具体情况修改<code>main.js</code>文件。这一步可能涉及到对Vue2和Vue3之间API差异的处理。</li><li><strong>重写组件逻辑</strong>：<br>Vue 3引入了Composition API作为官方提供的组合式API，取代了Vue 2中的Options API。因此，在升级过程中，需要重写现有的组件逻辑，改为基于Composition API编写。这涉及到对组件内部状态、生命周期钩子、方法等的重新组织和实现。</li><li><strong>修改生命周期钩子</strong>：<br>Vue 3对生命周期钩子进行了调整，一些在Vue 2中存在的钩子（如<code>beforeCreate</code>、<code>created</code>等）被删除或替换。同时，Vue 3引入了新的生命周期钩子，如<code>setup()</code>函数作为新的入口点，以及<code>onBeforeMount</code>、<code>onMounted</code>等。因此，在升级过程中，需要根据Vue 3的文档说明修改相应的生命周期钩子名称和用法。</li><li><strong>处理其他差异</strong>：<br>在升级过程中，还需要注意Vue 2和Vue 3之间可能存在的其他差异，如指令的注册方式、全局API的变化等。这些差异可能需要根据具体的项目代码和Vue 3的文档进行逐一处理。</li><li><strong>测试与调试</strong>：<br>完成上述步骤后，需要对升级后的Vue3项目进行测试和调试，确保所有功能都正常工作，没有出现错误或异常。这可能涉及到对项目的各个部分进行详细的检查和验证。</li></ol><p>请注意，Vue2升级到Vue3是一个复杂的过程，可能涉及到大量的代码修改和重构。在进行升级之前，建议详细阅读Vue 3的官方文档，了解Vue 3的新特性和与Vue 2的差异，以便更好地进行升级工作。同时，也建议备份好原Vue2项目的代码，以防万一出现不可预期的问题。</p><h3 id="ES6-中的一些新特性"><a href="#ES6-中的一些新特性" class="headerlink" title="ES6 中的一些新特性"></a>ES6 中的一些新特性</h3><p>ES6 即 ECMAScript 2015，是 JavaScript 的新一代标准。</p><ul><li>块级作用域：使用 let 和 const 关键字声明块级作用域的变量和常量，避免变量污染和重复定义。</li><li>箭头函数：可以更简洁地定义函数，并且它的 this 值绑定在定义时的环境中，而不是执行时的环境。</li><li>模板字符串：可以方便地拼接字符串和变量，避免了繁琐的字符串拼接和转义。</li><li>解构赋值：可以方便地提取对象和数组中的值并赋值给变量，使得代码更加简洁易懂。</li><li>Rest 参数：将函数参数作为数组来处理，避免了需要使用 arguments 对象的情况。</li><li>Spread 操作符：可以将数组或对象展开成独立的元素，方便地进行数组合并、对象合并等操作。</li><li>Class 类：更方便地定义对象和继承，使得面向对象编程更加规范和易懂。</li><li>Promise 异步编程：可以更好地处理异步操作，避免了回调地狱的问题。</li><li>Promise.all 方法：可以同时执行多个 Promise 对象，并在所有 Promise 对象都执行完毕后返回结果。</li><li>模块化：引入了模块化的概念，可以更好地组织和管理代码，避免了全局变量的污染。</li></ul><p>如你想了解更多关于 ES6 的新特性，可点击web前端tips:ES6部分常用新特性介绍查看。</p><h3 id="setter怎么通知它的订阅者"><a href="#setter怎么通知它的订阅者" class="headerlink" title="setter怎么通知它的订阅者"></a>setter怎么通知它的订阅者</h3><p>在Vue中，setter可以通过 dep.notify() 方法来通知它的订阅者。其具体流程如下：</p><ol><li>创建一个 Observer 对象作为数据监听器，用来监听所有属性的变化。</li><li>使用 Object.defineProperty() 方法，递归遍历所有属性，为每个属性添加 setter 和 getter 。</li><li>当给对象的某个属性赋值时，会触发 setter ，从而监听到数据的变化。</li><li>setter 触发 Dep 的 notify 方法，该方法会调用所有订阅者的 update 方法，以通知它们数据的变化。</li></ol><p>通过这种方式，setter可以及时通知它的订阅者，从而实现数据的双向绑定和动态更新。</p><h3 id="有一个20g的tar包，需要前端上传，如何做技术架构"><a href="#有一个20g的tar包，需要前端上传，如何做技术架构" class="headerlink" title="有一个20g的tar包，需要前端上传，如何做技术架构"></a>有一个20g的tar包，需要前端上传，如何做技术架构</h3><p>对于20GB的tar包，前端上传确实需要一些特殊的技术架构来处理大文件上传的问题。以下是一个建议的技术架构：</p><h4 id="前端处理"><a href="#前端处理" class="headerlink" title="前端处理"></a>前端处理</h4><p>文件分片：<br>将20GB的tar包切分成多个较小的文件分片。每个分片的大小可以根据网络条件和服务器配置来决定，通常可以选择几MB到几十MB不等。</p><p>分片上传：<br>使用JavaScript中的File API和FormData对象，逐个上传这些分片。可以使用如axios或fetch等HTTP客户端库来发送分片上传的请求。</p><p>进度追踪与展示：<br>通过监听每个分片的上传进度事件，实时更新并展示上传进度给用户，以便他们了解上传的进度和剩余时间。</p><p>断点续传：<br>如果上传过程中发生网络中断或其他错误，前端需要能够记录已经上传的分片信息，并在恢复上传时跳过这些已上传的分片，从断点处继续上传。</p><p>错误处理与重试机制：<br>对于上传失败的分片，前端应该实现重试机制，尝试重新上传失败的分片，直到成功为止。</p><h4 id="后端处理"><a href="#后端处理" class="headerlink" title="后端处理"></a>后端处理</h4><p>接收分片：<br>后端需要提供一个API接口，用于接收前端发送的文件分片。可以使用Node.js、Java、Python等后端技术栈来实现。</p><p>分片存储：<br>后端接收到分片后，需要将其存储到临时目录中，以便后续合并成完整的tar包。可以使用文件系统、云存储服务（如Amazon S3、阿里云OSS等）或其他存储解决方案来存储分片。</p><p>合并分片：<br>当所有分片都上传完成后，后端需要将这些分片合并成一个完整的tar包。可以使用文件操作API或相关库来完成分片的合并。</p><p>文件完整性校验：<br>后端在合并完成后，应该计算整个tar包的哈希值，并与前端提供的哈希值进行比对，以确保文件的完整性。</p><p>删除临时分片：<br>合并完成后，后端需要删除存储的临时分片，以释放存储空间。</p><h4 id="其他考虑"><a href="#其他考虑" class="headerlink" title="其他考虑"></a>其他考虑</h4><p>安全性：<br>确保上传过程的安全性，例如使用HTTPS进行通信，验证用户身份，防止恶意文件上传等。</p><p>上传速度优化：<br>根据网络条件和服务器性能，可以考虑使用多线程上传、并行上传等技术来加快上传速度。</p><p>用户体验：<br>优化前端界面和交互，提供友好的上传体验，如拖拽上传、批量上传等功能。</p><p>综上所述，处理20GB的tar包上传需要前端和后端的紧密配合，通过文件分片、断点续传、错误处理等技术手段来确保上传的可靠性和效率。同时，还需要考虑安全性和用户体验等方面的问题。</p><h3 id="js设计模式"><a href="#js设计模式" class="headerlink" title="js设计模式"></a>js设计模式</h3><p>在 JavaScript 中，设计模式是解决软件开发某些特定问题而提出的一些解决方案，也可以理解成解决问题的一些思路。通过设计模式可以帮助开发者增强代码的可重用性、可扩充性、可维护性、灵活性。以下是几种常见的 JavaScript 设计模式：</p><ul><li>单例模式：单例模式是一种只允许实例化一次的对象创建模式。它保证一个类只有一个实例，并且提供一个访问该实例的全局点。在 JavaScript 中，可以通过闭包来实现单例模式。</li><li>原型模式：原型模式是基于原型继承的。在这种模式中，被创建的对象充当其他对象的原型。实际上，原型（prototype）是被创建的每个对象构造函数的蓝图。</li><li>模块设计模式：模块设计模式对原型模式做了一些改进。模块模式设置了不同类型的修饰符（私有和公共）。你可以创建相似的函数或属性而不会发生冲突。这个设计模式的一个缺陷是无法覆盖（override）外部环境中创建的函数。</li><li>构造函数设计模式：这是一种特殊的方法，用于在分配内存后初始化新创建的对象。由于 JavaScript 一般来说是面向对象的，所以它打交道最多的就是对象。于是深入研究对象构造函数。在 JavaScript 中创建新对象有三种方法可用。</li></ul><p>如果你还想了解更多关于 JavaScript 设计模式的内容，请继续向我提问。</p><h3 id="vue2迁移vue3，具体怎么处理"><a href="#vue2迁移vue3，具体怎么处理" class="headerlink" title="vue2迁移vue3，具体怎么处理"></a>vue2迁移vue3，具体怎么处理</h3><p>将 Vue 2 项目迁移到 Vue 3 可以按照以下步骤进行处理：</p><ol><li>升级 Vue 版本：在项目中安装 Vue 3。</li><li>组件重构：根据 Vue 3 的语法和特性，重构组件。</li><li>使用 Composition API：利用 Composition API 来管理状态和逻辑。</li><li>模板语法调整：适应 Vue 3 的模板语法变化。</li><li>处理生命周期钩子：了解 Vue 3 中生命周期钩子的改动。</li><li>适配插件和依赖：确保使用的插件和依赖与 Vue 3 兼容。</li><li>测试和调试：进行全面的测试以确保项目的正常运行。</li></ol><p>在迁移过程中，可能会遇到一些问题，需要仔细检查和调试。同时，参考 Vue 3 的官方文档和相关教程可以帮助你更好地完成迁移。</p><h3 id="前端工程师在项目中遇到什么难题，你是怎么解决它？"><a href="#前端工程师在项目中遇到什么难题，你是怎么解决它？" class="headerlink" title="前端工程师在项目中遇到什么难题，你是怎么解决它？"></a>前端工程师在项目中遇到什么难题，你是怎么解决它？</h3><p>前端工程师在项目中可能会遇到以下一些难题：</p><ol><li>浏览器兼容性问题：不同浏览器对 HTML、CSS 和 JavaScript 的实现可能存在差异。<br>解决方法：进行广泛的浏览器测试，使用特定的兼容解决方案。</li><li>性能优化：确保页面加载速度快，用户体验良好。<br>解决方法：压缩资源、优化代码、使用缓存等。</li><li>复杂的用户界面设计：创建具有复杂交互和视觉效果的界面。<br>解决方法：选择合适的前端框架和工具，进行合理的架构设计。</li><li>与后端集成：确保前端与后端之间的数据传输和通信顺畅。<br>解决方法：使用合适的 API 设计和通信协议。</li><li>移动端适配：使页面在各种移动设备上良好显示。<br>解决方法：采用响应式设计或特定的移动端解决方案。</li><li>安全和权限问题：保护用户数据和系统安全。<br>解决方法：实施安全策略，进行漏洞测试。</li><li>团队协作和代码管理：与其他开发者协同工作。<br>解决方法：使用版本控制系统，进行有效的沟通和协作。</li><li>不断变化的技术和需求：跟上行业的发展和用户需求的变化。<br>解决方法：持续学习，灵活调整项目架构。</li></ol><p>解决这些难题通常需要以下步骤：</p><ol><li>分析问题：确定问题的本质和范围。</li><li>研究和学习：查找相关的知识和解决方案。</li><li>尝试不同方法：进行实验和测试。</li><li>与团队成员沟通：分享想法和经验。</li><li>优化和改进：不断完善解决方案。</li><li>记录和总结：以便在未来的项目中参考。</li></ol><h3 id="程序题"><a href="#程序题" class="headerlink" title="程序题"></a>程序题</h3><p>let str='aabcd'<br>计算每个字母出现的次数<br>将重复字母移出字符串</p><p>在 JavaScript 中，可以通过遍历字符串来计算每个字母出现的次数，并使用数组来存储每个字母及其出现的次数。然后遍历数组，将重复的字母从字符串中移除。以下是示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let str = &apos;aabcd&apos;;</span><br><span class="line">let charCount = &#123;&#125;;</span><br><span class="line">for (let i = 0; i &lt; str.length; i++) &#123;</span><br><span class="line">  if (charCount[str[i]]) &#123;</span><br><span class="line">    charCount[str[i]]++;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    charCount[str[i]] = 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let newStr = &apos;&apos;;</span><br><span class="line">for (let key in charCount) &#123;</span><br><span class="line">  if (charCount[key] === 1) &#123;</span><br><span class="line">    newStr += key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(newStr);</span><br></pre></td></tr></table></figure><p>在上述代码中，首先定义了字符串<code>str</code>，然后遍历字符串，通过<code>charCount</code>对象来记录每个字母及其出现的次数。接着创建一个新的字符串<code>newStr</code>，遍历<code>charCount</code>对象，将出现次数为 1 的字母添加到<code>newStr</code>中。最后打印输出处理后的字符串。 </p></script></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;new操作符具体干了什么呢&quot;&gt;&lt;a href=&quot;#new操作符具体干了什么呢&quot; class=&quot;headerlink&quot; title=&quot;new操作符具体干了什么呢?&quot;&gt;&lt;/a&gt;new操作符具体干了什么呢?&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;创建一个空对象，并且 this 变量
      
    
    </summary>
    
      <category term="前端面试题" scheme="https://qw66.gitee.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="JavaScript" scheme="https://qw66.gitee.io/tags/JavaScript/"/>
    
      <category term="DOM" scheme="https://qw66.gitee.io/tags/DOM/"/>
    
      <category term="BOM" scheme="https://qw66.gitee.io/tags/BOM/"/>
    
      <category term="事件循环" scheme="https://qw66.gitee.io/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>vue3</title>
    <link href="https://qw66.gitee.io//interview/vue3.html"/>
    <id>https://qw66.gitee.io//interview/vue3.html</id>
    <published>2024-03-10T13:02:08.000Z</published>
    <updated>2024-03-28T18:11:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vue3的新特性"><a href="#vue3的新特性" class="headerlink" title="vue3的新特性"></a>vue3的新特性</h3><h4 id="1、响应系统的变动"><a href="#1、响应系统的变动" class="headerlink" title="1、响应系统的变动"></a>1、响应系统的变动</h4><p>由原来的Object.defineProperty 的getter和setter，改变成为了ES2015 Proxy 作为其观察机制。</p><p>Proxy的优势：消除了以前存在的警告，使速度加倍，并节省了一半的内存开销。</p><h4 id="2、虚拟DOM重写（Virtual-DOM-Rewrite）"><a href="#2、虚拟DOM重写（Virtual-DOM-Rewrite）" class="headerlink" title="2、虚拟DOM重写（Virtual DOM Rewrite）"></a>2、虚拟DOM重写（Virtual DOM Rewrite）</h4><p>虚拟 DOM 从头开始重写，我们可以期待更多的编译时提示来减少运行时开销。重写将包括更有效的代码来创建虚拟节点。</p><h4 id="3、组件渲染的优化（优化插槽生成）"><a href="#3、组件渲染的优化（优化插槽生成）" class="headerlink" title="3、组件渲染的优化（优化插槽生成）"></a>3、组件渲染的优化（优化插槽生成）</h4><p>Vue2当中在父组件渲染同时，子组件也会渲染。 Vue3就可以单独渲染父组件、子组件。</p><h4 id="4、静态树提升（Static-Tree-Hoisting）"><a href="#4、静态树提升（Static-Tree-Hoisting）" class="headerlink" title="4、静态树提升（Static Tree Hoisting）"></a>4、静态树提升（Static Tree Hoisting）</h4><p>使用静态树提升，这意味着 Vue3 的编译器将能够检测到什么是静态组件，然后将其提升，从而降低了渲染成本。它将能够跳过未整个树结构打补丁的过程。</p><h4 id="5、静态属性提升（Static-Props-Hoisting）"><a href="#5、静态属性提升（Static-Props-Hoisting）" class="headerlink" title="5、静态属性提升（Static Props Hoisting）"></a>5、静态属性提升（Static Props Hoisting）</h4><p>此外，我们可以期待静态属性提升，其中 Vue3将跳过不会改变节点的打补丁过程。</p><p>总体来说：1. 更快 2. 更小 3. 更容易维护 4. 更加友好 5. 更容易使用</p><h3 id="vue3对比vue2有哪些不同？"><a href="#vue3对比vue2有哪些不同？" class="headerlink" title="vue3对比vue2有哪些不同？"></a>vue3对比vue2有哪些不同？</h3><p>答： <a href="https://www.cnblogs.com/ygunoil/p/14463855.html" target="_blank" rel="noopener">https://www.cnblogs.com/ygunoil/p/14463855.html</a></p><h3 id="Proxy-相比于-defineProperty-的优势"><a href="#Proxy-相比于-defineProperty-的优势" class="headerlink" title="Proxy 相比于 defineProperty 的优势"></a>Proxy 相比于 defineProperty 的优势</h3><p>Object.defineProperty() 的问题主要有三个：</p><ul><li>不能监听数组的变化</li><li>必须深层遍历嵌套的对象</li><li>必须遍历对象的每个属性</li></ul><p>Proxy 在 ES2015 规范中被正式加入，它有以下几个特点：</p><ul><li>针对对象：针对整个对象，而不是对象的某个属性，所以也就不需要对 keys 进行遍历。这解决了上述 Object.defineProperty() 第二个问题</li><li>支持数组：Proxy 不需要对数组的方法进行重载，省去了众多 hack，减少代码量等于减少了维护成本，而且标准的就是最好的。</li></ul><p>除了上述两点之外，Proxy 还拥有以下优势：</p><ul><li>Proxy 的第二个参数可以有 13 种拦截方法，这比起 Object.defineProperty() 要更加丰富</li><li>Proxy 作为新标准受到浏览器厂商的重点关注和性能优化，相比之下 Object.defineProperty() 是一个已有的老方法。</li></ul><h3 id="vue2为什么不使用proxy？"><a href="#vue2为什么不使用proxy？" class="headerlink" title="vue2为什么不使用proxy？"></a>vue2为什么不使用proxy？</h3><p> 答： 兼容性</p><h3 id="vue3性能比vue2好的原因？"><a href="#vue3性能比vue2好的原因？" class="headerlink" title="vue3性能比vue2好的原因？"></a>vue3性能比vue2好的原因？</h3><p>1.diff算法优化</p><p>2.静态提升hoistStatic</p><p>3.事件侦听器缓存cacheHandles</p><p><a href="https://www.cnblogs.com/ygunoil/p/14463687.html" target="_blank" rel="noopener">https://www.cnblogs.com/ygunoil/p/14463687.html</a></p><h3 id="Vue3-0-里为什么要用-Proxy-API-替代-defineProperty-API？"><a href="#Vue3-0-里为什么要用-Proxy-API-替代-defineProperty-API？" class="headerlink" title="Vue3.0 里为什么要用 Proxy API 替代 defineProperty API？"></a>Vue3.0 里为什么要用 Proxy API 替代 defineProperty API？</h3><p>响应式优化<strong>（高频，重点！！！）</strong></p><p>这是在面试中问的最多的一个问题，无论是大厂还是中小型公司，都喜欢问，也是Vue更新的重点。</p><p>1.defineProperty API 的局限性最大原因是<strong>它只能针对单例属性做监听</strong>。</p><p>Vue2.x中的响应式实现正是基于defineProperty中的descriptor，对 data 中的属性做了遍历 + 递归，为每个属性设置了 getter、setter。这也就是为什么 Vue 只能对 data 中预定义过的属性做出响应的原因，在Vue中使用下标的方式直接修改属性的值或者添加一个预先不存在的对象属性是无法做到setter监听的，这是defineProperty的局限性。</p><p>2.Proxy API的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作， 这就完全可以代理所有属性，将会带来很大的性能提升和更优的代码。</p><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p><p>3.响应式是惰性的</p><p>在 Vue.js 2.x 中，对于一个深层属性嵌套的对象，要劫持它内部深层次的变化，就需要递归遍历这个对象，<strong>执行 Object.defineProperty 把每一层对象数据都变成响应式的，这无疑会有很大的性能消耗</strong>。在 Vue.js 3.0 中，使用 Proxy API 并不能监听到对象内部深层次的属性变化，因此它的处理方式是在 getter 中去递归响应式，这样的好处是<strong>真正访问到的内部属性才会变成响应式，简单的可以说是按需实现响应式，减少性能消耗。</strong>基础用法：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://pics7.baidu.com/feed/42166d224f4a20a4ac217837b8d32f25730ed088.jpeg?token=ab85fef62897b5de230005159580dbae&s=21F0632201FB2E210CE15E8F0200808A" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><h3 id="Vue3-0-编译做了哪些优化？（底层，源码）"><a href="#Vue3-0-编译做了哪些优化？（底层，源码）" class="headerlink" title="Vue3.0 编译做了哪些优化？（底层，源码）"></a>Vue3.0 编译做了哪些优化？<strong>（底层，源码）</strong></h3><h4 id="生成-Block-tree"><a href="#生成-Block-tree" class="headerlink" title="生成 Block tree"></a>生成 Block tree</h4><p>Vue.js 2.x 的数据更新并触发重新渲染的粒度是组件级的，单个组件内部 需要遍历该组件的整个 vnode 树。<strong>在2.0里，渲染效率的快慢与组件大小成正相关：组件越大，渲染效率越慢。**</strong>并且，对于一些静态节点，又无数据更新，这些遍历都是性能浪费。<strong>Vue.js 3.0 做到了通过编译阶段对静态模板的分析，编译生成了 Block tree。 <strong>Block tree</strong></strong>是一个将模版基于动态节点指令切割的嵌套区块<strong>，每个 区块内部的节点结构是固定的，每个区块只需要追踪自身包含的动态节点。所以，</strong>在3.0里，渲染效率不再与模板大小成正相关，而是与模板中动态节点的数量成正相关。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://pics7.baidu.com/feed/8cb1cb13495409230918b8cebad9660eb2de4992.jpeg?token=d8b708fbbfa88364be1301c26a826a6a&s=BAA2F54C1AE0AB7C5C6524030000E0C3" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><h4 id="slot-编译优化"><a href="#slot-编译优化" class="headerlink" title="slot 编译优化"></a>slot 编译优化</h4><p>Vue.js 2.x 中，如果有一个组件传入了slot，那么每次父组件更新的时候，会强制使子组件update，造成性能的浪费。Vue.js 3.0 优化了slot的生成，使得非动态slot中属性的更新只会触发子组件的更新。<strong>动态slot指的是在slot上面使用v-if，v-for，动态slot名字等会导致slot产生运行时动态变化但是又无法被子组件track的操作。**</strong>c. diff算法优化**（此知识点进大厂可能会问到，由于篇幅较长，大家可以去官网看下）</p><h4 id="Vue3-0新特性-——-Composition-API-与-React-js-中-Hooks的异同点（难点问题）"><a href="#Vue3-0新特性-——-Composition-API-与-React-js-中-Hooks的异同点（难点问题）" class="headerlink" title="Vue3.0新特性 —— Composition API 与 React.js 中 Hooks的异同点（难点问题）"></a>Vue3.0新特性 —— Composition API 与 React.js 中 Hooks的异同点（难点问题）</h4><h4 id="React-js-中的-Hooks-基本使用"><a href="#React-js-中的-Hooks-基本使用" class="headerlink" title="React.js 中的 Hooks 基本使用"></a>React.js 中的 Hooks 基本使用</h4><p>React Hooks 允许你 “勾入” 诸如组件状态和副作用处理等 React 功能中。Hooks 只能用在函数组件中，并允许我们在不需要创建类的情况下将状态、副作用处理和更多东西带入组件中。React 核心团队奉上的采纳策略是不反对类组件，所以你可以升级 React 版本、在新组件中开始尝试 Hooks，并保持既有组件不做任何更改。案例：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://pics0.baidu.com/feed/4bed2e738bd4b31cdb2c7638af5790789f2ff8ae.jpeg?token=227aa01d9da625df78e4629dab22e444&s=01F0E9264BAEB64D4C594F8E0200708A" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>useState 和 useEffect 是 React Hooks 中的一些例子，使得函数组件中也能增加状态和运行副作用。我们也可以自定义一个Hooks，它打开了代码复用性和扩展性的新大门。</p><h4 id="Vue-Composition-API-基本使用"><a href="#Vue-Composition-API-基本使用" class="headerlink" title="Vue Composition API 基本使用"></a>Vue Composition API 基本使用</h4><p>Vue Composition API 围绕一个新的组件选项 setup 而创建。setup() 为 Vue 组件提供了状态、计算值、watcher 和生命周期钩子。并没有让原来的 API（Options-based API）消失。允许开发者 结合使用新旧两种 API（向下兼容）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://pics5.baidu.com/feed/fcfaaf51f3deb48f5f457428d89e8d2e2cf578a5.jpeg?token=540b94be60198116f5a6803d43073660&s=09F1EB004BAEB64D0EFC85870200E08A" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>React hook 底层是基于链表实现，调用的条件是每次组件被render的时候都会顺序执行所有的hooks。vue hook 只会被注册调用一次，vue 能避开这些麻烦的问题，原因在于它对数据的响应是基于proxy的，对数据直接代理观察。（这种场景下，只要任何一个更改data的地方，相关的function或者template都会被重新计算，因此避开了react可能遇到的性能上的问题）。react 中，数据更改的时候，会导致重新render，重新render又会重新把hooks重新注册一次，所以react复杂程度会高一些。</p><h3 id="Vue3-0是如何变得更快的？（底层，源码）"><a href="#Vue3-0是如何变得更快的？（底层，源码）" class="headerlink" title="Vue3.0是如何变得更快的？（底层，源码）"></a>Vue3.0是如何变得更快的？（底层，源码）</h3><h4 id="diff方法优化"><a href="#diff方法优化" class="headerlink" title="diff方法优化"></a>diff方法优化</h4><p>Vue2.x 中的虚拟dom是进行全量的对比。Vue3.0 中新增了静态标记（PatchFlag）：在与上次虚拟结点进行对比的时候，值对比带有patch flag的节点，并且可以通过flag 的信息得知当前节点要对比的具体内容化。</p><h4 id="hoistStatic-静态提升"><a href="#hoistStatic-静态提升" class="headerlink" title="hoistStatic 静态提升"></a>hoistStatic 静态提升</h4><p>Vue2.x : 无论元素是否参与更新，每次都会重新创建。Vue3.0 : 对不参与更新的元素，只会被创建一次，之后会在每次渲染时候被不停的复用。</p><h4 id="cacheHandlers-事件侦听器缓存"><a href="#cacheHandlers-事件侦听器缓存" class="headerlink" title="cacheHandlers 事件侦听器缓存"></a>cacheHandlers 事件侦听器缓存</h4><p>默认情况下onClick会被视为动态绑定，所以每次都会去追踪它的变化但是因为是同一个函数，所以没有追踪变化，直接缓存起来复用即可。说在后面</p><p>其实很多小伙伴都存在这样一种情况：<strong>Vue2.x都用了一年多了，官方文档都还没有去详细过一遍，遇到问题就百度，所以Vue3.0一出就惊慌失措。</strong></p><p>所以我建议正确的学习姿势应该是：</p><p>当我们去接触一门新技术的时候，首要任务就是看官方文档，先大致过一遍，知道有哪些东西。开发的时候遇到问题再去针对具体的知识点细看。遇到实在搞不定的，官方文档看不懂的，再行百度也不迟。</p><h3 id="Vue-3-0-性能提升主要是通过哪几方面体现的？"><a href="#Vue-3-0-性能提升主要是通过哪几方面体现的？" class="headerlink" title="Vue 3.0 性能提升主要是通过哪几方面体现的？"></a>Vue 3.0 性能提升主要是通过哪几方面体现的？</h3><h4 id="响应式系统提升"><a href="#响应式系统提升" class="headerlink" title="响应式系统提升"></a>响应式系统提升</h4><p>vue2在初始化的时候，对data中的每个属性使用definepropery调用getter和setter使之变为响应式对象。如果属性值为对象，还会递归调用defineproperty使之变为响应式对象。<br>vue3使用proxy对象重写响应式。proxy的性能本来比defineproperty好，proxy可以拦截属性的访问、赋值、删除等操作，不需要初始化的时候遍历所有属性，另外有多层属性嵌套的话，只有访问某个属性的时候，才会递归处理下一级的属性。<br>优势：<br>可以监听动态新增的属性；<br>可以监听删除的属性 ；<br>可以监听数组的索引和 length 属性；</p><h4 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h4><p>优化编译和重写虚拟dom，让首次渲染和更新dom性能有更大的提升<br>vue2 通过标记静态根节点,优化 diff 算法<br>vue3 标记和提升所有静态根节点,diff 的时候只比较动态节点内容</p><p>Fragments, 模板里面不用创建唯一根节点,可以直接放同级标签和文本内容</p><p>静态提升</p><p>patch flag, 跳过静态节点,直接对比动态节点</p><p>缓存事件处理函数</p><h4 id="源码体积的优化"><a href="#源码体积的优化" class="headerlink" title="源码体积的优化"></a>源码体积的优化</h4><p>vue3移除了一些不常用的api，例如：inline-template、filter等<br>使用tree-shaking</p><h4 id="Vue-3-0-所采用的-Composition-Api-与-Vue-2-x使用的Options-Api-有什么区别？"><a href="#Vue-3-0-所采用的-Composition-Api-与-Vue-2-x使用的Options-Api-有什么区别？" class="headerlink" title="Vue 3.0 所采用的 Composition Api 与 Vue 2.x使用的Options Api 有什么区别？"></a>Vue 3.0 所采用的 Composition Api 与 Vue 2.x使用的Options Api 有什么区别？</h4><h4 id="Options-Api"><a href="#Options-Api" class="headerlink" title="Options Api"></a>Options Api</h4><p>包含一个描述组件选项（data、methods、props等）的对象 options；<br>API开发复杂组件，同一个功能逻辑的代码被拆分到不同选项 ；<br>使用mixin重用公用代码，也有问题：命名冲突，数据来源不清晰；</p><h4 id="composition-Api"><a href="#composition-Api" class="headerlink" title="composition Api"></a>composition Api</h4><p>vue3 新增的一组 api，它是基于函数的 api，可以更灵活的组织组件的逻辑。<br>解决options api在大型项目中，options api不好拆分和重用的问题。</p><h3 id="Proxy-相对于-Object-defineProperty-有哪些优点？"><a href="#Proxy-相对于-Object-defineProperty-有哪些优点？" class="headerlink" title="Proxy 相对于 Object.defineProperty 有哪些优点？"></a>Proxy 相对于 Object.defineProperty 有哪些优点？</h3><p>proxy的性能本来比defineproperty好，proxy可以拦截属性的访问、赋值、删除等操作，不需要初始化的时候遍历所有属性，另外有多层属性嵌套的话，只有访问某个属性的时候，才会递归处理下一级的属性。</p><p>可以监听数组变化<br>可以劫持整个对象<br>操作时不是对原对象操作,是 new Proxy 返回的一个新对象<br>可以劫持的操作有 13 种</p><h3 id="Vue-3-0-在编译方面有哪些优化？"><a href="#Vue-3-0-在编译方面有哪些优化？" class="headerlink" title="Vue 3.0 在编译方面有哪些优化？"></a>Vue 3.0 在编译方面有哪些优化？</h3><p>vue.js 3.x中标记和提升所有的静态节点，diff的时候只需要对比动态节点内容；<br>Fragments（升级vetur插件): template中不需要唯一根节点，可以直接放文本或者同级标签<br>静态提升(hoistStatic),当使用 hoistStatic 时,所有静态的节点都被提升到 render 方法之外.只会在应用启动的时候被创建一次,之后使用只需要应用提取的静态节点，随着每次的渲染被不停的复用。<br>patch flag, 在动态标签末尾加上相应的标记,只能带 patchFlag 的节点才被认为是动态的元素,会被追踪属性的修改,能快速的找到动态节点,而不用逐个逐层遍历，提高了虚拟dom diff的性能。<br>缓存事件处理函数cacheHandler,避免每次触发都要重新生成全新的function去更新之前的函数<br>tree shaking 通过摇树优化核心库体积,减少不必要的代码量</p><h3 id="Vue-js-3-0-响应式系统的实现原理？"><a href="#Vue-js-3-0-响应式系统的实现原理？" class="headerlink" title="Vue.js 3.0 响应式系统的实现原理？"></a>Vue.js 3.0 响应式系统的实现原理？</h3><h4 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h4><p>设置对象为响应式对象。接收一个参数，判断这参数是否是对象。不是对象则直接返回这个参数，不做响应式处理。<br>创建拦截器handerler，设置get/set/deleteproperty。<br>get<br>收集依赖（track）；<br>如果当前 key 的值是对象，则为当前 key 的对象创建拦截器 handler, 设置 get/set/deleteProperty；<br>如果当前的 key 的值不是对象，则返回当前 key 的值。<br>set<br>设置的新值和老值不相等时，更新为新值，并触发更新（trigger）。<br>deleteProperty<br>当前对象有这个 key 的时候，删除这个 key 并触发更新（trigger）。</p><h4 id="effect"><a href="#effect" class="headerlink" title="effect"></a>effect</h4><p>接收一个函数作为参数。作用是：访问响应式对象属性时去收集依赖</p><h4 id="track"><a href="#track" class="headerlink" title="track"></a>track</h4><p>接收两个参数：target 和 key<br>－如果没有 activeEffect，则说明没有创建 effect 依赖<br>－如果有 activeEffect，则去判断 WeakMap 集合中是否有 target 属性<br>－WeakMap 集合中没有 target 属性，则 set(target, (depsMap = new Map()))<br>－WeakMap 集合中有 target 属性，则判断 target 属性的 map 值的 depsMap 中是否有 key 属性<br>－depsMap 中没有 key 属性，则 set(key, (dep = new Set()))<br>－depsMap 中有 key 属性，则添加这个 activeEffect</p><h4 id="trigger"><a href="#trigger" class="headerlink" title="trigger"></a>trigger</h4><p>判断 WeakMap 中是否有 target 属性，WeakMap 中有 target 属性，则判断 target 属性的 map 值中是否有 key 属性，有的话循环触发收集的 effect()。</p><p>昨晚做了一个梦，梦见自己到了一家大厂面试，面试官走近房间，坐了下来：是杨溜溜吧？国际惯例，先来个自我介绍吧。</p><p>于是我巴拉巴拉开始了长达两分钟的自我介绍，与此同时，面试官边听边看我的简历，边看边皱眉，结束后问：看你之前的项目经常用到vue，对Vue熟悉吗？</p><p>我嘴角一笑，心里暗喜：幸好有专门看Vue的面试题，看来这次稳了。于是谦虚又装逼的回答：还行吧，您随便问。</p><p>于是面试官看我口气那么大，心想：哟嚯，来了一个装逼的，劳资今天就只问Vue。</p><h3 id="来，先介绍一下Vue的响应式系统"><a href="#来，先介绍一下Vue的响应式系统" class="headerlink" title="来，先介绍一下Vue的响应式系统"></a>来，先介绍一下Vue的响应式系统</h3><p>Vue为MVVM框架，当数据模型data变化时，页面视图会得到响应更新，其原理对data的getter/setter方法进行拦截（Object.defineProperty或者Proxy），利用发布订阅的设计模式，在getter方法中进行订阅，在setter方法中发布通知，让所有订阅者完成响应。</p><p>在响应式系统中，Vue会为数据模型data的每一个属性新建一个订阅中心作为发布者，而监听器watch、计算属性computed、视图渲染template/render三个角色同时作为订阅者，对于监听器watch，会直接订阅观察监听的属性，对于计算属性computed和视图渲染template/render，如果内部执行获取了data的某个属性，就会执行该属性的getter方法，然后自动完成对该属性的订阅，当属性被修改时，就会执行该属性的setter方法，从而完成该属性的发布通知，通知所有订阅者进行更新。</p><h3 id="computed与watch的区别"><a href="#computed与watch的区别" class="headerlink" title="computed与watch的区别"></a>computed与watch的区别</h3><p>计算属性computed和监听器watch<strong>都可以观察属性的变化从而做出响应</strong>，不同的是：</p><p>计算属性computed更多是<strong>作为缓存功能的观察者</strong>，它可以将一个或者多个data的属性进行复杂的计算生成一个新的值，提供给渲染函数使用，当依赖的属性变化时，computed不会立即重新计算生成新的值，而是先标记为脏数据，当下次computed被获取时候，才会进行重新计算并返回。</p><p>而监听器watch<strong>并不具备缓存性，监听器watch提供一个监听函数，当监听的属性发生变化时，会立即执行该函数。</strong></p><h3 id="介绍一下Vue的生命周期"><a href="#介绍一下Vue的生命周期" class="headerlink" title="介绍一下Vue的生命周期"></a>介绍一下Vue的生命周期</h3><p>beforeCreate：是new Vue()之后触发的第一个钩子，在当前阶段data、methods、computed以及watch上的<strong>数据和方法都不能被访问</strong>。</p><p>created：在实例创建完成后发生，当前阶段已经完成了数据观测，也就是<strong>可以使用数据，更改数据</strong>，在这里更改数据不会触发updated函数。可以做一些初始数据的获取，在当前阶段<strong>无法与Dom进行交互</strong>，如果非要想，可以通过vm.$nextTick来访问Dom。</p><p>beforeMount：发生在挂载之前，在这之前template模板已导入渲染函数编译。而当前阶段虚拟Dom已经创建完成，即将开始渲染。在此时<strong>也可以对数据进行更改，不会触发updated</strong>。</p><p>mounted：在挂载完成后发生，在当前阶段，<strong>真实的Dom挂载完毕，数据完成双向绑定，可以访问到Dom节点，使用$refs属性对Dom进行操作。</strong></p><p>beforeUpdate：发生在更新之前，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。</p><p>updated：发生在更新完成之后，当前阶段组件Dom已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。</p><p>beforeDestroy：发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。</p><p>destroyed：发生在实例销毁之后，这个时候只剩下了dom空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</p><h3 id="为什么组件的data必须是一个函数"><a href="#为什么组件的data必须是一个函数" class="headerlink" title="为什么组件的data必须是一个函数"></a>为什么组件的data必须是一个函数</h3><p>一个组件可能在很多地方使用，也就是会创建很多个实例，如果data是一个对象的话，对象是引用类型，一个实例修改了data会影响到其他实例，所以data必须使用函数，为每一个实例创建一个属于自己的data，使其同一个组件的不同实例互不影响。</p><h3 id="组件之间是怎么通信的"><a href="#组件之间是怎么通信的" class="headerlink" title="组件之间是怎么通信的"></a>组件之间是怎么通信的</h3><p>父子组件通信<br>父组件 -&gt; 子组件：prop</p><p>子组件 -&gt; 父组件：$on/$emit</p><p>获取组件实例：使用$parent/$children，$refs.xxx，获取到实例后直接获取属性数据或调用组件方法</p><p>兄弟组件通信<br>Event Bus：每一个Vue实例都是一个Event Bus，都支持$on/$emit，可以为兄弟组件的实例之间new一个Vue实例，作为Event Bus进行通信。</p><p>Vuex：将状态和方法提取到Vuex，完成共享</p><p>跨级组件通信<br>使用provide/inject</p><p>Event Bus：同兄弟组件Event Bus通信</p><p>Vuex：将状态和方法提取到Vuex，完成共享</p><h3 id="Vue事件绑定原理说一下"><a href="#Vue事件绑定原理说一下" class="headerlink" title="Vue事件绑定原理说一下"></a>Vue事件绑定原理说一下</h3><p>每一个Vue实例都是一个Event Bus，当子组件被创建的时候，父组件将事件传递给子组件，子组件初始化的时候是有$on方法将事件注册到内部，在需要的时候使用$emit触发函数，而对于原生native事件，使用addEventListener绑定到真实的DOM元素上。</p><h3 id="slot是什么？有什么作用？原理是什么？"><a href="#slot是什么？有什么作用？原理是什么？" class="headerlink" title="slot是什么？有什么作用？原理是什么？"></a>slot是什么？有什么作用？原理是什么？</h3><p>slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。</p><p>slot又分三类，默认插槽，具名插槽和作用域插槽。</p><h4 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h4><p>又名匿名插槽，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。</p><h4 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h4><p>带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。</p><h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h4><p>默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。<br>实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在vm.$slot中，默认插槽为vm.$slot.default，具名插槽为vm.$slot.xxx，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用$slot中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。</p><h3 id="Vue模板渲染的原理是什么？"><a href="#Vue模板渲染的原理是什么？" class="headerlink" title="Vue模板渲染的原理是什么？"></a>Vue模板渲染的原理是什么？</h3><p>vue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的html语法，所有需要将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的html元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。</p><p>模板编译又分三个阶段，解析parse，优化optimize，生成generate，最终生成可执行函数render。</p><p>parse阶段：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。<br>optimize阶段：遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。<br>generate阶段：将最终的AST转化为render函数字符串。</p><h3 id="template预编译是什么？"><a href="#template预编译是什么？" class="headerlink" title="template预编译是什么？"></a>template预编译是什么？</h3><p>对于 Vue 组件来说，模板编译只会在<strong>组件实例化的时候编译一次</strong>，生成渲染函数之后在也不会进行编译。因此，编译对组件的 runtime 是一种性能损耗。</p><p>而模板编译的目的仅仅是将template转化为render function，这个过程，正好可以在项目构建的过程中完成，这样可以让实际组件在 runtime 时直接跳过模板渲染，进而提升性能，这个在项目构建的编译template的过程，就是预编译。</p><h3 id="那template和jsx的有什么分别？"><a href="#那template和jsx的有什么分别？" class="headerlink" title="那template和jsx的有什么分别？"></a>那template和jsx的有什么分别？</h3><p>对于 runtime 来说，只需要保证组件存在 render 函数即可，而我们有了预编译之后，我们只需要保证构建过程中生成 render 函数就可以。</p><p>在 webpack 中，我们使用vue-loader编译.vue文件，内部依赖的vue-template-compiler模块，在 webpack 构建过程中，将template预编译成 render 函数。</p><p>与 react 类似，在添加了jsx的语法糖解析器babel-plugin-transform-vue-jsx之后，就可以直接手写render函数。</p><p>所以，template和jsx的都是render的一种表现形式，不同的是：</p><p>JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。</p><h3 id="说一下什么是Virtual-DOM"><a href="#说一下什么是Virtual-DOM" class="headerlink" title="说一下什么是Virtual DOM"></a>说一下什么是Virtual DOM</h3><p>Virtual DOM 是 DOM 节点在 JavaScript 中的一种抽象数据结构，之所以需要虚拟DOM，是因为浏览器中操作DOM的代价比较昂贵，频繁操作DOM会产生性能问题。虚拟DOM的作用是在每一次响应式数据发生变化引起页面重渲染时，<strong>Vue对比更新前后的虚拟DOM，匹配找出尽可能少的需要更新的真实DOM，从而达到提升性能的目的。</strong></p><h3 id="介绍一下Vue中的Diff算法"><a href="#介绍一下Vue中的Diff算法" class="headerlink" title="介绍一下Vue中的Diff算法"></a>介绍一下Vue中的Diff算法</h3><p>在新老虚拟DOM对比时</p><p>首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换<br>如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)<br>比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。<br>匹配时，找到相同的子节点，递归比较子节点<br>在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从O(n^3)降低值O(n)，也就是说，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。</p><h3 id="key属性的作用是什么"><a href="#key属性的作用是什么" class="headerlink" title="key属性的作用是什么"></a>key属性的作用是什么</h3><p>在对节点进行diff的过程中，判断是否为相同节点的一个很重要的条件是key是否相等，如果是相同节点，则会尽可能的复用原有的DOM节点。所以key属性是提供给框架在diff的时候使用的，而非开发者。</p><h3 id="说说Vue2-0和Vue3-0有什么区别"><a href="#说说Vue2-0和Vue3-0有什么区别" class="headerlink" title="说说Vue2.0和Vue3.0有什么区别"></a>说说Vue2.0和Vue3.0有什么区别</h3><p>重构响应式系统，使用Proxy替换Object.defineProperty，使用Proxy优势：<br>可直接监听数组类型的数据变化<br>监听的目标为对象本身，不需要像Object.defineProperty一样遍历每个属性，有一定的性能提升<br>可拦截apply、ownKeys、has等13种方法，而Object.defineProperty不行<br>直接实现对象属性的新增/删除<br>新增Composition API，更好的逻辑复用和代码组织<br>重构 Virtual DOM<br>模板编译时的优化，将一些静态节点编译成常量<br>slot优化，将slot编译为lazy函数，将slot的渲染的决定权交给子组件<br>模板中内联事件的提取并重用（原本每次渲染都重新生成内联函数）<br>代码结构调整，更便于Tree shaking，使得体积更小<br>使用Typescript替换Flow</p><h3 id="为什么要新增Composition-API，它能解决什么问题"><a href="#为什么要新增Composition-API，它能解决什么问题" class="headerlink" title="为什么要新增Composition API，它能解决什么问题"></a>为什么要新增Composition API，它能解决什么问题</h3><p>Vue2.0中，随着功能的增加，组件变得越来越复杂，越来越难维护，而难以维护的根本原因是Vue的API设计迫使开发者使用watch，computed，methods选项组织代码，而不是实际的业务逻辑。</p><p>另外Vue2.0缺少一种较为简洁的低成本的机制来完成逻辑复用，虽然可以minxis完成逻辑复用，但是当mixin变多的时候，会使得难以找到对应的data、computed或者method来源于哪个mixin，使得类型推断难以进行。</p><p>所以Composition API的出现，主要是也是为了解决Option API带来的问题，第一个是代码组织问题，Compostion API可以让开发者根据业务逻辑组织自己的代码，让代码具备更好的可读性和可扩展性，也就是说当下一个开发者接触这一段不是他自己写的代码时，他可以更好的利用代码的组织反推出实际的业务逻辑，或者根据业务逻辑更好的理解代码。</p><p>第二个是实现代码的逻辑提取与复用，当然mixin也可以实现逻辑提取与复用，但是像前面所说的，多个mixin作用在同一个组件时，很难看出property是来源于哪个mixin，来源不清楚，另外，多个mixin的property存在变量命名冲突的风险。而Composition API刚好解决了这两个问题。</p><h3 id="都说Composition-API与React-Hook很像，说说区别"><a href="#都说Composition-API与React-Hook很像，说说区别" class="headerlink" title="都说Composition API与React Hook很像，说说区别"></a>都说Composition API与React Hook很像，说说区别</h3><p>从React Hook的实现角度看，React Hook是根据useState调用的顺序来确定下一次重渲染时的state是来源于哪个useState，所以出现了以下限制</p><p>不能在循环、条件、嵌套函数中调用Hook<br>必须确保总是在你的React函数的顶层调用Hook<br>useEffect、useMemo等函数必须手动确定依赖关系<br>而Composition API是基于Vue的响应式系统实现的，与React Hook的相比</p><p>声明在setup函数内，一次组件实例化只调用一次setup，而React Hook每次重渲染都需要调用Hook，使得React的GC比Vue更有压力，性能也相对于Vue来说也较慢<br>Compositon API的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用<br>响应式系统自动实现了依赖收集，进而组件的部分的性能优化由Vue内部自己完成，而React Hook需要手动传入依赖，而且必须必须保证依赖的顺序，让useEffect、useMemo等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。<br>虽然Compositon API看起来比React Hook好用，但是其设计思想也是借鉴React Hook的。</p><h3 id="SSR有了解吗？原理是什么？"><a href="#SSR有了解吗？原理是什么？" class="headerlink" title="SSR有了解吗？原理是什么？"></a>SSR有了解吗？原理是什么？</h3><p>在客户端请求服务器的时候，服务器到数据库中获取到相关的数据，并且<strong>在服务器内部将Vue组件渲染成HTML</strong>，并且将数据、HTML一并返回给客户端，这个在服务器将数据和组件转化为HTML的过程，叫做<strong>服务端渲染SSR</strong>。</p><p>而当客户端拿到服务器渲染的HTML和数据之后，由于数据已经有了，客户端不需要再一次请求数据，而只需要将数据同步到组件或者Vuex内部即可。除了数据以外，HTML也结构已经有了，客户端在渲染组件的时候，也只需要将HTML的DOM节点映射到Virtual DOM即可，不需要重新创建DOM节点，这个将数据和HTML同步的过程，又叫做<strong>客户端激活</strong>。</p><h3 id="使用SSR的好处："><a href="#使用SSR的好处：" class="headerlink" title="使用SSR的好处："></a>使用SSR的好处：</h3><h4 id="有利于seo"><a href="#有利于seo" class="headerlink" title="有利于seo"></a>有利于seo</h4><p>其实就是有利于爬虫来爬你的页面，因为部分页面爬虫是不支持执行JavaScript的，这种不支持执行JavaScript的爬虫抓取到的非SSR的页面会是一个空的HTML页面，而有了SSR以后，这些爬虫就可以获取到完整的HTML结构的数据，进而收录到搜索引擎中。</p><h4 id="白屏时间更短"><a href="#白屏时间更短" class="headerlink" title="白屏时间更短"></a>白屏时间更短</h4><p>相对于客户端渲染，服务端渲染在浏览器请求URL之后已经得到了一个带有数据的HTML文本，<strong>浏览器只需要解析HTML，直接构建DOM树就可以</strong>。而客户端渲染，需要先得到一个空的HTML页面，这个时候页面已经进入白屏，之后还需要经过<strong>加载并执行 JavaScript、请求后端服务器获取数据、JavaScript 渲染页面</strong>几个过程才可以看到最后的页面。特别是在复杂应用中，由于需要加载 JavaScript 脚本，越是复杂的应用，需要加载的 JavaScript 脚本就越多、越大，这会导致应用的首屏加载时间非常长，进而降低了体验感。</p><h2 id="一、Vue3-里-script-的三种写法"><a href="#一、Vue3-里-script-的三种写法" class="headerlink" title="一、Vue3 里 script 的三种写法"></a>一、Vue3 里 <code>script</code> 的三种写法</h2><p>首先，Vue3 新增了一个叫做组合式 api 的东西，英文名叫 Composition API。因此 Vue3 的 <code>script</code> 现在支持三种写法，</p><h3 id="1、最基本的-Vue2-写法"><a href="#1、最基本的-Vue2-写法" class="headerlink" title="1、最基本的 Vue2 写法"></a><strong>1、最基本的 Vue2 写法</strong></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"onClick"</span>&gt;</span></span><br><span class="line">    增加 1</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      count: 1,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onClick() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.count += <span class="number">1</span>;</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、setup-属性"><a href="#2、setup-属性" class="headerlink" title="2、setup() 属性"></a><strong>2、setup() 属性</strong></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"onClick"</span>&gt;</span></span><br><span class="line">    增加 1</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">  <span class="comment">// 注意这部分</span></span></span><br><span class="line">  setup() &#123;</span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> count = ref(<span class="number">1</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line">      count.value += 1;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      count,</span><br><span class="line">      onClick,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3、script-setup"><a href="#3、script-setup" class="headerlink" title="3、script setup"></a>3、<code>script setup</code></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"onClick"</span>&gt;</span></span><br><span class="line">    增加 1</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="keyword">const</span> count = ref(<span class="number">1</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line">  count.value += 1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>正如你看到的那样，无论是代码行数，还是代码的精简度，<code>script setup</code> 的方式是最简单的形式。</p><p><strong>如果你对 Vue 很熟悉，那么，我推荐你使用</strong><code>script setup</code><strong>的方式。</strong></p><p>这种写法，让 Vue3 成了我最喜欢的前端框架。</p><p><strong>如果你还是前端新人，那么，我推荐你先学习第一种写法。</strong></p><p>因为第一种写法的学习负担更小，先学第一种方式，掌握最基本的 Vue 用法，然后再根据我这篇文章，快速掌握 Vue3 里最需要关心的内容。</p><p>第一种写法，跟过去 Vue2 的写法是一样的，所以我们不过多介绍。</p><p>第二种写法，所有的对象和方法都需要 <code>return</code> 才能使用，太啰嗦。除了旧项目，可以用这种方式体验 Vue3 的新特性以外，我个人不建议了解这种方式。反正我自己暂时不打算精进这部分。</p><p>所以，接下来，我们主要介绍的，也就是<code>script setup</code> ，这种写法里需要了解的内容。</p><p><strong>注意：</strong><code>script setup</code>本质上是第二种写法的语法糖，掌握了这种写法，其实第二种写法也基本上就会了。（又多了一个不学第二种写法的理由）。</p><h2 id="二、如何使用script-setup编写组件"><a href="#二、如何使用script-setup编写组件" class="headerlink" title="二、如何使用script setup编写组件"></a>二、如何使用<code>script setup</code>编写组件</h2><p><strong>学习 Vue3 并不代表你需要新学习一个技术，Vue3 的底层开发思想，跟 Vue2 是没有差别的。</strong></p><p><strong>V3 和 V2 的区别就像是，你用不同的语言或者方言说同一句话。</strong></p><p>所以我们需要关心的，就是 Vue2 里的内容，怎么用 Vue3 的方式写出来。</p><h3 id="1、data——唯一需要注意的地方"><a href="#1、data——唯一需要注意的地方" class="headerlink" title="1、data——唯一需要注意的地方"></a>1、<code>data</code>——唯一需要注意的地方</h3><p>整个 <code>data</code> 这一部分的内容，你只需要记住下面这一点。</p><p><strong>以前在</strong> <strong><code>data</code></strong> <strong>中创建的属性，现在全都用</strong> <strong><code>ref()</code></strong> <strong>声明。</strong></p><p><strong>在</strong> <strong><code>template</code></strong> <strong>中直接用，在</strong> <strong><code>script</code></strong> <strong>中记得加</strong> <strong><code>.value</code></strong> <strong>。</strong></p><p>在开头，我就已经写了一个简单的例子，我们直接拿过来做对比。</p><h4 id="1）写法对比"><a href="#1）写法对比" class="headerlink" title="1）写法对比"></a><strong>1）写法对比</strong></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> // Vue2 的写法</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"onClick"</span>&gt;</span></span><br><span class="line">    增加 1</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      count: 1,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onClick() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.count += <span class="number">1</span>;</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> // Vue3 的写法</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"onClick"</span>&gt;</span></span><br><span class="line">    增加 1</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"> <span class="comment">// 用这种方式声明</span></span></span><br><span class="line"><span class="actionscript"><span class="keyword">const</span> count = ref(<span class="number">1</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">   <span class="comment">// 使用的时候记得 .value</span></span></span><br><span class="line">  count.value += 1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2）注意事项——组合式-api-的心智负担"><a href="#2）注意事项——组合式-api-的心智负担" class="headerlink" title="2）注意事项——组合式 api 的心智负担"></a><strong>2）注意事项——组合式</strong> <strong>api</strong> <strong>的心智负担</strong></h4><h5 id="a、ref-和-reactive"><a href="#a、ref-和-reactive" class="headerlink" title="a、ref 和 reactive"></a><strong>a、ref 和 reactive</strong></h5><p>Vue3 里，还提供了一个叫做 <code>reactive</code> 的 <code>api</code>。</p><p>但是我的建议是，你不需要关心它。绝大多数场景下，<code>ref</code> 都够用了。</p><h5 id="b、什么时候用-ref-包裹，什么时候不用。"><a href="#b、什么时候用-ref-包裹，什么时候不用。" class="headerlink" title="b、什么时候用 ref() 包裹，什么时候不用。"></a><strong>b、什么时候用</strong> <strong><code>ref()</code></strong> <strong>包裹，什么时候不用。</strong></h5><p>要不要用ref，就看你的这个变量的值改变了以后，页面要不要跟着变。</p><p>当然，你可以完全不需要关心这一点，跟过去写 <code>data</code> 一样就行。</p><p>只不过这样做，你在使用的时候，需要一直 <code>.value</code>。</p><h5 id="c、不要解构使用"><a href="#c、不要解构使用" class="headerlink" title="c、不要解构使用"></a><strong>c、不要解构使用</strong></h5><p>在使用时，不要像下面这样去写，会<strong>丢失响应性。</strong></p><p><strong>也就是会出现更新了值，但是页面没有更新的情况</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// Vue3 的写法</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"onClick"</span>&gt;</span></span><br><span class="line">    增加 1</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="keyword">const</span> count = ref(<span class="number">1</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">  <span class="comment">// 不要这样写！！</span></span></span><br><span class="line"><span class="actionscript">  <span class="keyword">const</span> &#123; value &#125; = count;</span></span><br><span class="line">  value += 1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 学习 Vue3 就需要考虑像这样的内容，徒增了学习成本。实际上这些心智负担，在学习的过程中，是可以完全不需要考虑的。</p><p><strong>这也是为什么我推荐新人先学习 Vue2 的写法。</strong></p><h3 id="2、methods"><a href="#2、methods" class="headerlink" title="2、methods"></a><strong>2、methods</strong></h3><p>声明事件方法，我们只需要在 <code>script</code> 标签里，创建一个方法对象即可。</p><p>剩下的在 Vue2 里是怎么写的，Vue3 是同样的写法。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// Vue2 的写法</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">"onClick"</span>&gt;</span></span><br><span class="line">    这是一个div</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    onClick() &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'clicked'</span>)</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">// Vue3 的写法</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">"onClick"</span>&gt;</span></span><br><span class="line">    这是一个div</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="comment">// 注意这部分</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'clicked'</span>)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3、props"><a href="#3、props" class="headerlink" title="3、props"></a><strong>3、props</strong></h3><p>声明 <code>props</code> 我们可以用 <code>defineProps()</code>，具体写法，我们看代码。</p><h4 id="1）写法对比-1"><a href="#1）写法对比-1" class="headerlink" title="1）写法对比"></a><strong>1）写法对比</strong></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// Vue2 的写法</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; foo &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  props: &#123;</span><br><span class="line"><span class="javascript">    foo: <span class="built_in">String</span>,</span></span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">// Vue3 的写法</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; foo &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="comment">// 注意这里</span></span></span><br><span class="line"><span class="actionscript"><span class="keyword">const</span> props = defineProps(&#123;</span></span><br><span class="line"><span class="javascript">  foo: <span class="built_in">String</span></span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="comment">// 在 script 标签里使用</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(props.foo)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2）注意事项——组合式-api-的心智负担-1"><a href="#2）注意事项——组合式-api-的心智负担-1" class="headerlink" title="2）注意事项——组合式 api 的心智负担"></a><strong>2）注意事项——组合式</strong> <strong>api</strong> <strong>的心智负担</strong></h4><p>使用 props 时，同样注意不要使用解构的方式。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">const</span> props = defineProps(&#123;</span></span><br><span class="line"><span class="javascript">  foo: <span class="built_in">String</span></span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="actionscript"> <span class="comment">// 不要这样写</span></span></span><br><span class="line"><span class="actionscript"><span class="keyword">const</span> &#123; foo &#125; = props;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(foo)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4、emits-事件"><a href="#4、emits-事件" class="headerlink" title="4、emits 事件"></a><strong>4、emits 事件</strong></h3><p>与 <code>props</code> 相同，声明 <code>emits</code> 我们可以用 <code>defineEmits()</code>，具体写法，我们看代码。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// Vue2 的写法</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">"onClick"</span>&gt;</span></span><br><span class="line">    这是一个div</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">  emits: [<span class="string">'click'</span>], <span class="comment">// 注意这里</span></span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    onClick() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.$emit(<span class="string">'click'</span>); <span class="comment">// 注意这里</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">// Vue3 的写法</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">"onClick"</span>&gt;</span></span><br><span class="line">    这是一个div</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="comment">// 注意这里</span></span></span><br><span class="line"><span class="actionscript"><span class="keyword">const</span> emit = defineEmits([<span class="string">'click'</span>]);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">  emit(<span class="string">'click'</span>) <span class="comment">// 注意这里</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5、computed"><a href="#5、computed" class="headerlink" title="5、computed"></a><strong>5、computed</strong></h3><p>直接上写法对比。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// Vue2 的写法</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; value &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; reversedValue &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">      value: <span class="string">'this is a value'</span>,</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    reversedValue() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> value</span></span><br><span class="line"><span class="actionscript">        .split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">// Vue3 的写法</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; value &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; reversedValue &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123;ref, computed&#125; <span class="keyword">from</span> <span class="string">'vue'</span></span></span><br><span class="line"><span class="actionscript"><span class="keyword">const</span> value = ref(<span class="string">'this is a value'</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="comment">// 注意这里</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> reversedValue = computed(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">  <span class="comment">// 使用 ref 需要 .value</span></span></span><br><span class="line"><span class="actionscript">  <span class="keyword">return</span> value.value</span></span><br><span class="line"><span class="actionscript">    .split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6、watch"><a href="#6、watch" class="headerlink" title="6、watch"></a>6、watch</h3><p>这一部分，我们需要注意一下了，Vue3 中，watch 有两种写法。一种是直接使用 <code>watch</code>，还有一种是使用 <code>watchEffect</code>。</p><p>两种写法的区别是：</p><ul><li><code>watch</code> 需要你明确指定依赖的变量，才能做到监听效果。</li><li>而 <code>watchEffect</code> 会根据你使用的变量，自动的实现监听效果。</li></ul><h4 id="1）直接使用-watch"><a href="#1）直接使用-watch" class="headerlink" title="1）直接使用 watch"></a>1）直接使用 <code>watch</code></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// Vue2 的写法</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; anotherCount &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"onClick"</span>&gt;</span></span><br><span class="line">    增加 1</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;  </span></span><br><span class="line">      count: 1,</span><br><span class="line">      anotherCount: 0,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onClick() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.count += <span class="number">1</span>;</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    count(newValue) &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.anotherCount = newValue - <span class="number">1</span>;</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">// Vue3 的写法</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; anotherCount &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"onClick"</span>&gt;</span></span><br><span class="line">    增加 1</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="keyword">const</span> count = ref(<span class="number">1</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line">  count.value += 1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="keyword">const</span> anotherCount = ref(<span class="number">0</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="comment">// 注意这里</span></span></span><br><span class="line"><span class="actionscript"><span class="comment">// 需要在这里，</span></span></span><br><span class="line"><span class="actionscript"><span class="comment">// 明确指定依赖的是 count 这个变量</span></span></span><br><span class="line">watch(count, (newValue) =&gt; &#123;</span><br><span class="line">  anotherCount.value = newValue - 1;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2）使用-watchEffect"><a href="#2）使用-watchEffect" class="headerlink" title="2）使用 watchEffect"></a>2）使用 <code>watchEffect</code></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// Vue2 的写法</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; anotherCount &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"onClick"</span>&gt;</span></span><br><span class="line">    增加 1</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;  </span></span><br><span class="line">      count: 1,</span><br><span class="line">      anotherCount: 0,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onClick() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.count += <span class="number">1</span>;</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    count(newValue) &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.anotherCount = newValue - <span class="number">1</span>;</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">// Vue3 的写法</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; anotherCount &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"onClick"</span>&gt;</span></span><br><span class="line">    增加 1</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; ref, watchEffect &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="keyword">const</span> count = ref(<span class="number">1</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line">  count.value += 1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="keyword">const</span> anotherCount = ref(<span class="number">0</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="comment">// 注意这里</span></span></span><br><span class="line"><span class="javascript">watchEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">  <span class="comment">// 会自动根据 count.value 的变化，</span></span></span><br><span class="line"><span class="actionscript">  <span class="comment">// 触发下面的操作</span></span></span><br><span class="line">  anotherCount.value = count.value - 1;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="7、生命周期"><a href="#7、生命周期" class="headerlink" title="7、生命周期"></a>7、生命周期</h3><p>Vue3 里，除了将两个 <code>destroy</code> 相关的钩子，改成了 <code>unmount</code>，剩下的需要注意的，就是在 `` 中，不能使用 <code>beforeCreate</code> 和 <code>created</code> 两个钩子。</p><p>如果你熟悉相关的生命周期，只需要记得在 <code>setup</code> 里，用 <code>on</code> 开头，加上大写首字母就行。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 选项式 api 写法</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  beforeCreate() &#123;&#125;,</span><br><span class="line">  created() &#123;&#125;,</span><br><span class="line">  </span><br><span class="line">  beforeMount() &#123;&#125;,</span><br><span class="line">  mounted() &#123;&#125;,</span><br><span class="line">  </span><br><span class="line">  beforeUpdate() &#123;&#125;,</span><br><span class="line">  updated() &#123;&#125;,</span><br><span class="line">  </span><br><span class="line"><span class="actionscript">  <span class="comment">// Vue2 里叫 beforeDestroy</span></span></span><br><span class="line">  beforeUnmount() &#123;&#125;,</span><br><span class="line"><span class="actionscript">  <span class="comment">// Vue2 里叫 destroyed</span></span></span><br><span class="line">  unmounted() &#123;&#125;,</span><br><span class="line">  </span><br><span class="line"><span class="actionscript">  <span class="comment">// 其他钩子不常用，所以不列了。</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">// 组合式 api 写法</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="meta"><span class="meta-keyword">import</span> &#123;</span></span></span><br><span class="line">  onBeforeMount,</span><br><span class="line">  onMounted,</span><br><span class="line"></span><br><span class="line">  onBeforeUpdate,</span><br><span class="line">  onUpdated,</span><br><span class="line"></span><br><span class="line">  onBeforeUnmount,</span><br><span class="line">  onUnmounted,</span><br><span class="line"><span class="javascript">&#125; <span class="keyword">from</span> <span class="string">'vue'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">onBeforeMount(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span></span><br><span class="line"><span class="javascript">onMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">onBeforeUpdate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span></span><br><span class="line"><span class="javascript">onUpdated(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">onBeforeUnmount(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span></span><br><span class="line"><span class="javascript">onUnmounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="三、结语"><a href="#三、结语" class="headerlink" title="三、结语"></a>三、结语</h2><p>好了，对于快速上手 Vue3 来说，以上内容基本已经足够了。</p><p>如果觉得这篇文章不错，有帮你节省时间的话，还想听我说哪些内容，欢迎评论区里告诉我。</p><p>这篇文章本身不能做到帮你理解所有 Vue3 的内容，但是能帮你快速掌握 Vue3 的写法。</p><p>如果想做到对 Vue3 的整个内容心里有数，还需要你自己多看看 Vue3 的官方文档。<br>原文链接：<a href="https://juejin.cn/post/7225267685763907621" target="_blank" rel="noopener">https://juejin.cn/post/7225267685763907621</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;vue3的新特性&quot;&gt;&lt;a href=&quot;#vue3的新特性&quot; class=&quot;headerlink&quot; title=&quot;vue3的新特性&quot;&gt;&lt;/a&gt;vue3的新特性&lt;/h3&gt;&lt;h4 id=&quot;1、响应系统的变动&quot;&gt;&lt;a href=&quot;#1、响应系统的变动&quot; class=&quot;he
      
    
    </summary>
    
      <category term="前端面试题" scheme="https://qw66.gitee.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="vue3" scheme="https://qw66.gitee.io/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>vue</title>
    <link href="https://qw66.gitee.io//interview/vue.html"/>
    <id>https://qw66.gitee.io//interview/vue.html</id>
    <published>2024-03-09T13:02:08.000Z</published>
    <updated>2024-05-28T02:10:45.286Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面试题链接"><a href="#面试题链接" class="headerlink" title="面试题链接"></a>面试题链接</h3><p><a href="https://blog.csdn.net/qq_41646249/article/details/104644647" target="_blank" rel="noopener">https://blog.csdn.net/qq_41646249/article/details/104644647</a></p><p><a href="https://blog.csdn.net/qq_41646249/article/details/104644712" target="_blank" rel="noopener">https://blog.csdn.net/qq_41646249/article/details/104644712</a></p><h3 id="Vue-中的-key-有什么作用？"><a href="#Vue-中的-key-有什么作用？" class="headerlink" title="Vue 中的 key 有什么作用？"></a>Vue 中的 key 有什么作用？</h3><p>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。</p><p>Vue 的 diff 过程可以概括为：oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex 和 newStartIndex、newEndIndex，它们会新节点和旧节点会进行两两对比，即一共有4种比较方式：newStartIndex 和oldStartIndex 、newEndIndex 和 oldEndIndex 、newStartIndex 和 oldEndIndex 、newEndIndex 和 oldStartIndex，如果以上 4 种比较都没匹配，如果设置了key，就会用 key 再进行比较，在比较的过程中，遍历会往中间靠，一旦 StartIdx &gt; EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。具体有无 key 的 diff 过程，可以查看作者写的另一篇详解虚拟 DOM 的文章《深入剖析：Vue核心之虚拟DOM》</p><p>所以 Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速</p><p>更准确：因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。</p><p>更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快，源码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createKeyToOldIdx</span> (<span class="params">children, beginIdx, endIdx</span>) </span>&#123;</span><br></pre></td></tr></table></figure><h3 id="vue的优点是什么？"><a href="#vue的优点是什么？" class="headerlink" title="vue的优点是什么？"></a>vue的优点是什么？</h3><ul><li><p>低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变</p></li><li><p>可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑</p></li><li><p>可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写</p></li><li><p>简洁、轻快、舒服</p></li></ul><h3 id="组件之间的传值？"><a href="#组件之间的传值？" class="headerlink" title="组件之间的传值？"></a>组件之间的传值？</h3><h4 id="父组件与子组件传值"><a href="#父组件与子组件传值" class="headerlink" title="父组件与子组件传值"></a>父组件与子组件传值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//父组件通过标签上面定义传值</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;Main :obj=&quot;data&quot;&gt;&lt;/Main&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    //引入子组件</span><br><span class="line">    import Main form &quot;./main&quot;</span><br><span class="line">    </span><br><span class="line">    exprot default&#123;</span><br><span class="line">        name:&quot;parent&quot;,</span><br><span class="line">        data()&#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                data:&quot;我要向子组件传递数据&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        //初始化组件</span><br><span class="line">        components:&#123;</span><br><span class="line">            Main</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">//子组件通过props方法接受数据</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;data&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    exprot default&#123;</span><br><span class="line">        name:&quot;son&quot;,</span><br><span class="line">        //接受父组件传值</span><br><span class="line">        props:[&quot;data&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="子组件向父组件传递数据"><a href="#子组件向父组件传递数据" class="headerlink" title="子组件向父组件传递数据"></a>子组件向父组件传递数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//子组件通过$emit方法传递参数</span><br><span class="line">&lt;template&gt;</span><br><span class="line">   &lt;div v-on:click=&quot;events&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    //引入子组件</span><br><span class="line">    import Main form &quot;./main&quot;</span><br><span class="line">    </span><br><span class="line">    exprot default&#123;</span><br><span class="line">        methods:&#123;</span><br><span class="line">            events:function()&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;data&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    exprot default&#123;</span><br><span class="line">        name:&quot;son&quot;,</span><br><span class="line">        //接受父组件传值</span><br><span class="line">        props:[&quot;data&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="Vue-的实例生命周期"><a href="#Vue-的实例生命周期" class="headerlink" title="Vue 的实例生命周期"></a>Vue 的实例生命周期</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="../../images/vue001.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>（1） beforeCreate 初始化实例后 数据观测和事件配置之前调用</p><p>（2） created 实例创建完成后调用</p><p>（3） beforeMount 挂载开始前被用</p><p>（4） mounted el 被新建 vm.$el 替换并挂在到实例上之后调用</p><p>（5） beforeUpdate 数据更新时调用</p><p>（6） updated 数据更改导致的 DOM 重新渲染后调用</p><p>（7） beforeDestory 实例被销毁前调用</p><p>（8） destroyed 实例销毁后调用</p><blockquote><p>答：总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后</p></blockquote><ul><li>创建前/后： 在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el还没有</li><li>载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。</li><li>更新前/后：当data变化时，会触发beforeUpdate和updated方法</li><li>销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在</li></ul><h3 id="vue-双向数据绑定原理？"><a href="#vue-双向数据绑定原理？" class="headerlink" title="vue 双向数据绑定原理？"></a>vue 双向数据绑定原理？</h3><p>vue 通过使用双向数据绑定，来实现了 View 和 Model 的同步更新。vue 的双向数据绑定主要是通过<strong>使用数据劫持和发布订阅者模式来实现的</strong>。</p><p>首先我们通过 Object.defineProperty() 方法来对 Model 数据各个属性添加访问器属性，以此来实现数据的劫持，因此当 Model 中的数据发生变化的时候，我们可以通过配置的 <strong>setter 和 getter 方法来实现对 View 层数据更新的通知</strong>。Vue3.0 将用原生 Proxy 替换 Object.defineProperty</p><p>数据在 html 模板中一共有两种绑定情况，一种是使用 v-model 来对 value 值进行绑定，一种是作为文本绑定，在对模板引擎进行解析的过程中。</p><p>如果遇到元素节点，并且属性值包含 v-model 的话，我们就从 Model 中去获取 v-model 所对应的属性的值，并赋值给元素的 value 值。然后给这个元素设置一个监听事件，当 View 中元素的数据发生变化的时候触发该事件，通知 Model 中的对应的属性的值进行更新。</p><p>如果遇到了绑定的文本节点，我们使用 Model 中对应的属性的值来替换这个文本。对于文本节点的更新，我们使用了发布订阅者模式，属性作为一个主题，我们为这个节点设置一个订阅者对象，将这个订阅者对象加入这个属性主题的订阅者列表中。当 Model 层数据发生改变的时候，Model 作为发布者向主题发出通知，主题收到通知再向它的所有订阅者推送，订阅者收到通知后更改自己的数<br>据。</p><p>详细资料可以参考：<br><a href="http://www.cnblogs.com/kidney/p/6052935.html?utm_source=gold_browser_extension" target="_blank" rel="noopener">《Vue.js 双向绑定的实现原理》</a></p><h3 id="Object-defineProperty-介绍？"><a href="#Object-defineProperty-介绍？" class="headerlink" title="Object.defineProperty 介绍？"></a>Object.defineProperty 介绍？</h3><p>Object.defineProperty 函数一共有三个参数，第一个参数是需要定义属性的对象，第二个参数是需要定义的属性，第三个是该属性描述符。</p><p>一个属性的描述符有四个属性，分别是 value 属性的值，writable 属性是否可写，enumerable 属性是否可枚举，configurable 属性是否可配置修改。</p><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">《Object.defineProperty()》</a></p><h3 id="使用Object-defineProperty-来进行数据劫持有什么缺点？"><a href="#使用Object-defineProperty-来进行数据劫持有什么缺点？" class="headerlink" title="使用Object.defineProperty() 来进行数据劫持有什么缺点？"></a>使用Object.defineProperty() 来进行数据劫持有什么缺点？</h3><p>Object.defineProperty 无法监控到数组下标的变化，有一些对属性的操作，使用这种方法无法拦截，比如说<strong>通过下标方式修改数组数据</strong>或者<strong>给对象新增属性</strong>，不能实时响应，vue 内部通过重写函数解决了这个问题。Object.defineProperty 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。</p><p>在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用 Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为这是 ES6 的语法。</p><h3 id="什么是-Proxy？"><a href="#什么是-Proxy？" class="headerlink" title="什么是 Proxy？"></a>什么是 Proxy？</h3><p>Proxy 是 ES6 中新增的一个特性，翻译过来意思是”代理”，用在这里表示<strong>由它来“代理”某些操作</strong>，可以译为“代理器”。 Proxy 让我们能够以简洁易懂的方式控制外部对对象的访问。其功能非常类似于设计模式中的代理模式。</p><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”，即对编程语言进行编程。</p><p>使用 Proxy 的核心优点是可以交由它来处理一些非核心逻辑（如：读取或设置对象的某些属性前记录日志；设置对象的某些属性值前，需要验证；某些属性的访问控制等）。 从而可以让对象只需关注于核心逻辑，达到关注点分离，降低对象复杂度等目的。</p><h3 id="Vue组件通信有哪些方式"><a href="#Vue组件通信有哪些方式" class="headerlink" title="Vue组件通信有哪些方式"></a>Vue组件通信有哪些方式</h3><p>1.父传子：props<br>父组件通过 props 向下传递数据给子组件。注：组件中的数据共有三种形式：data、props、computed</p><p>2.父传子孙：provide 和 inject<br>父组件定义provide方法return需要分享给子孙组件的属性，子孙组件使用 inject 选项来接收指定的我们想要添加在这个实例上的 属性；</p><p>3.子传父：通过事件形式<br>子组件通过 $emit()给父组件发送消息，父组件通过v-on绑定事件接收数据。</p><p>4.父子、兄弟、跨级：eventBus.js<br>这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心）,用它来（e m i t ） 触 发 事 件 和 （ emit）触发事件和（emit）触发事件和（on）监听事件，巧妙而轻量地实现了任何组件间的通信。</p><p>5.通信插件：PubSub.js</p><p>6.vuex<br>vuex 是 vue 的状态管理器，存储的数据是响应式的。只需要把共享的值放到vuex中，其他需要的组件直接获取使用即可；</p><h3 id="router和route的区别"><a href="#router和route的区别" class="headerlink" title="router和route的区别"></a>router和route的区别</h3><p>router为VueRouter的实例，是路由实例对象，相当于一个全局的路由器对象，包括了路由的跳转方法，钩子函数等，里面含有很多属性和子对象，例如history对象。经常用的跳转链接就可以用this.$router.push和router-link跳转一样。</p><p>route是当前正在跳转的路由信息对象。包括path，params，hash，query，fullPath，matched，name 等路由信息参数，可以从里面获取name,path,params,query等。</p><h3 id="nextTick的理解"><a href="#nextTick的理解" class="headerlink" title="$nextTick的理解"></a>$nextTick的理解</h3><p>用法：<br>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。<br>为什么？<br>Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。<br>所以为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数将在 DOM 更新完成后被调用。<br>使用场景：<br>在你更新完数据后，需要及时操作渲染好的 DOM时</p><h3 id="Vue中常用的一些指令"><a href="#Vue中常用的一些指令" class="headerlink" title="Vue中常用的一些指令"></a>Vue中常用的一些指令</h3><p>1.v-model指令：用于表单输入，实现表单控件和数据的双向绑定。<br>2.v-on：简写为@，基础事件绑定<br>3.v-bind：简写为：，动态绑定一些元素的属性，类型可以是：字符串、对象或数组。<br>4.v-if指令：取值为true/false，控制元素是否需要被渲染<br>5.v-else指令：和v-if指令搭配使用，没有对应的值。当v-if的值false，v-else才会被渲染出来。<br>6.v-show指令：指令的取值为true/false，分别对应着显示/隐藏。<br>7.v-for指令：遍历data中存放的数组数据，实现列表的渲染。<br>8.v-once： 通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新</p><h3 id="vue的自定义指令"><a href="#vue的自定义指令" class="headerlink" title="vue的自定义指令"></a>vue的自定义指令</h3><p>Vue除了核心功能默认内置的指令 ，Vue 也允许注册自定义指令。<br>自定义指令是用来操作DOM的。尽管Vue推崇数据驱动视图的理念，但并非所有情况都适合数据驱动。自定义指令就是一种有效的补充和扩展，不仅可用于定义任何的DOM操作，并且是可复用的。</p><p>添加自定义指令的两种方式：</p><p>全局指令： 通过 Vue.directive() 函数注册一个全局的指令。<br>局部指令：通过组件的 directives 属性，对该组件添加一个局部的指令。<br>可以参考<a href="https://blog.csdn.net/qq_44182284/article/details/111309028" target="_blank" rel="noopener">如何写一个Vue自定义指令</a>或<a href="https://cn.vuejs.org/v2/guide/custom-directive.html" target="_blank" rel="noopener">Vue.js官网关于自定义指令的详细讲解</a>学习</p><h3 id="你有写过自定义指令吗？自定义指令的应用场景有哪些？"><a href="#你有写过自定义指令吗？自定义指令的应用场景有哪些？" class="headerlink" title="你有写过自定义指令吗？自定义指令的应用场景有哪些？"></a>你有写过自定义指令吗？自定义指令的应用场景有哪些？</h3><p>可以参考<a href="https://blog.csdn.net/qq_44182284/article/details/111309028" target="_blank" rel="noopener">如何写一个Vue自定义指令</a></p><h3 id="16-如何编写一个自定义指令"><a href="#16-如何编写一个自定义指令" class="headerlink" title="16.如何编写一个自定义指令"></a>16.如何编写一个自定义指令</h3><p>指令是个函数或者对象，用来操作dom，指令内部的this指向window；</p><p>a:全局指令 Vue.directive（指令名称不带v-,回调（el,bingding））</p><p>el:dom元素；binding是个对象，含有传入的参数，binding。value</p><p>b:局部 定义在选项里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">directives:&#123;</span><br><span class="line">指令名不带v-: 函数(el,binding)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="v-show和v-if指令的共同点和不同点"><a href="#v-show和v-if指令的共同点和不同点" class="headerlink" title="v-show和v-if指令的共同点和不同点"></a>v-show和v-if指令的共同点和不同点</h3><p>相同点：<br>v-show和v-if都能控制元素的显示和隐藏。<br>不同点：<br>1.实现本质方法不同:v-show本质就是通过设置css中的display设置为none;控制隐藏v-if是动态的向DOM树内添加或者删除DOM元素;<br>2.v-show都会编译，初始值为false，只是将display设为none，但它也编译了;v-if初始值为false，就不会编译了<br>总结：v-show只编译一次，后面其实就是控制css，而v-if不停的销毁和创建，如果要频繁切换某节点时，故v-show性能更好一点。</p><h3 id="为什么避免v-if和v-for一起使用"><a href="#为什么避免v-if和v-for一起使用" class="headerlink" title="为什么避免v-if和v-for一起使用"></a>为什么避免v-if和v-for一起使用</h3><p>vue2.x版本中，当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级；<br>vue3.x版本中，当 v-if 与 v-for 一起使用时，v-if 具有比 v-for 更高的优先级。<br>官网明确指出：避免 v-if 和 v-for 一起使用，永远不要在一个元素上同时使用 v-if 和 v-for。</p><p>可以先对数据在计算数据中进行过滤，然后再进行遍历渲染；</p><p>操作和实现起来都没有什么问题，页面也会正常展示。但是会带来不必要的性能消耗；</p><h3 id="为什么避免-v-if-和-v-for-用在一起"><a href="#为什么避免-v-if-和-v-for-用在一起" class="headerlink" title="为什么避免 v-if 和 v-for 用在一起"></a>为什么避免 v-if 和 v-for 用在一起</h3><p>当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级，这意味着 v-if 将分别重复运行于每个 v-for 循环中。通过 v-if 移动到容器元素，不会再重复遍历列表中的每个值。取而代之的是，我们只检查它一次，且不会在 v-if 为否的时候运算 v-for。</p><h3 id="请问-v-if-和-v-show-有什么区别"><a href="#请问-v-if-和-v-show-有什么区别" class="headerlink" title="请问 v-if 和 v-show 有什么区别"></a>请问 v-if 和 v-show 有什么区别</h3><p>v-if 指令是直接销毁和重建 DOM 达到让元素显示和隐藏的效果，适用于在运行时很少改变条件，不需要频繁切换条件的场景</p><p>v-show 指令是通过修改元素的 display 的 CSS 属性让其显示或者隐藏，适用于需要非常频繁切换条件的场景</p><h3 id="vue中-key-值的作用"><a href="#vue中-key-值的作用" class="headerlink" title="vue中 key 值的作用"></a>vue中 key 值的作用</h3><p>需要使用 key 来给每个节点做一个唯一标识，Diff 算法就可以正确的识别此节点，找到正确的位置区插入新的节点<br>所以一句话，key 的作用主要是为了高效的更新虚拟 DOM</p><h3 id="computed-和-watch-区别？"><a href="#computed-和-watch-区别？" class="headerlink" title="computed 和 watch 区别？"></a>computed 和 watch 区别？</h3><p>computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。</p><p>watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。</p><h3 id="keep-alive-组件有什么作用？"><a href="#keep-alive-组件有什么作用？" class="headerlink" title="keep-alive 组件有什么作用？"></a>keep-alive 组件有什么作用？</h3><p>如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。</p><h3 id="路由之间跳转？"><a href="#路由之间跳转？" class="headerlink" title="路由之间跳转？"></a>路由之间跳转？</h3><h4 id="声明式（标签跳转）"><a href="#声明式（标签跳转）" class="headerlink" title="声明式（标签跳转）"></a>声明式（标签跳转）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=&quot;index&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="编程式（-js跳转）"><a href="#编程式（-js跳转）" class="headerlink" title="编程式（ js跳转）"></a>编程式（ js跳转）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.push(&apos;index&apos;)</span><br></pre></td></tr></table></figure><h3 id="vue-中的性能优化"><a href="#vue-中的性能优化" class="headerlink" title="vue 中的性能优化"></a>vue 中的性能优化</h3><p>编码阶段</p><ul><li>尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher</li><li>v-if和v-for不能连用</li><li>如果需要使用v-for给每项元素绑定事件时使用事件代理</li><li>在更多的情况下，使用v-if替代v-show</li><li>key保证唯一</li><li>SPA 页面采用keep-alive缓存组件</li><li>使用路由（组件）懒加载、异步组件</li><li>防抖、节流</li><li>第三方模块按需导入</li><li>长列表滚动到可视区域动态加载</li><li>图片懒加载（LazyLoad Images）</li><li>引入生产环境的 Vue 文件</li><li>使用单文件组件预编译模板</li><li>减少 http 请求，合理设置 HTTP 缓存</li><li>CSS Sprites</li><li>提取组件的 CSS 到单独到文件</li><li>CSS 放在页面最上部，javascript 放在页面最下面</li><li>尽量避免使用 eval 和 Function</li><li>利用 Object.freeze()提升性能</li><li>扁平化 Store 数据结构</li><li>合理使用持久化 Store 数据</li></ul><p>SEO优化</p><ul><li>服务端渲染SSR</li><li>预渲染</li></ul><p>打包优化</p><ul><li>压缩代码</li><li>服务端开启 gzip 压缩</li><li>Tree Shaking/Scope Hoisting</li><li>使用cdn加载第三方模块</li><li>多线程打包happypack</li><li>splitChunks抽离公共文件</li><li>sourceMap优化</li></ul><p>用户体验</p><ul><li><p>骨架屏</p></li><li><p>PWA</p></li></ul><p>使用缓存优化</p><ul><li>客户端（浏览器）缓存</li><li>服务端缓存</li></ul><h3 id="什么是-MVVM？比之-MVC-有什么区别？什么又是-MVP-？"><a href="#什么是-MVVM？比之-MVC-有什么区别？什么又是-MVP-？" class="headerlink" title="什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？"></a>什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？</h3><p>MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化我们的开发效率。</p><p>比如说我们实验室在以前项目开发的时候，使用单页应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，当时一旦项目变得复杂，那么整个文件就会变得冗长，混乱，这样对我们的项目开发和后期的项目维护是非常不利的。</p><p>MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。</p><p>MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中我们使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此我们可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。</p><p>MVVM 模式中的 VM，指的是 ViewModel，它和 MVP 的思想其实是相同的，不过它通过双向的数据绑定，将 View 和 Model 的同步更新给自动化了。当 Model 发生变化的时候，ViewModel 就会自动更新；ViewModel 变化了，View 也会更新。这样就将 Presenter 中的工作给自动化了。我了解过一点双向数据绑定的原理，比如 vue 是通过使用数据劫持和发布订阅者模式来实现的这一功能。</p><p>详细资料可以参考：<br><a href="https://juejin.im/post/593021272f301e0058273468" target="_blank" rel="noopener">《浅析前端开发中的 MVC/MVP/MVVM 模式》</a><br><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="noopener">《MVC，MVP 和 MVVM 的图示》</a><br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc72e6e51d45054f664dbf" target="_blank" rel="noopener">《MVVM》</a><br><a href="https://segmentfault.com/a/1190000015310674" target="_blank" rel="noopener">《一篇文章了解架构模式：MVC/MVP/MVVM》</a></p><h3 id="什么是-Virtual-DOM？为什么-Virtual-DOM-比原生-DOM-快？"><a href="#什么是-Virtual-DOM？为什么-Virtual-DOM-比原生-DOM-快？" class="headerlink" title="什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？"></a>什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？</h3><p>我对 Virtual DOM 的理解是，</p><p>首先对我们将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后我们将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。</p><p>当页面的状态发生改变，我们需要对页面的 DOM 的结构进行调整的时候，我们首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。</p><p>最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。</p><p>我认为 Virtual DOM 这种方法对于我们需要有大量的 DOM 操作的时候，能够很好的提高我们的操作效率，通过在操作前确定需要做的最小修改，尽可能的减少 DOM 操作带来的重流和重绘的影响。其实 Virtual DOM 并不一定比我们真实的操作 DOM 要快，这种方法的目的是为了提高我们开发时的可维护性，在任意的情况下，都能保证一个尽量小的性能消耗去进行操作。</p><p>详细资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc72e6e51d45054f664dbf" target="_blank" rel="noopener">《Virtual DOM》</a><br><a href="https://github.com/y8n/blog/issues/5" target="_blank" rel="noopener">《理解 Virtual DOM》</a><br><a href="https://github.com/livoras/blog/issues/13" target="_blank" rel="noopener">《深度剖析：如何实现一个 Virtual DOM 算法》</a><br><a href="https://www.zhihu.com/question/31809713/answer/53544875" target="_blank" rel="noopener">《网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？》</a></p><h3 id="如何比较两个-DOM-树的差异？"><a href="#如何比较两个-DOM-树的差异？" class="headerlink" title="如何比较两个 DOM 树的差异？"></a>如何比较两个 DOM 树的差异？</h3><p>两个树的完全 diff 算法的时间复杂度为 O(n^3) ，但是在前端中，我们很少会跨层级的移动元素，所以我们只需要比较同一层级的元素进行比较，这样就可以将算法的时间复杂度降低为 O(n)。</p><p>算法首先会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个序号。在深度遍历的时候，每遍历到一个节点，我们就将这个节点和新的树中的节点进行比较，如果有差异，则将这个差异记录到一个对象中。</p><p>在对列表元素进行对比的时候，由于 TagName 是重复的，所以我们不能使用这个来对比。我们需要给每一个子节点加上一个 key，列表对比的时候使用 key 来进行比较，这样我们才能够复用老的 DOM 树上的节点。</p><h3 id="组件的设计原则"><a href="#组件的设计原则" class="headerlink" title="组件的设计原则"></a>组件的设计原则</h3><ul><li>页面上每个独立的可视/可交互区域视为一个组件(比如页面的头部，尾部，可复用的区块)</li><li>每个组件对应一个工程目录，组件所需要的各种资源在这个目录下就近维护(组件的就近维护思想体现了前端的工程化思想，为前端开发提供了很好的分治策略，在vue.js中，通过.vue文件将组件依赖的模板，js，样式写在一个文件中)<br>(每个开发者清楚开发维护的功能单元，它的代码必然存在在对应的组件目录中，在该目录下，可以找到功能单元所有的内部逻辑)</li><li>页面不过是组件的容器，组件可以嵌套自由组合成完整的页面</li></ul><h3 id="对于-Vue-是一套渐进式框架的理解"><a href="#对于-Vue-是一套渐进式框架的理解" class="headerlink" title="对于 Vue 是一套渐进式框架的理解"></a>对于 Vue 是一套渐进式框架的理解</h3><p>每个框架都不可避免会有自己的一些特点，从而会对使用者有一定的要求，这些要求就是主张，主张有强有弱，它的强势程度会影响在业务开发中的使用方式。</p><p>1、使用 vue，你可以在原有大系统的上面，把一两个组件改用它实现，当 jQuery 用；</p><p>2、也可以整个用它全家桶开发，当 Angular 用；</p><p>3、还可以用它的视图，搭配你自己设计的整个下层用。你可以在底层数据逻辑的地方用 OO(Object–Oriented )面向对象和设计模式的那套理念。<br>也可以函数式，都可以。</p><p>它只是个轻量视图而已，只做了自己该做的事，没有做不该做的事，仅此而已。</p><p>你不必一开始就用 Vue 所有的全家桶，根据场景，官方提供了方便的框架供你使用。</p><p>场景联想<br>场景 1：<br>维护一个老项目管理后台，日常就是提交各种表单了，这时候你可以把 vue 当成一个 js 库来使用，就用来收集 form 表单，和表单验证。</p><p>场景 2：<br>得到 boss 认可， 后面整个页面的 dom 用 Vue 来管理，抽组件，列表用 v-for 来循环，用数据驱动 DOM 的变化</p><p>场景 3:<br>越来越受大家信赖，领导又找你了，让你去做一个移动端 webapp，直接上了 vue 全家桶！</p><p>场景 1-3 从最初的只因多看你一眼而用了前端 js 库，一直到最后的大型项目解决方案。</p><h3 id="vue-常用的修饰符"><a href="#vue-常用的修饰符" class="headerlink" title="vue 常用的修饰符"></a>vue 常用的修饰符</h3><p><a href="https://blog.csdn.net/qq_42238554/article/details/86592295" target="_blank" rel="noopener">参考</a></p><h3 id="v-on-可以监听多个方法吗？"><a href="#v-on-可以监听多个方法吗？" class="headerlink" title="v-on 可以监听多个方法吗？"></a>v-on 可以监听多个方法吗？</h3><p>肯定可以的。</p><p>解析：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">"text"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:value</span>=<span class="string">"name"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">input</span>=<span class="string">"onInput"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">focus</span>=<span class="string">"onFocus"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">blur</span>=<span class="string">"onBlur"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="vue-cli-工程升级-vue-版本"><a href="#vue-cli-工程升级-vue-版本" class="headerlink" title="vue-cli 工程升级 vue 版本"></a>vue-cli 工程升级 vue 版本</h3><p>在项目目录里运行 npm upgrade vue vue-template-compiler，不出意外的话，可以正常运行和 build。如果有任何问题，删除 node_modules 文件夹然后重新运行 npm i 即可。（简单的说就是升级 vue 和 vue-template-compiler 两个插件）</p><h3 id="vue-事件中如何使用-event-对象？"><a href="#vue-事件中如何使用-event-对象？" class="headerlink" title="vue 事件中如何使用 event 对象？"></a>vue 事件中如何使用 event 对象？</h3><p>v-on 指令（可以简写为 @）</p><p>1、使用不带圆括号的形式，event 对象将被自动当做实参传入；</p><p>2、使用带圆括号的形式，我们需要使用 $event 变量显式传入 event 对象。</p><p>解析：</p><p>一、event 对象</p><p>（一）事件的 event 对象</p><p>你说你是搞前端的，那么你肯定就知道事件，知道事件，你就肯定知道 event 对象吧？各种的库、框架多少都有针对 event 对象的处理。比如 jquery，通过它内部进行一定的封装，我们开发的时候，就无需关注 event 对象的部分兼容性问题。最典型的，如果我们要阻止默认事件，在 chrome 等浏览器中，我们可能要写一个：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.preventDefault();</span><br></pre></td></tr></table></figure><p>而在 IE 中，我们则需要写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.returnValue = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>多亏了 jquery ，跨浏览器的实现，我们统一只需要写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.preventDefault();</span><br></pre></td></tr></table></figure><p>兼容？jquery 内部帮我们搞定了。类似的还有比如阻止事件冒泡以以及事件绑定（addEventListener / attachEvent）等，简单到很多的后端都会使用 $(‘xxx’).bind(…)，这不是我们今天的重点，我们往下看。</p><p>（二）vue 中的 event 对象</p><p>我们知道，相比于 jquery，vue 的事件绑定可以显得更加直观和便捷，我们只需要在模板上添加一个 v-on 指令（还可以简写为 @），即可完成类似于 $(‘xxx’).bind 的效果，少了一个利用选择器查询元素的操作。我们知道，jquery 中，event 对象会被默认当做实参传入到处理函数中，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"body"</span>).bind(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> event); <span class="comment">// object</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里直接就获取到了 event 对象，那么问题来了，vue 中呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;button v-on:click=<span class="string">"click"</span>&gt;click me&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        click(event) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">typeof</span> event);    <span class="comment">// object</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里的实现方式看起来和 jquery 是一致的啊，但是实际上，vue 比 jquery 要要复杂得多，jquery 官方也明确的说，v-on 不简单是 addEventListener 的语法糖。在 jquery 中，我们传入到 bind 方法中的回调，只能是一个函数表类型的变量或者一个匿名函数，传递的时候，还不能执行它（在后面加上一堆圆括号），否则就变成了取这一个函数的返回值作为事件回调。而我们知道，vue 的 v-on 指令接受的值可以是函数执行的形式，比如 v-on:click=”click(233)” 。这里我们可以传递任何需要传递的参数，甚至可以不传递参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;button v-on:click=<span class="string">"click()"</span>&gt;click me&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        click(event) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">typeof</span> event);    <span class="comment">// undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>咦？我的 event 对象呢？怎么不见了？打印看看 arguments.length 也是 0，说明这时候确实没有实参被传入进来。T_T，那我们如果既需要传递参数，又需要用到 event 对象，这个该怎么办呢？</p><p>（三）$event</p><p>翻看 vue 文档，不难发现，其实我们可以通过将一个特殊变量 $event 传入到回调中解决这个问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;button v-on:click=<span class="string">"click($event, 233)"</span>&gt;click me&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        click(event, val) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">typeof</span> event);    <span class="comment">// object</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>好吧，这样看起来就正常了。<br>简单总结来说：</p><p>使用不带圆括号的形式，event 对象将被自动当做实参传入；</p><p>使用带圆括号的形式，我们需要使用 $event 变量显式传入 event 对象。</p><h3 id="nextTick-的使用"><a href="#nextTick-的使用" class="headerlink" title="$nextTick 的使用"></a>$nextTick 的使用</h3><h4 id="1、什么是-Vue-nextTick-？"><a href="#1、什么是-Vue-nextTick-？" class="headerlink" title="1、什么是 Vue.nextTick()？"></a>1、什么是 Vue.nextTick()？</h4><p>定义：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p><p>所以就衍生出了这个获取更新后的 DOM 的 Vue 方法。所以放在 Vue.nextTick()回调函数中的执行的应该是会对 DOM 进行操作的 js 代码；</p><p>理解：nextTick()，是将回调函数延迟在下一次 dom 更新数据后调用，简单的理解是：当数据更新了，在 dom 中渲染后，自动执行该函数，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"hello"</span>&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button id=<span class="string">"firstBtn"</span> @click=<span class="string">"testClick()"</span> ref=<span class="string">"aa"</span>&gt;&#123;&#123;testMsg&#125;&#125;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'HelloWorld'</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      testMsg:<span class="string">"原始值"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    testClick:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> that=<span class="keyword">this</span>;</span><br><span class="line">      that.testMsg=<span class="string">"修改后的值"</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(that.$refs.aa.innerText);   <span class="comment">//that.$refs.aa获取指定DOM，输出：原始值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>使用 this.$nextTick()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    testClick:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> that=<span class="keyword">this</span>;</span><br><span class="line">      that.testMsg=<span class="string">"修改后的值"</span>;</span><br><span class="line">      that.$nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(that.$refs.aa.innerText);  <span class="comment">//输出：修改后的值</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>注意：Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM，</p><h4 id="2、什么时候需要用的-Vue-nextTick-？"><a href="#2、什么时候需要用的-Vue-nextTick-？" class="headerlink" title="2、什么时候需要用的 Vue.nextTick()？"></a>2、什么时候需要用的 Vue.nextTick()？</h4><p>1、Vue 生命周期的 created()钩子函数进行的 DOM 操作一定要放在 Vue.nextTick()的回调函数中，原因是在 created()钩子函数执行的时候 DOM 其实并未进行任何渲染，而此时进行 DOM 操作无异于徒劳，所以此处一定要将 DOM 操作的 js 代码放进 Vue.nextTick()的回调函数中。与之对应的就是 mounted 钩子函数，因为该钩子函数执行时所有的 DOM 挂载已完成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">created()&#123;</span><br><span class="line">    <span class="keyword">let</span> that=<span class="keyword">this</span>;</span><br><span class="line">    that.$nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">//不使用this.$nextTick()方法会报错</span></span><br><span class="line">        that.$refs.aa.innerHTML=<span class="string">"created中更改了按钮内容"</span>;  <span class="comment">//写入到DOM元素</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、当项目中你想在改变 DOM 元素的数据后基于新的 dom 做点什么，对新 DOM 一系列的 js 操作都需要放进 Vue.nextTick()的回调函数中；通俗的理解是：更改数据后当你想立即使用 js 操作新的视图的时候需要使用它</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"hello"</span>&gt;</span><br><span class="line">    &lt;h3 id=<span class="string">"h"</span>&gt;&#123;&#123;testMsg&#125;&#125;&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  name: 'HelloWorld',</span></span><br><span class="line"><span class="regexp">  data () &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      testMsg:"原始值",</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  methods:&#123;</span></span><br><span class="line"><span class="regexp">    changeTxt:function()&#123;</span></span><br><span class="line"><span class="regexp">      let that=this;</span></span><br><span class="line"><span class="regexp">      that.testMsg="修改后的文本值";  /</span><span class="regexp">/vue数据改变，改变dom结构</span></span><br><span class="line"><span class="regexp">      let domTxt=document.getElementById('h').innerText;  /</span><span class="regexp">/后续js对dom的操作</span></span><br><span class="line"><span class="regexp">      console.log(domTxt);  /</span><span class="regexp">/输出可以看到vue数据修改后DOM并没有立即更新，后续的dom都不是最新的</span></span><br><span class="line"><span class="regexp">      if(domTxt==="原始值")&#123;</span></span><br><span class="line"><span class="regexp">        console.log("文本data被修改后dom内容没立即更新");</span></span><br><span class="line"><span class="regexp">      &#125;else &#123;</span></span><br><span class="line"><span class="regexp">        console.log("文本data被修改后dom内容被马上更新了");</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>正确的用法是：vue 改变 dom 元素结构后使用 vue.$nextTick()方法来实现 dom 数据更新后延迟执行后续代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">changeTxt:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> that=<span class="keyword">this</span>;</span><br><span class="line">  that.testMsg=<span class="string">"修改后的文本值"</span>;  <span class="comment">//修改dom结构</span></span><br><span class="line"></span><br><span class="line">  that.$nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">//使用vue.$nextTick()方法可以dom数据更新后延迟执行</span></span><br><span class="line">    <span class="keyword">let</span> domTxt=<span class="built_in">document</span>.getElementById(<span class="string">'h'</span>).innerText;</span><br><span class="line">    <span class="built_in">console</span>.log(domTxt);  <span class="comment">//输出可以看到vue数据修改后并没有DOM没有立即更新，</span></span><br><span class="line">    <span class="keyword">if</span>(domTxt===<span class="string">"原始值"</span>)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"文本data被修改后dom内容没立即更新"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"文本data被修改后dom内容被马上更新了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、在使用某个第三方插件时 ，希望在 vue 生成的某些 dom 动态发生变化时重新应用该插件，也会用到该方法，这时候就需要在 $nextTick 的回调函数中执行重新应用插件的方法。</p><p>Vue.nextTick(callback) 使用原理：</p><p>原因是，Vue 是异步执行 dom 更新的，一旦观察到数据变化，Vue 就会开启一个队列，然后把在同一个事件循环 (event loop) 当中观察到数据变化的 watcher 推送进这个队列。如果这个 watcher 被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和 DOm 操作。而在下一个事件循环时，Vue 会清空队列，并进行必要的 DOM 更新。<br>当你设置 vm.someData = ‘new value’，DOM 并不会马上更新，而是在异步队列被清除，也就是下一个事件循环开始时执行更新时才会进行必要的 DOM 更新。如果此时你想要根据更新的 DOM 状态去做某些事情，就会出现问题。。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。</p><h3 id="Vue-组件中-data-为什么必须是函数"><a href="#Vue-组件中-data-为什么必须是函数" class="headerlink" title="Vue 组件中 data 为什么必须是函数"></a>Vue 组件中 data 为什么必须是函数</h3><p>在 new Vue() 中，data 是可以作为一个对象进行操作的，然而在 component 中，data 只能以函数的形式存在，不能直接将对象赋值给它，这并非是 Vue 自身如此设计，而是跟 JavaScript 特性相关，我们来回顾下 JavaScript 的原型链</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Component = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Component.prototype.data = &#123;</span><br><span class="line">  message: <span class="string">"Love"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> component1 = <span class="keyword">new</span> Component(),</span><br><span class="line">component2 = <span class="keyword">new</span> Component();</span><br><span class="line">component1.data.message = <span class="string">"Peace"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(component2.data.message); <span class="comment">// Peace</span></span><br></pre></td></tr></table></figure><p>以上<strong>两个实例都引用同一个对象，当其中一个实例属性改变时，另一个实例属性也随之改变，只有当两个实例拥有自己的作用域时，才不会互相干扰</strong> ！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Component = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.data = <span class="keyword">this</span>.data();</span><br><span class="line">&#125;;</span><br><span class="line">Component.prototype.data = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    message: <span class="string">"Love"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> component1 = <span class="keyword">new</span> Component(),</span><br><span class="line"> component2 = <span class="keyword">new</span> Component();</span><br><span class="line">component1.data.message = <span class="string">"Peace"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(component2.data.message); <span class="comment">// Love</span></span><br></pre></td></tr></table></figure><h3 id="vue-中子组件调用父组件的方法"><a href="#vue-中子组件调用父组件的方法" class="headerlink" title="vue 中子组件调用父组件的方法"></a>vue 中子组件调用父组件的方法</h3><ul><li>第一种方法是直接在子组件中通过 this.$parent.event 来调用父组件的方法</li><li>第二种方法是在子组件里用$emit 向父组件触发一个事件，父组件监听这个事件就行了</li><li>第三种是父组件把方法传入子组件中，在子组件里直接调用这个方法</li></ul><p>解析：</p><p>第一种方法是直接在子组件中通过 this.$parent.event 来调用父组件的方法</p><p>父组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;child&gt;<span class="xml"><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">'~/components/dam/child'</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">      child</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      fatherMethod() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'测试'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>子组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"childMethod()"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    methods: &#123;</span><br><span class="line">      childMethod() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.$parent.fatherMethod();</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二种方法是在子组件里用$emit 向父组件触发一个事件，父组件监听这个事件就行了</p><p>父组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span> @<span class="attr">fatherMethod</span>=<span class="string">"fatherMethod"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">"~/components/dam/child"</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    components: &#123;</span><br><span class="line">      child</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      fatherMethod() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"测试"</span>);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"childMethod()"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    methods: &#123;</span><br><span class="line">      childMethod() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.$emit(<span class="string">"fatherMethod"</span>);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第三种是父组件把方法传入子组件中，在子组件里直接调用这个方法</p><p>父组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">:fatherMethod</span>=<span class="string">"fatherMethod"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">"~/components/dam/child"</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    components: &#123;</span><br><span class="line">      child</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      fatherMethod() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"测试"</span>);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"childMethod()"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    props: &#123;</span><br><span class="line">      fatherMethod: &#123;</span><br><span class="line"><span class="javascript">        type: <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">default</span>: <span class="literal">null</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      childMethod() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">if</span> (<span class="keyword">this</span>.fatherMethod) &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.fatherMethod();</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="vue-中父组件调用子组件的方法"><a href="#vue-中父组件调用子组件的方法" class="headerlink" title="vue 中父组件调用子组件的方法"></a>vue 中父组件调用子组件的方法</h3><p>答案：使用$refs</p><p>父组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"clickParent"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">ref</span>=<span class="string">"mychild"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">"./child"</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">    name: <span class="string">"parent"</span>,</span></span><br><span class="line">    components: &#123;</span><br><span class="line">      child: Child</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      clickParent() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.$refs.mychild.parentHandleclick(<span class="string">"嘿嘿嘿"</span>); <span class="comment">// 划重点！！！！</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    child</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">    name: <span class="string">"child"</span>,</span></span><br><span class="line"><span class="actionscript">    props: <span class="string">"someprops"</span>,</span></span><br><span class="line">    methods: &#123;</span><br><span class="line">      parentHandleclick(e) &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(e);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="vue-中-keep-alive-组件的作用"><a href="#vue-中-keep-alive-组件的作用" class="headerlink" title="vue 中 keep-alive 组件的作用"></a>vue 中 keep-alive 组件的作用</h3><p>答案：keep-alive 是 Vue 内置的一个组件，<strong>可以使被包含的组件保留状态，或避免重新渲染。</strong></p><p>解析：</p><p>用法也很简单：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 该组件将被缓存！ --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><p>props<br>_ include - 字符串或正则表达，只有匹配的组件会被缓存<br>_ exclude - 字符串或正则表达式，任何匹配的组件都不会被缓存</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件 a</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">"a"</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">"a"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- name 为 a 的组件将被缓存！ --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">component</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">可以保留它的状态或避免重新渲染</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">exclude</span>=<span class="string">"a"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 除了 name 为 a 的组件都将被缓存！ --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">component</span>&gt;</span> <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">可以保留它的状态或避免重新渲染</span><br></pre></td></tr></table></figure><p>但实际项目中,需要配合 vue-router 共同使用.</p><p>router-view 也是一个组件，如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 所有路径匹配到的视图组件都会被缓存！ --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果只想 router-view 里面某个组件被缓存，怎么办？</p><p>增加 router.meta 属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// routes 配置</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">"/"</span>,</span><br><span class="line">    name: <span class="string">"home"</span>,</span><br><span class="line">    component: Home,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      keepAlive: <span class="literal">true</span> <span class="comment">// 需要被缓存</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">"/:id"</span>,</span><br><span class="line">    name: <span class="string">"edit"</span>,</span><br><span class="line">    component: Edit,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      keepAlive: <span class="literal">false</span> <span class="comment">// 不需要被缓存</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">    &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;</span><br><span class="line">        &lt;!-- 这里是会被缓存的视图组件，比如 Home！ --&gt;</span><br><span class="line">    &lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;</span><br><span class="line">    &lt;!-- 这里是不被缓存的视图组件，比如 Edit！ --&gt;</span><br><span class="line">&lt;/router-view&gt;</span><br></pre></td></tr></table></figure><h3 id="vue-中如何编写可复用的组件？"><a href="#vue-中如何编写可复用的组件？" class="headerlink" title="vue 中如何编写可复用的组件？"></a>vue 中如何编写可复用的组件？</h3><p>总结组件的职能，什么需要外部控制（即 props 传啥），组件需要控制外部吗（$emit）,是否需要插槽（slot）</p><h3 id="什么是-vue-生命周期和生命周期钩子函数？"><a href="#什么是-vue-生命周期和生命周期钩子函数？" class="headerlink" title="什么是 vue 生命周期和生命周期钩子函数？"></a>什么是 vue 生命周期和生命周期钩子函数？</h3><p>vue 的生命周期就是 vue 实例从创建到销毁的过程</p><p>解析：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="../../images/vue002.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="vue-生命周期钩子函数有哪些？"><a href="#vue-生命周期钩子函数有哪些？" class="headerlink" title="vue 生命周期钩子函数有哪些？"></a>vue 生命周期钩子函数有哪些？</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="../../images/vue003.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="vue-如何监听键盘事件中的按键"><a href="#vue-如何监听键盘事件中的按键" class="headerlink" title="vue 如何监听键盘事件中的按键"></a>vue 如何监听键盘事件中的按键</h3><p><a href="https://blog.csdn.net/xiaxiangyun/article/details/80404768" target="_blank" rel="noopener">参考</a></p><h3 id="什么是-vue-的计算属性？"><a href="#什么是-vue-的计算属性？" class="headerlink" title="什么是 vue 的计算属性？"></a>什么是 vue 的计算属性？</h3><p>答案：先来看一下计算属性的定义：<br><strong>当其依赖的属性的值发生变化的时，计算属性会重新计算。反之则使用缓存中的属性值。</strong><br>计算属性和vue中的其它数据一样，都是响应式的，只不过它必须依赖某一个数据实现，并且只有它依赖的数据的值改变了，它才会更新。</p><h3 id="什么是-Virtual-DOM？"><a href="#什么是-Virtual-DOM？" class="headerlink" title="什么是 Virtual DOM？"></a>什么是 Virtual DOM？</h3><p>可以看作是一个使用 javascript 模拟了 DOM 结构的树形结构</p><p><a href="https://www.cnblogs.com/gaosong-shuhong/p/9253959.html" target="_blank" rel="noopener">参考</a></p><h3 id="Vue-中如何实现-proxy-代理？"><a href="#Vue-中如何实现-proxy-代理？" class="headerlink" title="Vue 中如何实现 proxy 代理？"></a>Vue 中如何实现 proxy 代理？</h3><p>webpack 自带的 devServer 中集成了 http-proxy-middleware。配置 devServer 的 proxy 选项即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">proxyTable: &#123;</span><br><span class="line">    <span class="string">'/api'</span>: &#123;</span><br><span class="line">        target: <span class="string">'http://192.168.149.90:8080/'</span>, <span class="comment">// 设置你调用的接口域名和端口号</span></span><br><span class="line">    changeOrigin: <span class="literal">true</span>,   <span class="comment">// 跨域</span></span><br><span class="line">    pathRewrite: &#123;</span><br><span class="line">     <span class="string">'^/api'</span>: <span class="string">'/'</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vue-在什么情况下在数据发生改变的时候不会触发视图更新"><a href="#vue-在什么情况下在数据发生改变的时候不会触发视图更新" class="headerlink" title="vue 在什么情况下在数据发生改变的时候不会触发视图更新"></a>vue 在什么情况下在数据发生改变的时候不会触发视图更新</h3><p>v-for 遍历的数组，当数组内容使用的是 arr[0].xx =xx 更改数据，vue 无法监测到<br>vm.arr.length = newLength 也是无法检测的到的</p><h3 id="vue-的优点是什么？"><a href="#vue-的优点是什么？" class="headerlink" title="vue 的优点是什么？"></a>vue 的优点是什么？</h3><p>低耦合。视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的”View”上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。</p><p>可重用性。你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 view 重用这段视图逻辑。</p><p>独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</p><p>可测试。界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。</p><p>轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 kb ；</p><p>简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；</p><p>双向数据绑定：保留了 angular 的特点，在数据操作方面更为简单；</p><p>组件化：保留了 react 的优点，实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势；</p><p>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</p><p>虚拟DOM：dom 操作是非常耗费性能的， 不再使用原生的 dom 操作节点，极大解放 dom 操作，但具体操作的还是 dom 不过是换了另一种方式；</p><p>运行速度更快：相比较于 react 而言，同样是操作虚拟 dom ，就性能而言， vue 存在很大的优势。</p><h3 id="观察者模式和发布订阅模式有什么不同？"><a href="#观察者模式和发布订阅模式有什么不同？" class="headerlink" title="观察者模式和发布订阅模式有什么不同？"></a>观察者模式和发布订阅模式有什么不同？</h3><p>发布订阅模式其实属于广义上的观察者模式</p><p>在观察者模式中，观察者需要直接订阅目标事件。在目标发出内容改变的事件后，直接接收事件并作出响应。</p><p>而在发布订阅模式中，发布者和订阅者之间多了一个调度中心。调度中心一方面从发布者接收事件，另一方面向订阅者发布事件，订阅者需要在调度中心中订阅事件。通过调度中心实现了发布者和订阅者关系的解耦。使用发布订阅者模式更利于我们代码的可维护性。</p><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/23486749" target="_blank" rel="noopener">《观察者模式和发布订阅模式有什么不同？》</a></p><h3 id="Vue-的生命周期是什么？"><a href="#Vue-的生命周期是什么？" class="headerlink" title="Vue 的生命周期是什么？"></a>Vue 的生命周期是什么？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue 的生命周期指的是组件从创建到销毁的一系列的过程，被称为 Vue 的生命周期。通过提供的 Vue 在生命周期各个阶段的钩子函数，我们可以很好的在 Vue 的各个生命阶段实现一些操作。</span><br></pre></td></tr></table></figure><h3 id="Vue-的各个生命阶段是什么？"><a href="#Vue-的各个生命阶段是什么？" class="headerlink" title="Vue 的各个生命阶段是什么？"></a>Vue 的各个生命阶段是什么？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Vue 一共有8个生命阶段，分别是创建前、创建后、加载前、加载后、更新前、更新后、销毁前和销毁后，每个阶段对应了一个生命周期的钩子函数。</span><br><span class="line"></span><br><span class="line">（1）beforeCreate 钩子函数，在实例初始化之后，在数据监听和事件配置之前触发。因此在这个事件中我们是获取不到 data 数据的。</span><br><span class="line"></span><br><span class="line">（2）created 钩子函数，在实例创建完成后触发，此时可以访问 data、methods 等属性。但这个时候组件还没有被挂载到页面中去，所以这个时候访问不到 $el 属性。一般我们可以在这个函数中进行一些页面初始化的工作，比如通过 ajax 请求数据来对页面进行初始化。</span><br><span class="line"></span><br><span class="line">（3）beforeMount 钩子函数，在组件被挂载到页面之前触发。在 beforeMount 之前，会找到对应的 template，并编译成 render 函数。</span><br><span class="line"></span><br><span class="line">（4）mounted 钩子函数，在组件挂载到页面之后触发。此时可以通过 DOM API 获取到页面中的 DOM 元素。</span><br><span class="line"></span><br><span class="line">（5）beforeUpdate 钩子函数，在响应式数据更新时触发，发生在虚拟 DOM 重新渲染和打补丁之前，这个时候我们可以对可能会被移除的元素做一些操作，比如移除事件监听器。</span><br><span class="line"></span><br><span class="line">（6）updated 钩子函数，虚拟 DOM 重新渲染和打补丁之后调用。</span><br><span class="line"></span><br><span class="line">（7）beforeDestroy 钩子函数，在实例销毁之前调用。一般在这一步我们可以销毁定时器、解绑全局事件等。</span><br><span class="line"></span><br><span class="line">（8）destroyed 钩子函数，在实例销毁之后调用，调用后，Vue 实例中的所有东西都会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</span><br><span class="line"></span><br><span class="line">当我们使用 keep-alive 的时候，还有两个钩子函数，分别是 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/entry/5aee8fbb518825671952308c" target="_blank" rel="noopener">《vue 生命周期深入》</a><br><a href="https://cn.vuejs.org/v2/guide/instance.html" target="_blank" rel="noopener">《Vue 实例》</a></p><h3 id="Vue-组件间的参数传递方式？"><a href="#Vue-组件间的参数传递方式？" class="headerlink" title="Vue 组件间的参数传递方式？"></a>Vue 组件间的参数传递方式？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">（1）父子组件间通信</span><br><span class="line"></span><br><span class="line">第一种方法是子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事</span><br><span class="line">件来向父组件发送数据。</span><br><span class="line"></span><br><span class="line">第二种是通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组</span><br><span class="line">件，这样也可以实现通信。</span><br><span class="line"></span><br><span class="line">第三种是使用 provider/inject，在父组件中通过 provider 提供变量，在子组件中通过 inject 来将变量注入到组件</span><br><span class="line">中。不论子组件有多深，只要调用了 inject 那么就可以注入 provider 中的数据。</span><br><span class="line"></span><br><span class="line">（2）兄弟组件间通信</span><br><span class="line"></span><br><span class="line">第一种是使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实</span><br><span class="line">例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。</span><br><span class="line"></span><br><span class="line">第二种是通过 $parent.$refs 来获取到兄弟组件，也可以进行通信。</span><br><span class="line"></span><br><span class="line">（3）任意组件之间</span><br><span class="line"></span><br><span class="line">使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候</span><br><span class="line">可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个</span><br><span class="line">公共数据进行读写操作，这样达到了解耦的目的。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/entry/5ba215ac5188255c6d0d8345" target="_blank" rel="noopener">《VUE 组件之间数据传递全集》</a></p><h3 id="computed-和-watch-的差异？"><a href="#computed-和-watch-的差异？" class="headerlink" title="computed 和 watch 的差异？"></a>computed 和 watch 的差异？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）computed 是计算一个新的属性，并将该属性挂载到 Vue 实例上，而 watch 是监听已经存在且已挂载到 Vue 实例上的数据，所以用 watch 同样可以监听 computed 计算属性的变化。</span><br><span class="line"></span><br><span class="line">（2）computed 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问 computed 属性，才会计算新的值。而 watch 则是当数据发生变化便会调用执行函数。</span><br><span class="line"></span><br><span class="line">（3）从使用场景上说，computed 适用一个数据被多个数据影响，而 watch 适用一个数据影响多个数据。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b98c4da6fb9a05d353c5fd7" target="_blank" rel="noopener">《做面试的不倒翁：浅谈 Vue 中 computed 实现原理》</a><br><a href="https://juejin.im/post/5af908ea5188254265399009" target="_blank" rel="noopener">《深入理解 Vue 的 watch 实现原理及其实现方式》</a></p><h3 id="vue-router-中的导航钩子函数"><a href="#vue-router-中的导航钩子函数" class="headerlink" title="vue-router 中的导航钩子函数"></a>vue-router 中的导航钩子函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">（1）全局的钩子函数 beforeEach 和 afterEach</span><br><span class="line"></span><br><span class="line">beforeEach 有三个参数，to 代表要进入的路由对象，from 代表离开的路由对象。next 是一个必须要执行的函数，如果不传参数，那就执行下一个钩子函数，如果传入 false，则终止跳转，如果传入一个路径，则导航到对应的路由，如果传入 error ，则导航终止，error 传入错误的监听函数。</span><br><span class="line"></span><br><span class="line">（2）单个路由独享的钩子函数 beforeEnter，它是在路由配置上直接进行定义的。</span><br><span class="line"></span><br><span class="line">（3）组件内的导航钩子主要有这三种：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave。它们是直接在路由组</span><br><span class="line">件内部直接进行定义的。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB" target="_blank" rel="noopener">《导航守卫》</a></p><h3 id="route-和-router-的区别？"><a href="#route-和-router-的区别？" class="headerlink" title="$route 和 $router 的区别？"></a>$route 和 $router 的区别？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数。而 $router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。</span><br></pre></td></tr></table></figure><h3 id="vue-常用的修饰符？"><a href="#vue-常用的修饰符？" class="headerlink" title="vue 常用的修饰符？"></a>vue 常用的修饰符？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.prevent: 提交事件不再重载页面；.stop: 阻止单击事件冒泡；.self: 当事件发生在该元素本身而不是子元素的时候会触发；</span><br></pre></td></tr></table></figure><h3 id="vue-中-key-值的作用？"><a href="#vue-中-key-值的作用？" class="headerlink" title="vue 中 key 值的作用？"></a>vue 中 key 值的作用？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vue 中 key 值的作用可以分为两种情况来考虑。</span><br><span class="line"></span><br><span class="line">第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当我们使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此我们可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。</span><br><span class="line"></span><br><span class="line">第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000016344599" target="_blank" rel="noopener">《Vue 面试中，经常会被问到的面试题 Vue 知识点整理》</a><br><a href="https://www.zhihu.com/question/61064119" target="_blank" rel="noopener">《Vue2.0 v-for 中 :key 到底有什么用？》</a><br><a href="https://www.cnblogs.com/RainyBear/p/8563101.html" target="_blank" rel="noopener">《vue 中 key 的作用》</a></p><h3 id="vue-中-mixin-和-mixins-区别？"><a href="#vue-中-mixin-和-mixins-区别？" class="headerlink" title="vue 中 mixin 和 mixins 区别？"></a>vue 中 mixin 和 mixins 区别？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mixin 用于全局混入，会影响到每个组件实例。</span><br><span class="line"></span><br><span class="line">mixins 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种逻辑等等。另外需要注意的是 mixins 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc731b51882516c56ced6f" target="_blank" rel="noopener">《前端面试之道》</a><br><a href="https://cn.vuejs.org/v2/guide/mixins.html" target="_blank" rel="noopener">《混入》</a></p><h3 id="说说你对SPA单页面的理解，它的优缺点分别是什么？"><a href="#说说你对SPA单页面的理解，它的优缺点分别是什么？" class="headerlink" title="说说你对SPA单页面的理解，它的优缺点分别是什么？"></a>说说你对SPA单页面的理解，它的优缺点分别是什么？</h3><p>是什么</p><ul><li>SPA（ single page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。</li><li>一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转</li><li>而页面的变化是利用路由机制实现 HTML 内容的变换，避免页面的重新加载。</li></ul><p>优点</p><ul><li>用户体验好，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染</li><li>减少了不必要的跳转和重复渲染，这样相对减轻了服务器的压力</li><li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理</li></ul><p>缺点</p><ul><li>初次加载耗时多</li><li>不能使用浏览器的前进后退功能，由于单页应用在一个页面中显示所有的内容，所以，无法前进后退</li><li>不利于搜索引擎检索：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li></ul><h3 id="SPA首屏加载速度慢的怎么解决？"><a href="#SPA首屏加载速度慢的怎么解决？" class="headerlink" title="SPA首屏加载速度慢的怎么解决？"></a>SPA首屏加载速度慢的怎么解决？</h3><p>首屏时间（First Contentful Paint），指的是浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容；</p><p>加载慢的原因</p><ul><li>网络延时问题</li><li>资源文件体积是否过大</li><li>资源是否重复发送请求去加载了</li><li>加载脚本的时候，渲染内容堵塞了</li></ul><p>常见的几种SPA首屏优化方式</p><ul><li>减小入口文件积</li><li>静态资源本地缓存</li><li>UI框架按需加载</li><li>图片资源的压缩</li><li>组件重复打包</li><li>开启GZip压缩</li><li>使用SSR（想要具体了解可以点击<a href="https://blog.csdn.net/weixin_44475093/article/details/110675962" target="_blank" rel="noopener">SPA（单页应用）首屏加载速度慢的解决详解</a>）</li></ul><h3 id="Vue初始化过程中（new-Vue-options-）都做了什么？"><a href="#Vue初始化过程中（new-Vue-options-）都做了什么？" class="headerlink" title="Vue初始化过程中（new Vue(options)）都做了什么？"></a>Vue初始化过程中（new Vue(options)）都做了什么？</h3><ul><li><p>处理组件配置项；初始化根组件时进行了选项合并操作，将全局配置合并到根组件的局部配置上；初始化每个子组件时做了一些性能优化，将组件配置对象上的一些深层次属性放到 vm.$options 选项中，以提高代码的执行效率；初始化组件实例的关系属性，比如 p a r e n t 、 parent、parent、children、r o o t 、 root、root、refs 等</p></li><li><p>处理自定义事件</p></li><li><p>调用 beforeCreate 钩子函数</p></li><li><p>初始化组件的 inject 配置项，得到 ret[key] = val 形式的配置对象，然后对该配置对象进行响应式处理，并代理每个 key 到 vm 实例上</p></li><li><p>数据响应式，处理 props、methods、data、computed、watch 等选项</p></li><li><p>解析组件配置项上的 provide 对象，将其挂载到 vm._provided 属性上</p></li><li><p>调用 created 钩子函数</p></li><li><p>如果发现配置项上有 el 选项，则自动调用 $mount 方法，也就是说有了 el 选项，就不需要再手动调用</p></li><li><p>$mount 方法，反之，没提供 el 选项则必须调用 $mount</p></li><li><p>接下来则进入挂载阶段</p><p>  // core/instance/init.js<br>  export function initMixin (Vue: Class<component>) {</component></p><pre><code>Vue.prototype._init = function (options?: Object) {    const vm: Component = this    vm._uid = uid++</code></pre></li></ul><pre><code>      // 如果是Vue的实例，则不需要被observe      vm._isVue = true      if (options &amp;&amp; options._isComponent) {        // optimize internal component instantiation        // since dynamic options merging is pretty slow, and none of the        // internal component options needs special treatment.        initInternalComponent(vm, options)      } else {        vm.$options = mergeOptions(          resolveConstructorOptions(vm.constructor),          options || {},          vm        )      }      if (process.env.NODE_ENV !== &apos;production&apos;) {        initProxy(vm)      } else {        vm._renderProxy = vm      }      vm._self = vm      initLifecycle(vm)      initEvents(vm)      callHook(vm, &apos;beforeCreate&apos;)      initInjections(vm) // resolve injections before data/props      initState(vm)      initProvide(vm) // resolve provide after data/props      callHook(vm, &apos;created&apos;)      if (vm.$options.el) {        vm.$mount(vm.$options.el)      }  }}</code></pre><h3 id="对MVVM的理解？"><a href="#对MVVM的理解？" class="headerlink" title="对MVVM的理解？"></a>对MVVM的理解？</h3><p>MVVM 由 Model、View、ViewModel 三部分构成，Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来；ViewModel 是一个同步View 和 Model的对象。</p><p>在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。</p><p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM， 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p><h3 id="Vue数据双向绑定原理"><a href="#Vue数据双向绑定原理" class="headerlink" title="Vue数据双向绑定原理"></a>Vue数据双向绑定原理</h3><p>实现mvvm的数据双向绑定，是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来给各个属性添加setter，getter并劫持监听，在数据变动时发布消息给订阅者，触发相应的监听回调。就必须要实现以下几点：<br>1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者<br>2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数<br>3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20201215103019747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTgyMjg0,size_16,color_FFFFFF,t_70#pic_center" alt="vue4" title>                </div>                <div class="image-caption">vue4</div>            </figure><h3 id="Vue的响应式原理"><a href="#Vue的响应式原理" class="headerlink" title="Vue的响应式原理"></a>Vue的响应式原理</h3><p>什么是响应式，也即是说，数据发生改变的时候，视图会重新渲染，匹配更新为最新的值。<br>Object.defineProperty 为对象中的每一个属性，设置 get 和 set 方法，每个声明的属性，都会有一个 专属的依赖收集器 subs，当页面使用到 某个属性时，触发 ObjectdefineProperty - get函数，页面的 watcher 就会被 放到 属性的依赖收集器 subs 中，在 数据变化时，通知更新；<br>当数据改变的时候，会触发Object.defineProperty - set函数，数据会遍历自己的 依赖收集器 subs，逐个通知 watcher，视图开始更新；</p><h3 id="Vue3-x响应式数据原理"><a href="#Vue3-x响应式数据原理" class="headerlink" title="Vue3.x响应式数据原理"></a>Vue3.x响应式数据原理</h3><p>Vue3.x改用Proxy替代Object.defineProperty。<br>因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。<br>Proxy只会代理对象的第一层，Vue3是怎样处理这个问题的呢？<br>判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。<br>监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。</p><h3 id="Vue3-0-里为什么要用-Proxy-API替代-defineProperty-API？"><a href="#Vue3-0-里为什么要用-Proxy-API替代-defineProperty-API？" class="headerlink" title="Vue3.0 里为什么要用 Proxy API替代 defineProperty API？"></a>Vue3.0 里为什么要用 Proxy API替代 defineProperty API？</h3><p>1.defineProperty API 的局限性最大原因是它只能针对单例属性做监听。<br>Vue2.x中的响应式实现正是基于defineProperty中的descriptor，对 data 中的属性做了遍历 + 递归，为每个属性设置了 getter、setter。这也就是为什么 Vue 只能对 data 中预定义过的属性做出响应的原因。<br>2.Proxy API的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作， 这就完全可以代理所有属性，将会带来很大的性能提升和更优的代码。<br>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。<br>3.响应式是惰性的。<br>在 Vue.js 2.x 中，对于一个深层属性嵌套的对象，要劫持它内部深层次的变化，就需要递归遍历这个对象，执行 Object.defineProperty 把每一层对象数据都变成响应式的，这无疑会有很大的性能消耗。<br>在 Vue.js 3.0 中，使用 Proxy API 并不能监听到对象内部深层次的属性变化，因此它的处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部属性才会变成响应式，简单的可以说是按需实现响应式，减少性能消耗。</p><h3 id="Proxy-与-Object-defineProperty-优劣对比"><a href="#Proxy-与-Object-defineProperty-优劣对比" class="headerlink" title="Proxy 与 Object.defineProperty 优劣对比"></a>Proxy 与 Object.defineProperty 优劣对比</h3><p>1.Proxy 可以直接监听对象而非属性；<br>2.Proxy 可以直接监听数组的变化；<br>3.Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；<br>4.Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；<br>5.Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；<br>6.Object.defineProperty 的优势如下:<br>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。</p><h3 id="vue中组件的data为什么是一个函数？而new-Vue-实例里，data-可以直接是一个对象"><a href="#vue中组件的data为什么是一个函数？而new-Vue-实例里，data-可以直接是一个对象" class="headerlink" title="vue中组件的data为什么是一个函数？而new Vue 实例里，data 可以直接是一个对象"></a>vue中组件的data为什么是一个函数？而new Vue 实例里，data 可以直接是一个对象</h3><p>我们知道，Vue组件其实就是一个Vue实例。</p><p>JS中的实例是通过构造函数来创建的，每个构造函数可以new出很多个实例，那么每个实例都会继承原型上的方法或属性。</p><p>Vue的data数据其实是Vue原型上的属性，数据存在于内存当中。Vue为了保证每个实例上的data数据的独立性，规定了必须使用函数，而不是对象。</p><p>因为使用对象的话，每个实例（组件）上使用的data数据是相互影响的，这当然就不是我们想要的了。对象是对于内存地址的引用，直接定义个对象的话组件之间都会使用这个对象，这样会造成组件之间数据相互影响。</p><p>使用函数后，使用的是data()函数，data()函数中的this指向的是当前实例本身，就不会相互影响了。</p><p>而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。</p><h3 id="vue中data的属性可以和methods中方法同名吗，为什么？"><a href="#vue中data的属性可以和methods中方法同名吗，为什么？" class="headerlink" title="vue中data的属性可以和methods中方法同名吗，为什么？"></a>vue中data的属性可以和methods中方法同名吗，为什么？</h3><p>可以同名，methods的方法名会被data的属性覆盖；调试台也会出现报错信息，但是不影响执行；<br>原因：源码定义的initState函数内部执行的顺序：props&gt;methods&gt;data&gt;computed&gt;watch</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//initState部分源码</span><br><span class="line">export function initState (vm: Component) &#123;</span><br><span class="line">  vm._watchers = []</span><br><span class="line">  const opts = vm.$options</span><br><span class="line">  if (opts.props) initProps(vm, opts.props)</span><br><span class="line">  if (opts.methods) initMethods(vm, opts.methods)</span><br><span class="line">  if (opts.data) &#123;</span><br><span class="line">    initData(vm)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    observe(vm._data = &#123;&#125;, true /* asRootData */)</span><br><span class="line">  &#125;</span><br><span class="line">  if (opts.computed) initComputed(vm, opts.computed)</span><br><span class="line">  if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    initWatch(vm, opts.watch)</span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vue中created与mounted区别"><a href="#vue中created与mounted区别" class="headerlink" title="vue中created与mounted区别"></a>vue中created与mounted区别</h3><p>在created阶段，实例已经被初始化，但是还没有挂载至el上，所以我们无法获取到对应的节点，但是此时我们是可以获取到vue中data与methods中的数据的；<br>在mounted阶段，vue的template成功挂载在$el中，此时一个完整的页面已经能够显示在浏览器中，所以在这个阶段，可以调用节点了；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//以下为测试vue部分生命函数，便于理解</span><br><span class="line">beforeCreate()&#123;  //创建前</span><br><span class="line">    console.log(&apos;beforecreate:&apos;,document.getElementById(&apos;first&apos;))//null</span><br><span class="line">    console.log(&apos;data:&apos;,this.text);//undefined</span><br><span class="line">    this.sayHello();//error:not a function</span><br><span class="line">&#125;,</span><br><span class="line">created()&#123;  //创建后</span><br><span class="line">    console.log(&apos;create:&apos;,document.getElementById(&apos;first&apos;))//null</span><br><span class="line">    console.log(&apos;data:&apos;,this.text);//this.text</span><br><span class="line">    this.sayHello();//this.sayHello()</span><br><span class="line">&#125;,</span><br><span class="line">beforeMount()&#123; //挂载前</span><br><span class="line">    console.log(&apos;beforeMount:&apos;,document.getElementById(&apos;first&apos;))//null</span><br><span class="line">    console.log(&apos;data:&apos;,this.text);//this.text</span><br><span class="line">    this.sayHello();//this.sayHello()</span><br><span class="line">&#125;,</span><br><span class="line">mounted()&#123;  //挂载后</span><br><span class="line">    console.log(&apos;mounted:&apos;,document.getElementById(&apos;first&apos;))//&lt;p&gt;&lt;/p&gt;</span><br><span class="line">    console.log(&apos;data:&apos;,this.text);//this.text</span><br><span class="line">    this.sayHello();//this.sayHello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vue中computed与method的区别"><a href="#Vue中computed与method的区别" class="headerlink" title="Vue中computed与method的区别"></a>Vue中computed与method的区别</h3><p>相同点:<br>如果作为模板的数据显示，二者能实现响应的功能，唯一不同的是methods定义的方法需要执行<br>不同点：<br>1.computed 会基于响应数据缓存，methods不会缓存；<br>2.diff之前先看data里的数据是否发生变化，如果没有变化computed的方法不会执行，但methods里的方法会执行<br>3.computed是属性调用，而methods是函数调用</p><h3 id="虚拟DOM中key的作用"><a href="#虚拟DOM中key的作用" class="headerlink" title="虚拟DOM中key的作用"></a>虚拟DOM中key的作用</h3><p>简单的说：key是虚拟DOM对象的标识，在更新显示时key起着极其重要的作用。<br>复杂的说：当状态中的数据发生了变化时，react会根据【新数据】生成【新的虚拟DOM】，随后React进行【新虚拟DOM】与【旧虚拟DOM】的diff比较，比较规则如下：</p><p>旧虚拟DOM中找到了与新虚拟DOM相同的key<br>1.若虚拟DOM中的内容没有变，直接使用之前的真是DOM<br>2.若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM<br>旧虚拟DOM中未找到与新虚拟DOM相同的key<br>1.根据数据创建新的真实DOM，随后渲染到页面</p><h3 id="用index作为key可能会引发的问题"><a href="#用index作为key可能会引发的问题" class="headerlink" title="用index作为key可能会引发的问题"></a>用index作为key可能会引发的问题</h3><p>若对数据进行：逆序添加/逆序删除等破坏顺序的操作，会产生没有必要的真实DOM更新，界面效果虽然没有问题，但是数据过多的话，会效率过低；<br>如果结构中还包含输入类的DOM，会产生错误DOM更新，界面有问题；<br>注意！如果不存在对数据的逆序操作，仅用于渲染表用于展示，使用index作为key是没有问题的。</p><h3 id="Vue中watch用法详解"><a href="#Vue中watch用法详解" class="headerlink" title="Vue中watch用法详解"></a>Vue中watch用法详解</h3><p>在vue中，使用watch来监听数据的变化；<br>1.监听的数据后面可以写成对象形式，包含handler方法，immediate和deep。<br>2.immediate表示在watch中首次绑定的时候，是否执行handler，值为true则表示在watch中声明的时候，就立即执行handler方法，值为false，则和一般使用watch一样，在数据发生变化的时候才执行handler。<br>3.当需要监听一个对象的改变时，普通的watch方法无法监听到对象内部属性的改变，只有data中的数据才能够监听到变化，此时就需要deep属性对对象进行深度监听。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">      handler(newName, oldName) &#123;</span><br><span class="line">      </span><br><span class="line">      &#125;,</span><br><span class="line">      deep: true,</span><br><span class="line">      immediate: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="vue中对mixins的理解和使用"><a href="#vue中对mixins的理解和使用" class="headerlink" title="vue中对mixins的理解和使用"></a>vue中对mixins的理解和使用</h3><p>mixins是一种分发 Vue 组件中可复用功能的非常灵活的方式。混合对象可以包含任意组件选项。当组件使用混合对象时，所有混合对象的选项将被混入该组件本身的选项。<br>而mixins引入组件之后，则是将组件内部的内容如data等方法、method等属性与父组件相应内容进行合并。相当于在引入后，父组件的各种属性方法都被扩充了。<br>可点击<a href="https://blog.csdn.net/qq_44182284/article/details/108119674" target="_blank" rel="noopener">vue中对mixins的理解和使用的介绍</a>作为参考</p><h3 id="vue中的插槽"><a href="#vue中的插槽" class="headerlink" title="vue中的插槽"></a>vue中的插槽</h3><p>点击<a href="https://mp.weixin.qq.com/s/6sUvglxC25zEo_pGLVJHeQ" target="_blank" rel="noopener">Vue中组件神兵利器，插槽Slot</a>！查看详解！</p><h3 id="为什么vue采用异步渲染"><a href="#为什么vue采用异步渲染" class="headerlink" title="为什么vue采用异步渲染"></a>为什么vue采用异步渲染</h3><p>vue是组件级更新，当前组件里的数据变了，它就会去更新这个组件。当数据更改一次组件就要重新渲染一次，性能不高，为了防止数据一更新就更新组件，所以做了个异步更新渲染。（核心的方法就是nextTick）</p><p>源码实现原理：<br>当数据变化后会调用notify方法，将watcher遍历，调用update方法通知watcher进行更新，这时候watcher并不会立即去执行，在update中会调用queueWatcher方法将watcher放到了一个队列里，在queueWatcher会根据watcher的进行去重，多个属性依赖一个watcher，如果队列中没有该watcher就会将该watcher添加到队列中，然后通过nextTick异步执行flushSchedulerQueue方法刷新watcher队列。flushSchedulerQueue中开始会触发一个before的方法，其实就是beforeUpdate，然后watcher.run() 才开始真正执行watcher，执行完页面就渲染完成啦，更新完成后会调用updated钩子。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210421111758144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTgyMjg0,size_16,color_FFFFFF,t_70" alt="vue5" title>                </div>                <div class="image-caption">vue5</div>            </figure><h3 id="Vue-的异步更新机制是如何实现的？"><a href="#Vue-的异步更新机制是如何实现的？" class="headerlink" title="Vue 的异步更新机制是如何实现的？"></a>Vue 的异步更新机制是如何实现的？</h3><p>Vue 的异步更新机制的核心是利用了浏览器的异步任务队列来实现的，首选微任务队列，宏任务队列次之。</p><p>当响应式数据更新后，会调用 dep.notify 方法，通知 dep 中收集的 watcher 去执行 update 方法，watcher.update 将 watcher 自己放入一个 watcher 队列（全局的 queue 数组）。</p><p>然后通过 nextTick 方法将一个刷新 watcher 队列的方法（flushSchedulerQueue）放入一个全局的 callbacks 数组中。</p><p>如果此时浏览器的异步任务队列中没有一个叫 flushCallbacks 的函数，则执行 timerFunc 函数，将 flushCallbacks 函数放入异步任务队列。如果异步任务队列中已经存在 flushCallbacks 函数，等待其执行完成以后再放入下一个 flushCallbacks 函数。</p><p>flushCallbacks 函数负责执行 callbacks 数组中的所有 flushSchedulerQueue 函数。</p><p>flushSchedulerQueue 函数负责刷新 watcher 队列，即执行 queue 数组中每一个 watcher 的 run 方法，从而进入更新阶段，比如执行组件更新函数或者执行用户 watch 的回调函数。</p><h3 id="vue为什么在-HTML-中监听事件？"><a href="#vue为什么在-HTML-中监听事件？" class="headerlink" title="vue为什么在 HTML 中监听事件？"></a>vue为什么在 HTML 中监听事件？</h3><p>你可能注意到这种事件监听的方式违背了关注点分离 (separation of concern) 这个长期以来的优良传统。但不必担心，因为所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。实际上，使用 v-on 或 @ 有几个好处：</p><p>扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。<br>因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。<br>当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何清理它们。</p><h3 id="Vue-set-改变数组和对象中的属性"><a href="#Vue-set-改变数组和对象中的属性" class="headerlink" title="Vue.set 改变数组和对象中的属性"></a>Vue.set 改变数组和对象中的属性</h3><p>在一个组件实例中，只有在data里初始化的数据才是响应的，Vue不能检测到对象属性的添加或删除，没有在data里声明的属性不是响应的,所以数据改变了但是不会在页面渲染；<br>解决办法：<br>使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上</p><h3 id="说说vue的生命周期的理解"><a href="#说说vue的生命周期的理解" class="headerlink" title="说说vue的生命周期的理解"></a>说说vue的生命周期的理解</h3><p>生命周期通俗说就是Vue实例从创建到销毁的过程，就是生命周期。<br>beforecreate （初始化界面前）<br>created （初始化界面后）<br>beforemount （渲染界面前）<br>mounted （渲染界面后）<br>beforeUpdate （更新数据前）<br>updated （更新数据后）<br>beforedestory （卸载组件前）<br>destroyed （卸载组件后）<br>注意：面试官想听到的不只是你说出了以上八个钩子名称，而是每个阶段做了什么？可以收藏下图！</p><h3 id="第一次页面加载会触发哪几个钩子？"><a href="#第一次页面加载会触发哪几个钩子？" class="headerlink" title="第一次页面加载会触发哪几个钩子？"></a>第一次页面加载会触发哪几个钩子？</h3><p>第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子</p><h3 id="vue-router有几种钩子函数？"><a href="#vue-router有几种钩子函数？" class="headerlink" title="vue-router有几种钩子函数？"></a>vue-router有几种钩子函数？</h3><p>1.全局路由<br>全局导航钩子主要有两种钩子：前置守卫(beforeEach)、后置钩子(afterEach)</p><p>2.路由独享的钩子<br>单个路由独享的导航钩子，它是在路由配置上直接进行定义的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">routes: [</span><br><span class="line">         &#123;</span><br><span class="line">            path: &apos;/file&apos;,</span><br><span class="line">            component: File,</span><br><span class="line">            beforeEnter: (to, from ,next) =&gt; &#123; </span><br><span class="line">             //do something</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure><p>3.组件内的导航钩子<br>组件内的导航钩子主要有这三种：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave。他们是直接在路由组件内部直接进行定义的。<br>ps:详细知识点可以点击<a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html" target="_blank" rel="noopener">路由导航守卫</a>查看；</p><h3 id="vue路由跳转"><a href="#vue路由跳转" class="headerlink" title="vue路由跳转"></a>vue路由跳转</h3><p>在Vue中，路由跳转通常使用vue-router插件来实现。以下是一些常见的路由跳转方法：</p><p>使用router-link组件创建链接进行导航：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><p>在Vue组件中使用this.$router.push方法进行编程式导航：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 字符串</span><br><span class="line">this.$router.push(&apos;home&apos;)</span><br><span class="line"></span><br><span class="line">// 对象</span><br><span class="line">this.$router.push(&#123; path: &apos;home&apos; &#125;)</span><br><span class="line"></span><br><span class="line">// 带查询参数，变成 /register?plan=private</span><br><span class="line">this.$router.push(&#123; path: &apos;register&apos;, query: &#123; plan: &apos;private&apos; &#125;&#125;)</span><br><span class="line">created() &#123;  </span><br><span class="line">    // 当组件被创建时，访问查询参数  </span><br><span class="line">    const empGroupName = this.$route.query.empGroupName;  </span><br><span class="line">    const empGroupId = this.$route.query.empGroupId;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>使用router-link的tag属性自定义标签类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=&quot;/about&quot; tag=&quot;button&quot;&gt;About&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><p>使用router-link的replace属性避免在历史记录中留下记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=&quot;/about&quot; replace&gt;About&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><p>在JavaScript中使用name属性进行导航（推荐）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 使用路由name进行导航</span><br><span class="line">this.$router.push(&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;)</span><br></pre></td></tr></table></figure><p>使用Vue Router的beforeEach钩子进行全局路由守卫：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  // 对路由进行某些操作，例如权限校验</span><br><span class="line">  // ...</span><br><span class="line">  next(); // 必须调用该方法来resolve这个钩子</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以上是Vue路由跳转的一些常用方法，实际应用中可以根据需要选择合适的方式进行路由跳转。</p><h3 id="vue-router路由跳转方式"><a href="#vue-router路由跳转方式" class="headerlink" title="vue-router路由跳转方式"></a>vue-router路由跳转方式</h3><p>声明式（标签跳转）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=&quot;&#123;name:&apos;home&apos;&#125;&quot;&gt;&lt;/router-link&gt;</span><br><span class="line">&lt;router-link :to=&quot;&#123;path:&apos;/home&apos;&#125;&quot;&gt;&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><p>编程式（ js跳转）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.$router.push(&apos;/home&apos;)</span><br><span class="line">this.$router.push(&#123;name:&apos;home&apos;&#125;)</span><br><span class="line">this.$router.push(&#123;path:&apos;/home&apos;&#125;)</span><br></pre></td></tr></table></figure><h3 id="vue-router路由传参"><a href="#vue-router路由传参" class="headerlink" title="vue-router路由传参"></a>vue-router路由传参</h3><p><a href="https://blog.csdn.net/qq_44182284/article/details/108128860" target="_blank" rel="noopener">router-link 进行页面按钮式路由跳转传参</a><br><a href="https://blog.csdn.net/qq_44182284/article/details/108197898" target="_blank" rel="noopener">this.$router.push进行编程式路由跳转传参</a></p><h3 id="Vuex是什么？怎么使用？"><a href="#Vuex是什么？怎么使用？" class="headerlink" title="Vuex是什么？怎么使用？"></a>Vuex是什么？怎么使用？</h3><p>Vuex是实现组件全局状态（数据）管理的一种机制，可以方便实现组件数据之间的共享；Vuex集中管理共享的数据，易于开发和后期维护；能够高效的实现组件之间的数据共享，提高开发效率；存储在Vuex的数据是响应式的，能够实时保持页面和数据的同步；<br>Vuex重要核心属性包括：state,mutations,action,getters,modules.</p><p>state<br>Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。</p><p>mutations<br>mutations定义的方法动态修改Vuex 的 store 中的状态或数据。</p><p>action<br>actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。</p><p>getters<br>类似vue的计算属性，主要用来过滤一些数据。</p><p>modules<br>项目特别复杂的时候，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理。<br>ps:详细使用和对其各属性的理解可以参考以下文章！</p><p><a href="https://blog.csdn.net/qq_44182284/article/details/125460217?spm=1001.2014.3001.5501" target="_blank" rel="noopener">一文吃透Vuex3的状态管理</a></p><h3 id="什么情况下使用-Vuex？"><a href="#什么情况下使用-Vuex？" class="headerlink" title="什么情况下使用 Vuex？"></a>什么情况下使用 Vuex？</h3><p>如果应用够简单，最好不要使用 Vuex，一个简单的 store 模式即可；<br>需要构建一个中大型单页应用时，使用Vuex能更好地在组件外部管理状态；</p><h3 id="Vuex和单纯的全局对象有什么区别？"><a href="#Vuex和单纯的全局对象有什么区别？" class="headerlink" title="Vuex和单纯的全局对象有什么区别？"></a>Vuex和单纯的全局对象有什么区别？</h3><p>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。<br>不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</p><h3 id="为什么-Vuex-的-mutation-中不能做异步操作？"><a href="#为什么-Vuex-的-mutation-中不能做异步操作？" class="headerlink" title="为什么 Vuex 的 mutation 中不能做异步操作？"></a>为什么 Vuex 的 mutation 中不能做异步操作？</h3><p>每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。</p><h3 id="axios-是什么，其特点和常用语法"><a href="#axios-是什么，其特点和常用语法" class="headerlink" title="axios 是什么，其特点和常用语法"></a>axios 是什么，其特点和常用语法</h3><p>是什么？</p><p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。前端最流行的 ajax 请求库，<br>react/vue 官方都推荐使用 axios 发 ajax 请求<br>特点:</p><p>基于 promise 的异步 ajax 请求库，支持promise所有的API<br>浏览器端/node 端都可以使用，浏览器中创建XMLHttpRequests<br>支持请求／响应拦截器<br>支持请求取消<br>可以转换请求数据和响应数据，并对响应回来的内容自动转换成 JSON类型的数据<br>批量发送多个请求<br>安全性更高，客户端支持防御 XSRF，就是让你的每个请求都带一个从cookie中拿到的key, 根据浏览器同源策略，假冒的网站是拿不到你cookie中得key的，这样，后台就可以轻松辨别出这个请求是否是用户在假冒网站上的误导输入，从而采取正确的策略。<br>常用语法：<br>axios(config): 通用/最本质的发任意类型请求的方式<br>axios(url[, config]): 可以只指定 url 发 get 请求<br>axios.request(config): 等同于 axios(config)<br>axios.get(url[, config]): 发 get 请求<br>axios.delete(url[, config]): 发 delete 请求<br>axios.post(url[, data, config]): 发 post 请求<br>axios.put(url[, data, config]): 发 put 请求<br>axios.defaults.xxx: 请求的默认全局配置<br>axios.interceptors.request.use(): 添加请求拦截器<br>axios.interceptors.response.use(): 添加响应拦截器<br>axios.create([config]): 创建一个新的 axios(它没有下面的功能)<br>axios.Cancel(): 用于创建取消请求的错误对象<br>axios.CancelToken(): 用于创建取消请求的 token 对象<br>axios.isCancel(): 是否是一个取消请求的错误<br>axios.all(promises): 用于批量执行多个异步请求<br>axios.spread(): 用来指定接收所有成功数据的回调函数的方法</p><h3 id="对SSR有了解吗，它主要解决什么问题？"><a href="#对SSR有了解吗，它主要解决什么问题？" class="headerlink" title="对SSR有了解吗，它主要解决什么问题？"></a>对SSR有了解吗，它主要解决什么问题？</h3><p>Server-Side Rendering 我们称其为SSR，意为服务端渲染指由服务侧完成页面的 HTML 结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程；</p><p>解决了以下两个问题：</p><ul><li>seo：搜索引擎优先爬取页面HTML结构，使用ssr时，服务端已经生成了和业务想关联的HTML，有利于seo</li><li>首屏呈现渲染：用户无需等待页面所有js加载完成就可以看到页面视图（压力来到了服务器，所以需要权衡哪些用服务端渲染，哪些交给客户端）</li></ul><p>缺点</p><ul><li><p>复杂度：整个项目的复杂度</p></li><li><p>性能会受到影响</p></li><li><p>服务器负载变大，相对于前后端分离务器只需要提供静态资源来说，服务器负载更大，所以要慎重使用</p></li></ul><h3 id="Vue要做权限管理该怎么做？控制到按钮级别的权限怎么做？"><a href="#Vue要做权限管理该怎么做？控制到按钮级别的权限怎么做？" class="headerlink" title="Vue要做权限管理该怎么做？控制到按钮级别的权限怎么做？"></a>Vue要做权限管理该怎么做？控制到按钮级别的权限怎么做？</h3><p>具体详解查看<a href="https://cloud.tencent.com/developer/article/1794300" target="_blank" rel="noopener">Vue要做权限管理该怎么做？控制到按钮级别的权限怎么做</a></p><h3 id="Vue项目前端开发环境请求服务器接口跨域问题"><a href="#Vue项目前端开发环境请求服务器接口跨域问题" class="headerlink" title="Vue项目前端开发环境请求服务器接口跨域问题"></a>Vue项目前端开发环境请求服务器接口跨域问题</h3><p>对于vue-cli 2.x版本在config文件夹配置服务器代理；<br>对于vue-cli 3.x版本前端配置服务器代理在vue.config.js中设置服务器代理；如下图：</p><p>target对应的属性值为你准备向后端服务器发送请求的主机+端口，含义为：相当于把前端发送请求的主机+端口自动替换成挂载的主机和端口，这样前后端的主机端口都一一就不会存在跨域问题；<br>ws:表示WebSocket协议；<br>changeOrigin:true;表示是否改变原域名；这个一定要选择为true;<br>这样发送请求的时候就不会出现跨域问题了。</p><h3 id="Vue3有了解过吗？能说说跟Vue2的区别吗？"><a href="#Vue3有了解过吗？能说说跟Vue2的区别吗？" class="headerlink" title="Vue3有了解过吗？能说说跟Vue2的区别吗？"></a>Vue3有了解过吗？能说说跟Vue2的区别吗？</h3><p>具体详解请点击<a href="https://cloud.tencent.com/developer/article/1794328" target="_blank" rel="noopener">Vue3有了解过吗？能说说跟Vue2的区别吗？</a></p><h3 id="Vue-3-0-所采用的-Composition-Api-与-Vue-2-x使用的Options-Api-有什么区别？"><a href="#Vue-3-0-所采用的-Composition-Api-与-Vue-2-x使用的Options-Api-有什么区别？" class="headerlink" title="Vue 3.0 所采用的 Composition Api 与 Vue 2.x使用的Options Api 有什么区别？"></a>Vue 3.0 所采用的 Composition Api 与 Vue 2.x使用的Options Api 有什么区别？</h3><p>Options Api</p><p>包含一个描述组件选项（data、methods、props等）的对象 options；<br>API开发复杂组件，同一个功能逻辑的代码被拆分到不同选项 ；<br>使用mixin重用公用代码，也有问题：命名冲突，数据来源不清晰；</p><p>Composition Api</p><p>vue3 新增的一组 api，它是基于函数的 api，可以更灵活的组织组件的逻辑。<br>解决options api在大型项目中，options api不好拆分和重用的问题。</p><h3 id="vue-如何实现按需加载配合-webpack-设置"><a href="#vue-如何实现按需加载配合-webpack-设置" class="headerlink" title="vue 如何实现按需加载配合 webpack 设置"></a>vue 如何实现按需加载配合 webpack 设置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">webpack 中提供了 require.ensure()来实现按需加载。以前引入路由是通过 import 这样的方式引入，改为 const 定义的方式进行引入。</span><br><span class="line">不进行页面按需加载引入方式：import home from &apos;../../common/home.vue&apos;</span><br><span class="line">进行页面按需加载的引入方式：const home = r =&gt; require.ensure( [], () =&gt; r (require(&apos;../../common/home.vue&apos;)))</span><br></pre></td></tr></table></figure><p>在音乐 app 中使用的路由懒加载方式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const Recommend = (resolve) =&gt; &#123;</span><br><span class="line">  import(&apos;components/recommend/recommend&apos;).then((module) =&gt; &#123;</span><br><span class="line">    resolve(module)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Singer = (resolve) =&gt; &#123;</span><br><span class="line">  import(&apos;components/singer/singer&apos;).then((module) =&gt; &#123;</span><br><span class="line">    resolve(module)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何让-CSS-只在当前组件中起作用"><a href="#如何让-CSS-只在当前组件中起作用" class="headerlink" title="如何让 CSS 只在当前组件中起作用"></a>如何让 CSS 只在当前组件中起作用</h3><p>将当前组件的<style>修改为<style scoped></p><h3 id="指令-v-el-的作用是什么"><a href="#指令-v-el-的作用是什么" class="headerlink" title="指令 v-el 的作用是什么?"></a>指令 v-el 的作用是什么?</h3><p>提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标.可以是 CSS 选择器，也可以是一个 HTMLElement 实例</p><h3 id="vue-loader-是什么？使用它的用途有哪些？"><a href="#vue-loader-是什么？使用它的用途有哪些？" class="headerlink" title="vue-loader 是什么？使用它的用途有哪些？"></a>vue-loader 是什么？使用它的用途有哪些？</h3><p>vue-loader 是解析 .vue 文件的一个加载器，将 template/js/style 转换成 js 模块。</p><p>用途：js 可以写 es6、style 样式可以 scss 或 less；template 可以加 jade 等。</p><h3 id="vue怎么实现页面的权限控制"><a href="#vue怎么实现页面的权限控制" class="headerlink" title="vue怎么实现页面的权限控制"></a>vue怎么实现页面的权限控制</h3><p>利用 vue-router 的 beforeEach 事件，可以在跳转页面前判断用户的权限（利用 cookie 或 token），是否能够进入此页面，如果不能则提示错误或重定向到其他页面，在后台管理系统中这种场景经常能遇到。</p><h3 id="watch的作用是什么"><a href="#watch的作用是什么" class="headerlink" title="watch的作用是什么"></a>watch的作用是什么</h3><p>watch 主要作用是监听某个数据值的变化。和计算属性相比除了<strong>没有缓存</strong>，作用是一样的。</p><p>借助 watch 还可以做一些特别的事情，例如监听页面路由，当页面跳转时，我们可以做相应的权限控制，拒绝没有权限的用户访问页面。</p><h3 id="vue组件设计相关"><a href="#vue组件设计相关" class="headerlink" title="vue组件设计相关"></a>vue组件设计相关</h3><p>​    1）用一些功能单一的小模块来组织应用，较小的模块更容易看懂、维护、复用和调试 （每个组件应该保持单一、独立、可复用、可测试）；</p><p>​    2)组件命名应该遵从以下几点原则：</p><p>​        有意义: 名字不要太详细，也不要太抽象。</p><p>​        短: 名字最好是2-3个单词。</p><p>​        可读的:容易让人能读出来以便我们可以更容易的讨论它。</p><p>​    vue组件也应该遵循以下原则：</p><p>​        遵从元素命名规范，包括连字符，不要使用保留字</p><p>​        为了在其他项目中复用，应该以某个模块名字作为命名空间。</p><p>​    3）把复杂的语法移动到methods或者计算属性中，避免使用行内表达式；</p><p>​    4）保证组件的props简单，保证接口简单，便于开发理解维护，同时进行props限制，比如检查是否存在，设置默认值，设置类型校验等；</p><p>​    参考链接：<a href="https://www.cnblogs.com/ytu2010dt/p/6523586.html">vue组件最佳实践</a></p><h3 id="vue数据绑定原理"><a href="#vue数据绑定原理" class="headerlink" title="vue数据绑定原理"></a>vue数据绑定原理</h3><blockquote><p><strong>定义</strong>：vue的数据双向绑定是基于Object.defineProperty方法，通过定义data属性的get和set函数来监听数据对象的变化，一旦变化，vue利用发布订阅模式，通知订阅者执行回调函数，更新dom。</p></blockquote><p>参考链接：<a href="https://www.cnblogs.com/knightsu/p/7230302.html">vue数据绑定原理</a></p><h3 id="vue父子组件和兄弟组件的通信问题；"><a href="#vue父子组件和兄弟组件的通信问题；" class="headerlink" title="vue父子组件和兄弟组件的通信问题；"></a>vue父子组件和兄弟组件的通信问题；</h3><p>1）父子组件通信：</p><blockquote><p>1、父组件使用 props 把数据传给子组件。</p><p>2、子组件使用 $emit 触发父组件的自定义事件。</p></blockquote><p>2）兄弟组件通信：</p><p>创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let Hub = new Vue(); //创建事件中心</span><br></pre></td></tr></table></figure><p>组件1触发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">eve() &#123; Hub.$emit(&apos;change&apos;,&apos;hehe&apos;);  &#125;  //Hub触发事件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件2接收:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">Hub.$on(&apos;change&apos;, () =&gt; &#123;  //Hub接收事件</span><br><span class="line">this.msg = &apos;hehe&apos;;  </span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vue的事件监听"><a href="#vue的事件监听" class="headerlink" title="vue的事件监听"></a>vue的事件监听</h3><p>参考链接：<a href="http://wiki.jikexueyuan.com/project/vue-js/listen.html">事件监听</a></p><h3 id="vue和react的对比"><a href="#vue和react的对比" class="headerlink" title="vue和react的对比"></a>vue和react的对比</h3><p>参考链接：<a href="https://blog.csdn.net/CystalVon/article/details/78428036">Vue.js与React的全面对比</a></p><h3 id="vue和jquery的对比"><a href="#vue和jquery的对比" class="headerlink" title="vue和jquery的对比"></a>vue和jquery的对比</h3><p>jQuery是使用选择器（$）选取DOM对象，对其进行赋值、取值、事件绑定等操作，其实和原生的HTML的区别只在于可以更方便的选取和操作DOM对象，而数据和界面是在一起的。比如需要获取label标签的内容：$(“lable”).val();,它还是依赖DOM元素的值。</p><p>Vue则是通过Vue对象将数据和View完全分离开来了。对数据进行操作不再需要引用相应的DOM对象，可以说数据和View是分离的，他们通过Vue对象这个vm实现相互的绑定。这就是传说中的MVVM。</p><blockquote><p>vue适用的场景：复杂数据操作的后台页面，表单填写页面；</p><p>jquery适用的场景：比如说一些html5的动画页面，一些需要js来操作页面样式的页面；</p><p>然而二者也是可以结合起来一起使用的，vue侧重数据绑定，jquery侧重样式操作，动画效果等，则会更加高效率的完成业务需求。</p></blockquote><h3 id="实现-Vue-SSR"><a href="#实现-Vue-SSR" class="headerlink" title="实现 Vue SSR"></a>实现 Vue SSR</h3><p>其基本实现原理</p><ul><li>app.js 作为客户端与服务端的公用入口，导出 Vue 根实例，供客户端 entry 与服务端 entry 使用。客户端 entry 主要作用挂载到 DOM 上，服务端 entry 除了创建和返回实例，还进行路由匹配与数据预获取。</li><li>webpack 为客服端打包一个 Client Bundle ，为服务端打包一个 Server Bundle 。</li><li>服务器接收请求时，会根据 url，加载相应组件，获取和解析异步数据，创建一个读取 Server Bundle 的 BundleRenderer，然后生成 html 发送给客户端。</li><li>客户端混合，客户端收到从服务端传来的 DOM 与自己的生成的 DOM 进行对比，把不相同的 DOM 激活，使其可以能够响应后续变化，这个过程称为客户端激活 。为确保混合成功，客户端与服务器端需要共享同一套数据。在服务端，可以在渲染之前获取数据，填充到 stroe 里，这样，在客户端挂载到 DOM 之前，可以直接从 store 里取数据。首屏的动态数据通过 <code>window.__INITIAL_STATE__</code>发送到客户端</li></ul><blockquote><p>Vue SSR 的实现，主要就是把 Vue 的组件输出成一个完整 HTML, vue-server-renderer 就是干这事的</p></blockquote><p><code>Vue SSR</code>需要做的事多点（输出完整 HTML），除了<code>complier -&gt; vnode</code>，还需如数据获取填充至 HTML、客户端混合（hydration）、缓存等等。<br>相比于其他模板引擎（ejs, jade 等），最终要实现的目的是一样的，性能上可能要差点</p><h3 id="Vue-组件-data-为什么必须是函数"><a href="#Vue-组件-data-为什么必须是函数" class="headerlink" title="Vue 组件 data 为什么必须是函数"></a>Vue 组件 data 为什么必须是函数</h3><ul><li>每个组件都是 Vue 的实例。</li><li>组件共享 data 属性，当 data 的值是同一个引用类型的值时，改变其中一个会影响其他</li></ul><h3 id="Vue-computed-实现"><a href="#Vue-computed-实现" class="headerlink" title="Vue computed 实现"></a>Vue computed 实现</h3><ul><li>建立与其他属性（如：data、 Store）的联系；</li><li>属性改变后，通知计算属性重新计算</li></ul><blockquote><p>实现时，主要如下</p></blockquote><ul><li>初始化 data， 使用 <code>Object.defineProperty</code> 把这些属性全部转为 <code>getter/setter</code>。</li><li>初始化 <code>computed</code>, 遍历 <code>computed</code> 里的每个属性，每个 computed 属性都是一个 watch 实例。每个属性提供的函数作为属性的 getter，使用 Object.defineProperty 转化。</li><li><code>Object.defineProperty getter</code> 依赖收集。用于依赖发生变化时，触发属性重新计算。</li><li>若出现当前 computed 计算属性嵌套其他 computed 计算属性时，先进行其他的依赖收集</li></ul><h3 id="Vue-complier-实现"><a href="#Vue-complier-实现" class="headerlink" title="Vue complier 实现"></a>Vue complier 实现</h3><ul><li>模板解析这种事，本质是将数据转化为一段 html ，最开始出现在后端，经过各种处理吐给前端。随着各种 mv* 的兴起，模板解析交由前端处理。</li><li>总的来说，Vue complier 是将 template 转化成一个 render 字符串。</li></ul><blockquote><p>可以简单理解成以下步骤：</p></blockquote><ul><li>parse 过程，将 template 利用正则转化成 AST 抽象语法树。</li><li>optimize 过程，标记静态节点，后 diff 过程跳过静态节点，提升性能。</li><li>generate 过程，生成 render 字符串</li></ul><h3 id="怎么快速定位哪个组件出现性能问题"><a href="#怎么快速定位哪个组件出现性能问题" class="headerlink" title="怎么快速定位哪个组件出现性能问题"></a>怎么快速定位哪个组件出现性能问题</h3><p>用 timeline 工具。 大意是通过 timeline 来查看每个函数的调用时常，定位出哪个函数的问题，从而能判断哪个组件出了问题</p><h3 id="1-那你能讲一讲-MVVM-吗？"><a href="#1-那你能讲一讲-MVVM-吗？" class="headerlink" title="1.那你能讲一讲 MVVM 吗？"></a>1.那你能讲一讲 MVVM 吗？</h3><p>MVVM 是 Model-View-ViewModel 缩写，也就是把 MVC 中的 Controller 演变成 ViewModel。Model 层代表数据模型，View 代表 UI 组件，</p><p>ViewModel 是 View 和 Model 层的桥梁，数据会绑定到 viewModel 层并自动将数据渲染到页面中，视图变化的时候会通知 viewModel 层更新数据。</p><h3 id="2-简单说一下-Vue2-x-响应式数据原理"><a href="#2-简单说一下-Vue2-x-响应式数据原理" class="headerlink" title="2.简单说一下 Vue2.x 响应式数据原理"></a>2.简单说一下 Vue2.x 响应式数据原理</h3><p>Vue 在初始化数据时，会使用 Object.defineProperty 重新定义 data 中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的 watcher)</p><p>如果属性发生变化会通知相关依赖进行更新操作(发布订阅)。</p><h3 id="3-那你知道-Vue3-x-响应式数据原理吗？"><a href="#3-那你知道-Vue3-x-响应式数据原理吗？" class="headerlink" title="3.那你知道 Vue3.x 响应式数据原理吗？"></a>3.那你知道 Vue3.x 响应式数据原理吗？</h3><p>(还好我有看，这个难不倒我)</p><p>Vue3.x 改用 Proxy 替代 Object.defineProperty。因为 Proxy 可以直接监听对象和数组的变化，并且有多达 13 种拦截方法。</p><p>并且作为新标准将受到浏览器厂商重点持续的性能优化。</p><p>❝ Proxy 只会代理对象的第一层，那么 Vue3 又是怎样处理这个问题的呢？❞</p><p>（很简单啊）</p><p>判断当前 Reflect.get 的返回值是否为 Object，如果是则再通过 reactive 方法做代理， 这样就实现了深度观测。</p><p>❝ 监测数组的时候可能触发多次 get/set，那么如何防止触发多次呢？❞</p><p>我们可以判断 key 是否为当前被代理对象 target 自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行 trigger。</p><p>面试官抬起了头。心里暗想</p><p>(这小子还行，比上两个强，应该是多多少少看过 Vue3 的源码了)</p><h3 id="4-再说一下-vue2-x-中如何监测数组变化"><a href="#4-再说一下-vue2-x-中如何监测数组变化" class="headerlink" title="4.再说一下 vue2.x 中如何监测数组变化"></a>4.再说一下 vue2.x 中如何监测数组变化</h3><p>使用了函数劫持的方式，重写了数组的方法，Vue 将 data 中的数组进行了原型链重写，指向了自己定义的数组原型方法。</p><p>这样当调用数组 api 时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。</p><p>（能问到这的面试官都比较注重深度，这些常规操作要记牢）</p><p>（原型链的细节可以参考我的另一篇专栏）</p><h3 id="5-nextTick-知道吗，实现原理是什么？"><a href="#5-nextTick-知道吗，实现原理是什么？" class="headerlink" title="5.nextTick 知道吗，实现原理是什么？"></a>5.nextTick 知道吗，实现原理是什么？</h3><p>在下次 DOM 更新循环结束之后执行延迟回调。nextTick 主要使用了宏任务和微任务。根据执行环境分别尝试采用</p><p>Promise</p><p>MutationObserver</p><p>setImmediate</p><p>如果以上都不行则采用 setTimeout</p><p>定义了一个异步方法，多次调用 nextTick 会将方法存入队列中，通过这个异步方法清空当前队列。</p><p>（关于宏任务和微任务以及事件循环可以参考我的另两篇专栏）</p><p>(看到这你就会发现，其实问框架最终还是考验你的原生 JavaScript 功底)</p><h3 id="6-说一下-Vue-的生命周期"><a href="#6-说一下-Vue-的生命周期" class="headerlink" title="6.说一下 Vue 的生命周期"></a>6.说一下 Vue 的生命周期</h3><p>beforeCreate 是 new Vue()之后触发的第一个钩子，在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问。</p><p>created 在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发 updated 函数。</p><p>可以做一些初始数据的获取，在当前阶段无法与 Dom 进行交互，如果非要想，可以通过 vm.$nextTick 来访问 Dom。</p><p>beforeMount 发生在挂载之前，在这之前 template 模板已导入渲染函数编译。而当前阶段虚拟 Dom 已经创建完成，即将开始渲染。</p><p>在此时也可以对数据进行更改，不会触发 updated。</p><p>mounted 在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom 节点，使用$refs 属性对 Dom 进行操作。</p><p>beforeUpdate 发生在更新之前，也就是响应式数据发生更新，虚拟 dom 重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。</p><p>updated 发生在更新完成之后，当前阶段组件 Dom 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。</p><p>beforeDestroy 发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。</p><p>destroyed 发生在实例销毁之后，这个时候只剩下了 dom 空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</p><p>(关于 Vue 的生命周期详解感兴趣的也请移步我的另一篇专栏)</p><h3 id="7-你的接口请求一般放在哪个生命周期中？"><a href="#7-你的接口请求一般放在哪个生命周期中？" class="headerlink" title="7.你的接口请求一般放在哪个生命周期中？"></a>7.你的接口请求一般放在哪个生命周期中？</h3><p>接口请求一般放在 mounted 中，但需要注意的是服务端渲染时不支持 mounted，需要放到 created 中。</p><h3 id="8-再说一下-Computed-和-Watch"><a href="#8-再说一下-Computed-和-Watch" class="headerlink" title="8.再说一下 Computed 和 Watch"></a>8.再说一下 Computed 和 Watch</h3><p>Computed 本质是一个具备缓存的 watcher，依赖的属性发生变化就会更新视图。适用于计算比较消耗性能的计算场景。</p><p>当表达式过于复杂时，在模板中放入过多逻辑会让模板难以维护，可以将复杂的逻辑放入计算属性中处理。</p><p>Watch 没有缓存性，更多的是观察的作用，可以监听某些数据执行回调。当我们需要深度监听对象中的属性时，可以打开 deep：true 选项，</p><p>这样便会对对象中的每一项进行监听。这样会带来性能问题，优化的话可以使用字符串形式监听，如果没有写到组件中，不要忘记使用 unWatch 手动注销哦。</p><h3 id="9-说一下-v-if-和-v-show-的区别"><a href="#9-说一下-v-if-和-v-show-的区别" class="headerlink" title="9.说一下 v-if 和 v-show 的区别"></a>9.说一下 v-if 和 v-show 的区别</h3><p>当条件不成立时，v-if 不会渲染 DOM 元素，v-show 操作的是样式(display)，切换当前 DOM 的显示和隐藏。</p><h3 id="10-组件中的-data-为什么是一个函数？"><a href="#10-组件中的-data-为什么是一个函数？" class="headerlink" title="10.组件中的 data 为什么是一个函数？"></a>10.组件中的 data 为什么是一个函数？</h3><p>一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果 data 是对象的话，对象属于引用类型，会影响到所有的实例。</p><p>所以为了保证组件不同的实例之间 data 不冲突，data 必须是一个函数。</p><h3 id="11-说一下-v-model-的原理"><a href="#11-说一下-v-model-的原理" class="headerlink" title="11.说一下 v-model 的原理"></a>11.说一下 v-model 的原理</h3><p>v-model 本质就是一个语法糖，可以看成是 value + input 方法的语法糖。可以通过 model 属性的 prop 和 event 属性来进行自定义。</p><p>原生的 v-model，会根据标签的不同生成不同的事件和属性。</p><h3 id="12-Vue-事件绑定原理说一下"><a href="#12-Vue-事件绑定原理说一下" class="headerlink" title="12.Vue 事件绑定原理说一下"></a>12.Vue 事件绑定原理说一下</h3><p>原生事件绑定是通过 addEventListener 绑定给真实元素的，组件事件绑定是通过 Vue 自定义的$on 实现的。</p><p>❝ 面试官：(这小子基础还可以，接下来我得上上难度了） ❞</p><h3 id="13-Vue-模版编译原理知道吗，能简单说一下吗？"><a href="#13-Vue-模版编译原理知道吗，能简单说一下吗？" class="headerlink" title="13.Vue 模版编译原理知道吗，能简单说一下吗？"></a>13.Vue 模版编译原理知道吗，能简单说一下吗？</h3><p>简单说，Vue 的编译过程就是将 template 转化为 render 函数的过程。会经历以下阶段：</p><p>生成 AST 树</p><p>优化</p><p>codegen</p><p>首先解析模版，生成 AST 语法树(一种用 JavaScript 对象的形式来描述整个模板)。使用大量的正则表达式对模板进行解析，</p><p>遇到标签、文本的时候都会执行对应的钩子进行相关处理。</p><p>Vue 的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的 DOM 也不会变化。</p><p>那么优化过程就是深度遍历 AST 树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。</p><p>编译的最后一步是将优化后的 AST 树转换为可执行的代码。</p><p>❝ 面试官：(精神小伙啊，有点东西，难度提升，不信难不倒你）❞</p><h3 id="14-Vue2-x-和-Vue3-x-渲染器的-diff-算法分别说一下"><a href="#14-Vue2-x-和-Vue3-x-渲染器的-diff-算法分别说一下" class="headerlink" title="14.Vue2.x 和 Vue3.x 渲染器的 diff 算法分别说一下"></a>14.Vue2.x 和 Vue3.x 渲染器的 diff 算法分别说一下</h3><p>简单来说，diff 算法有以下过程</p><p>同级比较，再比较子节点</p><p>先判断一方有子节点一方没有子节点的情况(如果新的 children 没有子节点，将旧的子节点移除)</p><p>比较都有子节点的情况(核心 diff)</p><p>递归比较子节点</p><p>正常 Diff 两个树的时间复杂度是 O(n^3)，但实际情况下我们很少会进行跨层级的移动 DOM，所以 Vue 将 Diff 进行了优化，从 O(n^3) -&gt; O(n)，</p><p>只有当新旧 children 都为多个子节点时才需要用核心的 Diff 算法进行同层级比较。</p><p>Vue2 的核心 Diff 算法采用了双端比较的算法，同时从新旧 children 的两端开始进行比较，借助 key 值找到可复用的节点，再进行相关操作。</p><p>相比 React 的 Diff 算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。</p><p>Vue3.x 借鉴了 ivi 算法和 inferno 算法</p><p>在创建 VNode 时就确定其类型，以及在 mount/patch 的过程中采用位运算来判断一个 VNode 的类型，在这个基础之上再配合核心的 Diff 算法，</p><p>使得性能上较 Vue2.x 有了提升。(实际的实现可以结合 Vue3.x 源码看。)</p><p>该算法中还运用了动态规划的思想求解最长递归子序列。</p><p>(看到这你还会发现，框架内无处不蕴藏着数据结构和算法的魅力)</p><p>❝ 面试官：(可以可以，看来是个苗子，不过自我介绍属实有些无聊，下一题) ❞</p><h3 id="15-再说一下虚拟-Dom-以及-key-属性的作用"><a href="#15-再说一下虚拟-Dom-以及-key-属性的作用" class="headerlink" title="15.再说一下虚拟 Dom 以及 key 属性的作用"></a>15.再说一下虚拟 Dom 以及 key 属性的作用</h3><p>由于在浏览器中操作 DOM 是很昂贵的。<strong>频繁的操作 DOM，会产生一定的性能问题。</strong>这就是虚拟 Dom 的产生原因。</p><p>Vue2 的 Virtual DOM 借鉴了开源库 snabbdom 的实现。</p><p>Virtual DOM 本质就是用一个原生的 JS 对象去描述一个 DOM 节点。是对真实 DOM 的一层抽象。(也就是源码中的 VNode 类，它定义在 src/core/vdom/vnode.js 中。)</p><p>VirtualDOM 映射到真实 DOM 要经历 VNode 的 create、diff、patch 等阶段。</p><p>「key 的作用是尽可能的复用 DOM 元素。」</p><p>新旧 children 中的节点只有顺序是不同的时候，最佳的操作应该是通过移动元素的位置来达到更新的目的。</p><p>需要在新旧 children 的节点中保存映射关系，以便能够在旧 children 的节点中找到可复用的节点。key 也就是 children 中节点的唯一标识。</p><h3 id="16-keep-alive-了解吗？"><a href="#16-keep-alive-了解吗？" class="headerlink" title="16.keep-alive 了解吗？"></a>16.keep-alive 了解吗？</h3><p>keep-alive 可以<strong>实现组件缓存</strong>，当组件切换时不会对当前组件进行卸载。</p><p>常用的两个属性 include/exclude，允许组件有条件的进行缓存。</p><p>两个生命周期 activated/deactivated，用来得知当前组件是否处于活跃状态。</p><p>keep-alive 的中还运用了 LRU(Least Recently Used)算法。</p><p>（又是数据结构与算法，原来算法在前端有这么多的应用）</p><h3 id="17-Vue-中组件生命周期调用顺序说一下"><a href="#17-Vue-中组件生命周期调用顺序说一下" class="headerlink" title="17.Vue 中组件生命周期调用顺序说一下"></a>17.Vue 中组件生命周期调用顺序说一下</h3><p>组件的调用顺序都是先父后子,渲染完成的顺序是先子后父。</p><p>组件的销毁操作是先父后子，销毁完成的顺序是先子后父。</p><p>加载渲染过程</p><p>父 beforeCreate-&gt;父 created-&gt;父 beforeMount-&gt;子 beforeCreate-&gt;子 created-&gt;子 beforeMount- &gt;子 mounted-&gt;父 mounted</p><p>子组件更新过程</p><p>父 beforeUpdate-&gt;子 beforeUpdate-&gt;子 updated-&gt;父 updated</p><p>父组件更新过程</p><p>父 beforeUpdate -&gt; 父 updated</p><p>销毁过程</p><p>父 beforeDestroy-&gt;子 beforeDestroy-&gt;子 destroyed-&gt;父 destroyed</p><h3 id="18-Vue2-x-组件通信有哪些方式？"><a href="#18-Vue2-x-组件通信有哪些方式？" class="headerlink" title="18.Vue2.x 组件通信有哪些方式？"></a>18.Vue2.x 组件通信有哪些方式？</h3><p>父子组件通信</p><p>父-&gt;子 props，子-&gt;父 $on、$emit</p><p>获取父子组件实例 $parent、$children</p><p>Ref 获取实例的方式调用组件的属性或者方法</p><p>Provide、inject 官方不推荐使用，但是写组件库时很常用</p><p>兄弟组件通信</p><p>Event Bus 实现跨组件通信 Vue.prototype.$bus = new Vue</p><p>Vuex</p><p>跨级组件通信</p><p>Vuex</p><p>$attrs、$listeners</p><p>Provide、inject</p><h3 id="19-SSR-了解吗？"><a href="#19-SSR-了解吗？" class="headerlink" title="19.SSR 了解吗？"></a>19.SSR 了解吗？</h3><p>SSR 也就是服务端渲染，也就是将 Vue 在客户端把标签渲染成 HTML 的工作放在服务端完成，然后再把 html 直接返回给客户端。</p><p>SSR <strong>有着更好的 SEO、并且首屏加载速度更快</strong>等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，</p><p>服务器端渲染只支持 beforeCreate 和 created 两个钩子，当我们需要一些外部扩展库时需要特殊处理，</p><p>服务端渲染应用程序也需要处于 Node.js 的运行环境。还有就是服务器会有更大的负载需求。</p><h3 id="21-hash-路由和-history-路由实现原理说一下"><a href="#21-hash-路由和-history-路由实现原理说一下" class="headerlink" title="21.hash 路由和 history 路由实现原理说一下"></a>21.hash 路由和 history 路由实现原理说一下</h3><p>location.hash 的值实际就是 URL 中#后面的东西。</p><p>history 实际采用了 HTML5 中提供的 API 来实现，主要有 history.pushState()和 history.replaceState()。</p><p>面试官拿起旁边已经凉透的咖啡，喝了一口。(我难道问不倒这小子了么)</p><h3 id="1-v-show-与-v-if-区别"><a href="#1-v-show-与-v-if-区别" class="headerlink" title="1.v-show 与 v-if 区别"></a>1.v-show 与 v-if 区别</h3><p>v-show 是css隐藏，v-if是直接销毁和创建，所以频繁切换的适合用v-show</p><h3 id="2-计算属性和-watch-的区别"><a href="#2-计算属性和-watch-的区别" class="headerlink" title="2.计算属性和 watch 的区别"></a>2.计算属性和 watch 的区别</h3><p>计算属性是自动监听依赖值的变化，从而动态返回内容，监听是一个过程，在监听的值变化时，可以触发一个回调，并做一些事情。</p><p>所以区别来源于用法，只是<strong>需要动态值，那就用计算属性</strong>；需要知道值的改变后执行业务逻辑，才用 watch，用反或混用虽然可行，但都是不正确的用法。</p><p><strong>说出一下区别会加分</strong></p><p>computed 是一个对象时，它有哪些选项？</p><p>computed 和 methods 有什么区别？</p><p>computed 是否能依赖其它组件的数据？</p><p>watch 是一个对象时，它有哪些选项？</p><p>有get和set两个选项</p><p>methods是一个方法，它可以接受参数，而computed不能，computed是可以缓存的，methods不会。</p><p>computed可以依赖其他computed，甚至是其他组件的data</p><p>watch 配置</p><p>handler</p><p>deep 是否深度</p><p>immeditate 是否立即执行</p><p><strong>总结</strong></p><p>当有一些数据需要随着另外一些数据变化时，建议使用computed。</p><p>当有一个通用的响应数据变化的时候，要执行一些业务逻辑或异步操作的时候建议使用watcher</p><h3 id="3-事件修饰符"><a href="#3-事件修饰符" class="headerlink" title="3.事件修饰符"></a>3.事件修饰符</h3><p>绑定一个原生的click事件， 加native，</p><p>其他事件修饰符</p><p>stop（阻止事件冒泡） prevent（阻止默认事件） self（只有自己触发，子组件不会触发）</p><p>组合键</p><p>click.ctrl.exact 只有ctrl被按下的时候才触发</p><h3 id="4-双向绑定的原理"><a href="#4-双向绑定的原理" class="headerlink" title="4.双向绑定的原理"></a>4.双向绑定的原理</h3><p>通过数据劫持和发布订阅模式方式实现的，<strong>核心的 API 是通过Object.defineProperty()来劫持各个属性的setter / getter，在数据变动时发布消息给订阅者，触发相应的监听回调，这也是为什么 Vue.js 2.x 不支持 IE8 的原因。</strong>要实现双向绑定，首先进行数据劫持，所以需要设置一个监听器Observer，用来监听所有属性。如果属性发生变化，就需要告诉订阅者Watcher看是否需要更新。因为订阅者很多，所以需要一个消息订阅器Dep来专门收集这些订阅者，然后在监听器和订阅者之间进行统一管理，最后需要一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令（v-model，v-on）对应初始化一个订阅者Watcheer  ，并替换模板数据或绑定相应函数</p><p>官网解释：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fxn--kbt444f7hhh9h%2F">https://cn.vuejs.org/v2/guide/reactivity.html</a></p><h3 id="5-怎么理解单项数据流"><a href="#5-怎么理解单项数据流" class="headerlink" title="5.怎么理解单项数据流"></a>5.怎么理解单项数据流</h3><p>这是关于组件通讯中父组件的prop传递给子组件，在子组件中不能更改prop，只能父组件更改prop，否则会报错。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p><p>一般来说，对于子组件想要更改父组件状态的场景，可以有两种方案：</p><p>在子组件的 data 中拷贝一份 prop，data 是可以修改的，但 prop 不能：</p><p>exportdefault{props: {value:String}, data () {return{currentValue:this.value  } }}复制代码</p><p>如果是对 prop 值的转换，可以使用计算属性：</p><p>exportdefault{props: [‘size’],computed: {normalizedSize:function(){returnthis.size.trim().toLowerCase();  } }}</p><h3 id="6-简述vue的状态管理并说明你在项目中哪些地方使用了"><a href="#6-简述vue的状态管理并说明你在项目中哪些地方使用了" class="headerlink" title="6.简述vue的状态管理并说明你在项目中哪些地方使用了"></a>6.简述vue的状态管理并说明你在项目中哪些地方使用了</h3><p>component通过mapactions或者dispatch将方法类型和负载传给actions，actions接收到后进行业务处理通过commit将处理后的类型和负载传给mutations，mutations不做业务处理，只根据接收的类型和负载将state中的数据进行突变，component通过mapgetters拿到更新后的仓库数据。</p><p>在组件中用mapactions接管methods方法，用mapgetters接收computed计算属性，这样主要是为了action更简洁，便于后期迭代更新。以下通过官网例子进行加深理解：</p><p><img src="/img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/6797393-a57ddd52f9f57073.png" alt="img"></p><p><img src="/img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/6797393-2507d7d00b4612b0.png" alt="img"></p><p><img src="/img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/6797393-955763ea0ba27a20.png" alt="img"></p><p><img src="/img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/6797393-051fac1509247c81.png" alt="img"></p><p><img src="/img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/6797393-49e7ee0d2466c4d7.png" alt="img"></p><p><img src="/img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/6797393-dde6ffc92fd4f7a2.png" alt="img"></p><p><img src="/img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/6797393-25b34adb24f79219.png" alt="img"></p><p><img src="/img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/6797393-8e4666029b755c33.gif" alt="img"></p><h3 id="7-简述下生命周期钩子"><a href="#7-简述下生命周期钩子" class="headerlink" title="7.简述下生命周期钩子"></a>7.简述下生命周期钩子</h3><p>vue实例从创建到销毁的过程，就是生命周期。从开始创建，初始化数据，编译模板，挂载DOM，渲染，更新再渲染，最后到销毁等一系列过程就是生命周期。</p><p><strong>beforeCreate</strong>：数据观测和初始化事件还没开始</p><p><strong>Created</strong>：完成数据观测，属性和方法的运算，初始化事件，$el属性还没显示出来</p><p>beforeMount：挂载前调用，相关的render第一次调用。实例已经完成编译模板，<strong>data里的数据和模板已经生成HTML，但没有讲HTML挂载到页面上</strong></p><p><strong>Mounted：el被新创建的Vm.$el替换，并挂载到实例上面调用。实例已经完成以下配置：用上面编译好的HTML内容替换el属性指向DOM元素。完成模板中HTML渲染到HTML页面中。此过程进行ajax交互。</strong></p><p><strong>beforeUpdate</strong>:发生在虚拟dom和打补丁之前，可以在该钩子中进一步修改状态，不会触发附加的冲渲染过程。</p><p><strong>Updated</strong>：由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</p><p><strong>beforeDestroy</strong>（销毁前） 在实例销毁之前调用。实例仍然完全可用。</p><p><strong>destroyed</strong>（销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</p><h3 id="8-组件中如何通信"><a href="#8-组件中如何通信" class="headerlink" title="8.组件中如何通信"></a>8.组件中如何通信</h3><p><strong>九叔说要讲半小时左右：。。。。</strong></p><p>父到子：</p><p>传&lt;子组件 :自定义属性=“父数据”&gt;</p><p>收：子组件选项props：【‘自定义属性’】</p><p>子到父：</p><p>父组件向子组件传递事件方法，子组件通过$emit触发事件，回调给父组件</p><p>非父子，兄弟组件通讯：</p><p>可以通过实例一个vue实例Bus作为媒介，要相互通信的兄弟组件之中，都引入Bus，然后通过分别调用Bus事件触发和监听来实现通信和参数传递。</p><p><a href="https://www.jianshu.com/p/949b4ecf1cba">组件通讯更详细解释</a></p><h3 id="9-路由守卫是什么，有几种方式"><a href="#9-路由守卫是什么，有几种方式" class="headerlink" title="9.路由守卫是什么，有几种方式"></a>9.路由守卫是什么，有几种方式</h3><p>全局守卫，路由独享守卫，组件内部守卫；</p><h4 id="全局守卫："><a href="#全局守卫：" class="headerlink" title="全局守卫："></a>全局守卫：</h4><p>router.beforeRouteEnter(to,from,next){前置守卫，进入}</p><p>router.beforeRouterLeave(to,from,next){后置守卫，离开}</p><p>to 目标路由 from  当前路由 </p><p>next函数：next() == next(true) 运行跳转</p><p>  next(false) 不让跳转</p><p>  next(‘字符路径’)/next({对象路径}) 重定向</p><h4 id="路由独享守卫：没有后置守卫"><a href="#路由独享守卫：没有后置守卫" class="headerlink" title="路由独享守卫：没有后置守卫"></a>路由独享守卫：没有后置守卫</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   path: &apos;/foo&apos;,</span><br><span class="line">   component: Foo,</span><br><span class="line">   beforeEnter: (to, from, next) =&gt; &#123;</span><br><span class="line">   // ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组件内部守卫："><a href="#组件内部守卫：" class="headerlink" title="组件内部守卫："></a>组件内部守卫：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const Foo = &#123;</span><br><span class="line">template: `...`,</span><br><span class="line"> beforeRouteEnter (to, from, next) &#123; 前置</span><br><span class="line">  // 在渲染该组件的对应路由被 confirm 前调用</span><br><span class="line">  // 不！能！获取组件实例 `this`</span><br><span class="line">  // 因为当守卫执行前，组件实例还没被创建</span><br><span class="line"> &#125;,</span><br><span class="line"> beforeRouteLeave (to, from, next) &#123; 后置</span><br><span class="line">  // 导航离开该组件的对应路由时调用</span><br><span class="line">  // 可以访问组件实例 `this`</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-vue的优化"><a href="#10-vue的优化" class="headerlink" title="10.vue的优化"></a>10.vue的优化</h3><p>不支持低版本的浏览器，最低只支持到IE9；</p><p>不利于SEO的优化（如果要支持SEO，建议通过服务端来进行渲染组件）；</p><p>第一次加载首页耗时相对长一些；</p><p>不可以使用浏览器的导航按钮需要自行实现前进、后退</p><h3 id="11-什么是插槽或内容分发-，插槽有几种方式"><a href="#11-什么是插槽或内容分发-，插槽有几种方式" class="headerlink" title="11.什么是插槽或内容分发 ，插槽有几种方式"></a>11.什么是插槽或内容分发 ，插槽有几种方式</h3><p>组件内部保留槽位:</p><p>具名槽位:&lt;slot name=槽名</p><p>匿名槽位: <slot>&lt;/..&gt;</p><p>调用组件插入内容: 内容 == dom | 组件</p><p>&lt;组件名&gt;</p><p>&lt;template #槽名&gt; 内容 | &lt;组件名&gt;</p><p>&lt;template v-slot:槽名&gt;内容</p><p>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译</p><h3 id="12-简述下mvvm和MVC"><a href="#12-简述下mvvm和MVC" class="headerlink" title="12.简述下mvvm和MVC"></a>12.简述下mvvm和MVC</h3><h4 id="MVC："><a href="#MVC：" class="headerlink" title="MVC："></a>MVC：</h4><p><img src="/img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/6797393-9cbf57574f7571af.png" alt="img"></p><p>1.View 传送指令到 Controller</p><p>2.Controller 完成业务逻辑后，要求 Model 改变状态</p><p>3.Model 将新的数据发送到 View，用户得到反馈</p><h4 id="MVP："><a href="#MVP：" class="headerlink" title="MVP："></a>MVP：</h4><p><img src="/img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/6797393-0154726ea6e7faca.png" alt="img"></p><ol><li><p>各部分之间的通信，都是双向的。</p></li><li><p>View 与 Model 不发生联系，都通过 Presenter 传递。</p></li><li><p>View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。</p></li></ol><h4 id="MVVM："><a href="#MVVM：" class="headerlink" title="MVVM："></a>MVVM：</h4><p><img src="/img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/6797393-ac12fffcfb5d1e01.png" alt="img"></p><p>和MVP很像，采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然</p><h3 id="13-路由懒加载，异步路由，分片打包"><a href="#13-路由懒加载，异步路由，分片打包" class="headerlink" title="13.路由懒加载，异步路由，分片打包"></a>13.路由懒加载，异步路由，分片打包</h3><p>原理: 把组件封装到一个函数内部，路由激活时，调用该函数，函数内部 异步加载目标组件并返回</p><p>路由配置router.js:</p><p>a)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\- import home from &quot;../components/home.vue&quot;</span><br><span class="line">\+ const home =()=&gt;import(&quot;../components/home.vue&quot;);</span><br><span class="line">&#123;path:&apos;/home&apos;, component: home &#125;</span><br></pre></td></tr></table></figure><p>b)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;path:xxx, component: r =&gt; &#123; require([&apos;./login/Login&apos;], r) &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="17-如何自定义事件"><a href="#17-如何自定义事件" class="headerlink" title="17.如何自定义事件"></a>17.如何自定义事件</h3><p>定义：vm.$on( ‘自定义事件名’|[‘自定义事件名1’,’自定义事件名2’], 回调(参数) )</p><p>销毁：vm.$off( ‘自定义事件名’|[‘自定义事件名1’,’自定义事件名2’], 回调(参数) )</p><p>触发: vm.$emit(自定义事件名1,参数)</p><p>自定义事件名：    使用 kebab-case 的事件名</p><p>场景： 在一个组件实例上手动侦听事件时</p><h3 id="18-懒加载，按需加载，点击加载，滑动加载"><a href="#18-懒加载，按需加载，点击加载，滑动加载" class="headerlink" title="18.懒加载，按需加载，点击加载，滑动加载"></a>18.懒加载，按需加载，点击加载，滑动加载</h3><p>把组件加载封装在一个函数中，路由激活的时候调用这个函数，这个函数在运行的时候去加载这个组件。加载用import或者requireAPI</p><h3 id="19-如何更改计算属性并响应式"><a href="#19-如何更改计算属性并响应式" class="headerlink" title="19.如何更改计算属性并响应式"></a>19.如何更改计算属性并响应式</h3><p>计算属性的set方法</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/6797393-fe84a1036e98d526.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/6797393-d9da215d3b550120.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p><img src="/img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/6797393-5d807cbefdc80442.png" alt="img"></p><h3 id="20-vue的diff算法"><a href="#20-vue的diff算法" class="headerlink" title="20.vue的diff算法"></a>20.vue的diff算法</h3><p>突然发现弄懂这个就不是初级了。。。</p><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fxn--8nr082bujt19l%2F">https://juejin.im/post/5c97002b6fb9a070aa5cf60b</a></p><h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><p>vue项目作为一个单页面应用，如果不对路由进行处理，在加载首页的时候，就会将所有组件全部加载，并向服务器请求数据，这必将拖慢加载速度；当打包构建应用时，Javascript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。</p><h3 id="图片资源的压缩"><a href="#图片资源的压缩" class="headerlink" title="图片资源的压缩"></a>图片资源的压缩</h3><p>严格说来这一步不算在编码技术范围内，但是却对页面的加载速度影响很大，特别是对于移动端的项目来说。</p><p>对于非logo的图片文件，让UI设计师提供jpg格式的，不要用png</p><p>对于所有的图片文件，都可以在一个叫tinypng的网站上去压缩一下或采用webpack插件进行压缩</p><p>使用cdn</p><p>在Vue项目中，引入到工程中的所有js、css文件，编译时都会被打包进vendor.js，浏览器在加载该文件之后才能开始显示首屏。若是引入的库众多，那么vendor.js文件体积将会相当的大，影响首开的体验。</p><p>解决方法是，将引用的外部js、css文件剥离开来，不编译到vendor.js中，而是用资源的形式引用，这样浏览器可以使用多个线程异步将vendor.js、外部的js等加载下来，达到加速首开的目的。</p><p>外部的库文件，可以使用CDN资源，或者别的服务器资源等。</p><h3 id="详述虚拟DOM"><a href="#详述虚拟DOM" class="headerlink" title="详述虚拟DOM"></a>详述虚拟DOM</h3><h4 id="第一种："><a href="#第一种：" class="headerlink" title="第一种："></a>第一种：</h4><p>1、state数据</p><p>2、JSX模板</p><p>3、 数据 + 模板 结合，生成真实的DOM -&gt; 视图</p><p>4、state发生了变化</p><p>5、数据 + 模板 结合，生成真实的DOM，替换原始的DOM</p><p>缺陷：</p><p>1、第一次生成了完整的DOM片段</p><p>2、第二次生成了完整的DOM片段</p><p>3、第二次的DOM替换第一次的DOM，非常耗费性能</p><h4 id="第二种："><a href="#第二种：" class="headerlink" title="第二种："></a>第二种：</h4><p>1、state数据</p><p>2、JSX模板</p><p>3、数据 + 模板 结合， 生成真实的DOM -&gt; 视图</p><p>4、state发生变化</p><p>5、数据 + 模板 结合，生成真实的DOM，并不直接替换原始的DOM</p><p>6、新的DOM（DocumentFragment）和原始的DOM做比对，找差异</p><p>7、找出input框发生了变化</p><p>8、只用新的DOM中的input元素，替换掉老的DOM中input元素</p><p>缺陷：</p><p>虽然DOM只是局部替换，但是在比对时候的计算是比较耗费性能的，因此，性能的提升并不明显</p><h4 id="第三种："><a href="#第三种：" class="headerlink" title="第三种："></a>第三种：</h4><p>1、state数据</p><p>2、JSX模板</p><p>3、数据 + 模板 生成虚拟DOM(虚拟DOM就是一个JS对象，用它来描述真实DOM)（损耗一点性能）</p><p>虚拟DOM：[‘div’, {id: ‘abc’}, [‘span’, ‘’, ‘hello world’]]</p><p>4、用虚拟DOM的结构生成真实的DOM -&gt; 视图显示</p><p>真实DOM：</p><p>5、state发生了变化</p><p>6、数据 + 模板 生成新的虚拟DOM：[‘div’, {id: ‘abc’}, [‘span’, ‘’, ‘hi world’]]（极大提升性能）</p><p>7、比较原始虚拟DOM和新的虚拟DOM的区别，找到的区别是span中的内容发生了变化（极大提升了性能）</p><p>8、直接操作DOM，改变span中的内容</p><p>总结：</p><p>减少了真实DOM的创建及对比，创建都是JS对象，对比的也都是JS的对象，在JS底层实现了极大的性能飞越</p><p>组件生成流程：</p><p>JSX -&gt; JS对象(虚拟DOM) -&gt; 真实的DOM</p><p>用React.createElement改写JSX模板：</p><p>JSX：return</p><p>{ item }</p><p>JSX -&gt; JS对象(虚拟DOM) -&gt; 真实的DOM</p><p>React.createElement(‘div’, {}, React.createElement(‘span’, {}, ‘item’))</p><p>JSX -&gt; createElement -&gt; JS对象(虚拟DOM) -&gt; 真实的DOM</p><h3 id="虚拟DOM优点："><a href="#虚拟DOM优点：" class="headerlink" title="虚拟DOM优点："></a>虚拟DOM优点：</h3><p>1、性能提升了</p><p>2、它使得跨端应用得以实现，Ract Native</p><p>React可以写原生应用了，得益于React中的虚拟DOM，如果没有虚拟DOM是不能写原生应用的。原生系统是不支持DOM不存在DOm这个概念的，但是支持虚拟DOM（虚拟DOM就是一个JS对象）；虚拟DOM可以在浏览器端被解析为真实的DOM，在原生端可以被解析原生所支持的组件等格式</p><h3 id="详述虚拟DOM中的diff算法"><a href="#详述虚拟DOM中的diff算法" class="headerlink" title="详述虚拟DOM中的diff算法"></a>详述虚拟DOM中的diff算法</h3><p>虚拟DOM对比时，会用到diff算法</p><p>虚拟DOM什么时候会被比对？</p><p>当数据发生变化的时候就会被比对</p><p>那什么时候数据会发生改变呢？</p><p>要么改变了state，要么改变了props（props的改变其实是他的父组件的state发生了改变）</p><p>setState方法，其实是异步的，为什么是异步的？实际为了提升React底层的性能，假设：调用三次setState变更三组数据，大家想页面会怎么做或者说React会怎么做？我们想的是React可能会做三次比对更新三次视图。又假设三次更新间隔非常小，这样会耗费性能，React可以把三次合并为一次，只去做一次虚拟DOM的比对，然后更新一次视图，这样的话就可以省去两次比对性能上的耗费。</p><h3 id="1、说说你对-SPA-单页面的理解，它的优缺点分别是什么？"><a href="#1、说说你对-SPA-单页面的理解，它的优缺点分别是什么？" class="headerlink" title="1、说说你对 SPA 单页面的理解，它的优缺点分别是什么？"></a>1、说说你对 SPA 单页面的理解，它的优缺点分别是什么？</h3><p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p><p><strong>优点：</strong></p><ul><li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li><li>基于上面一点，SPA 相对对服务器压力小；</li><li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li></ul><p><strong>缺点：</strong></p><ul><li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li><li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li><li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li></ul><h3 id="2、v-show-与-v-if-有什么区别？"><a href="#2、v-show-与-v-if-有什么区别？" class="headerlink" title="2、v-show 与 v-if 有什么区别？"></a>2、v-show 与 v-if 有什么区别？</h3><p><strong>v-if</strong> 是<strong>真正</strong>的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p><strong>v-show</strong> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。</p><p>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p><h3 id="3、Class-与-Style-如何动态绑定？"><a href="#3、Class-与-Style-如何动态绑定？" class="headerlink" title="3、Class 与 Style 如何动态绑定？"></a>3、Class 与 Style 如何动态绑定？</h3><p>Class 可以通过对象语法和数组语法进行动态绑定：</p><ul><li>对象语法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;&#123; active: isActive, &apos;text-danger&apos;: hasError &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  isActive: true,</span><br><span class="line">  hasError: false</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>数组语法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;[isActive ? activeClass : &apos;&apos;, errorClass]&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  activeClass: &apos;active&apos;,</span><br><span class="line">  errorClass: &apos;text-danger&apos;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>Style 也可以通过对象语法和数组语法进行动态绑定：</p><ul><li>对象语法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  activeColor: &apos;red&apos;,</span><br><span class="line">  fontSize: 30</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>数组语法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;[styleColor, styleSize]&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  styleColor: &#123;</span><br><span class="line">     color: &apos;red&apos;</span><br><span class="line">   &#125;,</span><br><span class="line">  styleSize:&#123;</span><br><span class="line">     fontSize:&apos;23px&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="4、怎样理解-Vue-的单向数据流？"><a href="#4、怎样理解-Vue-的单向数据流？" class="headerlink" title="4、怎样理解 Vue 的单向数据流？"></a>4、怎样理解 Vue 的单向数据流？</h3><p>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p><p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p><p>有两种常见的试图改变一个 prop 的情形 :</p><ul><li><strong>这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。</strong> 在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">props: [&apos;initialCounter&apos;],</span><br><span class="line">data: function () &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    counter: this.initialCounter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><strong>这个 prop 以一种原始的值传入且需要进行转换。</strong> 在这种情况下，最好使用这个 prop 的值来定义一个计算属性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">props: [&apos;size&apos;],</span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedSize: function () &#123;</span><br><span class="line">    return this.size.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="5、computed-和-watch-的区别和运用的场景？"><a href="#5、computed-和-watch-的区别和运用的场景？" class="headerlink" title="5、computed 和 watch 的区别和运用的场景？"></a>5、computed 和 watch 的区别和运用的场景？</h3><p><strong>computed：</strong> 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed  的值；</p><p><strong>watch：</strong> 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p><p><strong>运用场景：</strong></p><ul><li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</li><li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li></ul><h3 id="7、谈谈你对-Vue-生命周期的理解？"><a href="#7、谈谈你对-Vue-生命周期的理解？" class="headerlink" title="7、谈谈你对 Vue 生命周期的理解？"></a>7、谈谈你对 Vue 生命周期的理解？</h3><p><strong>（1）生命周期是什么？</strong></p><p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p><p><strong>（2）各个生命周期的作用</strong></p><table><thead><tr><th>生命周期</th><th>描述</th></tr></thead><tbody><tr><td>beforeCreate</td><td>组件实例被创建之初，组件的属性生效之前</td></tr><tr><td>created</td><td>组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用</td></tr><tr><td>beforeMount</td><td>在挂载开始之前被调用：相关的 render 函数首次被调用</td></tr><tr><td>mounted</td><td>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</td></tr><tr><td>beforeUpdate</td><td>组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td></tr><tr><td>update</td><td>组件数据更新之后</td></tr><tr><td>activited</td><td>keep-alive 专属，组件被激活时调用</td></tr><tr><td>deactivated</td><td>keep-alive 专属，组件被销毁时调用</td></tr><tr><td>beforeDestory</td><td>组件销毁前调用</td></tr><tr><td>destoryed</td><td>组件销毁后调用</td></tr></tbody></table><p><strong>（3）生命周期示意图</strong></p><p><img src="/img/loading.gif" data-original="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/19/16ca74f183827f46~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="1.png"></p><h3 id="8、Vue-的父组件和子组件生命周期钩子函数执行顺序？"><a href="#8、Vue-的父组件和子组件生命周期钩子函数执行顺序？" class="headerlink" title="8、Vue 的父组件和子组件生命周期钩子函数执行顺序？"></a>8、Vue 的父组件和子组件生命周期钩子函数执行顺序？</h3><p>Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</p><ul><li><p>加载渲染过程</p><p>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p></li><li><p>子组件更新过程</p><p>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p></li><li><p>父组件更新过程</p><p>父 beforeUpdate -&gt; 父 updated</p></li><li><p>销毁过程</p><p>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p></li></ul><h3 id="9、在哪个生命周期内调用异步请求？"><a href="#9、在哪个生命周期内调用异步请求？" class="headerlink" title="9、在哪个生命周期内调用异步请求？"></a>9、在哪个生命周期内调用异步请求？</h3><p>可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p><ul><li>能更快获取到服务端数据，减少页面 loading 时间；</li><li>ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</li></ul><h3 id="10、在什么阶段才能访问操作DOM？"><a href="#10、在什么阶段才能访问操作DOM？" class="headerlink" title="10、在什么阶段才能访问操作DOM？"></a>10、在什么阶段才能访问操作DOM？</h3><p>在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 DOM。vue 具体的生命周期示意图可以参见如下，理解了整个生命周期各个阶段的操作，关于生命周期相关的面试题就难不倒你了。</p><p><img src="/img/loading.gif" data-original="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/19/16ca74f183827f46~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="1.png"></p><h3 id="11、父组件可以监听到子组件的生命周期吗？"><a href="#11、父组件可以监听到子组件的生命周期吗？" class="headerlink" title="11、父组件可以监听到子组件的生命周期吗？"></a>11、父组件可以监听到子组件的生命周期吗？</h3><p>比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Parent.vue</span><br><span class="line">&lt;Child @mounted=&quot;doSomething&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">// Child.vue</span><br><span class="line">mounted() &#123;</span><br><span class="line">  this.$emit(&quot;mounted&quot;);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//  Parent.vue</span><br><span class="line">&lt;Child @hook:mounted=&quot;doSomething&quot; &gt;&lt;/Child&gt;</span><br><span class="line"></span><br><span class="line">doSomething() &#123;</span><br><span class="line">   console.log(&apos;父组件监听到 mounted 钩子函数 ...&apos;);</span><br><span class="line">&#125;,</span><br><span class="line">    </span><br><span class="line">//  Child.vue</span><br><span class="line">mounted()&#123;</span><br><span class="line">   console.log(&apos;子组件触发 mounted 钩子函数 ...&apos;);</span><br><span class="line">&#125;,    </span><br><span class="line">    </span><br><span class="line">// 以上输出顺序为：</span><br><span class="line">// 子组件触发 mounted 钩子函数 ...</span><br><span class="line">// 父组件监听到 mounted 钩子函数 ...     </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。</p><h3 id="12、谈谈你对-keep-alive-的了解？"><a href="#12、谈谈你对-keep-alive-的了解？" class="headerlink" title="12、谈谈你对 keep-alive 的了解？"></a>12、谈谈你对 keep-alive 的了解？</h3><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染DOM ，其有以下特性：</p><ul><li>一般结合路由和动态组件一起使用，用于缓存组件；</li><li>&lt; keep-alive &gt; 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。</li><li>提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；</li><li>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</li></ul><h3 id="13、组件中-data-为什么是一个函数？"><a href="#13、组件中-data-为什么是一个函数？" class="headerlink" title="13、组件中 data 为什么是一个函数？"></a>13、组件中 data 为什么是一个函数？</h3><blockquote><p>为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// data</span><br><span class="line">data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">message: &quot;子组件&quot;,</span><br><span class="line">childName:this.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// new Vue</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  router,</span><br><span class="line">  template: &apos;&lt;App/&gt;&apos;,</span><br><span class="line">  components: &#123;App&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。</p><h3 id="14、v-model-的原理？"><a href="#14、v-model-的原理？" class="headerlink" title="14、v-model 的原理？"></a>14、v-model 的原理？</h3><p>我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p><ul><li>text 和 textarea 元素使用 value 属性和 input 事件；</li><li>checkbox 和 radio 使用 checked 属性和 change 事件；</li><li>select 字段将 value 作为 prop 并将 change 作为事件。</li></ul><p>以 input  表单元素为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=&apos;something&apos;&gt;</span><br><span class="line">    </span><br><span class="line">相当于</span><br><span class="line"></span><br><span class="line">&lt;input v-bind:value=&quot;something&quot; v-on:input=&quot;something = $event.target.value&quot;&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">父组件：</span><br><span class="line">&lt;ModelChild v-model=&quot;message&quot;&gt;&lt;/ModelChild&gt;</span><br><span class="line"></span><br><span class="line">子组件：</span><br><span class="line">&lt;div&gt;&#123;&#123;value&#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">props:&#123;</span><br><span class="line">    value: String</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  test1()&#123;</span><br><span class="line">     this.$emit(&apos;input&apos;, &apos;小红&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="15、Vue-组件间通信有哪几种方式？"><a href="#15、Vue-组件间通信有哪几种方式？" class="headerlink" title="15、Vue 组件间通信有哪几种方式？"></a>15、Vue 组件间通信有哪几种方式？</h3><p>Vue 组件间通信是面试常考的知识点之一，这题有点类似于开放题，你回答出越多方法当然越加分，表明你对 Vue 掌握的越熟练。Vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。</p><p><strong>（1）<code>props / $emit</code>  适用 父子组件通信</strong></p><p>这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。</p><p><strong>（2）<code>ref</code> 与 <code>$parent / $children</code> 适用 父子组件通信</strong></p><ul><li><code>ref</code>：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</li><li><code>$parent</code> / <code>$children</code>：访问父 / 子实例</li></ul><p><strong>（3）<code>EventBus （$emit / $on）</code>  适用于 父子、隔代、兄弟组件通信</strong></p><p>这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。</p><p><strong>（4）<code>$attrs</code>/<code>$listeners</code> 适用于 隔代组件通信</strong></p><ul><li><code>$attrs</code>：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 <code>v-bind=&quot;$attrs&quot;</code> 传入内部组件。通常配合 inheritAttrs 选项一起使用。</li><li><code>$listeners</code>：包含了父作用域中的 (不含 .native 修饰器的)  v-on 事件监听器。它可以通过 <code>v-on=&quot;$listeners&quot;</code> 传入内部组件</li></ul><p><strong>（5）<code>provide / inject</code> 适用于 隔代组件通信</strong></p><p>祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。 provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。</p><p><strong>（6）Vuex  适用于 父子、隔代、兄弟组件通信</strong></p><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p><ul><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><li>改变 store 中的状态的唯一途径就是显式地提交  (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</li></ul><h3 id="16、你使用过-Vuex-吗？"><a href="#16、你使用过-Vuex-吗？" class="headerlink" title="16、你使用过 Vuex 吗？"></a>16、你使用过 Vuex 吗？</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p><p>（1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p><p>（2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</p><p>主要包括以下几个模块：</p><ul><li>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li><li>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li><li>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。</li><li>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</li><li>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</li></ul><h3 id="17、使用过-Vue-SSR-吗？说说-SSR？"><a href="#17、使用过-Vue-SSR-吗？说说-SSR？" class="headerlink" title="17、使用过 Vue SSR 吗？说说 SSR？"></a>17、使用过 Vue SSR 吗？说说 SSR？</h3><blockquote><p>Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。</p><p>即：SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。</p></blockquote><p><strong>服务端渲染 SSR 的优缺点如下：</strong></p><p><strong>（1）服务端渲染的优点：</strong></p><ul><li>更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</li><li>更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；</li></ul><p><strong>（2) 服务端渲染的缺点：</strong></p><ul><li>更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</li><li>更多的服务器负载：在 Node.js  中渲染完整的应用程序，显然会比仅仅提供静态文件的  server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</li></ul><p>如果没有 SSR 开发经验的同学，可以参考本文作者的另一篇 SSR 的实践文章<a href="https://juejin.cn/post/6844903824956588040">《Vue SSR 踩坑之旅》</a>，里面 SSR 项目搭建以及附有项目源码。</p><h3 id="18、vue-router-路由模式有几种？"><a href="#18、vue-router-路由模式有几种？" class="headerlink" title="18、vue-router 路由模式有几种？"></a>18、vue-router 路由模式有几种？</h3><p>vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">switch (mode) &#123;</span><br><span class="line">  case &apos;history&apos;:</span><br><span class="line">this.history = new HTML5History(this, options.base)</span><br><span class="line">break</span><br><span class="line">  case &apos;hash&apos;:</span><br><span class="line">this.history = new HashHistory(this, options.base, this.fallback)</span><br><span class="line">break</span><br><span class="line">  case &apos;abstract&apos;:</span><br><span class="line">this.history = new AbstractHistory(this, options.base)</span><br><span class="line">break</span><br><span class="line">  default:</span><br><span class="line">if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">  assert(false, `invalid mode: $&#123;mode&#125;`)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>其中，3 种路由模式的说明如下：</p><ul><li>hash:  使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；</li><li>history :  依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；</li><li>abstract :  支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</li></ul><h3 id="19、能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？"><a href="#19、能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？" class="headerlink" title="19、能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？"></a>19、能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？</h3><p><strong>（1）hash 模式的实现原理</strong></p><p>早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 ‘#search’：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://www.word.com#search</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>hash  路由模式的实现主要是基于下面几个特性：</p><ul><li>URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；</li><li>hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；</li><li>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用  JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；</li><li>我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。</li></ul><p><strong>（2）history 模式的实现原理</strong></p><p>HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.history.pushState(null, null, path);</span><br><span class="line">window.history.replaceState(null, null, path);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>history 路由模式的实现主要基于存在下面几个特性：</p><ul><li>pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；</li><li>我们可以使用 popstate  事件来监听 url 的变化，从而对页面进行跳转（渲染）；</li><li>history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。</li></ul><h3 id="20、什么是-MVVM？"><a href="#20、什么是-MVVM？" class="headerlink" title="20、什么是 MVVM？"></a>20、什么是 MVVM？</h3><p>Model–View–ViewModel （MVVM） 是一个软件架构设计模式，由微软 WPF 和 Silverlight 的架构师 Ken Cooper 和 Ted Peters 开发，是一种简化用户界面的事件驱动编程方式。由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于2005年在他的博客上发表</p><p>MVVM 源自于经典的 Model–View–Controller（MVC）模式  ，MVVM 的出现促进了前端开发与后端业务逻辑的分离，极大地提高了前端开发效率，MVVM 的核心是 ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。如下图所示：</p><p><img src="/img/loading.gif" data-original="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/19/16ca75871ec53fba~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="1.png"></p><p>（1）View 层</p><p>View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。</p><p>（2）Model 层</p><p>Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。</p><p>（3）ViewModel 层</p><p>ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的，比如页面的这一块展示什么，而页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互），视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。</p><p>MVVM 框架实现了双向绑定，这样 ViewModel 的内容会实时展现在 View 层，前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新。这样 View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。</p><p>我们以下通过一个 Vue 实例来说明 MVVM 的具体实现，有 Vue 开发经验的同学应该一目了然：</p><p>（1）View 层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button v-on:click=&quot;showMessage()&quot;&gt;Click me&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>（2）ViewModel 层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var app = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data: &#123;  // 用于描述视图状态   </span><br><span class="line">        message: &apos;Hello Vue!&apos;, </span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;  // 用于描述视图行为  </span><br><span class="line">        showMessage()&#123;</span><br><span class="line">            let vm = this;</span><br><span class="line">            alert(vm.message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created()&#123;</span><br><span class="line">        let vm = this;</span><br><span class="line">        // Ajax 获取 Model 层的数据</span><br><span class="line">        ajax(&#123;</span><br><span class="line">            url: &apos;/your/server/data/api&apos;,</span><br><span class="line">            success(res)&#123;</span><br><span class="line">                vm.message = res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>（3） Model 层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;url&quot;: &quot;/your/server/data/api&quot;,</span><br><span class="line">    &quot;res&quot;: &#123;</span><br><span class="line">        &quot;success&quot;: true,</span><br><span class="line">        &quot;name&quot;: &quot;IoveC&quot;,</span><br><span class="line">        &quot;domain&quot;: &quot;www.cnblogs.com&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="21、Vue-是如何实现数据双向绑定的？"><a href="#21、Vue-是如何实现数据双向绑定的？" class="headerlink" title="21、Vue 是如何实现数据双向绑定的？"></a>21、Vue 是如何实现数据双向绑定的？</h3><p>Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据，如下图所示：</p><p><img src="/img/loading.gif" data-original="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/19/16ca75871f2e5f80~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="1.png"></p><p>即：</p><ul><li>输入框内容变化时，Data 中的数据同步变化。即 View =&gt; Data 的变化。</li><li>Data 中的数据变化时，文本节点的内容同步变化。即 Data =&gt; View 的变化。</li></ul><p>其中，View 变化更新 Data ，可以通过事件监听的方式来实现，所以 Vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View。</p><p>Vue 主要通过以下 4 个步骤来实现数据双向绑定的：</p><p>实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。</p><p>实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。</p><p>实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。</p><p>实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。</p><p>以上四个步骤的流程图表示如下，如果有同学理解不大清晰的，可以查看作者专门介绍数据双向绑定的文章<a href="https://juejin.cn/post/6844903903822086151">《0 到 1 掌握：Vue 核心之数据双向绑定》</a>，有进行详细的讲解、以及代码 demo 示例。</p><p><img src="/img/loading.gif" data-original="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/19/16ca75871f729d89~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="1.png"></p><h3 id="22、Vue-框架怎么实现对象和数组的监听？"><a href="#22、Vue-框架怎么实现对象和数组的监听？" class="headerlink" title="22、Vue 框架怎么实现对象和数组的监听？"></a>22、Vue 框架怎么实现对象和数组的监听？</h3><p>如果被问到 Vue 怎么实现数据双向绑定，大家肯定都会回答 通过 Object.defineProperty() 对数据进行劫持，但是  Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持，同理无法对数组进行劫持，但是我们在使用 Vue 框架中都知道，Vue 能检测到对象和数组（部分方法的操作）的变化，那它是怎么实现的呢？我们查看相关代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line">   * Observe a list of Array items.</span><br><span class="line">   */</span><br><span class="line">  observeArray (items: Array&lt;any&gt;) &#123;</span><br><span class="line">    for (let i = 0, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i])  // observe 功能为监测数据的变化</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 对属性进行递归遍历</span><br><span class="line">   */</span><br><span class="line">  let childOb = !shallow &amp;&amp; observe(val) // observe 功能为监测数据的变化</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>通过以上 Vue 源码部分查看，我们就能知道 Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用  Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。</p><h3 id="23、Proxy-与-Object-defineProperty-优劣对比"><a href="#23、Proxy-与-Object-defineProperty-优劣对比" class="headerlink" title="23、Proxy 与 Object.defineProperty 优劣对比"></a>23、Proxy 与 Object.defineProperty 优劣对比</h3><p><strong>Proxy 的优势如下:</strong></p><ul><li>Proxy 可以直接监听对象而非属性；</li><li>Proxy 可以直接监听数组的变化；</li><li>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；</li><li>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；</li><li>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；</li></ul><p><strong>Object.defineProperty 的优势如下:</strong></p><ul><li>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。</li></ul><h3 id="25、虚拟-DOM-的优缺点？"><a href="#25、虚拟-DOM-的优缺点？" class="headerlink" title="25、虚拟 DOM 的优缺点？"></a>25、虚拟 DOM 的优缺点？</h3><p><strong>优点：</strong></p><ul><li><strong>保证性能下限：</strong> 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</li><li><strong>无需手动操作 DOM：</strong> 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</li><li><strong>跨平台：</strong> 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</li></ul><p><strong>缺点:</strong></p><ul><li><strong>无法进行极致优化：</strong> 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。</li></ul><h3 id="26、虚拟-DOM-实现原理？"><a href="#26、虚拟-DOM-实现原理？" class="headerlink" title="26、虚拟 DOM 实现原理？"></a>26、虚拟 DOM 实现原理？</h3><p>虚拟 DOM 的实现原理主要包括以下 3 部分：</p><ul><li>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；</li><li>diff 算法 — 比较两棵虚拟 DOM 树的差异；</li><li>pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</li></ul><p>如果对以上 3 个部分还不是很了解的同学，可以查看本文作者写的另一篇详解虚拟 DOM 的文章《<a href="https://juejin.cn/post/6844903895467032589#heading-14">深入剖析：Vue核心之虚拟DOM</a>》</p><h3 id="27、Vue-中的-key-有什么作用？"><a href="#27、Vue-中的-key-有什么作用？" class="headerlink" title="27、Vue 中的 key 有什么作用？"></a>27、Vue 中的 key 有什么作用？</h3><p>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。Vue 的 diff 过程可以概括为：oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex 和 newStartIndex、newEndIndex，它们会新节点和旧节点会进行两两对比，即一共有4种比较方式：newStartIndex 和oldStartIndex 、newEndIndex 和  oldEndIndex 、newStartIndex 和 oldEndIndex 、newEndIndex 和 oldStartIndex，如果以上 4 种比较都没匹配，如果设置了key，就会用 key 再进行比较，在比较的过程中，遍历会往中间靠，一旦 StartIdx &gt; EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。具体有无 key 的 diff 过程，可以查看作者写的另一篇详解虚拟 DOM 的文章《<a href="https://juejin.cn/post/6844903895467032589#heading-14">深入剖析：Vue核心之虚拟DOM</a>》</p><p>所以 Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速</p><p><strong>更准确</strong>：因为带 key 就不是就地复用了，在 sameNode 函数 <code>a.key === b.key</code> 对比中可以避免就地复用的情况。所以会更加准确。</p><p><strong>更快速</strong>：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快，源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function createKeyToOldIdx (children, beginIdx, endIdx) &#123;</span><br><span class="line">  let i, key</span><br><span class="line">  const map = &#123;&#125;</span><br><span class="line">  for (i = beginIdx; i &lt;= endIdx; ++i) &#123;</span><br><span class="line">    key = children[i].key</span><br><span class="line">    if (isDef(key)) map[key] = i</span><br><span class="line">  &#125;</span><br><span class="line">  return map</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="28、你有对-Vue-项目进行哪些优化？"><a href="#28、你有对-Vue-项目进行哪些优化？" class="headerlink" title="28、你有对 Vue 项目进行哪些优化？"></a>28、你有对 Vue 项目进行哪些优化？</h3><p>如果没有对 Vue 项目没有进行过优化总结的同学，可以参考本文作者的另一篇文章<a href="https://juejin.cn/post/6844903913410314247">《 Vue 项目性能优化 — 实践指南 》</a>，文章主要介绍从 3 个大方面，22 个小方面详细讲解如何进行 Vue 项目的优化。</p><p><strong>（1）代码层面的优化</strong></p><ul><li>v-if 和 v-show 区分使用场景</li><li>computed 和 watch  区分使用场景</li><li>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li><li>长列表性能优化</li><li>事件的销毁</li><li>图片资源懒加载</li><li>路由懒加载</li><li>第三方插件的按需引入</li><li>优化无限列表性能</li><li>服务端渲染 SSR or 预渲染</li></ul><p><strong>（2）Webpack 层面的优化</strong></p><ul><li>Webpack 对图片进行压缩</li><li>减少 ES6 转为 ES5 的冗余代码</li><li>提取公共代码</li><li>模板预编译</li><li>提取组件的 CSS</li><li>优化 SourceMap</li><li>构建结果输出分析</li><li>Vue 项目的编译优化</li></ul><p><strong>（3）基础的 Web 技术的优化</strong></p><ul><li>开启 gzip 压缩</li><li>浏览器缓存</li><li>CDN 的使用</li><li>使用 Chrome Performance 查找性能瓶颈</li></ul><h3 id="29、对于即将到来的-vue3-0-特性你有什么了解的吗？"><a href="#29、对于即将到来的-vue3-0-特性你有什么了解的吗？" class="headerlink" title="29、对于即将到来的 vue3.0 特性你有什么了解的吗？"></a>29、对于即将到来的 vue3.0 特性你有什么了解的吗？</h3><p>Vue 3.0 正走在发布的路上，Vue 3.0 的目标是让 Vue 核心变得更小、更快、更强大，因此 Vue 3.0 增加以下这些新特性：</p><p><strong>（1）监测机制的改变</strong></p><p>3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。这消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：</p><ul><li>只能监测属性，不能监测对象</li><li>检测属性的添加和删除；</li><li>检测数组索引和长度的变更；</li><li>支持 Map、Set、WeakMap 和 WeakSet。</li></ul><p>新的 observer 还提供了以下特性：</p><ul><li>用于创建 observable 的公开 API。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。</li><li>默认采用惰性观察。在 2.x 中，不管反应式数据有多大，都会在启动时被观察到。如果你的数据集很大，这可能会在应用启动时带来明显的开销。在 3.x 中，只观察用于渲染应用程序最初可见部分的数据。</li><li>更精确的变更通知。在 2.x 中，通过 Vue.set 强制添加新属性将导致依赖于该对象的 watcher 收到变更通知。在 3.x 中，只有依赖于特定属性的 watcher 才会收到通知。</li><li>不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 prop 传递或 Vuex 状态树以外的变化。</li><li>更好的调试功能：我们可以使用新的 renderTracked 和 renderTriggered 钩子精确地跟踪组件在什么时候以及为什么重新渲染。</li></ul><p><strong>（2）模板</strong></p><p>模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。</p><p>同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。</p><p><strong>（3）对象式的组件声明方式</strong></p><p>vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易。</p><p>此外，vue 的源码也改用了 TypeScript 来写。其实当代码的功能复杂之后，必须有一个静态类型系统来做一些辅助管理。现在 vue3.0 也全面改用 TypeScript 来重写了，更是使得对外暴露的 api 更容易结合 TypeScript。静态类型系统对于复杂代码的维护确实很有必要。</p><p><strong>（4）其它方面的更改</strong></p><p>vue3.0 的改变是全面的，上面只涉及到主要的 3 个方面，还有一些其他的更改：</p><ul><li>支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。</li><li>支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。</li><li>基于 treeshaking 优化，提供了更多的内置功能。</li></ul><h3 id="30、说说你使用-Vue-框架踩过最大的坑是什么？怎么解决的？"><a href="#30、说说你使用-Vue-框架踩过最大的坑是什么？怎么解决的？" class="headerlink" title="30、说说你使用 Vue 框架踩过最大的坑是什么？怎么解决的？"></a>30、说说你使用 Vue 框架踩过最大的坑是什么？怎么解决的？</h3><p>本题为开放题目，欢迎大家在评论区畅所欲言，分享自己的踩坑、填坑经历，提供前车之鉴，避免大伙再次踩坑 <del>~</del></p><p>链接：<a href="https://juejin.cn/post/6844903918753808398">https://juejin.cn/post/6844903918753808398</a></p></style></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;面试题链接&quot;&gt;&lt;a href=&quot;#面试题链接&quot; class=&quot;headerlink&quot; title=&quot;面试题链接&quot;&gt;&lt;/a&gt;面试题链接&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_41646249/article/details
      
    
    </summary>
    
      <category term="前端面试题" scheme="https://qw66.gitee.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="vue" scheme="https://qw66.gitee.io/tags/vue/"/>
    
      <category term="MVVM" scheme="https://qw66.gitee.io/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>vue全家桶</title>
    <link href="https://qw66.gitee.io//knowledges/vue-quan-jia-tong.html"/>
    <id>https://qw66.gitee.io//knowledges/vue-quan-jia-tong.html</id>
    <published>2024-03-08T12:34:52.000Z</published>
    <updated>2024-03-28T18:15:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><h3 id="vue-router-有哪几种导航钩子（-导航守卫-）？"><a href="#vue-router-有哪几种导航钩子（-导航守卫-）？" class="headerlink" title="vue-router 有哪几种导航钩子（ 导航守卫 ）？"></a>vue-router 有哪几种导航钩子（ 导航守卫 ）？</h3><p>答案：三种</p><p>第一种是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。<br>第二种：组件内的钩子；<br>第三种：单独路由独享组件</p><h3 id="怎么定义-vue-router-的动态路由？怎么获取传过来的动态参数？"><a href="#怎么定义-vue-router-的动态路由？怎么获取传过来的动态参数？" class="headerlink" title="怎么定义 vue-router 的动态路由？怎么获取传过来的动态参数？"></a>怎么定义 vue-router 的动态路由？怎么获取传过来的动态参数？</h3><p>答案：</p><p>答：在 router 目录下的 index.js 文件中，对 path 属性加上/:id。 使用 router 对象的 params.id</p><h3 id="vue路由实现原理-或-vue-router原理"><a href="#vue路由实现原理-或-vue-router原理" class="headerlink" title="vue路由实现原理?或 vue-router原理?"></a>vue路由实现原理?或 vue-router原理?</h3><p>说简单点，vue-router的原理就是通过对URL地址变化的监听，继而对不同的组件进行渲染。<br>每当URL地址改变时，就对相应的组件进行渲染。原理是很简单，实现方式可能有点复杂，主要有hash模式和history模式。<br>如果想了解得详细点，建议百度或者阅读源码。</p><h3 id="vue-router获取自定义参数"><a href="#vue-router获取自定义参数" class="headerlink" title="vue-router获取自定义参数"></a>vue-router获取自定义参数</h3><p>传值<strong>：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; this.$router.push(name:&quot;test&quot;,params:&#123;data:&quot;test&quot;&#125;);</span><br><span class="line"></span><br><span class="line">&gt; this.$router.push(path:&quot;/test&quot;,query:&#123;data:&quot;test&quot;&#125;);</span><br></pre></td></tr></table></figure><p>取值（与传值一一对应）：</p><blockquote><p>$route.params      类型: Object</p><p>一个 key/value 对象，包含了动态片段和全匹配片段，如果没有路由参数，就是一个空对象。</p><p>this.$route.params.data  //“test”</p></blockquote><blockquote><p>$route.query       类型: Object</p><p>一个 key/value 对象，表示 URL 查询参数。例如，对于路径 /foo?user=1，则有 $route.query.user == 1，如果没有查询参数，则是个空对象。</p><p>this.$route.query.data  //“test”</p></blockquote><p>​        </p><h3 id="vue-router-路由模式（url中-号的解析）"><a href="#vue-router-路由模式（url中-号的解析）" class="headerlink" title="vue-router 路由模式（url中#号的解析）"></a>vue-router 路由模式（url中#号的解析）</h3><p>​    参考链接：<a href="https://router.vuejs.org/zh/api/#mode" target="_blank" rel="noopener">vueRouter - mode API</a></p><p>​    1）Hash模式：使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器。（URL中带有#号）：</p><blockquote><p><a href="http://localhost:8080/#/" target="_blank" rel="noopener">http://localhost:8080/#/</a></p></blockquote><p>​    2）History模式：依赖HTML5 History API 和服务器配置。<a href="https://router.vuejs.org/zh-cn/essentials/history-mode.html" target="_blank" rel="noopener">HTML5 History模式</a>，(URL中不带有#号）:</p><blockquote><p>export default new Router ({</p><p>​     mode: ‘history’,</p><p>​    routes: [ {</p><p>​        path: ‘/‘,</p><p>​        name: ‘/‘,</p><p>​        component: main</p><p>​    } ]</p><p>})</p></blockquote><p>​    3）Abstract模式：支持所有javascript运行模式，如 Node.js 服务器端。如果发现没有浏览器的API，路由会自动强制进入这个模式。</p><h3 id="vue-router的go相关"><a href="#vue-router的go相关" class="headerlink" title="vue-router的go相关"></a>vue-router的go相关</h3><blockquote><p>router.go(n)：类似 window.history.go(n)，在 history 记录中向前或后退n步(n为int类型)</p><p>router.push(location)：导航到不同的 URL，则使用 router.push 方法。这个方法会<strong>向 history 栈添加一个新的记录</strong>，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。</p><p>router.replace(location)：跟 router.push 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— <em>替换掉当前的 history 记录</em>。</p></blockquote><h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><h3 id="vuex-工作原理详解"><a href="#vuex-工作原理详解" class="headerlink" title="vuex 工作原理详解"></a>vuex 工作原理详解</h3><p>vuex 整体思想诞生于 flux,可其的实现方式完完全全的使用了 vue 自身的响应式设计，依赖监听、依赖收集都属于 vue 对对象 Property set get 方法的代理劫持。最后一句话结束 vuex 工作原理，vuex 中的 store 本质就是没有 template 的隐藏着的 vue 组件；</p><p>解析：vuex的原理其实非常简单，它为什么能实现所有的组件共享同一份数据？<br>因为vuex生成了一个store实例，并且把这个实例挂在了所有的组件上，所有的组件引用的都是同一个store实例。<br>store实例上有数据，有方法，方法改变的都是store实例上的数据。由于其他组件引用的是同样的实例，所以一个组件改变了store上的数据， 导致另一个组件上的数据也会改变，就像是一个对象的引用。</p><h3 id="vuex-是什么？怎么使用？哪种功能场景使用它？"><a href="#vuex-是什么？怎么使用？哪种功能场景使用它？" class="headerlink" title="vuex 是什么？怎么使用？哪种功能场景使用它？"></a>vuex 是什么？怎么使用？哪种功能场景使用它？</h3><p>vue 框架中状态管理。在 main.js 引入 store，注入。新建一个目录 store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车</p><p>main.js:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import store from &apos;./store&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">el:&apos;#app&apos;,</span><br><span class="line">store</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="vuex-有哪几种属性？"><a href="#vuex-有哪几种属性？" class="headerlink" title="vuex 有哪几种属性？"></a>vuex 有哪几种属性？</h3><p>有五种，分别是 State、 Getter、Mutation 、Action、 Module</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vuex的State特性</span><br><span class="line">A、Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于一般Vue对象里面的data</span><br><span class="line">B、state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新</span><br><span class="line">C、它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中</span><br><span class="line"></span><br><span class="line">· vuex的Getter特性</span><br><span class="line">A、getters 可以对State进行计算操作，它就是Store的计算属性</span><br><span class="line">B、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用</span><br><span class="line">C、 如果一个状态只在一个组件内使用，是可以不用getters</span><br><span class="line"></span><br><span class="line">·  vuex的Mutation特性</span><br><span class="line">Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态；Action 可以包含任意异步操作。</span><br></pre></td></tr></table></figure><h3 id="不用-Vuex-会带来什么问题？"><a href="#不用-Vuex-会带来什么问题？" class="headerlink" title="不用 Vuex 会带来什么问题？"></a>不用 Vuex 会带来什么问题？</h3><p>可维护性会下降，想修改数据要维护三个地方；</p><p>可读性会下降，因为一个组件里的数据，根本就看不出来是从哪来的；</p><p>增加耦合，大量的上传派发，会让耦合性大大增加，本来 Vue 用 Component 就是为了减少耦合，现在这么用，和组件化的初衷相背。</p><h3 id="vuex的原理"><a href="#vuex的原理" class="headerlink" title="vuex的原理"></a>vuex的原理</h3><p>​    参考链接：<a href="https://segmentfault.com/a/1190000007516967?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io" target="_blank" rel="noopener">到底vuex是什么</a></p><h3 id="vuex的action和mutation的异步操作和同步操作问题"><a href="#vuex的action和mutation的异步操作和同步操作问题" class="headerlink" title="vuex的action和mutation的异步操作和同步操作问题"></a>vuex的action和mutation的异步操作和同步操作问题</h3><p>​    参考链接：<a href="https://www.cnblogs.com/SamWeb/p/6543931.html" target="_blank" rel="noopener">vuex2.0 基本使用(2) — mutation 和 action</a></p><h2 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h2><h3 id="构建的-vue-cli-工程都到了哪些技术，它们的作用分别是什么？"><a href="#构建的-vue-cli-工程都到了哪些技术，它们的作用分别是什么？" class="headerlink" title="构建的 vue-cli 工程都到了哪些技术，它们的作用分别是什么？"></a>构建的 vue-cli 工程都到了哪些技术，它们的作用分别是什么？</h3><p>1、vue.js：vue-cli 工程的核心，主要特点是 双向数据绑定 和 组件系统。</p><p>2、vue-router：vue 官方推荐使用的路由框架。</p><p>3、vuex：专为 Vue.js 应用项目开发的状态管理器，主要用于维护 vue 组件间共用的一些 变量 和 方法。</p><p>4、axios（ 或者 fetch 、ajax ）：用于发起 GET 、或 POST 等 http 请求，基于 Promise 设计。</p><p>5、vux 等：一个专为 vue 设计的移动端 UI 组件库。</p><p>6、创建一个 emit.js 文件，用于 vue 事件机制的管理。</p><p>7、webpack：模块加载和 vue-cli 工程打包器。</p><h3 id="vue-cli-工程常用的-npm-命令有哪些？"><a href="#vue-cli-工程常用的-npm-命令有哪些？" class="headerlink" title="vue-cli 工程常用的 npm 命令有哪些？"></a>vue-cli 工程常用的 npm 命令有哪些？</h3><p> <strong>答案：</strong>npm install、npm run dev、npm run build –report等</p><p><strong>解析：</strong></p><ul><li>下载 node_modules 资源包的命令：npm install</li><li>启动 vue-cli 开发环境的 npm 命令：npm run dev</li><li>vue-cli 生成 生产环境部署资源 的 npm 命令：npm run build</li><li>用于查看 vue-cli 生产环境部署资源文件大小的 npm 命令：npm run build –report，此命令必答</li></ul><p>在浏览器上自动弹出一个 展示 vue-cli 工程打包后 app.js、manifest.js、vendor.js 文件里面所包含代码的页面。可以具此优化 vue-cli 生产环境部署的静态资源，提升 页面 的加载速度。</p><h3 id="请说出-vue-cli-工程中每个文件夹和文件的用处"><a href="#请说出-vue-cli-工程中每个文件夹和文件的用处" class="headerlink" title="请说出 vue-cli 工程中每个文件夹和文件的用处"></a>请说出 vue-cli 工程中每个文件夹和文件的用处</h3><p><strong>vue-cli目录解析：</strong></p><ul><li><p>build 文件夹：用于存放 webpack 相关配置和脚本。开发中仅 偶尔使用 到此文件夹下 webpack.base.conf.js 用于配置 less、sass等css预编译库，或者配置一下 UI 库。</p></li><li><p>config 文件夹：主要存放配置文件，用于区分开发环境、线上环境的不同。 常用到此文件夹下 config.js 配置开发环境的 端口号、是否开启热加载 或者 设置生产环境的静态资源相对路径、是否开启gzip压缩、npm run build 命令打包生成静态资源的名称和路径等。</p></li><li><p>dist 文件夹：默认 npm run build 命令打包生成的静态资源文件，用于生产部署。</p></li><li><p>node_modules：存放npm命令下载的开发环境和生产环境的依赖包。</p></li><li><p>src: 存放项目源码及需要引用的资源文件。</p><p>src下assets：存放项目中需要用到的资源文件，css、js、images等。</p><p>src下componets：存放vue开发中一些公共组件：header.vue、footer.vue等。</p><p>src下emit：自己配置的vue集中式事件管理机制。</p><p>src下router：vue-router vue路由的配置文件。</p><p>src下service：自己配置的vue请求后台接口方法。</p><p>src下page：存在vue页面组件的文件夹。</p><p>src下util：存放vue开发过程中一些公共的.js方法。</p><p>src下vuex：存放 vuex 为vue专门开发的状态管理器。</p><p>src下app.vue：使用标签<route-view>渲染整个工程的.vue组件。</route-view></p><p>src下main.js：vue-cli工程的入口文件。</p></li><li><p>index.html：设置项目的一些meta头信息和提供<div id="app"></div>用于挂载 vue 节</p></li><li><p>package.json：用于 node_modules资源部 和 启动、打包项目的 npm 命令管理。</p></li></ul><h3 id="config-文件夹-下-index-js-的对于工程-开发环境-和-生产环境-的配置"><a href="#config-文件夹-下-index-js-的对于工程-开发环境-和-生产环境-的配置" class="headerlink" title="config 文件夹 下 index.js 的对于工程 开发环境 和 生产环境 的配置"></a>config 文件夹 下 index.js 的对于工程 开发环境 和 生产环境 的配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">build 对象下 对于 生产环境 的配置：</span><br><span class="line"></span><br><span class="line">index：配置打包后入口.html文件的名称以及文件夹名称</span><br><span class="line">assetsRoot：配置打包后生成的文件名称和路径</span><br><span class="line">assetsPublicPath：配置 打包后 .html 引用静态资源的路径，一般要设置成 &quot;./&quot;</span><br><span class="line">productionGzip：是否开发 gzip 压缩，以提升加载速度</span><br><span class="line"></span><br><span class="line">dev 对象下 对于 开发环境 的配置：</span><br><span class="line"></span><br><span class="line">port：设置端口号</span><br><span class="line">autoOpenBrowser：启动工程时，自动打开浏览器</span><br><span class="line">proxyTable：vue设置的代理，用以解决 跨域 问题</span><br></pre></td></tr></table></figure><h3 id="vue-cli-中常用到的加载器"><a href="#vue-cli-中常用到的加载器" class="headerlink" title="vue-cli 中常用到的加载器"></a>vue-cli 中常用到的加载器</h3><p>1.安装 sass:</p><p>2.安装 axios:</p><p>3.安装 mock:</p><p>4.安装 lib-flexible: –实现移动端自适应</p><p>5.安装 sass-resourses-loader</p><h3 id="vue-cli-中怎样使用自定义的组件？有遇到过哪些问题吗？"><a href="#vue-cli-中怎样使用自定义的组件？有遇到过哪些问题吗？" class="headerlink" title="vue.cli 中怎样使用自定义的组件？有遇到过哪些问题吗？"></a>vue.cli 中怎样使用自定义的组件？有遇到过哪些问题吗？</h3><p>第一步：在 components 目录新建你的组件文件（如：indexPage.vue），script 一定要 export default {}</p><p>第二步：在需要用的页面（组件）中导入：import indexPage from ‘@/components/indexPage.vue’</p><p>第三步：注入到 vue 的子组件的 components 属性上面,components:{indexPage}</p><p>第四步：在 template 视图 view 中使用</p><p>遇到的问题：<br>例如有 indexPage 命名，使用的时候则 index-page</p><h3 id="babel相关"><a href="#babel相关" class="headerlink" title="babel相关"></a>babel相关</h3><p>​    参考链接：<a href="http://web.jobbole.com/91277/" target="_blank" rel="noopener">Babel 从入门到插件开发</a>   </p><p>​                       <a href="http://web.jobbole.com/tag/babel/" target="_blank" rel="noopener">Babel</a></p><h3 id="lodash相关"><a href="#lodash相关" class="headerlink" title="lodash相关"></a>lodash相关</h3><p>​    参考链接：<a href="http://www.css88.com/doc/lodash/" target="_blank" rel="noopener">官方文档</a></p><h3 id="webGL"><a href="#webGL" class="headerlink" title="webGL"></a>webGL</h3><p>​    参考链接：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API/Tutorial/Adding_2D_content_to_a_WebGL_context" target="_blank" rel="noopener">webGL—MDN</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;vue-router&quot;&gt;&lt;a href=&quot;#vue-router&quot; class=&quot;headerlink&quot; title=&quot;vue-router&quot;&gt;&lt;/a&gt;vue-router&lt;/h2&gt;&lt;h3 id=&quot;vue-router-有哪几种导航钩子（-导航守卫-）？&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="前端知识点" scheme="https://qw66.gitee.io/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="vuex" scheme="https://qw66.gitee.io/tags/vuex/"/>
    
      <category term="vue-router" scheme="https://qw66.gitee.io/tags/vue-router/"/>
    
      <category term="vue-cli" scheme="https://qw66.gitee.io/tags/vue-cli/"/>
    
  </entry>
  
  <entry>
    <title>vue知识点</title>
    <link href="https://qw66.gitee.io//knowledges/vue-zhi-shi-dian.html"/>
    <id>https://qw66.gitee.io//knowledges/vue-zhi-shi-dian.html</id>
    <published>2024-03-07T13:02:08.000Z</published>
    <updated>2024-06-06T01:59:24.038Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是vue的生命周期？"><a href="#1-什么是vue的生命周期？" class="headerlink" title="1.什么是vue的生命周期？"></a>1.什么是vue的生命周期？</h3><p>Vue实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载DOM-&gt;渲染、更新-&gt;渲染、卸载等一系列过程，我们称这是Vue的生命周期。</p><h3 id="2-vue生命周期的作用是什么？"><a href="#2-vue生命周期的作用是什么？" class="headerlink" title="2.vue生命周期的作用是什么？"></a>2.vue生命周期的作用是什么？</h3><p>它的生命周期中有多个事件钩子，让我们在控制整个vue实例的过程时更容易形成好的逻辑。</p><h3 id="3-Vue生命周期总共有几个阶段？"><a href="#3-Vue生命周期总共有几个阶段？" class="headerlink" title="3.Vue生命周期总共有几个阶段？"></a>3.Vue生命周期总共有几个阶段？</h3><p>它可以总共分为8个阶段：创建前/后，载入前/后，更新前/后，销毁前/销毁后</p><h3 id="4-第一次页面加载会触发那几个钩子？"><a href="#4-第一次页面加载会触发那几个钩子？" class="headerlink" title="4.第一次页面加载会触发那几个钩子？"></a>4.第一次页面加载会触发那几个钩子？</h3><p>第一次页面加载时会触发beforeCreate,created,beforeMount,mounted</p><h3 id="5-DOM渲染在哪个周期中就已经完成？"><a href="#5-DOM渲染在哪个周期中就已经完成？" class="headerlink" title="5.DOM渲染在哪个周期中就已经完成？"></a>5.DOM渲染在哪个周期中就已经完成？</h3><p>DOM渲染在mounted中就已经完成了</p><h3 id="6-生命周期钩子的一些使用方法："><a href="#6-生命周期钩子的一些使用方法：" class="headerlink" title="6.生命周期钩子的一些使用方法："></a>6.生命周期钩子的一些使用方法：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>beforecreate:可以在加个loading事件，在加载实例是触发</span><br><span class="line"><span class="number">2.</span>created:初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用</span><br><span class="line"><span class="number">3.</span>mounted:挂载元素，获取到dom节点</span><br><span class="line"><span class="number">4.</span>updated:如果对数据统一处理，在这里写上相应函数</span><br><span class="line"><span class="number">5.</span>beforeDestroy:可以一个确认停止事件的确认框</span><br><span class="line"><span class="number">6.</span>nextTick:更新数据后立即操作dom</span><br></pre></td></tr></table></figure><h3 id="7-v-show与v-if的区别"><a href="#7-v-show与v-if的区别" class="headerlink" title="7.v-show与v-if的区别"></a>7.v-show与v-if的区别</h3><p>v-show是css切换，v-if是完整的销毁和重新创建<br>使用频繁切换时用v-show,运行时较少改变时用v-if<br>V-if=’false’v-if是条件渲染，当false的时候不会渲染<br>使用v-if的时候，如果值为false，那么页面将不会有这个html标签生成<br>v-show则是不管值是为true还是false，html元素都会存在，只是css中的display显示或隐藏<br>v-show 仅仅控制元素的显示方式，将 display 属性在 block 和 none 来回切换；而v-if会控制这个 DOM 节点的存在与否。</p><p><strong>当我们需要经常切换某个元素的显示/隐藏时，使用v-show会更加节省性能上的开销；</strong></p><p><strong>当只需要一次显示或隐藏时，使用v-if更加合理。</strong></p><h3 id="8-开发中常用的指令有哪些"><a href="#8-开发中常用的指令有哪些" class="headerlink" title="8.开发中常用的指令有哪些?"></a>8.开发中常用的指令有哪些?</h3><p>v-model:一般用在表达输入，很轻松的实现表单控件和数据的双向绑定<br>v-html：更新元素的innerHTML<br>v-show与v-if：条件渲染，注意二者区别<br>v-on:click:可以简写为@click,@绑定一个事件。如果事件触发了，就可以指定事件的处理函数<br>v-for：基于源数据多次渲染元素或模板<br>v-bind:当表达式的值改变时，将其产生的连带影响，响应式地作用于DOM语法<br>v-bind:title=”msg”简写 :title=”msg”</p><h3 id="9-绑定class的数组用法"><a href="#9-绑定class的数组用法" class="headerlink" title="9.绑定class的数组用法"></a>9.绑定class的数组用法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>对象方法v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"&#123;'orange':isRipe, 'green':isNotRipe&#125;”</span></span><br><span class="line"><span class="string">2.数组方法v-bind:class="</span>[class1,class2]<span class="string">"</span></span><br><span class="line"><span class="string">3.行内v-bind:style="</span>&#123;<span class="attr">color</span>:color,<span class="attr">fontSize</span>:fontSize+<span class="string">'px'</span>&#125;”</span><br></pre></td></tr></table></figure><h3 id="10-路由跳转方式"><a href="#10-路由跳转方式" class="headerlink" title="10.路由跳转方式"></a>10.路由跳转方式</h3><p>1.router-link标签会渲染为标签，咋填template中的跳转都是这种；<br>2.另一种是编辑是导航，也就是通过js跳转比如router.push(‘/home’)</p><h3 id="11-MVVM"><a href="#11-MVVM" class="headerlink" title="11.MVVM"></a>11.MVVM</h3><p>M-model，model代表数据模型，也可以在model中定义数据修改和操作的业务逻辑</p><p>V-view,view代表UI组件，它负责将数据模型转化为UI展现出来</p><p>VM-viewmodel,viewmodel监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步view和model的对象，连接model和view</p><h3 id="12-computed和watch有什么区别"><a href="#12-computed和watch有什么区别" class="headerlink" title="12.computed和watch有什么区别"></a>12.<strong>computed和watch有什么区别</strong></h3><p><strong>computed</strong></p><p>computed是计算属性，也就是计算值，它<strong>更多用于计算值的场景</strong><br>computed具有缓存性，computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时重新调用对应的getter来计算<br>computed适用于计算比较消耗性能的计算场景</p><p><strong>watch</strong></p><p>watch更多的是[观察]的作用，类似于某些数据的监听回调，用于观察props $emit或者本组件的值，当数据变化时来执行回调进行后续操作<br>无缓存性，页面重新渲染时值不变化也会执行</p><p><strong>小结</strong></p><p><strong>当我们要进行数值计算，而且依赖于其他数据，那么把这个数据设计为computed</strong><br><strong>如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化。</strong></p><h3 id="13-vue组件的scoped属性的作用"><a href="#13-vue组件的scoped属性的作用" class="headerlink" title="13.vue组件的scoped属性的作用"></a>13.<strong>vue组件的scoped属性的作用</strong></h3><p>在style标签上添加scoped属性，以表示它的样式作用于当下的模块，很好的实现了样式私有化的目的；<br>但是也得慎用：样式不易（可）修改，而很多时候，我们是需要对公共组件的样式做微调的；</p><p><strong>解决办法：</strong></p><p>①：使用混合型的css样式：（混合使用全局跟本地的样式） </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt; /* 全局样式 */ &lt;/style&gt;</span><br><span class="line">&lt;style scoped&gt; /* 本地样式 */ &lt;/style&gt;</span><br></pre></td></tr></table></figure><p>②：深度作用选择器（&gt;&gt;&gt;）如果你希望 scoped 样式中的一个选择器能够作用得“更深”，例如影响子组件，你可以使用 &gt;&gt;&gt; 操作符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt; .a &gt;&gt;&gt; .b &#123; /* ... */ &#125; &lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="14-vue是渐进式的框架的理解：-主张最少-没有多做职责之外的事"><a href="#14-vue是渐进式的框架的理解：-主张最少-没有多做职责之外的事" class="headerlink" title="14.vue是渐进式的框架的理解：(主张最少,没有多做职责之外的事)"></a>14.vue是渐进式的框架的理解：(<strong>主张最少,没有多做职责之外的事</strong>)</h3><p>Vue的核心的功能，是一个视图模板引擎，但这不是说Vue就不能成为一个框架。如下图所示，这里包含了Vue的所有部件，在声明式渲染（视图模板引擎）的基础上，我们可以通过添加组件系统、客户端路由、大规模状态管理来构建一个完整的框架。更重要的是，这些功能相互独立，你可以在核心功能的基础上任意选用其他的部件，不一定要全部整合在一起。可以看到，所说的“渐进式”，其实就是Vue的使用方式，同时也体现了Vue的设计的理念<br>在我看来，渐进式代表的含义是：主张最少。视图模板引擎<br>每个框架都不可避免会有自己的一些特点，从而会对使用者有一定的要求，这些要求就是主张，主张有强有弱，它的强势程度会影响在业务开发中的使用方式。<br>比如说，Angular，它两个版本都是强主张的，如果你用它，必须接受以下东西：<br>必须使用它的模块机制- 必须使用它的依赖注入- 必须使用它的特殊形式定义组件（这一点每个视图框架都有，难以避免）<br>所以Angular是带有比较强的排它性的，如果你的应用不是从头开始，而是要不断考虑是否跟其他东西集成，这些主张会带来一些困扰。<br>Vue可能有些方面是不如React，不如Angular，但它是渐进的，没有强主张，你可以在原有大系统的上面，把一两个组件改用它实现，当jQuery用；也可以整个用它全家桶开发，当Angular用；还可以用它的视图，搭配你自己设计的整个下层用。也可以函数式，都可以，它只是个轻量视图而已，只做了自己该做的事，没有做不该做的事，仅此而已。<br><strong>渐进式的含义，我的理解是：没有多做职责之外的事。</strong></p><h3 id="15-vue-js的两个核心是什么-数据驱动、组件系统。"><a href="#15-vue-js的两个核心是什么-数据驱动、组件系统。" class="headerlink" title="15.vue.js的两个核心是什么(数据驱动、组件系统。)"></a>15.vue.js的两个核心是什么(数据驱动、组件系统。)</h3><p>数据驱动:Object.defineProperty和存储器属性: getter和setter（所以只兼容IE9及以上版本），可称为基于依赖收集的观测机制,核心是VM，即ViewModel，保证数据和视图的一致性。<br>组件系统:<a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/tangxiujiang/article/details/79620542%23commentBox" target="_blank" rel="noopener">点此查看</a></p><h3 id="16-vue常用修饰符"><a href="#16-vue常用修饰符" class="headerlink" title="16.vue常用修饰符"></a>16.vue常用修饰符</h3><p><strong>修饰符分为：一般修饰符，事件修饰符，按键、系统</strong></p><h4 id="①一般修饰符："><a href="#①一般修饰符：" class="headerlink" title="①一般修饰符："></a>①一般修饰符：</h4><p>.lazy：v-model 在每次 input 事件触发后将输入框的值与数据进行同步 。你可以添加 lazy 修饰符，从而转变为使用 change 事件进行同步</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model.lazy=<span class="string">"msg"</span> &gt;</span><br></pre></td></tr></table></figure><p><strong>.number</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model.number=<span class="string">"age"</span> type=<span class="string">"number"</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>.trim</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>如果要自动过滤用户输入的首尾空白字符 &lt;input v-model.trim=<span class="string">'trim'</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="②-事件修饰符"><a href="#②-事件修饰符" class="headerlink" title="② 事件修饰符"></a>② 事件修饰符</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-on:click.stop=<span class="string">"doThis"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><span class="xml"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span> <span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">"doThat"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span>   <span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">"doThis"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>   <span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span> <span class="comment">&lt;!-- 即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理 --&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">"doThat"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  <span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span> <span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.once</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="comment">&lt;!-- 点击事件将只会触发一次 --&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="③按键修饰符"><a href="#③按键修饰符" class="headerlink" title="③按键修饰符"></a>③按键修饰符</h4><p>全部的按键别名:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.enter</span><br><span class="line">.tab</span><br><span class="line">.delete (捕获“删除”和“退格”键)</span><br><span class="line">.esc</span><br><span class="line">.space</span><br><span class="line">.up</span><br><span class="line">.down</span><br><span class="line">.left</span><br><span class="line">.right</span><br><span class="line">.ctrl</span><br><span class="line">.alt</span><br><span class="line">.shift</span><br><span class="line">.meta</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-on:keyup.enter=<span class="string">"submit"</span>&gt; 或者 &lt;input @keyup.enter=<span class="string">"submit"</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="④系统修饰键-（可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。）"><a href="#④系统修饰键-（可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。）" class="headerlink" title="④系统修饰键 （可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。）"></a>④系统修饰键 （可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.ctrl</span><br><span class="line">.alt</span><br><span class="line">.shift</span><br><span class="line">.meta</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input @keyup.alt<span class="number">.67</span>=<span class="string">"clear"</span>&gt; 或者 &lt;div @click.ctrl=<span class="string">"doSomething"</span>&gt;Do something&lt;<span class="regexp">/div&gt;&lt;!-- Ctrl + Click --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="17-v-on可以监听多个方法吗？（可以的）"><a href="#17-v-on可以监听多个方法吗？（可以的）" class="headerlink" title="17.v-on可以监听多个方法吗？（可以的）"></a>17.<strong>v-on可以监听多个方法吗？（可以的）</strong></h3><p>一个元素绑定多个事件的两种写法，一个事件绑定多个函数的两种写法，修饰符的使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a style=<span class="string">"cursor:default"</span> v-on=<span class="string">'&#123;click:DoSomething,mouseleave:MouseLeave&#125;'</span>&gt;doSomething&lt;<span class="regexp">/a&gt;</span></span><br></pre></td></tr></table></figure><p>在method方法里面分别写两个时事件；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=<span class="string">"a(),b()"</span>&gt;点我ab&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><h3 id="18-vue事件中如何使用event对象"><a href="#18-vue事件中如何使用event对象" class="headerlink" title="18.vue事件中如何使用event对象"></a>18.<strong>vue事件中如何使用event对象</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=<span class="string">"Event($event)"</span>&gt;事件对象&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><h3 id="19-比如你想让一个dom元素显示，然后下一步去获取这个元素的offsetWidth，最后你获取到的会是0。"><a href="#19-比如你想让一个dom元素显示，然后下一步去获取这个元素的offsetWidth，最后你获取到的会是0。" class="headerlink" title="19.比如你想让一个dom元素显示，然后下一步去获取这个元素的offsetWidth，最后你获取到的会是0。"></a>19.<strong>比如你想让一个dom元素显示</strong>，然后下一步去获取这个元素的offsetWidth，最后你获取到的会是0。</h3><p>因为你改变数据把show变成true,元素并不会立即显示，理所当然也不会获取到动态宽度。<br>正确的做法是先把元素show出来，在$nextTick去执行获取宽度的操作，不知道这样说会不会好理解一点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">openSubmenu() &#123;</span><br><span class="line"><span class="keyword">this</span>.show = <span class="literal">true</span> <span class="comment">//获取不到宽度</span></span><br><span class="line"><span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="comment">//这里才可以 let w = this.$refs.submenu.offsetWidth;</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20-Vue-组件中-data-为什么必须是函数"><a href="#20-Vue-组件中-data-为什么必须是函数" class="headerlink" title="20.Vue 组件中 data 为什么必须是函数"></a>20.Vue 组件中 data 为什么必须是函数</h3><p>vue组件中data值不能为对象，<strong>因为对象是引用类型，组件可能会被多个实例同时引用</strong>。<br>如果data值为对象，将导致多个实例共享一个对象，其中一个组件改变data属性值，其它实例也会受到影响。</p><h3 id="21-vue中子组件调用父组件的方法"><a href="#21-vue中子组件调用父组件的方法" class="headerlink" title="21.vue中子组件调用父组件的方法"></a>21.vue中子组件调用父组件的方法</h3><p>第一种方法是直接在子组件中通过this.$parent.event来调用父组件的方法<br>第二种方法是在子组件里用$emit向父组件触发一个事件，父组件监听这个事件就行了。<br>第三种都可以实现子组件调用父组件的方法，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click=<span class="string">"childMethod()"</span>&gt;点击&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  export default &#123;</span></span><br><span class="line"><span class="regexp">    props: &#123;</span></span><br><span class="line"><span class="regexp">      fatherMethod: &#123;</span></span><br><span class="line"><span class="regexp">        type: Function,</span></span><br><span class="line"><span class="regexp">        default: null</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    methods: &#123;</span></span><br><span class="line"><span class="regexp">      childMethod() &#123;</span></span><br><span class="line"><span class="regexp">        if (this.fatherMethod) &#123;</span></span><br><span class="line"><span class="regexp">          this.fatherMethod();</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><h3 id="22-vue中-keep-alive-组件的作用"><a href="#22-vue中-keep-alive-组件的作用" class="headerlink" title="22.vue中 keep-alive 组件的作用"></a>22.vue中 keep-alive 组件的作用</h3><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;component&gt;</span><br><span class="line">    &lt;!-- 该组件将被缓存！ --&gt;</span><br><span class="line">  &lt;<span class="regexp">/component&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>keep-alive&gt;</span><br><span class="line">如果只想 router-view 里面某个组件被缓存</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/'</span>,</span><br><span class="line">    name: <span class="string">'home'</span>,</span><br><span class="line">    component: Home,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      keepAlive: <span class="literal">true</span> <span class="comment">// 需要被缓存</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    path: <span class="string">'/:id'</span>,</span><br><span class="line">    name: <span class="string">'edit'</span>,</span><br><span class="line">    component: Edit,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      keepAlive: <span class="literal">false</span> <span class="comment">// 不需要被缓存</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">    &lt;router-view v-<span class="keyword">if</span>=<span class="string">"$route.meta.keepAlive"</span>&gt;</span><br><span class="line">        &lt;!-- 这里是会被缓存的视图组件，比如 Home！ --&gt;</span><br><span class="line">    &lt;<span class="regexp">/router-view&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>keep-alive&gt;</span><br><span class="line"> </span><br><span class="line">&lt;router-view v-<span class="keyword">if</span>=<span class="string">"!$route.meta.keepAlive"</span>&gt;</span><br><span class="line">    &lt;!-- 这里是不被缓存的视图组件，比如 Edit！ --&gt;</span><br><span class="line">&lt;<span class="regexp">/router-view&gt;</span></span><br></pre></td></tr></table></figure><h3 id="23-vue中如何编写可复用的组件？"><a href="#23-vue中如何编写可复用的组件？" class="headerlink" title="23.vue中如何编写可复用的组件？"></a>23.vue中如何编写可复用的组件？</h3><p><a href="https://blog.csdn.net/qq_38563845/article/details/77524934" target="_blank" rel="noopener">https://blog.csdn.net/qq_38563845/article/details/77524934</a></p><p>①创建组件页面eg Toast.vue；<br>②用Vue.extend()扩展一个组件构造器,再通过实例化组件构造器,就可创造出可复用的组件<br>③将toast组件挂载到新创建的div上；<br>④把toast组件的dom添加到body里；<br>⑤修改优化达到动态控制页面显示文字跟显示时间；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>; </span><br><span class="line"><span class="keyword">import</span> Toast <span class="keyword">from</span> <span class="string">'@/components/Toast'</span>;     <span class="comment">//引入组件</span></span><br><span class="line"><span class="keyword">let</span> ToastConstructor  = Vue.extend(Toast) <span class="comment">// 返回一个“扩展实例构造器”</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> myToast = <span class="function">(<span class="params">text,duration</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> toastDom = <span class="keyword">new</span> ToastConstructor(&#123;</span><br><span class="line">        el:<span class="built_in">document</span>.createElement(<span class="string">'div'</span>)    <span class="comment">//将toast组件挂载到新创建的div上</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild( toastDom.$el )   <span class="comment">//把toast组件的dom添加到body里</span></span><br><span class="line">    </span><br><span class="line">    toastDom.text = text;</span><br><span class="line">    toastDom.duration = duration;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 在指定 duration 之后让 toast消失</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        toastDom.isShow = <span class="literal">false</span>;  </span><br><span class="line">    &#125;, toastDom.duration);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> myToast;</span><br></pre></td></tr></table></figure><h3 id="24-什么是vue生命周期和生命周期钩子函数？"><a href="#24-什么是vue生命周期和生命周期钩子函数？" class="headerlink" title="24.什么是vue生命周期和生命周期钩子函数？"></a>24.什么是vue生命周期和生命周期钩子函数？</h3><p><strong>beforecreated</strong>：在实例初始化之后，el 和 data 并未初始化（这个时期，this变量还不能使用，在data下的数据，和methods下的方法，watcher中的事件都不能获得到；）<br><strong>created</strong>:完成了 data 数据的初始化，el没有（这个时候可以操作vue实例中的数据和各种方法，但是还不能对”dom”节点进行操作；）<br><strong>beforeMount</strong>：完成了 el 和 data 初始化 //这里的el是虚拟的dom；<br><strong>mounted</strong> ：完成挂载，在这发起后端请求，拿回数据，配合路由钩子做一些事情（挂载完毕，这时dom节点被渲染到文档内，一些需要dom的操作在此时才能正常进行）<br><strong>beforeUpdate</strong>：是指view层数据变化前，不是data中的数据改变前触发；<br><strong>update</strong>：是指view层的数据变化之后，<br><strong>beforeDestory</strong>： 你确认删除XX吗？<br><strong>destoryed</strong> ：当前组件已被删除，清空相关内容<br><strong>A、什么是vue生命周期？</strong><br>Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。<br><strong>B、vue生命周期的作用是什么？</strong><br>它的生命周期有多个事件钩子,让我们在控制整个Vue实例的过程时更容易形成好的逻辑。<br><strong>C、vue生命周期总共有几个阶段？</strong><br>它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后<br><strong>D、第一次页面加载会触发哪几个钩子？</strong><br>第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子<br><strong>E、DOM 渲染在 哪个周期中就已经完成？</strong><br>DOM 渲染在 mounted 中就已经完成了。<br><strong>F、简单描述每个周期具体适合哪些场景？</strong><br>生命周期钩子的一些使用方法： beforecreate : 可以在这加个loading事件，在加载实例时触发 created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用 mounted : 挂载元素，获取到DOM节点 updated : 如果对数据统一处理，在这里写上相应函数 beforeDestroy : 可以做一个确认停止事件的确认框 nextTick : 更新数据后立即操作dom;</p><h3 id="26-webpack的作用"><a href="#26-webpack的作用" class="headerlink" title="26.webpack的作用"></a>26.webpack的作用</h3><p>①、依赖管理：方便引用第三方模块、让模块更容易复用，避免全局注入导致的冲突、避免重复加载或者加载不需要的模块。会一层一层的读取依赖的模块，添加不同的入口；同时，不会重复打包依赖的模块。<br>②、合并代码：把各个分散的模块集中打包成大文件，减少HTTP的请求链接数，配合UglifyJS（压缩代码）可以减少、优化代码的体积。<br>③、各路插件：统一处理引入的插件，babel编译ES6文件，TypeScript,eslint 可以检查编译期的错误。<br><strong>一句话总结：</strong>webpack 的作用就是处理依赖，模块化，打包压缩文件，管理插件。<br>一切皆为模块，由于webpack只支持js文件，所以需要用loader 转换为webpack支持的模块，其中plugin 用于扩张webpack 的功能，在webpack构建生命周期的过程中，在合适的时机做了合适的事情。</p><h3 id="webpack怎么工作的过程"><a href="#webpack怎么工作的过程" class="headerlink" title="webpack怎么工作的过程"></a>webpack怎么工作的过程</h3><p>①解析配置参数，合并从shell(npm install 类似的命令)和webpack.config.js文件的配置信息，输出最终的配置信息；<br>②注册配置中的插件,让插件监听webpack构建生命周期中的事件节点，做出对应的反应；<br>③解析配置文件中的entry入口文件，并找出每个文件依赖的文件，递归下去；<br>④在递归每个文件的过程中，根据文件类型和配置文件中的loader找出对应的loader对文件进行转换；<br>⑤递归结束后得到每个文件最终的结果，根据entry 配置生成代码chunk(打包之后的名字)；<br>⑥输出所以chunk 到文件系统。</p><h3 id="27-vue等单页面应用及其优缺点"><a href="#27-vue等单页面应用及其优缺点" class="headerlink" title="27.vue等单页面应用及其优缺点"></a>27.vue等单页面应用及其优缺点</h3><p><strong>缺点：</strong></p><blockquote><p>不支持低版本的浏览器，最低只支持到IE9；<br>不利于SEO的优化（如果要支持SEO，建议通过服务端来进行渲染组件）；<br>第一次加载首页耗时相对长一些；<br>不可以使用浏览器的导航按钮需要自行实现前进、后退。</p></blockquote><p><strong>优点：</strong></p><blockquote><p>无刷新体验,提升了用户体验；<br>前端开发不再以页面为单位，更多地采用组件化的思想，代码结构和组织方式更加规范化，便于修改和调整；<br>API 共享，同一套后端程序代码不用修改就可以用于Web界面、手机、平板等多种客户端<br>用户体验好、快，内容的改变不需要重新加载整个页面。</p></blockquote><h3 id="28-什么是vue的计算属性computed"><a href="#28-什么是vue的计算属性computed" class="headerlink" title="28.什么是vue的计算属性computed"></a>28.什么是vue的计算属性computed</h3><p>计算属性是需要复杂的逻辑，可以用方法method代替</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">    totalPrice()&#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">this</span>.good.price*<span class="keyword">this</span>.good.count)*<span class="keyword">this</span>.discount+<span class="keyword">this</span>.deliver;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="29-vue-cli提供的几种脚手架模板"><a href="#29-vue-cli提供的几种脚手架模板" class="headerlink" title="29.vue-cli提供的几种脚手架模板"></a>29.vue-cli提供的几种脚手架模板</h3><blockquote><p>vue-cli 的脚手架项目模板有browserify 和 webpack；</p></blockquote><h3 id="30-组件中传递数据？"><a href="#30-组件中传递数据？" class="headerlink" title="30.组件中传递数据？"></a>30.组件中传递数据？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">props：<span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">props: &#123;</span><br><span class="line">message: <span class="built_in">String</span> <span class="comment">//定义传值的类型&lt;br&gt;</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者props:["message"]</span></span><br><span class="line">data: &#123;&#125;</span><br><span class="line">父组件调用子组件的方法：父组件   <span class="keyword">this</span>.$refs.yeluosen.childMethod()</span><br><span class="line">子组件向父组件传值并调用方法 $emit</span><br><span class="line">组件之间：bus==$emit+$on</span><br></pre></td></tr></table></figure><h3 id="32-vue-router-的导航钩子-主要用来作用是拦截导航-让他完成跳转或取消。"><a href="#32-vue-router-的导航钩子-主要用来作用是拦截导航-让他完成跳转或取消。" class="headerlink" title="32.vue-router 的导航钩子,主要用来作用是拦截导航,让他完成跳转或取消。"></a>32.vue-router 的导航钩子,主要用来作用是拦截导航,让他完成跳转或取消。</h3><blockquote><p><strong>全局的:</strong>前置守卫、后置钩子（beforeEach，afterEach）beforeResolve<br><strong>单个路由独享的:</strong>beforeEnter<br><strong>组件级的:</strong> beforeRouteEnter（不能获取组件实例 this）、beforeRouteUpdate、beforeRouteLeave<br>这是因为在执行路由钩子函数beforRouteEnter时候，组件还没有被创建出来；<br>先执行beforRouteEnter，再执行组件周期钩子函数beforeCreate，可以通过 next 获取组件的实例对象，如：next( (vm)=&gt;{} )，参数vm就是组件的实例化对象。</p></blockquote><h3 id="33-完整的-vue-router-导航解析流程"><a href="#33-完整的-vue-router-导航解析流程" class="headerlink" title="33.完整的 vue-router 导航解析流程"></a>33.完整的 vue-router 导航解析流程</h3><blockquote><p>1.导航被触发；<br>2.在失活的组件里调用beforeRouteLeave守卫；<br>3.调用全局beforeEach守卫；<br>4.在复用组件里调用beforeRouteUpdate守卫；<br>5.调用路由配置里的beforeEnter守卫；<br>6.解析异步路由组件；<br>7.在被激活的组件里调用beforeRouteEnter守卫；<br>8.调用全局beforeResolve守卫；<br>9.导航被确认；<br>10..调用全局的afterEach钩子；<br>11.DOM更新；<br>12.用创建好的实例调用beforeRouteEnter守卫中传给next的回调函数。</p></blockquote><h3 id="34-vue-router如何响应-路由参数-的变化？"><a href="#34-vue-router如何响应-路由参数-的变化？" class="headerlink" title="34.vue-router如何响应 路由参数 的变化？"></a>34.vue-router如何响应 路由参数 的变化？</h3><p><strong>原来的组件实例会被复用。这也意味着组件的生命周期钩子不会再被调用。你可以简单地 watch (监测变化) $route 对象：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">'...'</span>,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="string">'$route'</span> (to, <span class="keyword">from</span>) &#123;</span><br><span class="line">      <span class="comment">// 对路由变化作出响应...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">'...'</span>,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="string">'$route'</span> (to, <span class="keyword">from</span>) &#123;</span><br><span class="line">      <span class="comment">// 对路由变化作出响应...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="35-vue-router的几种实例方法以及参数传递"><a href="#35-vue-router的几种实例方法以及参数传递" class="headerlink" title="35.vue-router的几种实例方法以及参数传递"></a>35.vue-router的几种实例方法以及参数传递</h3><blockquote><p>name传递<br>to来传递<br>采用url传参</p></blockquote><h3 id="36-is的用法（用于动态组件且基于-DOM-内模板的限制来工作。）"><a href="#36-is的用法（用于动态组件且基于-DOM-内模板的限制来工作。）" class="headerlink" title="36.is的用法（用于动态组件且基于 DOM 内模板的限制来工作。）"></a>36.is的用法（用于动态组件且基于 DOM 内模板的限制来工作。）</h3><p>is用来动态切换组件，DOM模板解析</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt; <span class="xml"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">is</span>=<span class="string">"my-row"</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a><a href="https://v2.cn.vuejs.org/v2/guide/components.html#动态组件" target="_blank" rel="noopener">动态组件</a></h3><p>有的时候，在不同组件之间进行动态切换是非常有用的，比如在一个多标签的界面里： </p><p>上述内容可以通过 Vue 的 <code>&lt;component&gt;</code> 元素加一个特殊的 <code>is</code> attribute 来实现： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 组件会在 `currentTabComponent` 改变时改变 --&gt;</span><br><span class="line">&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;</span><br></pre></td></tr></table></figure><p>在上述示例中，<code>currentTabComponent</code> 可以包括</p><ul><li><p>已注册组件的名字，或</p></li><li><p>一个组件的选项对象</p><p>请留意，这个 attribute 可以用于常规 HTML 元素，但这些元素将被视为组件，这意味着所有的 attribute <strong>都会作为 DOM attribute 被绑定</strong>。对于像 <code>value</code> 这样的 property，若想让其如预期般工作，你需要使用 <a href="https://v2.cn.vuejs.org/v2/api/#v-bind" target="_blank" rel="noopener"><code>.prop</code> 修饰器</a>。 </p></li></ul><h3 id="37-vuex是什么？怎么使用？哪种功能场景使用它？"><a href="#37-vuex是什么？怎么使用？哪种功能场景使用它？" class="headerlink" title="37.vuex是什么？怎么使用？哪种功能场景使用它？"></a>37.vuex是什么？怎么使用？哪种功能场景使用它？</h3><blockquote><p>是什么：vue框架中状态管理:有五种，分别是 State、 Getter、Mutation 、Action、 Module<br>使用：新建一个目录store，<br>场景：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">vuex的State特性</span><br><span class="line">A、Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于一般Vue对象里面的data</span><br><span class="line">B、state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新</span><br><span class="line">C、它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中</span><br><span class="line"></span><br><span class="line">vuex的Getter特性</span><br><span class="line">A、getters 可以对State进行计算操作，它就是Store的计算属性</span><br><span class="line">B、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用</span><br><span class="line">C、 如果一个状态只在一个组件内使用，是可以不用getters</span><br><span class="line"></span><br><span class="line">vuex的Mutation特性</span><br><span class="line">改变store中state状态的唯一方法就是提交mutation，就很类似事件。</span><br><span class="line">每个mutation都有一个字符串类型的事件类型和一个回调函数，我们需要改变state的值就要在回调函数中改变。</span><br><span class="line">我们要执行这个回调函数，那么我们需要执行一个相应的调用方法：store.commit。</span><br><span class="line"></span><br><span class="line">Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态；</span><br><span class="line">Action 可以包含任意异步操作，Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，</span><br><span class="line">因此你可以调用 context.commit 提交一个 mutation，</span><br><span class="line">或者通过 context.state 和 context.getters 来获取 state 和 getters。</span><br><span class="line">Action 通过 store.dispatch 方法触发：eg。</span><br><span class="line">store.dispatch(<span class="string">'increment'</span>)</span><br><span class="line"></span><br><span class="line">vuex的<span class="built_in">module</span>特性</span><br><span class="line">Module其实只是解决了当state中很复杂臃肿的时候，<span class="built_in">module</span>可以将store分割成模块，</span><br><span class="line">每个模块中拥有自己的state、mutation、action和getter</span><br></pre></td></tr></table></figure><h3 id="说说你对-SPA-单页面的理解，它的优缺点分别是什么？"><a href="#说说你对-SPA-单页面的理解，它的优缺点分别是什么？" class="headerlink" title="说说你对 SPA 单页面的理解，它的优缺点分别是什么？"></a>说说你对 SPA 单页面的理解，它的优缺点分别是什么？</h3><p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p><p>优点：</p><ul><li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li><li>基于上面一点，SPA 相对对服务器压力小；</li><li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li></ul><p>缺点：</p><ul><li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li><li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li><li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li></ul><h3 id="v-show-与-v-if-有什么区别？"><a href="#v-show-与-v-if-有什么区别？" class="headerlink" title="v-show 与 v-if 有什么区别？"></a>v-show 与 v-if 有什么区别？</h3><p>v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p>v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。</p><p>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p><h3 id="Class-与-Style-如何动态绑定？"><a href="#Class-与-Style-如何动态绑定？" class="headerlink" title="Class 与 Style 如何动态绑定？"></a>Class 与 Style 如何动态绑定？</h3><p>Class 可以通过对象语法和数组语法进行动态绑定：</p><ul><li>对象语法：</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"&#123; active: isActive, 'text-danger': hasError &#125;"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>数组语法：</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"[isActive ? activeClass : '', errorClass]"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>Style 也可以通过对象语法和数组语法进行动态绑定：</p><ul><li>对象语法：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>数组语法：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"[styleColor, styleSize]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="怎样理解-Vue-的单向数据流？"><a href="#怎样理解-Vue-的单向数据流？" class="headerlink" title="怎样理解 Vue 的单向数据流？"></a>怎样理解 Vue 的单向数据流？</h3><p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。</p><p>这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p><p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。</p><p>子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p><p>有两种常见的试图改变一个 prop 的情形 :</p><ul><li>这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。 在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">'initialCounter'</span>],</span><br></pre></td></tr></table></figure><ul><li>这个 prop 以一种原始的值传入且需要进行转换。 在这种情况下，最好使用这个 prop 的值来定义一个计算属性</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">'size'</span>],</span><br></pre></td></tr></table></figure><h3 id="computed-和-watch-的区别和运用的场景？"><a href="#computed-和-watch-的区别和运用的场景？" class="headerlink" title="computed 和 watch 的区别和运用的场景？"></a>computed 和 watch 的区别和运用的场景？</h3><p>computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；</p><p>watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p><p>运用场景：</p><ul><li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</li><li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li></ul><h3 id="直接给一个数组项赋值，Vue-能检测到变化吗？"><a href="#直接给一个数组项赋值，Vue-能检测到变化吗？" class="headerlink" title="直接给一个数组项赋值，Vue 能检测到变化吗？"></a>直接给一个数组项赋值，Vue 能检测到变化吗？</h3><p>由于 JavaScript 的限制，Vue 不能检测到以下数组的变动：</p><ul><li>当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue</li><li>当你修改数组的长度时，例如：vm.items.length = newLength</li></ul><p>为了解决第一个问题，Vue 提供了以下操作方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue.set</span></span><br></pre></td></tr></table></figure><p>为了解决第二个问题，Vue 提供了以下操作方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array.prototype.splice</span></span><br></pre></td></tr></table></figure><h3 id="谈谈你对-Vue-生命周期的理解？"><a href="#谈谈你对-Vue-生命周期的理解？" class="headerlink" title="谈谈你对 Vue 生命周期的理解？"></a>谈谈你对 Vue 生命周期的理解？</h3><h4 id="（1）生命周期是什么？"><a href="#（1）生命周期是什么？" class="headerlink" title="（1）生命周期是什么？"></a>（1）生命周期是什么？</h4><p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p><h4 id="（2）各个生命周期的作用"><a href="#（2）各个生命周期的作用" class="headerlink" title="（2）各个生命周期的作用"></a>（2）各个生命周期的作用</h4><table><thead><tr><th>生命周期</th><th>描述</th></tr></thead><tbody><tr><td>beforeCreate</td><td>组件实例被创建之初，组件的属性生效之前</td></tr><tr><td>created</td><td>组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用</td></tr><tr><td>beforeMount</td><td>在挂载开始之前被调用：相关的 render 函数首次被调用</td></tr><tr><td>mounted</td><td>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</td></tr><tr><td>beforeUpdate</td><td>组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td></tr><tr><td>update</td><td>组件数据更新之后</td></tr><tr><td>activited</td><td>keep-alive 专属，组件被激活时调用</td></tr><tr><td>deactivated</td><td>keep-alive 专属，组件被销毁时调用</td></tr><tr><td>beforeDestory</td><td>组件销毁前调用</td></tr><tr><td>destoryed</td><td>组件销毁后调用</td></tr></tbody></table><h4 id="（3）生命周期示意图"><a href="#（3）生命周期示意图" class="headerlink" title="（3）生命周期示意图"></a>（3）生命周期示意图</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https:////upload-images.jianshu.io/upload_images/12842279-43f8b23ff3bd3a30?imageMogr2/auto-orient/strip|imageView2/2/w/640/format/webp" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><h3 id="Vue-的父组件和子组件生命周期钩子函数执行顺序？"><a href="#Vue-的父组件和子组件生命周期钩子函数执行顺序？" class="headerlink" title="Vue 的父组件和子组件生命周期钩子函数执行顺序？"></a>Vue 的父组件和子组件生命周期钩子函数执行顺序？</h3><p>Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</p><ul><li><p>加载渲染过程</p><p>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p></li><li><p>子组件更新过程</p><p>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p></li><li><p>父组件更新过程</p><p>父 beforeUpdate -&gt; 父 updated</p></li><li><p>销毁过程</p><p>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p></li></ul><h3 id="在哪个生命周期内调用异步请求？"><a href="#在哪个生命周期内调用异步请求？" class="headerlink" title="在哪个生命周期内调用异步请求？"></a>在哪个生命周期内调用异步请求？</h3><p>可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p><ul><li>能更快获取到服务端数据，减少页面 loading 时间；</li><li>ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</li></ul><h3 id="在什么阶段才能访问操作DOM？"><a href="#在什么阶段才能访问操作DOM？" class="headerlink" title="在什么阶段才能访问操作DOM？"></a>在什么阶段才能访问操作DOM？</h3><p>在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 DOM。vue 具体的生命周期示意图可以参见如下，理解了整个生命周期各个阶段的操作，关于生命周期相关的面试题就难不倒你了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https:////upload-images.jianshu.io/upload_images/12842279-f01c5f655dd3628a?imageMogr2/auto-orient/strip|imageView2/2/w/640/format/webp" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><h3 id="父组件可以监听到子组件的生命周期吗？"><a href="#父组件可以监听到子组件的生命周期吗？" class="headerlink" title="父组件可以监听到子组件的生命周期吗？"></a>父组件可以监听到子组件的生命周期吗？</h3><p>比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parent.vue</span></span><br></pre></td></tr></table></figure><p>以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Parent.vue</span></span><br></pre></td></tr></table></figure><p>当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。</p><h3 id="谈谈你对-keep-alive-的了解？"><a href="#谈谈你对-keep-alive-的了解？" class="headerlink" title="谈谈你对 keep-alive 的了解？"></a>谈谈你对 keep-alive 的了解？</h3><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p><ul><li>一般结合路由和动态组件一起使用，用于缓存组件；</li><li>提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；</li><li>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</li></ul><h3 id="组件中-data-为什么是一个函数？"><a href="#组件中-data-为什么是一个函数？" class="headerlink" title="组件中 data 为什么是一个函数？"></a>组件中 data 为什么是一个函数？</h3><p>为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// data</span></span><br></pre></td></tr></table></figure><p>因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。</p><h3 id="v-model-的原理？"><a href="#v-model-的原理？" class="headerlink" title="v-model 的原理？"></a>v-model 的原理？</h3><p>我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p><ul><li>text 和 textarea 元素使用 value 属性和 input 事件；</li><li>checkbox 和 radio 使用 checked 属性和 change 事件；</li><li>select 字段将 value 作为 prop 并将 change 作为事件。</li></ul><p>以 input 表单元素为例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">'something'</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父组件：</span><br></pre></td></tr></table></figure><h3 id="Vue-组件间通信有哪几种方式？"><a href="#Vue-组件间通信有哪几种方式？" class="headerlink" title="Vue 组件间通信有哪几种方式？"></a>Vue 组件间通信有哪几种方式？</h3><p>Vue 组件间通信是面试常考的知识点之一，这题有点类似于开放题，你回答出越多方法当然越加分，表明你对 Vue 掌握的越熟练。Vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。</p><p><strong>（1）props / $emit 适用 父子组件通信</strong></p><p>这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。</p><p><strong>（2）ref 与 <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://math.jianshu.com/math?formula=parent%20%2F" alt="parent /" title>                </div>                <div class="image-caption">parent /</div>            </figure>children 适用 父子组件通信</strong></p><ul><li>ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</li><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://math.jianshu.com/math?formula=parent%20%2F" alt="parent /" title>                </div>                <div class="image-caption">parent /</div>            </figure>children：访问父 / 子实例</li></ul><p><strong>（3）EventBus （<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://math.jianshu.com/math?formula=emit%20%2F" alt="emit /" title>                </div>                <div class="image-caption">emit /</div>            </figure>on） 适用于 父子、隔代、兄弟组件通信</strong></p><p>这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。</p><p><strong>（4）<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://math.jianshu.com/math?formula=attrs%2F" alt="attrs/" title>                </div>                <div class="image-caption">attrs/</div>            </figure>listeners 适用于 隔代组件通信</strong></p><ul><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://math.jianshu.com/math?formula=attrs%EF%BC%9A%E5%8C%85%E5%90%AB%E4%BA%86%E7%88%B6%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E4%B8%8D%E8%A2%AB%20prop%20%E6%89%80%E8%AF%86%E5%88%AB%20(%E4%B8%94%E8%8E%B7%E5%8F%96)%20%E7%9A%84%E7%89%B9%E6%80%A7%E7%BB%91%E5%AE%9A%20(%20class%20%E5%92%8C%20style%20%E9%99%A4%E5%A4%96%20)%E3%80%82%E5%BD%93%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6%E6%B2%A1%E6%9C%89%E5%A3%B0%E6%98%8E%E4%BB%BB%E4%BD%95%20prop%20%E6%97%B6%EF%BC%8C%E8%BF%99%E9%87%8C%E4%BC%9A%E5%8C%85%E5%90%AB%E6%89%80%E6%9C%89%E7%88%B6%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E7%BB%91%E5%AE%9A%20(%20class%20%E5%92%8C%20style%20%E9%99%A4%E5%A4%96%20)%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%20v-bind%3D%22" alt="attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind=" " title>                </div>                <div class="image-caption">attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind="</div>            </figure>attrs" 传入内部组件。通常配合 inheritAttrs 选项一起使用。</li><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://math.jianshu.com/math?formula=listeners%EF%BC%9A%E5%8C%85%E5%90%AB%E4%BA%86%E7%88%B6%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E7%9A%84%20(%E4%B8%8D%E5%90%AB%20.native%20%E4%BF%AE%E9%A5%B0%E5%99%A8%E7%9A%84)%20v-on%20%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8%E3%80%82%E5%AE%83%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%20v-on%3D%22" alt="listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=" " title>                </div>                <div class="image-caption">listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on="</div>            </figure>listeners" 传入内部组件</li></ul><p><strong>（5）provide / inject 适用于 隔代组件通信</strong></p><p>祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。</p><p><strong>（6）Vuex 适用于 父子、隔代、兄弟组件通信</strong></p><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p><ul><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><li>改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</li></ul><h4 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h4><h5 id="props"><a href="#props" class="headerlink" title="props"></a>props</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//child</span><br><span class="line">props: &#123;</span><br><span class="line">  msg: String;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// parent</span><br><span class="line">&lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot; /&gt;;</span><br></pre></td></tr></table></figure><h5 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// parent</span><br><span class="line">&lt;HelloWorld ref=&quot;hw&quot; /&gt;</span><br><span class="line"></span><br><span class="line">this.$refs.hw.xx</span><br></pre></td></tr></table></figure><h4 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// child</span><br><span class="line">this.$emit(&apos;add&apos;, good)</span><br><span class="line"></span><br><span class="line">// parent</span><br><span class="line">&lt;div @add=&quot;cartAdd($event)&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="sync-传参绑定"><a href="#sync-传参绑定" class="headerlink" title=".sync 传参绑定"></a>.sync 传参绑定</h4><p>.sync 其实也是事件传参的语法糖，父组件 以这样的形式@update:msg=”changeEmit” 子组件 this.$emit(‘update:msg’,this.msg)进行触发 而sync是可以进行简写的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">        &#123;&#123;msg&#125;&#125;</span><br><span class="line">        &lt;son @update:msg=&quot;changeEmit&quot;&gt;&lt;/son&gt;</span><br><span class="line">        // 这下面是上面的语法糖，可以简写成这样</span><br><span class="line">        &lt;son :msg.sync=&quot;msg&quot;&gt;&lt;/son&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import son from &apos;./son.vue&apos;</span><br><span class="line">    export default &#123;</span><br><span class="line">        components:&#123;</span><br><span class="line">            son</span><br><span class="line">        &#125;,</span><br><span class="line">        data()&#123;</span><br><span class="line">            return&#123;</span><br><span class="line">                msg:&quot;我是父亲&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            changeEmit(value)&#123;</span><br><span class="line">                this.msg = value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">     &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data()&#123;</span><br><span class="line">             return&#123;</span><br><span class="line">                  msg:&quot;我是儿子emit&quot;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">         mounted() &#123;</span><br><span class="line">              this.$emit(&apos;update:msg&apos;,this.msg)</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="兄弟组件：通过共同祖辈组件"><a href="#兄弟组件：通过共同祖辈组件" class="headerlink" title="兄弟组件：通过共同祖辈组件"></a>兄弟组件：通过共同祖辈组件</h4><p>通过共同的祖辈组件搭桥，$parent或$root。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// brother1</span></span><br><span class="line"><span class="keyword">this</span>.$parent.$on(<span class="string">"foo"</span>, handle);</span><br><span class="line"><span class="comment">// brother2</span></span><br><span class="line"><span class="keyword">this</span>.$parent.$emit(<span class="string">"foo"</span>);</span><br></pre></td></tr></table></figure><h4 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h4><p>EventBus 又称为事件总线。在Vue中可以使用 EventBus 来作为沟通桥梁的概念， 就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件， 所以组件都可以上下平行地通知其他组件，但也就是太方便所以若使用不慎， 就会造成难以维护的灾难，因此才需要更完善的Vuex作为状态管理中心，将通知的概念上升到共享状态层次。</p><p>平常我们采用更多的是父传子，子传父，当遇到兄弟之间的组件通信的时候 就可以使用EventBus<br>如下例 Vue.prototype.$EventBus = new Vue() 这句话的意思是 因为Vue的原型上有$on $emit 方法 继承自vue原型上的方法，实现一个发布订阅模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">//这句话的意思是 因为Vue的原型上有$on $emit 方法 继承自vue原型上的方法，实现一个发布订阅模式</span><br><span class="line">Vue.prototype.$EventBus = new Vue()</span><br><span class="line">// 父组件-----------------</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">        &#123;&#123;msg&#125;&#125;</span><br><span class="line">        &lt;son&gt;&lt;/son&gt;</span><br><span class="line">        &lt;son1&gt;&lt;/son1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import son from &apos;./son.vue&apos;</span><br><span class="line">    import son1 from &apos;./son1.vue&apos;</span><br><span class="line">    export default &#123;</span><br><span class="line">        components:&#123;</span><br><span class="line">            son,</span><br><span class="line">            son1</span><br><span class="line">        &#125;,</span><br><span class="line">        data()&#123;</span><br><span class="line">            return&#123;</span><br><span class="line">                msg:&quot;我是父亲&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// 子组件son------------------------</span><br><span class="line">&lt;template&gt;</span><br><span class="line">     &lt;div&gt;</span><br><span class="line">          &lt;span&gt;&#123;&#123;sonValue&#125;&#125;&lt;/span&gt;</span><br><span class="line">     &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data()&#123;</span><br><span class="line">          return&#123;</span><br><span class="line">               sonValue:&quot;我是son1&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">         mounted() &#123;</span><br><span class="line">             this.$EventBus.$on(&apos;son1&apos;,(val)=&gt;&#123;</span><br><span class="line">                  this.sonValue = val</span><br><span class="line">             &#125;)</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// 子组件son1----------------</span><br><span class="line">&lt;template&gt;</span><br><span class="line">     &lt;div&gt;</span><br><span class="line">          &lt;span&gt;&#123;&#123;sonValue&#125;&#125;&lt;/span&gt;</span><br><span class="line">          &lt;button @click=&quot;btn&quot;&gt;在son1里面改变son的值&lt;/button&gt;</span><br><span class="line">     &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data()&#123;</span><br><span class="line">          return&#123;</span><br><span class="line">               sonValue:&quot;我是son2&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">         methods:&#123;</span><br><span class="line">             btn()&#123;</span><br><span class="line">                  this.$EventBus.$emit(&apos;son1&apos;,&apos;在son1里面改变son的值&apos;)</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">​``` --&gt;</span><br><span class="line"></span><br><span class="line">### 祖先和后代之间</span><br><span class="line"></span><br><span class="line">provide/inject：能够实现祖先给后代传值</span><br><span class="line"></span><br><span class="line">​```javascript</span><br><span class="line">// ancestor</span><br><span class="line">provide() &#123;    </span><br><span class="line">    return &#123;foo: &apos;foo&apos;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// descendant</span><br><span class="line">inject: [&apos;foo&apos;]</span><br></pre></td></tr></table></figure><h4 id="dispatch：后代给祖先传值"><a href="#dispatch：后代给祖先传值" class="headerlink" title="dispatch：后代给祖先传值"></a>dispatch：后代给祖先传值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个dispatch方法，指定要派发事件名称和数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">eventName, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> parent = <span class="keyword">this</span>.$parent;</span><br><span class="line">  <span class="comment">// 只要还存在父元素就继续往上查找</span></span><br><span class="line">  <span class="keyword">while</span> (parent) &#123;</span><br><span class="line">    <span class="comment">// 父元素用$emit触发</span></span><br><span class="line">    parent.$emit(eventName, data);</span><br><span class="line">    <span class="comment">// 递归查找父元素</span></span><br><span class="line">    parent = parent.$parent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用，HelloWorld.vue</span></span><br><span class="line">&lt;h1 @click=<span class="string">"dispatch('hello', 'hello,world')"</span>&gt;&#123;&#123; msg &#125;&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ App.vue</span></span><br><span class="line"><span class="regexp">this.$on('hello', this.sayHello)</span></span><br></pre></td></tr></table></figure><h4 id="任意两个组件之间：事件总线-或-vuex"><a href="#任意两个组件之间：事件总线-或-vuex" class="headerlink" title="任意两个组件之间：事件总线 或 vuex"></a>任意两个组件之间：事件总线 或 vuex</h4><p>事件总线：创建一个 Bus 类负责事件派发、监听和回调管理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bus：事件派发、监听和回调管理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//   eventName1:[fn1,fn2],</span></span><br><span class="line">    <span class="comment">//   eventName2:[fn3,fn4],</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">this</span>.callbacks = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  $on(name, fn) &#123;</span><br><span class="line">    <span class="keyword">this</span>.callbacks[name] = <span class="keyword">this</span>.callbacks[name] || [];</span><br><span class="line">    <span class="keyword">this</span>.callbacks[name].push(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  $emit(name, args) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.callbacks[name]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.callbacks[name].forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb(args));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line">Vue.prototype.$bus = <span class="keyword">new</span> Bus()</span><br><span class="line"></span><br><span class="line"><span class="comment">// child1 </span></span><br><span class="line"><span class="keyword">this</span>.$bus.$on(<span class="string">'foo'</span>, handle) </span><br><span class="line"><span class="comment">// child2 </span></span><br><span class="line"><span class="keyword">this</span>.$bus.$emit(<span class="string">'foo'</span>)</span><br></pre></td></tr></table></figure><p>vuex：创建唯一的全局数据管理者 store，通过它管理数据并通知组件状态变更</p><h3 id="sync修饰符"><a href="#sync修饰符" class="headerlink" title=".sync修饰符"></a>.sync修饰符</h3><h4 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h4><p>可以实现子组件与父组件数据的双向绑定，简化代码</p><p>简单理解:子组件可以修改父组件传过来的props值</p><h4 id="2-场景"><a href="#2-场景" class="headerlink" title="2.场景"></a>2.场景</h4><p>封装弹框类的基础组件， visible属性true显示false隐藏</p><p>特点:prop属性名，可以自定义，非固定为value</p><h4 id="3-本质"><a href="#3-本质" class="headerlink" title="3.本质"></a>3.本质</h4><p>.sync修饰符就是:属性名和@update:属性名合写</p><p>.sync(有语义)</p><p>:属性.sync=’数据’ 相当于</p><p>：属性=“数据“ + @update：属性=”数据=$event”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;base-select :selectId=&quot;selectId&quot;@update:selectId=&quot;selectId = $event&quot; &gt;</span><br></pre></td></tr></table></figure><p>相当于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;base-select :selectId.sync=&quot;selectId&quot;/&gt;</span><br></pre></td></tr></table></figure><p>v-model中的value不具有语义，要使其有语义写成 <strong>：属性名=” 数据” @update:属性名=” 数据”</strong></p><p>来替换原来的 <strong>：属性名=”数据” @input=”数据”</strong></p><h4 id="4-案例一"><a href="#4-案例一" class="headerlink" title="4.案例一"></a>4.案例一</h4><p>App.vue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;大标题&lt;/h1&gt;</span><br><span class="line">    &lt;!-- &lt;header-comp :projectId=&quot;selectId&quot; @changeId=&quot;selectId=$event&quot;&gt;&lt;/header-comp&gt; --&gt;</span><br><span class="line">&lt;header-comp :selectId=&quot;selectId&quot; @update:selectId=&quot;selectId=$event&quot;&gt;&lt;/header-comp&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">import HeaderComp from &apos;./components/HeaderComp.vue&apos;</span><br><span class="line"> </span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    HeaderComp</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      selectId: &apos;2&apos;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> </span><br><span class="line">&lt;style&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>HeaderComp.vue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;fa&quot;&gt;</span><br><span class="line">    &lt;h2&gt;h2文章二级标题&lt;/h2&gt;</span><br><span class="line">&lt;select name=&quot;&quot; id=&quot;&quot; :value=&quot;selectId&quot;  @change=&quot;handleChange&quot;&gt;</span><br><span class="line">  &lt;option value=&quot;1&quot;&gt;html&lt;/option&gt;</span><br><span class="line">  &lt;option value=&quot;2&quot;&gt;css&lt;/option&gt;</span><br><span class="line">  &lt;option value=&quot;3&quot;&gt;js&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line"> </span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    selectId: String</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleChange (e) &#123;</span><br><span class="line">      console.log(e.target.value)</span><br><span class="line">      this.$emit(&apos;update:selectId&apos;, e.target.value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> </span><br><span class="line">&lt;style&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>用.sync修饰符简化，只需将App.vue中的子组件标签写成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;header-comp :selectId.sync=&quot;selectId&quot;&gt;&lt;/header-comp&gt;</span><br></pre></td></tr></table></figure><h4 id="5-案例二"><a href="#5-案例二" class="headerlink" title="5.案例二"></a>5.案例二</h4><p>father.vue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line"> &lt;input type=&quot;text&quot; v-model=&quot;wrd&quot;&gt;</span><br><span class="line"> &lt;box :wrd.sync=&quot;wrd&quot;&gt;&lt;/box&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import box from &apos;./box&apos;</span><br><span class="line">export default &#123;</span><br><span class="line"> name: &apos;HelloWorld&apos;,</span><br><span class="line"> data() &#123;</span><br><span class="line"> return &#123;</span><br><span class="line">  wrd: &apos;&apos;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> methods: &#123;</span><br><span class="line"> boxIncremend(e) &#123;</span><br><span class="line">  this.wrd = e</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> components: &#123;</span><br><span class="line"> box</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>child.vue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; v-model=&quot;str&quot;&gt;</span><br><span class="line"> &lt;h2&gt;&#123;&#123; word &#125;&#125;&lt;/h2&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line"> name: &apos;box&apos;,</span><br><span class="line"> props: &#123;</span><br><span class="line"> word: &apos;&apos;</span><br><span class="line"> &#125;,</span><br><span class="line"> watch: &#123;</span><br><span class="line"> str: function(newword) &#123;</span><br><span class="line">  //往父级发射incre事件</span><br><span class="line">  this.$emit(&apos;update:word&apos;, newword)</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>父组件中的子组件，少写了一个自定义事件属性，子组件中$emit直接出发父组件中数据的更新，清新明了。使用中需要注意的是，update和后面对应的数据名不能写错。 </p><h3 id="你使用过-Vuex-吗？"><a href="#你使用过-Vuex-吗？" class="headerlink" title="你使用过 Vuex 吗？"></a>你使用过 Vuex 吗？</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p><p>（1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p><p>（2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</p><p>主要包括以下几个模块：</p><ul><li>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li><li>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li><li>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。</li><li>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</li><li>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</li></ul><h3 id="使用过-Vue-SSR-吗？说说-SSR？"><a href="#使用过-Vue-SSR-吗？说说-SSR？" class="headerlink" title="使用过 Vue SSR 吗？说说 SSR？"></a>使用过 Vue SSR 吗？说说 SSR？</h3><blockquote><p>Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。</p><p>即：SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。</p></blockquote><h3 id="服务端渲染-SSR-的优缺点如下："><a href="#服务端渲染-SSR-的优缺点如下：" class="headerlink" title="服务端渲染 SSR 的优缺点如下："></a>服务端渲染 SSR 的优缺点如下：</h3><p>（1）服务端渲染的优点：</p><ul><li>更好的 SEO：因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</li><li>更快的内容到达时间（首屏加载更快）：SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；</li></ul><p>（2) 服务端渲染的缺点：</p><ul><li>更多的开发条件限制：例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</li><li>更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</li></ul><p>如果没有 SSR 开发经验的同学，可以参考本文作者的另一篇 SSR 的实践文章《Vue SSR 踩坑之旅》，里面 SSR 项目搭建以及附有项目源码。</p><h3 id="vue-router-路由模式有几种？"><a href="#vue-router-路由模式有几种？" class="headerlink" title="vue-router 路由模式有几种？"></a>vue-router 路由模式有几种？</h3><p>vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (mode) &#123;</span><br></pre></td></tr></table></figure><p>其中，3 种路由模式的说明如下：</p><ul><li>hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；</li><li>history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；</li><li>abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</li></ul><h3 id="能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？"><a href="#能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？" class="headerlink" title="能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？"></a>能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？</h3><h4 id="（1）hash-模式的实现原理"><a href="#（1）hash-模式的实现原理" class="headerlink" title="（1）hash 模式的实现原理"></a>（1）hash 模式的实现原理</h4><p>早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 ‘#search’：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.word.com<span class="comment">#search</span></span><br></pre></td></tr></table></figure><p>hash 路由模式的实现主要是基于下面几个特性：</p><ul><li>URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；</li><li>hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；</li><li>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；</li><li>我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。</li></ul><h4 id="（2）history-模式的实现原理"><a href="#（2）history-模式的实现原理" class="headerlink" title="（2）history 模式的实现原理"></a>（2）history 模式的实现原理</h4><p>HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.history.pushState(<span class="keyword">null</span>, <span class="keyword">null</span>, path);</span><br></pre></td></tr></table></figure><p>history 路由模式的实现主要基于存在下面几个特性：</p><ul><li>pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；</li><li>我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）；</li><li>history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。</li></ul><h3 id="什么是-MVVM？"><a href="#什么是-MVVM？" class="headerlink" title="什么是 MVVM？"></a>什么是 MVVM？</h3><p>Model–View–ViewModel （MVVM） 是一个软件架构设计模式，由微软 WPF 和 Silverlight 的架构师 Ken Cooper 和 Ted Peters 开发，是一种简化用户界面的事件驱动编程方式。由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于2005年在他的博客上发表</p><p>MVVM 源自于经典的 Model–View–Controller（MVC）模式 ，MVVM 的出现促进了前端开发与后端业务逻辑的分离，极大地提高了前端开发效率，MVVM 的核心是 ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https:////upload-images.jianshu.io/upload_images/12842279-5af933c42fa81a9e?imageMogr2/auto-orient/strip|imageView2/2/w/640/format/webp" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><h4 id="（1）View-层"><a href="#（1）View-层" class="headerlink" title="（1）View 层"></a>（1）View 层</h4><p>View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。</p><h4 id="（2）Model-层"><a href="#（2）Model-层" class="headerlink" title="（2）Model 层"></a>（2）Model 层</h4><p>Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。</p><h4 id="（3）ViewModel-层"><a href="#（3）ViewModel-层" class="headerlink" title="（3）ViewModel 层"></a>（3）ViewModel 层</h4><p>ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。</p><p>需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的，比如页面的这一块展示什么，而页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互），视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。</p><p>MVVM 框架实现了双向绑定，这样 ViewModel 的内容会实时展现在 View 层，前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新。</p><p>这样 View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。</p><p>我们以下通过一个 Vue 实例来说明 MVVM 的具体实现，有 Vue 开发经验的同学应该一目了然：</p><p>（1）View 层</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="keyword">id</span>=<span class="string">"app"</span>&gt;</span><br></pre></td></tr></table></figure><p>（2）ViewModel 层</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br></pre></td></tr></table></figure><p>（3） Model 层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure><h3 id="Vue-是如何实现数据双向绑定的？"><a href="#Vue-是如何实现数据双向绑定的？" class="headerlink" title="Vue 是如何实现数据双向绑定的？"></a>Vue 是如何实现数据双向绑定的？</h3><p>Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据，如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https:////upload-images.jianshu.io/upload_images/12842279-965e38fb3e4c6774?imageMogr2/auto-orient/strip|imageView2/2/w/492/format/webp" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>即：</p><ul><li>输入框内容变化时，Data 中的数据同步变化。即 View =&gt; Data 的变化。</li><li>Data 中的数据变化时，文本节点的内容同步变化。即 Data =&gt; View 的变化。</li></ul><p>其中，View 变化更新 Data ，可以通过事件监听的方式来实现，所以 Vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View。</p><p>Vue 主要通过以下 4 个步骤来实现数据双向绑定的：</p><p>实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。</p><p>实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。</p><p>实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。</p><p>实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。</p><p>以上四个步骤的流程图表示如下，如果有同学理解不大清晰的，可以查看作者专门介绍数据双向绑定的文章《0 到 1 掌握：Vue 核心之数据双向绑定》，有进行详细的讲解、以及代码 demo 示例。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https:////upload-images.jianshu.io/upload_images/12842279-fd64627956b167e5?imageMogr2/auto-orient/strip|imageView2/2/w/640/format/webp" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><h3 id="Vue-框架怎么实现对象和数组的监听？"><a href="#Vue-框架怎么实现对象和数组的监听？" class="headerlink" title="Vue 框架怎么实现对象和数组的监听？"></a>Vue 框架怎么实现对象和数组的监听？</h3><p>如果被问到 Vue 怎么实现数据双向绑定，大家肯定都会回答 通过 Object.defineProperty() 对数据进行劫持，但是 Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持，同理无法对数组进行劫持，但是我们在使用 Vue 框架中都知道，Vue 能检测到对象和数组（部分方法的操作）的变化，那它是怎么实现的呢？我们查看相关代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br></pre></td></tr></table></figure><p>通过以上 Vue 源码部分查看，我们就能知道 Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。</p><h3 id="Proxy-与-Object-defineProperty-优劣对比"><a href="#Proxy-与-Object-defineProperty-优劣对比" class="headerlink" title="Proxy 与 Object.defineProperty 优劣对比"></a>Proxy 与 Object.defineProperty 优劣对比</h3><p>Proxy 的优势如下:</p><ul><li>Proxy 可以直接监听对象而非属性；</li><li>Proxy 可以直接监听数组的变化；</li><li>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；</li><li>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；</li><li>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；</li></ul><p>Object.defineProperty 的优势如下:</p><ul><li>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。</li></ul><h3 id="vue中this-set的用法"><a href="#vue中this-set的用法" class="headerlink" title="vue中this.$set的用法"></a>vue中this.$set的用法</h3><p>当你发现你给对象加了一个属性，在控制台能打印出来，但是却没有更新到视图上时，也许这个时候就需要用到this.$set（）这个方法了，简单来说this.$set的功能就是解决这个问题的啦。</p><p>官方解释：向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性 (比如 this.myObject.newProperty = ‘hi’)</p><p>调用方法：this.$set( target, key, value )</p><p>🌹 target：要更改的数据源(可以是对象或者数组)</p><p>🌹 key：要更改的具体数据</p><p>🌹 value ：重新赋的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 不能动态修改值</span><br><span class="line">item2.price = 0</span><br><span class="line">this.arr[2] = 0</span><br><span class="line">this.$set(item, &apos;price&apos;, 0)// 对象给item设置新属性price，值为0，可以动态修改</span><br><span class="line">this.$set(this.arr, 2, 0) // 数组给第三个元素赋值为0</span><br></pre></td></tr></table></figure><h3 id="vue更新数组时触发视图更新的方法"><a href="#vue更新数组时触发视图更新的方法" class="headerlink" title="vue更新数组时触发视图更新的方法"></a>vue更新数组时触发视图更新的方法</h3><p>1.Vue.set 可以设置对象或数组的值，通过 key 或数组索引，可以触发视图更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数组修改</span><br><span class="line">Vue.set(array, indexOfItem, newValue)</span><br><span class="line">this.array.$set(indexOfItem, newValue)</span><br><span class="line"></span><br><span class="line">对象修改</span><br><span class="line">Vue.set(obj, keyOfItem, newValue)</span><br><span class="line">this.obj.$set(keyOfItem, newValue)</span><br></pre></td></tr></table></figure><p>2.Vue.delete 删除对象或数组中元素，通过 key 或数组索引，可以触发视图更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数组修改</span><br><span class="line">Vue.delete(array, indexOfItem)</span><br><span class="line">this.array.$delete(indexOfItem)</span><br><span class="line"></span><br><span class="line">对象修改</span><br><span class="line">Vue.delete(obj, keyOfItem)</span><br><span class="line">this.obj.$delete(keyOfItem)</span><br></pre></td></tr></table></figure><p>3.数组对象直接修改属性，可以触发视图更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.array[0].show = true;</span><br><span class="line">this.array.forEach(function(item)&#123;</span><br><span class="line">    item.show = true;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>4.splice 方法修改数组，可以触发视图更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.array.splice(indexOfItem, 1, newElement)</span><br></pre></td></tr></table></figure><p>5.数组整体修改，可以触发视图更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var tempArray = this.array;</span><br><span class="line">tempArray[0].show = true;</span><br><span class="line">this.array = tempArray;</span><br></pre></td></tr></table></figure><p>6.用 Object.assign 或 lodash.assign 可以为对象添加响应式属性，可以触发视图更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//Object.assign的单层的覆盖前面的属性，不会递归的合并属性</span><br><span class="line">this.obj = Object.assign(&#123;&#125;,this.obj,&#123;a:1, b:2&#125;)</span><br><span class="line"></span><br><span class="line">//assign与Object.assign一样</span><br><span class="line">this.obj = _.assign(&#123;&#125;,this.obj,&#123;a:1, b:2&#125;)</span><br><span class="line"></span><br><span class="line">//merge会递归的合并属性</span><br><span class="line">this.obj = _.merge(&#123;&#125;,this.obj,&#123;a:1, b:2&#125;)</span><br></pre></td></tr></table></figure><p>7.Vue 提供了如下的数组的变异方法，可以触发视图更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">push()</span><br><span class="line">pop()</span><br><span class="line">shift()</span><br><span class="line">unshift()</span><br><span class="line">splice()</span><br><span class="line">sort()</span><br><span class="line">reverse()</span><br></pre></td></tr></table></figure><h3 id="直接给一个数组项赋值，Vue-能检测到变化吗？-1"><a href="#直接给一个数组项赋值，Vue-能检测到变化吗？-1" class="headerlink" title="直接给一个数组项赋值，Vue 能检测到变化吗？"></a>直接给一个数组项赋值，Vue 能检测到变化吗？</h3><p>由于 JavaScript 的限制，Vue 不能检测到以下数组的变动：</p><ul><li>当你利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code></li><li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li></ul><p>为了解决第一个问题，Vue 提供了以下操作方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Vue.set</span><br><span class="line">Vue.set(vm.items, indexOfItem, newValue)</span><br><span class="line">// vm.$set，Vue.set的一个别名</span><br><span class="line">vm.$set(vm.items, indexOfItem, newValue)</span><br><span class="line">// Array.prototype.splice</span><br><span class="line">vm.items.splice(indexOfItem, 1, newValue)</span><br></pre></td></tr></table></figure><p>为了解决第二个问题，Vue 提供了以下操作方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Array.prototype.splice</span><br><span class="line">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure><h3 id="vue更新数组时触发视图更新的方法-1"><a href="#vue更新数组时触发视图更新的方法-1" class="headerlink" title="vue更新数组时触发视图更新的方法"></a>vue更新数组时触发视图更新的方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Vue.set    ==========Vue.set(target,key,value)这个方法主要是用于避开vue不能检测属性被添加的限制</span><br><span class="line">Vue.set(array, indexOfItem, newValue)<span class="comment">//indexOfItem指的索引</span></span><br><span class="line"><span class="keyword">this</span>.array.$<span class="keyword">set</span>(indexOfItem, newValue)</span><br><span class="line">Vue.<span class="keyword">set</span>(obj, keyOfItem, newValue)</span><br><span class="line">this.obj.$<span class="keyword">set</span>(keyOfItem, newValue)</span><br><span class="line">Vue.delete   这个方法主要用于避开vue不能检测到属性被删除；</span><br><span class="line"></span><br><span class="line">Vue.delete(array, indexOfItem)</span><br><span class="line">this.array.$delete(indexOfItem)</span><br><span class="line">Vue.delete(obj, keyOfItem)</span><br><span class="line">this.obj.$delete(keyOfItem)</span><br></pre></td></tr></table></figure><h3 id="vue的数据是响应式的，请问什么时候是非响应式的并如何解决"><a href="#vue的数据是响应式的，请问什么时候是非响应式的并如何解决" class="headerlink" title="vue的数据是响应式的，请问什么时候是非响应式的并如何解决"></a>vue的数据是响应式的，请问什么时候是非响应式的并如何解决</h3><h4 id="数组数据："><a href="#数组数据：" class="headerlink" title="数组数据："></a>数组数据：</h4><p>问题1：通过改变长度，利用索引直接设置跟项</p><p>解决：Vue.set(数组对象, key, value)            |         vm|this.$set(数组对象, key, value)</p><p>问题2：对数组使用了非变异 (non-mutating method) 方法（返回的了新数组）</p><p>解决：对象合并</p><h4 id="对象数据变化："><a href="#对象数据变化：" class="headerlink" title="对象数据变化："></a>对象数据变化：</h4><p>问题：问题：data:{a:1}；a 数据是响应式的；vm.b=’qq’; b 属性不是响应式的</p><p>解决：Vue.set(对象, key, value)              |              vm|this.$set(对象, key, value)</p><p>总结：数据一开始就应该出现在data里，数组里面永远不要放置简单性数据</p><h3 id="vm-set-obj-key-val-做了什么？"><a href="#vm-set-obj-key-val-做了什么？" class="headerlink" title="vm.$set(obj, key, val) 做了什么？"></a>vm.$set(obj, key, val) 做了什么？</h3><p>由于 Vue 无法探测对象新增属性或者通过索引为数组新增一个元素，所以这才有了 vm.set ， 它 是 Vue.set 的 别 名 。 vm.set，它是 Vue.set 的别名。 vm.set，它是Vue.set的别名。vm.set 用于向响应式对象添加一个新的 property，并确保这个新的 property 同样是响应式的，并触发视图更新。</p><p>为对象添加一个新的响应式数据：调用 defineReactive 方法为对象增加响应式数据，然后执行 dep.notify 进行依赖通知，更新视图<br>为数组添加一个新的响应式数据：通过 splice 方法实现</p><h3 id="Vue-怎么用-vm-set-解决对象新增属性不能响应的问题-？"><a href="#Vue-怎么用-vm-set-解决对象新增属性不能响应的问题-？" class="headerlink" title="Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？"></a>Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？</h3><p>受现代 JavaScript 的限制 ，Vue 无法检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。</p><p>但是 Vue 提供了<code>Vue.set (object, propertyName, value) / vm.$set (object, propertyName, value)</code> 来实现为对象添加响应式属性，那框架本身是如何实现的呢？</p><p>我们查看对应的 Vue 源码：<code>vue/src/core/instance/index.js</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">export function set (target: Array&lt;any&gt; | Object, key: any, val: any): any &#123;</span><br><span class="line">  // target 为数组  </span><br><span class="line">  if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    // 修改数组的长度, 避免索引&gt;数组长度导致splcie()执行有误</span><br><span class="line">    target.length = Math.max(target.length, key)</span><br><span class="line">    // 利用数组的splice变异方法触发响应式  </span><br><span class="line">    target.splice(key, 1, val)</span><br><span class="line">    return val</span><br><span class="line">  &#125;</span><br><span class="line">  // key 已经存在，直接修改属性值  </span><br><span class="line">  if (key in target &amp;&amp; !(key in Object.prototype)) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    return val</span><br><span class="line">  &#125;</span><br><span class="line">  const ob = (target: any).__ob__</span><br><span class="line">  // target 本身就不是响应式数据, 直接赋值</span><br><span class="line">  if (!ob) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    return val</span><br><span class="line">  &#125;</span><br><span class="line">  // 对属性进行响应式处理</span><br><span class="line">  defineReactive(ob.value, key, val)</span><br><span class="line">  ob.dep.notify()</span><br><span class="line">  return val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们阅读以上源码可知，vm.$set 的实现原理是：</p><ul><li>如果目标是数组，直接使用数组的 splice 方法触发相应式；</li><li>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用   defineReactive 方法进行响应式处理（ defineReactive 方法就是  Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）</li></ul><h3 id="虚拟-DOM-的优缺点？"><a href="#虚拟-DOM-的优缺点？" class="headerlink" title="虚拟 DOM 的优缺点？"></a>虚拟 DOM 的优缺点？</h3><p>优点：</p><ul><li>保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</li><li>无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</li><li>跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</li></ul><p>缺点:</p><ul><li>无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。</li></ul><h3 id="虚拟-DOM-实现原理？"><a href="#虚拟-DOM-实现原理？" class="headerlink" title="虚拟 DOM 实现原理？"></a>虚拟 DOM 实现原理？</h3><p>虚拟 DOM 的实现原理主要包括以下 3 部分：</p><ul><li>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；</li><li>diff 算法 — 比较两棵虚拟 DOM 树的差异；</li><li>pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</li></ul><p>如果对以上 3 个部分还不是很了解的同学，可以查看本文作者写的另一篇详解虚拟 DOM 的文章《深入剖析：Vue核心之虚拟DOM》</p><h3 id="你有对-Vue-项目进行哪些优化？"><a href="#你有对-Vue-项目进行哪些优化？" class="headerlink" title="你有对 Vue 项目进行哪些优化？"></a>你有对 Vue 项目进行哪些优化？</h3><p>如果没有对 Vue 项目没有进行过优化总结的同学，可以参考本文作者的另一篇文章《 Vue 项目性能优化 — 实践指南 》，文章主要介绍从 3 个大方面，22 个小方面详细讲解如何进行 Vue 项目的优化。</p><h4 id="（1）代码层面的优化"><a href="#（1）代码层面的优化" class="headerlink" title="（1）代码层面的优化"></a>（1）代码层面的优化</h4><ul><li>v-if 和 v-show 区分使用场景</li><li>computed 和 watch 区分使用场景</li><li>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li><li>长列表性能优化</li><li>事件的销毁</li><li>图片资源懒加载</li><li>路由懒加载</li><li>第三方插件的按需引入</li><li>优化无限列表性能</li><li>服务端渲染 SSR or 预渲染</li></ul><h4 id="（2）Webpack-层面的优化"><a href="#（2）Webpack-层面的优化" class="headerlink" title="（2）Webpack 层面的优化"></a>（2）Webpack 层面的优化</h4><ul><li>Webpack 对图片进行压缩</li><li>减少 ES6 转为 ES5 的冗余代码</li><li>提取公共代码</li><li>模板预编译</li><li>提取组件的 CSS</li><li>优化 SourceMap</li><li>构建结果输出分析</li><li>Vue 项目的编译优化</li></ul><h4 id="（3）基础的-Web-技术的优化"><a href="#（3）基础的-Web-技术的优化" class="headerlink" title="（3）基础的 Web 技术的优化"></a>（3）基础的 Web 技术的优化</h4><ul><li>开启 gzip 压缩</li><li>浏览器缓存</li><li>CDN 的使用</li><li>使用 Chrome Performance 查找性能瓶颈</li></ul><h3 id="vue路由组件动态引入"><a href="#vue路由组件动态引入" class="headerlink" title="vue路由组件动态引入"></a>vue路由组件动态引入</h3><p>在Vue中，可以使用动态组件和Vue Router结合来实现路由组件的动态引入。以下是一个简单的例子：</p><p>安装Vue Router：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router</span><br></pre></td></tr></table></figure><p>设置Vue Router，并使用动态导入来懒加载组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// router.js</span><br><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line">import Router from &apos;vue-router&apos;;</span><br><span class="line"></span><br><span class="line">Vue.use(Router);</span><br><span class="line"></span><br><span class="line">function loadView(view) &#123;</span><br><span class="line">  return () =&gt; import(`@/views/$&#123;view&#125;.vue`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const router = new Router(&#123;</span><br><span class="line">  mode: &apos;history&apos;,</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/&apos;,</span><br><span class="line">      name: &apos;home&apos;,</span><br><span class="line">      component: loadView(&apos;Home&apos;) // 动态引入Home组件</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/about&apos;,</span><br><span class="line">      name: &apos;about&apos;,</span><br><span class="line">      component: loadView(&apos;About&apos;) // 动态引入About组件</span><br><span class="line">    &#125;,</span><br><span class="line">    // 更多路由...</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default router;</span><br></pre></td></tr></table></figure><p>在Vue实例中使用router：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line">import App from &apos;./App.vue&apos;;</span><br><span class="line">import router from &apos;./router&apos;;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;).$mount(&apos;#app&apos;);</span><br></pre></td></tr></table></figure><p>在上述代码中，loadView函数负责根据视图名称动态创建组件加载函数。当Vue Router匹配到相应路由时，会调用这个加载函数来懒加载对应的组件文件。这样可以实现按需加载，提高应用的初始化速度和性能。</p><h3 id="对于即将到来的-vue3-0-特性你有什么了解的吗？"><a href="#对于即将到来的-vue3-0-特性你有什么了解的吗？" class="headerlink" title="对于即将到来的 vue3.0 特性你有什么了解的吗？"></a>对于即将到来的 vue3.0 特性你有什么了解的吗？</h3><p>Vue 3.0 正走在发布的路上，Vue 3.0 的目标是让 Vue 核心变得更小、更快、更强大，因此 Vue 3.0 增加以下这些新特性：</p><h4 id="（1）监测机制的改变"><a href="#（1）监测机制的改变" class="headerlink" title="（1）监测机制的改变"></a>（1）监测机制的改变</h4><p>3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。这消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：</p><ul><li>只能监测属性，不能监测对象</li><li>检测属性的添加和删除；</li><li>检测数组索引和长度的变更；</li><li>支持 Map、Set、WeakMap 和 WeakSet。</li></ul><p>新的 observer 还提供了以下特性：</p><ul><li>用于创建 observable 的公开 API。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。</li><li>默认采用惰性观察。在 2.x 中，不管反应式数据有多大，都会在启动时被观察到。如果你的数据集很大，这可能会在应用启动时带来明显的开销。在 3.x 中，只观察用于渲染应用程序最初可见部分的数据。</li><li>更精确的变更通知。在 2.x 中，通过 Vue.set 强制添加新属性将导致依赖于该对象的 watcher 收到变更通知。在 3.x 中，只有依赖于特定属性的 watcher 才会收到通知。</li><li>不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 prop 传递或 Vuex 状态树以外的变化。</li><li>更好的调试功能：我们可以使用新的 renderTracked 和 renderTriggered 钩子精确地跟踪组件在什么时候以及为什么重新渲染。</li></ul><h4 id="（2）模板"><a href="#（2）模板" class="headerlink" title="（2）模板"></a>（2）模板</h4><p>模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。</p><p>同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。</p><h4 id="（3）对象式的组件声明方式"><a href="#（3）对象式的组件声明方式" class="headerlink" title="（3）对象式的组件声明方式"></a>（3）对象式的组件声明方式</h4><p>vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。</p><p>3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易。</p><p>此外，vue 的源码也改用了 TypeScript 来写。其实当代码的功能复杂之后，必须有一个静态类型系统来做一些辅助管理。</p><p>现在 vue3.0 也全面改用 TypeScript 来重写了，更是使得对外暴露的 api 更容易结合 TypeScript。静态类型系统对于复杂代码的维护确实很有必要。</p><h4 id="（4）其它方面的更改"><a href="#（4）其它方面的更改" class="headerlink" title="（4）其它方面的更改"></a>（4）其它方面的更改</h4><p>vue3.0 的改变是全面的，上面只涉及到主要的 3 个方面，还有一些其他的更改：</p><ul><li>支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。</li><li>支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。</li><li>基于 treeshaking 优化，提供了更多的内置功能。</li></ul><h2 id="说说你使用-Vue-框架踩过最大的坑是什么？怎么解决的？"><a href="#说说你使用-Vue-框架踩过最大的坑是什么？怎么解决的？" class="headerlink" title="说说你使用 Vue 框架踩过最大的坑是什么？怎么解决的？"></a>说说你使用 Vue 框架踩过最大的坑是什么？怎么解决的？</h2><p>本题为开放题目，Vue框架部分我们会涉及一些高频且有一定探讨价值的面试题,我们不会涉及一些非常初级的在官方文档就能查看的纯记忆性质的面试题,比如:</p><ul><li>vue常用的修饰符?</li><li>vue-cli 工程常用的 npm 命令有哪些？</li><li>vue中 keep-alive 组件的作用?</li></ul><p>首先,上述类型的面试题在文档中可查,没有比官方文档更权威的答案了,其次这种问题没有太大价值,除了考察候选人的记忆力,最后,这种面试题只要用过vue的都知道,没有必要占用我们的篇幅.</p><p>我们的问题并不多,但是难度可能会高一些,如果你真的搞懂了这些问题,在绝大多数情况下会有举一反三的效果,可以说基本能拿下Vue相关的所有重要知识点了.</p><h3 id="MVVM是什么"><a href="#MVVM是什么" class="headerlink" title="MVVM是什么?"></a>MVVM是什么?</h3><p>MVVM 模式，顾名思义即 Model-View-ViewModel 模式。它萌芽于2005年微软推出的基于 Windows 的用户界面框架 WPF ，前端最早的 MVVM 框架 knockout 在2010年发布。</p><p>Model 层: 对应数据层的域模型，它主要做域模型的同步。通过 Ajax/fetch 等 API 完成客户端和服务端业务 Model 的同步。在层间关系里，它主要用于抽象出 ViewModel 中视图的 Model。</p><p>View 层:作为视图模板存在，在 MVVM 里，整个 View 是一个动态模板。除了定义结构、布局外，它展示的是 ViewModel 层的数据和状态。View 层不负责处理状态，View 层做的是 数据绑定的声明、 指令的声明、 事件绑定的声明。</p><p>ViewModel 层:把 View 需要的层数据暴露，并对 View 层的 数据绑定声明、 指令声明、 事件绑定声明 负责，也就是处理 View 层的具体业务逻辑。ViewModel 底层会做好绑定属性的监听。当 ViewModel 中数据变化，View 层会得到更新；而当 View 中声明了数据的双向绑定（通常是表单元素），框架也会监听 View 层（表单）值的变化。一旦值变化，View 层绑定的 ViewModel 中的数据也会得到自动更新。</p><h3 id="MVVM的优缺点"><a href="#MVVM的优缺点" class="headerlink" title="MVVM的优缺点?"></a>MVVM的优缺点?</h3><p>优点:</p><ol><li>分离视图（View）和模型（Model）,降低代码耦合，提高视图或者逻辑的重用性: 比如视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定不同的”View”上，当View变化的时候Model不可以不变，当Model变化的时候View也可以不变。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑</li><li>提高可测试性: ViewModel的存在可以帮助开发者更好地编写测试代码</li><li>自动更新dom: 利用双向绑定,数据更新后视图自动更新,让开发者从繁琐的手动dom中解放</li></ol><p>缺点:</p><ol><li>Bug很难被调试: 因为使用双向绑定的模式，当你看到界面异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。数据绑定使得一个位置的Bug被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了。另外，数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的</li><li>一个大的模块中model也会很大，虽然使用方便了也很容易保证了数据的一致性，当时长期持有，不释放内存就造成了花费更多的内存</li><li>对于大型的图形应用程序，视图状态较多，ViewModel的构建和维护的成本都会比较高</li></ol><h3 id="异步请求适合在哪个生命周期调用？"><a href="#异步请求适合在哪个生命周期调用？" class="headerlink" title="异步请求适合在哪个生命周期调用？"></a>异步请求适合在哪个生命周期调用？</h3><p>官方实例的异步请求是在mounted生命周期中调用的，而实际上也可以在created生命周期中调用。</p><h3 id="Vue组件如何通信？"><a href="#Vue组件如何通信？" class="headerlink" title="Vue组件如何通信？"></a>Vue组件如何通信？</h3><p>Vue组件通信的方法如下:</p><ul><li><code>props</code> <code>$emit+v-on</code>: 通过props将数据自上而下传递，而通过<code>$emit</code>和<code>v-on</code>来向上传递信息。</li><li>EventBus: 通过EventBus进行信息的发布与订阅</li><li>vuex: 是全局数据管理库，可以通过vuex管理全局的数据流</li><li><code>$attrs</code> <code>$listeners</code>: Vue2.4中加入的<code>$attrs/$listeners</code>可以进行跨级的组件通信</li><li><code>provide/inject</code>：以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效，这成为了跨组件通信的基础</li></ul><p>还有一些用solt插槽或者ref实例进行通信的，使用场景过于有限就不赘述了。</p><h3 id="computed和watch有什么区别"><a href="#computed和watch有什么区别" class="headerlink" title="computed和watch有什么区别?"></a>computed和watch有什么区别?</h3><p>computed:</p><ol><li><code>computed</code>是计算属性,也就是计算值,它更多用于计算值的场景</li><li><code>computed</code>具有缓存性,computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时才会重新调用对应的getter来计算</li><li><code>computed</code>适用于计算比较消耗性能的计算场景</li></ol><p>watch:</p><ol><li>更多的是「观察」的作用,类似于某些数据的监听回调,用于观察<code>props</code> <code>$emit</code>或者本组件的值,当数据变化时来执行回调进行后续操作</li><li>无缓存性，页面重新渲染时值不变化也会执行</li></ol><p>小结:</p><ol><li>当我们要进行数值计算,而且依赖于其他数据，那么把这个数据设计为computed</li><li>如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化</li></ol><h3 id="Vue是如何实现双向绑定的"><a href="#Vue是如何实现双向绑定的" class="headerlink" title="Vue是如何实现双向绑定的?"></a>Vue是如何实现双向绑定的?</h3><p>利用<code>Object.defineProperty</code>劫持对象的访问器,在属性值发生变化时我们可以获取变化,然后根据变化进行后续响应,在vue3.0中通过Proxy代理对象进行类似的操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是将要被劫持的对象</span></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">    name: <span class="string">''</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name === <span class="string">'古天乐'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'给大家推荐一款超好玩的游戏'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name === <span class="string">'渣渣辉'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'戏我演过很多,可游戏我只玩贪玩懒月'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'来做我的兄弟'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历对象,对其属性值进行劫持</span></span><br><span class="line"><span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'get'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function(newVal) &#123;</span><br><span class="line">        <span class="comment">// 当属性值发生变化时我们可以进行额外操作</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`大家好,我系<span class="subst">$&#123;newVal&#125;</span>`</span>);</span><br><span class="line">        say(newVal);</span><br><span class="line">    &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">data.name = <span class="string">'渣渣辉'</span>;</span><br><span class="line"><span class="comment">//大家好,我系渣渣辉</span></span><br><span class="line"><span class="comment">//戏我演过很多,可游戏我只玩贪玩懒月</span></span><br></pre></td></tr></table></figure><blockquote><p>详细实现见<a href="http://mp.weixin.qq.com/s?__biz=MzI3NjM1OTI3Mw==&mid=2247483695&idx=1&sn=8f4d74b58f4102eced8089bcaac4c443&chksm=eb77f029dc00793f502d4a39819e488d560e6bf7d268f3e987a03d43d71a07a2edab59d8d78f&scene=21#wechat_redirect" target="_blank" rel="noopener">Proxy比defineproperty优劣对比?</a></p></blockquote><h3 id="Proxy与Object-defineProperty的优劣对比"><a href="#Proxy与Object-defineProperty的优劣对比" class="headerlink" title="Proxy与Object.defineProperty的优劣对比?"></a>Proxy与Object.defineProperty的优劣对比?</h3><p>Proxy的优势如下:</p><ul><li>Proxy可以直接监听对象而非属性</li><li>Proxy可以直接监听数组的变化</li><li>Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是<code>Object.defineProperty</code>不具备的</li><li>Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而<code>Object.defineProperty</code>只能遍历对象属性直接修改</li><li>Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利</li></ul><p>Object.defineProperty的优势如下:</p><ul><li>兼容性好,支持IE9</li></ul><blockquote><p>详细实现见<a href="http://mp.weixin.qq.com/s?__biz=MzI3NjM1OTI3Mw==&mid=2247483695&idx=1&sn=8f4d74b58f4102eced8089bcaac4c443&chksm=eb77f029dc00793f502d4a39819e488d560e6bf7d268f3e987a03d43d71a07a2edab59d8d78f&scene=21#wechat_redirect" target="_blank" rel="noopener">Proxy比defineproperty优劣对比</a>?</p></blockquote><h3 id="你是如何理解Vue的响应式系统的"><a href="#你是如何理解Vue的响应式系统的" class="headerlink" title="你是如何理解Vue的响应式系统的?"></a>你是如何理解Vue的响应式系统的?</h3><p>响应式系统简述:</p><ul><li>任何一个 Vue Component 都有一个与之对应的 Watcher 实例。</li><li>Vue 的 data 上的属性会被添加 getter 和 setter 属性。</li><li>当 Vue Component render 函数被执行的时候, data 上会被 触碰(touch), 即被读, getter 方法会被调用, 此时 Vue 会去记录此 Vue component 所依赖的所有 data。(这一过程被称为依赖收集)</li><li>data 被改动时（主要是用户操作）, 即被写, setter 方法会被调用, 此时 Vue 会去通知所有依赖于此 data 的组件去调用他们的 render 函数进行更新。</li></ul><h3 id="虚拟DOM的优劣如何"><a href="#虚拟DOM的优劣如何" class="headerlink" title="虚拟DOM的优劣如何?"></a>虚拟DOM的优劣如何?</h3><p>优点:</p><ul><li>保证性能下限: 虚拟DOM可以经过diff找出最小差异,然后批量进行patch,这种操作虽然比不上手动优化,但是比起粗暴的DOM操作性能要好很多,因此虚拟DOM可以保证性能下限</li><li>无需手动操作DOM: 虚拟DOM的diff和patch都是在一次更新中自动进行的,我们无需手动操作DOM,极大提高开发效率</li><li>跨平台: 虚拟DOM本质上是JavaScript对象,而DOM与平台强相关,相比之下虚拟DOM可以进行更方便地跨平台操作,例如服务器渲染、移动端开发等等</li></ul><p>缺点:</p><ul><li>无法进行极致优化: 在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化,比如VScode采用直接手动操作DOM的方式进行极端的性能优化</li></ul><h3 id="虚拟DOM实现原理"><a href="#虚拟DOM实现原理" class="headerlink" title="虚拟DOM实现原理?"></a>虚拟DOM实现原理?</h3><ul><li>虚拟DOM本质上是JavaScript对象,是对真实DOM的抽象</li><li>状态变更时，记录新树和旧树的差异</li><li>最后把差异更新到真正的dom中</li></ul><blockquote><p>详细实现见<a href="http://mp.weixin.qq.com/s?__biz=MzI3NjM1OTI3Mw==&mid=2247483738&idx=1&sn=3f38e3ad9dddfa9740c9f3f4eb8b412c&chksm=eb77f05cdc00794a8b87f46b5bef4d854227b800c0a3b71178f8cc1624ecafa049c8339981ae&scene=21#wechat_redirect" target="_blank" rel="noopener">虚拟DOM原理</a>?</p></blockquote><h3 id="既然Vue通过数据劫持可以精准探测数据变化-为什么还需要虚拟DOM进行diff检测差异"><a href="#既然Vue通过数据劫持可以精准探测数据变化-为什么还需要虚拟DOM进行diff检测差异" class="headerlink" title="既然Vue通过数据劫持可以精准探测数据变化,为什么还需要虚拟DOM进行diff检测差异?"></a>既然Vue通过数据劫持可以精准探测数据变化,为什么还需要虚拟DOM进行diff检测差异?</h3><p>考点: Vue的变化侦测原理</p><p>前置知识: 依赖收集、虚拟DOM、响应式系统</p><p>现代前端框架有两种方式侦测变化,一种是pull一种是push</p><p>pull: 其代表为React,我们可以回忆一下React是如何侦测到变化的,我们通常会用<code>setState</code>API显式更新,然后React会进行一层层的Virtual Dom Diff操作找出差异,然后Patch到DOM上,React从一开始就不知道到底是哪发生了变化,只是知道「有变化了」,然后再进行比较暴力的Diff操作查找「哪发生变化了」，另外一个代表就是Angular的脏检查操作。</p><p>push: Vue的响应式系统则是push的代表,当Vue程序初始化的时候就会对数据data进行依赖的收集,一但数据发生变化,响应式系统就会立刻得知,因此Vue是一开始就知道是「在哪发生变化了」,但是这又会产生一个问题,如果你熟悉Vue的响应式系统就知道,通常一个绑定一个数据就需要一个Watcher,一但我们的绑定细粒度过高就会产生大量的Watcher,这会带来内存以及依赖追踪的开销,而细粒度过低会无法精准侦测变化,因此Vue的设计是选择中等细粒度的方案,在组件级别进行push侦测的方式,也就是那套响应式系统,通常我们会第一时间侦测到发生变化的组件,然后在组件内部进行Virtual Dom Diff获取更加具体的差异,而Virtual Dom Diff则是pull操作,Vue是push+pull结合的方式进行变化侦测的.</p><h3 id="Vue为什么没有类似于React中shouldComponentUpdate的生命周期？"><a href="#Vue为什么没有类似于React中shouldComponentUpdate的生命周期？" class="headerlink" title="Vue为什么没有类似于React中shouldComponentUpdate的生命周期？"></a>Vue为什么没有类似于React中shouldComponentUpdate的生命周期？</h3><p>考点: Vue的变化侦测原理</p><p>前置知识: 依赖收集、虚拟DOM、响应式系统</p><p>根本原因是Vue与React的变化侦测方式有所不同</p><p>React是pull的方式侦测变化,当React知道发生变化后,会使用Virtual Dom Diff进行差异检测,但是很多组件实际上是肯定不会发生变化的,这个时候需要用shouldComponentUpdate进行手动操作来减少diff,从而提高程序整体的性能.</p><p>Vue是pull+push的方式侦测变化的,在一开始就知道那个组件发生了变化,因此在push的阶段并不需要手动控制diff,而组件内部采用的diff方式实际上是可以引入类似于shouldComponentUpdate相关生命周期的,但是通常合理大小的组件不会有过量的diff,手动优化的价值有限,因此目前Vue并没有考虑引入shouldComponentUpdate这种手动优化的生命周期.</p><h3 id="Vue中的key到底有什么用？"><a href="#Vue中的key到底有什么用？" class="headerlink" title="Vue中的key到底有什么用？"></a>Vue中的key到底有什么用？</h3><p><code>key</code>是为Vue中的vnode标记的唯一id,通过这个key,我们的diff操作可以更准确、更快速</p><p>diff算法的过程中,先会进行新旧节点的首尾交叉对比,当无法匹配的时候会用新节点的<code>key</code>与旧节点进行比对,然后超出差异.</p><blockquote><p>diff程可以概括为：oldCh和newCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较,这四种比较方式就是首、尾、旧尾新头、旧头新尾.</p></blockquote><ul><li>准确: 如果不加<code>key</code>,那么vue会选择复用节点(Vue的就地更新策略),导致之前节点的状态被保留下来,会产生一系列的bug.</li><li>快速: key的唯一性可以被Map数据结构充分利用,相比于遍历查找的时间复杂度O(n),Map的时间复杂度仅仅为O(1).</li></ul><p>在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 message 的翻转字符串。当你想要在模板中多次引用此处的翻转字符串时，就会更加难以处理。</p><p>所以，对于任何复杂逻辑，你都应当使用计算属性。</p><h3 id="vue-cli提供了几种脚手架模板"><a href="#vue-cli提供了几种脚手架模板" class="headerlink" title="vue-cli提供了几种脚手架模板"></a>vue-cli提供了几种脚手架模板</h3><p>六种</p><p><a href="https://github.com/vuejs/vue-cli/tree/v2#vue-cli--" target="_blank" rel="noopener">https://github.com/vuejs/vue-cli/tree/v2#vue-cli--</a></p><h3 id="computed、methods的区别"><a href="#computed、methods的区别" class="headerlink" title="computed、methods的区别"></a>computed、methods的区别</h3><p>两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的依赖进行缓存的。只在相关依赖发生改变时它们才会重新求值。这就意味着只要值还没有发生改变，多次访问 定义的计算属性会立即返回之前的计算结果，而不必再次执行函数。</p><p>相比之下，每当触发重新渲染时，调用方法(methods)将总会再次执行函数。</p><p>我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。</p><h3 id="什么是自定义指令，有哪些钩子函数及自定义指令的使用场景"><a href="#什么是自定义指令，有哪些钩子函数及自定义指令的使用场景" class="headerlink" title="什么是自定义指令，有哪些钩子函数及自定义指令的使用场景"></a>什么是自定义指令，有哪些钩子函数及自定义指令的使用场景</h3><p>有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。</p><p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p><p>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p><p>inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</p><p>update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</p><p>componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</p><p>unbind：只调用一次，指令与元素解绑时调用。</p><h3 id="父组件获取异步动态数据传递给子组件"><a href="#父组件获取异步动态数据传递给子组件" class="headerlink" title="父组件获取异步动态数据传递给子组件"></a>父组件获取异步动态数据传递给子组件</h3><p>在父组件中使用axios获取异步数据传给子组件，但是发现子组件在渲染的时候并没有数据，在created里面打印也是空的，结果发现一开始子组件绑定的数据是空的，在请求数据没有返回数据时，子组件就已经加载了，并且他绑定的值也是空的，问题找到了，怎么解决呢？</p><blockquote><p>开始的时候让子组件隐藏,然后等数据返回的时候，让子组件显示</p><p>通过v-if，也就是判断数据是否为空，为空就不渲染，也能解决了</p><p>为不能读取的属性添加一个默认值，就可以很好的解决了</p></blockquote><h3 id="vue-router实现原理"><a href="#vue-router实现原理" class="headerlink" title="vue-router实现原理"></a>vue-router实现原理</h3><p>这里指的路由并不是指我们平时所说的硬件路由器，这里的路由就是SPA（单页应用）的路径管理器。 换句话说，vue-router就是WebApp的链接路径管理系统。</p><p>vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。</p><h4 id="那与传统的页面跳转有什么区别呢？"><a href="#那与传统的页面跳转有什么区别呢？" class="headerlink" title="那与传统的页面跳转有什么区别呢？"></a>那与传统的页面跳转有什么区别呢？</h4><p>1.vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。</p><p>2.传统的页面应用，是用一些超链接来实现页面切换和跳转的。</p><p>在vue-router单页面应用中，则是路径之间的切换，也就是组件的切换。路由模块的本质 就是建立起url和页面之间的映射关系。</p><p>至于为啥不能用a标签，这是因为用Vue做的都是单页应用，就相当于只有一个主的index.html页面，所以你写的标签是不起作用的，必须使用vue-router来进行管理。</p><p>SPA(single page application):单一页面应用程序，有且只有一个完整的页面；当它在加载页面的时候，不会加载整个页面的内容，而只更新某个指定的容器中内容。</p><p>单页面应用(SPA)的核心之一是:</p><p>更新视图而不重新请求页面;</p><p>vue-router在实现单页面前端路由时，提供了三种方式：Hash模式、History模式、abstract模式，根据mode参数来决定采用哪一种方式。</p><h3 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h3><p>vue-router 提供了三种运行模式：</p><p>● hash: 使用 URL hash 值来作路由。默认模式。</p><p>● history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。</p><p>● abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。</p><h4 id="Hash模式"><a href="#Hash模式" class="headerlink" title="Hash模式"></a>Hash模式</h4><p>vue-router 默认模式是 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，当 URL 改变时，页面不会去重新加载。</p><p>hash（#）是URL 的锚点，代表的是网页中的一个位置，单单改变#后的部分（/#/…），浏览器只会加载相应位置的内容，不会重新加载网页，也就是说 #是用来指导浏览器动作的，对服务器端完全无用，HTTP请求中不包括#；同时每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置；所以说Hash模式通过锚点值的改变，根据不同的值，渲染指定DOM位置的不同数据。</p><p>JavaScript实现SPA路由hash模式详解</p><h4 id="History模式"><a href="#History模式" class="headerlink" title="History模式"></a>History模式</h4><p>HTML5 History API提供了一种功能，能让开发人员在不刷新整个页面的情况下修改站点的URL，就是利用 history.pushState API 来完成 URL 跳转而无须重新加载页面；</p><p>由于hash模式会在url中自带#，如果不想要很丑的 hash，我们可以用路由的 history 模式，只需要在配置路由规则时，加入”mode: ‘history’”,这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。</p><p><a href="https://main.xn--js-ry2cx4aj93f/" target="_blank" rel="noopener">//main.js文件中</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">mode: ‘history’,</span><br><span class="line">routes: […]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当使用 history 模式时，URL 就像正常的 url，例如 <a href="http://yoursite.com/user/id，比较好…" target="_blank" rel="noopener">yoursite.com/user/id，比较好…</a> 不过这种模式有点问题，还需要后台配置支持。你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面，如果不这么做，直接访问页面空白</p><h3 id="配置Apache"><a href="#配置Apache" class="headerlink" title="配置Apache"></a>配置Apache</h3><p>第一步：新建：.htaccess文件放在服务器根目录下 （命令type null&gt;.htaccess）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line">RewriteEngine On</span><br><span class="line">RewriteBase /</span><br><span class="line">RewriteRule ^index.html$ - [L]</span><br><span class="line">RewriteCond %&#123;REQUEST_FILENAME&#125; !-f</span><br><span class="line">RewriteCond %&#123;REQUEST_FILENAME&#125; !-d</span><br><span class="line">RewriteRule . /index.html [L]</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure><p>除了 mod_rewrite，你也可以使用 FallbackResource。</p><p>第二步： src/router/index.js</p><p>mode: ‘history’,</p><p>base: ‘/dist/’,</p><p>第三步：访问：地址进行测试</p><p>abstract模式</p><p>abstract模式是使用一个不依赖于浏览器的浏览历史虚拟管理后端。</p><p>根据平台差异可以看出，在 Weex 环境中只支持使用 abstract 模式。 不过，vue-router 自身会对环境做校验，如果发现没有浏览器的 API，vue-router 会自动强制进入 abstract 模式，所以 在使用 vue-router 时只要不写 mode 配置即可，默认会在浏览器环境中使用 hash 模式，在移动端原生环境中使用 abstract 模式。 （当然，你也可以明确指定在所有情况下都使用 abstract 模式）</p><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p>用户在组件中发起动作，然后从API中拿数据，就会牵扯到异步操作，所以我们通过dispatch来提交一个action，在action里面发起ajax请求，拿到数据以后我们只需要通过commit提交mutations改变我的state状态就可以了，状态改变后视图就会改变因为Vuex是响应式的，这就是Vuex的运作流程机制</p><h3 id="vuex中如何异步修改数据"><a href="#vuex中如何异步修改数据" class="headerlink" title="vuex中如何异步修改数据"></a>vuex中如何异步修改数据</h3><p>Action 类似于 mutation，不同在于：</p><p>Action 提交的是 mutation，而不是直接变更状态。</p><p>Action 可以包含任意异步操作。</p><p><img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/mmbiz_jpg/yphVQAwjncvicxKz1nicIOUh3ibEd24MWW1C0sVQ35DYJe5rPDTzZ8WeCPib3DibZ0uTc1Zfs9SGyDWoVu0cdgRNR8g/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h2 id="荣耀黄金"><a href="#荣耀黄金" class="headerlink" title="荣耀黄金"></a>荣耀黄金</h2><h3 id="1-Vue的优点？Vue的缺点？"><a href="#1-Vue的优点？Vue的缺点？" class="headerlink" title="1. Vue的优点？Vue的缺点？"></a>1. Vue的优点？Vue的缺点？</h3><p>优点：渐进式，组件化，轻量级，虚拟dom，响应式，单页面路由，数据与视图分开</p><p>缺点：单页面不利于seo，不支持IE8以下，首屏加载时间长</p><h3 id="2-为什么说Vue是一个渐进式框架？"><a href="#2-为什么说Vue是一个渐进式框架？" class="headerlink" title="2. 为什么说Vue是一个渐进式框架？"></a>2. 为什么说Vue是一个渐进式框架？</h3><p>渐进式：通俗点讲就是，你想用啥你就用啥，咱也不强求你。你想用component就用，不用也行，你想用vuex就用，不用也可以</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/sz_mmbiz_png/gMvNo9rxo40PPicD3fczxSYXZxxV3D2ORicibhZDdbZtm29mjvafm5unOBmia0s7iaSwolhVk6Ny4Aqe2Vbncoe4alw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>                </div>                <div class="image-caption">图片</div>            </figure>image.png<h3 id="3-Vue跟React的异同点？"><a href="#3-Vue跟React的异同点？" class="headerlink" title="3. Vue跟React的异同点？"></a>3. Vue跟React的异同点？</h3><p>相同点：</p><ul><li>1.都使用了虚拟dom</li><li>2.组件化开发</li><li>3.都是单向数据流(父子组件之间，不建议子修改父传下来的数据)</li><li>4.都支持服务端渲染</li></ul><p>不同点：</p><ul><li>1.React的JSX，Vue的template</li><li>2.数据变化，React手动(setState)，Vue自动(初始化已响应式处理，Object.defineProperty)</li><li>3.React单向绑定，Vue双向绑定</li><li>4.React的Redux，Vue的Vuex</li></ul><h3 id="4-MVVM是什么？和MVC有何区别呢？"><a href="#4-MVVM是什么？和MVC有何区别呢？" class="headerlink" title="4. MVVM是什么？和MVC有何区别呢？"></a>4. MVVM是什么？和MVC有何区别呢？</h3><p>MVC</p><ul><li>Model(模型)：负责从数据库中取数据</li><li>View(视图)：负责展示数据的地方</li><li>Controller(控制器)：用户交互的地方，例如点击事件等等</li><li>思想：Controller将Model的数据展示在View上</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/sz_mmbiz_png/gMvNo9rxo40PPicD3fczxSYXZxxV3D2ORCeyFh1MjM6kv9Msc0jue4OfHGLlIUQhQXgbwJkngNsGlXO39AoIUog/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>                </div>                <div class="image-caption">图片</div>            </figure>image.png<p>MVVM</p><ul><li>VM：也就是View-Model，做了两件事达到了数据的双向绑定 一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。</li><li>思想：实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素，来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变（对应Vue数据驱动的思想）</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/sz_mmbiz_png/gMvNo9rxo40PPicD3fczxSYXZxxV3D2ORickpt9vKH462r7e4Qia14ar4icQPk9IfZcFO81GB8AUCsh8Z2icRUzLIIw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>                </div>                <div class="image-caption">图片</div>            </figure>image.png<p>区别</p><p>整体看来，MVVM 比 MVC 精简很多，不仅简化了业务与界面的依赖，还解决了数据频繁更新的问题，不用再用选择器操作 DOM 元素。因为在 MVVM 中，View 不知道 Model 的存在，Model 和 ViewModel 也观察不到 View，这种低耦合模式提高代码的可重用性</p><p>Vue是不是MVVM框架？</p><p>Vue是MVVM框架，但是不是严格符合MVVM，因为MVVM规定Model和View不能直接通信，而Vue的<code>ref</code>可以做到这点</p><h3 id="5-Vue和JQuery的区别在哪？为什么放弃JQuery用Vue？"><a href="#5-Vue和JQuery的区别在哪？为什么放弃JQuery用Vue？" class="headerlink" title="5. Vue和JQuery的区别在哪？为什么放弃JQuery用Vue？"></a>5. Vue和JQuery的区别在哪？为什么放弃JQuery用Vue？</h3><ul><li>1.jQuery是直接操作DOM，Vue不直接操作DOM，Vue的数据与视图是分开的，Vue只需要操作数据即可</li><li>2.jQuery的操作DOM行为是频繁的，而Vue利用虚拟DOM的技术，大大提高了更新DOM时的性能</li><li>3.Vue中不倡导直接操作DOM，开发者只需要把大部分精力放在数据层面上</li><li>4.Vue集成的一些库，大大提高开发效率，比如Vuex，Router等</li></ul><h3 id="6-Vue的作者是谁？大声说出它的名字！！！"><a href="#6-Vue的作者是谁？大声说出它的名字！！！" class="headerlink" title="6. Vue的作者是谁？大声说出它的名字！！！"></a>6. Vue的作者是谁？大声说出它的名字！！！</h3><p>他的名字就是：鱿鱼西</p><h2 id="永恒钻石"><a href="#永恒钻石" class="headerlink" title="永恒钻石"></a>永恒钻石</h2><h3 id="7-为什么data是个函数并且返回一个对象呢？"><a href="#7-为什么data是个函数并且返回一个对象呢？" class="headerlink" title="7. 为什么data是个函数并且返回一个对象呢？"></a>7. 为什么data是个函数并且返回一个对象呢？</h3><p><code>data</code>之所以只一个函数，是因为一个组件可能会多处调用，而每一次调用就会执行<code>data函数</code>并返回新的数据对象，这样，可以避免多处调用之间的<code>数据污染</code>。</p><h3 id="8-使用过哪些Vue的修饰符呢？"><a href="#8-使用过哪些Vue的修饰符呢？" class="headerlink" title="8. 使用过哪些Vue的修饰符呢？"></a>8. 使用过哪些Vue的修饰符呢？</h3><p>可以看我这篇文章<strong>「百毒不侵」面试官最喜欢问的13种Vue修饰符</strong>[1]</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/sz_mmbiz_png/gMvNo9rxo40PPicD3fczxSYXZxxV3D2OR4V4kawxZ0rNQDgwzWh52f3btQ3sic8LA7DHayibYGicSUuNLo53gPxfCA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>                </div>                <div class="image-caption">图片</div>            </figure>截屏2021-07-11 下午9.56.53.png<h3 id="9-使用过哪些Vue的内部指令呢？"><a href="#9-使用过哪些Vue的内部指令呢？" class="headerlink" title="9. 使用过哪些Vue的内部指令呢？"></a>9. 使用过哪些Vue的内部指令呢？</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/sz_mmbiz_png/gMvNo9rxo40PPicD3fczxSYXZxxV3D2OReXR4ibmUb9kh4xNDO8cbmDiauq8cZ3mrbDd6VYk3bSblp3re6Xyd4jBA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>                </div>                <div class="image-caption">图片</div>            </figure>image.png<h3 id="10-组件之间的传值方式有哪些？"><a href="#10-组件之间的传值方式有哪些？" class="headerlink" title="10. 组件之间的传值方式有哪些？"></a>10. 组件之间的传值方式有哪些？</h3><ul><li>父组件传值给子组件，子组件使用<code>props</code>进行接收</li><li>子组件传值给父组件，子组件使用<code>$emit+事件</code>对父组件进行传值</li><li>组件中可以使用<code>$parent</code>和<code>$children</code>获取到父组件实例和子组件实例，进而获取数据</li><li>使用<code>$attrs</code>和<code>$listeners</code>，在对一些组件进行二次封装时可以方便传值，例如A-&gt;B-&gt;C</li><li>使用<code>$refs</code>获取组件实例，进而获取数据</li><li>使用<code>Vuex</code>进行状态管理</li><li>使用<code>eventBus</code>进行跨组件触发事件，进而传递数据</li><li>使用<code>provide</code>和<code>inject</code>，官方建议我们不要用这个，我在看<code>ElementUI</code>源码时发现大量使用</li><li>使用浏览器本地缓存，例如<code>localStorage</code></li></ul><h3 id="11-路由有哪些模式呢？又有什么不同呢？"><a href="#11-路由有哪些模式呢？又有什么不同呢？" class="headerlink" title="11. 路由有哪些模式呢？又有什么不同呢？"></a>11. 路由有哪些模式呢？又有什么不同呢？</h3><ul><li>hash模式：通过<code>#号</code>后面的内容的更改，触发<code>hashchange</code>事件，实现路由切换</li><li>history模式：通过<code>pushState</code>和<code>replaceState</code>切换url，触发<code>popstate</code>事件，实现路由切换，需要后端配合</li></ul><h3 id="12-如何设置动态class，动态style？"><a href="#12-如何设置动态class，动态style？" class="headerlink" title="12. 如何设置动态class，动态style？"></a>12. 如何设置动态class，动态style？</h3><ul><li>动态class对象：<code>&lt;div :class={ &#39;is-active&#39;: true, &#39;red&#39;: isRed }&gt;&lt;/div&gt;</code></li><li>动态class数组：<code>&lt;div :class=[&#39;is-active&#39;, isRed ? &#39;red&#39; : &#39;&#39; ]&gt;&lt;/div&gt;</code></li><li>动态style对象：<code>&lt;div :style={ color: textColor, fontSize: &#39;18px&#39; }&gt;&lt;/div&gt;</code></li><li>动态style数组：<code>&lt;div :style=[{ color: textColor, fontSize: &#39;18px&#39; }, { fontWeight: &#39;300&#39; }]&gt;&lt;/div&gt;</code></li></ul><h3 id="13-v-if和v-show有何区别？"><a href="#13-v-if和v-show有何区别？" class="headerlink" title="13. v-if和v-show有何区别？"></a>13. v-if和v-show有何区别？</h3><ul><li>1.<code>v-if</code>是通过控制dom元素的删除和生成来实现显隐，每一次显隐都会使组件重新跑一遍生命周期，因为显隐决定了组件的生成和销毁</li><li>2.<code>v-show</code>是通过控制dom元素的css样式来实现显隐，不会销毁</li><li>3.频繁或者大数量显隐使用<code>v-show</code>，否则使用<code>v-if</code></li></ul><h3 id="14-computed和watch有何区别？"><a href="#14-computed和watch有何区别？" class="headerlink" title="14. computed和watch有何区别？"></a>14. computed和watch有何区别？</h3><ul><li>1.<code>computed</code>是依赖已有的变量来计算一个目标变量，大多数情况都是<code>多个变量</code>凑在一起计算出<code>一个变量</code>，并且<code>computed</code>具有<code>缓存机制</code>，依赖值不变的情况下其会直接读取缓存进行复用，<code>computed</code>不能进行<code>异步操作</code></li><li>2.<code>watch</code>是监听某一个变量的变化，并执行相应的回调函数，通常是<code>一个变量</code>的变化决定<code>多个变量</code>的变化，<code>watch</code>可以进行<code>异步操作</code></li><li>3.简单记就是：一般情况下<code>computed</code>是<code>多对一</code>，<code>watch</code>是<code>一对多</code></li></ul><h3 id="15-Vue的生命周期，讲一讲？"><a href="#15-Vue的生命周期，讲一讲？" class="headerlink" title="15. Vue的生命周期，讲一讲？"></a>15. Vue的生命周期，讲一讲？</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/sz_mmbiz_png/gMvNo9rxo40PPicD3fczxSYXZxxV3D2ORibreS1NicHBvGjhAwC5pkSMeaOVSrS1gl1DwbxxU5LQnhjc4z2AoD3BA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>                </div>                <div class="image-caption">图片</div>            </figure><h3 id="16-为什么v-if和v-for不建议用在同一标签？"><a href="#16-为什么v-if和v-for不建议用在同一标签？" class="headerlink" title="16. 为什么v-if和v-for不建议用在同一标签？"></a>16. 为什么v-if和v-for不建议用在同一标签？</h3><p>在Vue2中，<code>v-for</code>优先级是高于<code>v-if</code>的，咱们来看例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=item in [1, 2, 3, 4, 5, 6, 7] v-if=item !== 3&gt;</span><br><span class="line">    &#123;&#123;item&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>上面的写法是<code>v-for</code>和<code>v-if</code>同时存在，会先把7个元素都遍历出来，然后再一个个判断是否为3，并把3给隐藏掉，这样的坏处就是，渲染了无用的3节点，增加无用的dom操作，建议使用computed来解决这个问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=item in list&gt;</span><br><span class="line">    &#123;&#123;item&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">computed() &#123;</span><br><span class="line">    list() &#123;</span><br><span class="line">        return [1, 2, 3, 4, 5, 6, 7].filter(item =&gt; item !== 3)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="17-vuex的有哪些属性？用处是什么？"><a href="#17-vuex的有哪些属性？用处是什么？" class="headerlink" title="17. vuex的有哪些属性？用处是什么？"></a>17. vuex的有哪些属性？用处是什么？</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/sz_mmbiz_png/gMvNo9rxo40PPicD3fczxSYXZxxV3D2ORaSZPoXANK5XTKiaYUKGPDZPjFx61fg7DNxeXctJxT08ibz9IagIXTmrA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>                </div>                <div class="image-caption">图片</div>            </figure>image.png<ul><li>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li><li>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li><li>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。</li><li>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</li><li>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</li></ul><h2 id="至尊星耀"><a href="#至尊星耀" class="headerlink" title="至尊星耀"></a>至尊星耀</h2><h3 id="18-不需要响应式的数据应该怎么处理？"><a href="#18-不需要响应式的数据应该怎么处理？" class="headerlink" title="18. 不需要响应式的数据应该怎么处理？"></a>18. 不需要响应式的数据应该怎么处理？</h3><p>在我们的Vue开发中，会有一些数据，从始至终都<code>未曾改变过</code>，这种<code>死数据</code>，既然<code>不改变</code>，那也就<code>不需要对他做响应式处理</code>了，不然只会做一些无用功消耗性能，比如一些写死的下拉框，写死的表格数据，这些数据量大的<code>死数据</code>，如果都进行响应式处理，那会消耗大量性能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 方法一：将数据定义在data之外</span><br><span class="line">data () &#123;</span><br><span class="line">    this.list1 = &#123; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &#125;</span><br><span class="line">    this.list2 = &#123; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &#125;</span><br><span class="line">    this.list3 = &#123; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &#125;</span><br><span class="line">    this.list4 = &#123; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &#125;</span><br><span class="line">    this.list5 = &#123; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &#125;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line">// 方法二：Object.freeze()</span><br><span class="line">data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        list1: Object.freeze(&#123;xxxxxxxxxxxxxxxxxxxxxxxx&#125;),</span><br><span class="line">        list2: Object.freeze(&#123;xxxxxxxxxxxxxxxxxxxxxxxx&#125;),</span><br><span class="line">        list3: Object.freeze(&#123;xxxxxxxxxxxxxxxxxxxxxxxx&#125;),</span><br><span class="line">        list4: Object.freeze(&#123;xxxxxxxxxxxxxxxxxxxxxxxx&#125;),</span><br><span class="line">        list5: Object.freeze(&#123;xxxxxxxxxxxxxxxxxxxxxxxx&#125;),</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="19-watch有哪些属性，分别有什么用？"><a href="#19-watch有哪些属性，分别有什么用？" class="headerlink" title="19. watch有哪些属性，分别有什么用？"></a>19. watch有哪些属性，分别有什么用？</h3><p>当我们监听一个基本数据类型时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    value () &#123;</span><br><span class="line">        // do something</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们监听一个引用数据类型时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    obj: &#123;</span><br><span class="line">       handler () &#123; // 执行回调</span><br><span class="line">           // do something</span><br><span class="line">       &#125;,</span><br><span class="line">       deep: true, // 是否进行深度监听</span><br><span class="line">       immediate: true // 是否初始执行handler函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20-父子组件生命周期顺序"><a href="#20-父子组件生命周期顺序" class="headerlink" title="20. 父子组件生命周期顺序"></a>20. 父子组件生命周期顺序</h3><p>父beforeCreate -&gt; 父created -&gt; 父beforeMount -&gt; 子beforeCreate -&gt; 子created -&gt; 子beforeMount -&gt; 子mounted -&gt; 父mounted</p><h3 id="21-对象新属性无法更新视图，删除属性无法更新视图，为什么？怎么办？"><a href="#21-对象新属性无法更新视图，删除属性无法更新视图，为什么？怎么办？" class="headerlink" title="21. 对象新属性无法更新视图，删除属性无法更新视图，为什么？怎么办？"></a>21. 对象新属性无法更新视图，删除属性无法更新视图，为什么？怎么办？</h3><ul><li>原因：<code>Object.defineProperty</code>没有对对象的新属性进行属性劫持</li><li>对象新属性无法更新视图：使用<code>Vue.$set(obj, key, value)</code>，组件中<code>this.$set(obj, key, value)</code></li><li>删除属性无法更新视图：使用<code>Vue.$delete(obj, key)</code>，组件中<code>this.$delete(obj, key)</code></li></ul><h3 id="22-直接arr-index-xxx无法更新视图怎么办？为什么？怎么办？"><a href="#22-直接arr-index-xxx无法更新视图怎么办？为什么？怎么办？" class="headerlink" title="22. 直接arr[index] = xxx无法更新视图怎么办？为什么？怎么办？"></a>22. 直接arr[index] = xxx无法更新视图怎么办？为什么？怎么办？</h3><ul><li>原因：Vue没有对数组进行<code>Object.defineProperty</code>的属性劫持，所以直接arr[index] = xxx是无法更新视图的</li><li>使用数组的splice方法，<code>arr.splice(index, 1, item)</code></li><li>使用<code>Vue.$set(arr, index, value)</code></li></ul><h3 id="24-插槽的使用以及原理？"><a href="#24-插槽的使用以及原理？" class="headerlink" title="24. 插槽的使用以及原理？"></a>24. 插槽的使用以及原理？</h3><p>建议看我这篇文章<strong>「Vue源码学习」你真的知道插槽Slot是怎么“插”的吗</strong>[3]</p><h3 id="25-为什么不建议用index做key，为什么不建议用随机数做key？"><a href="#25-为什么不建议用index做key，为什么不建议用随机数做key？" class="headerlink" title="25. 为什么不建议用index做key，为什么不建议用随机数做key？"></a>25. 为什么不建议用index做key，为什么不建议用随机数做key？</h3><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=(item, index) in list :key=index&gt;&#123;&#123;item.name&#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">list: [</span><br><span class="line">    &#123; name: &apos;小明&apos;, id: &apos;123&apos; &#125;,</span><br><span class="line">    &#123; name: &apos;小红&apos;, id: &apos;124&apos; &#125;,</span><br><span class="line">    &#123; name: &apos;小花&apos;, id: &apos;125&apos; &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">渲染为</span><br><span class="line">&lt;div key=0&gt;小明&lt;/div&gt;</span><br><span class="line">&lt;div key=1&gt;小红&lt;/div&gt;</span><br><span class="line">&lt;div key=2&gt;小花&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">现在我执行 list.unshift(&#123; name: &apos;小林&apos;, id: &apos;122&apos; &#125;)</span><br><span class="line"></span><br><span class="line">渲染为</span><br><span class="line">&lt;div key=0&gt;小林&lt;/div&gt;</span><br><span class="line">&lt;div key=1&gt;小明&lt;/div&gt;</span><br><span class="line">&lt;div key=2&gt;小红&lt;/div&gt;</span><br><span class="line">&lt;div key=3&gt;小花&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">新旧对比</span><br><span class="line"></span><br><span class="line">&lt;div key=0&gt;小明&lt;/div&gt;  &lt;div key=0&gt;小林&lt;/div&gt;</span><br><span class="line">&lt;div key=1&gt;小红&lt;/div&gt;  &lt;div key=1&gt;小明&lt;/div&gt;</span><br><span class="line">&lt;div key=2&gt;小花&lt;/div&gt;  &lt;div key=2&gt;小红&lt;/div&gt;</span><br><span class="line">                         &lt;div key=3&gt;小花&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">可以看出，如果用index做key的话，其实是更新了原有的三项，并新增了小花，虽然达到了渲染目的，但是损耗性能</span><br><span class="line"></span><br><span class="line">现在我们使用id来做key，渲染为</span><br><span class="line"></span><br><span class="line">&lt;div key=123&gt;小明&lt;/div&gt;</span><br><span class="line">&lt;div key=124&gt;小红&lt;/div&gt;</span><br><span class="line">&lt;div key=125&gt;小花&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">现在我执行 list.unshift(&#123; name: &apos;小林&apos;, id: &apos;122&apos; &#125;)，渲染为</span><br><span class="line"></span><br><span class="line">&lt;div key=122&gt;小林&lt;/div&gt;</span><br><span class="line">&lt;div key=123&gt;小明&lt;/div&gt;</span><br><span class="line">&lt;div key=124&gt;小红&lt;/div&gt;</span><br><span class="line">&lt;div key=125&gt;小花&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">新旧对比</span><br><span class="line"></span><br><span class="line">                           &lt;div key=122&gt;小林&lt;/div&gt;</span><br><span class="line">&lt;div key=123&gt;小明&lt;/div&gt;  &lt;div key=123&gt;小明&lt;/div&gt;</span><br><span class="line">&lt;div key=124&gt;小红&lt;/div&gt;  &lt;div key=124&gt;小红&lt;/div&gt;</span><br><span class="line">&lt;div key=125&gt;小花&lt;/div&gt;  &lt;div key=125&gt;小花&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">可以看出，原有的三项都不变，只是新增了小林这个人，这才是最理想的结果</span><br></pre></td></tr></table></figure><p>用<code>index</code>和用<code>随机数</code>都是同理，<code>随机数</code>每次都在变，做不到专一性，很<code>渣男</code>，也很消耗性能，所以，拒绝<code>渣男</code>，选择<code>老实人</code></p><h3 id="26-说说nextTick的用处？"><a href="#26-说说nextTick的用处？" class="headerlink" title="26. 说说nextTick的用处？"></a>26. 说说nextTick的用处？</h3><p>我举个例子，在vue中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.name = &apos;公众号：前端印象&apos;</span><br><span class="line">this.age = 18</span><br><span class="line">this.gender = &apos;男&apos;</span><br></pre></td></tr></table></figure><p>我们修改了三个变量，那问题来了，是每修改一次，DOM就更新一次吗？不是的，Vue采用的是<code>异步更新</code>的策略，通俗点说就是，<code>同一事件循环内</code>多次修改，会<code>统一</code>进行一次<code>视图更新</code>，这样才能节省性能嘛</p><p>看懂了上面，那你应该也看得懂下面的例子了吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div ref=testDiv&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">name: &apos;小林&apos;</span><br><span class="line"></span><br><span class="line">this.name = &apos;公众号：前端印象&apos;</span><br><span class="line">console.log(this.$refs.testDiv.innerHTML) // 这里是啥呢</span><br></pre></td></tr></table></figure><p>答案是“小林”，前面说了，Vue是<code>异步更新</code>，所以数据一更新，视图却还没更新，所以拿到的还是上一次的旧视图数据，那么想要拿到最新视图数据怎么办呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.name = &apos;公众号：前端印象&apos;</span><br><span class="line">this.$nextTick(() =&gt; &#123;</span><br><span class="line">    console.log(this.$refs.testDiv.innerHTML) // 公众号：前端印象</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="27-Vue的SSR是什么？有什么好处？"><a href="#27-Vue的SSR是什么？有什么好处？" class="headerlink" title="27. Vue的SSR是什么？有什么好处？"></a>27. Vue的SSR是什么？有什么好处？</h3><ul><li><code>SSR</code>就是服务端渲染</li><li>基于<code>nodejs serve</code>服务环境开发，所有<code>html</code>代码在服务端渲染</li><li>数据返回给前端，然后前端进行“激活”，即可成为浏览器识别的html代码</li><li><code>SSR</code>首次加载更快，有更好的用户体验，有更好的seo优化，因为爬虫能看到整个页面的内容，如果是vue项目，由于数据还要经过解析，这就造成爬虫并不会等待你的数据加载完成，所以其实Vue项目的seo体验并不是很好</li></ul><h2 id="最强王者"><a href="#最强王者" class="headerlink" title="最强王者"></a>最强王者</h2><h3 id="28-Vue响应式是怎么实现的？"><a href="#28-Vue响应式是怎么实现的？" class="headerlink" title="28. Vue响应式是怎么实现的？"></a>28. Vue响应式是怎么实现的？</h3><p>整体思路是数据劫持+观察者模式</p><p>对象内部通过<code>defineReactive</code> 方法，使用 <code>Object.defineProperty</code> 将属性进行劫持（只会劫持已经存在的属性），数组则是通过重写数组方法来实现。当页面使用对应属性时，每个属性都拥有自己的<code>dep</code>属性，存放他所依赖的<code>watcher</code>（依赖收集），当属性变化后会通知自己对应的<code>watcher</code> 去更新(派发更新)。</p><p>想详细了解过程，建议阅读我的<strong>Vue源码解析系列</strong>[4]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">const &#123; arrayMethods &#125; = require(&apos;./array&apos;)</span><br><span class="line"></span><br><span class="line">class Observer &#123;</span><br><span class="line">    constructor(value) &#123;</span><br><span class="line">        Object.defineProperty(value, &apos;__ob__&apos;, &#123;</span><br><span class="line">            value: this,</span><br><span class="line">            enumerable: false,</span><br><span class="line">            writable: true,</span><br><span class="line">            configurable: true</span><br><span class="line">        &#125;)</span><br><span class="line">        if(Array.isArray(value)) &#123;</span><br><span class="line">            value.__proto__ = arrayMethods</span><br><span class="line">            this.observeArray(value)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.walk(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    walk(data) &#123;</span><br><span class="line">        let keys = Object.keys(data)</span><br><span class="line">        for(let i = 0; i &lt; keys.length; i++) &#123;</span><br><span class="line">            const key = keys[i]</span><br><span class="line">            const value = data[key]</span><br><span class="line">            defineReactive(data, key, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    observeArray(items) &#123;</span><br><span class="line">        for(let i = 0; i &lt; items.length; i++) &#123;</span><br><span class="line">            observe(items[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function defineReactive(data, key, value) &#123;</span><br><span class="line">    const childOb = observe(value)</span><br><span class="line"></span><br><span class="line">    const dep = new Dep()</span><br><span class="line"></span><br><span class="line">    Object.defineProperty(data, key, &#123;</span><br><span class="line">        get() &#123;</span><br><span class="line">            console.log(&apos;获取值&apos;)</span><br><span class="line">            if (Dep.target) &#123;</span><br><span class="line">                dep.depend()</span><br><span class="line"></span><br><span class="line">                if (childOb) &#123;</span><br><span class="line">                    childOb.dep.depend()</span><br><span class="line"></span><br><span class="line">                    if (Array.isArray(value)) &#123;</span><br><span class="line">                        dependArray(value)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return value</span><br><span class="line">        &#125;,</span><br><span class="line">        set(newVal) &#123;</span><br><span class="line">            if (newVal === value) return</span><br><span class="line">            observe(newVal)</span><br><span class="line">            value = newVal</span><br><span class="line">            dep.notify()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function observe(value) &#123;</span><br><span class="line">    if (Object.prototype.toString.call(value) === &apos;[object Object]&apos; || Array.isArray(value)) &#123;</span><br><span class="line">        return new Observer(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function dependArray(value) &#123;</span><br><span class="line">    for(let e, i = 0, l = value.length; i &lt; l; i++) &#123;</span><br><span class="line">        e = value[i]</span><br><span class="line"></span><br><span class="line">        e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend()</span><br><span class="line"></span><br><span class="line">        if (Array.isArray(e)) &#123;</span><br><span class="line">            dependArray(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// array.js</span><br><span class="line">const arrayProto = Array.prototype</span><br><span class="line"></span><br><span class="line">const arrayMethods = Object.create(arrayProto)</span><br><span class="line"></span><br><span class="line">const methodsToPatch = [</span><br><span class="line">    &apos;push&apos;,</span><br><span class="line">    &apos;pop&apos;,</span><br><span class="line">    &apos;shift&apos;,</span><br><span class="line">    &apos;unshift&apos;,</span><br><span class="line">    &apos;splice&apos;,</span><br><span class="line">    &apos;reverse&apos;,</span><br><span class="line">    &apos;sort&apos;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">methodsToPatch.forEach(method =&gt; &#123;</span><br><span class="line">    arrayMethods[method] = function (...args) &#123;</span><br><span class="line">        const result = arrayProto[method].apply(this, args)</span><br><span class="line"></span><br><span class="line">        const ob = this.__ob__</span><br><span class="line"></span><br><span class="line">        var inserted</span><br><span class="line"></span><br><span class="line">        switch (method) &#123;</span><br><span class="line">            case &apos;push&apos;:</span><br><span class="line">            case &apos;unshift&apos;:</span><br><span class="line">                inserted = args</span><br><span class="line">                break;</span><br><span class="line">            case &apos;splice&apos;:</span><br><span class="line">                inserted = args.slice(2)</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (inserted) ob.observeArray(inserted)</span><br><span class="line"></span><br><span class="line">        ob.dep.notify()</span><br><span class="line"></span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="29-为什么只对对象劫持，而要对数组进行方法重写？"><a href="#29-为什么只对对象劫持，而要对数组进行方法重写？" class="headerlink" title="29. 为什么只对对象劫持，而要对数组进行方法重写？"></a>29. 为什么只对对象劫持，而要对数组进行方法重写？</h3><p>因为对象最多也就几十个属性，拦截起来数量不多，但是数组可能会有几百几千项，拦截起来非常耗性能，所以直接重写数组原型上的方法，是比较节省性能的方案</p><h3 id="30-Vue的模板编译原理？"><a href="#30-Vue的模板编译原理？" class="headerlink" title="30. Vue的模板编译原理？"></a>30. Vue的模板编译原理？</h3><p>因为这个问题讲起来可能比较长，所以：</p><p>建议看我这篇<strong>「Vue源码学习(二)」你不知道的-模板编译原理</strong>[5]</p><h3 id="31-Vue的computed和watch的原理？"><a href="#31-Vue的computed和watch的原理？" class="headerlink" title="31. Vue的computed和watch的原理？"></a>31. Vue的computed和watch的原理？</h3><p>因为这个问题讲起来可能比较长，所以：</p><p>建议看我这篇<strong>「Vue源码学习(四)」立志写一篇人人都看的懂的computed，watch原理</strong>[6]</p><h3 id="32-Vue-set方法的原理？"><a href="#32-Vue-set方法的原理？" class="headerlink" title="32. Vue.set方法的原理？"></a>32. Vue.set方法的原理？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function set(target, key, val) &#123;</span><br><span class="line">    // 判断是否是数组</span><br><span class="line">    if (Array.isArray(target)) &#123;</span><br><span class="line">        // 判断谁大谁小</span><br><span class="line">        target.length = Math.max(target.length, key)</span><br><span class="line">        // 执行splice</span><br><span class="line">        target.splice(key, 1, val)</span><br><span class="line">        return val</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const ob = target.__ob__</span><br><span class="line"></span><br><span class="line">    // 如果此对象没有不是响应式对象，直接设置并返回</span><br><span class="line">    if (key in target &amp;&amp; !(key in target.prototype) || !ob) &#123;</span><br><span class="line">        target[key] = val</span><br><span class="line">        return val</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 否则，新增属性，并响应式处理</span><br><span class="line">    defineReactive(target, key, val)</span><br><span class="line">    return val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="33-Vue-delete方法的原理？"><a href="#33-Vue-delete方法的原理？" class="headerlink" title="33. Vue.delete方法的原理？"></a>33. Vue.delete方法的原理？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function del (target, key) &#123;</span><br><span class="line">    // 判断是否为数组</span><br><span class="line">    if (Array.isArray(target)) &#123;</span><br><span class="line">        // 执行splice</span><br><span class="line">        target.splice(key, 1)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const ob = target.__ob__</span><br><span class="line"></span><br><span class="line">    // 对象本身就没有这个属性，直接返回</span><br><span class="line">    if (!(key in target)) return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 否则，删除这个属性</span><br><span class="line">    delete target[key]</span><br><span class="line"></span><br><span class="line">    // 判断是否是响应式对象，不是的话，直接返回</span><br><span class="line">    if (!ob) return</span><br><span class="line">    // 是的话，删除后要通知视图更新</span><br><span class="line">    ob.dep.notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="34-nextTick的原理？"><a href="#34-nextTick的原理？" class="headerlink" title="34. nextTick的原理？"></a>34. nextTick的原理？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">let callbacks = []; //回调函数</span><br><span class="line">let pending = false;</span><br><span class="line">function flushCallbacks() &#123;</span><br><span class="line">  pending = false; //把标志还原为false</span><br><span class="line">  // 依次执行回调</span><br><span class="line">  for (let i = 0; i &lt; callbacks.length; i++) &#123;</span><br><span class="line">    callbacks[i]( i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let timerFunc; //先采用微任务并按照优先级优雅降级的方式实现异步刷新</span><br><span class="line">if (typeof Promise !== undefined) &#123;</span><br><span class="line">  // 如果支持promise</span><br><span class="line">  const p = Promise.resolve();</span><br><span class="line">  timerFunc = () =&gt; &#123;</span><br><span class="line">    p.then(flushCallbacks);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; else if (typeof MutationObserver !== undefined) &#123;</span><br><span class="line">  // MutationObserver 主要是监听dom变化 也是一个异步方法</span><br><span class="line">  let counter = 1;</span><br><span class="line">  const observer = new MutationObserver(flushCallbacks);</span><br><span class="line">  const textNode = document.createTextNode(String(counter));</span><br><span class="line">  observer.observe(textNode, &#123;</span><br><span class="line">    characterData: true,</span><br><span class="line">  &#125;);</span><br><span class="line">  timerFunc = () =&gt; &#123;</span><br><span class="line">    counter = (counter + 1) % 2;</span><br><span class="line">    textNode.data = String(counter);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; else if (typeof setImmediate !== undefined) &#123;</span><br><span class="line">  // 如果前面都不支持 判断setImmediate</span><br><span class="line">  timerFunc = () =&gt; &#123;</span><br><span class="line">    setImmediate(flushCallbacks);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // 最后降级采用setTimeout</span><br><span class="line">  timerFunc = () =&gt; &#123;</span><br><span class="line">    setTimeout(flushCallbacks, 0);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function nextTick(cb) &#123;</span><br><span class="line">  callbacks.push(cb);</span><br><span class="line">  if (!pending) &#123;</span><br><span class="line">    pending = true;</span><br><span class="line">    timerFunc();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冷门的知识点"><a href="#冷门的知识点" class="headerlink" title="冷门的知识点"></a>冷门的知识点</h2><h3 id="36-如果子组件改变props里的数据会发生什么"><a href="#36-如果子组件改变props里的数据会发生什么" class="headerlink" title="36. 如果子组件改变props里的数据会发生什么"></a>36. 如果子组件改变props里的数据会发生什么</h3><p>props可以修改对象的属性值，不能直接改其他类型的值</p><ul><li>改变的props数据是基本类型</li></ul><blockquote><p>如果修改的是基本类型，则会报错</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">    num: Number,</span><br><span class="line">  &#125;</span><br><span class="line">created() &#123;</span><br><span class="line">    this.num = 999</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/sz_mmbiz_png/gMvNo9rxo40PPicD3fczxSYXZxxV3D2ORlUNlxTKRMrIBzJ1XonRXojcVYdg8fsMpncY9eHxxYJDp6rYngeL9Rw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>                </div>                <div class="image-caption">图片</div>            </figure>0458e2ff1538ee85d42953cec9a94ca.png<ul><li>改变的props数据是引用类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">    item: &#123;</span><br><span class="line">      default: () =&gt; &#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">created() &#123;</span><br><span class="line">    // 不报错，并且父级数据会跟着变</span><br><span class="line">    this.item.name = &apos;sanxin&apos;;</span><br><span class="line">    </span><br><span class="line">    // 会报错，跟基础类型报错一样</span><br><span class="line">    this.item = &apos;sss&apos;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h3 id="37-props怎么自定义验证"><a href="#37-props怎么自定义验证" class="headerlink" title="37. props怎么自定义验证"></a>37. props怎么自定义验证</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">    num: &#123;</span><br><span class="line">      default: 1,</span><br><span class="line">      validator: function (value) &#123;</span><br><span class="line">          // 返回值为true则验证不通过，报错</span><br><span class="line">          return [</span><br><span class="line">            1, 2, 3, 4, 5</span><br><span class="line">          ].indexOf(value) !== -1</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="38-watch的immediate属性有什么用？"><a href="#38-watch的immediate属性有什么用？" class="headerlink" title="38. watch的immediate属性有什么用？"></a>38. watch的immediate属性有什么用？</h3><blockquote><p>比如平时created时要请求一次数据，并且当搜索值改变，也要请求数据，我们会这么写：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">created()&#123;</span><br><span class="line">  this.getList()</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">  searchInputValue()&#123;</span><br><span class="line">    this.getList()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用<code>immediate</code>完全可以这么写，当它为<code>true</code>时，会初始执行一次</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  searchInputValue:&#123;</span><br><span class="line">    handler: &apos;getList&apos;,</span><br><span class="line">    immediate: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="39-watch监听一个对象时，如何排除某些属性的监听"><a href="#39-watch监听一个对象时，如何排除某些属性的监听" class="headerlink" title="39. watch监听一个对象时，如何排除某些属性的监听"></a>39. watch监听一个对象时，如何排除某些属性的监听</h3><blockquote><p>下面代码是，params发生改变就重新请求数据，无论是a，b，c，d属性改变</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      params: &#123;</span><br><span class="line">        a: 1,</span><br><span class="line">        b: 2,</span><br><span class="line">        c: 3,</span><br><span class="line">        d: 4</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      deep: true,</span><br><span class="line">      handler() &#123;</span><br><span class="line">        this.getList;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>但是如果我只想要a，b改变时重新请求，c，d改变时不重新请求呢？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">    Object.keys(this.params)</span><br><span class="line">      .filter((_) =&gt; ![c, d].includes(_)) // 排除对c，d属性的监听</span><br><span class="line">      .forEach((_) =&gt; &#123;</span><br><span class="line">        this.$watch((vm) =&gt; vm.params[_], handler, &#123;</span><br><span class="line">          deep: true,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      params: &#123;</span><br><span class="line">        a: 1,</span><br><span class="line">        b: 2,</span><br><span class="line">        c: 3,</span><br><span class="line">        d: 4</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      deep: true,</span><br><span class="line">      handler() &#123;</span><br><span class="line">        this.getList;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>欢迎关注公众号：<code>前端印象</code>，每日精选好文推送</p></blockquote><h3 id="40-审查元素时发现data-v-xxxxx，这是啥？"><a href="#40-审查元素时发现data-v-xxxxx，这是啥？" class="headerlink" title="40. 审查元素时发现data-v-xxxxx，这是啥？"></a>40. 审查元素时发现data-v-xxxxx，这是啥？</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/sz_mmbiz_png/gMvNo9rxo40PPicD3fczxSYXZxxV3D2ORqNJn2TO6WXVPh7NTpsSY4HHffjia9A4uiceWZfablgNoqAL5Kx9Rzsdg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>                </div>                <div class="image-caption">图片</div>            </figure>image.png<blockquote><p>这是在标记vue文件中css时使用scoped标记产生的，因为要保证各文件中的css不相互影响，给每个component都做了唯一的标记，所以每引入一个component就会出现一个新的’data-v-xxx’标记</p></blockquote><h3 id="41-computed如何实现传参？"><a href="#41-computed如何实现传参？" class="headerlink" title="41. computed如何实现传参？"></a>41. computed如何实现传参？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// html</span><br><span class="line">&lt;div&gt;&#123;&#123; total(3) &#125;&#125;</span><br><span class="line"></span><br><span class="line">// js</span><br><span class="line">computed: &#123;</span><br><span class="line">    total() &#123;</span><br><span class="line">      return function(n) &#123;</span><br><span class="line">          return n * this.num</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="42-vue的hook的使用"><a href="#42-vue的hook的使用" class="headerlink" title="42. vue的hook的使用"></a>42. vue的hook的使用</h3><ul><li>同一组件中使用</li></ul><blockquote><p>这是我们常用的使用定时器的方式</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export default&#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    timer:null  </span><br><span class="line">  &#125;,</span><br><span class="line">  mounted()&#123;</span><br><span class="line">      this.timer = setInterval(()=&gt;&#123;</span><br><span class="line">      //具体执行内容</span><br><span class="line">      console.log(&apos;1&apos;);</span><br><span class="line">    &#125;,1000);</span><br><span class="line">  &#125;</span><br><span class="line">  beforeDestory()&#123;</span><br><span class="line">    clearInterval(this.timer);</span><br><span class="line">    this.timer = null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面做法不好的地方在于：得全局多定义一个timer变量，可以使用hook这么做：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export default&#123;</span><br><span class="line">  methods:&#123;</span><br><span class="line">    fn()&#123;</span><br><span class="line">      const timer = setInterval(()=&gt;&#123;</span><br><span class="line">        //具体执行代码</span><br><span class="line">        console.log(&apos;1&apos;);</span><br><span class="line">      &#125;,1000);</span><br><span class="line">      this.$once(&apos;hook:beforeDestroy&apos;,()=&gt;&#123;</span><br><span class="line">        clearInterval(timer);</span><br><span class="line">        timer = null;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>7.2 父子组件使用</li></ul><blockquote><p>如果子组件需要在mounted时触发父组件的某一个函数，平时都会这么写：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//父组件</span><br><span class="line">&lt;rl-child @childMounted=childMountedHandle</span><br><span class="line">/&gt;</span><br><span class="line">method () &#123;</span><br><span class="line">  childMountedHandle() &#123;</span><br><span class="line">  // do something...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">mounted () &#123;</span><br><span class="line">  this.$emit(&apos;childMounted&apos;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><blockquote><p>使用hook的话可以更方便：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//父组件</span><br><span class="line">&lt;rl-child @hook:mounted=childMountedHandle</span><br><span class="line">/&gt;</span><br><span class="line">method () &#123;</span><br><span class="line">  childMountedHandle() &#123;</span><br><span class="line">  // do something...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="43-provide和inject是响应式的吗？"><a href="#43-provide和inject是响应式的吗？" class="headerlink" title="43. provide和inject是响应式的吗？"></a>43. provide和inject是响应式的吗？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 祖先组件</span><br><span class="line">provide()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">   // keyName: &#123; name: this.name &#125;, // value 是对象才能实现响应式，也就是引用类型</span><br><span class="line">      keyName: this.changeValue // 通过函数的方式也可以[注意，这里是把函数作为value，而不是this.changeValue()]</span><br><span class="line">   // keyName: &apos;test&apos; value 如果是基本类型，就无法实现响应式</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">data()&#123;</span><br><span class="line">  return &#123;</span><br><span class="line"> name:&apos;张三&apos;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">   changeValue()&#123;</span><br><span class="line">    this.name = &apos;改变后的名字-李四&apos;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  // 后代组件</span><br><span class="line">  inject:[&apos;keyName&apos;]</span><br><span class="line">  create()&#123;</span><br><span class="line"> console.log(this.keyName) // 改变后的名字-李四</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="44-Vue的el属性和-mount优先级？"><a href="#44-Vue的el属性和-mount优先级？" class="headerlink" title="44.Vue的el属性和 $mount优先级？"></a>44.Vue的el属性和 $mount优先级？</h3><blockquote><p>比如下面这种情况，Vue会渲染到哪个节点上</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;).$mount(&apos;#ggg&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>这是官方的一张图，可以看出<code>el</code>和<code>$mount</code>同时存在时，<code>el优先级</code> &gt; <code>$mount</code></p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/sz_mmbiz_png/gMvNo9rxo40PPicD3fczxSYXZxxV3D2ORib744Hzu19Rsf5HIpFjAeakRVBgeMf7sic9O8hvfs8gu9JMTntut1tjQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title>                </div>                <div class="image-caption">图片</div>            </figure>image.png<h3 id="45-动态指令和参数使用过吗？"><a href="#45-动态指令和参数使用过吗？" class="headerlink" title="45. 动态指令和参数使用过吗？"></a>45. 动态指令和参数使用过吗？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;aButton @[someEvent]=handleSomeEvent() :[someProps]=1000 /&gt;...</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  ...</span><br><span class="line">  data()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">      ...</span><br><span class="line">      someEvent: someCondition ? click : dbclick,</span><br><span class="line">      someProps: someCondition ? num : price</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleSomeEvent()&#123;</span><br><span class="line">      // handle some event</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="46-相同的路由组件如何重新渲染？"><a href="#46-相同的路由组件如何重新渲染？" class="headerlink" title="46. 相同的路由组件如何重新渲染？"></a>46. 相同的路由组件如何重新渲染？</h3><blockquote><p>开发人员经常遇到的情况是，多个路由解析为同一个Vue组件。问题是，Vue出于性能原因，默认情况下共享组件将不会重新渲染，如果你尝试在使用相同组件的路由之间进行切换，则不会发生任何变化。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: /a,</span><br><span class="line">    component: MyComponent</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: /b,</span><br><span class="line">    component: MyComponent</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><blockquote><p>如果依然想重新渲染，怎么办呢？可以使用<code>key</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;router-view :key=$route.path&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h3 id="47-自定义v-model"><a href="#47-自定义v-model" class="headerlink" title="47. 自定义v-model"></a>47. 自定义v-model</h3><blockquote><p>默认情况下，v-model 是 @input 事件侦听器和 :value 属性上的语法糖。但是，你可以在你的Vue组件中指定一个模型属性来定义使用什么事件和value属性——非常棒！</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export default: &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    event: &apos;change&apos;,</span><br><span class="line">    prop: &apos;checked&apos;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="48-如何将获取data中某一个数据的初始状态？"><a href="#48-如何将获取data中某一个数据的初始状态？" class="headerlink" title="48. 如何将获取data中某一个数据的初始状态？"></a>48. 如何将获取data中某一个数据的初始状态？</h3><blockquote><p>在开发中，有时候需要拿初始状态去计算。例如</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      num: 10</span><br><span class="line">  &#125;,</span><br><span class="line">mounted() &#123;</span><br><span class="line">    this.num = 1000</span><br><span class="line">  &#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    howMuch() &#123;</span><br><span class="line">        // 计算出num增加了多少，那就是1000 - 初始值</span><br><span class="line">        // 可以通过this.$options.data().xxx来获取初始值</span><br><span class="line">        console.log(1000 - this.$options.data().num)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="49-为什么不建议v-for和v-if同时存在"><a href="#49-为什么不建议v-for和v-if同时存在" class="headerlink" title="49.为什么不建议v-for和v-if同时存在"></a>49.为什么不建议v-for和v-if同时存在</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=item in [1, 2, 3, 4, 5, 6, 7] v-if=item !== 3&gt;</span><br><span class="line">    &#123;&#123;item&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><blockquote><p>上面的写法是v-for和v-if同时存在，会先把7个元素都遍历出来，然后再一个个判断是否为3，并把3给隐藏掉，这样的坏处就是，渲染了无用的3节点，增加无用的dom操作，建议使用computed来解决这个问题：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=item in list&gt;</span><br><span class="line">    &#123;&#123;item&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">computed() &#123;</span><br><span class="line">    list() &#123;</span><br><span class="line">        return [1, 2, 3, 4, 5, 6, 7].filter(item =&gt; item !== 3)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="50-计算变量时，methods和computed哪个好？"><a href="#50-计算变量时，methods和computed哪个好？" class="headerlink" title="50.计算变量时，methods和computed哪个好？"></a>50.计算变量时，methods和computed哪个好？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;howMuch1()&#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;howMuch2()&#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;index&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">         index: 0</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">methods: &#123;</span><br><span class="line">    howMuch1() &#123;</span><br><span class="line">        return this.num + this.price</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">computed() &#123;</span><br><span class="line">    howMuch2() &#123;</span><br><span class="line">        return this.num + this.price</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>computed</code>会好一些，因为computed会有<code>缓存</code>。例如index由0变成1，那么会触发视图更新，这时候methods会重新执行一次，而computed不会，因为computed依赖的两个变量num和price都没变。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-什么是vue的生命周期？&quot;&gt;&lt;a href=&quot;#1-什么是vue的生命周期？&quot; class=&quot;headerlink&quot; title=&quot;1.什么是vue的生命周期？&quot;&gt;&lt;/a&gt;1.什么是vue的生命周期？&lt;/h3&gt;&lt;p&gt;Vue实例从创建到销毁的过程，就是生命周期。
      
    
    </summary>
    
      <category term="前端知识点" scheme="https://qw66.gitee.io/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="vue" scheme="https://qw66.gitee.io/tags/vue/"/>
    
      <category term="MVVM" scheme="https://qw66.gitee.io/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript执行机制</title>
    <link href="https://qw66.gitee.io//knowledges/javascript-zhi-xing-ji-zhi.html"/>
    <id>https://qw66.gitee.io//knowledges/javascript-zhi-xing-ji-zhi.html</id>
    <published>2024-02-27T02:24:57.000Z</published>
    <updated>2024-04-03T16:14:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>不论你是javascript新手还是老鸟，不论是面试求职，还是日常开发工作，我们经常会遇到这样的情况：给定的几行代码，我们需要知道其输出内容和顺序。因为javascript是一门单线程语言，所以我们可以得出结论：</p><p>javascript是按照语句出现的顺序执行的</p><p>看到这里读者要打人了：我难道不知道js是一行一行执行的？还用你说？稍安勿躁，正因为js是一行一行执行的，所以我们以为js都是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'1'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="string">'2'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/20/15fd87f7221d0dbe~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>然而实际上js是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'定时器开始啦'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'马上执行for循环啦'</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">        i == <span class="number">99</span> &amp;&amp; resolve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行then函数啦'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'代码执行结束'</span>);</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/20/15fd87d38acc4905~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>依照<strong>js是按照语句出现的顺序执行</strong>这个理念，我自信的写下输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//"定时器开始啦"</span></span><br><span class="line"><span class="comment">//"马上执行for循环啦"</span></span><br><span class="line"><span class="comment">//"执行then函数啦"</span></span><br><span class="line"><span class="comment">//"代码执行结束"</span></span><br></pre></td></tr></table></figure><p>去chrome上验证下，结果完全不对，瞬间懵了，说好的一行一行执行的呢？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/20/15fd8840f3c3f109~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>我们真的要彻底弄明白javascript的执行机制了。</p><h3 id="1-关于javascript"><a href="#1-关于javascript" class="headerlink" title="1.关于javascript"></a>1.关于javascript</h3><p>javascript是一门<strong>单线程</strong>语言，在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。所以一切javascript版的”多线程”都是用单线程模拟出来的，一切javascript多线程都是纸老虎！</p><h3 id="2-javascript事件循环"><a href="#2-javascript事件循环" class="headerlink" title="2.javascript事件循环"></a>2.javascript事件循环</h3><p>既然js是单线程，那就像只有一个窗口的银行，客户需要排队一个一个办理业务，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此聪明的程序员将任务分为两类：</p><ul><li>同步任务</li><li>异步任务</li></ul><p>当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。关于这部分有严格的文字定义，但本文的目的是用最小的学习成本彻底弄懂执行机制，所以我们用导图来说明：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/21/15fdd88994142347~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>导图要表达的内容用文字来表述的话：</p><ul><li>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。</li><li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li><li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li><li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li></ul><p>我们不禁要问了，那怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。</p><p>说了这么多文字，不如直接一段代码更直白：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [];</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url:www.javascript.com,</span><br><span class="line">    data:data,</span><br><span class="line">    success:<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'发送成功!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'代码执行结束'</span>);</span><br></pre></td></tr></table></figure><p>上面是一段简易的<code>ajax</code>请求代码：</p><ul><li>ajax进入Event Table，注册回调函数<code>success</code>。</li><li>执行<code>console.log(&#39;代码执行结束&#39;)</code>。</li><li>ajax事件完成，回调函数<code>success</code>进入Event Queue。</li><li>主线程从Event Queue读取回调函数<code>success</code>并执行。</li></ul><p>相信通过上面的文字和代码，你已经对js的执行顺序有了初步了解。接下来我们来研究进阶话题：setTimeout。</p><h3 id="3-又爱又恨的setTimeout"><a href="#3-又爱又恨的setTimeout" class="headerlink" title="3.又爱又恨的setTimeout"></a>3.又爱又恨的setTimeout</h3><p>大名鼎鼎的<code>setTimeout</code>无需再多言，大家对他的第一印象就是异步可以延时执行，我们经常这么实现延时3秒执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'延时3秒'</span>);</span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><p>渐渐的<code>setTimeout</code>用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，这又咋回事啊？</p><p>先看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    task();</span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'执行console'</span>);</span><br></pre></td></tr></table></figure><p>根据前面我们的结论，<code>setTimeout</code>是异步的，应该先执行<code>console.log</code>这个同步任务，所以我们的结论是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行console</span></span><br><span class="line"><span class="comment">//task()</span></span><br></pre></td></tr></table></figure><p>去验证一下，结果正确！ 然后我们修改一下前面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    task()</span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">10000000</span>)</span><br></pre></td></tr></table></figure><p>乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行<code>task()</code>需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？</p><p>这时候我们需要重新理解<code>setTimeout</code>的定义。我们先说上述代码是怎么执行的：</p><ul><li><code>task()</code>进入Event Table并注册,计时开始。</li><li>执行<code>sleep</code>函数，很慢，非常慢，计时仍在继续。</li><li>3秒到了，计时事件<code>timeout</code>完成，<code>task()</code>进入Event Queue，但是<code>sleep</code>也太慢了吧，还没执行完，只好等着。</li><li><code>sleep</code>终于执行完了，<code>task()</code>终于从Event Queue进入了主线程执行。</li></ul><p>上述的流程走完，我们知道<code>setTimeout</code>这个函数，是经过指定时间后，把要执行的任务(本例中为<code>task()</code>)加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。</p><p>我们还经常遇到<code>setTimeout(fn,0)</code>这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？</p><p>答案是不会的，<code>setTimeout(fn,0)</code>的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'先执行这里'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行啦'</span>)</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//代码2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'先执行这里'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行啦'</span>)</span><br><span class="line">&#125;,<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>代码1的输出结果是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先执行这里</span></span><br><span class="line"><span class="comment">//执行啦</span></span><br></pre></td></tr></table></figure><p>代码2的输出结果是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先执行这里</span></span><br><span class="line"><span class="comment">// ... 3s later</span></span><br><span class="line"><span class="comment">// 执行啦</span></span><br></pre></td></tr></table></figure><p>关于<code>setTimeout</code>要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。有兴趣的同学可以自行了解。</p><h3 id="4-又恨又爱的setInterval"><a href="#4-又恨又爱的setInterval" class="headerlink" title="4.又恨又爱的setInterval"></a>4.又恨又爱的setInterval</h3><p>上面说完了<code>setTimeout</code>，当然不能错过它的孪生兄弟<code>setInterval</code>。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，<code>setInterval</code>会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。</p><p>唯一需要注意的一点是，对于<code>setInterval(fn,ms)</code>来说，我们已经知道不是每过<code>ms</code>秒会执行一次<code>fn</code>，而是每过<code>ms</code>秒，会有<code>fn</code>进入Event Queue。一旦<strong><code>setInterval</code>的回调函数<code>fn</code>执行时间超过了延迟时间<code>ms</code>，那么就完全看不出来有时间间隔了</strong>。这句话请读者仔细品味。</p><h3 id="5-Promise与process-nextTick-callback"><a href="#5-Promise与process-nextTick-callback" class="headerlink" title="5.Promise与process.nextTick(callback)"></a>5.Promise与process.nextTick(callback)</h3><p>传统的定时器我们已经研究过了，接着我们探究<code>Promise</code>与<code>process.nextTick(callback)</code>的表现。</p><p><code>Promise</code>的定义和功能本文不再赘述，不了解的读者可以学习一下阮一峰老师的<a href="https://link.juejin.cn?target=http%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fpromise" target="_blank" rel="noopener">Promise</a>。而<code>process.nextTick(callback)</code>类似node.js版的”setTimeout”，在事件循环的下一次循环中调用 callback 回调函数。</p><p>我们进入正题，除了广义的同步任务和异步任务，我们对任务有更精细的定义：</p><ul><li>macro-task(宏任务)：包括整体代码script，setTimeout，setInterval</li><li>micro-task(微任务)：Promise，process.nextTick</li></ul><p>不同类型的任务会进入对应的Event Queue，比如<code>setTimeout</code>和<code>setInterval</code>会进入相同的Event Queue。</p><p>事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。听起来有点绕，我们用文章最开始的一段代码说明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'then'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'console'</span>);</span><br></pre></td></tr></table></figure><ul><li>这段代码作为宏任务，进入主线程。</li><li>先遇到<code>setTimeout</code>，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述)</li><li>接下来遇到了<code>Promise</code>，<code>new Promise</code>立即执行，<code>then</code>函数分发到微任务Event Queue。</li><li>遇到<code>console.log()</code>，立即执行。</li><li>好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了<code>then</code>在微任务Event Queue里面，执行。</li><li>ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中<code>setTimeout</code>对应的回调函数，立即执行。</li><li>结束。</li></ul><p>事件循环，宏任务，微任务的关系如图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/21/15fdcea13361a1ec~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>我们来分析一段较复杂的代码，看看你是否真的掌握了js的执行机制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'6'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'7'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'9'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'10'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'11'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'12'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>第一轮事件循环流程分析如下：</p><ul><li>整体script作为第一个宏任务进入主线程，遇到<code>console.log</code>，输出1。</li><li>遇到<code>setTimeout</code>，其回调函数被分发到宏任务Event Queue中。我们暂且记为<code>setTimeout1</code>。</li><li>遇到<code>process.nextTick()</code>，其回调函数被分发到微任务Event Queue中。我们记为<code>process1</code>。</li><li>遇到<code>Promise</code>，<code>new Promise</code>直接执行，输出7。<code>then</code>被分发到微任务Event Queue中。我们记为<code>then1</code>。</li><li>又遇到了<code>setTimeout</code>，其回调函数被分发到宏任务Event Queue中，我们记为<code>setTimeout2</code>。</li></ul><table><thead><tr><th>宏任务Event Queue</th><th>微任务Event Queue</th></tr></thead><tbody><tr><td>setTimeout1</td><td>process1</td></tr><tr><td>setTimeout2</td><td>then1</td></tr></tbody></table><ul><li>上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。</li><li>我们发现了<code>process1</code>和<code>then1</code>两个微任务。</li><li>执行<code>process1</code>,输出6。</li><li>执行<code>then1</code>，输出8。</li></ul><p>好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从<code>setTimeout1</code>宏任务开始：</p><ul><li>首先输出2。接下来遇到了<code>process.nextTick()</code>，同样将其分发到微任务Event Queue中，记为<code>process2</code>。<code>new Promise</code>立即执行输出4，<code>then</code>也分发到微任务Event Queue中，记为<code>then2</code>。</li></ul><table><thead><tr><th>宏任务Event Queue</th><th>微任务Event Queue</th></tr></thead><tbody><tr><td>setTimeout2</td><td>process2</td></tr><tr><td></td><td>then2</td></tr></tbody></table><ul><li>第二轮事件循环宏任务结束，我们发现有<code>process2</code>和<code>then2</code>两个微任务可以执行。</li><li>输出3。</li><li>输出5。</li><li>第二轮事件循环结束，第二轮输出2，4，3，5。</li><li>第三轮事件循环开始，此时只剩setTimeout2了，执行。</li><li>直接输出9。</li><li>将<code>process.nextTick()</code>分发到微任务Event Queue中。记为<code>process3</code>。</li><li>直接执行<code>new Promise</code>，输出11。</li><li>将<code>then</code>分发到微任务Event Queue中，记为<code>then3</code>。</li></ul><table><thead><tr><th>宏任务Event Queue</th><th>微任务Event Queue</th></tr></thead><tbody><tr><td></td><td>process3</td></tr><tr><td></td><td>then3</td></tr></tbody></table><ul><li>第三轮事件循环宏任务执行结束，执行两个微任务<code>process3</code>和<code>then3</code>。</li><li>输出10。</li><li>输出12。</li><li>第三轮事件循环结束，第三轮输出9，11，10，12。</li></ul><p>整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。 (请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差)</p><h3 id="6-写在最后"><a href="#6-写在最后" class="headerlink" title="6.写在最后"></a>6.写在最后</h3><h4 id="1-js的异步"><a href="#1-js的异步" class="headerlink" title="(1)js的异步"></a>(1)js的异步</h4><p>我们从最开头就说javascript是一门单线程语言，不管是什么新框架新语法糖实现的所谓异步，其实都是用同步的方法去模拟的，牢牢把握住单线程这点非常重要。</p><h4 id="2-事件循环Event-Loop"><a href="#2-事件循环Event-Loop" class="headerlink" title="(2)事件循环Event Loop"></a>(2)事件循环Event Loop</h4><p>事件循环是js实现异步的一种方法，也是js的执行机制。</p><h4 id="3-javascript的执行和运行"><a href="#3-javascript的执行和运行" class="headerlink" title="(3)javascript的执行和运行"></a>(3)javascript的执行和运行</h4><p>执行和运行有很大的区别，javascript在不同的环境下，比如node，浏览器，Ringo等等，执行方式是不同的。而运行大多指javascript解析引擎，是统一的。</p><h4 id="4-setImmediate"><a href="#4-setImmediate" class="headerlink" title="(4)setImmediate"></a>(4)setImmediate</h4><p>微任务和宏任务还有很多种类，比如<code>setImmediate</code>等等，执行都是有共同点的，有兴趣的同学可以自行了解。</p><h4 id="5-最后的最后"><a href="#5-最后的最后" class="headerlink" title="(5)最后的最后"></a>(5)最后的最后</h4><ul><li>javascript是一门单线程语言</li><li>Event Loop是javascript的执行机制</li></ul><p>牢牢把握两个基本点，以认真学习javascript为中心，早日实现成为前端高手的伟大梦想！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/21/15fdd96beade6575~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>原文链接：<a href="https://juejin.cn/post/6844903512845860872" target="_blank" rel="noopener">https://juejin.cn/post/6844903512845860872</a></p><h1 id="代码题-看代码说结果-事件循环-async-函数"><a href="#代码题-看代码说结果-事件循环-async-函数" class="headerlink" title="代码题: 看代码说结果, 事件循环 + async 函数"></a>代码题: 看代码说结果, 事件循环 + async 函数</h1><h3 id="1-基本的-async-await-和事件循环"><a href="#1-基本的-async-await-和事件循环" class="headerlink" title="1.基本的 async/await 和事件循环"></a>1.基本的 async/await 和事件循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;1&apos;);</span><br><span class="line"></span><br><span class="line">async function asyncFunc() &#123;</span><br><span class="line">    console.log(&apos;2&apos;);</span><br><span class="line">    await Promise.resolve();</span><br><span class="line">    console.log(&apos;3&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncFunc();</span><br><span class="line"></span><br><span class="line">console.log(&apos;4&apos;);</span><br></pre></td></tr></table></figure><h4 id="执行顺序："><a href="#执行顺序：" class="headerlink" title="执行顺序："></a>执行顺序：</h4><p>执行顺序：</p><ol><li><p>打印 <code>1</code></p></li><li><p>定义异步函数 <code>asyncFunc</code>，但并不执行它。</p></li><li><p>调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asyncFunc()</span><br></pre></td></tr></table></figure><ul><li>打印 <code>2</code></li><li>遇到 <code>await</code>，所以 <code>asyncFunc</code> 的后续代码（打印 <code>3</code>）被移到事件队列中等待。</li></ul></li><li><p>打印 <code>4</code></p></li><li><p>所有同步代码执行完毕后，事件循环开始执行队列中的任务。</p><ul><li>打印 <code>3</code></li></ul></li></ol><h4 id="预期输出："><a href="#预期输出：" class="headerlink" title="预期输出："></a>预期输出：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="2-setTimeout-和-async-await-的结合"><a href="#2-setTimeout-和-async-await-的结合" class="headerlink" title="2.setTimeout 和 async/await 的结合"></a>2.setTimeout 和 async/await 的结合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;1&apos;);</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;2&apos;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">async function asyncFunc() &#123;</span><br><span class="line">    console.log(&apos;3&apos;);</span><br><span class="line">    await Promise.resolve();</span><br><span class="line">    console.log(&apos;4&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncFunc();</span><br><span class="line"></span><br><span class="line">console.log(&apos;5&apos;);</span><br></pre></td></tr></table></figure><h4 id="执行顺序：-1"><a href="#执行顺序：-1" class="headerlink" title="执行顺序："></a>执行顺序：</h4><ol><li>打印 1</li><li>将 setTimeout 回调（打印 2）设置为在0毫秒后执行。但实际上，它会被放入宏任务队列，等待所有微任务完成。</li><li>定义异步函数 asyncFunc，但并不执行。</li><li>调用 asyncFunc()。<br>打印 3<br>遇到 await，所以 asyncFunc 的后续代码（打印 4）被移到微任务队列中等待。</li><li>打印 5</li><li>执行微任务队列中的任务（因为微任务的优先级高于宏任务）。<br>打印 4</li><li>执行宏任务队列中的任务。<br>打印 2</li></ol><h4 id="预期输出：-1"><a href="#预期输出：-1" class="headerlink" title="预期输出："></a>预期输出：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="3-嵌套的-async-await"><a href="#3-嵌套的-async-await" class="headerlink" title="3.嵌套的 async/await"></a>3.嵌套的 async/await</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;1&apos;);</span><br><span class="line"></span><br><span class="line">async function firstAsync() &#123;</span><br><span class="line">    console.log(&apos;2&apos;);</span><br><span class="line">    await secondAsync();</span><br><span class="line">    console.log(&apos;3&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function secondAsync() &#123;</span><br><span class="line">    console.log(&apos;4&apos;);</span><br><span class="line">    await Promise.resolve();</span><br><span class="line">    console.log(&apos;5&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">firstAsync();</span><br><span class="line"></span><br><span class="line">console.log(&apos;6&apos;);</span><br></pre></td></tr></table></figure><h4 id="执行顺序：-2"><a href="#执行顺序：-2" class="headerlink" title="执行顺序："></a>执行顺序：</h4><ol><li>打印 1</li><li>定义两个异步函数，但不执行。</li><li>调用 firstAsync()。<br>打印 2<br>调用 secondAsync()。<pre><code>打印 4遇到 await，所以 secondAsync 的后续代码（打印 5）被移到微任务队列中等待。</code></pre>firstAsync 的后续代码（打印 3）也被移到微任务队列中等待。</li><li>打印 6</li><li>执行微任务队列中的任务。<br>打印 5<br>打印 3</li></ol><h4 id="预期输出：-2"><a href="#预期输出：-2" class="headerlink" title="预期输出："></a>预期输出：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="4-多个异步函数"><a href="#4-多个异步函数" class="headerlink" title="4.多个异步函数"></a>4.多个异步函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">async function asyncOne() &#123;</span><br><span class="line"> console.log(&apos;1&apos;);</span><br><span class="line"> await Promise.resolve();</span><br><span class="line"> console.log(&apos;2&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function asyncTwo() &#123;</span><br><span class="line">    console.log(&apos;3&apos;);</span><br><span class="line">    await Promise.resolve();</span><br><span class="line">    console.log(&apos;4&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&apos;5&apos;);</span><br><span class="line"></span><br><span class="line">asyncOne();</span><br><span class="line">asyncTwo();</span><br><span class="line"></span><br><span class="line">console.log(&apos;6&apos;);</span><br></pre></td></tr></table></figure><h4 id="执行顺序：-3"><a href="#执行顺序：-3" class="headerlink" title="执行顺序："></a>执行顺序：</h4><ol><li>定义两个异步函数，但不执行。</li><li>打印 5</li><li>调用 asyncOne()。<br>打印 1<br>遇到 await，所以 asyncOne 的后续代码（打印 2）被移到微任务队列中等待。</li><li>调用 asyncTwo()。<br>打印 3<br>遇到 await，所以 asyncTwo 的后续代码（打印 4）被移到微任务队列中等待。</li><li>打印 6</li><li>执行微任务队列中的任务。<br>打印 2<br>打印 4</li></ol><h4 id="预期输出：-3"><a href="#预期输出：-3" class="headerlink" title="预期输出："></a>预期输出：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="5-Promise-的基本行为"><a href="#5-Promise-的基本行为" class="headerlink" title="5.Promise 的基本行为"></a>5.Promise 的基本行为</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;1&apos;);</span><br><span class="line"></span><br><span class="line">Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;2&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;3&apos;);</span><br></pre></td></tr></table></figure><h4 id="执行顺序：-4"><a href="#执行顺序：-4" class="headerlink" title="执行顺序："></a>执行顺序：</h4><ol><li>打印 1</li><li>创建一个已解决的Promise，并在微任务队列中注册一个回调。</li><li>打印 3</li><li>当同步代码执行完成后，事件循环开始处理微任务队列，执行回调。</li><li>打印 2</li></ol><h4 id="预期输出：-4"><a href="#预期输出：-4" class="headerlink" title="预期输出："></a>预期输出：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="6-setTimeout-与-Promise-的组合"><a href="#6-setTimeout-与-Promise-的组合" class="headerlink" title="6.setTimeout 与 Promise 的组合"></a>6.setTimeout 与 Promise 的组合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;1&apos;);</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;2&apos;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;3&apos;);</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;4&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;5&apos;);</span><br></pre></td></tr></table></figure><h4 id="执行顺序：-5"><a href="#执行顺序：-5" class="headerlink" title="执行顺序："></a>执行顺序：</h4><ol><li>打印 1</li><li>将setTimeout的回调加入宏任务队列</li><li>创建一个已解决的Promise，并在微任务队列中注册第一个回调</li><li>在第一个then的回调中，注册第二个then的回调到微任务队列</li><li>打印 5</li><li>事件循环开始处理微任务，首先执行第一个then的回调</li><li>打印 3</li><li>紧接着，事件循环处理第二个then的回调</li><li>打印 4</li><li>最后，事件循环处理宏任务队列</li><li>打印 2</li></ol><h4 id="预期输出：-5"><a href="#预期输出：-5" class="headerlink" title="预期输出："></a>预期输出：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">5</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="7-多个-async-await-的嵌套"><a href="#7-多个-async-await-的嵌套" class="headerlink" title="7.多个 async/await 的嵌套"></a>7.多个 async/await 的嵌套</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;1&apos;);</span><br><span class="line"></span><br><span class="line">async function outerAsync() &#123;</span><br><span class="line">    console.log(&apos;2&apos;);</span><br><span class="line">    await innerAsync();</span><br><span class="line">    console.log(&apos;3&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function innerAsync() &#123;</span><br><span class="line">    console.log(&apos;4&apos;);</span><br><span class="line">    await new Promise(resolve =&gt; setTimeout(resolve, 0));</span><br><span class="line">    console.log(&apos;5&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outerAsync();</span><br><span class="line"></span><br><span class="line">console.log(&apos;6&apos;);</span><br></pre></td></tr></table></figure><h4 id="执行顺序：-6"><a href="#执行顺序：-6" class="headerlink" title="执行顺序："></a>执行顺序：</h4><ol><li>打印 1</li><li>定义两个异步函数，但此时并未执行它们</li><li>调用 outerAsync()</li><li>打印 2</li><li>调用 innerAsync()</li><li>打印 4</li><li>遇到setTimeout，所以它的回调被加入宏任务队列</li><li>await将后续代码（打印 5 和 outerAsync 中的打印 3）移至微任务队列</li><li>打印 6</li><li>事件循环开始处理微任务，但在此之前，必须先完成setTimeout的回调，<strong>必须要等里面完成才能完成外面</strong></li><li>打印 5</li><li>继续执行outerAsync中的代码</li><li>打印 3</li></ol><h4 id="预期输出：-6"><a href="#预期输出：-6" class="headerlink" title="预期输出："></a>预期输出：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="8-多个微任务队列（这个不会）"><a href="#8-多个微任务队列（这个不会）" class="headerlink" title="8.多个微任务队列（这个不会）"></a>8.多个微任务队列（这个不会）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;1&apos;);</span><br><span class="line"></span><br><span class="line">async function firstFunc() &#123;</span><br><span class="line">    console.log(&apos;2&apos;);</span><br><span class="line">    await Promise.resolve();</span><br><span class="line">    console.log(&apos;3&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function secondFunc() &#123;</span><br><span class="line">    console.log(&apos;4&apos;);</span><br><span class="line">    await Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">        console.log(&apos;5&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(&apos;6&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">firstFunc();</span><br><span class="line">secondFunc();</span><br><span class="line">console.log(&apos;7&apos;);</span><br></pre></td></tr></table></figure><h4 id="执行顺序：-7"><a href="#执行顺序：-7" class="headerlink" title="执行顺序："></a>执行顺序：</h4><ol><li>打印 1</li><li>调用 firstFunc()</li><li>打印 2</li><li>await使其后续代码（打印 3）移到微任务队列中</li><li>调用 secondFunc()</li><li>打印 4</li><li>await和then使其后续代码（首先打印 5，然后打印 6）移到微任务队列中</li><li>打印 7</li><li>事件循环开始处理微任务队列</li><li>打印 5</li><li>打印 3</li><li>打印 6</li></ol><h4 id="预期输出：-7"><a href="#预期输出：-7" class="headerlink" title="预期输出："></a>预期输出：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">7</span><br><span class="line">5</span><br><span class="line">3</span><br><span class="line">6</span><br></pre></td></tr></table></figure><h3 id="9-复杂的async-await与setTimeout"><a href="#9-复杂的async-await与setTimeout" class="headerlink" title="9.复杂的async/await与setTimeout"></a>9.复杂的async/await与setTimeout</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;1&apos;);</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;2&apos;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">async function asyncFunction() &#123;</span><br><span class="line">    console.log(&apos;3&apos;);</span><br><span class="line">    await Promise.resolve();</span><br><span class="line">    console.log(&apos;4&apos;);</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br></pre></td></tr></table></figure><p>原文链接：<a href="https://blog.csdn.net/weixin_43850639/article/details/132599505" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43850639/article/details/132599505</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不论你是javascript新手还是老鸟，不论是面试求职，还是日常开发工作，我们经常会遇到这样的情况：给定的几行代码，我们需要知道其输出内容和顺序。因为javascript是一门单线程语言，所以我们可以得出结论：&lt;/p&gt;
&lt;p&gt;javascript是按照语句出现的顺序执行的
      
    
    </summary>
    
      <category term="前端知识点" scheme="https://qw66.gitee.io/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="JavaScript" scheme="https://qw66.gitee.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>python</title>
    <link href="https://qw66.gitee.io//other/python.html"/>
    <id>https://qw66.gitee.io//other/python.html</id>
    <published>2024-02-26T01:44:06.000Z</published>
    <updated>2024-02-26T03:37:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装Python"><a href="#安装Python" class="headerlink" title="安装Python"></a>安装Python</h3><p>你可以从Python官方网站（<a href="https://www.python.org/downloads/）下载并安装Python。确保下载适合你操作系统的版本。如" target="_blank" rel="noopener">https://www.python.org/downloads/）下载并安装Python。确保下载适合你操作系统的版本。如</a> <a href="https://www.python.org/ftp/python/3.12.2/python-3.12.2-amd64.exe" target="_blank" rel="noopener">Windows installer (64-bit)</a> </p><p>特别要注意勾上 Add Python 3.5 to PATH，然后“lnstall Now”即可完成安装，默认会安装到 C：\Python35 目录下。</p><p>安装完成后， 打开命令提示符窗口（方法是点击“开始”-“运行”-输入：“cmd”），敲入 Python 后，会出现“Python 3.11.0”等内容。</p><h3 id="文件批量按日期命名"><a href="#文件批量按日期命名" class="headerlink" title="文件批量按日期命名"></a>文件批量按日期命名</h3><p>文件批量按日期命名可以通过脚本或命令行工具来实现。下面是一个使用Python脚本的示例，该脚本将指定目录下的所有文件按照日期进行重命名。</p><p>使用你选择的代码编辑器或IDE创建一个新文件<code>rename_files_by_date.py</code>，将下面Python代码复制粘贴进去。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os  </span><br><span class="line"><span class="keyword">import</span> datetime  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 设置要重命名文件的目录  </span></span><br><span class="line">directory = <span class="string">r"D:\test\images万贯"</span>  <span class="comment"># 使用原始字符串以避免反斜杠转义问题   </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历目录下的所有文件  </span></span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(directory):  </span><br><span class="line">    <span class="comment"># 拼接完整的文件路径  </span></span><br><span class="line">    filepath = os.path.join(directory, filename)  </span><br><span class="line">      </span><br><span class="line">    <span class="comment"># 判断是否为文件（排除目录）  </span></span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(filepath):  </span><br><span class="line">        <span class="comment"># 获取当前文件的修改时间  </span></span><br><span class="line">        mtime = os.path.getmtime(filepath)  </span><br><span class="line">        date = datetime.datetime.fromtimestamp(mtime)  </span><br><span class="line">          </span><br><span class="line">        <span class="comment"># 将文件名格式化为日期字符串，并添加文件扩展名</span></span><br><span class="line">        new_filename = date.strftime(<span class="string">"%Y%m%d_%H%M%S"</span>) + os.path.splitext(filename)[<span class="number">1</span>]  </span><br><span class="line">          </span><br><span class="line">        <span class="comment"># 拼接新的文件路径  </span></span><br><span class="line">        new_filepath = os.path.join(directory, new_filename)  </span><br><span class="line">          </span><br><span class="line">        <span class="comment"># 重命名文件  </span></span><br><span class="line">        os.rename(filepath, new_filepath)  </span><br><span class="line">        print(<span class="string">f"Renamed '<span class="subst">&#123;filename&#125;</span>' to '<span class="subst">&#123;new_filename&#125;</span>'"</span>)</span><br></pre></td></tr></table></figure><p>请确保将<code>/path/to/directory</code>替换为你要重命名文件的实际目录路径。运行脚本后，它将遍历指定目录下的所有文件，并按照文件的修改时间（以<code>YYYYMMDD_HHMMSS</code>的格式）对文件进行重命名。</p><p>注意：在运行脚本之前，请务必备份重要文件，以防意外情况发生。此外，脚本只会重命名文件，不会重命名子目录中的文件。如果你需要重命名子目录中的文件，请相应地修改脚本。</p><p>在Python字符串中，反斜杠<code>\</code>是一个特殊字符，也被用作转义字符，因此你需要使用双反斜杠<code>\\</code>来表示一个单独的反斜杠。或者，你可以在字符串前加上<code>r</code>来表示原始字符串，这样反斜杠就不会被当作转义字符。</p><p>以下是两种设置<code>directory</code>变量的方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用双反斜杠作为路径分隔符  </span></span><br><span class="line">directory = <span class="string">"D:\\test\\images万贯"</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 或者使用原始字符串（在字符串前加r）  </span></span><br><span class="line">directory = <span class="string">r"D:\test\images万贯"</span></span><br></pre></td></tr></table></figure><p>请确保在编写代码时使用其中一种方式正确设置<code>directory</code>变量，以便脚本能够正确地找到你的文件目录。</p><p>此外，需要注意的是，在Windows系统中，文件夹名称中的空格通常不会导致问题，但在路径字符串中确保正确地处理了所有特殊字符和空格是很重要的。</p><p>为了避免在重命名文件时出现名称冲突，我们可以在文件名后面添加序号来区分。我们可以修改脚本，使其检查新文件名是否已存在，如果存在，则在文件名后面添加括号和序号，直到找到一个唯一的文件名。</p><p>我们首先从文件名中提取出扩展名。然后，我们检查由基础文件名和扩展名组成的文件名是否已存在于<code>existing_filenames</code>字典中。如果存在，我们就在基础文件名后面添加括号和序号，序号从1开始递增，直到找到一个唯一的文件名。每次构造出新文件名后，我们都在字典中记录它，以确保下次不会重复使用。</p><p>这样，即使同一秒内只有一个文件被修改，我们的脚本也会确保文件名是唯一的，且序号出现在文件扩展名前面。 </p><h4 id="打开命令行或终端"><a href="#打开命令行或终端" class="headerlink" title="打开命令行或终端"></a>打开命令行或终端</h4><p>在Windows上，你可以按<code>Win + R</code>，然后输入<code>cmd</code>并按回车。在macOS或Linux上，你可以打开终端应用程序。</p><h4 id="导航到脚本所在目录"><a href="#导航到脚本所在目录" class="headerlink" title="导航到脚本所在目录"></a>导航到脚本所在目录</h4><p>在命令行或终端中，使用<code>cd</code>命令导航到保存了Python脚本的目录。例如，如果你的脚本在<code>C:\Users\YourName\Documents</code>目录下，你可以输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\Users\YourName\Documents</span><br></pre></td></tr></table></figure><h4 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h4><p>在命令行或终端中，输入以下命令来运行脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python rename_files_by_date.py</span><br></pre></td></tr></table></figure><p>确保你的Python安装路径已经添加到了系统的环境变量中，这样你才能直接在命令行中运行<code>python</code>命令。</p><h4 id="等待脚本执行完成"><a href="#等待脚本执行完成" class="headerlink" title="等待脚本执行完成"></a>等待脚本执行完成</h4><p>脚本将开始执行，并按照上述代码中定义的逻辑重命名指定目录下的文件。你将在命令行或终端中看到重命名的进度。</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>确保你有足够的权限来重命名文件。</li><li>在运行脚本之前，最好先备份你的文件，以防万一。</li><li>脚本将按照文件的修改时间进行重命名，这意味着如果两个文件有相同的修改时间，它们将被重命名为相同的文件名，这可能会导致文件覆盖。请确保这种情况不会发生，或者在脚本中添加额外的逻辑来处理这种情况。</li></ul><p>经过一步一步修改，现在没啥问题了，可以使用这个脚本来对自己备份的图片目录来重命名，文件名就是创建日期时间，一目了然。</p><p>Python牛逼(*≧∪≦) </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;安装Python&quot;&gt;&lt;a href=&quot;#安装Python&quot; class=&quot;headerlink&quot; title=&quot;安装Python&quot;&gt;&lt;/a&gt;安装Python&lt;/h3&gt;&lt;p&gt;你可以从Python官方网站（&lt;a href=&quot;https://www.python.org
      
    
    </summary>
    
      <category term="其他" scheme="https://qw66.gitee.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="python" scheme="https://qw66.gitee.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript</title>
    <link href="https://qw66.gitee.io//interview/javascript.html"/>
    <id>https://qw66.gitee.io//interview/javascript.html</id>
    <published>2024-02-14T02:24:57.000Z</published>
    <updated>2024-03-31T12:01:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JS的基本数据类型和引用数据类型"><a href="#JS的基本数据类型和引用数据类型" class="headerlink" title="JS的基本数据类型和引用数据类型"></a>JS的基本数据类型和引用数据类型</h3><ul><li><p>基本数据类型</p><table><thead><tr><th>类型</th><th>值</th></tr></thead><tbody><tr><td>string</td><td>单双引号引起来的数据</td></tr><tr><td>number</td><td>包括整型和浮点型</td></tr><tr><td>undefiend</td><td>未初始化的变量</td></tr><tr><td>null</td><td>相当于占位符</td></tr><tr><td>boolean</td><td>true真   false 假</td></tr><tr><td>Symbol</td><td>ES6新增，表示独一无二且不可变的值</td></tr><tr><td>BigInt</td><td>ES10新增，BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</td></tr></tbody></table></li><li><p>引用数据类型：object、array、function</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;    // 对象</span><br><span class="line">var arr = [];    // 数组</span><br><span class="line">var fn = function()&#123;&#125;;    // 函数</span><br></pre></td></tr></table></figure><h3 id="javascript-的-typeof-返回哪些数据类型"><a href="#javascript-的-typeof-返回哪些数据类型" class="headerlink" title="javascript 的 typeof 返回哪些数据类型"></a>javascript 的 typeof 返回哪些数据类型</h3><p>7 种分别为 string、boolean、number、Object、Function、undefined、symbol(ES6)、</p><h3 id="检测数据类型"><a href="#检测数据类型" class="headerlink" title="检测数据类型"></a>检测数据类型</h3><blockquote><p>typeof  +  变量名</p></blockquote><table><thead><tr><th align="center">检测</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center"><strong>null</strong></td><td align="center"><strong>object</strong></td></tr><tr><td align="center"><strong>{}</strong></td><td align="center"><strong>object</strong></td></tr><tr><td align="center"><strong>[]</strong></td><td align="center"><strong>object</strong></td></tr><tr><td align="center">undefined</td><td align="center">undefined</td></tr><tr><td align="center">string</td><td align="center">string</td></tr><tr><td align="center">number</td><td align="center">number</td></tr><tr><td align="center">boolean</td><td align="center">boolean</td></tr><tr><td align="center">Symbol</td><td align="center">symbol</td></tr><tr><td align="center">function</td><td align="center">function</td></tr></tbody></table><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>强制类型转换</p><ul><li>Number() 任意类型数据转化为数字</li><li>parselnt() 任意类型数据转化为整数</li><li>parseFloat() 任意类型数据转化为浮点数</li><li>String) 任意类型数据转化为字符串</li><li>Boolean() 任意类型数据转化为布尔值</li></ul><p>隐式类型转换</p><ul><li>算术运算符</li><li>逻辑运算符：&amp;&amp;||！运算，会调用Boolean()~函数判断参与逻辑运算的数据的真假性</li><li>关系运算符：<br>if、while、do while语句和三元表达式 里面的判断条件表达式会隐式的调用 Boolean()函数</li></ul><h3 id="复杂数据类型如何转变为字符串"><a href="#复杂数据类型如何转变为字符串" class="headerlink" title="复杂数据类型如何转变为字符串"></a>复杂数据类型如何转变为字符串</h3><ul><li>首先，会调用 valueOf 方法，如果方法的返回值是一个基本数据类型，就返回这个值</li><li>如果调用 valueOf 方法之后的返回值仍旧是一个复杂数据类型，就会调用该对象的 toString 方法</li><li>如果 toString 方法调用之后的返回值是一个基本数据类型，就返回这个值，</li><li>如果 toString 方法调用之后的返回值是一个复杂数据类型，就报一个错误。</li></ul><h3 id="JavaScript-中如何检测一个变量是一个-String-类型？"><a href="#JavaScript-中如何检测一个变量是一个-String-类型？" class="headerlink" title="JavaScript 中如何检测一个变量是一个 String 类型？"></a>JavaScript 中如何检测一个变量是一个 String 类型？</h3><p>答案：三种方法（typeof、constructor、Object.prototype.toString.call()）</p><p>解析：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">①<span class="keyword">typeof</span></span><br><span class="line"><span class="keyword">typeof</span>(<span class="string">'123'</span>) === <span class="string">"string"</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'123'</span> === <span class="string">"string"</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">②<span class="keyword">constructor</span></span><br><span class="line">'123'.<span class="keyword">constructor</span> === String // true</span><br><span class="line"></span><br><span class="line">③Object.prototype.toString.call()</span><br><span class="line">Object.prototype.toString.call('123') === '[object String]' // true</span><br></pre></td></tr></table></figure><h3 id="JavaScript-有几种类型的值？你能画一下他们的内存图吗？"><a href="#JavaScript-有几种类型的值？你能画一下他们的内存图吗？" class="headerlink" title="JavaScript 有几种类型的值？你能画一下他们的内存图吗？"></a>JavaScript 有几种类型的值？你能画一下他们的内存图吗？</h3><p>涉及知识点：</p><ul><li>栈：原始数据类型（Undefined、Null、Boolean、Number、String）</li><li>堆：引用数据类型（对象、数组和函数）</li></ul><p>两种类型的区别是：存储位置不同。<br>原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</p><p>引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。<br><a href="https://blog.csdn.net/jiangjuanjaun/article/details/80327342" target="_blank" rel="noopener">《JavaScript 有几种类型的值？能否画一下它们的内存图；》</a></p><h3 id="什么是堆？什么是栈？它们之间有什么区别和联系？"><a href="#什么是堆？什么是栈？它们之间有什么区别和联系？" class="headerlink" title="什么是堆？什么是栈？它们之间有什么区别和联系？"></a>什么是堆？什么是栈？它们之间有什么区别和联系？</h3><p>堆和栈的概念存在于数据结构中和操作系统内存中。</p><p>在数据结构中</p><p>栈中数据的存取方式为先进后出。而堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。完全二叉树是堆的一种实现方式。</p><p>在操作系统中</p><p>内存被分为栈区和堆区。</p><p>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p><p>堆区内存一般由程序员分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收。</p><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/19729973" target="_blank" rel="noopener">《什么是堆？什么是栈？他们之间有什么区别和联系？》</a></p><h3 id="null，undefined-的区别？"><a href="#null，undefined-的区别？" class="headerlink" title="null，undefined 的区别？"></a>null，undefined 的区别？</h3><h4 id="undefined-表示不存在这个值。"><a href="#undefined-表示不存在这个值。" class="headerlink" title="undefined   表示不存在这个值。"></a>undefined   表示不存在这个值。</h4><p>undefined :是一个表示”无”的原始值或者说表示”缺少值”，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined</p><p>例如变量被声明了，但没有赋值时，就等于undefined</p><h4 id="null-表示一个对象被定义了，值为“空值”"><a href="#null-表示一个对象被定义了，值为“空值”" class="headerlink" title="null 表示一个对象被定义了，值为“空值”"></a>null 表示一个对象被定义了，值为“空值”</h4><p>null : 是一个对象(空对象, 没有任何属性和方法)</p><p>例如作为函数的参数，表示该函数的参数不是对象；</p><p>在验证null时，一定要使用　=== ，因为 == 无法分别 null 和　undefined</p><h3 id="和-的不同"><a href="#和-的不同" class="headerlink" title="== 和 === 的不同"></a>== 和 === 的不同</h3><p>答案：<code>==</code>是抽象相等运算符，而<code>===</code>是严格相等运算符。</p><p><code>==</code>运算符是在进行必要的类型转换后，再比较。</p><p><code>===</code>运算符不会进行类型转换，所以如果两个值不是相同的类型，会直接返回<code>false</code>。使用<code>==</code>时，可能发生一些特别的事情，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="string">"1"</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span> == [<span class="number">1</span>]; <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span> == <span class="literal">true</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">""</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">"0"</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">false</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果你对<code>==</code>和<code>===</code>的概念不是特别了解，建议大多数情况下使用<code>===</code></p><h3 id="如何判断-NaN"><a href="#如何判断-NaN" class="headerlink" title="如何判断 NaN"></a>如何判断 NaN</h3><p>isNaN()方法</p><p>解析：isNaN(NaN) // true</p><h3 id="说几条写JavaScript的基本规范？"><a href="#说几条写JavaScript的基本规范？" class="headerlink" title="说几条写JavaScript的基本规范？"></a>说几条写JavaScript的基本规范？</h3><ul><li><p>代码缩进，建议使用“四个空格”缩进</p></li><li><p>代码段使用花括号{}包裹</p></li><li><p>语句结束使用分号;</p></li><li><p>变量和函数在使用前进行声明，不要在同一行声明多个变量。</p></li><li><p>以大写字母开头命名构造函数，全大写命名常量</p></li><li><p>规范定义JSON对象，补全双引号</p></li><li><p>用{}和[]声明对象和数组</p></li><li><p>请使用 ===/!==来比较true/false或者数值</p></li><li><p>使用对象字面量替代new Array这种形式</p></li><li><p>不要使用全局函数</p></li><li><p>Switch语句必须带有default分支</p></li><li><p>函数不应该有时候有返回值，有时候没有返回值。</p></li><li><p>For循环必须使用大括号，If语句必须使用大括号。</p></li><li><p>for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。</p></li></ul><h3 id="如何编写高性能的JavaScript？"><a href="#如何编写高性能的JavaScript？" class="headerlink" title="如何编写高性能的JavaScript？"></a>如何编写高性能的JavaScript？</h3><ul><li>将js脚本放在页面底部，加快渲染页面</li><li>尽量减少使用闭包</li><li>将js脚本将脚本成组打包，减少请求</li><li>使用非阻塞方式下载js脚本</li><li>尽量使用局部变量来保存全局变量</li><li>遵循严格模式：”use strict”;</li><li>使用 window 对象属性方法时，省略 window</li><li>尽量减少对象成员嵌套</li><li>缓存 DOM 节点的访问</li><li>通过避免使用 eval() 和 Function() 构造器</li><li>给 setTimeout() 和 setInterval() 传递函数而不是字符串作为参数</li><li>尽量使用直接量创建对象和数组</li><li>最小化重绘(repaint)和回流(reflow)</li><li>使用 DocumentFragment 优化多次 append</li><li>通过模板元素 clone ，替代 createElement</li><li>使用一次 innerHTML 赋值代替构建 dom 元素</li><li>使用 firstChild 和 nextSibling 代替 childNodes 遍历 dom 元素</li><li>使用 Array 做为 StringBuffer ，代替字符串拼接的操作</li><li>将循环控制量保存到局部变量</li><li>顺序无关的遍历时，用 while 替代 for</li><li>将条件分支，按可能性顺序从高到低排列</li><li>在同一条件子的多（ &gt;2 ）条件分支时，使用 switch 优于 if</li><li>使用三目运算符替代条件分支</li><li>需要不断执行的时候，优先考虑使用 setInterval</li></ul><h3 id="document-load-和-document-ready-的区别"><a href="#document-load-和-document-ready-的区别" class="headerlink" title="document load 和 document ready 的区别"></a>document load 和 document ready 的区别</h3><p>页面加载完成有两种事件<br>1.load是当页面所有资源全部加载完成后（包括DOM文档树，css文件，js文件，图片资源等），执行一个函数<br>问题：如果图片资源较多，加载时间较长，onload后等待执行的函数需要等待较长时间，所以一些效果可能受到影响</p><p>2.$(document).ready()是当DOM文档树加载完成后执行一个函数 （不包含图片，css等）所以会比load较快执行<br>在原生的jS中不包括ready()这个方法，只有load方法就是onload事件</p><h3 id="字符串常用操作"><a href="#字符串常用操作" class="headerlink" title="字符串常用操作"></a>字符串常用操作</h3><ul><li>charAt(index):返回指定索引处的字符串</li><li>charCodeAt(index):返回指定索引处的字符的 Unicode 的值</li><li>concat(str1,str2,…):连接多个字符串，返回连接后的字符串的副本</li><li>fromCharCode():将 Unicode 值转换成实际的字符串</li><li>indexOf(str):返回 str 在父串中第一次出现的位置，若没有则返回-1</li><li>lastIndexOf(str):返回 str 在父串中最后一次出现的位置，若没有则返回-1</li><li>match(regex):搜索字符串，并返回正则表达式的所有匹配</li><li>replace(str1,str2):str1 也可以为正则表达式，用 str2 替换 str1</li><li>search(regex):基于正则表达式搜索字符串，并返回第一个匹配的位置</li><li>slice(start,end)：返回字符索引在 start 和 end（不含）之间的子串</li><li>split(sep，limit)：将字符串分割为字符数组，limit 为从头开始执行分割的最大数量</li><li>substr(start，length)：从字符索引 start 的位置开始，返回长度为 length 的子串</li><li>substring(from,to)：返回字符索引在 from 和 to（不含）之间的子串</li><li>toLowerCase()：将字符串转换为小写</li><li>toUpperCase()：将字符串转换为大写</li><li>valueOf()：返回原始字符串值</li></ul><h3 id="内部属性-Class-是什么？"><a href="#内部属性-Class-是什么？" class="headerlink" title="内部属性 [[Class]] 是什么？"></a>内部属性 [[Class]] 是什么？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">所有 typeof 返回值为 &quot;object&quot; 的对象（如数组）都包含一个内部属性 [[Class]]（我们可以把它看作一个内部的分类，而非</span><br><span class="line">传统的面向对象意义上的类）。这个属性无法直接访问，一般通过 Object.prototype.toString(..) 来查看。例如：</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call( [1,2,3] );</span><br><span class="line">// &quot;[object Array]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call( /regex-literal/i );</span><br><span class="line">// &quot;[object RegExp]&quot;</span><br><span class="line"></span><br><span class="line">// 我们自己创建的类就不会有这份特殊待遇，因为 toString() 找不到 toStringTag 属性时只好返回默认的 Object 标签</span><br><span class="line">// 默认情况类的[[Class]]返回[object Object]</span><br><span class="line">class Class1 &#123;&#125;</span><br><span class="line">Object.prototype.toString.call(new Class1()); // &quot;[object Object]&quot;</span><br><span class="line">// 需要定制[[Class]]</span><br><span class="line">class Class2 &#123;</span><br><span class="line">  get [Symbol.toStringTag]() &#123;</span><br><span class="line">    return &quot;Class2&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Object.prototype.toString.call(new Class2()); // &quot;[object Class2]&quot;</span><br></pre></td></tr></table></figure><h3 id="介绍-js-有哪些内置对象？"><a href="#介绍-js-有哪些内置对象？" class="headerlink" title="介绍 js 有哪些内置对象？"></a>介绍 js 有哪些内置对象？</h3><p>涉及知识点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">全局的对象（ global objects ）或称标准内置对象，不要和 &quot;全局对象（global object）&quot; 混淆。这里说的全局的对象是说在</span><br><span class="line">全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。</span><br><span class="line"></span><br><span class="line">标准内置对象的分类</span><br><span class="line"></span><br><span class="line">（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。</span><br><span class="line"></span><br><span class="line">例如 Infinity、NaN、undefined、null 字面量</span><br><span class="line"></span><br><span class="line">（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。</span><br><span class="line"></span><br><span class="line">例如 eval()、parseFloat()、parseInt() 等</span><br><span class="line"></span><br><span class="line">（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。</span><br><span class="line"></span><br><span class="line">例如 Object、Function、Boolean、Symbol、Error 等</span><br><span class="line"></span><br><span class="line">（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。</span><br><span class="line"></span><br><span class="line">例如 Number、Math、Date</span><br><span class="line"></span><br><span class="line">（5）字符串，用来表示和操作字符串的对象。</span><br><span class="line"></span><br><span class="line">例如 String、RegExp</span><br><span class="line"></span><br><span class="line">（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array</span><br><span class="line"></span><br><span class="line">（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。</span><br><span class="line"></span><br><span class="line">例如 Map、Set、WeakMap、WeakSet</span><br><span class="line"></span><br><span class="line">（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。</span><br><span class="line"></span><br><span class="line">例如 SIMD 等</span><br><span class="line"></span><br><span class="line">（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。</span><br><span class="line"></span><br><span class="line">例如 JSON 等</span><br><span class="line"></span><br><span class="line">（10）控制抽象对象</span><br><span class="line"></span><br><span class="line">例如 Promise、Generator 等</span><br><span class="line"></span><br><span class="line">（11）反射</span><br><span class="line"></span><br><span class="line">例如 Reflect、Proxy</span><br><span class="line"></span><br><span class="line">（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。</span><br><span class="line"></span><br><span class="line">例如 Intl、Intl.Collator 等</span><br><span class="line"></span><br><span class="line">（13）WebAssembly</span><br><span class="line"></span><br><span class="line">（14）其他</span><br><span class="line"></span><br><span class="line">例如 arguments</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函</span><br><span class="line">数对象。一般我们经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构</span><br><span class="line">造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="noopener">《标准内置对象的分类》</a><br><a href="https://segmentfault.com/a/1190000011467723#articleHeader24" target="_blank" rel="noopener">《JS 所有内置对象属性和方法汇总》</a></p><h3 id="undefined-与-undeclared-的区别？"><a href="#undefined-与-undeclared-的区别？" class="headerlink" title="undefined 与 undeclared 的区别？"></a>undefined 与 undeclared 的区别？</h3><p>已在作用域中声明但还没有赋值的变量，是 undefined 的。相反，还没有在作用域中声明过的变量，是 undeclared 的。</p><p>对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用 typ<br>eof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 “undefined”。</p><h3 id="null-和-undefined-的区别？"><a href="#null-和-undefined-的区别？" class="headerlink" title="null 和 undefined 的区别？"></a>null 和 undefined 的区别？</h3><p>首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</p><p>undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null<br>主要用于赋值给一些可能会返回对象的变量，作为初始化。</p><p>undefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它<br>会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。</p><p>当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等<br>号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</p><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8Bundefined%E4%B8%8Enull.html" target="_blank" rel="noopener">《JavaScript 深入理解之 undefined 与 null》</a></p><h3 id="如何获取安全的-undefined-值？"><a href="#如何获取安全的-undefined-值？" class="headerlink" title="如何获取安全的 undefined 值？"></a>如何获取安全的 undefined 值？</h3><p>因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。</p><p>表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。</p><p>按惯例我们用 void 0 来获得 undefined。</p><h3 id="说几条写-JavaScript-的基本规范？"><a href="#说几条写-JavaScript-的基本规范？" class="headerlink" title="说几条写 JavaScript 的基本规范？"></a>说几条写 JavaScript 的基本规范？</h3><p>在平常项目开发中，我们遵守一些这样的基本规范，比如说：</p><p>（1）一个函数作用域中所有的变量声明应该尽量提到函数首部，用一个 var 声明，不允许出现两个连续的 var 声明，声明时<br>    如果变量没有值，应该给该变量赋值对应类型的初始值，便于他人阅读代码时，能够一目了然的知道变量对应的类型值。</p><p>（2）代码中出现地址、时间等字符串时需要使用常量代替。</p><p>（3）在进行比较的时候吧，尽量使用’===’, ‘!==’代替’==’, ‘!=’。</p><p>（4）不要在内置对象的原型上添加方法，如 Array, Date。</p><p>（5）switch 语句必须带有 default 分支。</p><p>（6）for 循环必须使用大括号。</p><p>（7）if 语句必须使用大括号。</p><h3 id="JavaScript-原型，原型链？-有什么特点？"><a href="#JavaScript-原型，原型链？-有什么特点？" class="headerlink" title="JavaScript 原型，原型链？ 有什么特点？"></a>JavaScript 原型，原型链？ 有什么特点？</h3><p>在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说我们是不应该能够获取到这个值的，但是现在浏览器中都实现了 <strong>proto</strong> 属性来让我们访问这个属性，但是我们最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个Object.getPrototypeOf() 方法，我们可以通过这个方法来获取对象的原型。</p><p>当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是我们新建的对象为什么能够使用 toString() 等方法的原因。</p><p>特点：</p><p>JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</p><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE.html" target="_blank" rel="noopener">《JavaScript 深入理解之原型与原型链》</a></p><h3 id="js-获取原型的方法？"><a href="#js-获取原型的方法？" class="headerlink" title="js 获取原型的方法？"></a>js 获取原型的方法？</h3><ul><li>p.__proto__</li><li>p.constructor.prototype</li><li>Object.getPrototypeOf(p)</li></ul><h3 id="在-js-中不同进制数字的表示方式"><a href="#在-js-中不同进制数字的表示方式" class="headerlink" title="在 js 中不同进制数字的表示方式"></a>在 js 中不同进制数字的表示方式</h3><ul><li><p>以 0X、0x 开头的表示为十六进制。</p></li><li><p>以 0、0O、0o 开头的表示为八进制。</p></li><li><p>以 0B、0b 开头的表示为二进制格式。</p></li></ul><h3 id="js-中整数的安全范围是多少？"><a href="#js-中整数的安全范围是多少？" class="headerlink" title="js 中整数的安全范围是多少？"></a>js 中整数的安全范围是多少？</h3><p>安全整数指的是，在这个范围内的整数转化为二进制存储的时候不会出现精度丢失，能够被“安全”呈现的最大整数是 2^53 - 1，<br>即9007199254740991，在 ES6 中被定义为 Number.MAX_SAFE_INTEGER。最小整数是-9007199254740991，在 ES6 中被定义为 Number.MIN_SAFE_INTEGER。</p><p>如果某次计算的结果得到了一个超过 JavaScript 数值范围的值，那么这个值会被自动转换为特殊的 Infinity 值。如果某次计算返回了正或负的 Infinity 值，那么该值将无法参与下一次的计算。判断一个数是不是有穷的，可以使用 isFinite 函数来判断。</p><h3 id="typeof-NaN-的结果是什么？"><a href="#typeof-NaN-的结果是什么？" class="headerlink" title="typeof NaN 的结果是什么？"></a>typeof NaN 的结果是什么？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NaN 意指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</span><br><span class="line"></span><br><span class="line">typeof NaN; // &quot;number&quot;</span><br><span class="line"></span><br><span class="line">NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN != NaN为 true。</span><br></pre></td></tr></table></figure><h3 id="isNaN-和-Number-isNaN-函数的区别？"><a href="#isNaN-和-Number-isNaN-函数的区别？" class="headerlink" title="isNaN 和 Number.isNaN 函数的区别？"></a>isNaN 和 Number.isNaN 函数的区别？</h3><p>函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。</p><p>函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，这种方法对于 NaN 的判断更为准确。</p><h3 id="Array-构造函数只有一个参数值时的表现？"><a href="#Array-构造函数只有一个参数值时的表现？" class="headerlink" title="Array 构造函数只有一个参数值时的表现？"></a>Array 构造函数只有一个参数值时的表现？</h3><p>Array 构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度（length），而非只充当数组中的一个元素。这样<br>创建出来的只是一个空数组，只不过它的 length 属性被设置成了指定的值。</p><p>构造函数 Array(..) 不要求必须带 new 关键字。不带时，它会被自动补上。</p><h3 id="其他值到字符串的转换规则？"><a href="#其他值到字符串的转换规则？" class="headerlink" title="其他值到字符串的转换规则？"></a>其他值到字符串的转换规则？</h3><p>规范的 9.8 节中定义了抽象操作 ToString ，它负责处理非字符串到字符串的强制类型转换。</p><p>（1）Null 和 Undefined 类型 ，null 转换为 “null”，undefined 转换为 “undefined”，</p><p>（2）Boolean 类型，true 转换为 “true”，false 转换为 “false”。</p><p>（3）Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。</p><p>（4）Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。</p><p>（5）对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）<br>    来返回内部属性 [[Class]] 的值，如”[object Object]”。如果对象有自己的 toString() 方法，字符串化时就会<br>    调用该方法并使用其返回值。</p><h3 id="其他值到数字值的转换规则？"><a href="#其他值到数字值的转换规则？" class="headerlink" title="其他值到数字值的转换规则？"></a>其他值到数字值的转换规则？</h3><p>有时我们需要将非数字值当作数字来使用，比如数学运算。为此 ES5 规范在 9.3 节定义了抽象操作 ToNumber。</p><p>（1）Undefined 类型的值转换为 NaN。</p><p>（2）Null 类型的值转换为 0。</p><p>（3）Boolean 类型的值，true 转换为 1，false 转换为 0。</p><p>（4）String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。</p><p>（5）Symbol 类型的值不能转换为数字，会报错。</p><p>（6）对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。</p><p>为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf() 方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。</p><p>如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。</p><h3 id="其他值到布尔类型的值的转换规则？"><a href="#其他值到布尔类型的值的转换规则？" class="headerlink" title="其他值到布尔类型的值的转换规则？"></a>其他值到布尔类型的值的转换规则？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ES5 规范 9.2 节中定义了抽象操作 ToBoolean，列举了布尔强制类型转换所有可能出现的结果。</span><br><span class="line"></span><br><span class="line">以下这些是假值：</span><br><span class="line">• undefined</span><br><span class="line">• null</span><br><span class="line">• false</span><br><span class="line">• +0、-0 和 NaN</span><br><span class="line">• &quot;&quot;</span><br><span class="line"></span><br><span class="line">假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。</span><br></pre></td></tr></table></figure><h3 id="和-的-valueOf-和-toString-的结果是什么？"><a href="#和-的-valueOf-和-toString-的结果是什么？" class="headerlink" title="{} 和 [] 的 valueOf 和 toString 的结果是什么？"></a>{} 和 [] 的 valueOf 和 toString 的结果是什么？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125; 的 valueOf 结果为 &#123;&#125; ，toString 的结果为 &quot;[object Object]&quot;</span><br><span class="line"></span><br><span class="line">[] 的 valueOf 结果为 [] ，toString 的结果为 &quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="什么是假值对象？"><a href="#什么是假值对象？" class="headerlink" title="什么是假值对象？"></a>什么是假值对象？</h3><p>浏览器在某些特定情况下，在常规 JavaScript 语法基础上自己创建了一些外来值，这些就是“假值对象”。假值对象看起来和普通对象并无二致（都有属性，等等），但将它们强制类型转换为布尔值时结果为 false 最常见的例子是 document.all，它是一个类数组对象，包含了页面上的所有元素，由 DOM（而不是 JavaScript 引擎）提供给 JavaScript 程序使用。</p><h3 id="操作符的作用？"><a href="#操作符的作用？" class="headerlink" title="~ 操作符的作用？"></a>~ 操作符的作用？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~ 返回 2 的补码，并且 ~ 会将数字转换为 32 位整数，因此我们可以使用 ~ 来进行取整操作。</span><br><span class="line"></span><br><span class="line">~x 大致等同于 -(x+1)。</span><br></pre></td></tr></table></figure><h3 id="解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？"><a href="#解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？" class="headerlink" title="解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？"></a>解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？</h3><p>解析允许字符串（如 parseInt() ）中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换（如 Nu<br>mber ()）不允许出现非数字字符，否则会失败并返回 NaN。</p><h3 id="操作符什么时候用于字符串的拼接？"><a href="#操作符什么时候用于字符串的拼接？" class="headerlink" title="+ 操作符什么时候用于字符串的拼接？"></a><code>+</code> 操作符什么时候用于字符串的拼接？</h3><p>根据 ES5 规范 11.6.1 节，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其<br>中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以<br>数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。</p><p>简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字<br>加法。</p><p>那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。</p><h3 id="什么情况下会发生布尔值的隐式强制类型转换？"><a href="#什么情况下会发生布尔值的隐式强制类型转换？" class="headerlink" title="什么情况下会发生布尔值的隐式强制类型转换？"></a>什么情况下会发生布尔值的隐式强制类型转换？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1） if (..) 语句中的条件判断表达式。</span><br><span class="line">（2） for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。</span><br><span class="line">（3） while (..) 和 do..while(..) 循环中的条件判断表达式。</span><br><span class="line">（4） ? : 中的条件判断表达式。</span><br><span class="line">（5） 逻辑运算符 ||（逻辑或）和 &amp;&amp;（逻辑与）左边的操作数（作为条件判断表达式）。</span><br></pre></td></tr></table></figure><h3 id="和-amp-amp-操作符的返回值？"><a href="#和-amp-amp-操作符的返回值？" class="headerlink" title="|| 和 &amp;&amp; 操作符的返回值？"></a>|| 和 &amp;&amp; 操作符的返回值？</h3><p>|| 和 &amp;&amp; 首先会对第一个操作数执行条件判断，如果其不是布尔值就先进行 ToBoolean 强制类型转换，然后再执行条件判断。</p><p>对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。</p><p>&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。</p><p>|| 和 &amp;&amp; 返回它们其中一个操作数的值，而非条件判断的结果</p><h3 id="Symbol-值的强制类型转换？"><a href="#Symbol-值的强制类型转换？" class="headerlink" title="Symbol 值的强制类型转换？"></a>Symbol 值的强制类型转换？</h3><p>ES6 允许从符号到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误。</p><p>Symbol 值不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换为布尔值（显式和隐式结果<br>都是 true ）。</p><h3 id="操作符的强制类型转换规则？"><a href="#操作符的强制类型转换规则？" class="headerlink" title="== 操作符的强制类型转换规则？"></a>== 操作符的强制类型转换规则？</h3><p>（1）字符串和数字之间的相等比较，将字符串转换为数字之后再进行比较。</p><p>（2）其他类型和布尔类型之间的相等比较，先将布尔值转换为数字后，再应用其他规则进行比较。</p><p>（3）null 和 undefined 之间的相等比较，结果为真。其他值和它们进行比较都返回假值。</p><p>（4）对象和非对象之间的相等比较，对象先调用 ToPrimitive 抽象操作后，再进行比较。</p><p>（5）如果一个操作值为 NaN ，则相等比较返回 false（ NaN 本身也不等于 NaN ）。</p><p>（6）如果两个操作值都是对象，则比较它们是不是指向同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true，否则，返回 false。</p><p>详细资料可以参考：<br><a href="https://www.jeffjade.com/2015/08/28/2015-09-02-js-string-compare/" target="_blank" rel="noopener">《JavaScript 字符串间的比较》</a></p><h3 id="如何将字符串转化为数字，例如-‘12-3b’"><a href="#如何将字符串转化为数字，例如-‘12-3b’" class="headerlink" title="如何将字符串转化为数字，例如 ‘12.3b’?"></a>如何将字符串转化为数字，例如 ‘12.3b’?</h3><p>（1）使用 Number() 方法，前提是所包含的字符串不包含不合法字符。</p><p>（2）使用 parseInt() 方法，parseInt() 函数可解析一个字符串，并返回一个整数。还可以设置要解析的数字的基数。当基数的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。</p><p>（3）使用 parseFloat() 方法，该函数解析一个字符串参数并返回一个浮点数。</p><p>（4）使用 + 操作符的隐式转换，前提是所包含的字符串不包含不合法字符。</p><p>详细资料可以参考：<br><a href="https://blog.csdn.net/m0_38099607/article/details/72638678" target="_blank" rel="noopener">《详解 JS 中 Number()、parseInt() 和 parseFloat() 的区别》</a></p><h3 id="如何将浮点数点左边的数每三位添加一个逗号，如-12000000-11-转化为『12-000-000-11』"><a href="#如何将浮点数点左边的数每三位添加一个逗号，如-12000000-11-转化为『12-000-000-11』" class="headerlink" title="如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?"></a>如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> number &amp;&amp; number.replace(<span class="regexp">/(?!^)(?=(\d&#123;3&#125;)+\.)/g</span>, <span class="string">","</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format1</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Intl</span>.NumberFormat().format(number)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法三</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format2</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> number.toLocaleString(<span class="string">'en'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）匹配 16 进制颜色值</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）匹配日期，如 yyyy-mm-dd 格式</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）匹配 qq 号</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[1-9][0-9]&#123;4,10&#125;$/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （4）手机号码正则</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^1[34578]\d&#123;9&#125;$/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （5）用户名正则</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[a-zA-Z\$][a-zA-Z0-9_\$]&#123;4,16&#125;$/</span>;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://caibaojian.com/form-regexp.html" target="_blank" rel="noopener">《前端表单验证常用的 15 个 JS 正则表达式》</a><br><a href="https://www.jianshu.com/p/1cb5229325a7" target="_blank" rel="noopener">《JS 常用正则汇总》</a></p><h3 id="生成随机数的各种方法？"><a href="#生成随机数的各种方法？" class="headerlink" title="生成随机数的各种方法？"></a>生成随机数的各种方法？</h3><p><a href="http://www.hangge.com/blog/cache/detail_1872.html" target="_blank" rel="noopener">《JS - 生成随机数的方法汇总（不同范围、类型的随机数）》</a></p><h3 id="如何实现数组的随机排序？"><a href="#如何实现数组的随机排序？" class="headerlink" title="如何实现数组的随机排序？"></a>如何实现数组的随机排序？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）使用数组 sort 方法对数组元素随机排序，让 Math.random() 出来的数与 0.5 比较，如果大于就返回 1 交换位置，如果小于就返回 -1，不交换位置。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  缺点：每个元素被派到新数组的位置不是随机的，原因是 sort() 方法是依次比较的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）随机从原数组抽取一个元素，加入到新数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (arr.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> randomIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * arr.length);</span><br><span class="line">    result.push(arr[randomIndex]);</span><br><span class="line">    arr.splice(randomIndex, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）随机交换数组内的元素（洗牌算法类似）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index,</span><br><span class="line">    randomIndex,</span><br><span class="line">    temp,</span><br><span class="line">    len = arr.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; len; index++) &#123;</span><br><span class="line">    randomIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (len - index)) + index;</span><br><span class="line"></span><br><span class="line">    temp = arr[index];</span><br><span class="line">    arr[index] = arr[randomIndex];</span><br><span class="line">    arr[randomIndex] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> length = array.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; length - <span class="number">1</span>; index++) &#123;</span><br><span class="line">    <span class="keyword">let</span> randomIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (length - index)) + index;</span><br><span class="line"></span><br><span class="line">    [array[index], array[randomIndex]] = [array[randomIndex], array[index]];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://gaohaoyang.github.io/2016/10/16/shuffle-algorithm/#top" target="_blank" rel="noopener">《Fisher and Yates 的原始版》</a><br><a href="https://www.zhihu.com/question/32303195" target="_blank" rel="noopener">《javascript 实现数组随机排序?》</a><br><a href="https://www.w3cplus.com/javascript/how-to-randomize-shuffle-a-javascript-array.html" target="_blank" rel="noopener">《JavaScript 学习笔记：数组随机排序》</a></p><h3 id="javascript-创建对象的几种方式？"><a href="#javascript-创建对象的几种方式？" class="headerlink" title="javascript 创建对象的几种方式？"></a>javascript 创建对象的几种方式？</h3><p>我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是我们可以使用函数来进行模拟，从而产生出可复用的对象<br>创建方式，我了解到的方式有这么几种：</p><p>（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。</p><p>（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。</p><p>（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。</p><p>（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。</p><p>（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。</p><p>（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。</p><p>嗯我目前了解到的就是这么几种方式。</p><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA.html" target="_blank" rel="noopener">《JavaScript 深入理解之对象创建》</a></p><h3 id="JavaScript-继承的几种实现方式？"><a href="#JavaScript-继承的几种实现方式？" class="headerlink" title="JavaScript 继承的几种实现方式？"></a>JavaScript 继承的几种实现方式？</h3><p>我了解的 js 中实现继承的几种方式有：</p><p>（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。</p><p>（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。</p><p>（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。</p><p>（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。</p><p>（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。</p><p>（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</p><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E7%BB%A7%E6%89%BF.html" target="_blank" rel="noopener">《JavaScript 深入理解之继承》</a></p><h3 id="寄生式组合继承的实现？"><a href="#寄生式组合继承的实现？" class="headerlink" title="寄生式组合继承的实现？"></a>寄生式组合继承的实现？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"My name is "</span> + <span class="keyword">this</span>.name + <span class="string">"."</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, grade</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype = <span class="built_in">Object</span>.create(Person.prototype);</span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line">Student.prototype.sayMyGrade = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"My grade is "</span> + <span class="keyword">this</span>.grade + <span class="string">"."</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Javascript-的作用域链？"><a href="#Javascript-的作用域链？" class="headerlink" title="Javascript 的作用域链？"></a>Javascript 的作用域链？</h3><p>作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。</p><p>作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</p><p>当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。</p><p>作用域链的创建过程跟执行上下文的建立有关….</p><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.html" target="_blank" rel="noopener">《JavaScript 深入理解之作用域链》</a></p><h3 id="谈谈-This-对象的理解。"><a href="#谈谈-This-对象的理解。" class="headerlink" title="谈谈 This 对象的理解。"></a>谈谈 This 对象的理解。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。</span><br></pre></td></tr></table></figure><p>1.第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。</p><p>2.第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。</p><p>3.第三种是构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。</p><p>4.第四种是 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这四种方式，使用构造器调用模式的优先级最高，然后是 apply 、 call 和 bind 调用模式，然后是方法调用模式，然后</span><br><span class="line">是函数调用模式。</span><br></pre></td></tr></table></figure><p><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8Bthis%E8%AF%A6%E8%A7%A3.html" target="_blank" rel="noopener">《JavaScript 深入理解之 this 详解》</a></p><h3 id="eval-是做什么的？"><a href="#eval-是做什么的？" class="headerlink" title="eval 是做什么的？"></a>eval 是做什么的？</h3><p>它的功能是把对应的字符串解析成 JS 代码并运行。</p><p>应该避免使用 eval，不安全，非常耗性能（2次，一次解析成 js 语句，一次执行）。</p><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval" target="_blank" rel="noopener">《eval()》</a></p><h3 id="什么是-DOM-和-BOM？"><a href="#什么是-DOM-和-BOM？" class="headerlink" title="什么是 DOM 和 BOM？"></a>什么是 DOM 和 BOM？</h3><p>DOM 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。</p><p>BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。</p><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/33453164" target="_blank" rel="noopener">《DOM, DOCUMENT, BOM, WINDOW 有什么区别?》</a><br><a href="http://www.w3school.com.cn/jsref/dom_obj_window.asp" target="_blank" rel="noopener">《Window 对象》</a><br><a href="https://www.zhihu.com/question/20724662" target="_blank" rel="noopener">《DOM 与 BOM 分别是什么，有何关联？》</a><br><a href="https://segmentfault.com/a/1190000000654274#articleHeader21" target="_blank" rel="noopener">《JavaScript 学习总结（三）BOM 和 DOM 详解》</a></p><h3 id="写一个通用的事件侦听器函数。"><a href="#写一个通用的事件侦听器函数。" class="headerlink" title="写一个通用的事件侦听器函数。"></a>写一个通用的事件侦听器函数。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventUtils = &#123;</span><br><span class="line">  <span class="comment">// 视能力分别使用dom0||dom2||IE方式 来绑定事件</span></span><br><span class="line">  <span class="comment">// 添加事件</span></span><br><span class="line">  addEvent: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">      element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">      element.attachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">"on"</span> + type] = handler;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除事件</span></span><br><span class="line">  removeEvent: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">      element.removeEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">      element.detachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">"on"</span> + type] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取事件目标</span></span><br><span class="line">  getTarget: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event.target || event.srcElement;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event</span></span><br><span class="line">  getEvent: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event || <span class="built_in">window</span>.event;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获）</span></span><br><span class="line">  stopPropagation: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.stopPropagation) &#123;</span><br><span class="line">      event.stopPropagation();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消事件的默认行为</span></span><br><span class="line">  preventDefault: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.preventDefault) &#123;</span><br><span class="line">      event.preventDefault();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.returnValue = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000006934031#articleHeader6" target="_blank" rel="noopener">《JS 事件模型》</a></p><h3 id="事件是什么？IE-与火狐的事件机制有什么区别？-如何阻止冒泡？"><a href="#事件是什么？IE-与火狐的事件机制有什么区别？-如何阻止冒泡？" class="headerlink" title="事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？"></a>事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？</h3><p>1.事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。</p><p>2.事件处理机制：IE 支持事件冒泡、Firefox 同时支持两种事件模型，也就是：事件冒泡和事件捕获。</p><p>3.event.stopPropagation() 或者 ie 下的方法 event.cancelBubble = true;</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/lvdabao/p/3265870.html" target="_blank" rel="noopener">《Javascript 事件模型系列（一）事件及事件的三种模型》</a><br><a href="https://blog.csdn.net/wuseyukui/article/details/13771493" target="_blank" rel="noopener">《Javascript 事件模型：事件捕获和事件冒泡》</a></p><h3 id="三种事件模型是什么？"><a href="#三种事件模型是什么？" class="headerlink" title="三种事件模型是什么？"></a>三种事件模型是什么？</h3><p>事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。</p><p>第一种事件模型是最早的 DOM0 级模型，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实<br>现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。这种方式是所有浏览器都兼容的。</p><p>第二种事件模型是 IE 事件模型，在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。</p><p>第三种是 DOM2 级事件模型，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。</p><p>详细资料可以参考：<br><a href="https://blog.csdn.net/u013217071/article/details/77613706" target="_blank" rel="noopener">《一个 DOM 元素绑定多个事件时，先执行冒泡还是捕获》</a></p><h3 id="事件委托是什么？"><a href="#事件委托是什么？" class="headerlink" title="事件委托是什么？"></a>事件委托是什么？</h3><p>事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。</p><p>使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。</p><p>详细资料可以参考：<br><a href="https://zhuanlan.zhihu.com/p/26536815" target="_blank" rel="noopener">《JavaScript 事件委托详解》</a></p><h3 id="“1”-“2”-“3”-map-parseInt-答案是多少？"><a href="#“1”-“2”-“3”-map-parseInt-答案是多少？" class="headerlink" title="[“1”, “2”, “3”].map(parseInt) 答案是多少？"></a>[“1”, “2”, “3”].map(parseInt) 答案是多少？</h3><p>parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)，其中 radix 表示要解析的数字的基数。（该值介于 2 ~ 36 之间，并且字符串中的数字不能大于 radix 才能正确返回数字结果值）。</p><p>此处 map 传了 3 个参数 (element, index, array)，默认第三个参数被忽略掉，因此三次传入的参数分别为 “1-0”, “2-1”, “3-2”</p><p>因为字符串的值不能大于基数，因此后面两次调用均失败，返回 NaN ，第一次基数为 0 ，按十进制解析返回 1。</p><p>详细资料可以参考：<br><a href="https://blog.csdn.net/justjavac/article/details/19473199" target="_blank" rel="noopener">《为什么 [“1”, “2”, “3”].map(parseInt) 返回 [1,NaN,NaN]？》</a></p><h3 id="什么是闭包，为什么要用它？"><a href="#什么是闭包，为什么要用它？" class="headerlink" title="什么是闭包，为什么要用它？"></a>什么是闭包，为什么要用它？</h3><p>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。</p><p>闭包有两个常用的用途。</p><p>闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</p><p>函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</p><p>其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。</p><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E9%97%AD%E5%8C%85.html" target="_blank" rel="noopener">《JavaScript 深入理解之闭包》</a></p><h3 id="javascript-代码中的-“use-strict”-是什么意思-使用它区别是什么？"><a href="#javascript-代码中的-“use-strict”-是什么意思-使用它区别是什么？" class="headerlink" title="javascript 代码中的 “use strict”; 是什么意思 ? 使用它区别是什么？"></a>javascript 代码中的 “use strict”; 是什么意思 ? 使用它区别是什么？</h3><p>use strict 是一种 ECMAscript5 添加的（严格）运行模式，这种模式使得 Javascript 在更严格的条件下运行。</p><p>设立”严格模式”的目的，主要有以下几个：</p><ul><li>消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;</li><li>消除代码运行的一些不安全之处，保证代码运行的安全；</li><li>提高编译器效率，增加运行速度；</li><li>为未来新版本的 Javascript 做好铺垫。</li></ul><p>区别：</p><ul><li>1.禁止使用 with 语句。</li><li>2.禁止 this 关键字指向全局对象。</li><li>3.对象不能有重名的属性。</li></ul><p>回答：</p><p>use strict 指的是严格运行模式，在这种模式对 js 的使用添加了一些限制。比如说禁止 this 指向全局对象，还有禁止使用 with 语句等。设立严格模式的目的，主要是为了消除代码使用中的一些不安全的使用方式，也是为了消除 js 语法本身的一些不合理的地方，以此来减少一些运行时的怪异的行为。同时使用严格运行模式也能够提高编译的效率，从而提高代码的运行速度。<br>我认为严格模式代表了 js 一种更合理、更安全、更严谨的发展方向。</p><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html" target="_blank" rel="noopener">《Javascript 严格模式详解》</a></p><h3 id="如何判断一个对象是否属于某个类？"><a href="#如何判断一个对象是否属于某个类？" class="headerlink" title="如何判断一个对象是否属于某个类？"></a>如何判断一个对象是否属于某个类？</h3><p>第一种方式是使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p><p>第二种方式可以通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。</p><p>第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断。</p><p>详细资料可以参考：<br><a href="https://blog.csdn.net/haitunmin/article/details/78418522" target="_blank" rel="noopener">《js 判断一个对象是否属于某一类》</a></p><h3 id="instanceof-的作用？"><a href="#instanceof-的作用？" class="headerlink" title="instanceof 的作用？"></a>instanceof 的作用？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</span></span><br><span class="line"><span class="comment">// 实现：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> proto = <span class="built_in">Object</span>.getPrototypeOf(left), <span class="comment">// 获取对象的原型</span></span><br><span class="line">    prototype = right.prototype; <span class="comment">// 获取构造函数的 prototype 对象</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断构造函数的 prototype 对象是否在对象的原型链上</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!proto) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (proto === prototype) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    proto = <span class="built_in">Object</span>.getPrototypeOf(proto);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof" target="_blank" rel="noopener">《instanceof》</a></p><h3 id="new-操作符具体干了什么呢？如何实现？"><a href="#new-操作符具体干了什么呢？如何实现？" class="headerlink" title="new 操作符具体干了什么呢？如何实现？"></a>new 操作符具体干了什么呢？如何实现？</h3><p>（1）首先创建了一个新的空对象<br>（2）设置原型，将对象的原型设置为函数的 prototype 对象。<br>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）<br>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">constructor</span> = Array.prototype.shift.call(arguments),</span><br><span class="line">    result = null;</span><br><span class="line"></span><br><span class="line">  // 参数判断</span><br><span class="line">  if (typeof <span class="keyword">constructor</span> !== "function") &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"type error"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span></span><br><span class="line">  newObject = <span class="built_in">Object</span>.create(<span class="keyword">constructor</span>.prototype);</span><br><span class="line"></span><br><span class="line">  // 将 this 指向新建对象，并执行函数</span><br><span class="line">  result = <span class="keyword">constructor</span>.apply(newObject, arguments);</span><br><span class="line"></span><br><span class="line">  // 判断返回对象</span><br><span class="line">  let flag =</span><br><span class="line">    result &amp;&amp; (typeof result === "object" || typeof result === "function");</span><br><span class="line"></span><br><span class="line">  // 判断返回结果</span><br><span class="line">  return flag ? result : newObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用方法</span><br><span class="line">// objectFactory(构造函数, 初始化参数);</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000008576048" target="_blank" rel="noopener">《new 操作符具体干了什么？》</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/13" target="_blank" rel="noopener">《JavaScript 深入之 new 的模拟实现》</a></p><h3 id="Javascript-中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？"><a href="#Javascript-中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？" class="headerlink" title="Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？"></a>Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hasOwnProperty</span><br><span class="line"></span><br><span class="line">所有继承了 Object 的对象都会继承到 hasOwnProperty 方法。这个方法可以用来检测一个对象是否含有特定的自身属性，和in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty" target="_blank" rel="noopener">《Object.prototype.hasOwnProperty()》</a></p><h3 id="对于-JSON-的了解？"><a href="#对于-JSON-的了解？" class="headerlink" title="对于 JSON 的了解？"></a>对于 JSON 的了解？</h3><p>相关知识点：</p><p>JSON 是一种数据交换格式，基于文本，优于轻量，用于交换数据。</p><p>JSON 可以表示数字、布尔值、字符串、null、数组（值的有序序列），以及由这些值（或数组、对象）所组成的对象（字符串与值的映射）。</p><p>JSON 使用 JavaScript 语法，但是 JSON 格式仅仅是一个文本。文本可以被任何编程语言读取及作为数据格式传递。</p><p>回答：</p><p>JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。</p><p>在项目开发中，我们使用 JSON 作为前后端数据交换的方式。在前端我们通过将一个符合 JSON 格式的数据结构序列化为 JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。</p><p>因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是我们应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。</p><p>在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，一个是 JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，我们可以调用这个函数将数据对象转化为 JSON 格式的字符串。</p><p>另一个函数 JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当我们从后端接收到 JSON 格式的字符串时，我们可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。</p><p>详细资料可以参考：<br><a href="https://my.oschina.net/u/3284240/blog/874368" target="_blank" rel="noopener">《深入了解 JavaScript 中的 JSON 》</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[].forEach.call($$(&quot;*&quot;),function(a)&#123;a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16)&#125;)`</span><br></pre></td></tr></table></figure><h3 id="能解释一下这段代码的意思吗？"><a href="#能解释一下这段代码的意思吗？" class="headerlink" title="能解释一下这段代码的意思吗？"></a>能解释一下这段代码的意思吗？</h3><p>（1）选取页面所有 DOM 元素。在浏览器的控制台中可以使用$$()方法来获取页面中相应的元素，这是现代浏览器提供的一个命令行 API 相当于 document.querySelectorAll 方法。</p><p>（2）循环遍历 DOM 元素</p><p>（3）给元素添加 outline 。由于渲染的 outline 是不在 CSS 盒模型中的，所以为元素添加 outline 并不会影响元素的大小和页面的布局。</p><p>（4）生成随机颜色函数。Math.random()*(1&lt;&lt;24) 可以得到 0~2^24 - 1 之间的随机数，因为得到的是一个浮点数，但我们只需要整数部分，使用取反操作符 ~ 连续两次取反获得整数部分，然后再用 toString(16) 的方式，转换为一个十六进制的字符串。</p><p>详细资料可以参考：<br><a href="https://2008winstar.iteye.com/blog/2128290" target="_blank" rel="noopener">《通过一行代码学 JavaScript》</a></p><h3 id="js-延迟加载的方式有哪些？"><a href="#js-延迟加载的方式有哪些？" class="headerlink" title="js 延迟加载的方式有哪些？"></a>js 延迟加载的方式有哪些？</h3><p>js 延迟加载，也就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度。</p><p>一般有以下几种方式：</p><ul><li>defer 属性</li><li>async 属性</li><li>动态创建 DOM 方式</li><li>使用 setTimeout 延迟方法</li><li>让 JS 最后加载</li></ul><p>回答：</p><p>js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。</p><p>我了解到的几种方式是：</p><p>第一种方式是我们一般采用的是将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</p><p>第二种方式是给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</p><p>第三种方式是给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</p><p>第四种方式是动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</p><p>详细资料可以参考：<br><a href="https://blog.csdn.net/meijory/article/details/76389762" target="_blank" rel="noopener">《JS 延迟加载的几种方式》</a><br><a href="http://www.w3school.com.cn/html5/att_script_async.asp" target="_blank" rel="noopener">《HTML 5 <code>&lt;script&gt;</code> <code>async</code> 属性》</a></p><h3 id="Ajax-是什么-如何创建一个-Ajax？"><a href="#Ajax-是什么-如何创建一个-Ajax？" class="headerlink" title="Ajax 是什么? 如何创建一个 Ajax？"></a>Ajax 是什么? 如何创建一个 Ajax？</h3><p>相关知识点：</p><p>2005 年 2 月，AJAX 这个词第一次正式提出，它是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</p><p>具体来说，AJAX 包括以下几个步骤。</p><p>1.创建 XMLHttpRequest 对象，也就是创建一个异步调用对象</p><p>2.创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息</p><p>3.设置响应 HTTP 请求状态变化的函数</p><p>4.发送 HTTP 请求</p><p>5.获取异步调用返回的数据</p><p>6.使用 JavaScript 和 DOM 实现局部刷新</p><p>一般实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SERVER_URL = <span class="string">"/server"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Http 请求</span></span><br><span class="line">xhr.open(<span class="string">"GET"</span>, SERVER_URL, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 设置状态监听函数</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.readyState !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 当请求成功时</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">    handle(<span class="keyword">this</span>.response);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="keyword">this</span>.statusText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置请求失败时的监听函数</span></span><br><span class="line">xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="keyword">this</span>.statusText);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置请求头信息</span></span><br><span class="line">xhr.responseType = <span class="string">"json"</span>;</span><br><span class="line">xhr.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送 Http 请求</span></span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// promise 封装实现：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJSON</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个 promise 对象</span></span><br><span class="line">  <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建一个 http 请求</span></span><br><span class="line">    xhr.open(<span class="string">"GET"</span>, url, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置状态的监听函数</span></span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.readyState !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当请求成功或失败时，改变 promise 的状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(<span class="keyword">this</span>.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置错误监听函数</span></span><br><span class="line">    xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置响应的数据类型</span></span><br><span class="line">    xhr.responseType = <span class="string">"json"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置请求头信息</span></span><br><span class="line">    xhr.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送 http 请求</span></span><br><span class="line">    xhr.send(<span class="literal">null</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回答：</p><p>我对 ajax 的理解是，它是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。</p><p>创建一个 ajax 有这样几个步骤</p><p>首先是创建一个 XMLHttpRequest 对象。</p><p>然后在这个对象上使用 open 方法创建一个 http 请求，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</p><p>在发起请求前，我们可以为这个对象添加一些信息和监听函数。比如说我们可以通过 setRequestHeader 方法来为请求添加头信息。我们还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，我们可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候我们可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候我们就可以通过 response 中的数据来对页面进行更新了。</p><p>当对象的属性和监听函数设置完成后，最后我们调用 sent 方法来向服务器发起请求，可以传入参数作为发送的数据体。</p><p>详细资料可以参考：<br><a href="https://wangdoc.com/javascript/bom/xmlhttprequest.html" target="_blank" rel="noopener">《XMLHttpRequest 对象》</a><br><a href="https://juejin.im/post/5acde23c5188255cb32e7e76" target="_blank" rel="noopener">《从 ajax 到 fetch、axios》</a><br><a href="https://juejin.im/post/5c160937f265da61180199b2" target="_blank" rel="noopener">《Fetch 入门》</a><br><a href="https://segmentfault.com/a/1190000003810652" target="_blank" rel="noopener">《传统 Ajax 已死，Fetch 永生》</a></p><h3 id="谈一谈浏览器的缓存机制？"><a href="#谈一谈浏览器的缓存机制？" class="headerlink" title="谈一谈浏览器的缓存机制？"></a>谈一谈浏览器的缓存机制？</h3><p>浏览器的缓存机制指的是通过在一段时间内保留已接收到的 web 资源的一个副本，如果在资源的有效时间内，发起了对这个资源的再一次请求，那么浏览器会直接使用缓存的副本，而不是向服务器发起请求。使用 web 缓存可以有效地提高页面的打开速度，减少不必要的网络带宽的消耗。</p><p>web 资源的缓存策略一般由服务器来指定，可以分为两种，分别是强缓存策略和协商缓存策略。</p><p>使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。</p><p>服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。</p><p>Expires 是 http1.0 中的方式，因为它的一些缺点，在 http 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，常用的比如我们可以通过设置 max-age 来指定资源能够被缓存的时间的大小，这是一个相对的时间，它会根据这个时间的大小和资源第一次请求时的时间来计算出资源过期的时间，因此相对于 Expires来说，这种方式更加有效一些。常用的还有比如 private ，用来规定资源只能被客户端缓存，不能够代理服务器所缓存。还有如 no-store ，用来指定资源不能够被缓存，no-cache 代表该资源能够被缓存，但是立即失效，每次都需要向服务器发起请求。</p><p>一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires 。</p><p>使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。<br>如果资源发生了修改，则返回修改后的资源。协商缓存也可以通过两种方式来设置，分别是 http 头信息中的 Etag 和 Last-Modified 属性。</p><p>服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，<br>这样会造成缓存命中的不准确。</p><p>因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。</p><p>当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。</p><p>强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。</p><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000012573337" target="_blank" rel="noopener">《浅谈浏览器缓存》</a><br><a href="https://juejin.im/post/5b9346dcf265da0aac6fbe57#heading-3" target="_blank" rel="noopener">《前端优化：浏览器缓存技术介绍》</a><br><a href="https://www.web-tinker.com/article/21221.html" target="_blank" rel="noopener">《请求头中的 Cache-Control》</a><br><a href="https://juejin.im/post/5c2d6c9ae51d450cf4195a08" target="_blank" rel="noopener">《Cache-Control 字段值详解》</a></p><h3 id="Ajax-解决浏览器缓存问题？"><a href="#Ajax-解决浏览器缓存问题？" class="headerlink" title="Ajax 解决浏览器缓存问题？"></a>Ajax 解决浏览器缓存问题？</h3><p>1.在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(“If-Modified-Since”,”0”)。</p><p>2.在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(“Cache-Control”,”no-cache”)。</p><p>3.在 URL 后面加上一个随机数： “fresh=” + Math.random();。</p><p>4.在 URL 后面加上时间戳：”nowtime=” + new Date().getTime();。</p><p>5.如果是使用 jQuery，直接这样就可以了$.ajaxSetup({cache:false})。这样页面的所有 ajax 都会执行这条语句就是不需要保存缓存记录。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/cwzqianduan/p/8632009.html" target="_blank" rel="noopener">《Ajax 中浏览器的缓存问题解决方法》</a><br><a href="https://segmentfault.com/a/1190000012573337" target="_blank" rel="noopener">《浅谈浏览器缓存》</a></p><h3 id="同步和异步的区别？"><a href="#同步和异步的区别？" class="headerlink" title="同步和异步的区别？"></a>同步和异步的区别？</h3><p>同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是处于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。  </p><p>异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。 </p><p>回答：</p><p>同步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。</p><p>异步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理。</p><p>详细资料可以参考：<br><a href="https://blog.csdn.net/tennysonsky/article/details/45111623" target="_blank" rel="noopener">《同步和异步的区别》</a></p><h3 id="什么是浏览器的同源政策？"><a href="#什么是浏览器的同源政策？" class="headerlink" title="什么是浏览器的同源政策？"></a>什么是浏览器的同源政策？</h3><p>我对浏览器的同源政策的理解是，一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容。这里的同源的指的是两个域的协议、域名、端口号必须相同，否则则不属于同一个域。</p><p>同源政策主要限制了三个方面</p><p>第一个是当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。</p><p>第二个是当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。</p><p>第三个是当前域下 ajax 无法发送跨域请求。</p><p>同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。</p><h3 id="如何解决跨域问题？"><a href="#如何解决跨域问题？" class="headerlink" title="如何解决跨域问题？"></a>如何解决跨域问题？</h3><p>相关知识点：</p><ol><li><p>通过 jsonp 跨域</p></li><li><p>document.domain + iframe 跨域</p></li><li><p>location.hash + iframe</p></li><li><p>window.name + iframe 跨域</p></li><li><p>postMessage 跨域</p></li><li><p>跨域资源共享（CORS)</p></li><li><p>nginx 代理跨域</p></li><li><p>nodejs 中间件代理跨域</p></li><li><p>WebSocket 协议跨域</p></li></ol><p>回答：</p><p>解决跨域的方法我们可以根据我们想要实现的目的来划分。</p><p>首先我们如果只是想要实现主域名下的不同子域名的跨域操作，我们可以使用设置 document.domain 来解决。</p><p>（1）将 document.domain 设置为主域名，来实现相同子域名的跨域操作，这个时候主域名下的 cookie 就能够被子域名所访问。同时如果文档中含有主域名相同，子域名不同的 iframe 的话，我们也可以对这个 iframe 进行操作。</p><p>如果是想要解决不同跨域窗口间的通信问题，比如说一个页面想要和页面的中的不同源的 iframe 进行通信的问题，我们可以使用 location.hash 或者 window.name 或者 postMessage 来解决。</p><p>（2）使用 location.hash 的方法，我们可以在主页面动态的修改 iframe 窗口的 hash 值，然后在 iframe 窗口里实现监听函数来实现这样一个单向的通信。因为在 iframe 是没有办法访问到不同源的父级窗口的，所以我们不能直接修改父级窗口的 hash 值来实现通信，我们可以在 iframe 中再加入一个 iframe ，这个 iframe 的内容是和父级页面同源的，所以我们可以 window.parent.parent 来修改最顶级页面的 src，以此来实现双向通信。</p><p>（3）使用 window.name 的方法，主要是基于同一个窗口中设置了 window.name 后不同源的页面也可以访问，所以不同源的子页面可以首先在 window.name 中写入数据，然后跳转到一个和父级同源的页面。这个时候级页面就可以访问同源的子页面中 window.name 中的数据了，这种方式的好处是可以传输的数据量大。</p><p>（4）使用 postMessage 来解决的方法，这是一个 h5 中新增的一个 api。通过它我们可以实现多窗口间的信息传递，通过获取到指定窗口的引用，然后调用 postMessage 来发送信息，在窗口中我们通过对 message 信息的监听来接收信息，以此来实现不同源间的信息交换。</p><p>如果是像解决 ajax 无法提交跨域请求的问题，我们可以使用 jsonp、cors、websocket 协议、服务器代理来解决问题。</p><p>（5）使用 jsonp 来实现跨域请求，它的主要原理是通过动态构建 script  标签来实现跨域请求，因为浏览器对 script 标签的引入没有跨域的访问限制 。通过在请求的 url 后指定一个回调函数，然后服务器在返回数据的时候，构建一个 json 数据的包装，这个包装就是回调函数，然后返回给前端，前端接收到数据后，因为请求的是脚本文件，所以会直接执行，这样我们先前定义好的回调函数就可以被调用，从而实现了跨域请求的处理。这种方式只能用于 get 请求。</p><p>（6）使用 CORS 的方式，CORS 是一个 W3C 标准，全称是”跨域资源共享”。CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，因此我们只需要在服务器端配置就行。浏览器将 CORS 请求分成两类：简单请求和非简单请求。对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是会在头信息之中，增加一个 Origin 字段。Origin 字段用来说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。对于如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，ajax 不会收到响应信息。如果成功的话会包含一些以 Access-Control- 开头的字段。</p><p>非简单请求，浏览器会先发出一次预检请求，来判断该域名是否在服务器的白名单中，如果收到肯定回复后才会发起请求。</p><p>（7）使用 websocket 协议，这个协议没有同源限制。</p><p>（8）使用服务器来代理跨域的访问请求，就是有跨域的请求操作时发送请求给后端，让后端代为请求，然后最后将获取的结果发返回。</p><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000011145364" target="_blank" rel="noopener">《前端常见跨域解决方案（全）》</a><br><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">《浏览器同源政策及其规避方法》</a><br><a href="https://juejin.im/entry/59feae9df265da43094488f6" target="_blank" rel="noopener">《跨域，你需要知道的全在这里》</a><br><a href="https://www.zhihu.com/question/31592553" target="_blank" rel="noopener">《为什么 form 表单提交没有跨域问题，但 ajax 提交有跨域问题？》</a></p><h3 id="服务器代理转发时，该如何处理-cookie？"><a href="#服务器代理转发时，该如何处理-cookie？" class="headerlink" title="服务器代理转发时，该如何处理 cookie？"></a>服务器代理转发时，该如何处理 cookie？</h3><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/5eab0f83e3b4" target="_blank" rel="noopener">《深入浅出 Nginx》</a></p><h3 id="模块化开发怎么做？"><a href="#模块化开发怎么做？" class="headerlink" title="模块化开发怎么做？"></a>模块化开发怎么做？</h3><p>我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，js 只实现一些简单的功能，所以并没有模块的概念，但随着程序越来越复杂，代码的模块化开发变得越来越重要。</p><p>由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污染，并且模块间没有联系。</p><p>后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所有的所有的模块成员，外部代码可以修改内部属性的值。</p><p>现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。</p><p>详细资料可以参考：<br><a href="https://juejin.im/post/5ab378c46fb9a028ce7b824f" target="_blank" rel="noopener">《浅谈模块化开发》</a><br><a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank" rel="noopener">《Javascript 模块化编程（一）：模块的写法》</a><br><a href="https://juejin.im/post/5aaa37c8f265da23945f365c" target="_blank" rel="noopener">《前端模块化：CommonJS，AMD，CMD，ES6》</a><br><a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">《Module 的语法》</a></p><h3 id="js-的几种模块规范？"><a href="#js-的几种模块规范？" class="headerlink" title="js 的几种模块规范？"></a>js 的几种模块规范？</h3><p>js 中现在比较成熟的有四种模块加载方案。</p><p>第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。</p><p>第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。</p><p>第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和 require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。参考60</p><p>第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。这种方案和上面三种方案都不同。参考 61。</p><h3 id="AMD-和-CMD-规范的区别？"><a href="#AMD-和-CMD-规范的区别？" class="headerlink" title="AMD 和 CMD 规范的区别？"></a>AMD 和 CMD 规范的区别？</h3><p>它们之间的主要区别有两个方面。</p><p>（1）第一个方面是在模块定义时对依赖的处理不同。AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。</p><p>（2）第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CMD</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">"./a"</span>);</span><br><span class="line">  a.doSomething();</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">"./b"</span>); <span class="comment">// 依赖可以就近书写</span></span><br><span class="line">  b.doSomething();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// AMD 默认推荐</span></span><br><span class="line">define([<span class="string">"./a"</span>, <span class="string">"./b"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 依赖必须一开始就写好</span></span><br><span class="line">  a.doSomething();</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  b.doSomething();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5a422b036fb9a045211ef789" target="_blank" rel="noopener">《前端模块化，AMD 与 CMD 的区别》</a></p><h3 id="ES6-模块与-CommonJS-模块、AMD、CMD-的差异。"><a href="#ES6-模块与-CommonJS-模块、AMD、CMD-的差异。" class="headerlink" title="ES6 模块与 CommonJS 模块、AMD、CMD 的差异。"></a>ES6 模块与 CommonJS 模块、AMD、CMD 的差异。</h3><p>1.CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</p><p>2.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p><h3 id="requireJS-的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何-缓存的？）"><a href="#requireJS-的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何-缓存的？）" class="headerlink" title="requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）"></a>requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）</h3><p>require.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。</p><p>详细资料可以参考：<br><a href="https://github.com/HRFE/blog/issues/10" target="_blank" rel="noopener">《requireJS 的用法和原理分析》</a><br><a href="https://zhuanlan.zhihu.com/p/55039478" target="_blank" rel="noopener">《requireJS 的核心原理是什么？》</a><br><a href="https://www.cnblogs.com/dong-xu/p/7160919.html" target="_blank" rel="noopener">《从 RequireJs 源码剖析脚本加载原理》</a><br><a href="https://www.jianshu.com/p/5a39535909e4" target="_blank" rel="noopener">《requireJS 原理分析》</a></p><h3 id="JS-模块加载器的轮子怎么造，也就是如何实现一个模块加载器？"><a href="#JS-模块加载器的轮子怎么造，也就是如何实现一个模块加载器？" class="headerlink" title="JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？"></a>JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？</h3><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/21157540" target="_blank" rel="noopener">《JS 模块加载器加载原理是怎么样的？》</a></p><h3 id="ECMAScript6-怎么写-class，为什么会出现-class-这种东西"><a href="#ECMAScript6-怎么写-class，为什么会出现-class-这种东西" class="headerlink" title="ECMAScript6 怎么写 class，为什么会出现 class 这种东西?"></a>ECMAScript6 怎么写 class，为什么会出现 class 这种东西?</h3><p>在我看来 ES6 新添加的 class 只是为了补充 js 中缺少的一些面向对象语言的特性，但本质上来说它只是一种语法糖，不是一个新的东西，其背后还是原型继承的思想。通过加入 class 可以有利于我们更好的组织代码。</p><p>在 class 中添加的方法，其实是添加在类的原型上的。</p><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/29789315" target="_blank" rel="noopener">《ECMAScript 6 实现了 class，对 JavaScript 前端开发有什么意义？》</a><br><a href="http://es6.ruanyifeng.com/#docs/class" target="_blank" rel="noopener">《Class 的基本语法》</a></p><h3 id="documen-write-和-innerHTML-的区别？"><a href="#documen-write-和-innerHTML-的区别？" class="headerlink" title="documen.write 和 innerHTML 的区别？"></a>documen.write 和 innerHTML 的区别？</h3><p>document.write 的内容会代替整个文档内容，会重写整个页面。</p><p>innerHTML 的内容只是替代指定元素的内容，只会重写页面中的部分内容。</p><p>详细资料可以参考：<br><a href="https://www.nowcoder.com/questionTerminal/2c5d8105b2694d85b06eff85e871cf50" target="_blank" rel="noopener">《简述 document.write 和 innerHTML 的区别。》</a></p><h3 id="DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？"><a href="#DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？" class="headerlink" title="DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？"></a>DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</h3><p>（1）创建新节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">createDocumentFragment(node);</span><br><span class="line">createElement(node);</span><br><span class="line">createTextNode(text);</span><br></pre></td></tr></table></figure><p>（2）添加、移除、替换、插入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">appendChild(node)</span><br><span class="line">removeChild(node)</span><br><span class="line">replaceChild(<span class="keyword">new</span>,old)</span><br><span class="line">insertBefore(<span class="keyword">new</span>,old)</span><br></pre></td></tr></table></figure><p>（3）查找</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getElementById();</span><br><span class="line">getElementsByName();</span><br><span class="line">getElementsByTagName();</span><br><span class="line">getElementsByClassName();</span><br><span class="line">querySelector();</span><br><span class="line">querySelectorAll();</span><br></pre></td></tr></table></figure><p>（4）属性操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getAttribute(key);</span><br><span class="line">setAttribute(key, value);</span><br><span class="line">hasAttribute(key);</span><br><span class="line">removeAttribute(key);</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Introduction#DOM_interfaces" target="_blank" rel="noopener">《DOM 概述》</a><br><a href="https://harttle.land/2015/10/01/javascript-dom-api.html" target="_blank" rel="noopener">《原生 JavaScript 的 DOM 操作汇总》</a><br><a href="https://microzz.com/2017/04/06/jsdom/" target="_blank" rel="noopener">《原生 JS 中 DOM 节点相关 API 合集》</a></p><h3 id="innerHTML-与-outerHTML-的区别？"><a href="#innerHTML-与-outerHTML-的区别？" class="headerlink" title="innerHTML 与 outerHTML 的区别？"></a>innerHTML 与 outerHTML 的区别？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对于这样一个 HTML 元素：&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;。</span><br><span class="line"></span><br><span class="line">innerHTML：内部 HTML，content&lt;br/&gt;；</span><br><span class="line">outerHTML：外部 HTML，&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;；</span><br><span class="line">innerText：内部文本，content ；</span><br><span class="line">outerText：内部文本，content ；</span><br></pre></td></tr></table></figure><h3 id="call-和-apply-的区别？"><a href="#call-和-apply-的区别？" class="headerlink" title=".call() 和 .apply() 的区别？"></a>.call() 和 .apply() 的区别？</h3><p>它们的作用一模一样，区别仅在于传入参数的形式的不同。</p><p>apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。</p><p>call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</p><p>详细资料可以参考：<br><a href="https://juejin.im/entry/58d0a7b22f301e007e5a15ae" target="_blank" rel="noopener">《apply、call 的区别和用途》</a></p><h3 id="JavaScript-类数组对象的定义？"><a href="#JavaScript-类数组对象的定义？" class="headerlink" title="JavaScript 类数组对象的定义？"></a>JavaScript 类数组对象的定义？</h3><p>一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。</p><p>常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length属性值，代表可接收的参数个数。</p><p>常见的类数组转换为数组的方法有这样几种：</p><p>（1）通过 call 调用数组的 slice 方法来实现转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.call(arrayLike);</span><br></pre></td></tr></table></figure><p>（2）通过 call 调用数组的 splice 方法来实现转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.splice.call(arrayLike, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>（3）通过 apply 调用数组的 concat 方法来实现转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.concat.apply([], arrayLike);</span><br></pre></td></tr></table></figure><p>（4）通过 Array.from 方法来实现转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike);</span><br></pre></td></tr></table></figure><p>详细的资料可以参考：<br><a href="https://github.com/mqyqingfeng/Blog/issues/14" target="_blank" rel="noopener">《JavaScript 深入之类数组对象与 arguments》</a><br><a href="https://segmentfault.com/a/1190000000415572" target="_blank" rel="noopener">《javascript 类数组》</a><br><a href="https://blog.lxxyx.cn/2016/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E7%B1%BB%E6%95%B0%E7%BB%84/" target="_blank" rel="noopener">《深入理解 JavaScript 类数组》</a></p><h3 id="数组和对象有哪些原生方法，列举一下？"><a href="#数组和对象有哪些原生方法，列举一下？" class="headerlink" title="数组和对象有哪些原生方法，列举一下？"></a>数组和对象有哪些原生方法，列举一下？</h3><p>数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。</p><p>数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。</p><p>数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</p><p>数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。</p><p>数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。</p><p>数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法</p><p>数组归并方法 reduce() 和 reduceRight() 方法</p><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8BArray%E8%AF%A6%E8%A7%A3.html" target="_blank" rel="noopener">《JavaScript 深入理解之 Array 类型详解》</a></p><h3 id="数组的-fill-方法？"><a href="#数组的-fill-方法？" class="headerlink" title="数组的 fill 方法？"></a>数组的 fill 方法？</h3><p>fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。<br>fill 方法接受三个参数 value，start 以及 end，start 和 end 参数是可选的，其默认值分别为 0 和 this 对象的 length 属性值。</p><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill" target="_blank" rel="noopener">《Array.prototype.fill()》</a></p><h3 id="的长度？"><a href="#的长度？" class="headerlink" title="[,,,] 的长度？"></a>[,,,] 的长度？</h3><p>尾后逗号 （有时叫做“终止逗号”）在向 JavaScript 代码添加元素、参数、属性时十分有用。如果你想要添加新的属性，并且上一行已经使用了尾后逗号，你可以仅仅添加新的一行，而不需要修改上一行。这使得版本控制更加清晰，以及代码维护麻烦更少。</p><p>JavaScript 一开始就支持数组字面值中的尾后逗号，随后向对象字面值（ECMAScript 5）中添加了尾后逗号。最近（ECMAScript 2017），又将其添加到函数参数中。但是 JSON 不支持尾后逗号。</p><p>如果使用了多于一个尾后逗号，会产生间隙。 带有间隙的数组叫做稀疏数组（密致数组没有间隙）。稀疏数组的长度为逗号的数量。</p><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Trailing_commas" target="_blank" rel="noopener">《尾后逗号》</a></p><h3 id="JavaScript-中的作用域与变量声明提升？"><a href="#JavaScript-中的作用域与变量声明提升？" class="headerlink" title="JavaScript 中的作用域与变量声明提升？"></a>JavaScript 中的作用域与变量声明提升？</h3><p>变量提升的表现是，无论我们在函数中何处位置声明的变量，好像都被提升到了函数的首部，我们可以在变量声明前访问到而不会报错。</p><p>造成变量声明提升的本质原因是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当我们访问一个变量时，我们会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。这就是会出现变量声明提升的根本原因。</p><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1.html" target="_blank" rel="noopener">《JavaScript 深入理解之变量对象》</a></p><h3 id="如何编写高性能的-Javascript-？"><a href="#如何编写高性能的-Javascript-？" class="headerlink" title="如何编写高性能的 Javascript ？"></a>如何编写高性能的 Javascript ？</h3><p>1.使用位运算代替一些简单的四则运算。</p><p>2.避免使用过深的嵌套循环。</p><p>3.不要使用未定义的变量。</p><p>4.当需要多次访问数组长度时，可以用变量保存起来，避免每次都会去进行属性查找。</p><p>详细资料可以参考：<br><a href="https://zhuanlan.zhihu.com/p/34780474" target="_blank" rel="noopener">《如何编写高性能的 Javascript？》</a></p><h3 id="简单介绍一下-V8-引擎的垃圾回收机制"><a href="#简单介绍一下-V8-引擎的垃圾回收机制" class="headerlink" title="简单介绍一下 V8 引擎的垃圾回收机制"></a>简单介绍一下 V8 引擎的垃圾回收机制</h3><p>v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。</p><p>新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。</p><p>新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：</p><p>（1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。</p><p>（2）如果对象不存活，则释放对象的空间。</p><p>（3）最后将 From 空间和 To 空间角色进行交换。</p><p>新生代对象晋升到老生代有两个条件：</p><p>（1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。</p><p>（2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。</p><p>老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。</p><p>由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。</p><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/b8ed21e8a4fb" target="_blank" rel="noopener">《深入理解 V8 的垃圾回收原理》</a><br><a href="https://zhuanlan.zhihu.com/p/23992332" target="_blank" rel="noopener">《JavaScript 中的垃圾回收》</a></p><h3 id="哪些操作会造成内存泄漏？"><a href="#哪些操作会造成内存泄漏？" class="headerlink" title="哪些操作会造成内存泄漏？"></a>哪些操作会造成内存泄漏？</h3><p>相关知识点：</p><p>1.意外的全局变量</p><p>2.被遗忘的计时器或回调函数</p><p>3.脱离 DOM 的引用</p><p>4.闭包</p><p>回答：</p><p>第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</p><p>第二种情况是我们设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</p><p>第三种情况是我们获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。</p><p>第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</p><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html" target="_blank" rel="noopener">《JavaScript 内存泄漏教程》</a><br><a href="https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/" target="_blank" rel="noopener">《4 类 JavaScript 内存泄漏及如何避免》</a><br><a href="https://juejin.im/entry/5a64366c6fb9a01c9332c706" target="_blank" rel="noopener">《杜绝 js 中四种内存泄漏类型的发生》</a><br><a href="https://segmentfault.com/a/1190000008901861" target="_blank" rel="noopener">《javascript 典型内存泄漏及 chrome 的排查方法》</a></p><h3 id="如何做到修改url参数页面不刷新"><a href="#如何做到修改url参数页面不刷新" class="headerlink" title="如何做到修改url参数页面不刷新"></a>如何做到修改url参数页面不刷新</h3><p>HTML5引入了 <code>history.pushState()</code> 和 <code>history.replaceState()</code> 方法，它们分别可以添加和修改历史记录条目。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stateObj = &#123;</span><br><span class="line">    foo: <span class="string">"bar"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">history.pushState(stateObj, <span class="string">"page 2"</span>, <span class="string">"bar.html"</span>);</span><br></pre></td></tr></table></figure><p>假设当前页面为 <code>foo.html</code>，执行上述代码后会变为 <code>bar.html</code>，点击浏览器后退，会变为 <code>foo.html</code>，但浏览器并不会刷新。<br><code>pushState()</code> 需要三个参数: 一个状态对象, 一个标题 (目前被忽略), 和 (可选的) 一个 URL. 让我们来解释下这三个参数详细内容：</p><ul><li>状态对象 — 状态对象 <code>state</code> 是一个 JavaScript 对象，通过 <code>pushState ()</code> 创建新的历史记录条目。无论什么时候用户导航到新的状态，<code>popstate</code> 事件就会被触发，且该事件的 <code>state</code> 属性包含该历史记录条目状态对象的副本。<br>状态对象可以是能被序列化的任何东西。原因在于 Firefox 将状态对象保存在用户的磁盘上，以便在用户重启浏览器时使用，我们规定了状态对象在序列化表示后有640k的大小限制。如果你给 <code>pushState()</code> 方法传了一个序列化后大于 640k 的状态对象，该方法会抛出异常。如果你需要更大的空间，建议使用 <code>sessionStorage</code> 以及 <code>localStorage</code>.</li><li>标题 — Firefox 目前忽略这个参数，但未来可能会用到。传递一个空字符串在这里是安全的，而在将来这是不安全的。二选一的话，你可以为跳转的 <code>state</code> 传递一个短标题。</li><li>URL — 该参数定义了新的历史URL记录。注意，调用 <code>pushState()</code> 后浏览器并不会立即加载这个 URL，但可能会在稍后某些情况下加载这个 URL，比如在用户重新打开浏览器时。新URL不必须为绝对路径。如果新URL是相对路径，那么它将被作为相对于当前 URL 处理。新 URL 必须与当前URL同源，否则 <code>pushState()</code> 会抛出一个异常。该参数是可选的，缺省为当前 URL。</li></ul><h3 id="需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？"><a href="#需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？" class="headerlink" title="需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？"></a>需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？</h3><p>通过使用 pushState + ajax 实现浏览器无刷新前进后退，当一次 ajax 调用成功后我们将一条 state 记录加入到 history对象中。一条 state 记录包含了 url、title 和 content 属性，在 popstate 事件中可以获取到这个 state 对象，我们可以使用 content 来传递数据。最后我们通过对 window.onpopstate 事件监听来响应浏览器的前进后退操作。</p><p>使用 pushState 来实现有两个问题，一个是打开首页时没有记录，我们可以使用 replaceState 来将首页的记录替换，另一个问题是当一个页面刷新的时候，仍然会向服务器端请求数据，因此如果请求的 url 需要后端的配合将其重定向到一个页面。</p><p>详细资料可以参考：<br><a href="http://blog.chenxu.me/post/detail?id=ed4f0732-897f-48e4-9d4f-821e82f17fad" target="_blank" rel="noopener">《pushState + ajax 实现浏览器无刷新前进后退》</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History_API" target="_blank" rel="noopener">《Manipulating the browser history》</a></p><h3 id="如何判断当前脚本运行在浏览器还是-node-环境中？（阿里）"><a href="#如何判断当前脚本运行在浏览器还是-node-环境中？（阿里）" class="headerlink" title="如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）"></a>如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeof window === &apos;undefined&apos; ? &apos;node&apos; : &apos;browser&apos;;</span><br><span class="line"></span><br><span class="line">通过判断当前环境的 window 对象类型是否为 undefined，如果是undefined，则说明当前脚本运行在node环境，否则说明运行在window环境。</span><br></pre></td></tr></table></figure><h3 id="把-script-标签放在页面的最底部的-body-封闭之前和封闭之后有什么区别？浏览器会如何解析它们？"><a href="#把-script-标签放在页面的最底部的-body-封闭之前和封闭之后有什么区别？浏览器会如何解析它们？" class="headerlink" title="把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？"></a>把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？</h3><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/20027966" target="_blank" rel="noopener">《为什么把 script 标签放在 body 结束标签之后 html 结束标签之前？》</a><br><a href="https://zhuanlan.zhihu.com/p/30558018" target="_blank" rel="noopener">《从 Chrome 源码看浏览器如何加载资源》</a></p><h3 id="移动端的点击事件的有延迟，时间是多久，为什么会有？-怎么解决这个延时？"><a href="#移动端的点击事件的有延迟，时间是多久，为什么会有？-怎么解决这个延时？" class="headerlink" title="移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？"></a>移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？</h3><p>移动端点击有 300ms 的延迟是因为移动端会有双击缩放的这个操作，因此浏览器在 click 之后要等待 300ms，看用户有没有下一次点击，来判断这次操作是不是双击。</p><p>有三种办法来解决这个问题：</p><ul><li>1.通过 meta 标签禁用网页的缩放。</li><li>2.通过 meta 标签将网页的 viewport 设置为 ideal viewport。</li><li>3.调用一些 js 库，比如 FastClick</li></ul><p>click 延时问题还可能引起点击穿透的问题，就是如果我们在一个元素上注册了 touchStart 的监听事件，这个事件会将这个元素隐藏掉，我们发现当这个元素隐藏后，触发了这个元素下的一个元素的点击事件，这就是点击穿透。</p><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b3cc9836fb9a04f9a5cb0e0" target="_blank" rel="noopener">《移动端 300ms 点击延迟和点击穿透》</a></p><h3 id="什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？"><a href="#什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？" class="headerlink" title="什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？"></a>什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？</h3><p>（1）什么是前端路由？</p><p>前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前是通过服务端根据 url 的不同返回不同的页面实现的。</p><p>（2）什么时候使用前端路由？</p><p>在单页面应用，大部分页面结构不变，只改变部分内容的使用</p><p>（3）前端路由有什么优点和缺点？</p><p>优点：用户体验好，不需要每次都从服务器全部获取，快速展现给用户</p><p>缺点：单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置</p><p>前端路由一共有两种实现方式，一种是通过 hash 的方式，一种是通过使用 pushState 的方式。</p><p>详细资料可以参考：<br><a href="https://segmentfault.com/q/1010000005336260" target="_blank" rel="noopener">《什么是“前端路由”》</a><br><a href="https://github.com/kaola-fed/blog/issues/137" target="_blank" rel="noopener">《浅谈前端路由》 </a><br><a href="https://www.zhihu.com/question/53064386" target="_blank" rel="noopener">《前端路由是什么东西？》</a></p><h3 id="如何测试前端代码么？-知道-BDD-TDD-Unit-Test-么？-知道怎么测试你的前端工程么-mocha-sinon-jasmin-qUnit-？"><a href="#如何测试前端代码么？-知道-BDD-TDD-Unit-Test-么？-知道怎么测试你的前端工程么-mocha-sinon-jasmin-qUnit-？" class="headerlink" title="如何测试前端代码么？ 知道 BDD, TDD, Unit Test 么？ 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)？"></a>如何测试前端代码么？ 知道 BDD, TDD, Unit Test 么？ 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)？</h3><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b2da89cf265da597f1c7cab" target="_blank" rel="noopener">《浅谈前端单元测试》</a></p><h3 id="检测浏览器版本版本有哪些方式？"><a href="#检测浏览器版本版本有哪些方式？" class="headerlink" title="检测浏览器版本版本有哪些方式？"></a>检测浏览器版本版本有哪些方式？</h3><p>检测浏览器版本一共有两种方式：</p><p>一种是检测 window.navigator.userAgent 的值，但这种方式很不可靠，因为 userAgent 可以被改写，并且早期的浏览器如 ie，会通过伪装自己的 userAgent 的值为 Mozilla 来躲过服务器的检测。</p><p>第二种方式是功能检测，根据每个浏览器独有的特性来进行判断，如 ie 下独有的 ActiveXObject。</p><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/d99f4ca385ac" target="_blank" rel="noopener">《JavaScript 判断浏览器类型》</a></p><h3 id="什么是-Polyfill-？"><a href="#什么是-Polyfill-？" class="headerlink" title="什么是 Polyfill ？"></a>什么是 Polyfill ？</h3><p>Polyfill 指的是用于实现浏览器并不支持的原生 API 的代码。</p><p>比如说 querySelectorAll 是很多现代浏览器都支持的原生 Web API，但是有些古老的浏览器并不支持，那么假设有人写了一段代码来实现这个功能使这些浏览器也支持了这个功能，那么这就可以成为一个 Polyfill。</p><p>一个 shim 是一个库，有自己的 API，而不是单纯实现原生不支持的 API。</p><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000002593432" target="_blank" rel="noopener">《Web 开发中的“黑话”》</a><br><a href="https://juejin.im/post/5a579bc7f265da3e38496ba1" target="_blank" rel="noopener">《Polyfill 为何物》</a></p><h3 id="使用-JS-实现获取文件扩展名？"><a href="#使用-JS-实现获取文件扩展名？" class="headerlink" title="使用 JS 实现获取文件扩展名？"></a>使用 JS 实现获取文件扩展名？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String.lastIndexOf() 方法返回指定值（本例中的'.'）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于 'filename' 和 '.hiddenfile' ，lastIndexOf 的返回值分别为 0 和 -1 无符号右移操作符(&gt;&gt;&gt;) 将 -1 转换为 4294967295 ，将 -2 转换为 4294967294 ，这个方法可以保证边缘情况时文件名不变。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为""。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFileExtension</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> filename.slice(((filename.lastIndexOf(<span class="string">"."</span>) - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">0</span>) + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000004993946" target="_blank" rel="noopener">《如何更有效的获取文件扩展名》</a></p><h3 id="介绍一下-js-的节流与防抖？"><a href="#介绍一下-js-的节流与防抖？" class="headerlink" title="介绍一下 js 的节流与防抖？"></a>介绍一下 js 的节流与防抖？</h3><p>函数防抖： 在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。</p><p>函数节流： 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数防抖的实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span>,</span><br><span class="line">      args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果此时存在定时器的话，则取消之前的定时器重新记时</span></span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置定时器，使事件间隔指定事件后执行</span></span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数节流的实现;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> preTime = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span>,</span><br><span class="line">      args = <span class="built_in">arguments</span>,</span><br><span class="line">      nowTime = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果两次时间间隔超过了指定时间，则执行函数。</span></span><br><span class="line">    <span class="keyword">if</span> (nowTime - preTime &gt;= delay) &#123;</span><br><span class="line">      preTime = <span class="built_in">Date</span>.now();</span><br><span class="line">      <span class="keyword">return</span> fn.apply(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回答：</p><p>函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</p><p>函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</p><p>详细资料可以参考：<br><a href="https://juejin.im/post/5a35ed25f265da431d3cc1b1" target="_blank" rel="noopener">《轻松理解 JS 函数节流和函数防抖》</a><br><a href="https://juejin.im/post/5aa60b0e518825556b6c6d1a" target="_blank" rel="noopener">《JavaScript 事件节流和事件防抖》</a><br><a href="https://juejin.im/entry/5b1d2d54f265da6e2545bfa4" target="_blank" rel="noopener">《JS 的防抖与节流》</a></p><h3 id="Object-is-与原来的比较操作符-“-”、“-”-的区别？"><a href="#Object-is-与原来的比较操作符-“-”、“-”-的区别？" class="headerlink" title="Object.is() 与原来的比较操作符 “===”、“==” 的区别？"></a>Object.is() 与原来的比较操作符 “===”、“==” 的区别？</h3><p>相关知识点：</p><p>两等号判等，会在比较时进行类型转换。<br>三等号判等（判断严格），比较时不进行隐式类型转换，（类型不同则会返回false）。</p><p>Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 Object.is(NaN, NaN) 会返回 true.</p><p>Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。</p><p>回答：</p><p>使用双等号进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。</p><p>使用三等号进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。</p><p>使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 认定为是相等的。</p><h3 id="escape-encodeURI-encodeURIComponent-有什么区别？"><a href="#escape-encodeURI-encodeURIComponent-有什么区别？" class="headerlink" title="escape,encodeURI,encodeURIComponent 有什么区别？"></a>escape,encodeURI,encodeURIComponent 有什么区别？</h3><p>相关知识点：</p><p>escape 和 encodeURI 都属于 Percent-encoding，基本功能都是把 URI 非法字符转化成合法字符，转化后形式类似「%*」。<br>它们的根本区别在于，escape 在处理 0xff 之外字符的时候，是直接使用字符的 unicode 在前面加上一个「%u」，而 encode URI 则是先进行 UTF-8，再在 UTF-8 的每个字节码前加上一个「%」；在处理 0xff 以内字符时，编码方式是一样的（都是「%XX」，XX 为字符的 16 进制 unicode，同时也是字符的 UTF-8），只是范围（即哪些字符编码哪些字符不编码）不一样。</p><p>回答：</p><p>encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。</p><p>encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。</p><p>escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。</p><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/21861899" target="_blank" rel="noopener">《escape,encodeURI,encodeURIComponent 有什么区别?》</a></p><h3 id="Unicode-和-UTF-8-之间的关系？"><a href="#Unicode-和-UTF-8-之间的关系？" class="headerlink" title="Unicode 和 UTF-8 之间的关系？"></a>Unicode 和 UTF-8 之间的关系？</h3><p>Unicode 是一种字符集合，现在可容纳 100 多万个字符。每个字符对应一个不同的 Unicode 编码，它只规定了符号的二进制代码，却没有规定这个二进制代码在计算机中如何编码传输。</p><p>UTF-8 是一种对 Unicode 的编码方式，它是一种变长的编码方式，可以用 1~4 个字节来表示一个字符。</p><p>详细资料可以参考：<br><a href="https://blog.51cto.com/polaris/377468" target="_blank" rel="noopener">《字符编码详解》</a><br><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">《字符编码笔记：ASCII，Unicode 和 UTF-8》</a></p><h3 id="js-中的深浅拷贝实现？"><a href="#js-中的深浅拷贝实现？" class="headerlink" title="js 中的深浅拷贝实现？"></a>js 中的深浅拷贝实现？</h3><p>相关资料：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝的实现;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 只拷贝对象</span></span><br><span class="line">  <span class="keyword">if</span> (!object || <span class="keyword">typeof</span> object !== <span class="string">"object"</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据 object 的类型判断是新建一个数组还是对象</span></span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="built_in">Array</span>.isArray(object) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历 object，并且判断是 object 的属性才拷贝</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObject[key] = object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深拷贝的实现;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!object || <span class="keyword">typeof</span> object !== <span class="string">"object"</span>) <span class="keyword">return</span> object;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="built_in">Array</span>.isArray(object) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObject[key] = deepCopy(object[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回答：</p><p>浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用  Object.assign 和展开运算符来实现。</p><p>深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败。</p><p>详细资料可以参考：<br><a href="https://github.com/mqyqingfeng/Blog/issues/32" target="_blank" rel="noopener">《JavaScript 专题之深浅拷贝》</a><br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bed40d951882545f73004f6" target="_blank" rel="noopener">《前端面试之道》</a></p><h3 id="手写-call、apply-及-bind-函数"><a href="#手写-call、apply-及-bind-函数" class="headerlink" title="手写 call、apply 及 bind 函数"></a>手写 call、apply 及 bind 函数</h3><p>相关资料：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call函数实现</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断调用对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"type error"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>),</span><br><span class="line">    result = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 context 是否传入，如果未传入则设置为 window</span></span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将调用函数设为对象的方法</span></span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用函数</span></span><br><span class="line">  result = context.fn(...args);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// apply 函数实现</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Error"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 context 是否存在，如果未传入则为 window</span></span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将函数设为对象的方法</span></span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context.fn(...arguments[<span class="number">1</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.fn();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bind 函数实现</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Error"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>),</span><br><span class="line">    fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 根据调用方式，传入不同绑定值</span></span><br><span class="line">    <span class="keyword">return</span> fn.apply(</span><br><span class="line">      <span class="keyword">this</span> <span class="keyword">instanceof</span> Fn ? <span class="keyword">this</span> : context,</span><br><span class="line">      args.concat(...arguments)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>回答：</p><h4 id="call-函数的实现步骤："><a href="#call-函数的实现步骤：" class="headerlink" title="call 函数的实现步骤："></a>call 函数的实现步骤：</h4><p>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</p><p>2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。</p><p>3.处理传入的参数，截取第一个参数后的所有参数。</p><p>4.将函数作为上下文对象的一个属性。</p><p>5.使用上下文对象来调用这个方法，并保存返回结果。</p><p>6.删除刚才新增的属性。</p><p>7.返回结果。</p><h4 id="apply-函数的实现步骤："><a href="#apply-函数的实现步骤：" class="headerlink" title="apply 函数的实现步骤："></a>apply 函数的实现步骤：</h4><p>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</p><p>2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。</p><p>3.将函数作为上下文对象的一个属性。</p><p>4.判断参数值是否传入</p><p>4.使用上下文对象来调用这个方法，并保存返回结果。</p><p>5.删除刚才新增的属性</p><p>6.返回结果</p><h4 id="bind-函数的实现步骤："><a href="#bind-函数的实现步骤：" class="headerlink" title="bind 函数的实现步骤："></a>bind 函数的实现步骤：</h4><p>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</p><p>2.保存当前函数的引用，获取其余传入参数值。</p><p>3.创建一个函数返回</p><p>4.函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</p><p>详细资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdd0d8e6fb9a04a044073fe" target="_blank" rel="noopener">《手写 call、apply 及 bind 函数》</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/11" target="_blank" rel="noopener">《JavaScript 深入之 call 和 apply 的模拟实现》</a></p><h3 id="函数柯里化的实现"><a href="#函数柯里化的实现" class="headerlink" title="函数柯里化的实现"></a>函数柯里化的实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取函数需要的参数长度</span></span><br><span class="line">  <span class="keyword">let</span> length = fn.length;</span><br><span class="line"></span><br><span class="line">  args = args || [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> subArgs = args.slice(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接得到现有的所有参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">      subArgs.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断参数的长度是否已经满足函数所需参数的长度</span></span><br><span class="line">    <span class="keyword">if</span> (subArgs.length &gt;= length) &#123;</span><br><span class="line">      <span class="comment">// 如果满足，执行函数</span></span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, subArgs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果不满足，递归返回科里化的函数，等待参数的传入</span></span><br><span class="line">      <span class="keyword">return</span> curry.call(<span class="keyword">this</span>, fn, subArgs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6 实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fn.length &lt;= args.length ? fn(...args) : curry.bind(<span class="literal">null</span>, fn, ...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://github.com/mqyqingfeng/Blog/issues/42" target="_blank" rel="noopener">《JavaScript 专题之函数柯里化》</a></p><h3 id="为什么-0-1-0-2-0-3？如何解决这个问题？"><a href="#为什么-0-1-0-2-0-3？如何解决这个问题？" class="headerlink" title="为什么 0.1 + 0.2 != 0.3？如何解决这个问题？"></a>为什么 0.1 + 0.2 != 0.3？如何解决这个问题？</h3><p>当计算机计算 0.1+0.2 的时候，实际上计算的是这两个数字在计算机里所存储的二进制，0.1 和 0.2 在转换为二进制表示的时候会出现位数无限循环的情况。js 中是以 64 位双精度格式来存储数字的，只有 53 位的有效数字，超过这个长度的位数会被截取掉这样就造成了精度丢失的问题。这是第一个会造成精度丢失的地方。在对两个以 64 位双精度格式的数据进行计算的时候，首先会进行对阶的处理，对阶指的是将阶码对齐，也就是将小数点的位置对齐后，再进行计算，一般是小阶向大阶对齐，因此小阶的数在对齐的过程中，有效数字会向右移动，移动后超过有效位数的位会被截取掉，这是第二个可能会出现精度丢失的地方。当两个数据阶码对齐后，进行相加运算后，得到的结果可能会超过 53 位有效数字，因此超过的位数也会被截取掉，这是可能发生精度丢失的第三个地方。</p><p>对于这样的情况，我们可以将其转换为整数后再进行运算，运算后再转换为对应的小数，以这种方式来解决这个问题。</p><p>我们还可以将两个数相加的结果和右边相减，如果相减的结果小于一个极小数，那么我们就可以认定结果是相等的，这个极小数可以使用 es6 的 Number.EPSILON</p><p>详细资料可以参考：<br><a href="https://blog.csdn.net/Lixuanshengchao/article/details/82049191" target="_blank" rel="noopener">《十进制的 0.1 为什么不能用二进制很好的表示？》</a><br><a href="https://blog.csdn.net/zhengyanan815/article/details/78550073" target="_blank" rel="noopener">《十进制浮点数转成二进制》</a><br><a href="http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html" target="_blank" rel="noopener">《浮点数的二进制表示》</a><br><a href="https://juejin.im/post/5b372f106fb9a00e6714aa21" target="_blank" rel="noopener">《js 浮点数存储精度丢失原理》</a><br><a href="https://juejin.im/post/594a31d0a0bb9f006b0b2624" target="_blank" rel="noopener">《浮点数精度之谜》</a><br><a href="https://github.com/camsong/blog/issues/9" target="_blank" rel="noopener">《JavaScript 浮点数陷阱及解法》</a><br><a href="https://juejin.im/post/5bd2f10a51882555e072d0c4" target="_blank" rel="noopener">《0.1+0.2 !== 0.3？》</a><br><a href="https://juejin.im/entry/59cdd7fb6fb9a00a600f8eef" target="_blank" rel="noopener">《JavaScript 中奇特的~运算符》</a></p><h3 id="原码、反码和补码的介绍"><a href="#原码、反码和补码的介绍" class="headerlink" title="原码、反码和补码的介绍"></a>原码、反码和补码的介绍</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">原码是计算机中对数字的二进制的定点表示方法，最高位表示符号位，其余位表示数值位。优点是易于分辨，缺点是不能够直接参与运算。</span><br><span class="line"></span><br><span class="line">正数的反码和其原码一样；负数的反码，符号位为1，数值部分按原码取反。</span><br><span class="line">如 [+7]原 = 00000111，[+7]反 = 00000111； [-7]原 = 10000111，[-7]反 = 11111000。</span><br><span class="line"></span><br><span class="line">正数的补码和其原码一样；负数的补码为其反码加1。</span><br><span class="line"></span><br><span class="line">例如 [+7]原 = 00000111，[+7]反 = 00000111，[+7]补 = 00000111；</span><br><span class="line">[-7]原 = 10000111，[-7]反 = 11111000，[-7]补 = 11111001</span><br><span class="line"></span><br><span class="line">之所以在计算机中使用补码来表示负数的原因是，这样可以将加法运算扩展到所有的数值计算上，因此在数字电路中我们只需要考虑加法器的设计就行了，而不用再为减法设置新的数字电路。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2009/08/twos_complement.html" target="_blank" rel="noopener">《关于 2 的补码》</a></p><h3 id="toPrecision-和-toFixed-和-Math-round-的区别？"><a href="#toPrecision-和-toFixed-和-Math-round-的区别？" class="headerlink" title="toPrecision 和 toFixed 和 Math.round 的区别？"></a>toPrecision 和 toFixed 和 Math.round 的区别？</h3><p>toPrecision 用于处理精度，精度是从左至右第一个不为 0 的数开始数起。<br>toFixed 是对小数点后指定位数取整，从小数点开始数起。<br>Math.round 是将一个数字四舍五入到一个整数。</p><h3 id="什么是-requestAnimationFrame-？"><a href="#什么是-requestAnimationFrame-？" class="headerlink" title="什么是 requestAnimationFrame ？"></a>什么是 requestAnimationFrame ？</h3><p>详细资料可以参考：<br><a href="https://juejin.im/post/5a82f0626fb9a06358657c9c" target="_blank" rel="noopener">《你需要知道的 requestAnimationFrame》</a><br><a href="https://www.zhangxinxu.com/wordpress/2013/09/css3-animation-requestanimationframe-tween-%E5%8A%A8%E7%94%BB%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">《CSS3 动画那么强，requestAnimationFrame 还有毛线用？》</a></p><h3 id="offsetWidth-offsetHeight-clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别？"><a href="#offsetWidth-offsetHeight-clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别？" class="headerlink" title="offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别？"></a>offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别？</h3><p>clientWidth/clientHeight 返回的是元素的内部宽度，它的值只包含 content + padding，如果有滚动条，不包含滚动条。<br>clientTop 返回的是上边框的宽度。<br>clientLeft 返回的左边框的宽度。</p><p>offsetWidth/offsetHeight 返回的是元素的布局宽度，它的值包含 content + padding + border 包含了滚动条。<br>offsetTop 返回的是当前元素相对于其 offsetParent 元素的顶部的距离。<br>offsetLeft 返回的是当前元素相对于其 offsetParent 元素的左部的距离。</p><p>scrollWidth/scrollHeight 返回值包含 content + padding + 溢出内容的尺寸。<br>scrollTop 属性返回的是一个元素的内容垂直滚动的像素数。<br>scrollLeft 属性返回的是元素滚动条到元素左边的距离。</p><p>详细资料可以参考：<br><a href="https://juejin.im/post/5bc9366d5188255c4834e75a" target="_blank" rel="noopener">《最全的获取元素宽高及位置的方法》</a><br><a href="http://www.ruanyifeng.com/blog/2009/09/find_element_s_position_using_javascript.html" target="_blank" rel="noopener">《用 Javascript 获取页面元素的位置》</a></p><h3 id="谈一谈你理解的函数式编程？"><a href="#谈一谈你理解的函数式编程？" class="headerlink" title="谈一谈你理解的函数式编程？"></a>谈一谈你理解的函数式编程？</h3><p>简单说，”函数式编程”是一种”编程范式”（programming paradigm），也就是如何编写程序的方法论。</p><p>它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是”第一等公民”、只用”表达式”。</p><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html" target="_blank" rel="noopener">《函数式编程初探》</a></p><h3 id="异步编程的实现方式？"><a href="#异步编程的实现方式？" class="headerlink" title="异步编程的实现方式？"></a>异步编程的实现方式？</h3><p>相关资料：</p><p>回调函数<br>优点：简单、容易理解<br>缺点：不利于维护，代码耦合高</p><p>事件监听（采用时间驱动模式，取决于某个事件是否发生）：<br>优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数<br>缺点：事件驱动型，流程不够清晰</p><p>发布/订阅（观察者模式）<br>类似于事件监听，但是可以通过‘消息中心’，了解现在有多少发布者，多少订阅者</p><p>Promise 对象<br>优点：可以利用 then 方法，进行链式写法；可以书写错误时的回调函数；<br>缺点：编写和理解，相对比较难</p><p>Generator 函数<br>优点：函数体内外的数据交换、错误处理机制<br>缺点：流程管理不方便</p><p>async 函数<br>优点：内置执行器、更好的语义、更广的适用性、返回的是 Promise、结构清晰。<br>缺点：错误处理机制</p><p>回答：</p><p>js 中的异步机制可以分为以下几种：</p><p>第一种最常见的是使用回调函数的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。</p><p>第二种是 Promise 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。</p><p>第三种是使用 generator 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部我们还可以将执行权转移回来。当我们遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕的时候我们再将执行权给转移回来。因此我们在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式我们需要考虑的问题是何时将函数的控制权转移回来，因此我们需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。</p><p>第四种是使用 async 函数的形式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此我们可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。</p><h3 id="Js-动画与-CSS-动画区别及相应实现"><a href="#Js-动画与-CSS-动画区别及相应实现" class="headerlink" title="Js 动画与 CSS 动画区别及相应实现"></a>Js 动画与 CSS 动画区别及相应实现</h3><p>CSS3 的动画的优点</p><p>在性能上会稍微好一些，浏览器会对 CSS3 的动画做一些优化<br>代码相对简单</p><p>缺点</p><p>在动画控制上不够灵活<br>兼容性不好</p><p>JavaScript 的动画正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容 IE6，并且功能强大。对于一些复杂控制的动画，使用 javascript 会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑 CSS 吧</p><h3 id="get-请求传参长度的误区"><a href="#get-请求传参长度的误区" class="headerlink" title="get 请求传参长度的误区"></a>get 请求传参长度的误区</h3><p>误区：我们经常说 get 请求参数的大小存在限制，而 post 请求的参数大小是无限制的。</p><p>实际上 HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对 get 请求参数的限制是来源与浏览器或web 服务器，浏览器或 web 服务器限制了 url 的长度。为了明确这个概念，我们必须再次强调下面几点:</p><p>1.HTTP 协议未规定 GET 和 POST 的长度限制</p><p>2.GET 的最大长度显示是因为浏览器和 web 服务器限制了 URI 的长度</p><p>3.不同的浏览器和 WEB 服务器，限制的最大长度不一样</p><p>4.要支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度 8182byte</p><h3 id="URL-和-URI-的区别？"><a href="#URL-和-URI-的区别？" class="headerlink" title="URL 和 URI 的区别？"></a>URL 和 URI 的区别？</h3><p>URI: Uniform Resource Identifier      指的是统一资源标识符<br>URL: Uniform Resource Location        指的是统一资源定位符<br>URN: Universal Resource Name          指的是统一资源名称</p><p>URI 指的是统一资源标识符，用唯一的标识来确定一个资源，它是一种抽象的定义，也就是说，不管使用什么方法来定义，只要能唯一的标识一个资源，就可以称为 URI。</p><p>URL 指的是统一资源定位符，URN 指的是统一资源名称。URL 和 URN 是 URI 的子集，URL 可以理解为使用地址来标识资源，URN 可以理解为使用名称来标识资源。</p><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/21950864" target="_blank" rel="noopener">《HTTP 协议中 URI 和 URL 有什么区别？》</a><br><a href="http://web.jobbole.com/83452/" target="_blank" rel="noopener">《你知道 URL、URI 和 URN 三者之间的区别吗？》</a><br><a href="https://segmentfault.com/a/1190000006081973" target="_blank" rel="noopener">《URI、URL 和 URN 的区别》</a></p><h3 id="get-和-post-请求在缓存方面的区别"><a href="#get-和-post-请求在缓存方面的区别" class="headerlink" title="get 和 post 请求在缓存方面的区别"></a>get 和 post 请求在缓存方面的区别</h3><p>相关知识点：</p><p>get 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。</p><p>post 不同，post 做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此 get 请求适合于请求缓存。</p><p>回答：</p><p>缓存一般只适用于那些不会更新服务端数据的请求。一般 get 请求都是查找请求，不会对服务器资源数据造成修改，而 post 请求一般都会对服务器数据造成修改，所以，一般会对 get 请求进行缓存，很少会对 post 请求进行缓存。</p><p>详细资料可以参考：<br><a href="https://blog.csdn.net/qq_27093465/article/details/50479289" target="_blank" rel="noopener">《HTML 关于 post 和 get 的区别以及缓存问题的理解》</a></p><h3 id="图片的懒加载和预加载"><a href="#图片的懒加载和预加载" class="headerlink" title="图片的懒加载和预加载"></a>图片的懒加载和预加载</h3><p>相关知识点：</p><p>预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。</p><p>懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。</p><p>两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。 懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</p><p>回答：</p><p>懒加载也叫延迟加载，指的是在长网页中延迟加载图片的时机，当用户需要访问时，再去加载，这样可以提高网站的首屏加载速度，提升用户的体验，并且可以减少服务器的压力。它适用于图片很多，页面很长的电商网站的场景。懒加载的实现原理是，将页面上的图片的 src 属性设置为空字符串，将图片的真实路径保存在一个自定义属性中，当页面滚动的时候，进行判断，如果图片进入页面可视区域内，则从自定义属性中取出真实路径赋值给图片的 src 属性，以此来实现图片的延迟加载。</p><p>预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。通过预加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 scr 属性，来实现图片的预加载。</p><p>这两种方式都是提高网页性能的方式，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</p><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b0c3b53f265da09253cbed0" target="_blank" rel="noopener">《懒加载和预加载》</a><br><a href="https://juejin.im/entry/5a73f38cf265da4e99575be3" target="_blank" rel="noopener">《网页图片加载优化方案》</a><br><a href="https://www.zhangxinxu.com/wordpress/2016/06/image-preload-based-on-user-behavior/" target="_blank" rel="noopener">《基于用户行为的图片等资源预加载》</a></p><h3 id="mouseover-和-mouseenter-的区别？"><a href="#mouseover-和-mouseenter-的区别？" class="headerlink" title="mouseover 和 mouseenter 的区别？"></a>mouseover 和 mouseenter 的区别？</h3><p>当鼠标移动到元素上时就会触发 mouseenter 事件，类似 mouseover，它们两者之间的差别是 mouseenter 不会冒泡。</p><p>由于 mouseenter 不支持事件冒泡，导致在一个元素的子元素上进入或离开的时候会触发其 mouseover 和 mouseout 事件，但是却不会触发 mouseenter 和 mouseleave 事件。</p><p>详细资料可以参考：<br><a href="https://github.com/qianlongo/zepto-analysis/issues/1" target="_blank" rel="noopener">《mouseenter 与 mouseover 为何这般纠缠不清？》</a></p><h3 id="js-拖拽功能的实现"><a href="#js-拖拽功能的实现" class="headerlink" title="js 拖拽功能的实现"></a>js 拖拽功能的实现</h3><p>相关知识点：</p><p>首先是三个事件，分别是 mousedown，mousemove，mouseup<br>当鼠标点击按下的时候，需要一个 tag 标识此时已经按下，可以执行 mousemove 里面的具体方法。<br>clientX，clientY 标识的是鼠标的坐标，分别标识横坐标和纵坐标，并且我们用 offsetX 和 offsetY 来表示<br>元素的元素的初始坐标，移动的举例应该是：<br>鼠标移动时候的坐标-鼠标按下去时候的坐标。<br>也就是说定位信息为：<br>鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的 offetLeft.</p><p>回答：</p><p>一个元素的拖拽过程，我们可以分为三个步骤，第一步是鼠标按下目标元素，第二步是鼠标保持按下的状态移动鼠标，第三步是鼠标抬起，拖拽过程结束。</p><p>这三步分别对应了三个事件，mousedown 事件，mousemove 事件和 mouseup 事件。只有在鼠标按下的状态移动鼠标我们才会执行拖拽事件，因此我们需要在 mousedown 事件中设置一个状态来标识鼠标已经按下，然后在 mouseup 事件中再取消这个状态。</p><p>在 mousedown 事件中我们首先应该判断，目标元素是否为拖拽元素，如果是拖拽元素，我们就设置状态并且保存这个时候鼠标的位置。</p><p>然后在 mousemove 事件中，我们通过判断鼠标现在的位置和以前位置的相对移动，来确定拖拽元素在移动中的坐标。需要通过 event.clientX 和 clientY 获取拖拽位置，并实时更新位置<br>最后 mouseup 事件触发后，清除状态，结束拖拽事件。（需要注意浏览器边界的情况）</p><p>详细资料可以参考：<br><a href="https://blog.csdn.net/LZGS_4/article/details/43523465" target="_blank" rel="noopener">《原生 js 实现拖拽功能基本思路》</a></p><h3 id="为什么使用-setTimeout-实现-setInterval？怎么模拟？"><a href="#为什么使用-setTimeout-实现-setInterval？怎么模拟？" class="headerlink" title="为什么使用 setTimeout 实现 setInterval？怎么模拟？"></a>为什么使用 setTimeout 实现 setInterval？怎么模拟？</h3><p>相关知识点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思路是使用递归函数，不断地去执行 setTimeout 从而达到 setInterval 的效果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mySetInterval</span>(<span class="params">fn, timeout</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 控制器，控制定时器是否继续执行</span></span><br><span class="line">  <span class="keyword">var</span> timer = &#123;</span><br><span class="line">    flag: <span class="literal">true</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置递归函数，模拟定时器执行。</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">interval</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer.flag) &#123;</span><br><span class="line">      fn();</span><br><span class="line">      setTimeout(interval, timeout);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动定时器</span></span><br><span class="line">  setTimeout(interval, timeout);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回控制器</span></span><br><span class="line">  <span class="keyword">return</span> timer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回答：</p><p>setInterval 的作用是每隔一段指定时间执行一个函数，但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。</p><p>针对 setInterval 的这个缺点，我们可以使用 setTimeout 递归调用来模拟 setInterval，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 setInterval 的问题。</p><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/32479bdfd851" target="_blank" rel="noopener">《用 setTimeout 实现 setInterval》</a><br><a href="https://zhuanlan.zhihu.com/p/51995737" target="_blank" rel="noopener">《setInterval 有什么缺点？》</a></p><h3 id="let-和-const-的注意点？"><a href="#let-和-const-的注意点？" class="headerlink" title="let 和 const 的注意点？"></a>let 和 const 的注意点？</h3><p>1.声明的变量只在声明时的代码块内有效</p><p>2.不存在声明提升</p><p>3.存在暂时性死区，如果在变量声明前使用，会报错</p><p>4.不允许重复声明，重复声明会报错</p><h3 id="什么是-rest-参数？"><a href="#什么是-rest-参数？" class="headerlink" title="什么是 rest 参数？"></a>什么是 rest 参数？</h3><p>rest 参数（形式为…变量名），用于获取函数的多余参数。</p><h3 id="什么是尾调用，使用尾调用有什么好处？"><a href="#什么是尾调用，使用尾调用有什么好处？" class="headerlink" title="什么是尾调用，使用尾调用有什么好处？"></a>什么是尾调用，使用尾调用有什么好处？</h3><p>尾调用指的是函数的最后一步调用另一个函数。我们代码执行是基于执行栈的，所以当我们在一个函数里调用另一个函数时，我们会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这个时候我们可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</p><h3 id="Symbol-类型的注意点？"><a href="#Symbol-类型的注意点？" class="headerlink" title="Symbol 类型的注意点？"></a>Symbol 类型的注意点？</h3><p>1.Symbol 函数前不能使用 new 命令，否则会报错。</p><p>2.Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p><p>3.Symbol 作为属性名，该属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。</p><p>4.Object.getOwnPropertySymbols 方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p><p>5.Symbol.for 接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</p><p>6.Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key。</p><h3 id="Set-和-WeakSet-结构？"><a href="#Set-和-WeakSet-结构？" class="headerlink" title="Set 和 WeakSet 结构？"></a>Set 和 WeakSet 结构？</h3><p>1.ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><p>2.WeakSet 结构与 Set 类似，也是不重复的值的集合。但是 WeakSet 的成员只能是对象，而不能是其他类型的值。WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，</p><h3 id="Map-和-WeakMap-结构？"><a href="#Map-和-WeakMap-结构？" class="headerlink" title="Map 和 WeakMap 结构？"></a>Map 和 WeakMap 结构？</h3><p>1.Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</p><p>2.WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。</p><h3 id="Reflect-对象创建目的？"><a href="#Reflect-对象创建目的？" class="headerlink" title="Reflect 对象创建目的？"></a>Reflect 对象创建目的？</h3><p>1.将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty，放到 Reflect 对象上。</p><p>2.修改某些 Object 方法的返回结果，让其变得更合理。</p><p>3.让 Object 操作都变成函数行为。</p><p>4.Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为。</p><h3 id="require-模块引入的查找方式？"><a href="#require-模块引入的查找方式？" class="headerlink" title="require 模块引入的查找方式？"></a>require 模块引入的查找方式？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">当 Node 遇到 require(X) 时，按下面的顺序处理。</span><br><span class="line"></span><br><span class="line">（1）如果 X 是内置模块（比如 require(&apos;http&apos;)）</span><br><span class="line">　　a. 返回该模块。</span><br><span class="line">　　b. 不再继续执行。</span><br><span class="line"></span><br><span class="line">（2）如果 X 以 &quot;./&quot; 或者 &quot;/&quot; 或者 &quot;../&quot; 开头</span><br><span class="line">　　a. 根据 X 所在的父模块，确定 X 的绝对路径。</span><br><span class="line">　　b. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。</span><br><span class="line">    X</span><br><span class="line">    X.js</span><br><span class="line">    X.json</span><br><span class="line">    X.node</span><br><span class="line"></span><br><span class="line">　　c. 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。</span><br><span class="line">    X/package.json（main字段）</span><br><span class="line">    X/index.js</span><br><span class="line">    X/index.json</span><br><span class="line">    X/index.node</span><br><span class="line"></span><br><span class="line">（3）如果 X 不带路径</span><br><span class="line">　　a. 根据 X 所在的父模块，确定 X 可能的安装目录。</span><br><span class="line">　　b. 依次在每个目录中，将 X 当成文件名或目录名加载。</span><br><span class="line"></span><br><span class="line">（4）抛出 &quot;not found&quot;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2015/05/require.html" target="_blank" rel="noopener">《require() 源码解读》</a></p><h3 id="什么是-Promise-对象，什么是-Promises-A-规范？"><a href="#什么是-Promise-对象，什么是-Promises-A-规范？" class="headerlink" title="什么是 Promise 对象，什么是 Promises/A+ 规范？"></a>什么是 Promise 对象，什么是 Promises/A+ 规范？</h3><p>Promise 对象是异步编程的一种解决方案，最早由社区提出。Promises/A+ 规范是 JavaScript Promise 的标准，规定了一个 Promise 所必须具有的特性。</p><p>Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是 pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者 rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。状态的改变是通过 resolve() 和 reject() 函数来实现的，我们可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。</p><p>详细资料可以参考：<br><a href="http://www.ituring.com.cn/article/66566" target="_blank" rel="noopener">《Promises/A+ 规范》</a><br><a href="http://es6.ruanyifeng.com/#docs/promise#Promise-resolve" target="_blank" rel="noopener">《Promise》</a></p><h3 id="手写一个-Promise"><a href="#手写一个-Promise" class="headerlink" title="手写一个 Promise"></a>手写一个 Promise</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">"pending"</span>;</span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">"resolved"</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">"rejected"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 保存初始化状态</span></span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化状态</span></span><br><span class="line">  <span class="keyword">this</span>.state = PENDING;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于保存 resolve 或者 rejected 传入的值</span></span><br><span class="line">  <span class="keyword">this</span>.value = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于保存 resolve 的回调函数</span></span><br><span class="line">  <span class="keyword">this</span>.resolvedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于保存 reject 的回调函数</span></span><br><span class="line">  <span class="keyword">this</span>.rejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 状态转变为 resolved 方法</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">      <span class="keyword">return</span> value.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证代码的执行顺序为本轮事件循环的末尾</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 只有状态为 pending 时才能转变，</span></span><br><span class="line">      <span class="keyword">if</span> (self.state === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 修改状态</span></span><br><span class="line">        self.state = RESOLVED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置传入的值</span></span><br><span class="line">        self.value = value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调函数</span></span><br><span class="line">        self.resolvedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">          callback(value);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 状态转变为 rejected 方法</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 保证代码的执行顺序为本轮事件循环的末尾</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 只有状态为 pending 时才能转变</span></span><br><span class="line">      <span class="keyword">if</span> (self.state === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 修改状态</span></span><br><span class="line">        self.state = REJECTED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置传入的值</span></span><br><span class="line">        self.value = value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调函数</span></span><br><span class="line">        self.rejectedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">          callback(value);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将两个方法传入函数执行</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fn(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// 遇到错误时，捕获错误，执行 reject 函数</span></span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 首先判断两个参数是否为函数类型，因为这两个参数是可选参数</span></span><br><span class="line">  onResolved =</span><br><span class="line">    <span class="keyword">typeof</span> onResolved === <span class="string">"function"</span></span><br><span class="line">      ? onResolved</span><br><span class="line">      : <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> value;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">  onRejected =</span><br><span class="line">    <span class="keyword">typeof</span> onRejected === <span class="string">"function"</span></span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">throw</span> error;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是等待状态，则将函数加入对应列表中</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">    <span class="keyword">this</span>.resolvedCallbacks.push(onResolved);</span><br><span class="line">    <span class="keyword">this</span>.rejectedCallbacks.push(onRejected);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果状态已经凝固，则直接执行对应状态的函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.state === RESOLVED) &#123;</span><br><span class="line">    onResolved(<span class="keyword">this</span>.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.state === REJECTED) &#123;</span><br><span class="line">    onRejected(<span class="keyword">this</span>.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="如何检测浏览器所支持的最小字体大小？"><a href="#如何检测浏览器所支持的最小字体大小？" class="headerlink" title="如何检测浏览器所支持的最小字体大小？"></a>如何检测浏览器所支持的最小字体大小？</h3><p>用 JS 设置 DOM 的字体为某一个值，然后再取出来，如果值设置成功，就说明支持。</p><h3 id="怎么做-JS-代码-Error-统计？"><a href="#怎么做-JS-代码-Error-统计？" class="headerlink" title="怎么做 JS 代码 Error 统计？"></a>怎么做 JS 代码 Error 统计？</h3><p>error 统计使用浏览器的 window.error 事件。</p><h3 id="单例模式模式是什么？"><a href="#单例模式模式是什么？" class="headerlink" title="单例模式模式是什么？"></a>单例模式模式是什么？</h3><p>单例模式保证了全局只有一个实例来被访问。比如说常用的如弹框组件的实现和全局状态的实现。</p><h3 id="策略模式是什么？"><a href="#策略模式是什么？" class="headerlink" title="策略模式是什么？"></a>策略模式是什么？</h3><p>策略模式主要是用来将方法的实现和方法的调用分离开，外部通过不同的参数可以调用不同的策略。我主要在 MVP 模式解耦的时候<br>用来将视图层的方法定义和方法调用分离。</p><h3 id="代理模式是什么？"><a href="#代理模式是什么？" class="headerlink" title="代理模式是什么？"></a>代理模式是什么？</h3><p> 代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。比如说常见的事件代理。</p><h3 id="中介者模式是什么？"><a href="#中介者模式是什么？" class="headerlink" title="中介者模式是什么？"></a>中介者模式是什么？</h3><p>中介者模式指的是，多个对象通过一个中介者进行交流，而不是直接进行交流，这样能够将通信的各个对象解耦。</p><h3 id="适配器模式是什么？"><a href="#适配器模式是什么？" class="headerlink" title="适配器模式是什么？"></a>适配器模式是什么？</h3><p>适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。假如我们需要一种<br>新的接口返回方式，但是老的接口由于在太多地方已经使用了，不能随意更改，这个时候就可以使用适配器模式。比如我们需要一种<br>自定义的时间返回格式，但是我们又不能对 js 时间格式化的接口进行修改，这个时候就可以使用适配器模式。</p><p>更多关于设计模式的资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc74186fb9a049ab0d0b6b" target="_blank" rel="noopener">《前端面试之道》</a><br><a href="https://juejin.im/post/59df4f74f265da430f311909#heading-3" target="_blank" rel="noopener">《JavaScript 设计模式》</a><br><a href="https://juejin.im/post/5afe6430518825428630bc4d" target="_blank" rel="noopener">《JavaScript 中常见设计模式整理》</a></p><h3 id="开发中常用的几种Content-Type-？"><a href="#开发中常用的几种Content-Type-？" class="headerlink" title="开发中常用的几种Content-Type ？"></a>开发中常用的几种Content-Type ？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">（1）application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL</span><br><span class="line">转码。</span><br><span class="line"></span><br><span class="line">（2）multipart/form-data</span><br><span class="line"></span><br><span class="line">该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。</span><br><span class="line"></span><br><span class="line">（3）application/json</span><br><span class="line"></span><br><span class="line">告诉服务器消息主体是序列化后的 JSON 字符串。</span><br><span class="line"></span><br><span class="line">（4）text/xml</span><br><span class="line"></span><br><span class="line">该种方式主要用来提交 XML 格式的数据。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://honglu.me/2015/07/13/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8DContent-Type/" target="_blank" rel="noopener">《常用的几种 Content-Type》</a></p><h3 id="如何确定页面的可用性时间，什么是-Performance-API？"><a href="#如何确定页面的可用性时间，什么是-Performance-API？" class="headerlink" title="如何确定页面的可用性时间，什么是 Performance API？"></a>如何确定页面的可用性时间，什么是 Performance API？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Performance API 用于精确度量、控制、增强浏览器的性能表现。这个 API 为测量网站性能，提供以前没有办法做到的精度。</span><br><span class="line"></span><br><span class="line">使用 getTime 来计算脚本耗时的缺点，首先，getTime方法（以及 Date 对象的其他方法）都只能精确到毫秒级别（一秒的千分之一），想要得到更小的时间差别就无能为力了。其次，这种写法只能获取代码运行过程中的时间进度，无法知道一些后台事件的时间进度，比如浏览器用了多少时间从服务器加载网页。</span><br><span class="line"></span><br><span class="line">为了解决这两个不足之处，ECMAScript 5引入“高精度时间戳”这个 API，部署在 performance 对象上。它的精度可以达到1毫秒的千分之一（1秒的百万分之一）。</span><br><span class="line"></span><br><span class="line">navigationStart：当前浏览器窗口的前一个网页关闭，发生 unload 事件时的 Unix 毫秒时间戳。如果没有前一个网页，则等于 fetchStart 属性。</span><br><span class="line"></span><br><span class="line">loadEventEnd：返回当前网页 load 事件的回调函数运行结束时的 Unix 毫秒时间戳。如果该事件还没有发生，返回 0。</span><br></pre></td></tr></table></figure><p>根据上面这些属性，可以计算出网页加载各个阶段的耗时。比如，网页加载整个过程的耗时的计算方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t = performance.timing;</span><br><span class="line"><span class="keyword">var</span> pageLoadTime = t.loadEventEnd - t.navigationStart;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://javascript.ruanyifeng.com/bom/performance.html" target="_blank" rel="noopener">《Performance API》</a></p><h3 id="js-中的命名规则"><a href="#js-中的命名规则" class="headerlink" title="js 中的命名规则"></a>js 中的命名规则</h3><p>（1）第一个字符必须是字母、下划线（_）或美元符号（$）<br>（2）余下的字符可以是下划线、美元符号或任何字母或数字字符</p><p>一般我们推荐使用驼峰法来对变量名进行命名，因为这样可以与 ECMAScript 内置的函数和对象命名格式保持一致。</p><p>详细资料可以参考：<br><a href="http://www.w3school.com.cn/js/pro_js_variables.asp" target="_blank" rel="noopener">《ECMAScript 变量》</a></p><h3 id="js-语句末尾分号是否可以省略？"><a href="#js-语句末尾分号是否可以省略？" class="headerlink" title="js 语句末尾分号是否可以省略？"></a>js 语句末尾分号是否可以省略？</h3><p>在 ECMAScript 规范中，语句结尾的分号并不是必需的。但是我们一般最好不要省略分号，因为加上分号一方面有<br>利于我们代码的可维护性，另一方面也可以避免我们在对代码进行压缩时出现错误。</p><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</span><br></pre></td></tr></table></figure><h3 id="Math-ceil-和-Math-floor"><a href="#Math-ceil-和-Math-floor" class="headerlink" title="Math.ceil 和 Math.floor"></a>Math.ceil 和 Math.floor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.ceil() === 向上取整，函数返回一个大于或等于给定数字的最小整数。</span><br><span class="line"></span><br><span class="line">Math.floor() === 向下取整，函数返回一个小于或等于给定数字的最大整数。</span><br></pre></td></tr></table></figure><h3 id="js-for-循环注意点"><a href="#js-for-循环注意点" class="headerlink" title="js for 循环注意点"></a>js for 循环注意点</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; <span class="number">5</span>, j &lt; <span class="number">9</span>; i++, j++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当判断语句含有多个语句时，以最后一个判断语句的值为准，因此上面的代码会执行 10 次。</span></span><br><span class="line"><span class="comment">// 当判断语句为空时，循环会一直进行。</span></span><br></pre></td></tr></table></figure><h3 id="一个列表，假设有-100000-个数据，这个该怎么办？"><a href="#一个列表，假设有-100000-个数据，这个该怎么办？" class="headerlink" title="一个列表，假设有 100000 个数据，这个该怎么办？"></a>一个列表，假设有 100000 个数据，这个该怎么办？</h3><p>我们需要思考的问题：该处理是否必须同步完成？数据是否必须按顺序完成？</p><p>解决办法：</p><p>（1）将数据分页，利用分页的原理，每次服务器端只返回一定数目的数据，浏览器每次只对一部分进行加载。</p><p>（2）使用懒加载的方法，每次加载一部分数据，其余数据当需要使用时再去加载。</p><p>（3）使用数组分块技术，基本思路是为要处理的项目创建一个队列，然后设置定时器每过一段时间取出一部分数据，然后再使用定时器取出下一个要处理的项目进行处理，接着再设置另一个定时器。</p><h3 id="js-中倒计时的纠偏实现？"><a href="#js-中倒计时的纠偏实现？" class="headerlink" title="js 中倒计时的纠偏实现？"></a>js 中倒计时的纠偏实现？</h3><p>在前端实现中我们一般通过 setTimeout 和 setInterval 方法来实现一个倒计时效果。但是使用这些方法会存在时间偏差的问题，这是由于 js 的程序执行机制造成的，setTimeout 和 setInterval 的作用是隔一段时间将回调事件加入到事件队列中，因此事件并不是立即执行的，它会等到当前执行栈为空的时候再取出事件执行，因此事件等待执行的时间就是造成误差的原因。</p><p>一般解决倒计时中的误差的有这样两种办法：</p><p>（1）第一种是通过前端定时向服务器发送请求获取最新的时间差，以此来校准倒计时时间。</p><p>（2）第二种方法是前端根据偏差时间来自动调整间隔时间的方式来实现的。这一种方式首先是以 setTimeout 递归的方式来实现倒计时，然后通过一个变量来记录已经倒计时的秒数。每一次函数调用的时候，首先将变量加一，然后根据这个变量和每次的间隔时间，我们就可以计算出此时无偏差时应该显示的时间。然后将当前的真实时间与这个时间相减，这样我们就可以得到时间的偏差大小，因此我们在设置下一个定时器的间隔大小的时候，我们就从间隔时间中减去这个偏差大小，以此来实现由于程序执行所造成的时间误差的纠正。</p><p>详细资料可以参考：<br><a href="https://juejin.im/post/5badf8305188255c8e728adc" target="_blank" rel="noopener">《JavaScript 前端倒计时纠偏实现》</a></p><h3 id="进程间通信的方式？"><a href="#进程间通信的方式？" class="headerlink" title="进程间通信的方式？"></a>进程间通信的方式？</h3><ul><li>1.管道通信</li><li>2.消息队列通信</li><li>3.信号量通信</li><li>4.信号通信</li><li>5.共享内存通信</li><li>6.套接字通信</li></ul><p>详细资料可以参考：<br><a href="https://blog.csdn.net/violet_echo_0908/article/details/51201278" target="_blank" rel="noopener">《进程间 8 种通信方式详解》</a><br><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noopener">《进程与线程的一个简单解释》</a></p><h3 id="ele-getElementsByClassName和ele-querySelectorAll的区别？"><a href="#ele-getElementsByClassName和ele-querySelectorAll的区别？" class="headerlink" title="ele.getElementsByClassName和ele.querySelectorAll的区别？"></a>ele.getElementsByClassName和ele.querySelectorAll的区别？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">element.getElementsByClassName 返回一个即时更新（动态的）HTMLCollection</span><br><span class="line">element.querySelectorAll 返回一个非即时更新（静态的） NodeList</span><br><span class="line">// 先说什么叫即时更新，（前者是动态的，改变 DOM 结构会同步，后者只会记录调用 api 时的结果，不懂可以看下面的例子）</span><br><span class="line">&lt;div id=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;p class=&quot;p&quot;&gt;1&lt;/p&gt;</span><br><span class="line">  &lt;p class=&quot;p&quot;&gt;2&lt;/p&gt;</span><br><span class="line">  &lt;p class=&quot;p&quot;&gt;3&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">let list1 = parent.getElementsByClassName(&apos;p&apos;);</span><br><span class="line">let list2 = parent.querySelectorAll(&apos;.p&apos;);</span><br><span class="line">console.log(list1.length1); // 3</span><br><span class="line">console.log(list2.length1); // 3</span><br><span class="line">let newP = docuemnt.createElement(&quot;p&quot;)</span><br><span class="line">newP.classList.add(&apos;p&apos;);</span><br><span class="line">parent.appendChild(newP);</span><br><span class="line">console.log(list1.length1); // 4 (即时更新)</span><br><span class="line">console.log(list2.length1); // 3（非即时更新）</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">// 在说下返回值</span><br><span class="line">// HTMLCollection 和 NodeList 都是类数组形式</span><br><span class="line">如下一个 div 可以看成是 HTMLDivElement 的实例，其中 Node 的集合为 NodeList；Element 的集合为 HTMLCollection</span><br><span class="line">EventTarget - Node - Element - HTMLElement - HTMLDivElement&lt;br&gt;</span><br><span class="line">EventTarget - Node - Element - SVGElement - SVGPathElement&lt;br&gt;</span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLDivElement" target="_blank" rel="noopener">MDN 上元素 div 继承关系</a></p><h3 id="请用-js-去除字符串空格？"><a href="#请用-js-去除字符串空格？" class="headerlink" title="请用 js 去除字符串空格？"></a>请用 js 去除字符串空格？</h3><p>答案：replace 正则匹配方法、str.trim()方法、JQ 方法：$.trim(str)方法</p><p>解析：</p><p>方法一：replace 正则匹配方法</p><p>去除字符串内所有的空格：str = str.replace(/\s*/g,””);</p><p>去除字符串内两头的空格：str = str.replace(/^\s<em>|\s</em>$/g,””);</p><p>去除字符串内左侧的空格：str = str.replace(/^\s*/,””);</p><p>去除字符串内右侧的空格：str = str.replace(/(\s*$)/g,””);</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">" 6 6 "</span>;</span><br><span class="line"><span class="keyword">var</span> str_1 = str.replace(<span class="regexp">/\s*/g</span>, <span class="string">""</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str_1); <span class="comment">//66</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">" 6 6 "</span>;</span><br><span class="line"><span class="keyword">var</span> str_1 = str.replace(<span class="regexp">/^\s*|\s*$/g</span>, <span class="string">""</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str_1); <span class="comment">//6 6//输出左右侧均无空格</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">" 6 6 "</span>;</span><br><span class="line"><span class="keyword">var</span> str_1 = str.replace(<span class="regexp">/^\s*/</span>, <span class="string">""</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str_1); <span class="comment">//6 6 //输出右侧有空格左侧无空格</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">" 6 6 "</span>;</span><br><span class="line"><span class="keyword">var</span> str_1 = str.replace(<span class="regexp">/(\s*$)/g</span>, <span class="string">""</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str_1); <span class="comment">// 6 6//输出左侧有空格右侧无空格</span></span><br></pre></td></tr></table></figure><p>方法二：str.trim()方法</p><p>trim()方法是用来删除字符串两端的空白字符并返回，trim 方法并不影响原来的字符串本身，它返回的是一个新的字符串。</p><p>缺陷：只能去除字符串两端的空格，不能去除中间的空格</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">" 6 6 "</span>;</span><br><span class="line"><span class="keyword">var</span> str_1 = str.trim();</span><br><span class="line"><span class="built_in">console</span>.log(str_1); <span class="comment">//6 6//输出左右侧均无空格</span></span><br></pre></td></tr></table></figure><p>方法三：JQ 方法：$.trim(str)方法</p><p>$.trim() 函数用于去除字符串两端的空白字符。</p><p>注意：$.trim()函数会移除字符串开始和末尾处的所有换行符，空格(包括连续的空格)和制表符。如果这些空白字符在字符串中间时，它们将被保留，不会被移除。</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">" 6 6 "</span>;</span><br><span class="line"><span class="keyword">var</span> str_1 = $.trim(str);</span><br><span class="line"><span class="built_in">console</span>.log(str_1); <span class="comment">//6 6//输出左右侧均无空格</span></span><br></pre></td></tr></table></figure><h3 id="同步和异步的区别"><a href="#同步和异步的区别" class="headerlink" title="同步和异步的区别?"></a>同步和异步的区别?</h3><p>同步的概念应该是来自于OS中关于同步的概念:不同进程为协同完成某项工作而在先后次序上调整(通过阻塞,唤醒等方式).同步强调的是顺序性.谁先谁后.异步则不存在这种顺序性.</p><ul><li>同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作</li><li>异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容</li></ul><h3 id="异步加载JS的方式有哪些？"><a href="#异步加载JS的方式有哪些？" class="headerlink" title="异步加载JS的方式有哪些？"></a>异步加载JS的方式有哪些？</h3><ul><li><p>(1) defer，只支持IE</p></li><li><p>(2) async：</p></li><li><p>(3) 创建script，插入到DOM中，加载完毕后callBack</p></li></ul><h3 id="异步处理方法（参考链接）"><a href="#异步处理方法（参考链接）" class="headerlink" title="异步处理方法（参考链接）"></a>异步处理方法（<a href="https://juejin.im/entry/58b294a78d6d810057eea370" target="_blank" rel="noopener">参考链接</a>）</h3><p><strong>1)回调函数：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function fn1 () &#123;</span><br><span class="line">    console.log(&apos;Function 1&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn2 (f) &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&apos;Function 2&apos;)</span><br><span class="line">        f()</span><br><span class="line">&#125;, 500)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn3 () &#123;</span><br><span class="line">    console.log(&apos;Function 3&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn1();</span><br><span class="line">fn2(fn3) ; //可依次执行fn1，fn2，fn3</span><br></pre></td></tr></table></figure><p><strong>2)发布/订阅模式；</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class AsyncFunArr &#123;</span><br><span class="line">    constructor (...arr) &#123;</span><br><span class="line">        this.funcArr = [...arr]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">next () &#123;</span><br><span class="line">    const fn = this.funcArr.shift()</span><br><span class="line">    if (typeof fn === &apos;function&apos;) fn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run () &#123;</span><br><span class="line">    this.next()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn1 () &#123;</span><br><span class="line">    console.log(&apos;Function 1&apos;)</span><br><span class="line">    asyncFunArr.next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn2 () &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&apos;Function 2&apos;)</span><br><span class="line">        asyncFunArr.next()</span><br><span class="line">    &#125;, 500)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn3 () &#123;</span><br><span class="line">    console.log(&apos;Function 3&apos;)</span><br><span class="line">    asyncFunArr.next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3）Promise：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function fn1 () &#123;</span><br><span class="line"></span><br><span class="line">console.log(&apos;Function 1&apos;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn2 () &#123;</span><br><span class="line"></span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">            console.log(&apos;Function 2&apos;)</span><br><span class="line"></span><br><span class="line">            resolve()</span><br><span class="line"></span><br><span class="line">    &#125;, 500) &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn3 () &#123;</span><br><span class="line"></span><br><span class="line">console.log(&apos;Function 3&apos;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn1()；</span><br><span class="line"></span><br><span class="line">fn2().then(() =&gt; &#123; fn3() &#125;)；</span><br></pre></td></tr></table></figure><p><strong>4)generator:</strong>（<a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="noopener">参考链接</a>）</p><h3 id="documen-write和-innerHTML的区别"><a href="#documen-write和-innerHTML的区别" class="headerlink" title="documen.write和 innerHTML的区别"></a>documen.write和 innerHTML的区别</h3><ul><li>document.write只能重绘整个页面</li><li>innerHTML可以重绘页面的一部分</li></ul><h3 id="怎样添加、移除、移动、复制、创建和查找节点？"><a href="#怎样添加、移除、移动、复制、创建和查找节点？" class="headerlink" title="怎样添加、移除、移动、复制、创建和查找节点？"></a>怎样添加、移除、移动、复制、创建和查找节点？</h3><p>1）创建新节点</p><ul><li>createDocumentFragment() //创建一个 DOM 片段</li><li>createElement() //创建一个具体的元素</li><li>createTextNode() //创建一个文本节点</li></ul><p>2）添加、移除、替换、插入</p><ul><li>appendChild() //添加</li><li>removeChild() //移除</li><li>replaceChild() //替换</li><li>insertBefore() //插入</li></ul><p>3）查找</p><ul><li>getElementsByTagName() //通过标签名称</li><li>getElementsByName() //通过元素的 Name 属性的值</li><li>getElementById() //通过元素 Id，唯一性</li></ul><h3 id="如何判断-JS-变量的一个类型（至少三种方式）"><a href="#如何判断-JS-变量的一个类型（至少三种方式）" class="headerlink" title="如何判断 JS 变量的一个类型（至少三种方式）"></a>如何判断 JS 变量的一个类型（至少三种方式）</h3><p>typeof、instanceof、 constructor、 prototype</p><h3 id="null-undefined-的区别"><a href="#null-undefined-的区别" class="headerlink" title="null/undefined 的区别"></a>null/undefined 的区别</h3><p>null： Null 类型，代表“空值”，代表一个空对象指针，使用 typeof 运算得到 “object”，所以你可以认为它是一个特殊的对象值。</p><p>undefined： Undefined 类型，当一个声明了一个变量未初始化时，得到的就是 undefined。</p><h3 id="去除字符串里面的重复字符"><a href="#去除字符串里面的重复字符" class="headerlink" title="去除字符串里面的重复字符"></a>去除字符串里面的重复字符</h3><p>最简单的方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...new <span class="built_in">Set</span>(<span class="string">"ababbc"</span>)].join(<span class="string">""</span>);</span><br><span class="line"><span class="comment">// "abc"</span></span><br></pre></td></tr></table></figure><h3 id="数组和对象的深浅拷贝（参考链接）"><a href="#数组和对象的深浅拷贝（参考链接）" class="headerlink" title="数组和对象的深浅拷贝（参考链接）"></a>数组和对象的深浅拷贝（<a href="http://www.cnblogs.com/zqzjs/p/5410138.html" target="_blank" rel="noopener">参考链接</a>）</h3><h3 id="String-Array的一些基本操作（参考链接）"><a href="#String-Array的一些基本操作（参考链接）" class="headerlink" title="String + Array的一些基本操作（参考链接）"></a>String + Array的一些基本操作（<a href="https://blog.csdn.net/JSCTO/article/details/50063501" target="_blank" rel="noopener">参考链接</a>）</h3><h3 id="冒泡和捕获（参考链接）"><a href="#冒泡和捕获（参考链接）" class="headerlink" title="冒泡和捕获（参考链接）"></a>冒泡和捕获（<a href="https://segmentfault.com/a/1190000005654451" target="_blank" rel="noopener">参考链接</a>）</h3><h3 id="事件代理（参考链接）"><a href="#事件代理（参考链接）" class="headerlink" title="事件代理（参考链接）"></a>事件代理（<a href="https://www.jianshu.com/p/39613d176b3a" target="_blank" rel="noopener">参考链接</a>）</h3><h3 id="jsonp和跨域，为什么浏览器会禁止跨域（参考链接：jsonp）"><a href="#jsonp和跨域，为什么浏览器会禁止跨域（参考链接：jsonp）" class="headerlink" title="jsonp和跨域，为什么浏览器会禁止跨域（参考链接：jsonp）"></a>jsonp和跨域，为什么浏览器会禁止跨域（参考链接：<a href="https://blog.csdn.net/u014607184/article/details/52027879" target="_blank" rel="noopener">jsonp</a>）</h3><h3 id="变量提升（参考链接）"><a href="#变量提升（参考链接）" class="headerlink" title="变量提升（参考链接）"></a>变量提升（<a href="http://www.runoob.com/js/js-hoisting.html" target="_blank" rel="noopener">参考链接</a>）</h3><h3 id="高阶函数（参考链接）"><a href="#高阶函数（参考链接）" class="headerlink" title="高阶函数（参考链接）"></a>高阶函数（<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499355829ead974e550644e2ebd9fd8bb1b0dd721000" target="_blank" rel="noopener">参考链接</a>）</h3><h3 id="动画（参考链接）"><a href="#动画（参考链接）" class="headerlink" title="动画（参考链接）"></a>动画（<a href="http://www.imooc.com/learn/167" target="_blank" rel="noopener">参考链接</a>）</h3><h3 id="模块化开发参考链接、-UMD"><a href="#模块化开发参考链接、-UMD" class="headerlink" title="模块化开发参考链接、 UMD"></a>模块化开发<a href="https://zhuanlan.zhihu.com/p/22890374" target="_blank" rel="noopener">参考链接</a>、 <a href="https://github.com/umdjs/umd" target="_blank" rel="noopener">UMD</a></h3><h3 id="引起内存泄漏的原因（参考链接）"><a href="#引起内存泄漏的原因（参考链接）" class="headerlink" title="引起内存泄漏的原因（参考链接）"></a>引起内存泄漏的原因（<a href="https://juejin.im/entry/58158abaa0bb9f005873a843" target="_blank" rel="noopener">参考链接</a>）</h3><p><strong>1）全局变量引起的内存泄漏</strong></p><p>function leaks(){ leak = ‘xxxxxx’;//leak 成为一个全局变量，不会被回收}</p><p><strong>2）闭包引起的内存泄漏</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var leaks = (function()&#123;</span><br><span class="line">        var leak = &apos;xxxxxx&apos;;// 被闭包所引用，不会被回收</span><br><span class="line">        return function()&#123;</span><br><span class="line">                console.log(leak);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p><strong>3）dom清空或删除时，事件未清除导致的内存泄漏</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#container&apos;).bind(&apos;click&apos;, function()&#123;</span><br><span class="line">    console.log(&apos;click&apos;);</span><br><span class="line">&#125;).remove();</span><br><span class="line"></span><br><span class="line">// zepto 和原生 js下，#container dom 元素，还在内存里jquery 的 empty和 remove会帮助开发者避免这个问题</span><br><span class="line">$(&apos;#container&apos;).bind(&apos;click&apos;, function()&#123;</span><br><span class="line">    console.log(&apos;click&apos;);</span><br><span class="line">&#125;).off(&apos;click&apos;).remove();</span><br><span class="line">//把事件清除了，即可从内存中移除</span><br></pre></td></tr></table></figure><p><strong>4） 被遗忘的计时器或回调函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var someResource = getData();</span><br><span class="line">setInterval(function() &#123;</span><br><span class="line">    var node = document.getElementById(&apos;Node&apos;);</span><br><span class="line">    if(node) &#123;        // 处理 node 和 someResource</span><br><span class="line">        node.innerHTML = JSON.stringify(someResource));</span><br><span class="line">&#125;&#125;, 1000);</span><br><span class="line"></span><br><span class="line">修改：</span><br><span class="line">var element = document.getElementById(&apos;button&apos;);</span><br><span class="line">function onClick(event) &#123;</span><br><span class="line">    element.innerHTML = &apos;text&apos;;</span><br><span class="line">&#125;</span><br><span class="line">element.addEventListener(&apos;click&apos;, onClick);</span><br></pre></td></tr></table></figure><h3 id="map、filter、reduce相关"><a href="#map、filter、reduce相关" class="headerlink" title="map、filter、reduce相关"></a>map、filter、reduce相关</h3><p>参考链接：</p><p><a href="https://atendesigngroup.com/blog/array-map-filter-and-reduce-js" target="_blank" rel="noopener">https://atendesigngroup.com/blog/array-map-filter-and-reduce-js</a></p><p><a href="http://zerosoul.github.io/2016/12/06/array-filter-map-reduce-in-js" target="_blank" rel="noopener">http://zerosoul.github.io/2016/12/06/array-filter-map-reduce-in-js</a></p><h3 id="Map和Set（参考链接）"><a href="#Map和Set（参考链接）" class="headerlink" title="Map和Set（参考链接）"></a>Map和Set（<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014345007434430758e3ac6e1b44b1865178e7aff9082e000" target="_blank" rel="noopener">参考链接</a>）</h3><p><strong>Map</strong>是一组键值对的结构，具有极快的查找速度。</p><p>例：var m =new Map([[‘Michael’,95], [‘Bob’,75], [‘Tracy’,85]]);</p><p>m.get(‘Michael’);// 95</p><p><strong>Set</strong>和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。</p><p>要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set：</p><p>var s1 = new Set(); // 空Set</p><p>var s2 = new Set([1, 2, 3]); // 含1, 2, 3</p><h3 id="js-是一门怎样的语言，它有什么特点"><a href="#js-是一门怎样的语言，它有什么特点" class="headerlink" title="js 是一门怎样的语言，它有什么特点"></a>js 是一门怎样的语言，它有什么特点</h3><p>1.脚本语言。JavaScript 是一种<strong>解释型的脚本语言</strong>,C、C++等语言先编译后执行,而 JavaScript 是在程序的运行过程中逐行进行解释。</p><p>2.基于对象。JavaScript 是一种<strong>基于对象的脚本语言</strong>,它不仅可以创建对象,也能使用现有的对象。</p><p>3.简单。JavaScript 语言中采用的是<strong>弱类型的变量类型</strong>,对使用的数据类型未做出严格的要求,是基于 Java 基本语句和控制的脚本语言,其设计简单紧凑。</p><p>4.动态性。JavaScript 是一种<strong>采用事件驱动的脚本语言</strong>,它不需要经过 Web 服务器就可以对用户的输入做出响应。</p><p>5.<strong>跨平台性</strong>。JavaScript 脚本语言不依赖于操作系统,仅需要浏览器的支持。</p><h3 id="JavaScript-的循环语句有哪些？"><a href="#JavaScript-的循环语句有哪些？" class="headerlink" title="JavaScript 的循环语句有哪些？"></a>JavaScript 的循环语句有哪些？</h3><p>while for do while forEach</p><h3 id="script-的位置是否会影响首屏显示时间？"><a href="#script-的位置是否会影响首屏显示时间？" class="headerlink" title="script 的位置是否会影响首屏显示时间？"></a>script 的位置是否会影响首屏显示时间？</h3><ul><li>在解析 HTML 生成 DOM 过程中，js 文件的下载是并行的，不需要 DOM 处理到 script 节点。因此，script的位置不影响首屏显示的开始时间。</li><li>浏览器解析 HTML 是自上而下的线性过程，script作为 HTML 的一部分同样遵循这个原则</li><li>因此，script 会延迟 DomContentLoad，只显示其上部分首屏内容，从而影响首屏显示的完成时间</li></ul><h3 id="JavaScript有几种类型的值？你能画一下他们的内存图吗？"><a href="#JavaScript有几种类型的值？你能画一下他们的内存图吗？" class="headerlink" title="JavaScript有几种类型的值？你能画一下他们的内存图吗？"></a>JavaScript有几种类型的值？你能画一下他们的内存图吗？</h3><p><strong>栈</strong>：原始数据类型（Undefined，Null，Boolean，Number、String）</p><p><strong>堆</strong>：引用数据类型（对象、数组和函数）</p><p>两种类型的区别是：存储位置不同；</p><ul><li><p>原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</p></li><li><p>引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体</p></li></ul><h3 id="eval是做什么的？"><a href="#eval是做什么的？" class="headerlink" title="eval是做什么的？"></a>eval是做什么的？</h3><p><strong>eval的功能是把对应的字符串解析成JS代码并运行</strong></p><ul><li>应该避免使用eval，不安全，非常耗性能（先解析成js语句，再执行）</li><li>由JSON字符串转换为JSON对象的时候可以用 eval(‘(‘+ str +’)’);</li></ul><h3 id="javascript-代码中的”use-strict”-是什么意思-使用它区别是什么？"><a href="#javascript-代码中的”use-strict”-是什么意思-使用它区别是什么？" class="headerlink" title="javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？"></a>javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？</h3><ul><li>use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,</li><li>使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。</li><li>默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值;</li><li>全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用；</li><li>消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同;</li><li>提高编译器效率，增加运行速度；为未来新版本的Javascript标准化做铺垫。</li></ul><h3 id="js延迟加载的方式有哪些？"><a href="#js延迟加载的方式有哪些？" class="headerlink" title="js延迟加载的方式有哪些？"></a>js延迟加载的方式有哪些？</h3><ul><li>defer和async、动态创建DOM方式（用得最多）、按需异步载入js</li></ul><h3 id="介绍-DOM-的发展"><a href="#介绍-DOM-的发展" class="headerlink" title="介绍 DOM 的发展"></a>介绍 DOM 的发展</h3><ul><li>DOM：文档对象模型（Document Object Model），定义了访问HTML和XML文档的标准，与编程语言及平台无关</li><li>DOM0：提供了查询和操作Web文档的内容API。未形成标准，实现混乱。如：document.forms[‘login’]</li><li>DOM1：W3C提出标准化的DOM，简化了对文档中任意部分的访问和操作。如：JavaScript中的Document对象</li><li>DOM2：原来DOM基础上扩充了鼠标事件等细分模块，增加了对CSS的支持。如：getComputedStyle(elem, pseudo)</li><li>DOM3：增加了XPath模块和加载与保存（Load and Save）模块。如：XPathEvaluator</li></ul><h3 id="区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”？"><a href="#区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”？" class="headerlink" title="区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”？"></a>区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”？</h3><ul><li>客户区坐标：鼠标指针在可视区中的水平坐标(clientX)和垂直坐标(clientY)</li><li>页面坐标：鼠标指针在页面布局中的水平坐标(pageX)和垂直坐标(pageY)</li><li>屏幕坐标：设备物理屏幕的水平坐标(screenX)和垂直坐标(screenY)</li></ul><h3 id="如何获得一个DOM元素的绝对位置？"><a href="#如何获得一个DOM元素的绝对位置？" class="headerlink" title="如何获得一个DOM元素的绝对位置？"></a>如何获得一个DOM元素的绝对位置？</h3><ul><li>elem.offsetLeft：返回元素相对于其定位父级左侧的距离</li><li>elem.offsetTop：返回元素相对于其定位父级顶部的距离</li><li>elem.getBoundingClientRect()：返回一个DOMRect对象，包含一组描述边框的只读属性，单位像素</li></ul><h3 id="用原生JavaScript的实现过什么功能吗？"><a href="#用原生JavaScript的实现过什么功能吗？" class="headerlink" title="用原生JavaScript的实现过什么功能吗？"></a>用原生JavaScript的实现过什么功能吗？</h3><p>封装选择器、调用第三方API、设置和获取样式</p><h3 id="JavaScript实现异步编程的方法？"><a href="#JavaScript实现异步编程的方法？" class="headerlink" title="JavaScript实现异步编程的方法？"></a>JavaScript实现异步编程的方法？</h3><ul><li>回调函数</li><li>事件监听</li><li>发布/订阅</li><li>Promises对象</li><li>Async函数[ES7]</li></ul><h3 id="web开发中会话跟踪的方法有哪些"><a href="#web开发中会话跟踪的方法有哪些" class="headerlink" title="web开发中会话跟踪的方法有哪些"></a>web开发中会话跟踪的方法有哪些</h3><ul><li>cookie</li><li>session</li><li>url重写</li><li>隐藏input</li><li>ip地址</li></ul><h3 id="JavaScript有几种类型的值？，你能画一下他们的内存图吗？"><a href="#JavaScript有几种类型的值？，你能画一下他们的内存图吗？" class="headerlink" title="JavaScript有几种类型的值？，你能画一下他们的内存图吗？"></a>JavaScript有几种类型的值？，你能画一下他们的内存图吗？</h3><ul><li><p>栈：原始数据类型（Undefined，Null，Boolean，Number、String） </p></li><li><p>堆：引用数据类型（对象、数组和函数）</p></li><li><p>两种类型的区别是：存储位置不同；</p></li><li><p>原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</p></li><li><p>引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其</p></li><li><p>在栈中的地址，取得地址后从堆中获得实体</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://camo.githubusercontent.com/d1947e624a0444d1032a85800013df487adc5550/687474703a2f2f7777772e77337363686f6f6c2e636f6d2e636e2f692f63745f6a735f76616c75652e676966" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="eval是做什么的？-1"><a href="#eval是做什么的？-1" class="headerlink" title="eval是做什么的？"></a>eval是做什么的？</h3><ul><li>它的功能是把对应的字符串解析成JS代码并运行</li><li>应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）</li><li>由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(‘(‘+ str +’)’)</li></ul><h3 id="javascript-代码中的”use-strict”-是什么意思-使用它区别是什么？-1"><a href="#javascript-代码中的”use-strict”-是什么意思-使用它区别是什么？-1" class="headerlink" title="javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？"></a>javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？</h3><ul><li>use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为</li></ul><h3 id="js延迟加载的方式有哪些？-1"><a href="#js延迟加载的方式有哪些？-1" class="headerlink" title="js延迟加载的方式有哪些？"></a>js延迟加载的方式有哪些？</h3><p>defer和async、动态创建DOM方式（用得最多）、按需异步载入js</p><h3 id="异步加载JS的方式有哪些？-1"><a href="#异步加载JS的方式有哪些？-1" class="headerlink" title="异步加载JS的方式有哪些？"></a>异步加载JS的方式有哪些？</h3><ul><li>defer，只支持IE</li><li>async：</li><li>创建script，插入到DOM中，加载完毕后callBack</li></ul><h3 id="defer和async"><a href="#defer和async" class="headerlink" title="defer和async"></a>defer和async</h3><p>defer并行加载js文件，会按照页面上script标签的顺序执行async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行</p><h3 id="documen-write和-innerHTML的区别-1"><a href="#documen-write和-innerHTML的区别-1" class="headerlink" title="documen.write和 innerHTML的区别"></a>documen.write和 innerHTML的区别</h3><ul><li>document.write只能重绘整个页面</li><li>innerHTML可以重绘页面的一部分</li></ul><h3 id="那些操作会造成内存泄漏？"><a href="#那些操作会造成内存泄漏？" class="headerlink" title="那些操作会造成内存泄漏？"></a>那些操作会造成内存泄漏？</h3><ul><li>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在</li><li>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收</li><li>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏</li><li>闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</li></ul><h3 id="Javascript垃圾回收方法"><a href="#Javascript垃圾回收方法" class="headerlink" title="Javascript垃圾回收方法"></a>Javascript垃圾回收方法</h3><p><strong>标记清除（mark and sweep）</strong></p><blockquote><ul><li>这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”</li><li>垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了</li></ul></blockquote><p><strong>引用计数(reference counting)</strong></p><blockquote><p>在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间</p></blockquote><h3 id="用过哪些设计模式？"><a href="#用过哪些设计模式？" class="headerlink" title="用过哪些设计模式？"></a>用过哪些设计模式？</h3><p>工厂模式：</p><ul><li>主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字。将所有实例化的代码集中在一个位置防止代码重复</li><li>工厂模式解决了重复实例化的问题 ，但还有一个问题,那就是识别问题，因为根本无法 搞清楚他们到底是哪个对象的实例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function createObject(name,age,profession)&#123;//集中实例化的函数var obj = new Object();</span><br><span class="line">    obj.name = name;</span><br><span class="line">    obj.age = age;</span><br><span class="line">    obj.profession = profession;</span><br><span class="line">    obj.move = function () &#123;</span><br><span class="line">        return this.name + &apos; at &apos; + this.age + &apos; engaged in &apos; + this.profession;</span><br><span class="line">    &#125;;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line">var test1 = createObject(&apos;trigkit4&apos;,22,&apos;programmer&apos;);//第一个实例var test2 = createObject(&apos;mike&apos;,25,&apos;engineer&apos;);//第二个实例</span><br></pre></td></tr></table></figure><ul><li><p>构造函数模式</p><p>使用构造函数的方法 ，即解决了重复实例化的问题 ，又解决了对象识别的问题，该模式与工厂模式的不同之处在于</p></li><li><p>构造函数方法没有显示的创建对象 (new Object());</p></li><li><p>直接将属性和方法赋值给 this 对象;</p></li><li><p>没有 renturn 语句</p></li></ul><h3 id="实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制"><a href="#实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制" class="headerlink" title="实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制"></a>实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.clone = function()&#123;</span><br><span class="line">    var o = this.constructor === Array ? [] : &#123;&#125;;</span><br><span class="line">    for(var e in this)&#123;</span><br><span class="line">    o[e] = typeof this[e] === &quot;object&quot; ? this[e].clone() : this[e];</span><br><span class="line">    &#125;</span><br><span class="line">  return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="说说严格模式的限制"><a href="#说说严格模式的限制" class="headerlink" title="说说严格模式的限制"></a>说说严格模式的限制</h3><ul><li><p>严格模式主要有以下限制：</p></li><li><p>变量必须声明后再使用</p></li><li><p>函数的参数不能有同名属性，否则报错</p></li><li><p>不能使用with语句</p></li><li><p>不能对只读属性赋值，否则报错</p></li><li><p>不能使用前缀0表示八进制数，否则报错</p></li><li><p>不能删除不可删除的属性，否则报错</p></li><li><p>不能删除变量delete prop，会报错，只能删除属性delete global[prop]</p></li><li><p>eval不会在它的外层作用域引入变量</p></li><li><p>eval和arguments不能被重新赋值</p></li><li><p>arguments不会自动反映函数参数的变化</p></li><li><p>不能使用arguments.callee</p></li><li><p>不能使用arguments.caller</p></li><li><p>禁止this指向全局对象</p></li><li><p>不能使用fn.caller和fn.arguments获取函数调用的堆栈</p></li><li><p>增加了保留字（比如protected、static和interface）</p></li></ul><h3 id="如何删除一个cookie"><a href="#如何删除一个cookie" class="headerlink" title="如何删除一个cookie"></a>如何删除一个cookie</h3><ul><li>将时间设为当前时间往前一点</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var date = new Date();</span><br><span class="line">date.setDate(date.getDate() - 1);//真正的删除</span><br></pre></td></tr></table></figure><p>setDate()方法用于设置一个月的某一天</p><ul><li>expires的设置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = &apos;user=&apos;+ encodeURIComponent(&apos;name&apos;)  + &apos;;expires = &apos; + new Date(0)</span><br></pre></td></tr></table></figure><h3 id="attribute和property的区别是什么？"><a href="#attribute和property的区别是什么？" class="headerlink" title="attribute和property的区别是什么？"></a>attribute和property的区别是什么？</h3><ul><li><p>attribute是dom元素在文档中作为html标签拥有的属性；</p></li><li><p>property就是dom元素在js中作为对象拥有的属性。</p></li><li><p>对于html的标准属性来说，attribute和property是同步的，是会自动更新的</p></li><li><p>但是对于自定义的属性来说，他们是不同步的</p></li></ul><h3 id="页面编码和被请求的资源编码如果不一致如何处理？"><a href="#页面编码和被请求的资源编码如果不一致如何处理？" class="headerlink" title="页面编码和被请求的资源编码如果不一致如何处理？"></a>页面编码和被请求的资源编码如果不一致如何处理？</h3><ul><li>后端响应头设置 charset </li><li>前端页面<code>&lt;meta&gt;</code>设置 charset</li></ul><h3 id="把-lt-script-gt-放在-lt-body-gt-之前和之后有什么区别？浏览器会如何解析它们？"><a href="#把-lt-script-gt-放在-lt-body-gt-之前和之后有什么区别？浏览器会如何解析它们？" class="headerlink" title="把&lt;script&gt;放在&lt;/body&gt;之前和之后有什么区别？浏览器会如何解析它们？"></a>把<code>&lt;script&gt;</code>放在<code>&lt;/body&gt;</code>之前和之后有什么区别？浏览器会如何解析它们？</h3><ul><li>按照HTML标准，在<code>&lt;/body&gt;</code>结束后出现<code>&lt;script&gt;</code>或任何元素的开始标签，都是解析错误</li><li>虽然不符合HTML标准，但浏览器会自动容错，使实际效果与写在<code>&lt;/body&gt;</code>之前没有区别</li><li>浏览器的容错机制会忽略<script>之前的<code>&lt;/body&gt;</code>，视作<code>&lt;script&gt;</code>仍在 body 体内。省略<code>&lt;/body&gt;</code>和<code>&lt;/html&gt;</code>闭合标签符合HTML标准，服务器可以利用这一标准尽可能少输出内容</li></ul><h3 id="延迟加载（异步加载）JS的方式有哪些？"><a href="#延迟加载（异步加载）JS的方式有哪些？" class="headerlink" title="延迟加载（异步加载）JS的方式有哪些？"></a>延迟加载（异步加载）JS的方式有哪些？</h3><ul><li>设置<code>&lt;script&gt;</code>属性 defer="defer" （脚本将在页面完成解析时执行）</li><li>设置<code>&lt;script&gt;</code>属性 async="async" （一旦脚本可用，则会异步执行）</li><li>动态创建 script DOM：document.createElement('script');</li><li>XmlHttpRequest 脚本注入</li><li>延迟加载工具 LazyLoad</li><li>异步加载库 LABjs</li><li>模块加载器 Sea.js</li></ul><h3 id="JavaScript-对象生命周期的理解？"><a href="#JavaScript-对象生命周期的理解？" class="headerlink" title="JavaScript 对象生命周期的理解？"></a>JavaScript 对象生命周期的理解？</h3><ul><li>当创建一个对象时，JavaScript 会自动为该对象分配适当的内存</li><li>垃圾回收器定期扫描对象，并计算引用了该对象的其他对象的数量</li><li>如果被引用数量为 0，或惟一引用是循环的，那么该对象的内存即可回收</li></ul><h3 id="哪些操作会造成内存泄漏？-1"><a href="#哪些操作会造成内存泄漏？-1" class="headerlink" title="哪些操作会造成内存泄漏？"></a>哪些操作会造成内存泄漏？</h3><ul><li><p>JavaScript 内存泄露指对象在不需要使用它时仍然存在，导致占用的内存不能使用或回收</p></li><li><p>未使用 var 声明的全局变量</p></li><li><p>闭包函数(Closures)</p></li><li><p>循环引用(两个对象相互引用)</p></li><li><p>控制台日志(console.log)</p></li><li><p>移除存在绑定事件的DOM元素(IE)</p></li></ul><h3 id="require-与-import-的区别"><a href="#require-与-import-的区别" class="headerlink" title="require 与 import 的区别"></a>require 与 import 的区别</h3><p>两者的加载方式不同、规范不同</p><p>第一、两者的加载方式不同，require 是在运行时加载，而 import 是在编译时加载</p><p>require('./a')(); // a 模块是一个函数，立即执行 a 模块函数</p><p>var data = require('./a').data; // a 模块导出的是一个对象</p><p>var a = require('./a')[0]; // a 模块导出的是一个数组 ======> 哪都行</p><p>import $ from 'jquery';</p><p>import * as _ from '_';</p><p>import {a,b,c} from './a';</p><p>import {default as alias, a as a_a, b, c} from './a'; ======>用在开头</p><p>第二、规范不同，require 是 CommonJS/AMD 规范，import 是 ESMAScript6+规范</p><p>第三、require 特点：社区方案，提供了服务器/浏览器的模块加载方案。非语言层面的标准。只能在运行时确定模块的依赖关系及输入/输出的变量，无法进行静态优化。</p><p>import 特点：语言规格层面支持模块功能。支持编译时静态分析，便于 JS 引入宏和类型检验。动态绑定。</p><p><a href="https://zhidao.baidu.com/question/1180348878138910499.html">https://zhidao.baidu.com/question/1180348878138910499.html</a>)</p><h3 id="复杂数据类型如何转变为字符串-1"><a href="#复杂数据类型如何转变为字符串-1" class="headerlink" title="复杂数据类型如何转变为字符串"></a>复杂数据类型如何转变为字符串</h3><ul><li>首先，会调用 valueOf 方法，如果方法的返回值是一个基本数据类型，就返回这个值，</li><li>如果调用 valueOf 方法之后的返回值仍旧是一个复杂数据类型，就会调用该对象的 toString 方法，</li><li>如果 toString 方法调用之后的返回值是一个基本数据类型，就返回这个值，</li><li>如果 toString 方法调用之后的返回值是一个复杂数据类型，就报一个错误。</li></ul><p>解析：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj + <span class="string">""</span>); <span class="comment">//'1'</span></span><br><span class="line"><span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj + <span class="string">""</span>); <span class="comment">//'[object Object]';</span></span><br><span class="line"><span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj + <span class="string">""</span>); <span class="comment">//'1';</span></span><br><span class="line"><span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj + <span class="string">""</span>); <span class="comment">// 报错 Uncaught TypeError: Cannot convert object to primitive value</span></span><br></pre></td></tr></table></figure><p>拓展：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="keyword">new</span> <span class="built_in">Object</span>(), <span class="keyword">new</span> <span class="built_in">Date</span>(), <span class="keyword">new</span> <span class="built_in">RegExp</span>(), <span class="keyword">new</span> <span class="built_in">String</span>(), <span class="keyword">new</span> <span class="built_in">Number</span>(), <span class="keyword">new</span> <span class="built_in">Boolean</span>(), <span class="keyword">new</span> <span class="built_in">Function</span>(), <span class="keyword">new</span> <span class="built_in">Array</span>(), <span class="built_in">Math</span>] <span class="built_in">console</span>.log(arr.length) <span class="comment">// 9</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">arr[i].valueOf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line">arr[i].toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'toString'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr[i] + <span class="string">''</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、若 return [1,2,3]处为 return "valueof"，得到的返回值是 valueof toString 7valueof<br>说明：其他八种复杂数据类型是先调用 valueOf 方法，时间对象是先调用 toString 方法</p><p>2、改成 return [1,2,3]，得到的返回值是 9toString<br>说明：执行 valueof 后都来执行 toString</p><h3 id="JS-哪些操作会造成内存泄露"><a href="#JS-哪些操作会造成内存泄露" class="headerlink" title="JS 哪些操作会造成内存泄露"></a>JS 哪些操作会造成内存泄露</h3><p>1）意外的全局变量引起的内存泄露</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leak</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  leak = <span class="string">"xxx"</span>; <span class="comment">//leak成为一个全局变量，不会被回收</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）闭包引起的内存泄露</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">document</span>.createElement(<span class="string">"XXX"</span>);</span><br><span class="line">  obj.οnclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//Even if it's a empty function</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包可以维持函数内局部变量，使其得不到释放。 上例定义事件回调时，由于是函数内定义函数，并且内部函数--事件回调的引用外暴了，形成了闭包。<br>解决之道，将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对 dom 的引用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将事件处理函数定义在外部</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onclickHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">document</span>.createElement(<span class="string">"XXX"</span>);</span><br><span class="line">  obj.οnclick = onclickHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在定义事件处理函数的外部函数中，删除对dom的引用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">document</span>.createElement(<span class="string">"XXX"</span>);</span><br><span class="line">  obj.οnclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//Even if it's a empty function</span></span><br><span class="line">  &#125;;</span><br><span class="line">  obj = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）没有清理的 DOM 元素引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements=&#123;</span><br><span class="line">    button: <span class="built_in">document</span>.getElementById(<span class="string">"button"</span>),</span><br><span class="line">    image: <span class="built_in">document</span>.getElementById(<span class="string">"image"</span>),</span><br><span class="line">    text: <span class="built_in">document</span>.getElementById(<span class="string">"text"</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    image.src=<span class="string">"http://some.url/image"</span>;</span><br><span class="line">    button.click():</span><br><span class="line">    <span class="built_in">console</span>.log(text.innerHTML)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeButton</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">'button'</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）被遗忘的定时器或者回调</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someResouce = getData();</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> node = <span class="built_in">document</span>.getElementById(<span class="string">"Node"</span>);</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    node.innerHTML = <span class="built_in">JSON</span>.stringify(someResouce);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>这样的代码很常见, 如果 id 为 Node 的元素从 DOM 中移除, 该定时器仍会存在, 同时, 因为回调函数中包含对 someResource 的引用, 定时器外面的 someResource 也不会被释放。</p><p>5）子元素存在引起的内存泄露</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="../../images/js007.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>黄色是指直接被 js 变量所引用，在内存里，红色是指间接被 js 变量所引用，如上图，refB 被 refA 间接引用，导致即使 refB 变量被清空，也是不会被回收的子元素 refB 由于 parentNode 的间接引用，只要它不被删除，它所有的父元素（图中红色部分）都不会被删除。</p><p>6）IE7/8 引用计数使用循环引用产生的问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> b = &#123;&#125;;</span><br><span class="line">  a.pro = b;</span><br><span class="line">  b.pro = a;</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><p>fn()执行完毕后，两个对象都已经离开环境，在标记清除方式下是没有问题的，但是在引用计数策略下，因为 a 和 b 的引用次数不为 0，所以不会被垃圾回收器回收内存，如果 fn 函数被大量调用，就会造成内存泄漏。在 IE7 与 IE8 上，内存直线上升。<br>IE 中有一部分对象并不是原生 js 对象。例如，其内存泄漏 DOM 和 BOM 中的对象就是使用 C++以 COM 对象的形式实现的，而 COM 对象的垃圾回收机制采用的就是引用计数策略。因此，即使 IE 的 js 引擎采用标记清除策略来实现，但 js 访问的 COM 对象依然是基于引用计数策略的。换句话说，只要在 IE 中涉及 COM 对象，就会存在循环引用的问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"some_element"</span>);</span><br><span class="line"><span class="keyword">var</span> myObject = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">myObject.e = element;</span><br><span class="line">element.o = myObject;</span><br></pre></td></tr></table></figure><p>上面的例子在一个 DOM 元素（element)与一个原生 js 对象（myObject)之间创建了循环引用。其中，变量 myObject 有一个名为 e 的属性指向 element 对象；而变量 element 也有一个属性名为 o 回指 myObject。由于存在这个循环引用，即使例子中的 DOM 从页面中移除，它也永远不会被回收。</p><p>看上面的例子，有人会觉得太弱了，谁会做这样无聊的事情，但是其实我们经常会这样做</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.οnlοad=<span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj=<span class="built_in">document</span>.getElementById(<span class="string">"element"</span>):</span><br><span class="line">  obj.οnclick=<span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码看起来没什么问题，但是 obj 引用了 document.getElementById(“element”)，而 document.getElementById(“element”)的 onclick 方法会引用外部环境中的变量，自然也包括 obj，是不是很隐蔽啊。</p><p>最简单的解决方式就是自己手工解除循环引用，比如刚才的函数可以这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">myObject.element=<span class="literal">null</span>;</span><br><span class="line">element.o=<span class="literal">null</span>;</span><br><span class="line"><span class="built_in">window</span>.οnlοad=<span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj=<span class="built_in">document</span>.getElementById(<span class="string">"element"</span>):</span><br><span class="line">  obj.οnclick=<span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  obj=<span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾回收器下次运行时，就会删除这些值并回收它们占用的内存。 要注意的是，IE9+并不存在循环引用导致 Dom 内存泄漏问题，可能是微软做了优化，或者 Dom 的回收方式已经改变</p><h3 id="JS-的回收机制"><a href="#JS-的回收机制" class="headerlink" title="JS 的回收机制"></a>JS 的回收机制</h3><p>JavaScript 垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收系统（GC）会按照固定的时间间隔,周期性的执行。</p><p>到底哪个变量是没有用的？所以垃圾收集器必须跟踪到底哪个变量没用，对于不再有用的变量打上标记，以备将来收回其内存。用于标记的无用变量的策略可能因实现而有所区别，通常情况下有两种实现方式：标记清除和引用计数。引用计数不太常用，标记清除较为常用。</p><h4 id="标记清除（mark-and-sweep）"><a href="#标记清除（mark-and-sweep）" class="headerlink" title="标记清除（mark and sweep）"></a>标记清除（mark and sweep）</h4><p>js 中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>; <span class="comment">//被标记，进入环境</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">20</span>; <span class="comment">//被标记，进入环境</span></span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">//执行完毕之后a、b又被标记离开环境，被回收</span></span><br></pre></td></tr></table></figure><h4 id="引用计数-reference-counting"><a href="#引用计数-reference-counting" class="headerlink" title="引用计数(reference counting)"></a>引用计数(reference counting)</h4><p>引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值（function object array）赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为 0 的值所占用的内存。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = &#123;&#125;; <span class="comment">//a的引用次数为0</span></span><br><span class="line">  <span class="keyword">var</span> b = a; <span class="comment">//a的引用次数加1，为1</span></span><br><span class="line">  <span class="keyword">var</span> c = a; <span class="comment">//a的引用次数加1，为2</span></span><br><span class="line">  <span class="keyword">var</span> b = &#123;&#125;; <span class="comment">//a的引用次数减1，为1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何分析内存的使用情况"><a href="#如何分析内存的使用情况" class="headerlink" title="如何分析内存的使用情况"></a>如何分析内存的使用情况</h3><p>Google Chrome 浏览器提供了非常强大的 JS 调试工具，Memory 视图 profiles 视图让你可以对 JavaScript 代码运行时的内存进行快照，并且可以比较这些内存快照。它还让你可以记录一段时间内的内存分配情况。在每一个结果视图中都可以展示不同类型的列表，但是对我们最有用的是 summary 列表和 comparison 列表。 summary 视图提供了不同类型的分配对象以及它们的合计大小：shallow size （一个特定类型的所有对象的总和）和 retained size （shallow size 加上保留此对象的其它对象的大小）。distance 显示了对象到达 GC 根（校者注：最初引用的那块内存，具体内容可自行搜索该术语）的最短距离。 comparison 视图提供了同样的信息但是允许对比不同的快照。这对于找到泄漏很有帮助。</p><p>5、怎样避免内存泄露</p><p>1）减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收；</p><p>2）注意程序逻辑，避免“死循环”之类的 ；</p><p>3）避免创建过多的对象 原则：不用了的东西要及时归还。</p><p><a href="https://blog.csdn.net/michael8512/article/details/77888000">参考</a></p><h3 id="发布订阅设计模式"><a href="#发布订阅设计模式" class="headerlink" title="发布订阅设计模式"></a>发布订阅设计模式</h3><p>答案：发布/订阅模式(Publish Subscribe Pattern)属于设计模式中的行为(Behavioral Patterns)</p><p>解析：<a href="https://www.jianshu.com/p/c391c77a8771">参考</a></p><h3 id="Zepto-的点透问题如何解决？"><a href="#Zepto-的点透问题如何解决？" class="headerlink" title="Zepto 的点透问题如何解决？"></a>Zepto 的点透问题如何解决？</h3><p>方案一：来得很直接 github 上有个 fastclick 可以完美解决<a href="https://github.com/ftlabs/fastclick">https://github.com/ftlabs/fastclick</a></p><p>引入 fastclick.js，因为 fastclick 源码不依赖其他库所以你可以在原生的 js 前直接加上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(</span><br><span class="line">  <span class="string">"load"</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    FastClick.attach(<span class="built_in">document</span>.body);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>或者有 zepto 或者 jqm 的 js 里面加上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  FastClick.attach(<span class="built_in">document</span>.body);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当然 require 的话就这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> FastClick = <span class="built_in">require</span>(<span class="string">"fastclick"</span>);</span><br><span class="line">FastClick.attach(<span class="built_in">document</span>.body, options);</span><br></pre></td></tr></table></figure><p>方案二：用 touchend 代替 tap 事件并阻止掉 touchend 的默认行为 preventDefault()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#cbFinish"</span>).on(<span class="string">"touchend"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//很多处理比如隐藏什么的</span></span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>方案三：延迟一定的时间(300ms+)来处理事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#cbFinish"</span>).on(<span class="string">"tap"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//很多处理比如隐藏什么的</span></span><br><span class="line">  &#125;, <span class="number">320</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这种方法其实很好，可以和 fadeInIn/fadeOut 等动画结合使用，可以做出过渡效果</p><p>理论上上面的方法可以完美的解决 tap 的点透问题，如果真的不行，用 click</p><p>解析：</p><h3 id="“点透”是什么？"><a href="#“点透”是什么？" class="headerlink" title="“点透”是什么？"></a>“点透”是什么？</h3><p>你可能碰到过在列表页面上创建一个弹出层，弹出层有个关闭的按钮，你点了这个按钮关闭弹出层后后，这个按钮正下方的内容也会执行点击事件（或打开链接）。这个被定义为这是一个“点透”现象。</p><p>2、为什么会出现点透呢？</p><p><a href="https://www.cnblogs.com/axl234/p/5554281.html">参考</a></p><h3 id="移动端最小触控区域是多大？"><a href="#移动端最小触控区域是多大？" class="headerlink" title="移动端最小触控区域是多大？"></a>移动端最小触控区域是多大？</h3><p>苹果推荐是 44pt x 44pt</p><p>解析：<a href="https://developer.apple.com/ios/human-interface-guidelines/visual-design/layout/">参考</a></p><h3 id="移动端的点击事件的有延迟，时间是多久，为什么会有？-怎么解决这个延时？-1"><a href="#移动端的点击事件的有延迟，时间是多久，为什么会有？-怎么解决这个延时？-1" class="headerlink" title="移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？"></a>移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？</h3><ol><li>300 毫秒</li><li>因为浏览器捕获第一次单击后，会先等待一段时间，如果在这段时间区间里用户未进行下一次点击，则浏览器会做单击事件的处理。如果这段时间里用户进行了第二次单击操作，则浏览器会做双击事件处理。</li><li>推荐 fastclick.js</li></ol><h3 id="如何获取浏览器版本信息"><a href="#如何获取浏览器版本信息" class="headerlink" title="如何获取浏览器版本信息"></a>如何获取浏览器版本信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.navigator.userAgent</span><br></pre></td></tr></table></figure><h3 id="调试工具的使用"><a href="#调试工具的使用" class="headerlink" title="调试工具的使用"></a>调试工具的使用</h3><p>调试模式中的按钮作用<br>F8 跳出断点调试模式<br>F10、F11 代码的逐行调试</p><p>进入断点调试模式的 方法</p><ol><li>在浏览器当中打断点</li><li>直接在代码中加 debugger</li></ol><h3 id="foo-foo-bar-，这行代码是什么意思？为什么要这样写？"><a href="#foo-foo-bar-，这行代码是什么意思？为什么要这样写？" class="headerlink" title="foo = foo||bar ，这行代码是什么意思？为什么要这样写？"></a>foo = foo||bar ，这行代码是什么意思？为什么要这样写？</h3><p>这种写法称为短路表达式</p><p>解析：</p><p>相当于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">  foo = foo;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  foo = bar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：常用于函数参数的空判断</p><h3 id="列举浏览器对象模型-BOM-里常用的至少-4-个对象，并列举-window-对象的常用方法至少-5-个？"><a href="#列举浏览器对象模型-BOM-里常用的至少-4-个对象，并列举-window-对象的常用方法至少-5-个？" class="headerlink" title="列举浏览器对象模型 BOM 里常用的至少 4 个对象，并列举 window 对象的常用方法至少 5 个？"></a>列举浏览器对象模型 BOM 里常用的至少 4 个对象，并列举 window 对象的常用方法至少 5 个？</h3><p>对象：Window，document，location，screen，history，navigator。<br>方法：Alert（），confirm（），prompt（），open（），close（）。</p><h3 id="class-forname-的作用-为什么要用"><a href="#class-forname-的作用-为什么要用" class="headerlink" title="class.forname 的作用?为什么要用?"></a>class.forname 的作用?为什么要用?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、获取Class对象的方式：类名.class、对象.getClass()、Class.forName(“类名”);</span><br><span class="line">2、通过Class对象自审</span><br><span class="line">3、动态调用方法</span><br></pre></td></tr></table></figure><h3 id="外部-JS-文件出现中文字符，会出现什么问题，怎么解决？"><a href="#外部-JS-文件出现中文字符，会出现什么问题，怎么解决？" class="headerlink" title="外部 JS 文件出现中文字符，会出现什么问题，怎么解决？"></a>外部 JS 文件出现中文字符，会出现什么问题，怎么解决？</h3><p>会出现乱码，加 charset=”GB2312”;</p><h3 id="在-JS-中有哪些会被隐式转换为-false"><a href="#在-JS-中有哪些会被隐式转换为-false" class="headerlink" title="在 JS 中有哪些会被隐式转换为 false"></a>在 JS 中有哪些会被隐式转换为 false</h3><p>Undefined、null、关键字 false、NaN、零、空字符串</p><h3 id="eval-是做什么的？-1"><a href="#eval-是做什么的？-1" class="headerlink" title="eval 是做什么的？"></a>eval 是做什么的？</h3><ol><li>它的功能是把对应的字符串解析成 JS 代码并运行</li><li>应该避免使用 eval，不安全，非常耗性能（2 次，一次解析成 js 语句，一次执行）</li></ol><h3 id="documen-write-和-innerHTML-的区别"><a href="#documen-write-和-innerHTML-的区别" class="headerlink" title="documen.write 和 innerHTML 的区别?"></a>documen.write 和 innerHTML 的区别?</h3><p>document.write 是重写整个 document, 写入内容是字符串的 html<br>innerHTML 是 HTMLElement 的属性，是一个元素的内部 html 内容</p><h3 id="javascript-代码中的-use-strict-是什么意思-使用它区别是什么？"><a href="#javascript-代码中的-use-strict-是什么意思-使用它区别是什么？" class="headerlink" title="javascript 代码中的"use strict";是什么意思 ? 使用它区别是什么？"></a>javascript 代码中的"use strict";是什么意思 ? 使用它区别是什么？</h3><p>意思是使用严格模式，使用严格模式，一些不规范的语法将不再支持</p><h3 id="前端-templating-Mustache-underscore-handlebars-是干嘛的-怎么用"><a href="#前端-templating-Mustache-underscore-handlebars-是干嘛的-怎么用" class="headerlink" title="前端 templating(Mustache, underscore, handlebars)是干嘛的, 怎么用?"></a>前端 templating(Mustache, underscore, handlebars)是干嘛的, 怎么用?</h3><ul><li>Web 模板引擎是为了使用户界面与业务数据（内容）分离而产生的，</li><li>Mustache 是一个 logic-less （轻逻辑）模板解析引擎，它的优势在于可以应用在 Javascript、PHP、Python、Perl 等多种编程语言中。</li><li>Underscore 封装了常用的 JavaScript 对象操作方法，用于提高开发效率。</li><li>Handlebars 是 JavaScript 一个语义模板库，通过对 view 和 data 的分离来快速构建 Web 模板。</li></ul><h3 id="说说写JavaScript的基本规范？"><a href="#说说写JavaScript的基本规范？" class="headerlink" title="说说写JavaScript的基本规范？"></a>说说写JavaScript的基本规范？</h3><p>1) 不要在同一行声明多个变量<br>2) 使用 ===或!==来比较true/false或者数值<br>3) switch必须带有default分支<br>4) 函数应该有返回值<br>5) for if else 必须使用大括号<br>6) 语句结束加分号<br>7) 命名要有意义，使用驼峰命名法</p><h3 id="jQuery使用建议"><a href="#jQuery使用建议" class="headerlink" title="jQuery使用建议"></a>jQuery使用建议</h3><p>1) 尽量减少对dom元素的访问和操作<br>2) 尽量避免给dom元素绑定多个相同类型的事件处理函数，可以将多个相同类型事件<br>处理函数合并到一个处理函数，通过数据状态来处理分支<br>3) 尽量避免使用toggle事件</p><h3 id="Ajax使用"><a href="#Ajax使用" class="headerlink" title="Ajax使用"></a>Ajax使用</h3><p>全称 ： Asynchronous Javascript And XML<br>所谓异步，就是向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。<br>创建Ajax的过程：<br>1) 创建XMLHttpRequest对象（异步调用对象）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br></pre></td></tr></table></figure><p>2) 创建新的Http请求（方法、URL、是否异步）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(‘get’,’example.php’,false);</span><br></pre></td></tr></table></figure><p>3) 设置响应HTTP请求状态变化的函数。<br>onreadystatechange事件中readyState属性等于4。响应的HTTP状态为200(OK)或者304(Not Modified)。<br>4) 发送http请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.send(data);</span><br></pre></td></tr></table></figure><p>5) 获取异步调用返回的数据<br>注意：<br>1) 页面初次加载时，尽量在web服务器一次性输出所有相关的数据，只在页面加载完成之后，用户进行操作时采用ajax进行交互。<br>2) 同步ajax在IE上会产生页面假死的问题。所以建议采用异步ajax。<br>3) 尽量减少ajax请求次数<br>4) ajax安全问题，对于敏感数据在服务器端处理，避免在客户端处理过滤。对于关键业务逻辑代码也必须放在服务器端处理。</p><h3 id="JavaScript有几种类型的值？你能画一下他们的内存图吗？-1"><a href="#JavaScript有几种类型的值？你能画一下他们的内存图吗？-1" class="headerlink" title="JavaScript有几种类型的值？你能画一下他们的内存图吗？"></a>JavaScript有几种类型的值？你能画一下他们的内存图吗？</h3><p>基本数据类型存储在栈中，引用数据类型（对象）存储在堆中，指针放在栈中。<br>两种类型的区别是：存储位置不同；原始数据类型直接存储在栈中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；引用数据类型存储在堆中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能<br>引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</p><h3 id="栈和堆的区别？"><a href="#栈和堆的区别？" class="headerlink" title="栈和堆的区别？"></a>栈和堆的区别？</h3><p>栈（stack）：由编译器自动分配释放，存放函数的参数值，局部变量等；<br>堆（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统释放。</p><h3 id="Javascript实现继承的几种方式"><a href="#Javascript实现继承的几种方式" class="headerlink" title="Javascript实现继承的几种方式"></a>Javascript实现继承的几种方式</h3><p>可以参考我的另一篇文章<a href="https://segmentfault.com/a/1190000013253890">JavaScript实现类与继承的方法（全面整理）</a></p><h3 id="Javascript创建对象的几种方式？"><a href="#Javascript创建对象的几种方式？" class="headerlink" title="Javascript创建对象的几种方式？"></a>Javascript创建对象的几种方式？</h3><p>可以参考我的另一篇文章<a href="https://segmentfault.com/a/1190000013253890">JavaScript实现类与继承的方法（全面整理）</a></p><h3 id="Javascript作用链域"><a href="#Javascript作用链域" class="headerlink" title="Javascript作用链域"></a>Javascript作用链域</h3><p>作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。<br>注意：JS没有块级作用域，若要形成块级作用域，可通过（function（）｛｝）（）；立即执行的形式实现。</p><h3 id="谈谈this的理解"><a href="#谈谈this的理解" class="headerlink" title="谈谈this的理解"></a>谈谈this的理解</h3><p>1) this总是指向函数的直接调用者（而非间接调用者）<br>2) 如果有new关键字，this指向new出来的那个对象<br>3) 在事件中，this指向目标元素，特殊的是IE的attachEvent中的this总是指向全局对象window。</p><h3 id="eval是做什么的？-2"><a href="#eval是做什么的？-2" class="headerlink" title="eval是做什么的？"></a>eval是做什么的？</h3><p>它的功能是把对应的字符串解析成JS代码并运行；应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。</p><h3 id="什么是window对象-什么是document对象"><a href="#什么是window对象-什么是document对象" class="headerlink" title="什么是window对象? 什么是document对象?"></a>什么是window对象? 什么是document对象?</h3><p>window对象代表浏览器中打开的一个窗口。document对象代表整个html文档。实际上，document对象是window对象的一个属性。</p><h3 id="null，undefined的区别？"><a href="#null，undefined的区别？" class="headerlink" title="null，undefined的区别？"></a>null，undefined的区别？</h3><p>null表示一个对象被定义了，但存放了空指针，转换为数值时为0。<br>undefined表示声明的变量未初始化，转换为数值时为NAN。<br>typeof(null) -- object;<br>typeof(undefined) -- undefined</p><h3 id="1-2-3-map-parseInt-答案是多少？"><a href="#1-2-3-map-parseInt-答案是多少？" class="headerlink" title="["1", "2", "3"].map(parseInt) 答案是多少？"></a>["1", "2", "3"].map(parseInt) 答案是多少？</h3><p>[1,NaN,NaN]</p><p>解析：<br>Array.prototype.map()<br>array.map(callback[, thisArg])<br>callback函数的执行规则<br>参数：自动传入三个参数<br>currentValue（当前被传递的元素）；<br>index（当前被传递的元素的索引）；<br>array（调用map方法的数组）</p><p>parseInt方法接收两个参数<br>第三个参数["1", "2", "3"]将被忽略。parseInt方法将会通过以下方式被调用<br>parseInt("1", 0)<br>parseInt("2", 1)<br>parseInt("3", 2)</p><p>parseInt的第二个参数radix为0时，ECMAScript5将string作为十进制数字的字符串解析；<br>parseInt的第二个参数radix为1时，解析结果为NaN；<br>parseInt的第二个参数radix在2—36之间时，如果string参数的第一个字符（除空白以外），不属于radix指定进制下的字符，解析结果为NaN。<br>parseInt("3", 2)执行时，由于"3"不属于二进制字符，解析结果为NaN。</p><h3 id="关于事件，IE与火狐的事件机制有什么区别？-如何阻止冒泡？"><a href="#关于事件，IE与火狐的事件机制有什么区别？-如何阻止冒泡？" class="headerlink" title="关于事件，IE与火狐的事件机制有什么区别？ 如何阻止冒泡？"></a>关于事件，IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</h3><p>IE为事件冒泡，Firefox同时支持事件捕获和事件冒泡。但并非所有浏览器都支持事件捕获。jQuery中使用<code>event.stopPropagation()</code>方法可阻止冒泡;（旧IE的方法 <code>ev.cancelBubble = true;</code>）</p><h3 id="什么是闭包（closure），为什么要用它？"><a href="#什么是闭包（closure），为什么要用它？" class="headerlink" title="什么是闭包（closure），为什么要用它？"></a>什么是闭包（closure），为什么要用它？</h3><p>闭包指的是一个函数可以访问另一个函数作用域中变量。常见的构造方法，是在一个函数内部定义另外一个函数。内部函数可以引用外层的变量；外层变量不会被垃圾回收机制回收。<br>注意，闭包的原理是作用域链，所以闭包访问的上级作用域中的变量是个对象，其值为其运算结束后的最后一个值。<br>优点：避免全局变量污染。缺点：容易造成内存泄漏。<br>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function makeFunc() &#123;</span><br><span class="line">    var name = &quot;Mozilla&quot;;</span><br><span class="line">    function displayName() &#123;</span><br><span class="line">        console.log(name); </span><br><span class="line">    &#125;</span><br><span class="line">    return displayName;</span><br><span class="line">&#125;</span><br><span class="line">var myFunc = makeFunc();</span><br><span class="line">myFunc();   //输出Mozilla</span><br></pre></td></tr></table></figure><p>myFunc 变成一个 闭包。闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。在我们的例子中，myFunc 是一个闭包，由 displayName 函数和闭包创建时存在的 "Mozilla" 字符串形成。</p><h3 id="javascript-代码中的-use-strict-是什么意思-使用它区别是什么？-1"><a href="#javascript-代码中的-use-strict-是什么意思-使用它区别是什么？-1" class="headerlink" title="javascript 代码中的"use strict";是什么意思 ? 使用它区别是什么？"></a>javascript 代码中的"use strict";是什么意思 ? 使用它区别是什么？</h3><p>除了正常模式运行外，ECMAscript添加了第二种运行模式：“严格模式”。<br>作用：<br>1) 消除js不合理，不严谨地方，减少怪异行为<br>2) 消除代码运行的不安全之处，<br>3) 提高编译器的效率，增加运行速度<br>4) 为未来的js新版本做铺垫。</p><h3 id="如何判断一个对象是否属于某个类？-1"><a href="#如何判断一个对象是否属于某个类？-1" class="headerlink" title="如何判断一个对象是否属于某个类？"></a>如何判断一个对象是否属于某个类？</h3><p>使用instanceof 即if(a instanceof Person){alert('yes');}</p><h3 id="Javascript中，执行时对象查找时，永远不会去查找原型的函数？"><a href="#Javascript中，执行时对象查找时，永远不会去查找原型的函数？" class="headerlink" title="Javascript中，执行时对象查找时，永远不会去查找原型的函数？"></a>Javascript中，执行时对象查找时，永远不会去查找原型的函数？</h3><p>Object.hasOwnProperty(proName)：是用来判断一个对象是否有你给出名称的属性。不过需要注意的是，此方法无法检查该对象的原型链中是否具有该属性，该属性必须是对象本身的一个成员。</p><h3 id="对JSON的了解？"><a href="#对JSON的了解？" class="headerlink" title="对JSON的了解？"></a>对JSON的了解？</h3><p>全称：JavaScript Object Notation<br>JSON中对象通过“{}”来标识，一个“{}”代表一个对象，如{“AreaId”:”123”}，对象的值是键值对的形式（key：value）。JSON是JS的一个严格的子集，一种轻量级的数据交换格式，类似于xml。数据格式简单，易于读写，占用带宽小。<br>两个函数：<br>JSON.parse(str)<br>解析JSON字符串 把JSON字符串变成JavaScript值或对象<br>JSON.stringify(obj)<br>将一个JavaScript值(对象或者数组)转换为一个 JSON字符串<br>eval('('＋json＋')')<br>用eval方法注意加括号 而且这种方式更容易被攻击</p><h3 id="JS延迟加载的方式有哪些？"><a href="#JS延迟加载的方式有哪些？" class="headerlink" title="JS延迟加载的方式有哪些？"></a>JS延迟加载的方式有哪些？</h3><p>JS的延迟加载有助与提高页面的加载速度。<br>defer和async、动态创建DOM方式（用得最多）、按需异步载入JS<br>defer：延迟脚本。立即下载，但延迟执行（延迟到整个页面都解析完毕后再运行），按照脚本出现的先后顺序执行。<br>async：异步脚本。下载完立即执行，但不保证按照脚本出现的先后顺序执行。</p><h3 id="同步和异步的区别-1"><a href="#同步和异步的区别-1" class="headerlink" title="同步和异步的区别?"></a>同步和异步的区别?</h3><p>同步的概念在操作系统中：不同进程协同完成某项工作而先后次序调整（通过阻塞、唤醒等方式），同步强调的是顺序性，谁先谁后。异步不存在顺序性。<br>同步：浏览器访问服务器，用户看到页面刷新，重新发请求，等请求完，页面刷新，新内容出现，用户看到新内容之后进行下一步操作。<br>异步：浏览器访问服务器请求，用户正常操作，浏览器在后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。</p><h3 id="什么是跨域问题-，如何解决跨域问题"><a href="#什么是跨域问题-，如何解决跨域问题" class="headerlink" title="什么是跨域问题 ，如何解决跨域问题?"></a>什么是跨域问题 ，如何解决跨域问题?</h3><p>可以参考我的另一篇文章<a href="https://segmentfault.com/a/1190000013278814">什么是跨域以及几种简单解决方案</a></p><h3 id="页面编码和被请求的资源编码如果不一致如何处理？-1"><a href="#页面编码和被请求的资源编码如果不一致如何处理？-1" class="headerlink" title="页面编码和被请求的资源编码如果不一致如何处理？"></a>页面编码和被请求的资源编码如果不一致如何处理？</h3><p>若请求的资源编码，如外引js文件编码与页面编码不同。可根据外引资源编码方式定义为 charset="utf-8"或"gbk"。<br>比如：<a href="http://www.yyy.com/a.html">http://www.yyy.com/a.html</a> 中嵌入了一个<a href="http://www.xxx.com/test.js">http://www.xxx.com/test.js</a><br>a.html 的编码是gbk或gb2312的。 而引入的js编码为utf-8的 ，那就需要在引入的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://www.xxx.com/test.js&amp;quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="模块化开发怎么做？-1"><a href="#模块化开发怎么做？-1" class="headerlink" title="模块化开发怎么做？"></a>模块化开发怎么做？</h3><p>模块化开发指的是在解决某一个复杂问题或者一系列问题时，依照一种分类的思维把问题进行系统性的分解。模块化是一种将复杂系统分解为代码结构更合理，可维护性更高的可管理的模块方式。对于软件行业：系统被分解为一组高内聚，低耦合的模块。<br>（1）定义封装的模块<br>（2）定义新模块对其他模块的依赖<br>（3）可对其他模块的引入支持。在JavaScript中出现了一些非传统模块开发方式的规范。 CommonJS的模块规范，AMD（Asynchronous Module Definition），CMD（Common Module Definition）等。AMD是异步模块定义，所有的模块将被异步加载，模块加载不影响后边语句运行。</p><h3 id="AMD（Modules-Asynchronous-Definition）、CMD（Common-Module-Definition）规范区别？"><a href="#AMD（Modules-Asynchronous-Definition）、CMD（Common-Module-Definition）规范区别？" class="headerlink" title="AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？"></a>AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？</h3><p>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。<br>区别：<br>1) 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。<br>2) CMD 推崇依赖就近，AMD 推崇依赖前置。<br>3) AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// CMD</span><br><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">    var a = require(&apos;./a&apos;)</span><br><span class="line">    a.doSomething()</span><br><span class="line">    // 此处略去 100 行</span><br><span class="line">    var b = require(&apos;./b&apos;) // 依赖可以就近书写</span><br><span class="line">    b.doSomething()</span><br><span class="line">&#125;)</span><br><span class="line">// AMD 默认推荐</span><br><span class="line">define([&apos;./a&apos;, &apos;./b&apos;], function(a, b) &#123; // 依赖必须一开始就写好</span><br><span class="line">    a.doSomething();</span><br><span class="line">    // 此处略去 100 行</span><br><span class="line">    b.doSomething();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）"><a href="#requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）" class="headerlink" title="requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）"></a>requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）</h3><p>核心是js的加载模块，通过正则匹配模块以及模块的依赖关系，保证文件加载的先后顺序，根据文件的路径对加载过的文件做了缓存。</p><h3 id="call和apply"><a href="#call和apply" class="headerlink" title="call和apply"></a>call和apply</h3><p>call（）方法和apply（）方法的作用相同，动态改变某个类的某个方法的运行环境。他们的区别在于接收参数的方式不同。</p><p>在使用call（）方法时，传递给函数的参数必须逐个列举出来。</p><p>使用apply（）时，传递给函数的是参数数组。</p><h3 id="documen-write和-innerHTML的区别-2"><a href="#documen-write和-innerHTML的区别-2" class="headerlink" title="documen.write和 innerHTML的区别"></a>documen.write和 innerHTML的区别</h3><p>document.write()只能重绘整个页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">       document.write(&apos;&lt;p&gt;5 secs later&lt;/p&gt;&apos;);</span><br><span class="line">&#125;, 5000);</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function() &#123; document.write(&quot;HI&quot;);</span><br></pre></td></tr></table></figure><p>innerHTML可以重绘页面的一部分</p><h3 id="回流与重绘"><a href="#回流与重绘" class="headerlink" title="回流与重绘"></a>回流与重绘</h3><p>当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树。完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘</p><h3 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h3><p>（1）创建新节点<br>createDocumentFragment() //创建一个DOM片段<br>createElement() //创建一个具体的元素<br>createTextNode() //创建一个文本节点<br>（2）添加、移除、替换、插入<br>appendChild()<br>removeChild()<br>replaceChild()<br>insertBefore() //在已有的子节点前插入一个新的子节点<br>（3）查找<br>getElementsByTagName() //通过标签名称<br>getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)<br>getElementById() //通过元素Id，唯一性</p><h3 id="数组对象有哪些原生方法，列举一下"><a href="#数组对象有哪些原生方法，列举一下" class="headerlink" title="数组对象有哪些原生方法，列举一下"></a>数组对象有哪些原生方法，列举一下</h3><p>pop、push、shift、unshift、splice、reverse、sort、concat、join、slice、toString、indexOf、lastIndexOf、reduce、reduceRight<br>forEach、map、filter、every、some</p><h3 id="那些操作会造成内存泄漏"><a href="#那些操作会造成内存泄漏" class="headerlink" title="那些操作会造成内存泄漏"></a>那些操作会造成内存泄漏</h3><p>全局变量、闭包、DOM清空或删除时，事件未清除、子元素存在引用</p><h3 id="响应事件"><a href="#响应事件" class="headerlink" title="响应事件"></a>响应事件</h3><p>onclick鼠标点击某个对象；onfocus获取焦点；onblur失去焦点；onmousedown鼠标被按下</p><h3 id="flash和js通过什么类如何交互"><a href="#flash和js通过什么类如何交互" class="headerlink" title="flash和js通过什么类如何交互?"></a>flash和js通过什么类如何交互?</h3><p>Flash提供了ExternalInterface接口与JavaScript通信，ExternalInterface有两个方法，call和addCallback，call的作用是让Flash调用js里的方法，addCallback是用来注册flash函数让js调用。</p><h3 id="Flash与Ajax各自的优缺点？"><a href="#Flash与Ajax各自的优缺点？" class="headerlink" title="Flash与Ajax各自的优缺点？"></a>Flash与Ajax各自的优缺点？</h3><p>Flash：适合处理多媒体、矢量图形、访问机器。但对css、处理文本不足，不容易被搜索。<br>Ajax：对css、文本支持很好，但对多媒体、矢量图形、访问机器不足。</p><h3 id="有效的javascript变量定义规则"><a href="#有效的javascript变量定义规则" class="headerlink" title="有效的javascript变量定义规则"></a>有效的javascript变量定义规则</h3><p>第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；其他字符可以是字母、下划线、美元符号或数字。</p><h3 id="XML与JSON的区别？"><a href="#XML与JSON的区别？" class="headerlink" title="XML与JSON的区别？"></a>XML与JSON的区别？</h3><p>1) 数据体积方面。JSON相对于XML来讲，数据的体积小，传递的速度更快些。<br>2) 数据交互方面。JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。<br>3) 数据描述方面。JSON对数据的描述性比XML较差。<br>4) 传输速度方面。JSON的速度要远远快于XML。</p><h3 id="HTML与XML的区别？"><a href="#HTML与XML的区别？" class="headerlink" title="HTML与XML的区别？"></a>HTML与XML的区别？</h3><p>（1）XML用来传输和存储数据，HTML用来显示数据；<br>（2）XML使用的标签不用预先定义<br>（3）XML标签必须成对出现<br>（4）XML对大小写敏感<br>（5）XML中空格不会被删减<br>（6）XML中所有特殊符号必须用编码表示<br>（7）XML中的图片必须有文字说明</p><h3 id="渐进增强与优雅降级"><a href="#渐进增强与优雅降级" class="headerlink" title="渐进增强与优雅降级"></a>渐进增强与优雅降级</h3><p>渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进，达到更好的用户体验。<br>优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p><h3 id="Web-Worker和Web-Socket？"><a href="#Web-Worker和Web-Socket？" class="headerlink" title="Web Worker和Web Socket？"></a>Web Worker和Web Socket？</h3><p>web socket：在一个单独的持久连接上提供全双工、双向的通信。使用自定义的协议（ws://、wss://），同源策略对web socket不适用。<br>web worker：运行在后台的JavaScript，不影响页面的性能。<br>创建worker：var worker = new Worker(url);<br>向worker发送数据：worker.postMessage(data);<br>接收worker返回的数据：worker.onmessage<br>终止一个worker的执行：worker.terminate();</p><h3 id="JS垃圾回收机制？"><a href="#JS垃圾回收机制？" class="headerlink" title="JS垃圾回收机制？"></a>JS垃圾回收机制？</h3><p>1) 标记清除：<br>这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。<br>这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。定期的，垃圾回收器将从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象。从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。</p><p>2) 引用计数：<br>这是最简单的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。<br>该算法有个限制：无法处理循环引用。两个对象被创建，并互相引用，形成了一个循环。它们被调用之后不会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。</p><h3 id="web应用从服务器主动推送data到客户端的方式？"><a href="#web应用从服务器主动推送data到客户端的方式？" class="headerlink" title="web应用从服务器主动推送data到客户端的方式？"></a>web应用从服务器主动推送data到客户端的方式？</h3><p>JavaScript数据推送：commet（基于http长连接的服务器推送技术）。<br>基于web socket的推送：SSE（server-send Event）</p><h3 id="如何删除一个cookie？"><a href="#如何删除一个cookie？" class="headerlink" title="如何删除一个cookie？"></a>如何删除一个cookie？</h3><p>1） 将cookie的失效时间设置为过去的时间（expires）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = ‘user=’+ encodeURIComponent(‘name’) + &apos;;</span><br><span class="line">expires=’+ new Date(0);</span><br></pre></td></tr></table></figure><p>2） 将系统时间设置为当前时间往前一点时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var data = new Date();</span><br><span class="line">date.setDate(date.getDate()-1);</span><br></pre></td></tr></table></figure><h3 id="attribute与property的区别？"><a href="#attribute与property的区别？" class="headerlink" title="attribute与property的区别？"></a>attribute与property的区别？</h3><p>attribute是dom元素在文档中作为html标签拥有的属性<br>property是dom元素在js中作为对象拥有的属性。<br>所以，对于html的标准属性来说，attribute和property是同步的，是会自动更新的。但对于自定义属性，他们不同步。</p><h3 id="Ajax请求的页面历史记录状态问题？"><a href="#Ajax请求的页面历史记录状态问题？" class="headerlink" title="Ajax请求的页面历史记录状态问题？"></a>Ajax请求的页面历史记录状态问题？</h3><p>（1）通过location.hash记录状态，让浏览器记录Ajax请求时页面状态的变化。<br>（2）通过HTML5的history.pushstate，来实现浏览器地址栏的无刷新改变。</p></script></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JS的基本数据类型和引用数据类型&quot;&gt;&lt;a href=&quot;#JS的基本数据类型和引用数据类型&quot; class=&quot;headerlink&quot; title=&quot;JS的基本数据类型和引用数据类型&quot;&gt;&lt;/a&gt;JS的基本数据类型和引用数据类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;基本数据类
      
    
    </summary>
    
      <category term="前端面试题" scheme="https://qw66.gitee.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="JavaScript" scheme="https://qw66.gitee.io/tags/JavaScript/"/>
    
      <category term="DOM" scheme="https://qw66.gitee.io/tags/DOM/"/>
    
      <category term="BOM" scheme="https://qw66.gitee.io/tags/BOM/"/>
    
      <category term="字符串" scheme="https://qw66.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="同步异步" scheme="https://qw66.gitee.io/tags/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>基于Vue的前端架构</title>
    <link href="https://qw66.gitee.io//articles/ji-yu-vue-de-qian-duan-jia-gou.html"/>
    <id>https://qw66.gitee.io//articles/ji-yu-vue-de-qian-duan-jia-gou.html</id>
    <published>2023-12-16T16:00:00.000Z</published>
    <updated>2024-05-09T03:19:43.270Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-分解需求"><a href="#1-分解需求" class="headerlink" title="1.分解需求"></a>1.分解需求</h2><h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><ul><li>考虑到后续招人和现有人员的技术栈，选择 Vue 作为框架。</li><li>公司主要业务是 GIS 和 BIM，通常开发一些中大型的系统，所以 vue-router 和 vuex 都是必不可少的。</li><li>放弃了 Element UI 选择了 Ant Design Vue（最近 Element 好像复活了，麻蛋）。</li><li>工具库选择 lodash。</li></ul><h3 id="建立脚手架"><a href="#建立脚手架" class="headerlink" title="建立脚手架"></a>建立脚手架</h3><ul><li>搭建 NPM 私服。</li><li>使用 Node 环境开发 CLI 工具，参考我自己写过的一篇 -【 <a href="https://juejin.cn/post/6844903607855235079" target="_blank" rel="noopener">搭建自己的脚手架—“优雅”生成前端工程</a>】。</li><li>基于 @vue/cli 搭建基础的模板（大家都比较了解，节省开发时间，远胜于从零开始搭建）。</li><li>根据业务需求定义各种开发中可能用到的功能（组件库、状态管理、过滤器、指令、CSS内置变量、CSS Mixins、表单验证、工具函数等）。</li><li>性能优化，例如对 Ant Design Vue 组件库的优化。</li></ul><h3 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h3><ul><li>对代码风格、命名规则、目录结构进行统一规范。</li><li>静态资源的使用规范。</li><li>单元测试、提交线上测试规范。</li><li>Git 提交记录和多人协作规范。</li></ul><h2 id="2-样式"><a href="#2-样式" class="headerlink" title="2.样式"></a>2.样式</h2><h3 id="CSS-预处理器的选择"><a href="#CSS-预处理器的选择" class="headerlink" title="CSS 预处理器的选择"></a>CSS 预处理器的选择</h3><ul><li>Sass/Scss ✅</li><li>Less ✅</li><li>Stylus ⭕</li></ul><p>为什么选择了两个？因为公司团队跟倾向于使用 scss 开发，less 是为了覆盖 ant design vue 的样式，stylus 只有我自己喜欢这种风格。</p><h3 id="局部样式与全局样式"><a href="#局部样式与全局样式" class="headerlink" title="局部样式与全局样式"></a>局部样式与全局样式</h3><h4 id="局部样式"><a href="#局部样式" class="headerlink" title="局部样式"></a>局部样式</h4><p>一般都是使用 scoped 方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h4 id="全局样式"><a href="#全局样式" class="headerlink" title="全局样式"></a>全局样式</h4><p>全局样式 目录：@/styles</p><p>variable.scss: 全局变量管理 mixins.scss: 全局 Mixins 管理 global.scss: 全局样式</p><p>其中 variable.scss 和 mixins.scss 会优先于 global.css 加载，并且可以不通过 import 的方式在项目中任何位置使用这些变量和 mixins。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  css: &#123;</span><br><span class="line">    loaderOptions: &#123;</span><br><span class="line">      sass: &#123;</span><br><span class="line">        prependData: <span class="string">`</span></span><br><span class="line"><span class="string">        @import '@/styles/variable.scss';</span></span><br><span class="line"><span class="string">        @import '@/styles/mixins.scss';</span></span><br><span class="line"><span class="string">        `</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="体验优化"><a href="#体验优化" class="headerlink" title="体验优化"></a>体验优化</h3><h4 id="页面载入进度条"><a href="#页面载入进度条" class="headerlink" title="页面载入进度条"></a>页面载入进度条</h4><p>使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Frstacruz%2Fnprogress" target="_blank" rel="noopener">nprogress</a> 对路由跳转时做一个伪进度条，这样做在网络不好的情况下可以让用户知道页面已经在加载了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> NProgress <span class="keyword">from</span> <span class="string">'nprogress'</span>;</span><br><span class="line"></span><br><span class="line">router.beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  NProgress.start();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  NProgress.done();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="美化滚动条"><a href="#美化滚动条" class="headerlink" title="美化滚动条"></a>美化滚动条</h4><p>一直用 Mac 做前端，突然发现同事的 Windows 上出现了十分丑陋的滚动条，为了保持一致：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">::-webkit-scrollbar</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">6px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">6px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-track</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">6px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(#101F1C, 0.1);</span><br><span class="line">  <span class="attribute">-webkit-border-radius</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">-moz-border-radius</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-thumb</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(#101F1C, 0.5);</span><br><span class="line">  <span class="attribute">background-clip</span>: padding-box;</span><br><span class="line">  <span class="attribute">min-height</span>: <span class="number">28px</span>;</span><br><span class="line">  <span class="attribute">-webkit-border-radius</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">-moz-border-radius</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-thumb</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(#101F1C, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态资源加载页面"><a href="#静态资源加载页面" class="headerlink" title="静态资源加载页面"></a>静态资源加载页面</h4><p>首次加载页面时，会产生大量的白屏时间，这时做一个 loading 效果看起来会很友好，其实很简单，直接在 public/index.html 里写一些静态的样式即可。</p><h3 id="移动端-100vh-问题"><a href="#移动端-100vh-问题" class="headerlink" title="移动端 100vh 问题"></a>移动端 100vh 问题</h3><p>在移动端使用 100vh 时，发现在 Chrome、Safari 浏览器中，因为浏览器栏和一些导航栏、链接栏导致不一样的呈现：</p><p>你以为的 100vh === 视口高度</p><p>实际上 100vh === 视口高度 + 浏览器工具栏（地址栏等等）的高度</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>安装 vh-check <code>npm install vh-check --save</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vhCheck <span class="keyword">from</span> <span class="string">'vh-check'</span>;</span><br><span class="line">vhCheck(<span class="string">'browser-address-bar'</span>);</span><br></pre></td></tr></table></figure><p>定义一个 CSS Mixin</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s@<span class="keyword">mixin</span> vh(<span class="variable">$height</span>: 100vh) &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="variable">$height</span>;</span><br><span class="line">  <span class="attribute">height</span>: calc(#&#123;<span class="variable">$height</span>&#125; - var(--browser-address-bar, <span class="number">0px</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后就是哪里不会点哪里。</p><h2 id="3-组件库"><a href="#3-组件库" class="headerlink" title="3.组件库"></a>3.组件库</h2><p>因为 Element UI 长期没更新，并且之前使用过 React 的 Ant Design（重点），所以组件库选择了Ant Design Vue。</p><h3 id="覆盖-Ant-Design-Vue-样式"><a href="#覆盖-Ant-Design-Vue-样式" class="headerlink" title="覆盖 Ant  Design Vue 样式"></a>覆盖 Ant  Design Vue 样式</h3><p>设计师眼中的 Ant Design === ‘丑’（心酸）。</p><h4 id="1-使用-less-文件"><a href="#1-使用-less-文件" class="headerlink" title="1.使用 .less 文件"></a>1.使用 .less 文件</h4><p>Ant  Design Vue 的样式使用了 Less 作为开发语言，并定义了一系列全局/组件的样式变量，所以需要安装了 less、less-loader，在 <code>@/styles/antd-theme.less</code> 可以覆盖默认样式。</p><p><strong>优点是：</strong></p><p>方便快捷，可以修改 class，覆盖默认变量。</p><p><strong>缺点是：</strong></p><p>必须引入 <code>@import &#39;~ant-design-vue/dist/antd.less&#39;;</code> ，引入后会将所有的组件样式全部引入，导致打包后的 css 体积达到 500kb 左右。</p><h4 id="2-使用-JavaScript-对象"><a href="#2-使用-JavaScript-对象" class="headerlink" title="2.使用 JavaScript 对象"></a>2.使用 JavaScript 对象</h4><p>通过 JavaScript 对象的方式可以修改内置变量，需要对 Less 进行配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="keyword">const</span> modifyVars = <span class="built_in">require</span>(<span class="string">'./src/styles/antdTheme.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  css: &#123;</span><br><span class="line">    loaderOptions: &#123;</span><br><span class="line">      less: &#123;</span><br><span class="line">        lessOptions: &#123;</span><br><span class="line">          javascriptEnabled: <span class="literal">true</span>,</span><br><span class="line">          modifyVars,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步还可以继续优化，通过 babel-plugin-import 使 Ant Design Vue 的组件样式可以按需加载：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// babel.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    <span class="string">'@vue/cli-plugin-babel/preset'</span>,</span><br><span class="line">  ],</span><br><span class="line">  plugins: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'import'</span>,</span><br><span class="line">      &#123; <span class="attr">libraryName</span>: <span class="string">'ant-design-vue'</span>, <span class="attr">libraryDirectory</span>: <span class="string">'es'</span>, <span class="attr">style</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>优点是：</strong></p><p>可以按需引入，打包后的 CSS 体积取决于你引用了多少个组件。</p><p><strong>缺点是：</strong></p><p>不能使用 class 进行样式覆盖。</p><h3 id="干掉无用的图标"><a href="#干掉无用的图标" class="headerlink" title="干掉无用的图标"></a>干掉无用的图标</h3><p>Ant Design Vue 把所有的 Icon 一次性引入（不管你因用了多少个组件），这使得体积打包后图标所占的体积竟然有几百 kb 之多。这些图标大多数不会被设计师所采纳，所以部分图标都应该被干掉：</p><p>创建一个 icons.js 来管理 Ant  Design Vue 图标，这里以一个 Loading 图标为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @/src/assets/icons.js</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> LoadingOutline &#125; <span class="keyword">from</span> <span class="string">'@ant-design/icons/lib/outline/LoadingOutline'</span>;</span><br></pre></td></tr></table></figure><p><strong>如何知道你要加载的图标在什么路径下？</strong></p><p>在 @ant-design/icons/lib 目录下有三种风格的图标，分别是 fill、outline、twotone，这里面内部的文件并不是 svg 格式，而是 js 和 ts 格式，这就是为什么我们可以这么引入图标的关键所在了。</p><p>下一步是通过配置 vue.config.js 将这个文件引入进来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">    resolve: &#123;</span><br><span class="line">      alias: &#123;</span><br><span class="line">        <span class="string">'@ant-design/icons/lib/dist$'</span>: path.resolve(__dirname, <span class="string">'./src/assets/icons.js'</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决-Moment-多国语"><a href="#解决-Moment-多国语" class="headerlink" title="解决 Moment 多国语"></a>解决 Moment 多国语</h3><p>解决到这之后，Ant Design Vue 居然还很大，这是因为 moment 是 Ant Design Vue 中有强依赖该插件，所以使用 webpack 插件减小打包体积，这里我们只保留 zh-cn 语言包：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  chainWebpack: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    config</span><br><span class="line">      .plugin(<span class="string">'ContextReplacementPlugin'</span>)</span><br><span class="line">      .use(webpack.ContextReplacementPlugin, [<span class="regexp">/moment[/\\]locale$/</span>, /zh-cn/]);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="部分组件需要在页面内引用"><a href="#部分组件需要在页面内引用" class="headerlink" title="部分组件需要在页面内引用"></a>部分组件需要在页面内引用</h3><p>Ant Design Vue 中部分体积较大的组件，例如 <code>DatePicker</code>，根据业务需求，应考虑在页面中进行加载，尽量保证首屏加载的速度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; DatePicker &#125; from &apos;ant-design-vue&apos;;</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ADatePicker: DatePicker,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="4-静态资源与图标"><a href="#4-静态资源与图标" class="headerlink" title="4.静态资源与图标"></a>4.静态资源与图标</h2><h3 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h3><p>所有的静态资源文件都会上传到 阿里云 OSS 上，所以在环境变量上加以区分。</p><p><code>.env.development</code> 与 <code>.env.production</code> 的 <code>VUE_APP_STATIC_URL</code> 属性分别配置了本地的静态资源服务器地址和线上 OSS 的地址。</p><p>本地的静态资源服务器是通过 pm2 + http-server 创建的，设计师切完直接扔进来就好了。</p><h3 id="自动注册-Svg-图标"><a href="#自动注册-Svg-图标" class="headerlink" title="自动注册 Svg 图标"></a>自动注册 Svg 图标</h3><p>在日常的开发中，总是会有着大量的图标需要使用，这里我们直接选择使用 SVG 图标。但是如果每次使用图标还需要通过路径找到这张图标岂不是很麻烦？</p><p>下面这种才是我想要的方案（直接 name 等于 文件名即可）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;svg name=&quot;logo&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>而且最后打包后需要合并成一张雪碧图。</p><p>首先需要对  <code>@/assets/icons</code> 文件夹下的 svg 图标进行自动注册，需要对 webpack 和 svg-sprite-loader 进行了相关设置，文件全部打包成 svg-sprite。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  chainWebpack: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    config.module</span><br><span class="line">      .rule(<span class="string">'svg'</span>)</span><br><span class="line">      .exclude.add(resolve(<span class="string">'src/assets/icons'</span>))</span><br><span class="line">      .end();</span><br><span class="line"></span><br><span class="line">    config.module</span><br><span class="line">      .rule(<span class="string">'icons'</span>)</span><br><span class="line">      .test(<span class="regexp">/\.svg$/</span>)</span><br><span class="line">      .include.add(resolve(<span class="string">'src/assets/icons'</span>))</span><br><span class="line">      .end()</span><br><span class="line">      .use(<span class="string">'svg-sprite-loader'</span>)</span><br><span class="line">      .loader(<span class="string">'svg-sprite-loader'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写一个全局用的 Vue 组件 ``:</p><p>// @/components/m-svg/index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> requireAll = <span class="function">(<span class="params">requireContext</span>) =&gt;</span> requireContext.keys().map(requireContext);</span><br><span class="line"><span class="keyword">const</span> req = <span class="built_in">require</span>.context(<span class="string">'@/assets/icons'</span>, <span class="literal">false</span>, /\.svg$/);</span><br><span class="line">requireAll(req);</span><br></pre></td></tr></table></figure><p>@/components/m-svg/index.vue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;svg class=&quot;mw-svg&quot; aria-hidden=&quot;true&quot;&gt;</span><br><span class="line">    &lt;use :xlink:href=&quot;iconName&quot;&gt;&lt;/use&gt;</span><br><span class="line">  &lt;/svg&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;m-svg&apos;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    name: &#123; type: String, default: &apos;&apos; &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    iconName() &#123;</span><br><span class="line">      return `#$&#123;this.name&#125;`;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">.mw-svg &#123;</span><br><span class="line">  width: 1.4em;</span><br><span class="line">  height: 1.4em;</span><br><span class="line">  fill: currentColor;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  line-height: 1em;</span><br><span class="line">  display: inline-block;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>参数 name</p><ul><li>类型：String</li><li>默认值：null</li><li>说明：放置在 <code>@/assets/icons</code> 文件夹下的文件名</li></ul><p>样式</p><ul><li>图标的大小可以通过 width + height 属性改变。</li><li>通过改变 font-size 属性改变，宽高 = font-zise * 1.4</li></ul><h2 id="5-异步请求"><a href="#5-异步请求" class="headerlink" title="5.异步请求"></a>5.异步请求</h2><h3 id="封装-Axios"><a href="#封装-Axios" class="headerlink" title="封装 Axios"></a>封装 Axios</h3><p>在 <code>@/libs/request.js</code> 路径下对 Axios 进行封装，封装了请求参数，请求头，以及错误提示信息、 request 拦截器、response 拦截器、统一的错误处理、baseURL 设置等。</p><p>废话不说直接贴代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">get</span> from 'lodash/<span class="keyword">get</span>';</span><br><span class="line">import storage from 'store';</span><br><span class="line">// 创建 axios 实例</span><br><span class="line">const request = axios.create(&#123;</span><br><span class="line"> <span class="comment">// API 请求的默认前缀</span></span><br><span class="line"> baseURL: process.env.VUE_APP_BASE_URL,</span><br><span class="line"> timeout: <span class="number">10000</span>, <span class="comment">// 请求超时时间</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异常拦截处理器</span></span><br><span class="line"><span class="keyword">const</span> errorHandler = <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> status = <span class="keyword">get</span>(error, 'response.status');</span><br><span class="line"> switch (status) &#123;</span><br><span class="line">   <span class="comment">/* eslint-disable no-param-reassign */</span></span><br><span class="line">   <span class="keyword">case</span> <span class="number">400</span>: error.message = <span class="string">'请求错误'</span>; <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">401</span>: error.message = <span class="string">'未授权，请登录'</span>; <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">403</span>: error.message = <span class="string">'拒绝访问'</span>; <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">404</span>: error.message = <span class="string">`请求地址出错: <span class="subst">$&#123;error.response.config.url&#125;</span>`</span>; <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">408</span>: error.message = <span class="string">'请求超时'</span>; <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">500</span>: error.message = <span class="string">'服务器内部错误'</span>; <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">501</span>: error.message = <span class="string">'服务未实现'</span>; <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">502</span>: error.message = <span class="string">'网关错误'</span>; <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">503</span>: error.message = <span class="string">'服务不可用'</span>; <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">504</span>: error.message = <span class="string">'网关超时'</span>; <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">505</span>: error.message = <span class="string">'HTTP版本不受支持'</span>; <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">   <span class="comment">/* eslint-disabled */</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// request interceptor</span></span><br><span class="line">request.interceptors.request.use(<span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="comment">// 如果 token 存在</span></span><br><span class="line"> <span class="comment">// 让每个请求携带自定义 token 请根据实际情况自行修改</span></span><br><span class="line"> <span class="comment">// eslint-disable-next-line no-param-reassign</span></span><br><span class="line"> config.headers.Authorization = <span class="string">`bearer <span class="subst">$&#123;storage.get(<span class="string">'ACCESS_TOKEN'</span>)&#125;</span>`</span>;</span><br><span class="line"> <span class="keyword">return</span> config;</span><br><span class="line">&#125;, errorHandler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// response interceptor</span></span><br><span class="line">request.interceptors.response.use(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> dataAxios = response.data;</span><br><span class="line"> <span class="comment">// 这个状态码是和后端约定的</span></span><br><span class="line"> <span class="keyword">const</span> &#123; code &#125; = dataAxios;</span><br><span class="line"> <span class="comment">// 根据 code 进行判断</span></span><br><span class="line"> <span class="keyword">if</span> (code === <span class="literal">undefined</span>) &#123;</span><br><span class="line">   <span class="comment">// 如果没有 code 代表这不是项目后端开发的接口</span></span><br><span class="line">   <span class="keyword">return</span> dataAxios;</span><br><span class="line"> <span class="comment">// eslint-disable-next-line no-else-return</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 有 code 代表这是一个后端接口 可以进行进一步的判断</span></span><br><span class="line">   <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="number">200</span>:</span><br><span class="line">       <span class="comment">// [ 示例 ] code === 200 代表没有错误</span></span><br><span class="line">       <span class="keyword">return</span> dataAxios.data;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">'xxx'</span>:</span><br><span class="line">       <span class="comment">// [ 示例 ] 其它和后台约定的 code</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">'xxx'</span>;</span><br><span class="line">     <span class="keyword">default</span>:</span><br><span class="line">       <span class="comment">// 不是正确的 code</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">'不是正确的code'</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;, errorHandler);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> request;</span><br></pre></td></tr></table></figure><ul><li>通过 VUE_APP_BASE_URL 区分线上与开发环境的 API 地址。</li><li>code 起到一个比较关键的作用，例如 token 过期时的验证。</li><li>使用了一个叫 sotre 的包作为本地储存的工具用来存储 token。</li></ul><h3 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h3><p>跨域问题一般情况直接找后端解决了，你要是不好意思打扰他们的话，可以用 devServer 提供的 proxy 代理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line">devServer: &#123;</span><br><span class="line">  proxy: &#123;</span><br><span class="line">    <span class="string">'/api'</span>: &#123;</span><br><span class="line">      target: <span class="string">'http://47.100.186.132/your-path/api'</span>,</span><br><span class="line">      ws: <span class="literal">true</span>,</span><br><span class="line">      changeOrigin: <span class="literal">true</span>,</span><br><span class="line">      pathRewrite: &#123;</span><br><span class="line">        <span class="string">'^/api'</span>: <span class="string">''</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mock-数据"><a href="#Mock-数据" class="headerlink" title="Mock 数据"></a>Mock 数据</h3><p>一个很常见的情况，后端接口没出来，前端在这干瞪眼。</p><p>Mock 数据功能是基于 <a href="https://link.juejin.cn?target=http%3A%2F%2Fmockjs.com%2F" target="_blank" rel="noopener">mock.js (opens new window)</a>开发，通过 webpack 进行自动加载 mock 配置文件。</p><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ul><li>所有的 mock 配置文件均应放置在 <code>@/mock/services</code> 路径内。</li><li>在 <code>@/mock/services</code> 内部可以建立业务相关的文件夹分类存放配置文件。</li><li>所有的配置文件应按照 <code>***.mock.js</code> 的命名规范创建。</li><li>配置文件使用 ES6 Module 导出 <code>export default</code> 或 <code>export</code> 一个数组。</li></ul><h4 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Mock <span class="keyword">from</span> <span class="string">'mockjs'</span>;</span><br><span class="line"></span><br><span class="line">Mock.setup(&#123;</span><br><span class="line">  timeout: <span class="string">'500-800'</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> context = <span class="built_in">require</span>.context(<span class="string">'./services'</span>, <span class="literal">true</span>, /\.mock.js$/);</span><br><span class="line"></span><br><span class="line">context.keys().forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.keys(context(key)).forEach(<span class="function">(<span class="params">paramKey</span>) =&gt;</span> &#123;</span><br><span class="line">    Mock.mock(...context(key)[paramKey]);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="示例模板"><a href="#示例模板" class="headerlink" title="示例模板"></a>示例模板</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Mock <span class="keyword">from</span> <span class="string">'mockjs'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; Random &#125; = Mock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">  <span class="built_in">RegExp</span>(<span class="string">'/example.*'</span>),</span><br><span class="line">  <span class="string">'get'</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">'range|50-100'</span>: <span class="number">50</span>,</span><br><span class="line">    <span class="string">'data|10'</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 唯一 ID</span></span><br><span class="line">        id: <span class="string">'@guid()'</span>,</span><br><span class="line">        <span class="comment">// 生成一个中文名字</span></span><br><span class="line">        cname: <span class="string">'@cname()'</span>,</span><br><span class="line">        <span class="comment">// 生成一个 url</span></span><br><span class="line">        url: <span class="string">'@url()'</span>,</span><br><span class="line">        <span class="comment">// 生成一个地址</span></span><br><span class="line">        county: Mock.mock(<span class="string">'@county(true)'</span>),</span><br><span class="line">        <span class="comment">// 从数组中随机选择一个值</span></span><br><span class="line">        <span class="string">'array|1'</span>: [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>],</span><br><span class="line">        <span class="comment">// 随机生成一个时间</span></span><br><span class="line">        time: <span class="string">'@datetime()'</span>,</span><br><span class="line">        <span class="comment">// 生成一张图片</span></span><br><span class="line">        image: Random.dataImage(<span class="string">'200x100'</span>, <span class="string">'Mock Image'</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="6-路由"><a href="#6-路由" class="headerlink" title="6.路由"></a>6.路由</h2><h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><p>布局暂时分为三大类：</p><ul><li>frameIn：基于 <code>BasicLayout</code>，通常需要登录或权限认证的路由。</li><li>frameOut：不需要动态判断权限的路由，如登录页或通用页面。</li><li>errorPage：例如404。</li></ul><h3 id="权限验证"><a href="#权限验证" class="headerlink" title="权限验证"></a>权限验证</h3><p>通过获取当前用户的权限去比对路由表，生成当前用户具的权限可访问的路由表，通过 router.addRoutes 动态挂载到 router 上。</p><ul><li>判断页面是否需要登陆状态，需要则跳转到 /user/login</li><li>本地存储中不存在 token 则跳转到 /user/login</li><li>如果存在 token，用户信息不存在，自动调用 vuex ‘/system/user/getInfo’</li></ul><p>在路由中，集成了权限验证的功能，需要为页面增加权限时，在 meta 下添加相应的 key：</p><h4 id="auth"><a href="#auth" class="headerlink" title="auth"></a>auth</h4><ul><li>类型：Boolean</li><li>说明：当 auth 为 true 时，此页面需要进行登陆权限验证，只针对 frameIn 路由有效。</li></ul><h4 id="permissions"><a href="#permissions" class="headerlink" title="permissions"></a>permissions</h4><ul><li>类型：Object</li><li>说明：permissions 每一个 key 对应权限功能的验证，当 key 的值为 true 时，代表具有权限，若 key 为 false，配合 <code>v-permission</code> 指令，可以隐藏相应的 DOM。</li></ul><p>在这里贴一下路由跳转时权限验证的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'@/router'</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'@/store'</span>;</span><br><span class="line"><span class="keyword">import</span> storage <span class="keyword">from</span> <span class="string">'store'</span>;</span><br><span class="line"><span class="keyword">import</span> util <span class="keyword">from</span> <span class="string">'@/libs/utils'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进度条</span></span><br><span class="line"><span class="keyword">import</span> NProgress <span class="keyword">from</span> <span class="string">'nprogress'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'nprogress/nprogress.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loginRoutePath = <span class="string">'/user/login'</span>;</span><br><span class="line"><span class="keyword">const</span> defaultRoutePath = <span class="string">'/home'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 路由拦截</span></span><br><span class="line"><span class="comment"> * 权限验证</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">router.beforeEach(<span class="keyword">async</span> (to, <span class="keyword">from</span>, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 进度条</span></span><br><span class="line">  NProgress.start();</span><br><span class="line">  <span class="comment">// 验证当前路由所有的匹配中是否需要有登录验证的</span></span><br><span class="line">  <span class="keyword">if</span> (to.matched.some(<span class="function">(<span class="params">r</span>) =&gt;</span> r.meta.auth)) &#123;</span><br><span class="line">    <span class="comment">// 是否存有token作为验证是否登录的条件</span></span><br><span class="line">    <span class="keyword">const</span> token = storage.get(<span class="string">'ACCESS_TOKEN'</span>);</span><br><span class="line">    <span class="keyword">if</span> (token &amp;&amp; token !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">      <span class="comment">// 是否处于登录页面</span></span><br><span class="line">      <span class="keyword">if</span> (to.path === loginRoutePath) &#123;</span><br><span class="line">        next(&#123; <span class="attr">path</span>: defaultRoutePath &#125;);</span><br><span class="line">        <span class="comment">// 查询是否储存用户信息</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(store.state.system.user.info).length === <span class="number">0</span>) &#123;</span><br><span class="line">        store.dispatch(<span class="string">'system/user/getInfo'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          next();</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有登录的时候跳转到登录界面</span></span><br><span class="line">      <span class="comment">// 携带上登陆成功之后需要跳转的页面完整路径</span></span><br><span class="line">      next(&#123;</span><br><span class="line">        name: <span class="string">'Login'</span>,</span><br><span class="line">        query: &#123;</span><br><span class="line">          redirect: to.fullPath,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">      NProgress.done();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不需要身份校验 直接通过</span></span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.afterEach(<span class="function">(<span class="params">to</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 进度条</span></span><br><span class="line">  NProgress.done();</span><br><span class="line">  util.title(to.meta.title);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="页面开发"><a href="#页面开发" class="headerlink" title="页面开发"></a>页面开发</h3><ul><li>根据业务需要划分，按照路由层级在 views 中创建相对应的页面组件，以文件夹的形式创建，并在文件夹内创建 index.vue 文件作为页面的入口文件。</li><li>页面内的组件：在页面文件夹下创建 components 文件夹，在其内部对应创建相应的组件文件，如果是复杂组件，应以文件夹的形式创建组件。</li><li>工具模块：能够高度抽象的工具模块，应创建在 @/src/libs 内创建 js 文件。</li></ul><h2 id="7、构建优化"><a href="#7、构建优化" class="headerlink" title="7、构建优化"></a>7、构建优化</h2><h3 id="包分析工具"><a href="#包分析工具" class="headerlink" title="包分析工具"></a>包分析工具</h3><p>构建代码之后，到底是什么占用了这么多空间？靠直觉猜测或者使用 webpack-bundle-analyzer。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WebpackBundleAnalyzer = <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  chainWebpack: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.use_analyzer) &#123;</span><br><span class="line">      config</span><br><span class="line">        .plugin(<span class="string">'webpack-bundle-analyzer'</span>)</span><br><span class="line">        .use(WebpackBundleAnalyzer.BundleAnalyzerPlugin);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="开启-Gzip"><a href="#开启-Gzip" class="headerlink" title="开启 Gzip"></a>开启 Gzip</h3><p>对，这这么一句话，后端就得支持你的 .gz 文件了，而你只需要坐着等老板夸：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chainWebpack: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">  config</span><br><span class="line">    .plugin(<span class="string">'CompressionPlugin'</span>)</span><br><span class="line">    .use(CompressionPlugin, []);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><p>这块 @vue/cli 已经帮忙处理好了，但也需要了解一下他的原理和如何配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'home'</span>,</span><br><span class="line">  name: <span class="string">'Home'</span>,</span><br><span class="line">  component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(</span><br><span class="line">    <span class="comment">/* webpackChunkName: "home" */</span> <span class="string">'@/views/home/index.vue'</span></span><br><span class="line">  ),</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>webpackChunkName 这条注释还是很有必要加的，至少你打包后知道又是哪个页面变得又臭又大。</p><h3 id="Preload-amp-Prefetch"><a href="#Preload-amp-Prefetch" class="headerlink" title="Preload &amp; Prefetch"></a>Preload &amp; Prefetch</h3><p>不清楚这两个功能的去 @vue/cli 补课，这两个功能非常有助于你处理加载的性能。</p><h2 id="8-测试框架"><a href="#8-测试框架" class="headerlink" title="8.测试框架"></a>8.测试框架</h2><p>直接使用了官方提供的 Vue Test Utils，这东西可以对组件进行测试，很不错。</p><p>写单元测试在团队里其实很难推进，不知道大家怎么看。</p><h2 id="9-组件库"><a href="#9-组件库" class="headerlink" title="9.组件库"></a>9.组件库</h2><p>对于很多第三方的工具，我坚持认为二次封装成 vue 插件并没有多少开发成本，反而让你在后续的开发中变得很灵活。</p><p>我对以下库进行了 vue 插件的封装，并提交到 npm 私服：</p><ul><li>数字动画</li><li>代码高亮</li><li>大文件上传（切片、断点续传、秒传）需要与后端配合</li><li>图片预览</li><li>Excel 导入导出</li><li>富文本编辑器</li><li>Markdown 编辑器</li><li>代码编辑器</li></ul><blockquote><p>大文件上传有兴趣的可以留言，我后续单独拎出来详细的写一下这块。</p></blockquote><h2 id="10-Vuex"><a href="#10-Vuex" class="headerlink" title="10.Vuex"></a>10.Vuex</h2><p>内置一些功能，主要是对以下这些功能做了一些封装：</p><ul><li>用户信息管理（储存信息、对 token 进行操作等）</li><li>登陆（调接口）</li><li>菜单管理（储存路由信息，生成菜单，模糊查询等功能）</li><li>UA信息</li><li>全屏操作</li><li>Loading</li><li>日志管理（消息提醒、日志留存、日志上报）</li></ul><h2 id="11-过滤器"><a href="#11-过滤器" class="headerlink" title="11.过滤器"></a>11.过滤器</h2><p>过滤器是 Vue 提供的一个很好用的功能，听说 vue3 没了？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; message | capitalize &#125;&#125;</span><br></pre></td></tr></table></figure><p>我写了几个常用的过滤器：</p><ul><li>日期时间</li><li>剩余时间</li><li>区分环境的链接（主要针对本地静态资源服务器和 OSS ）</li><li>文件大小</li><li>数字金额</li><li>浮点型精度</li></ul><h2 id="12-指令"><a href="#12-指令" class="headerlink" title="12.指令"></a>12.指令</h2><p>自定义指令可以提供很好的帮助：</p><ul><li>组件权限验证</li><li>文本复制</li><li>快捷键绑定</li><li>滚动至指定位置</li><li>图片懒加载</li><li>焦点</li></ul><h2 id="13-开发规范"><a href="#13-开发规范" class="headerlink" title="13.开发规范"></a>13.开发规范</h2><h3 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h3><p>不管是多人合作还是个人项目，代码规范都是很重要的。这样做不仅可以很大程度地避免基本语法错误，也保证了代码的可读性。</p><p>这里我们采用了 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fairbnb%2Fjavascript" target="_blank" rel="noopener">Airbnb JavaScript Style Guide</a>。</p><p>这套规范给我的感觉就是 <strong>很严谨</strong>！</p><h3 id="CSS-规范"><a href="#CSS-规范" class="headerlink" title="CSS 规范"></a>CSS 规范</h3><h4 id="降低选择器复杂性"><a href="#降低选择器复杂性" class="headerlink" title="降低选择器复杂性"></a>降低选择器复杂性</h4><p>浏览器读取选择器，遵循的原则是从选择器的右边到左边读取。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#block</span> <span class="selector-class">.text</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查找所有 P 元素。</li><li>查找结果 1 中的元素是否有类名为 text 的父元素</li><li>查找结果 2 中的元素是否有 id 为 block 的父元素</li></ul><h4 id="选择器优先级"><a href="#选择器优先级" class="headerlink" title="选择器优先级"></a>选择器优先级</h4><blockquote><p>内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器</p></blockquote><ul><li>选择器越短越好。</li><li>尽量使用高优先级的选择器，例如 ID 和类选择器。</li><li>避免使用通配符 *。</li></ul><h4 id="使用-flexbox"><a href="#使用-flexbox" class="headerlink" title="使用 flexbox"></a>使用 flexbox</h4><p>在早期的 CSS 布局方式中我们能对元素实行绝对定位、相对定位或浮动定位。而现在，我们有了新的布局方式 flexbox，它比起早期的布局方式来说有个优势，那就是性能比较好。不过 flexbox 兼容性还是有点问题，不是所有浏览器都支持它，所以要谨慎使用。 各浏览器兼容性：</p><ul><li>Chrome 29+</li><li>Firefox 28+</li><li>Internet Explorer 11</li><li>Opera 17+</li><li>Safari 6.1+ (prefixed with -webkit-)</li><li>Android 4.4+</li><li>iOS 7.1+ (prefixed with -webkit-)</li></ul><h4 id="动画性能优化"><a href="#动画性能优化" class="headerlink" title="动画性能优化"></a>动画性能优化</h4><p>在 CSS 中，transforms 和 opacity 这两个属性更改不会触发重排与重绘，它们是可以由合成器（composite）单独处理的属性。</p><h4 id="属性值"><a href="#属性值" class="headerlink" title="属性值"></a>属性值</h4><ul><li>当数值为 0 - 1 之间的小数时，建议省略整数部分的 0。</li><li>当长度为 0 时建议省略单位。</li><li>建议不使用命名色值。</li><li>建议当元素需要撑起高度以包含内部的浮动元素时，通过对伪类设置 clear 或触发 BFC 的方式进行 clearfix。尽量不使用增加空标签的方式。</li><li>除公共样式之外，在业务代码中尽量不能使用 !important。</li><li>建议将 z-index 进行分层，对文档流外绝对定位元素的视觉层级关系进行管理。</li></ul><h4 id="字体排版"><a href="#字体排版" class="headerlink" title="字体排版"></a>字体排版</h4><ul><li>字号应不小于 12px（PC端）。</li><li>font-weight 属性建议使用数值方式描述。</li><li>line-height 在定义文本段落时，应使用数值。</li></ul><h3 id="Vue-代码规范"><a href="#Vue-代码规范" class="headerlink" title="Vue 代码规范"></a>Vue 代码规范</h3><h4 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h4><ul><li>当在组件中使用 data 属性的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数 <code>data() { return {...} }</code>。</li><li>prop 的定义应该尽量详细，至少需要指定其类型。</li><li>布尔类型的 attribute， 为 true 时直接写属性值。</li><li>不要在computed中对vue变量进行操作。</li><li>应该优先通过 prop 和事件进行父子组件之间的通信，而不是 this.$parent 或改变 prop。</li><li>在组件上总是必须用 key 配合 v-for，以便维护内部组件及其子树的状态。</li><li>v-if 和 v-for 不能同时使用</li><li>公共方法尽量不要挂到原型上, 可以写在 utils 文件，也可以使用 mixin 文件。不要将业务公共组件注册到全局。</li><li>不要将任何第三方插件挂载到 vue 原型上。</li><li>具有高度通用性的方法，要封装到 libs、全局组件或指令集里。</li><li>为组件样式设置作用域。</li><li>尽量使用指令缩写。</li></ul><h4 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h4><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fvuex.vuejs.org%2Fzh%2Fguide%2Fstate.html" target="_blank" rel="noopener">State (opens new window)</a>为单一状态树，在 state 中需要定义我们所需要管理的数组、对象、字符串等等，只有在这里定义了，在 vue 的组件中才能获取你定义的这个对象的状态。</p><ul><li>修改 <code>state</code> 中数据必须通过 <code>mutations</code>。</li><li>每一个可能发生改变的 <code>state</code> 必须同步创建一条或多条用来改变它的 <code>mutations</code>。</li><li>服务端获取的数据存放在 <code>state</code> 中，作为原始数据保留，不可变动。</li></ul><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fvuex.vuejs.org%2Fzh%2Fguide%2Fgetters.html" target="_blank" rel="noopener">Getters (opens new window)</a>有点类似 vue.js 的计算属性，当我们需要从 store 的 state 中派生出一些状态，那么我们就需要使用 getters，getters 会接收 state 作为第一个参数，而且 getters 的返回值会根据它的依赖被缓存起来，只有 getters 中的依赖值（state 中的某个需要派生状态的值）发生改变的时候才会被重新计算。</p><ul><li>通过 <code>getters</code> 处理你需要得到的数据格式，而不是通过修改 <code>state</code> 原始数据。</li><li>组件内不强制使用 <code>mapGetters</code>，因为你可能需要使用 <code>getter</code> 和 <code>setter</code>。</li><li>改变 <code>state</code> 的唯一方法就是提交 <a href="https://link.juejin.cn?target=https%3A%2F%2Fvuex.vuejs.org%2Fzh%2Fguide%2Fmutations.html" target="_blank" rel="noopener">mutations (opens new window)</a>。</li><li>组件内使用 <code>mapMutations</code> 辅助函数将组件中的 <code>methods</code> 映射为 <code>store.commit</code> 调用。</li><li>命名采用 <code>大写字母</code> + <code>下划线</code> 的规则。</li><li>定义 <code>CLEAR</code>，以确保路由切换时可以初始化数据。</li></ul><p>Actions</p><ul><li>页面重的数据接口尽量在 <a href="https://link.juejin.cn?target=https%3A%2F%2Fvuex.vuejs.org%2Fzh%2Fguide%2Factions.html" target="_blank" rel="noopener">actions (opens new window)</a>中调用。</li><li>服务端返回的数据尽量不作处理，保留原始数据。</li><li>获取到的数据必须通过调用 <code>mutations</code> 改变 <code>state</code>。</li></ul><p>Modules</p><ul><li>通常情况下按照页面划分 <a href="https://link.juejin.cn?target=https%3A%2F%2Fvuex.vuejs.org%2Fzh%2Fguide%2Fmodules.html" target="_blank" rel="noopener">modules (opens new window)</a>。</li><li>默认内置了 <code>system</code> 保证了脚手架的基础功能。</li><li>每个页面模块或页面的子模块添加属性 <code>namespaced: true</code>。</li></ul><h2 id="14-完成详细的使用文档"><a href="#14-完成详细的使用文档" class="headerlink" title="14.完成详细的使用文档"></a>14.完成详细的使用文档</h2><p>不论是功能还是组件库等等的工具，都需要完善的文档提供查阅，即使是轮子的构建者，也抵不住时间长了会忘记许多细节。</p><p>这里我使用 vuepress 构建文档，方便快捷。</p><p>参考【<a href="https://juejin.cn/post/6844903869558816781" target="_blank" rel="noopener">拯救懒癌文档君 - VuePress + Travis CI + Github Pages 自动线上生成文档</a>】</p><h2 id="15-Git-多人协作流程"><a href="#15-Git-多人协作流程" class="headerlink" title="15.Git 多人协作流程"></a>15.Git 多人协作流程</h2><p>公司使用内部搭建的 GitLab 托管代码</p><h3 id="Root-仓库"><a href="#Root-仓库" class="headerlink" title="Root 仓库"></a>Root 仓库</h3><p>项目启动时，由项目管理者搭建起最原始的仓库，称为 Root 仓库（源仓库）。</p><p>源仓库的有个作用 :</p><ul><li>汇总参与该项目的各个开发者的代码。</li><li>存放趋于稳定和可发布的代码。</li><li>向 Master 分支提交 Merge Requests 可以触发测试环境构建（CI/CD）。</li><li>源仓库是受保护的，开发者不可直接对其进行开发工作。</li></ul><h3 id="开发者仓库"><a href="#开发者仓库" class="headerlink" title="开发者仓库"></a>开发者仓库</h3><p>任何开发者都没有权限对 Root 仓库进行直接的操作，源仓库建立以后，每个开发者需要做的事情就是把源仓库的 Fork 一份，作为自己日常开发的仓库。</p><ul><li>每个开发者所Fork的仓库是完全独立的，互不干扰。</li><li>每个开发者提交到代码到自己的仓库中，开发工作完成以后，开发者可以向源仓库发送 Pull Request ，本地仓库先合并源仓库，解决冲突。</li><li>发起 Merge Request 请求管理员把自己的代码合并到源仓库中的 master 或 其他分支。</li></ul><h3 id="Git-流程"><a href="#Git-流程" class="headerlink" title="Git 流程"></a>Git 流程</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d69d8098ee5d48da903d5dfe8248896d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><ul><li>前端项目会在 <code>Root</code> 仓库下创建 <code>dev</code> 分支，用于代码的拉取和合并，如果有多个不同的测试环境，按照测试环境创建分支。</li><li>在本地的仓库中创建你的 <code>dev</code> 分支和其他功能性的分支。</li><li>开发过程中不允许直接在 <code>master</code> 分支上开发，创建一个新的分支进行开发，<code>git checkout –b {branch_name}</code>。</li><li>规范且详细的书写 <code>commit</code> ，推荐使用 <code>git-cz</code> 工具进行提交。</li><li>完成开发后将相应的分支合并到自己仓库的 <code>master</code> 分支。</li><li>将 <code>master</code> 分支 <code>push</code> 到自己的远程仓库（Fork仓库）。</li><li>向 <code>Root</code> 仓库 <code>dev</code> 分支提交 <code>Merge Requests</code>。</li><li>提醒前端负责人审查代码、解决冲突或测试环境上线。</li><li>解决冲突后 <code>git pull upstream dev</code> 拉取解决后的最新代码。</li></ul><p>原文链接：<a href="https://juejin.cn/post/6901466994478940168" target="_blank" rel="noopener">https://juejin.cn/post/6901466994478940168</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-分解需求&quot;&gt;&lt;a href=&quot;#1-分解需求&quot; class=&quot;headerlink&quot; title=&quot;1.分解需求&quot;&gt;&lt;/a&gt;1.分解需求&lt;/h2&gt;&lt;h3 id=&quot;技术栈&quot;&gt;&lt;a href=&quot;#技术栈&quot; class=&quot;headerlink&quot; title=&quot;技术栈
      
    
    </summary>
    
      <category term="前端文章" scheme="https://qw66.gitee.io/categories/%E5%89%8D%E7%AB%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="前端架构" scheme="https://qw66.gitee.io/tags/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>前端权限开发</title>
    <link href="https://qw66.gitee.io//articles/qian-duan-quan-xian-kai-fa.html"/>
    <id>https://qw66.gitee.io//articles/qian-duan-quan-xian-kai-fa.html</id>
    <published>2023-12-15T16:00:00.000Z</published>
    <updated>2024-05-10T09:29:21.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端权限开发——设计到实践（保姆级）"><a href="#前端权限开发——设计到实践（保姆级）" class="headerlink" title="前端权限开发——设计到实践（保姆级）"></a>前端权限开发——设计到实践（保姆级）</h1><h2 id="1-权限控制的方案选择。"><a href="#1-权限控制的方案选择。" class="headerlink" title="1.权限控制的方案选择。"></a>1.权限控制的方案选择。</h2><p>做后台项目区别于做其它的项目，权限验证与安全性是非常重要的，可以说是一个后台项目一开始就必须考虑和搭建的基础核心功能。在后台管理系统中，实现权限控制可以采用多种方案：</p><table><thead><tr><th>权限方案类型</th><th>描述</th></tr></thead><tbody><tr><td>基于角色的访问控制（Role-Based Access Control，RBAC）</td><td>是一种广泛采用的权限控制方案。系统中定义了不同的角色，每个角色具有一组权限，而用户被分配到一个或多个角色。通过控制用户角色的分配，可以实现对用户访问系统中不同功能和资源的权限控制。</td></tr><tr><td>基于权限的访问控制（Permission-Based Access Control）</td><td>这种方案将权限直接分配给用户，而不是通过角色来管理。每个用户都有自己的权限列表，控制用户对系统中各项功能和资源的访问。</td></tr><tr><td>基于资源的访问控制（Resource-Based Access Control，RBAC）</td><td>这种方案将权限控制与资源本身关联起来。系统中的每个资源都有自己的访问权限，用户通过被授予资源的访问权限来控制其对资源的操作。</td></tr><tr><td>层次结构权限控制（Hierarchical Access Control）</td><td>这种方案基于资源和操作的层次结构来进行权限控制。系统中的资源和操作被组织成层次结构，用户被授予访问某个层次及其子层次的权限。</td></tr><tr><td>基于规则的访问控制（Rule-Based Access Control）</td><td>这种方案使用预定义的规则来确定用户对系统中功能和资源的访问权限。规则可以基于用户属性、环境条件或其他因素进行定义。</td></tr></tbody></table><p>这里我选择了<strong>基于角色的访问控制（Role-Based Access Control，RBAC）</strong> 这是因为RBAC提供了一种灵活且易于管理的方式来控制用户对系统功能和资源的访问，也是目前最主流的前端权限方案选择。</p><p>在RBAC中，系统中的功能和资源被组织成角色，而用户则被分配到不同的角色。每个角色都有一组权限，定义了该角色可以执行的操作和访问的资源。通过给用户分配适当的角色，可以实现对用户的权限控制。</p><p>RBAC的好处之一是它简化了权限管理的复杂性。管理员只需管理角色和分配角色给用户，而不需要为每个用户单独定义权限。当需要对用户的权限进行修改时，只需调整其角色的权限即可。</p><p>此外，RBAC还支持灵活的权限组合，允许创建具有不同权限组合的角色，以适应不同用户的需求。它也便于扩展，可以随着系统的发展和需求的变化而调整和添加角色。</p><h2 id="2-RBAC下的权限字段设计与管理模型"><a href="#2-RBAC下的权限字段设计与管理模型" class="headerlink" title="2.RBAC下的权限字段设计与管理模型"></a>2.RBAC下的权限字段设计与管理模型</h2><h3 id="1-用户权限授权"><a href="#1-用户权限授权" class="headerlink" title="1.用户权限授权"></a>1.用户权限授权</h3><p>是对用户身份认证的细化。可简单理解为访问控制，在用户身份认证通过后，系统对用户访问菜单或按钮进行控制。也就是说，该用户有身份进入系统了，但他不一定能访问系统里的所有菜单或按钮，而他只能访问管理员给他分配的权限菜单或按钮。<br> 主要包括：</p><ul><li>Permission（权限标识、权限字符串）：针对系统访问资源的权限标识，如：用户添加、用户修改、用户删除。</li><li>Role （角色）：可以理解为权限组，也就是说角色下可以访问和点击哪些菜单、访问哪些权限标识。</li></ul><p>权限标识或权限字符串校验规则：</p><ul><li>权限字符串：指定权限串必须和菜单中的权限标识匹配才可访问</li><li><strong>权限字符串命名规范为：<code>模块:功能:操作</code>，例如：<code>sys:user:edit</code></strong></li><li>使用冒号分隔，对授权资源进行分类，如 <code>sys:user:edit</code> 代表 <code>系统模块:用户功能:编辑操作</code></li><li>设定的功能指定的<code>权限字符串</code>与当前用户的<code>权限字符串</code>进行匹配，若匹配成功说明当前用户有该功能权限</li><li>还可以使用简单的通配符，如 <code>sys:user:*</code>，建议省略为 <code>sys:user</code>（分离前端不能使用星号写法）</li><li>举例1 <code>sys:user</code> 将于 <code>sys:user</code> 或 <code>sys:user:</code> 开头的所有权限字符串匹配成功</li><li>举例2 <code>sys</code> 将于 <code>sys</code> 或 <code>sys:</code> 开头的所有权限字符串匹配成功 这种命名格式的好处有：</li></ul><ol><li><strong>可读性和可理解性</strong>：使用模块、功能和操作的格式可以直观地表达权限的含义。每个部分都有明确的作用，模块表示特定的模块或子系统，功能表示模块内的某个功能或页面，操作表示对功能进行的具体操作。通过这种格式，权限名称可以更容易地被开发人员、管理员和其他人员理解和解释。</li><li><strong>可扩展性和灵活性：</strong> 通过使用模块、功能和操作的格式，可以轻松地扩展和管理权限。每个模块、功能和操作都可以被单独定义和控制。当系统需要增加新的功能或操作时，可以根据需要添加新的权限字符串，而不需要修改现有的权限规则和代码。</li><li><strong>细粒度的权限控制：</strong> 这种格式支持细粒度的权限控制，可以针对特定的功能和操作进行权限管理。通过将权限名称拆分为模块、功能和操作，可以精确地定义哪些用户或角色具有访问或操作特定功能的权限。</li><li><strong>避免权限冲突：</strong> 使用模块、功能和操作的格式可以避免权限之间的冲突。不同模块、功能和操作的权限名称是唯一的，这样可以避免同名权限之间的混淆和冲突。</li></ol><h3 id="2-权限管理模型"><a href="#2-权限管理模型" class="headerlink" title="2.权限管理模型"></a>2.权限管理模型</h3><p>关键数据模型如下：</p><ul><li>用户：登录账号、密码、角色</li><li>角色：角色名称、角色权限字符、对应菜单、对应菜单下的权限</li><li>菜单：菜单名称、菜单URL、菜单类型</li><li>用户角色关系：用户编码、角色编码</li><li>角色菜单关系：角色编码、菜单编码</li></ul><p>关系图如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【用户】  &lt;---多对多---&gt;  【角色】  &lt;---多对多---&gt;  【菜单/权限】</span><br></pre></td></tr></table></figure><h2 id="3-实现思路与步骤"><a href="#3-实现思路与步骤" class="headerlink" title="3.实现思路与步骤"></a>3.实现思路与步骤</h2><p>前端权限一般分为路由级权限和按钮级权限，这里我们先实现页面路由级的权限功能，按钮级的会在后面讲到。大致的思路如下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c877eecd8dcb49c89cd5a294331804a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="飞书20230324-135033.png" title>                </div>                <div class="image-caption">飞书20230324-135033.png</div>            </figure> 上图是用户从`登录-->路由守卫-->权限验证-->构建路由表-->跳转目标页面`的一个简单的正向流程，可以看到，`权限验证`和`构建路由表`这两步是发生在`路由守卫`这一步里，而实际上在开发设计阶段，我们还要做的准备有：<ol><li>与后端确认权限字段及类型</li><li>确定路由表信息是由前端还是后端生成</li></ol><p>为了方便理解，我们就按照这个正向流程来逐步实现，期间需要用到或者提前考虑设计到的内容，包括以上需要准备的两点，我会补充在步骤当中。</p><h4 id="1-登录"><a href="#1-登录" class="headerlink" title="1.登录"></a>1.登录</h4><p>登录成功后，获取到token,将token存到本地的sessionStorage里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// action.js</span><br><span class="line">async login(&#123; commit &#125;, userInfo) &#123;</span><br><span class="line">    const &#123; data &#125; = await login(userInfo)</span><br><span class="line">    const accessToken = &apos;Bearer &apos; + data.access_token</span><br><span class="line">    if (accessToken) &#123;</span><br><span class="line">      sessionStorage.getItem(tokenTableName)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      message.error(`登录接口异常，未正确返回$&#123;tokenName&#125;...`)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>接着，进行路由跳转到首页</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// login.vue</span><br><span class="line">import &#123; useRouter &#125; from &apos;vue-router&apos;;</span><br><span class="line">const router = useRouter(); </span><br><span class="line">router.push(&apos;/&apos;);</span><br></pre></td></tr></table></figure><p>如果考虑到页面token失效后，重新登陆后返回原先的路由地址，则需要在路由守卫中添加<code>redirect</code>字段用来存储当前的路由地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// permissions.js</span><br><span class="line">next(&#123; path: &apos;/login&apos;, query: &#123; redirect: to.fullPath &#125;, replace: true &#125;)</span><br></pre></td></tr></table></figure><p>然后在登录页中，监听路由对象中的这个值，如果有值，那么在刚刚路由跳转时，就跳转到该路由地址，而非<code>/</code>首页，另外，还需要考虑到403，404页面。所以，添加了这些逻辑后，部分代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// login.vue</span></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref, watch, useRouter &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">'vue-router'</span>;</span><br><span class="line"><span class="keyword">const</span> redirect = ref(<span class="string">'/'</span>);</span><br><span class="line"><span class="keyword">const</span> router = useRouter();</span><br><span class="line"></span><br><span class="line">watch(</span><br><span class="line">  () =&gt; router.currentRoute.value.query.redirect,</span><br><span class="line">  (redirectValue) =&gt; &#123;</span><br><span class="line">    redirect.value = redirectValue || <span class="string">'/'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">immediate</span>: <span class="literal">true</span> &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleRoute</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redirect.value === <span class="string">'/404'</span> || redirect.value === <span class="string">'/403'</span></span><br><span class="line">          ? <span class="string">'/'</span></span><br><span class="line">          : redirect.value</span><br><span class="line">      &#125;,</span><br><span class="line">      </span><br><span class="line"> <span class="keyword">async</span> handleSubmit() &#123;</span><br><span class="line">        loading.value = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">await</span> login(form.value)</span><br><span class="line">          loading.value = <span class="literal">false</span></span><br><span class="line">          router.push(handleRoute());</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">         loading.value = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,      </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-路由守卫与权限校验"><a href="#2-路由守卫与权限校验" class="headerlink" title="2.路由守卫与权限校验"></a>2.路由守卫与权限校验</h4><p>当进行路由跳转时，会进入到路由守卫中，在路由守卫中：</p><ol><li>路由守卫会首先判断有没有token，如果没有，先判断要去的路由地址是否包含在路由白名单内，如果要去的路由地址也不在路由白名单内，就会让用户跳转到登录页重新登陆。</li><li>如果有token，会先判断跳转的目标地址是否是登录页，如果是，则重新跳转到默认首页</li><li>此时，我们就需要对用户权限进行校验，首先，判断当前用户是否<code>拥有角色</code>信息,如果没有，就要获取用户的角色信息。</li></ol><h4 id="3-获取角色信息与权限信息"><a href="#3-获取角色信息与权限信息" class="headerlink" title="3.获取角色信息与权限信息"></a>3.获取角色信息与权限信息</h4><p>调取用户信息接口获取用户角色信息和权限信息,代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//store/user</span></span><br><span class="line"> <span class="comment">// 获取用户信息</span></span><br><span class="line">  GetInfo(&#123; commit, dispatch &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      getUserInfo()</span><br><span class="line">        .then(<span class="keyword">async</span> (response) =&gt; &#123;</span><br><span class="line">          <span class="keyword">const</span> result = response.data</span><br><span class="line">          <span class="keyword">if</span> (result.roles &amp;&amp; result.roles.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 验证返回的roles是否是一个非空数组</span></span><br><span class="line">            commit(<span class="string">'SET_ROLES'</span>, result.roles)</span><br><span class="line">            <span class="comment">//permissions就是对应的用户权限信息</span></span><br><span class="line">            commit(<span class="string">'SET_PERMISSION'</span>, result.permissions)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果当前用户没有角色，则赋值一个默认角色</span></span><br><span class="line">            commit(<span class="string">'SET_ROLES'</span>, [<span class="string">'ROLE_DEFAULT'</span>]) </span><br><span class="line">          &#125;</span><br><span class="line">          resolve(result)</span><br><span class="line">          <span class="comment">// GetInfo一旦失败就说明这个token不是过期就是丢失了,直接走catch并让调用方跳转路由</span></span><br><span class="line">          <span class="keyword">if</span> (!response.success) &#123;</span><br><span class="line">            reject(response.errorMsg)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>根据之前上文提到的权限管理模型，从之间的关系是多对多，因此，<code>role(角色）</code>和<code>permssions(权限）</code>的类型应为数组，其中的权限permssion这个字段的格式规范也在上文提及。在与后端约定好后，后端返回的信息如图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98b02dc32a454dd4add24adbaf6b8251~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png" title>                </div>                <div class="image-caption">image.png</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22ee056f3dab483f9d055afb3cdc3009~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png" title>                </div>                <div class="image-caption">image.png</div>            </figure><h4 id="4-谁来生成动态路由表？"><a href="#4-谁来生成动态路由表？" class="headerlink" title="4.谁来生成动态路由表？"></a>4.谁来生成动态路由表？</h4><p>在成功获取到用户信息，拿到用户角色和对应权限后，此时，就需要根据权限生成对应的路由表了，到这里，我们需要思考一个问题：<br> <strong>路由表是由后端提供还是由前端提供？</strong><br> A:前端根据权限生成路由表<br> B:后端生成路由表给前端</p><p>没错！答案是C：路由表可以由后端提供或由前端提供。 <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e29e88edd9a14774b1a11253f1981a7f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="9b7ce6e5503212cdd80bfe8bc78040b9.jpg" title>                </div>                <div class="image-caption">9b7ce6e5503212cdd80bfe8bc78040b9.jpg</div>            </figure></p><p>两者的优劣分别是：</p><p><strong>后端提供路由表：</strong></p><ul><li>优点：<ul><li>安全性高：后端负责验证和控制权限，可以确保只有授权的用户能够访问特定的路由和功能。</li><li>隐藏敏感信息：后端可以根据用户的角色和权限隐藏不应该被访问的敏感路由和数据。</li><li>适用于复杂的权限规则：后端可以使用更复杂的逻辑和规则来处理权限控制，例如基于用户角色、用户组、权限等的复杂控制逻辑。</li></ul></li><li>缺点：<ul><li>前后端耦合度高：由于路由表由后端提供，前端开发人员可能需要与后端开发人员密切协作，增加了协调和沟通的成本。</li><li>前端依赖后端：前端应用程序可能需要等待后端提供路由表后才能进行开发和测试，增加了开发的时间和依赖性。</li></ul></li></ul><p><strong>前端提供路由表：</strong></p><ul><li>优点：<ul><li>前后端解耦：前端可以独立开发和维护路由表，减少了与后端的依赖性和协调成本。</li><li>更好的用户体验：前端可以根据用户的角色和权限动态展示路由和功能，提供更灵活和个性化的用户体验。</li></ul></li><li>缺点：<ul><li>安全性较低：前端提供的路由表容易受到篡改和绕过，安全性相对较低。</li><li>隐藏敏感信息的难度增加：前端无法直接隐藏敏感路由和数据，需要依赖后端接口的授权验证来保护敏感信息。</li></ul></li></ul><p>最终，考虑到后台管理系统的安全性优先级最高，我选择了由后端存储，并生成返回路由表信息。 确定好了之后，你就会遇到一个坑：<strong>后端提供的路由表无法直接在前端路由中添加使用</strong> 这是因为，后端存储的路由表的结构只一个JSON对象。怎么解决，我们放到后面讲。</p><h4 id="5-公共路由和动态路由"><a href="#5-公共路由和动态路由" class="headerlink" title="5.公共路由和动态路由"></a>5.公共路由和动态路由</h4><p>我们现在把整个路由分为两个部分，分别是<code>公共路由</code>和<code>动态路由（私有路由）</code>。</p><h5 id="公共路由"><a href="#公共路由" class="headerlink" title="公共路由"></a>公共路由</h5><p>公共路由顾名思义就是无论当前用户是什么角色，都会出现的路由部分。一般这样的路由分别有：首页驾驶舱、登录注册页、403页、404页。  <strong>这部分路由是在前端项目中提前写死的。</strong><br> 以我的项目为例，我在src/config下创建一个<code>publicRouter.js</code>文件，然后里面放入基础路由信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基础公共路由</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> constantRouterMap = [</span><br><span class="line">&#123;</span><br><span class="line"> path: <span class="string">'/'</span>,</span><br><span class="line"> name: <span class="string">''</span>,</span><br><span class="line"> component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/layout'</span>),</span><br><span class="line"> redirect: <span class="string">'/homePage'</span>,</span><br><span class="line"> children: [</span><br><span class="line">   &#123;</span><br><span class="line">     path: <span class="string">'/homePage'</span>,</span><br><span class="line">     name: <span class="string">'homePage'</span>,</span><br><span class="line">     component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/homePage/index.vue'</span>),</span><br><span class="line">   &#125;,</span><br><span class="line"> ],</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"> path: <span class="string">'/login'</span>,</span><br><span class="line"> component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/login'</span>),</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"> path: <span class="string">'/403'</span>,</span><br><span class="line"> name: <span class="string">'403'</span>,</span><br><span class="line"> component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/403'</span>),</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"> path: <span class="string">'/:pathMatch(.*)*'</span>,</span><br><span class="line"> component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/404'</span>),</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>这里面都是路由懒加载的写法，这个没啥好说的。需要注意的是在vue3中，vue-router的版本是4.x以上，在跳转404页面时，如果你的写法是</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attribute">path</span>: <span class="string">"/404"</span>,</span><br><span class="line"> name: <span class="string">"notFound"</span>,</span><br><span class="line"> component:  () =&gt; <span class="built_in">import</span>(<span class="string">'@/views/404'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写会提示报错，这是因为vue-router4.x的版本官方推荐引入了这种新写法，配置一个通配符路由，匹配所有未被其他具体路由匹配的路径。其中 <code>:pathMatch</code> 是参数名，而 <code>(.*)*</code> 是参数的匹配模式，它使用正则表达式来匹配任意路径。</p><h5 id="动态路由-私有路由）"><a href="#动态路由-私有路由）" class="headerlink" title="动态路由(私有路由）"></a>动态路由(私有路由）</h5><p>上文提到的后端返回给前端当前用户的路由表信息，其实就是私有路由，这部分的路由是动态的。那么我们只需要把<code>公共路由</code>+<code>动态路由</code>=<code>当前角色用户完整路由表</code>。然鹅，<strong>后端返回给前端的动态路由是无法直接添加到当前页面路由中的</strong>，这是因为在浏览器的前后端请求当中，信息的返回体都是以JSON字符串的数据交换格式进行传输，而JSON字符串是不支持函数的。为什么要提到函数形式呢？<br> <strong>因为当我们在路由表使用懒加载的写法时，<code>component</code>的值是一个异步函数。也只有异步函数才能实现对路由的异步懒加载。import（）会返回一个promise，这个 promise 最终会加载对应的组件模块。在格式上表现为一个func函数，因此，我们无法将compnent的值传给后端存储</strong><br> 但是办法总比困难多，我们可以将对应的路径字符串传给后端存储，然后再通过后端返回的路径字符串转换成这种箭头函数的写法。<br> 除了这个需要转换以外，我们还要考虑一些问题：</p><ol><li>比如，转换后的路由结构要符合router中的路由格式，否则会在调用router.addRoutes时报错，添加失败。</li><li>添加一些其他自定义属性（例如添加导航栏菜单图标、某个路由的显隐、路由缓存、跳转外链接、…），以满足特定需求。<br> 以我项目中的的路由示例，直接上代码看：</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "path": "/",  //path,路由的路径，即访问该路由时的 URL 路径。</span><br><span class="line">    "name": "homePage",//name,路由的名称，用于在代码中标识路由。通常用于编程式导航。</span><br><span class="line">    "hidden": false,//hidden,是否隐藏路由，在Vue Router 4.0 中被废弃。</span><br><span class="line">    "component": "Layout"//路由对应的组件，可以是通过懒加载方式导入的异步组件，或直接引入的同步组件。</span><br><span class="line">    "meta": &#123;//meta,路由元信息，可以用于存储一些额外的信息，比如页面标题、权限等</span><br><span class="line">        "title": "首页",   //路由标题</span><br><span class="line">        "icon": "icon-Home", //路由图标</span><br><span class="line">        "target": "", //是否跳转新页签</span><br><span class="line">        "permission": "homePage",//权限</span><br><span class="line">        "keepAlive": false//是否缓存</span><br><span class="line">    &#125;,</span><br><span class="line">    "redirect": "/homePage",//重定向</span><br><span class="line">    "fullPath": "/",//完整的url路径，会带上？后面的参数</span><br><span class="line">    "children": [//子路由</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"path"</span>: <span class="string">"/homePage"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"homePage"</span>,</span><br><span class="line">            <span class="attr">"meta"</span>: &#123;</span><br><span class="line">                <span class="attr">"title"</span>: <span class="string">"首页"</span>,</span><br><span class="line">                <span class="attr">"icon"</span>: <span class="string">""</span>,</span><br><span class="line">                <span class="attr">"target"</span>: <span class="string">""</span>,</span><br><span class="line">                <span class="attr">"permission"</span>: <span class="string">"homePage"</span>,</span><br><span class="line">                <span class="attr">"keepAlive"</span>: <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"fullPath"</span>: <span class="string">"/homePage"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑完这些之后，我们就开始拿着后端返回的路由表信息动手转换吧！ 先看看后端返回给前端的路由表格式内容</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d2b8f49dac546bd8813923e1882a4ac~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png" title>                </div>                <div class="image-caption">image.png</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a90144671a74d8b9c286bce9da788b6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png" title>                </div>                <div class="image-caption">image.png</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/489bf32154da4cd684cbb50eb850161b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png" title>                </div>                <div class="image-caption">image.png</div>            </figure> 这里你只需要注意component这个字段的值就行了。<p> 可能有人会问：<strong>“那我给后端传的路由表是什么格式的，也是这样吗？”</strong><br> 答案是：<strong>当然不是！RBAC权限方案中，用户可以自己配置权限，也就是会有对应的用户管理，角色管理，菜单（权限）管理这三个基本的模块，给后端传的是对应模块的修改配置内容。前端是不需要关心传给后端什么格式。</strong> 有点啰嗦了，总之，就是你指着上文这三张图片，让后端给你生成出来就完事了。后端要是说办不到，那就是后端的问题。<br> <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c25c2d91918d4035943ec7991671d2e6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="297708da4a493456bfcab94617c1ac55.jpg" title>                </div>                <div class="image-caption">297708da4a493456bfcab94617c1ac55.jpg</div>            </figure></p><h4 id="6-RBAC的权限配置项"><a href="#6-RBAC的权限配置项" class="headerlink" title="6.RBAC的权限配置项"></a>6.RBAC的权限配置项</h4><p>上文提到了三个基本的配置模块，分别是<code>用户管理</code>，<code>角色管理</code>，<code>菜单（权限）管理</code>,按照先后顺序，我们首先要新建一个权限，<code>在页面级的权限中，权限是跟每个页面路由一一对应的</code>，所以当我们需要新建一个权限的时候，也就是在新建一个页面路由。而为了方便知道所有页面权限之间的层级关系，最终的展现形式就是一个<strong>树形表格结构</strong>：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7655538c1a814518ab24d3f2c12b6ede~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png" title>                </div>                <div class="image-caption">image.png</div>            </figure><p> 可以看到，在页面路由（权限）配置项里，单个路由的各个都可以进行修改配置，这就让整个项目的路由表的可维护性和灵活度都极大的提高。需要注意的是<code>路由地址</code>和<code>组件路径</code>这两个配置项，路由地址可以随意命名，但是<strong>同层级下，必须唯一</strong>。<br> 而组件路径里面的值就是<strong>相对src目录的相对路径</strong>。比如我新建一个部门管理页面权限，一般在前端路由中的懒加载写法是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/login'</span>),</span><br></pre></td></tr></table></figure><p>但在这个配置项中，只需要填入login这个字段就行了。原因是因为前面的这些字段会在后面对路由的格式化中进行处理。虽然后续步骤会讲到这一步，但这里我还是先贴出来，方便你理解：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">component:</span><br><span class="line">       constantRouterComponents[item.component || item.key] ||</span><br><span class="line">       (<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">         <span class="keyword">import</span>(<span class="string">`@/views/<span class="subst">$&#123;item.component&#125;</span>`</span>).catch(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">           <span class="keyword">import</span>(<span class="string">'@/views/404'</span>)</span><br><span class="line">         )),</span><br></pre></td></tr></table></figure><p>那有人就会问，如果我乱填一个不存在的组件路径地址怎么办？正常情况下这样会导致整个动态路由在构建过程中报错，从而导致白屏。所以，上述代码里的<code>.catch</code>会捕获这个错误，然后跳转到404页面，再从404页面跳转到首页。就像这样：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18ffa074616f45a09a0c4e03e80698a7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png" title>                </div>                <div class="image-caption">image.png</div>            </figure> 当我们配置好权限后，会将新增的路由配置信息发送给后端，**后端根据这些配置信息，会在对应的路由表中添加这个路由，并生成新的路由表返回给前端**。<p> 那当我们有一个权限之后，该怎么配置给对应的用户呢？还记得我上文提及的RBAC的权限管理模型嘛：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e147dc7693b04501af601fd2ecc0667b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png" title>                </div>                <div class="image-caption">image.png</div>            </figure><p> 就是按照关系图中，我们将权限分配给角色，所以，就要有<code>角色管理</code>这个模块来进行分配：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15a5414b8de44b4a84732266675d07f0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png" title>                </div>                <div class="image-caption">image.png</div>            </figure><p> <code>用户管理</code>也是依葫芦画瓢，跟<code>角色管理</code>如出一辙，碍于篇幅，就不再过多赘述。每一个配置项都可以根据你的业务场景和需要，进行增减。</p><h4 id="7-获取动态路由（私有路由）并转换"><a href="#7-获取动态路由（私有路由）并转换" class="headerlink" title="7.获取动态路由（私有路由）并转换"></a>7.获取动态路由（私有路由）并转换</h4><p>言归正传，接下来，这一步是整个前端权限中最重要的一步。在src/router下，我们新建一个generatorRouters.js文件。里面的内容是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getCurrentUserNav获取动态路由的接口</span></span><br><span class="line"><span class="keyword">import</span> &#123; getCurrentUserNav &#125; <span class="keyword">from</span> <span class="string">'@/api/user'</span></span><br><span class="line"><span class="comment">//validURL是一个正则判断方法，用来校验当前字符串是否符合url外链格式</span></span><br><span class="line"><span class="keyword">import</span> &#123; validURL &#125; <span class="keyword">from</span> <span class="string">'@/utils/validate'</span></span><br><span class="line"><span class="comment">// 前端路由表</span></span><br><span class="line"><span class="keyword">const</span> constantRouterComponents = &#123;</span><br><span class="line">  <span class="comment">// 基础页面 layout 必须引入</span></span><br><span class="line">  Layout: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/layout'</span>),</span><br><span class="line">  <span class="number">403</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/403'</span>),</span><br><span class="line">  <span class="number">404</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/404'</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态生成菜单</span></span><br><span class="line"><span class="comment"> * @param token</span></span><br><span class="line"><span class="comment"> * @returns &#123;Promise&lt;Router&gt;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> generatorDynamicRouter = <span class="function">(<span class="params">token</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    getCurrentUserNav()</span><br><span class="line">      .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="comment">//接收后端返回的路由表，结构是个数组</span></span><br><span class="line">        <span class="keyword">let</span> menuNav = res.data</span><br><span class="line">        <span class="comment">//将路由表存到本地临时缓存中</span></span><br><span class="line">        <span class="comment">//这一步是为了刷新的时候不需要再调接口，增加用户体验的，没这方面需求可以不用写</span></span><br><span class="line">        sessionStorage.setItem(<span class="string">'generateRoutes'</span>, <span class="built_in">JSON</span>.stringify(menuNav))</span><br><span class="line">        <span class="comment">//转化路由格式</span></span><br><span class="line">        <span class="keyword">const</span> routers = generator(menuNav)</span><br><span class="line">        resolve(routers)</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 格式化树形结构数据 生成 vue-router 层级路由表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param routerMap //当前路由表route</span></span><br><span class="line"><span class="comment"> * @param parent//当前路由表route的父级component</span></span><br><span class="line"><span class="comment"> * @returns &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> generator = <span class="function">(<span class="params">routerMap, parent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> routerMap.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; title, show, hideChildren, hiddenHeaderContent, icon, hidden &#125; =</span><br><span class="line">      item.meta || &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (item.component) &#123;</span><br><span class="line">      <span class="comment">// Layout ParentView 组件特殊处理</span></span><br><span class="line">      <span class="comment">//这里是对父组件/布局组件的处理，因为有可能出现嵌套布局和多种布局的情况，这个时候需要进行处理。</span></span><br><span class="line">      <span class="keyword">if</span> (item.component === <span class="string">'Layout'</span>) &#123;</span><br><span class="line">        item.component = <span class="string">'Layout'</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.component === <span class="string">'ParentView'</span>) &#123;</span><br><span class="line">        item.component = <span class="string">'BasicLayout'</span></span><br><span class="line">        item.path = <span class="string">'/'</span> + item.path</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (item.isFrame === <span class="number">0</span>) &#123;</span><br><span class="line">      item.target = <span class="string">'_blank'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> currentRouter = &#123;</span><br><span class="line">      <span class="comment">// 如果路由设置了 path，则作为默认 path，否则 路由地址 动态拼接生成如 /dashboard/workplace</span></span><br><span class="line">      path: item.path || <span class="string">`<span class="subst">$&#123;(parent &amp;&amp; parent.path) || <span class="string">''</span>&#125;</span>/<span class="subst">$&#123;item.key&#125;</span>`</span>,</span><br><span class="line">      <span class="comment">// 路由名称，建议唯一</span></span><br><span class="line">      <span class="comment">// name: item.name || item.key || '',</span></span><br><span class="line">      name: item.name || item.key || <span class="string">''</span>,</span><br><span class="line">      <span class="comment">// 该路由对应页面的 组件 :方案1</span></span><br><span class="line">      <span class="comment">// 该路由对应页面的 组件 :方案2 (动态加载)</span></span><br><span class="line">      <span class="comment">//这里就是将component的字符串值转换成懒加载的异步函数</span></span><br><span class="line">      <span class="comment">//同时，如果当前路径并没有对应的组件，catch捕获报错，然后跳转到404页，这一步很重要，否则</span></span><br><span class="line">      component:</span><br><span class="line">        constantRouterComponents[item.component || item.key] ||</span><br><span class="line">        (<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">          <span class="keyword">import</span>(<span class="string">`@/views/<span class="subst">$&#123;item.component&#125;</span>`</span>).catch(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">            <span class="keyword">import</span>(<span class="string">'@/views/404'</span>)</span><br><span class="line">          )),</span><br><span class="line">      hidden: item.hidden,</span><br><span class="line">      <span class="comment">// redirect: '/' + item.path || `$&#123;parent &amp;&amp; parent.path || ''&#125;/$&#123;item.key&#125;`,</span></span><br><span class="line">      <span class="comment">// meta: 页面标题, 菜单图标, 页面权限(供指令权限用，可去掉)</span></span><br><span class="line">      meta: &#123;</span><br><span class="line">        title: title,</span><br><span class="line">        icon: icon,</span><br><span class="line">        hiddenHeaderContent: hiddenHeaderContent,</span><br><span class="line">        target: validURL(item.path) ? <span class="string">'_blank'</span> : <span class="string">''</span>,</span><br><span class="line">        permission: item.name,</span><br><span class="line">        keepAlive: <span class="literal">false</span>,</span><br><span class="line">        hidden: hidden,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//适配本框架的跳转路径</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否设置了隐藏菜单</span></span><br><span class="line">    <span class="keyword">if</span> (show === <span class="literal">false</span>) &#123;</span><br><span class="line">      currentRouter.hidden = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修正路径，而antdv-pro的pro-layout要求每个路径需为全路径</span></span><br><span class="line">    <span class="comment">//这一步的修正路径也是因人而异，正常情况下按照我这样拼接就没问题了</span></span><br><span class="line">    <span class="keyword">if</span> (!constantRouterComponents[item.component || item.key]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (parent &amp;&amp; parent.path &amp;&amp; parent.path !== <span class="string">'/'</span>) &#123;</span><br><span class="line">        currentRouter.path = <span class="string">`<span class="subst">$&#123;parent.path&#125;</span>/<span class="subst">$&#123;item.path&#125;</span>`</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否设置了隐藏子菜单</span></span><br><span class="line">    <span class="keyword">if</span> (hideChildren) &#123;</span><br><span class="line">      currentRouter.hideChildrenInMenu = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重定向</span></span><br><span class="line">    item.redirect &amp;&amp; (currentRouter.redirect = item.redirect)</span><br><span class="line">    <span class="comment">//添加fullPath</span></span><br><span class="line">    currentRouter.fullPath = currentRouter.path</span><br><span class="line">    <span class="comment">// 是否有子菜单，并递归处理</span></span><br><span class="line">    <span class="keyword">if</span> (item.children &amp;&amp; item.children.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      currentRouter.children = generator(item.children, currentRouter)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currentRouter</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="generatorDynamicRouter方法（promise嵌套）"><a href="#generatorDynamicRouter方法（promise嵌套）" class="headerlink" title="generatorDynamicRouter方法（promise嵌套）"></a>generatorDynamicRouter方法（promise嵌套）</h5><p>上面的代码有点多，不要觉得麻烦，其实就两个方法，第一个方法<code>generatorDynamicRouter</code>会调取后端接口，<strong>获取后端返回的私有路由表信息</strong>，返回的是个<code>promise对象</code>，因为需要调接口请求后端数据，并且其他方法依赖这个方法的接口返回值，所以是个异步函数。之所以这么写的另外一个原因，是因为在它之前还有个promise异步方法包着它。<br> 我们都知道：<strong>在嵌套的 Promise 中，内部的 Promise 会先执行，然后再执行外部的 Promise。这是由于 JavaScript 的异步执行机制所决定的。</strong> 所以这种套娃式的目的只有一个——<strong>就是确保外层的异步方法在调用内部异步方法时，能够保证拿到内部异步方法请求成功之后的返回值</strong>（也就是将异步方法变成同步方法，这也是Promise主要的作用之一，面试常问的）。</p><p>而最外层的异步方法，是放在路由守卫当中直接调用的，由于我们是动态异步加载路由，那么执行的方法肯定也是异步。具体的原因是因为：<br> <strong>如果动态加载路由的方法不是异步的，那么在路由守卫中使用它将导致它立即执行并返回一个 Promise，而不是在路由导航过程中延迟加载。这样会使得在路由守卫中的逻辑无法按预期执行，因为在组件加载完成之前，它依赖的组件可能还没有被加载，导致出现错误或不一致的状态。</strong></p><p><strong>从后端获取路由配置往往涉及到网络请求和异步操作，不能保证立即返回所有路由信息。当你从后端获取到路由配置后，需要将其添加到 Vue Router 中，以便在前端应用程序中进行动态路由。在这个过程中，你需要使用异步操作来确保在获取到路由配置后再添加到路由中。</strong></p><h5 id="generator方法（递归转化）"><a href="#generator方法（递归转化）" class="headerlink" title="generator方法（递归转化）"></a>generator方法（递归转化）</h5><p>言归正传，<code>generatorDynamicRouter</code>方法调取后端接口，拿到后端返回路由表信息后，会紧接着调用第二个<code>generator</code>方法，并将路由表信息当做参数传入。而<code>generator</code>是一个递归方法。这个也很好理解，因为路由信息里都会包含children子路由，需要层层递归，<code>generator</code>内部会对每一个路由进行<strong>逐层转化</strong>，每一步都在代码中标有注释，我就不再过多赘述了。我们只需要知道：<strong><code>generator</code>的最终目的就是将后端返回的路由表结构转化成符合前端路由格式的路由</strong>（听起来有点绕）。<br> 附上格式化好之后的路由信息： <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6812a0c51feb43b7b01cef919c75ce3e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3d0b3b606354dbeb064da7b21d406fd~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?) 再对比下格式化之前的样子： ![image.png" title>                </div>                <div class="image-caption">image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3d0b3b606354dbeb064da7b21d406fd~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?) 再对比下格式化之前的样子： ![image.png</div>            </figure> 可以看到component从字符串变成了函数，path路径也得到了拼接补充。</p><h4 id="8-存储格式化好的动态路由及导航栏菜单信息"><a href="#8-存储格式化好的动态路由及导航栏菜单信息" class="headerlink" title="8.存储格式化好的动态路由及导航栏菜单信息"></a>8.存储格式化好的动态路由及导航栏菜单信息</h4><p>上文提到在generatorDynamicRouter异步方法之外还有一层异步方法，其实我是放在了vuex的store下某个模块中的actions里（默认大家都会用vuex）。具体代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  GenerateRoutes(&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">let</span> sidebarList = []</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      generatorDynamicRouter().then(<span class="function">(<span class="params">routers</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//sidebarList是侧边栏渲染数据</span></span><br><span class="line">        sidebarList = routers</span><br><span class="line">        <span class="comment">//routers就是我们要存储到vuex中的动态路由</span></span><br><span class="line">        commit(<span class="string">'set_routers'</span>, routers)</span><br><span class="line">        <span class="comment">//侧边栏数据存到vuex中</span></span><br><span class="line">        commit(<span class="string">'set_sidebarList'</span>, sidebarList)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-添加动态路由"><a href="#9-添加动态路由" class="headerlink" title="9.添加动态路由"></a>9.添加动态路由</h4><p>好了，到这一步，我们就拿到了准备好的<code>公共路由</code>和<code>私有路由</code>。这个时候，我们再回到路由守卫，回顾一下之前的流程：</p><ol><li>路由守卫先判断token</li><li>没有token去登录拿token（或者是直接去了白名单里）</li><li>拿到token后判断有没有角色信息，没有角色信息就去请求角色信息（调接口）</li><li>拿到角色信息后，再去获取对应角色信息的路由表（调接口）</li><li>将后端返回的路由表信息转换成前端能添加的路由表信息格式</li><li>添加路由</li><li>跳转对应路由页面</li></ol><p>现在，我们来到了第6步，添加路由，在添加路由之前，先看下路由守卫：<br> 路由守卫的代码如下，在src/config目录下新建文件<code>permissions.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'@/router'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'@/store'</span></span><br><span class="line"><span class="keyword">import</span> getPageTitle <span class="keyword">from</span> <span class="string">'@/utils/pageTitle'</span></span><br><span class="line"><span class="keyword">import</span> getInfoRouter <span class="keyword">from</span> <span class="string">'@/router/getInfoRouter'</span></span><br><span class="line"><span class="keyword">import</span> &#123; loginInterception, recordRoute, routesWhiteList &#125; <span class="keyword">from</span> <span class="string">'@/config'</span></span><br><span class="line">router.beforeEach(<span class="keyword">async</span> (to, <span class="keyword">from</span>, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> hasToken = store.getters[<span class="string">'user/accessToken'</span>]</span><br><span class="line">  <span class="keyword">if</span> (hasToken) &#123;</span><br><span class="line">    <span class="keyword">if</span> (to.path === <span class="string">'/login'</span>) &#123;</span><br><span class="line">      next(&#123; <span class="attr">path</span>: <span class="string">'/'</span> &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//权限校验</span></span><br><span class="line">      <span class="keyword">if</span> (store.getters[<span class="string">'user/roles'</span>].length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取用户信息，包括角色信息和权限信息</span></span><br><span class="line">           <span class="keyword">await</span> store.dispatch(<span class="string">'user/GetInfo'</span>)</span><br><span class="line">            <span class="comment">//获取动态路由表信息，并对路由表进行格式转化，然后存到vuex中</span></span><br><span class="line">           <span class="keyword">await</span> store.dispatch(<span class="string">'async-router/GenerateRoutes'</span>)</span><br><span class="line">            <span class="comment">//从vuex中拿到动态路由表数据</span></span><br><span class="line">           <span class="keyword">let</span> accessRoutes = store.getters[<span class="string">'async-router/addRouters'</span>]</span><br><span class="line">            <span class="comment">//循环添加路由</span></span><br><span class="line">           accessRoutes.forEach(<span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//isHttp方法用来判断是否是外链，如果是外链，就不添加到当前路由表中</span></span><br><span class="line">            <span class="keyword">if</span> (!isHttp(route.path)) &#123;</span><br><span class="line">              router.addRoute(route) <span class="comment">// 动态添加可访问路由表</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="comment">//刷新跳转</span></span><br><span class="line">          next(&#123; ...to, <span class="attr">replace</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="comment">//登出</span></span><br><span class="line">          <span class="keyword">await</span> store.dispatch(<span class="string">'user/Logout'</span>)</span><br><span class="line">          <span class="comment">//记录登出前的路由地址</span></span><br><span class="line">          next(&#123; <span class="attr">path</span>: <span class="string">'/login'</span>, <span class="attr">query</span>: &#123; <span class="attr">redirect</span>: to.fullPath &#125; &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//判断是否在白名单中</span></span><br><span class="line">    <span class="keyword">if</span> (routesWhiteList.indexOf(to.path) !== <span class="number">-1</span>) &#123;</span><br><span class="line">      next()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//记录跳转到登录页之前的路由地址</span></span><br><span class="line">      next(&#123; <span class="attr">path</span>: <span class="string">'/login'</span>, <span class="attr">query</span>: &#123; <span class="attr">redirect</span>: to.fullPath &#125;, <span class="attr">replace</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">router.afterEach(<span class="function">(<span class="params">to</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//浏览器页签标题</span></span><br><span class="line">  <span class="built_in">document</span>.title = getPageTitle(to.meta.title)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>在vue-router4.x版本中</strong>，往当前的路由<code>router</code>对象中动态添加路由时，需要使用官方提供的<code>addRoute方法</code>，不能直接对router对象进行修改，这是因为vue-router必须是要vue在实例化之前就挂载上去的。<code>addRoute方法</code>传入的参数是<strong>单个路由对象</strong>,所以写法上我们需要对动态路由数组进行for循环，在内部调用<code>addRoute方法</code>，从而达到成功添加多个动态路由的目的。这里附上官方API地址链接：<a href="https://link.juejin.cn?target=https%3A%2F%2Frouter.vuejs.org%2Fzh%2Fapi%2Finterfaces%2FRouter.html%23Methods-addRoute" target="_blank" rel="noopener">router.vuejs.org/zh/api/inte…</a><br> 添加完路由之后，调用<code>next({ ...to, replace: true })</code>,就会成功跳转到目标路由地址了。</p><h4 id="10-登出"><a href="#10-登出" class="headerlink" title="10.登出"></a>10.登出</h4><p>当用户要退出时，也就是登出，我们只需要调用登出接口，并在接口成功返回后，重置vuex中的用户信息（token,角色roles,权限permission），同时清空本地缓存的数据就行了。附上代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @description 退出登录</span></span><br><span class="line"><span class="comment">  * @param &#123;*&#125; &#123; dispatch &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> Logout(&#123; commit, dispatch, state &#125;) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">     logout()</span><br><span class="line">       .then(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">         <span class="keyword">await</span> dispatch(<span class="string">'resetAll'</span>)</span><br><span class="line">         <span class="comment">//清空导航tab页签</span></span><br><span class="line">         <span class="keyword">this</span>.dispatch(<span class="string">'tagsBar/delAllVisitedRoutes'</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">         resolve()</span><br><span class="line">       &#125;)</span><br><span class="line">       .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">         reject(error)</span><br><span class="line">       &#125;)</span><br><span class="line">       .finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  * @description 重置accessToken、roles、permission等</span></span><br><span class="line"><span class="comment">  * @param &#123;*&#125; &#123; commit, dispatch &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">async</span> resetAll(&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">   <span class="keyword">await</span> dispatch(<span class="string">'setAccessToken'</span>, <span class="string">''</span>)</span><br><span class="line">   commit(<span class="string">'SET_ROLES'</span>, [])</span><br><span class="line">   commit(<span class="string">'SET_PERMISSION'</span>, [])</span><br><span class="line">   sessionStorage.clear()</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>到这一步，整个前端权限的流程就算是走完了。</p><h2 id="4-按钮级权限"><a href="#4-按钮级权限" class="headerlink" title="4.按钮级权限"></a>4.按钮级权限</h2><p>前端按钮级权限，是指在前端界面中，根据用户的权限不同，对不同的按钮进行权限控制。这样做的目的是为了确保系统的安全性和数据的保密性，使得不同用户只能执行其有权执行的操作，从而避免潜在的安全风险。<br> 上面这段定义是我copy过来的，其中这句<code>对不同的按钮进行权限控制</code>并不完全对，<strong>除了按钮，比如页面中的某个字段，某个div，某个组件要求根据当前用户的权限进行控制时，都可以称为按钮级权限</strong>。<br> 像这种按钮级权限的设计方案很多，在vue中，本人目前知道的主流方式有两种：</p><ul><li><strong>条件渲染（Conditional Rendering）：</strong> 这是一种简单有效的方法，通过在前端代码中根据用户的权限信息来决定是否渲染特定的按钮或组件。比如，你可以使用条件语句（如<code>v-if</code>、<code>ngIf</code>等）来判断用户是否有权限，从而决定是否渲染按钮。</li><li><strong>指令/组件封装：</strong> 使用一些前端框架（如Vue、React、Angular）提供的自定义指令或组件，可以封装权限控制逻辑。你可以创建一个自定义指令或组件，接受用户权限作为输入，然后根据权限来决定是否显示按钮。<br> 一开始我用的是指令封装的方式，但是随着业务需要，条件渲染这种方式我也用了。<br> 在开始看具体的实现方法之前，不知道你有没有留意到上文的路由守卫中，只是根据用户的角色字段<code>role</code>来校验当前用户的权限，还有一个字段<code>permssions(权限)</code>其实一直没有派上用场，但是无论是在权限的配置项中，还是在后端的返回字段里，都有它的存在：</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3469e61523a341db973276507547d7e6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png" title>                </div>                <div class="image-caption">image.png</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cde76813f6a1434785cae6417d5ea83a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png" title>                </div>                <div class="image-caption">image.png</div>            </figure><h4 id="1-指令-组件封装形式的按钮级权限"><a href="#1-指令-组件封装形式的按钮级权限" class="headerlink" title="1.指令/组件封装形式的按钮级权限"></a>1.指令/组件封装形式的按钮级权限</h4><p>现在它的作用来了，先看指令的具体实现方式，我们在src/directive目录下新建一个<code>hasPermi.js</code>文件，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * v-hasPermi 操作权限处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'@/store'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;   </span><br><span class="line"><span class="comment">//`el`（element）：这是指令所绑定的元素，是一个普通的DOM元素。在自定义指令的钩子函数中,</span></span><br><span class="line"><span class="comment">//你可以通过操作`el`来实现对元素的各种修改，比如添加、删除、修改样式等。</span></span><br><span class="line"><span class="comment">/** `binding`：这是一个包含指令信息的对象。它包括了以下属性：</span></span><br><span class="line"><span class="comment">   `name`：指令的名称，不包括`v-`前缀。</span></span><br><span class="line"><span class="comment">   `value`：指令的绑定值，即传递给指令的参数。在你的示例中，`value`存储了操作权限的标识符数组。</span></span><br><span class="line"><span class="comment">   `oldValue`：先前的绑定值，仅在组件更新时可用。</span></span><br><span class="line"><span class="comment">   `expression`：指令的表达式，如`v-my-directive="someValue"`中的`someValue`。</span></span><br><span class="line"><span class="comment">   `arg`：指令的参数，如`v-my-directive:arg="value"`中的`arg`。</span></span><br><span class="line"><span class="comment">   `modifiers`：一个包含修饰符的对象，如`v-my-directive.modifier`。</span></span><br><span class="line"><span class="comment">   `vnode`：渲染该组件的虚拟节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  mounted(el, binding, vnode) &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">const</span> &#123; value &#125; = binding</span><br><span class="line">    <span class="comment">//all_permission代表所有权限，一般超级管理员需要用这个</span></span><br><span class="line">    <span class="keyword">const</span> all_permission = <span class="string">'*:*:*'</span></span><br><span class="line">    <span class="comment">//获取后端返回的权限字段列表</span></span><br><span class="line">    <span class="keyword">const</span> permissions = store.getters &amp;&amp; store.getters[<span class="string">'user/permissions'</span>]</span><br><span class="line">    <span class="comment">//校验当前用户的权限列表是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; value <span class="keyword">instanceof</span> <span class="built_in">Array</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">//传入的参数，需要校验的权限字段值</span></span><br><span class="line">      <span class="keyword">const</span> permissionFlag = value</span><br><span class="line">      <span class="comment">//判断当前权限列表中，有无该传入的权限字段值</span></span><br><span class="line">      <span class="keyword">const</span> hasPermissions = permissions.some(<span class="function">(<span class="params">permission</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">          all_permission === permission || permissionFlag.includes(permission)</span><br><span class="line">        )</span><br><span class="line">      &#125;)</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (!hasPermissions) &#123;</span><br><span class="line">      <span class="comment">// 如果用户没有权限，移除当前元素的父节点（即移除当前元素）</span></span><br><span class="line">        el.parentNode &amp;&amp; el.parentNode.removeChild(el)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`请设置操作权限标签值`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码主要是在页面元素的挂载阶段（<code>mounted</code>钩子）检查用户权限，如果用户没有操作权限，那么就移除对应的页面元素。具体的代码说明我都放在里注释里。 写好了这个方法后，需要将该指令挂载到全局当中，这个时候需要进入<code>main.js</code>文件，在vue3中，给vue对象挂载自定义指令的方式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">import</span> directive <span class="keyword">from</span> <span class="string">'@/directive'</span> <span class="comment">// directive</span></span><br><span class="line"><span class="keyword">const</span> app = createApp(App)</span><br><span class="line">app.mount(<span class="string">'#app'</span>)</span><br><span class="line"><span class="comment">// 添加到全局</span></span><br><span class="line">directive(app)</span><br></pre></td></tr></table></figure><p>然后，在你需要进行按钮级权限校验的地方添加上这段指令，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;a-button</span><br><span class="line">   type=<span class="string">"primary"</span></span><br><span class="line">   @click=<span class="string">"openModal('add')"</span></span><br><span class="line">   v-hasPermi=<span class="string">"['system:user:add']"</span></span><br><span class="line">  &gt;</span><br><span class="line">  新增</span><br><span class="line">  &lt;<span class="regexp">/a-button&gt;</span></span><br></pre></td></tr></table></figure><p>上面这段代码里的<code>system:user:add</code>意思是<strong>系统目录下用户管理模块的新增按钮权限</strong>（如果看不懂就翻到文章最开始介绍RBAC的权限字段设计那里），当后端返回的当前用户数据中的permissions字段里，没有<code>system:user:add</code>这个权限字段时，这个按钮就不会显示出来。</p><h4 id="2-条件渲染形式的按钮级权限"><a href="#2-条件渲染形式的按钮级权限" class="headerlink" title="2.条件渲染形式的按钮级权限"></a>2.条件渲染形式的按钮级权限</h4><p>自定义指令实现的按钮级权限并不能满足我的业务需要，由于vue的限制，我们的自定义指令只能用在组件的<code>template</code>模块内，也就是只能放在dom标签上。但是有的时候，我可能需要对某个字段的逻辑，或者根据角色的不同，显示不同的表格列，这是数据上的处理，这个时候自定义指令就毫无用武之地。所以就需要用到条件渲染的形式。 条件渲染的形式，说白了，就是封装一个<code>全局方法</code>，方法返回值是<code>true</code>或者是<code>false</code>，然后再加一个<code>v-if</code>，但是我其实用不到这个<code>v-if</code>,我只需要这个判断权限的返回结果就足够了，核心逻辑跟自定义指令如出一辙。就不再过多赘述，直接上代码你就懂了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * checkPermi 操作权限处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'@/store'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">checkPermi</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> all_permission = <span class="string">'*:*:*'</span></span><br><span class="line">  <span class="keyword">const</span> permissions = store.getters &amp;&amp; store.getters[<span class="string">'user/permissions'</span>]</span><br><span class="line">  <span class="keyword">const</span> permissionFlag = value</span><br><span class="line">  <span class="keyword">const</span> hasPermissions = permissions.some(<span class="function">(<span class="params">permission</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> all_permission === permission || permissionFlag.includes(permission)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> hasPermissions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟上面的自定义指令不能说完全一样，只能说是一模一样。然后，我们就需要把这个方法挂载到全局，这里的挂载方式是<code>vue3</code>的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">const</span> app = createApp(App)</span><br><span class="line">app.config.globalProperties.$checkPermi = checkPermi</span><br><span class="line">app.mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure><p>然后在你需要用的地方引入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  <span class="keyword">import</span> &#123;</span><br><span class="line">    ref,</span><br><span class="line">    reactive,</span><br><span class="line">    onMounted,</span><br><span class="line">    watch,</span><br><span class="line">    toRefs,</span><br><span class="line">    nextTick,</span><br><span class="line">    getCurrentInstance,</span><br><span class="line">  &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line">    <span class="keyword">const</span> &#123; $checkPermi &#125; =</span><br><span class="line">    getCurrentInstance().appContext.config.globalProperties</span><br><span class="line">    <span class="keyword">if</span> ($checkPermi([<span class="string">'ProductionManagement:CustomOrderManagement:pro'</span>])) &#123;</span><br><span class="line">     <span class="comment">//有这个按钮级权限时的处理</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="comment">//没有这个按钮级权限时的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>怎么样，是不是很简单？</p><h4 id="后台系统按钮级别权限控制两种方案，自定义指令和条件控制的优缺点"><a href="#后台系统按钮级别权限控制两种方案，自定义指令和条件控制的优缺点" class="headerlink" title="后台系统按钮级别权限控制两种方案，自定义指令和条件控制的优缺点"></a>后台系统按钮级别权限控制两种方案，自定义指令和条件控制的优缺点</h4><p>在后台系统中，对于按钮级别权限控制，自定义指令和条件控制是两种常用的方法。以下是它们各自的优缺点：</p><h5 id="自定义指令方案"><a href="#自定义指令方案" class="headerlink" title="自定义指令方案"></a>自定义指令方案</h5><p><strong>优点</strong>：</p><ol><li><strong>高度封装</strong>：自定义指令可以将权限控制的逻辑封装起来，使得在多个地方使用相同的权限控制变得简单。</li><li><strong>易于扩展</strong>：如果需要添加新的权限控制逻辑，只需修改或扩展自定义指令即可，无需修改大量已有代码。</li><li><strong>提高可读性</strong>：在模板中使用自定义指令可以使得代码更加简洁，提高可读性。</li></ol><p><strong>缺点</strong>：</p><ol><li><strong>依赖后端</strong>：通常，自定义指令需要依赖于后端提供的用户权限数据来进行权限判断。</li><li><strong>学习成本</strong>：对于不熟悉Vue等前端框架的开发者来说，学习自定义指令的编写和使用需要一定的时间。</li><li><strong>性能考虑</strong>：如果自定义指令的实现不够高效，可能会对页面性能产生一定的影响。</li></ol><h5 id="条件控制方案"><a href="#条件控制方案" class="headerlink" title="条件控制方案"></a>条件控制方案</h5><p><strong>优点</strong>：</p><ol><li><strong>简单直接</strong>：条件控制直接基于前端逻辑进行判断，代码简单直接，易于理解。</li><li><strong>减少依赖</strong>：与自定义指令相比，条件控制通常不需要依赖于后端提供的权限数据，只需根据前端状态进行判断。</li><li><strong>无需额外学习</strong>：对于大多数开发者来说，条件控制是基本的前端技能，无需额外学习。</li></ol><p><strong>缺点</strong>：</p><ol><li><strong>代码冗余</strong>：如果在多个地方使用相同的权限控制逻辑，可能会导致代码冗余。</li><li><strong>维护困难</strong>：当需要修改权限控制逻辑时，可能需要修改多个地方的代码，维护起来较为困难。</li><li><strong>安全性</strong>：如果条件控制的逻辑过于简单，可能会存在安全风险，比如被绕过或猜测出正确的逻辑。</li></ol><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>在实际应用中，可以根据项目的具体需求和团队的实际情况来选择使用哪种方案。如果项目对权限控制的要求比较高，且团队对Vue等前端框架比较熟悉，可以考虑使用自定义指令方案；如果项目对权限控制的要求相对简单，或者团队对前端框架的熟悉程度不够，可以考虑使用条件控制方案。同时，也可以考虑将两种方案结合起来使用，以达到更好的效果。</p><h4 id="如何结合使用自定义指令和条件控制"><a href="#如何结合使用自定义指令和条件控制" class="headerlink" title="如何结合使用自定义指令和条件控制"></a>如何结合使用自定义指令和条件控制</h4><p>结合使用自定义指令和条件控制可以为后台系统的按钮级别权限控制提供更灵活和可维护的解决方案。以下是如何结合使用这两种方法的建议：</p><h5 id="1-定义自定义指令"><a href="#1-定义自定义指令" class="headerlink" title="1. 定义自定义指令"></a>1. 定义自定义指令</h5><p>首先，你可以定义一个或多个自定义指令来处理权限控制的逻辑。这些指令可以检查用户是否具有某个特定的权限，并根据权限决定是否显示或禁用某个按钮。</p><p>例如，在Vue中，你可以定义一个名为<code>v-permission</code>的自定义指令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">'permission'</span>, &#123;  </span><br><span class="line">  <span class="comment">// 当被绑定的元素挂载到 DOM 中时……  </span></span><br><span class="line">  inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el, binding, vnode</span>) </span>&#123;  </span><br><span class="line">    <span class="comment">// 假设 binding.value 是一个权限字符串，如 'admin'  </span></span><br><span class="line">    <span class="keyword">const</span> hasPermission = checkPermission(binding.value); <span class="comment">// 这是一个假设的函数，需要根据你的后端API实现  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (!hasPermission) &#123;  </span><br><span class="line">      <span class="comment">// 如果没有权限，隐藏或禁用元素  </span></span><br><span class="line">      el.style.display = <span class="string">'none'</span>; <span class="comment">// 或者你可以添加 disabled 属性到按钮上  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;,  </span><br><span class="line">  <span class="comment">// ...（其他钩子函数，如 update，componentUpdated）  </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="2-使用条件渲染"><a href="#2-使用条件渲染" class="headerlink" title="2. 使用条件渲染"></a>2. 使用条件渲染</h5><p>除了自定义指令，你还可以使用Vue的条件渲染指令（如<code>v-if</code>和<code>v-show</code>）来根据条件显示或隐藏按钮。这种方法特别适用于基于更复杂逻辑（不仅仅是权限）的渲染。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-if</span>=<span class="string">"isAdmin &amp;&amp; showButton"</span> @<span class="attr">click</span>=<span class="string">"handleClick"</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>isAdmin</code>可能是一个计算属性或方法来检查用户是否具有管理员权限，而<code>showButton</code>可能是一个简单的布尔值，用于根据其他条件（如页面状态）控制按钮的显示。</p><h5 id="3-结合使用"><a href="#3-结合使用" class="headerlink" title="3. 结合使用"></a>3. 结合使用</h5><p>你可以将自定义指令和条件渲染结合使用，以便在更复杂的场景中实现权限控制。例如，你可以使用<code>v-permission</code>指令来检查用户是否具有某个权限，并使用<code>v-if</code>来根据其他条件（如页面状态或数据可用性）进一步控制按钮的显示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-permission</span>=<span class="string">"'admin'"</span> <span class="attr">v-if</span>=<span class="string">"dataLoaded"</span> @<span class="attr">click</span>=<span class="string">"handleClick"</span>&gt;</span>管理操作<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，只有当用户具有管理员权限（由<code>v-permission</code>指令检查）且数据已加载（由<code>v-if</code>指令检查）时，按钮才会显示。</p><h5 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h5><ul><li><strong>性能</strong>：虽然自定义指令和条件渲染都是Vue的性能优化点，但在大规模应用中，过多的条件渲染可能会导致性能问题。确保在适当的时候使用<code>v-show</code>代替<code>v-if</code>，以避免不必要的重新渲染。</li><li><strong>代码组织</strong>：为了保持代码的清晰和可维护性，将权限控制逻辑与业务逻辑分开。你可以将权限检查逻辑封装在可复用的函数或组件中。</li><li><strong>测试</strong>：确保对自定义指令和条件渲染进行充分的测试，以确保它们在各种条件下都能正常工作。</li></ul><h2 id="5-遇到的坑"><a href="#5-遇到的坑" class="headerlink" title="5.遇到的坑"></a>5.遇到的坑</h2><p>这里面有几个坑需要注意下：</p><ol><li>第一个坑就是在<code>vue3</code>支持的vue-router4.0版本之前，也就是<code>vue2</code>中，动态添加路由的方式支持的是<code>addRoutes</code>，它的参数是格式是一个<code>数组</code>。而到了4.0后，<code>addRoutes</code>这个方法被废弃，取而代之的是<code>addRoute</code>，它的参数则是一个路由对象。这两个方法无论是在<code>传参类型</code>还是添加相同path时的覆盖逻辑都不相同。</li><li>第二个坑就是无论是用控制台还是打断点的方式，或者是用Vue.js devtools的谷歌插件，都无法在路由守卫中获取到添加完成后的最新router对象，<strong>也就是说你会在调试addRoute加载后的动态路由表时，发现与之前为添加路由时的路由表是一样的，从而无法判断是否动态路由添加成功</strong>（就很蛋疼）</li><li>第三个坑是 next({ …to, replace: true })这个方法，当添加好动态路由后，如果不这么写next，会白屏。<strong>在<code>addRoute()</code>之后第一次访问被添加的路由会白屏，这是因为刚刚<code>addRoute()</code>就立刻访问被添加的路由，然而此时<code>addRoute()</code>没有执行结束，因而找不到刚刚被添加的路由导致白屏。因此需要从新访问一次路由才行。</strong><br> 具体原因见文章链接：<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fqq_41912398%2Farticle%2Fdetails%2F109231418" target="_blank" rel="noopener">blog.csdn.net/qq_41912398…</a></li><li>退出后，新的用户会访问到原本不属于该用户的路由，必须刷新页面才会正常。后来通过排查，导致这个问题的原因是因为当用户登出时，当前路由router对象还保留着上一个用户的动态路由，因次，还需要在登出的时候，对路由router对象进行初始化。我们在src/router目录下的<code>index.js</code>文件里写一个初始化方法：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化路由</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resetRouter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//获取当前路有对象</span></span><br><span class="line">  <span class="keyword">let</span> routers = router.getRoutes()</span><br><span class="line"><span class="comment">//剔除动态路由</span></span><br><span class="line">  routers.map(<span class="function">(<span class="params">it</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (![<span class="string">'login'</span>, <span class="string">'403'</span>, <span class="string">':pathMatch(.*)*'</span>].includes(it.name)) &#123;</span><br><span class="line">      router.removeRoute(it.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在登出的地方引用这个方法并执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; resetRouter &#125; <span class="keyword">from</span> <span class="string">'@/router/index.js'</span></span><br><span class="line"> <span class="keyword">async</span> logout() &#123;</span><br><span class="line">        resetRouter()</span><br><span class="line">        <span class="keyword">await</span> store.dispatch(<span class="string">'user/Logout'</span>)</span><br><span class="line">        <span class="keyword">this</span>.$router.push(<span class="string">'/login'</span>)</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure><ol><li>还有一个关于vuex的问题，从之前的代码里不难看出，我们将用户信息，角色、权限、动态路由等都存在了vuex中。<strong>由于vuex的特性，用户会在刷新页面后，vuex里的数据会被清空，这个时候就会导致页面直接跳转到登录页</strong>。这肯定是不能接受的，因此，我们需要对vuex里的数据在刷新的时候做持久化处理。逻辑也很简单，监听页面刷新事件，<code>beforeunload</code>这个方法恰好就能做到，在页面刷新的时候，将vuex中的数据缓存到浏览器本地临时缓存中，然后再在页面初始化的时候，从本地临时缓存中取出存入vuex对象中。 附上代码：（项目根目录下的的App.vue文件中,这里是vue2的写法)</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">      <span class="comment">//在页面加载时读取sessionStorage里的状态信息</span></span><br><span class="line">      sessionStorage.getItem(<span class="string">'userMsg'</span>) &amp;&amp;</span><br><span class="line">        <span class="keyword">this</span>.$store.replaceState(</span><br><span class="line">          <span class="built_in">Object</span>.assign(</span><br><span class="line">            <span class="keyword">this</span>.$store.state,</span><br><span class="line">            <span class="built_in">JSON</span>.parse(sessionStorage.getItem(<span class="string">'userMsg'</span>))</span><br><span class="line">          )</span><br><span class="line">        )</span><br><span class="line">      <span class="comment">//在页面刷新时将vuex里的信息保存到sessionStorage里</span></span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">'beforeunload'</span>, () =&gt; &#123;</span><br><span class="line">        sessionStorage.setItem(<span class="string">'userMsg'</span>, <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.$store.state))</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>这里再附上src/router目录下的<code>index.js</code>代码，方便大家理解路由这块：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createWebHistory, createRouter, useRouter &#125; <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> &#123; constantRouterMap &#125; <span class="keyword">from</span> <span class="string">'@/config/router.config.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123; generator &#125; <span class="keyword">from</span> <span class="string">'@/router/generatorRouters'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">  history: createWebHistory(),</span><br><span class="line">  routes: constantRouterMap,</span><br><span class="line">  scrollBehavior(to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">    <span class="keyword">if</span> (savedPosition) &#123;</span><br><span class="line">      <span class="keyword">return</span> savedPosition</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">top</span>: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//这里是我为了刷新的时候不调取获取路由信息的接口，做的本地缓存，因为刷新一次就要获取一遍用户信息和</span></span><br><span class="line"><span class="comment">//动态路由表信息太影响用户体验了，尤其是在网速差的情况下。没这方面需求的可以不用管</span></span><br><span class="line"><span class="keyword">let</span> asyncRouterMap = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleLocalRouter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (sessionStorage.getItem(<span class="string">'generateRoutes'</span>)) &#123;</span><br><span class="line">    asyncRouterMap = asyncRouterMap.concat(</span><br><span class="line">      <span class="built_in">JSON</span>.parse(sessionStorage.getItem(<span class="string">'generateRoutes'</span>))</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">const</span> generatedRoutes = generator(asyncRouterMap)</span><br><span class="line">    generatedRoutes.push(&#123;</span><br><span class="line">      path: <span class="string">'/:pathMatch(.*)*'</span>,</span><br><span class="line">      redirect: <span class="string">'/404'</span>,</span><br><span class="line">      hidden: <span class="literal">true</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    generatedRoutes.forEach(<span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">      router.addRoute(route)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化路由</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resetRouter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> routers = router.getRoutes()</span><br><span class="line">  routers.map(<span class="function">(<span class="params">it</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (![<span class="string">'login'</span>, <span class="string">'403'</span>, <span class="string">':pathMatch(.*)*'</span>].includes(it.name)) &#123;</span><br><span class="line">      router.removeRoute(it.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">handleLocalRouter()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><h2 id="6-结束与优化"><a href="#6-结束与优化" class="headerlink" title="6.结束与优化"></a>6.结束与优化</h2><p>好，至此，整个RBAC的前端权限方案设计到实现就已经宣告完成，其实还有很多需要优化的地方，比如把用户路由表信息缓存到本地临时缓存中，这样用户每次刷新页面的时候就不会因为vuex的特性需要再去请求一边接口。（但是老实说，我觉得这个优化方案还是不够好，因为将路由表存在本地缓存中就已经背离了安全性这一块，但是在网络较差的情况下，刷新就要调取角色信息接口，调取获取私有路由的接口，再到构建新的完整路由这个过程期间，页面会处于白屏状态，非常影响用户体验。因此，只能取此下策。到底要不要缓存，看个人的想法吧。） 还比如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> store.dispatch(<span class="string">'user/GetInfo'</span>)</span><br><span class="line">   <span class="keyword">await</span> store.dispatch(<span class="string">'async-router/GenerateRoutes'</span>)</span><br><span class="line">   <span class="keyword">let</span> accessRoutes = store.getters[<span class="string">'async-router/addRouters'</span>]</span><br><span class="line">   accessRoutes.forEach(<span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//用来判断是否是外链</span></span><br><span class="line">    <span class="keyword">if</span> (!isHttp(route.path)) &#123;</span><br><span class="line">      router.addRoute(route) <span class="comment">// 动态添加可访问路由表</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>这段获取用户信息-&gt;构建路由-&gt;添加动态路由的代码可以抽离出来，单独封装。<br> 还可以根据当前环境是否是<code>development</code>来判断是否是开发环境，从而准备另外一套前端开发场景下使用的完整路由表，这样，就可以在不依赖后端的情况下，进行前端开发。<br> 另外还有侧边导航栏的处理，这个我没讲，一方面是相对简单，<strong>我们获取到格式化之后的动态路由数据的同时，其实也就是获取到了导航栏的菜单信息。</strong> 另一方面，每个人的项目页面布局方式不一样，导航栏的设计也会不一样。在此基础上，针对性的对数据进行修饰和改造即可。<br> 不啰嗦了，今天周五下班时间了，我写的比较匆忙，也有些地方我可能没有考虑到，看到这里的小伙伴，或者对着文章实践的小伙伴们，欢迎你们提出自己的意见和看法，我会加以订正，不足之处，还请海涵~~ <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49305cf84d7d48e5928f3116a925b981~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="5223e1f26a8ae0f57e4ff89518d9c82f.jpg" title>                </div>                <div class="image-caption">5223e1f26a8ae0f57e4ff89518d9c82f.jpg</div>            </figure></p><p>原文链接：<a href="https://juejin.cn/post/7259210874446692411" target="_blank" rel="noopener">https://juejin.cn/post/7259210874446692411</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前端权限开发——设计到实践（保姆级）&quot;&gt;&lt;a href=&quot;#前端权限开发——设计到实践（保姆级）&quot; class=&quot;headerlink&quot; title=&quot;前端权限开发——设计到实践（保姆级）&quot;&gt;&lt;/a&gt;前端权限开发——设计到实践（保姆级）&lt;/h1&gt;&lt;h2 id=&quot;1
      
    
    </summary>
    
      <category term="前端文章" scheme="https://qw66.gitee.io/categories/%E5%89%8D%E7%AB%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="权限" scheme="https://qw66.gitee.io/tags/%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>后台管理系统</title>
    <link href="https://qw66.gitee.io//articles/hou-tai-guan-li-xi-tong.html"/>
    <id>https://qw66.gitee.io//articles/hou-tai-guan-li-xi-tong.html</id>
    <published>2023-12-14T16:00:00.000Z</published>
    <updated>2024-05-08T06:50:25.053Z</updated>
    
    <content type="html"><![CDATA[<h3 id="总是做后台管理系统，到底要怎么提升自己呢？"><a href="#总是做后台管理系统，到底要怎么提升自己呢？" class="headerlink" title="总是做后台管理系统，到底要怎么提升自己呢？"></a>总是做后台管理系统，到底要怎么提升自己呢？</h3><p>很多人都来问我：<strong>我平时写的东西都是后台管理系统，根本就没啥亮点的东西，我也没啥进步，我该咋办呢？</strong></p><h3 id="后台管理不丢人"><a href="#后台管理不丢人" class="headerlink" title="后台管理不丢人"></a>后台管理不丢人</h3><p>其实据我了解，大部分前端在公司其实就是做后台管理系统，偶尔做做移动端，那么大家都是做后台管理，你要怎么比别人强呢？其实就是一个点：<strong>你如何把后台管理系统做得更好</strong></p><p>其实我也做过一段时间的后台管理系统，我总结了几点我的心得，分享给大家~</p><h3 id="多封装组件"><a href="#多封装组件" class="headerlink" title="多封装组件"></a>多封装组件</h3><p>封装是一个很普遍的操作，但是却很少人去做好这件事，我现在做后台管理系统的话我会做到<strong>极致的封装</strong>，只要是一个东西有两处地方复用到了，我肯定会抽取封装起来，在这个过程中，我也学到了很多 Vue3 的 API，也发现很多封装组件的技巧，比如</p><ul><li><strong>shallowRef 节省性能</strong></li><li><strong>computed 的 getter 和 setter</strong></li><li><strong>组件 props 类型的拓展</strong></li><li><strong>组件封装的更加方便使用</strong></li><li><strong>模板的极致复用</strong></li><li><strong>命令式使用弹窗</strong></li></ul><h3 id="多封装-Hooks"><a href="#多封装-Hooks" class="headerlink" title="多封装 Hooks"></a>多封装 Hooks</h3><p>对于一些业务性的逻辑代码，或者共用的逻辑代码，都要有抽取成 Hooks 的意识，这有利于于后续代码的可维护性，并且抽取共用的 Hooks，有利于代码可复用性，提高代码开发效率，锻炼你的逻辑封装能力，我最近封装了很多 Hooks，比如</p><ul><li><strong>useClickoutside：点击目标区域以外触发事件</strong></li><li><strong>useCommandComponent：命令式使用组件</strong></li><li><strong>createModal：命令式使用弹窗</strong></li><li><strong>useTemplate：本组件复用弹窗</strong></li><li><strong>useGlobalState：局部状态管理</strong></li><li><strong>useVirtualList：虚拟滚动</strong></li><li>等等。。。</li></ul><h3 id="多考虑边界条件"><a href="#多考虑边界条件" class="headerlink" title="多考虑边界条件"></a>多考虑边界条件</h3><p>我发现很多人在做后台管理也好，做其他的东西也好，其实总是会考虑得没那么周全，其中一点就是，总是不考虑边界条件，不去考虑兜底，比如：</p><ul><li><strong>组件的参数兜底检验补全</strong></li><li><strong>hooks的参数兜底补全</strong></li><li><strong>接口请求数据出错、接口报错的兜底</strong></li><li><strong>某些代码记得加 try catch 进行兜底</strong></li><li><strong>代码执行先后顺序问题，怎么去控制按照顺序去执行</strong></li></ul><h3 id="多想想产品优化"><a href="#多想想产品优化" class="headerlink" title="多想想产品优化"></a>多想想产品优化</h3><p>其实优化不止是代码优化，也有产品优化，有时候其实产品经理想出来的点子，也是不合理的，这个时候你可以去提出自己的见解，让整个产品更好，当然代码的优化也是必须做的，比如：</p><ul><li><strong>防抖节流</strong></li><li><strong>长列表的虚拟滚动</strong></li><li><strong>大文件的分片上传</strong></li><li><strong>多请求时的控制并发</strong></li><li><strong>使用合适的 API ，节省性能</strong></li><li><strong>多使用设计模式，提高代码健壮性</strong></li></ul><h3 id="多想想怎么提高效率"><a href="#多想想怎么提高效率" class="headerlink" title="多想想怎么提高效率"></a>多想想怎么提高效率</h3><p>你要知道，后台管理系统其实业务难度是有限的，但是其实你可以不要局限于项目，而是要经常去想想：</p><ul><li><strong>你能怎么在项目中去让自己进步</strong></li><li><strong>你要怎么样去提升自己的开发效率</strong></li><li><strong>你要怎么样去提升整个团队的开发效率</strong></li></ul><p>就比如我，我在开发后台管理系统的时候，我会做这些事：</p><ul><li><strong>发现某些别人不合理的开发习惯，可以记下来，反馈给团队</strong></li><li><strong>为了团队开发规范，开发一些小工具，来助力团队的规范</strong></li><li><strong>为了团队成员开发的效率，开发一些小工具，帮他们提升开发效率</strong></li><li><strong>多为团队的组件库工具库贡献，这样也能提升整个团队的开发效率</strong></li><li><strong>主动去封装一些比较难的组件，提升团队开发效率，使自己进步</strong></li></ul><h3 id="多搞配置化"><a href="#多搞配置化" class="headerlink" title="多搞配置化"></a>多搞配置化</h3><p>我记得我一年前去面试一个高级前端工程师的岗位时，面试官就问我一个问题：<strong>假如你开发一个后台管理系统，你怎么让你的团队成员更轻松去开发呢？</strong> 我当时回答说：<strong>制定规范！</strong> 然后面试官我没体会到他真正的意思</p><p>现在我算是领会到了，面试官的意思是：<strong>你要怎么开发一个后台管理系统，让你的组员无脑地开发</strong></p><p>那其实我觉得，把一些事情做成<strong>配置化</strong>，这样才能让别人开发的时候，更加方便、更加无脑~</p><p>其实后台管理无非就几个东西：</p><ul><li><strong>表单</strong></li><li><strong>表格</strong></li><li><strong>图表</strong></li></ul><p>那么可以做相对应的配置器，让其他人只需要传入配置，就可以生成想要的页面效果，比如：</p><ul><li><strong>表单配置器</strong></li><li><strong>表格配置器</strong></li><li><strong>图表配置器</strong></li></ul><h3 id="多看看别人怎么做的"><a href="#多看看别人怎么做的" class="headerlink" title="多看看别人怎么做的"></a>多看看别人怎么做的</h3><p>github 上有很多很出名的后台管理系统，大家可以去看看人家是怎么写的，为啥你写的像入门级，人家写的像大佬级别，可以多看看多学学，我推荐给你们<strong>vben-admin</strong>，我从这个后台管理项目中真的学到好多东西！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;总是做后台管理系统，到底要怎么提升自己呢？&quot;&gt;&lt;a href=&quot;#总是做后台管理系统，到底要怎么提升自己呢？&quot; class=&quot;headerlink&quot; title=&quot;总是做后台管理系统，到底要怎么提升自己呢？&quot;&gt;&lt;/a&gt;总是做后台管理系统，到底要怎么提升自己呢？&lt;/
      
    
    </summary>
    
      <category term="前端文章" scheme="https://qw66.gitee.io/categories/%E5%89%8D%E7%AB%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="管理系统" scheme="https://qw66.gitee.io/tags/%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Webpack优化实践</title>
    <link href="https://qw66.gitee.io//articles/webpack-you-hua-shi-jian.html"/>
    <id>https://qw66.gitee.io//articles/webpack-you-hua-shi-jian.html</id>
    <published>2023-11-20T16:00:00.000Z</published>
    <updated>2024-02-18T02:48:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue项目Webpack优化实践，构建效率提高50"><a href="#Vue项目Webpack优化实践，构建效率提高50" class="headerlink" title="Vue项目Webpack优化实践，构建效率提高50%"></a>Vue项目Webpack优化实践，构建效率提高50%</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 公司的前端项目使用<code>Vue</code>框架，<code>Vue</code>框架使用<code>Webpack</code>进行构建，随着项目不断迭代，项目逐渐变得庞大，然而项目的构建速度随之变得缓慢，于是对<code>Webpack</code>构建进行优化变得刻不容缓。经过不断的摸索和实践，通过以下方法优化后，项目的构建速度提高了50%。现将相关优化方法进行总结分享。</p><h2 id="1、缩小文件的搜索范围"><a href="#1、缩小文件的搜索范围" class="headerlink" title="1、缩小文件的搜索范围"></a>1、缩小文件的搜索范围</h2><h3 id="1-1、优化Loader配置"><a href="#1-1、优化Loader配置" class="headerlink" title="1.1、优化Loader配置"></a>1.1、优化<code>Loader</code>配置</h3><p>​       由于<code>Loader</code>对文件的转换操作很耗时，所以需要让尽可能少的文件被<code>Loader</code>处理。我们可以通过以下3方面优化<code>Loader</code>配置：（1）优化正则匹配（2）通过<code>cacheDirectory</code>选项开启缓存（3）通过<code>include</code>、<code>exclude</code>来减少被处理的文件。实践如下：</p><p><strong>项目原配置：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /\.js$/,</span><br><span class="line">  loader: &apos;babel-loader&apos;,</span><br><span class="line">  include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化后配置：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // 1、如果项目源码中只有js文件，就不要写成/\.jsx?$/，以提升正则表达式的性能</span><br><span class="line">  test: /\.js$/,</span><br><span class="line">  // 2、babel-loader支持缓存转换出的结果，通过cacheDirectory选项开启</span><br><span class="line">  loader: &apos;babel-loader?cacheDirectory&apos;,</span><br><span class="line">  // 3、只对项目根目录下的src 目录中的文件采用 babel-loader</span><br><span class="line">  include: [resolve(&apos;src&apos;)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2、优化resolve-modules配置"><a href="#1-2、优化resolve-modules配置" class="headerlink" title="1.2、优化resolve.modules配置"></a>1.2、优化<code>resolve.modules</code>配置</h3><p>​       <code>resolve.modules</code> 用于配置<code>Webpack</code>去哪些目录下寻找第三方模块。<code>resolve.modules</code>的默认值是［<code>node modules</code>］，含义是先去当前目录的<code>/node modules</code>目录下去找我们想找的模块，如果没找到，就去上一级目录<code>../node modules</code>中找，再没有就去<code>../ .. /node modules</code>中找，以此类推，这和<code>Node.js</code>的模块寻找机制很相似。当安装的第三方模块都放在项目根目录的<code>./node modules</code>目录下时，就没有必要按照默认的方式去一层层地寻找，可以指明存放第三方模块的绝对路径，以减少寻找。</p><p><strong>优化后配置：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">// 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤</span><br><span class="line">modules: [path.resolve(__dirname,&apos;node_modules&apos;)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3、优化resolve-alias配置"><a href="#1-3、优化resolve-alias配置" class="headerlink" title="1.3、优化resolve.alias配置"></a>1.3、优化<code>resolve.alias</code>配置</h3><p>​       <code>resolve.alias</code>配置项通过别名来将原导入路径映射成一个新的导入路径。</p><p><strong>如项目中的配置使用：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alias: &#123;</span><br><span class="line">  &apos;@&apos;: resolve(&apos;src&apos;),</span><br><span class="line">&#125;,</span><br><span class="line">// 通过以上的配置，引用src底下的common.js文件，就可以直接这么写</span><br><span class="line">import common from &apos;@/common.js&apos;;</span><br></pre></td></tr></table></figure><h3 id="1-4、优化resolve-extensions配置"><a href="#1-4、优化resolve-extensions配置" class="headerlink" title="1.4、优化resolve.extensions配置"></a>1.4、优化<code>resolve.extensions</code>配置</h3><p>​       在导入语句没带文件后缀时，<code>Webpack</code> 会在自动带上后缀后去尝试询问文件是否存在。默认是：<code>extensions :[‘. js ‘,’. json ’]</code> 。也就是说，当遇到<code>require ( &#39;. /data ’）</code>这样的导入语句时，<code>Webpack</code>会先去寻找<code>./data .js</code> 文件，如果该文件不存在，就去寻找<code>./data.json</code> 文件，如果还是找不到就报错。如果这个列表越长，或者正确的后缀越往后，就会造成尝试的次数越多，所以 <code>resolve .extensions</code> 的配置也会影响到构建的性能。 </p><h3 id="优化措施："><a href="#优化措施：" class="headerlink" title="优化措施："></a>优化措施：</h3><p> • 后缀尝试列表要尽可能小，不要将项目中不可能存在的情况写到后缀尝试列表中。</p><p> • 频率出现最高的文件后缀要优先放在最前面，以做到尽快退出寻找过程。</p><p> • 在源码中写导入语句时，要尽可能带上后缀，从而可以避免寻找过程。例如在确定的情况下将 <code>require(’. /data ’)</code>写成<code>require(’. /data.json ’)</code>，可以结合<code>enforceExtension</code> 和 <code>enforceModuleExtension</code>开启使用来强制开发者遵守这条优化</p><h3 id="1-5、优化resolve-noParse配置"><a href="#1-5、优化resolve-noParse配置" class="headerlink" title="1.5、优化resolve.noParse配置"></a>1.5、优化<code>resolve.noParse</code>配置</h3><p>​       <code>noParse</code>配置项可以让<code>Webpack</code>忽略对部分没采用模块化的文件的递归解析和处理，这 样做的好处是能提高构建性能。原因是一些库如<code>jQuery</code>、<code>ChartJS</code> 庞大又没有采用模块化标准，让<code>Webpack</code>去解析这些文件既耗时又没有意义。 <code>noParse</code>是可选的配置项，类型需要是<code>RegExp</code> 、<code>[RegExp]</code>、<code>function</code>中的一种。例如，若想要忽略<code>jQuery</code> 、<code>ChartJS</code> ，<strong>则优化配置如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 使用正则表达式 </span><br><span class="line">noParse: /jquerylchartjs/ </span><br><span class="line">// 使用函数，从 Webpack3.0.0开始支持 </span><br><span class="line">noParse: (content)=&gt; &#123; </span><br><span class="line">// 返回true或false </span><br><span class="line">return /jquery|chartjs/.test(content); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、减少冗余代码"><a href="#2、减少冗余代码" class="headerlink" title="2、减少冗余代码"></a>2、减少冗余代码</h2><p>​        <code>babel-plugin-transform-runtime</code> 是<code>Babel</code>官方提供的一个插件，作用是减少冗余的代码 。 <code>Babel</code>在将<code>ES6</code>代码转换成<code>ES5</code>代码时，通常需要一些由<code>ES5</code>编写的辅助函数来完成新语法的实现，例如在转换 <code>class</code> <code>extent</code> 语法时会在转换后的 <code>ES5</code> 代码里注入 <code>extent</code> 辅助函数用于实现继承。<code>babel-plugin-transform-runtime</code>会将相关辅助函数进行替换成导入语句，从而减小<code>babel</code>编译出来的代码的文件大小。</p><h2 id="3、使用HappyPack多进程解析和处理文件"><a href="#3、使用HappyPack多进程解析和处理文件" class="headerlink" title="3、使用HappyPack多进程解析和处理文件"></a>3、使用<code>HappyPack</code>多进程解析和处理文件</h2><p>​       由于有大量文件需要解析和处理，所以构建是文件读写和计算密集型的操作，特别是当文件数量变多后，<code>Webpack</code>构建慢的问题会显得更为严重。运行在 <code>Node</code>之上的<code>Webpack</code>是单线程模型的，也就是说<code>Webpack</code>需要一个一个地处理任务，不能同时处理多个任务。<code>Happy Pack</code> ( <a href="https://github.com/amireh/happypack" target="_blank" rel="noopener">https://github.com/amireh/happypack</a> ）就能让<code>Webpack</code>做到这一点，它将任务分解给多个子进程去并发执行，子进程处理完后再将结果发送给主进程。</p><p><strong>项目中<code>HappyPack</code>使用配置：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">（1）HappyPack插件安装：</span><br><span class="line">    $ npm i -D happypack</span><br><span class="line">（2）webpack.base.conf.js 文件对module.rules进行配置</span><br><span class="line">    module: &#123;</span><br><span class="line">     rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        // 将对.js 文件的处理转交给 id 为 babel 的HappyPack实例</span><br><span class="line">          use:[&apos;happypack/loader?id=babel&apos;],</span><br><span class="line">          include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;),   </span><br><span class="line">            resolve(&apos;node_modules/webpack-dev-server/client&apos;)],</span><br><span class="line">        // 排除第三方插件</span><br><span class="line">          exclude:path.resolve(__dirname,&apos;node_modules&apos;),</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test: /\.vue$/,</span><br><span class="line">          use: [&apos;happypack/loader?id=vue&apos;],</span><br><span class="line">        &#125;,</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">（3）webpack.prod.conf.js 文件进行配置    const HappyPack = require(&apos;happypack&apos;);</span><br><span class="line">    // 构造出共享进程池，在进程池中包含5个子进程</span><br><span class="line">    const HappyPackThreadPool = HappyPack.ThreadPool(&#123;size:5&#125;);</span><br><span class="line">    plugins: [</span><br><span class="line">       new HappyPack(&#123;</span><br><span class="line">         // 用唯一的标识符id，来代表当前的HappyPack是用来处理一类特定的文件</span><br><span class="line">         id:&apos;vue&apos;,</span><br><span class="line">         loaders:[</span><br><span class="line">           &#123;</span><br><span class="line">             loader:&apos;vue-loader&apos;,</span><br><span class="line">             options: vueLoaderConfig</span><br><span class="line">           &#125;</span><br><span class="line">         ],</span><br><span class="line">         threadPool: HappyPackThreadPool,</span><br><span class="line">       &#125;),</span><br><span class="line"></span><br><span class="line">       new HappyPack(&#123;</span><br><span class="line">         // 用唯一的标识符id，来代表当前的HappyPack是用来处理一类特定的文件</span><br><span class="line">         id:&apos;babel&apos;,</span><br><span class="line">         // 如何处理.js文件，用法和Loader配置中一样</span><br><span class="line">         loaders:[&apos;babel-loader?cacheDirectory&apos;],</span><br><span class="line">         threadPool: HappyPackThreadPool,</span><br><span class="line">       &#125;),</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><h2 id="4、使用ParallelUglifyPlugin多进程压缩代码文件"><a href="#4、使用ParallelUglifyPlugin多进程压缩代码文件" class="headerlink" title="4、使用ParallelUglifyPlugin多进程压缩代码文件"></a>4、使用ParallelUglifyPlugin多进程压缩代码文件</h2><p>​       由于压缩<code>JavaScript</code> 代码时，需要先将代码解析成用 <code>Object</code> 抽象表示的 <code>AST</code> 语法树，再去应用各种规则分析和处理<code>AST</code> ，所以导致这个过程的计算量巨大，耗时非常多。当<code>Webpack</code>有多个<code>JavaScript</code> 文件需要输出和压缩时，原本会使用<code>UglifyJS</code>去一个一个压缩再输出，但是<code>ParallelUglifyPlugin</code>会开启多个子进程，将对多个文件的压缩工作分配给多个子进程去完成，每个子进程其实还是通过<code>UglifyJS</code>去压缩代码，但是变成了并行执行。所以 <code>ParallelUglify Plugin</code>能更快地完成对多个文件的压缩工作。</p><p> <strong>项目中<code>ParallelUglifyPlugin</code>使用配置：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">（1）ParallelUglifyPlugin插件安装：</span><br><span class="line">     $ npm i -D webpack-parallel-uglify-plugin</span><br><span class="line">（2）webpack.prod.conf.js 文件进行配置</span><br><span class="line">    const ParallelUglifyPlugin =require(&apos;webpack-parallel-uglify-plugin&apos;);</span><br><span class="line">    plugins: [</span><br><span class="line">    new ParallelUglifyPlugin(&#123;</span><br><span class="line">      cacheDir: &apos;.cache/&apos;,</span><br><span class="line">      uglifyJs:&#123;</span><br><span class="line">        compress: &#123;</span><br><span class="line">          warnings: false</span><br><span class="line">        &#125;,</span><br><span class="line">        sourceMap: true</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;),</span><br><span class="line">    ]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="5、使用自动刷新"><a href="#5、使用自动刷新" class="headerlink" title="5、使用自动刷新"></a>5、使用自动刷新</h2><p>​       借助自动化的手段，在监听到本地源码文件发生变化时，自动重新构建出可运行的代码后再控制浏览器刷新。<code>Webpack</code>将这些功能都内置了，并且提供了多种方案供我们选择。</p><p> <strong>项目中自动刷新的配置：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  watchOptions: &#123;</span><br><span class="line">    // 不监听的文件或文件夹，支持正则匹配</span><br><span class="line">    ignored: /node_modules/,</span><br><span class="line">    // 监听到变化后等300ms再去执行动作</span><br><span class="line">    aggregateTimeout: 300,</span><br><span class="line">    // 默认每秒询问1000次</span><br><span class="line">    poll: 1000</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>相关优化措施：</strong> </p><p>（1）配置忽略一些不监听的一些文件，如：<code>node_modules</code>。 </p><p>（2）<code>watchOptions.aggregateTirneout</code> 的值越大性能越好，因为这能降低重新构建的频率。</p><p>（3） <code>watchOptions.poll</code> 的值越小越好，因为这能降低检查的频率。</p><h2 id="6、开启模块热替换"><a href="#6、开启模块热替换" class="headerlink" title="6、开启模块热替换"></a>6、开启模块热替换</h2><p>​       <code>DevServer</code> 还支持一种叫做模块热替换（ <code>Hot Module Replacement</code> ）的技术可在不刷新整个网页的情况下做到超灵敏实时预览。原理是在一个源码发生变化时，只需重新编译发生变化的模块，再用新输出的模块替换掉浏览器中对应的老模块 。模块热替换技术在很大程度上提升了开发效率和体验 。 </p><p><strong>项目中模块热替换的配置：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  hot: true,</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  new webpack.HotModuleReplacementPlugin(),</span><br><span class="line">// 显示被替换模块的名称</span><br><span class="line">  new webpack.NamedModulesPlugin(), // HMR shows correct file names</span><br><span class="line">]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="7、提取公共代码"><a href="#7、提取公共代码" class="headerlink" title="7、提取公共代码"></a>7、提取公共代码</h2><p>​        如果每个页面的代码都将这些公共的部分包含进去，则会造成以下问题 ： </p><p> • 相同的资源被重复加载，浪费用户的流量和服务器的成本。</p><p> • 每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。 </p><p>​       如果将多个页面的公共代码抽离成单独的文件，就能优化以上问题 。<code>Webpack</code>内置了专门用于提取多个<code>Chunk</code>中的公共部分的插件<code>CommonsChunkPlugin</code>。 </p><p><strong>项目中<code>CommonsChunkPlugin</code>的配置：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 所有在 package.json 里面依赖的包，都会被打包进 vendor.js 这个文件中。</span><br><span class="line">new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: &apos;vendor&apos;,</span><br><span class="line">  minChunks: function(module, count) &#123;</span><br><span class="line">    return (</span><br><span class="line">      module.resource &amp;&amp;</span><br><span class="line">      /\.js$/.test(module.resource) &amp;&amp;</span><br><span class="line">      module.resource.indexOf(</span><br><span class="line">        path.join(__dirname, &apos;../node_modules&apos;)</span><br><span class="line">      ) === 0</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;),</span><br><span class="line">// 抽取出代码模块的映射关系</span><br><span class="line">new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: &apos;manifest&apos;,</span><br><span class="line">  chunks: [&apos;vendor&apos;]</span><br><span class="line">&#125;),</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="8、按需加载代码"><a href="#8、按需加载代码" class="headerlink" title="8、按需加载代码"></a>8、按需加载代码</h2><p>​       通过<code>vue</code>写的单页应用时，可能会有很多的路由引入。当打包构建的时候，<code>javascript</code>包会变得非常大，影响加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来。 </p><p><strong>项目中路由按需加载（懒加载）的配置：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const Foo = () =&gt; import(&apos;./Foo.vue&apos;)</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &apos;/foo&apos;, component: Foo &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="9、优化SourceMap"><a href="#9、优化SourceMap" class="headerlink" title="9、优化SourceMap"></a>9、优化SourceMap</h2><p>​       我们在项目进行打包后，会将开发中的多个文件代码打包到一个文件中，并且经过压缩，去掉多余的空格，且<code>babel</code>编译化后，最终会用于线上环境，那么这样处理后的代码和源代码会有很大的差别，当有<code>bug</code>的时候，我们只能定位到压缩处理后的代码位置，无法定位到开发环境中的代码，对于开发不好调式，因此<code>sourceMap</code>出现了，它就是为了解决不好调式代码问题的。</p><p> <strong><code>SourceMap</code>的可选值如下：</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="https://user-gold-cdn.xitu.io/2018/12/23/167dba50e9d02b22?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p><strong>开发环境推荐： <code>cheap-module-eval-source-map</code></strong> </p><p><strong>生产环境推荐： `cheap-module-source-map</strong>`</p><p><strong>原因如下：</strong> </p><ol><li>源代码中的列信息是没有任何作用，因此我们打包后的文件不希望包含列相关信息，只有行信息能建立打包前后的依赖关系。因此不管是开发环境或生产环境，我们都希望添加<code>cheap</code>的基本类型来忽略打包前后的列信息。 </li><li>不管是开发环境还是正式环境，我们都希望能定位到<code>bug</code>的源代码具体的位置，比如说某个<code>vue</code>文件报错了，我们希望能定位到具体的<code>vue</code>文件，因此我们也需要<code>module</code>配置。 </li><li>我们需要生成<code>map</code>文件的形式，因此我们需要增加<code>source-map</code>属性。 </li><li>我们介绍了<code>eval</code>打包代码的时候，知道<code>eval</code>打包后的速度非常快，因为它不生成<code>map</code>文件，但是可以对<code>eval</code>组合使用 <code>eval-source-map</code>使用会将<code>map</code>文件以<code>DataURL</code>的形式存在打包后的<code>js</code>文件中。在正式环境中不要使用 <code>eval-source-map</code>, 因为它会增加文件的大小，但是在开发环境中，可以试用下，因为他们打包的速度很快。</li></ol><h2 id="10、构建结果输出分析"><a href="#10、构建结果输出分析" class="headerlink" title="10、构建结果输出分析"></a>10、构建结果输出分析</h2><p>​       <code>Webpack</code>输出的代码可读性非常差而且文件非常大，让我们非常头疼。为了更简单、直观地分析输出结果，社区中出现了许多可视化分析工具。这些工具以图形的方式将结果更直观地展示出来，让我们快速了解问题所在。接下来讲解vue项目中用到的分析工具：<code>webpack-bundle-analyzer</code> 。</p><p><strong>项目中在<code>webpack.prod.conf.js</code>进行配置：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (config.build.bundleAnalyzerReport) &#123;</span><br><span class="line">  var BundleAnalyzerPlugin =   require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin;</span><br><span class="line">  webpackConfig.plugins.push(new BundleAnalyzerPlugin());</span><br><span class="line">&#125;</span><br><span class="line">执行 $ npm run build --report 后生成分析报告如下：</span><br></pre></td></tr></table></figure><p> <img src="/img/loading.gif" data-original="https://user-gold-cdn.xitu.io/2018/12/23/167dba6f9640342d?imageslim" alt="img"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Vue项目Webpack优化实践，构建效率提高50&quot;&gt;&lt;a href=&quot;#Vue项目Webpack优化实践，构建效率提高50&quot; class=&quot;headerlink&quot; title=&quot;Vue项目Webpack优化实践，构建效率提高50%&quot;&gt;&lt;/a&gt;Vue项目Webpa
      
    
    </summary>
    
      <category term="前端文章" scheme="https://qw66.gitee.io/categories/%E5%89%8D%E7%AB%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Webpack" scheme="https://qw66.gitee.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Vue核心之虚拟DOM</title>
    <link href="https://qw66.gitee.io//articles/vue-he-xin-zhi-xu-ni-dom.html"/>
    <id>https://qw66.gitee.io//articles/vue-he-xin-zhi-xu-ni-dom.html</id>
    <published>2023-11-19T16:00:00.000Z</published>
    <updated>2024-02-18T02:52:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入剖析：Vue核心之虚拟DOM"><a href="#深入剖析：Vue核心之虚拟DOM" class="headerlink" title="深入剖析：Vue核心之虚拟DOM"></a>深入剖析：Vue核心之虚拟DOM</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用 <code>Vue</code> 做项目也有两年时间了，对 <code>Vue</code> 的 <code>api</code>也用的比较得心应手了，虽然对 <code>Vue</code> 的一些实现原理也耳有所闻，例如 虚拟<code>DOM</code>、<code>flow</code>、数据驱动、路由原理等等，但是自己并没有特意去探究这些原理的基础以及 <code>Vue</code> 源码是如何利用这些原理进行框架实现的，所以利用空闲时间，进行 <code>Vue</code> 框架相关技术原理和 <code>Vue</code> 框架的具体实现的整理。如果你对 <code>Vue</code> 的实现原理很感兴趣，那么就可以开始这系列文章的阅读，将会为你打开 <code>Vue</code> 的底层世界大门，对它的实现细节一探究竟。 本文为 <code>Virtual DOM</code>的技术原理和 <code>Vue</code> 框架的具体实现。</p><p><strong>辛苦编写良久，还望手动点赞鼓励~</strong></p><p><strong>github地址为：<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Ffengshi123%2Fblog" target="_blank" rel="noopener">github.com/fengshi123/…</a>，上面汇总了作者所有的博客文章，如果喜欢或者有所启发，请帮忙给个 star ~，对作者也是一种鼓励。</strong></p><h2 id="一、真实DOM和其解析流程"><a href="#一、真实DOM和其解析流程" class="headerlink" title="一、真实DOM和其解析流程"></a>一、真实<code>DOM</code>和其解析流程</h2><p>本节我们主要介绍真实   <code>DOM</code> 的解析过程，通过介绍其解析过程以及存在的问题，从而引出为什么需要虚拟<code>DOM</code>。一图胜千言，如下图为 <code>webkit</code> 渲染引擎工作流程图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="../../images/virtual_dom1.png?raw=true" alt="1.png" title>                </div>                <div class="image-caption">1.png</div>            </figure><p>所有的浏览器渲染引擎工作流程大致分为5步：创建        <code>DOM</code> 树 —&gt; 创建 <code>Style Rules</code> -&gt; 构建 <code>Render</code> 树 —&gt; 布局 <code>Layout</code> -—&gt; 绘制 <code>Painting</code>。</p><ul><li><p>第一步，构建 <code>DOM</code> 树：用 <code>HTML</code> 分析器，分析 <code>HTML</code> 元素，构建一棵 <code>DOM</code> 树；</p></li><li><p>第二步，生成样式表：用 <code>CSS</code> 分析器，分析 <code>CSS</code> 文件和元素上的 <code>inline</code> 样式，生成页面的样式表；</p></li><li><p>第三步，构建 <code>Render</code> 树：将 <code>DOM</code> 树和样式表关联起来，构建一棵 <code>Render</code> 树（<code>Attachment</code>）。每个 <code>DOM</code> 节点都有 <code>attach</code> 方法，接受样式信息，返回一个 <code>render</code> 对象（又名 <code>renderer</code>），这些 <code>render</code> 对象最终会被构建成一棵 <code>Render</code> 树；</p></li><li><p>第四步，确定节点坐标：根据 <code>Render</code> 树结构，为每个 <code>Render</code> 树上的节点确定一个在显示屏上出现的精确坐标；</p></li><li><p>第五步，绘制页面：根据 <code>Render</code> 树和节点显示坐标，然后调用每个节点的 <code>paint</code> 方法，将它们绘制出来。</p></li></ul><p><strong>注意点：</strong></p><p>*<em>1、<code>DOM</code> 树的构建是文档加载完成开始的？ *</em>构建 <code>DOM</code> 树是一个渐进过程，为达到更好的用户体验，渲染引擎会尽快将内容显示在屏幕上，它不必等到整个 <code>HTML</code> 文档解析完成之后才开始构建 <code>render</code> 树和布局。</p><p>*<em>2、<code>Render</code> 树是 <code>DOM</code> 树和 <code>CSS</code> 样式表构建完毕后才开始构建的？ *</em>这三个过程在实际进行的时候并不是完全独立的，而是会有交叉，会一边加载，一边解析，以及一边渲染。</p><p><strong>3、<code>CSS</code> 的解析注意点？</strong> <code>CSS</code> 的解析是从右往左逆向解析的，嵌套标签越多，解析越慢。</p><p><strong>4、<code>JS</code> 操作真实 <code>DOM</code> 的代价？</strong> 用我们传统的开发模式，原生 <code>JS</code> 或 <code>JQ</code> 操作 <code>DOM</code> 时，浏览器会从构建 DOM 树开始从头到尾执行一遍流程。在一次操作中，我需要更新 10 个 <code>DOM</code> 节点，浏览器收到第一个 <code>DOM</code> 请求后并不知道还有 9 次更新操作，因此会马上执行流程，最终执行10 次。例如，第一次计算完，紧接着下一个 <code>DOM</code> 更新请求，这个节点的坐标值就变了，前一次计算为无用功。计算 <code>DOM</code> 节点坐标值等都是白白浪费的性能。即使计算机硬件一直在迭代更新，操作 <code>DOM</code> 的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户体验</p><h2 id="二、Virtual-DOM-基础"><a href="#二、Virtual-DOM-基础" class="headerlink" title="二、Virtual-DOM 基础"></a>二、<code>Virtual-DOM</code> 基础</h2><h3 id="2-1、虚拟-DOM-的好处"><a href="#2-1、虚拟-DOM-的好处" class="headerlink" title="2.1、虚拟 DOM 的好处"></a>2.1、虚拟 <code>DOM</code> 的好处</h3><p>​    虚拟 <code>DOM</code> 就是为了解决浏览器性能问题而被设计出来的。如前，若一次操作中有 10 次更新 <code>DOM</code> 的动作，虚拟 <code>DOM</code> 不会立即操作 <code>DOM</code>，而是将这 10 次更新的 <code>diff</code> 内容保存到本地一个 <code>JS</code> 对象中，最终将这个 <code>JS</code> 对象一次性 <code>attch</code> 到 <code>DOM</code> 树上，再进行后续操作，避免大量无谓的计算量。所以，用 <code>JS</code> 对象模拟 <code>DOM</code> 节点的好处是，页面的更新可以先全部反映在 <code>JS</code> 对象(虚拟 <code>DOM</code> )上，操作内存中的 <code>JS</code> 对象的速度显然要更快，等更新完成后，再将最终的 <code>JS</code> 对象映射成真实的 <code>DOM</code>，交由浏览器去绘制。</p><h3 id="2-2、算法实现"><a href="#2-2、算法实现" class="headerlink" title="2.2、算法实现"></a>2.2、算法实现</h3><h4 id="2-2-1、用-JS-对象模拟-DOM-树"><a href="#2-2-1、用-JS-对象模拟-DOM-树" class="headerlink" title="2.2.1、用 JS 对象模拟 DOM 树"></a>2.2.1、用 <code>JS</code> 对象模拟 <code>DOM</code> 树</h4><p><strong>（1）如何用 <code>JS</code> 对象模拟 <code>DOM</code> 树</strong></p><p>例如一个真实的 <code>DOM</code> 节点如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"virtual-dom"</span>&gt;</span><br><span class="line">&lt;p&gt;Virtual DOM&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;ul id="list"&gt;</span></span><br><span class="line"><span class="regexp">  &lt;li class="item"&gt;Item 1&lt;/</span>li&gt;</span><br><span class="line">  &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">"item"</span>&gt;Item <span class="number">2</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  &lt;li class="item"&gt;Item 3&lt;/</span>li&gt;</span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">&lt;div&gt;Hello World&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p>我们用 <code>JavaScript</code> 对象来表示 <code>DOM</code> 节点，使用对象的属性记录节点的类型、属性、子节点等。</p><p><code>element.js</code> 中表示节点对象代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Element virdual-dom 对象定义</span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; tagName - dom 元素名称</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; props - dom 属性</span></span><br><span class="line"><span class="comment"> * @param &#123;Array&lt;Element|String&gt;&#125; - 子节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Element</span>(<span class="params">tagName, props, children</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.tagName = tagName</span><br><span class="line">    <span class="keyword">this</span>.props = props</span><br><span class="line">    <span class="keyword">this</span>.children = children</span><br><span class="line">    <span class="comment">// dom 元素的 key 值，用作唯一标识符</span></span><br><span class="line">    <span class="keyword">if</span>(props.key)&#123;</span><br><span class="line">       <span class="keyword">this</span>.key = props.key</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    children.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">child, i</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (child <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">            count += child.count</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            children[i] = <span class="string">''</span> + child</span><br><span class="line">        &#125;</span><br><span class="line">        count++</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 子元素个数</span></span><br><span class="line">    <span class="keyword">this</span>.count = count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">tagName, props, children</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> Element(tagName, props, children);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = createElement;</span><br></pre></td></tr></table></figure><p>根据 <code>element</code> 对象的设定，则上面的 <code>DOM</code> 结构就可以简单表示为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">require</span>(<span class="string">"./element.js"</span>);</span><br><span class="line"><span class="keyword">var</span> ul = el(<span class="string">'div'</span>,&#123;<span class="attr">id</span>:<span class="string">'virtual-dom'</span>&#125;,[</span><br><span class="line">  el(<span class="string">'p'</span>,&#123;&#125;,[<span class="string">'Virtual DOM'</span>]),</span><br><span class="line">  el(<span class="string">'ul'</span>, &#123; <span class="attr">id</span>: <span class="string">'list'</span> &#125;, [</span><br><span class="line">el(<span class="string">'li'</span>, &#123; <span class="attr">class</span>: <span class="string">'item'</span> &#125;, [<span class="string">'Item 1'</span>]),</span><br><span class="line">el(<span class="string">'li'</span>, &#123; <span class="attr">class</span>: <span class="string">'item'</span> &#125;, [<span class="string">'Item 2'</span>]),</span><br><span class="line">el(<span class="string">'li'</span>, &#123; <span class="attr">class</span>: <span class="string">'item'</span> &#125;, [<span class="string">'Item 3'</span>])</span><br><span class="line">  ]),</span><br><span class="line">  el(<span class="string">'div'</span>,&#123;&#125;,[<span class="string">'Hello World'</span>])</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>现在 <code>ul</code> 就是我们用  <code>JavaScript</code> 对象表示的 <code>DOM</code> 结构，我们输出查看 <code>ul</code> 对应的数据结构如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="../../images/virtual_dom1_2.png?raw=true" alt="12.png" title>                </div>                <div class="image-caption">12.png</div>            </figure> <p><strong>（2）渲染用 <code>JS</code> 表示的 <code>DOM</code> 对象</strong></p><p>但是页面上并没有这个结构，下一步我们介绍如何将 <code>ul</code> 渲染成页面上真实的 <code>DOM</code> 结构，相关渲染函数如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * render 将virdual-dom 对象渲染为实际 DOM 元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Element.prototype.render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> el = <span class="built_in">document</span>.createElement(<span class="keyword">this</span>.tagName)</span><br><span class="line">    <span class="keyword">var</span> props = <span class="keyword">this</span>.props</span><br><span class="line">    <span class="comment">// 设置节点的DOM属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> propName <span class="keyword">in</span> props) &#123;</span><br><span class="line">        <span class="keyword">var</span> propValue = props[propName]</span><br><span class="line">        el.setAttribute(propName, propValue)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> children = <span class="keyword">this</span>.children || []</span><br><span class="line">    children.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">child</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> childEl = (child <span class="keyword">instanceof</span> Element)</span><br><span class="line">            ? child.render() <span class="comment">// 如果子节点也是虚拟DOM，递归构建DOM节点</span></span><br><span class="line">            : <span class="built_in">document</span>.createTextNode(child) <span class="comment">// 如果字符串，只构建文本节点</span></span><br><span class="line">        el.appendChild(childEl)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> el</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过查看以上 <code>render</code> 方法，会根据  <code>tagName</code> 构建一个真正的 <code>DOM</code> 节点，然后设置这个节点的属性，最后递归地把自己的子节点也构建起来。</p><p>我们将构建好的 <code>DOM</code> 结构添加到页面 <code>body</code> 上面，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ulRoot = ul.render();</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(ulRoot);</span><br></pre></td></tr></table></figure><p>这样，页面 <code>body</code> 里面就有真正的 <code>DOM</code> 结构，效果如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="../../images/virtual_dom2.png?raw=true" alt="2.png" title>                </div>                <div class="image-caption">2.png</div>            </figure> <h4 id="2-2-2、比较两棵虚拟-DOM-树的差异-—-diff-算法"><a href="#2-2-2、比较两棵虚拟-DOM-树的差异-—-diff-算法" class="headerlink" title="2.2.2、比较两棵虚拟 DOM 树的差异 — diff 算法"></a>2.2.2、比较两棵虚拟 <code>DOM</code> 树的差异 — <code>diff</code> 算法</h4><p><code>diff</code> 算法用来比较两棵 <code>Virtual DOM</code> 树的差异，如果需要两棵树的完全比较，那么 <code>diff</code> 算法的时间复杂度为<code>O(n^3)</code>。但是在前端当中，你很少会跨越层级地移动 <code>DOM</code> 元素，所以 <code>Virtual DOM</code> 只会对同一个层级的元素进行对比，如下图所示， <code>div</code> 只会和同一层级的 <code>div</code> 对比，第二层级的只会跟第二层级对比，这样算法复杂度就可以达到 <code>O(n)</code>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="../../images/virtual_dom3.png?raw=true" alt="3.png" title>                </div>                <div class="image-caption">3.png</div>            </figure>  <p><strong>（1）深度优先遍历，记录差异</strong></p><p>在实际的代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记： </p><p><img src="/img/loading.gif" data-original="../../images/virtual_dom4.png?raw=true" alt="4.png">   </p><p>在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// diff 函数，对比两棵树</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params">oldTree, newTree</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span> <span class="comment">// 当前节点的标志</span></span><br><span class="line">  <span class="keyword">var</span> patches = &#123;&#125; <span class="comment">// 用来记录每个节点差异的对象</span></span><br><span class="line">  dfsWalk(oldTree, newTree, index, patches)</span><br><span class="line">  <span class="keyword">return</span> patches</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对两棵树进行深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfsWalk</span>(<span class="params">oldNode, newNode, index, patches</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> currentPatch = []</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> (oldNode) === <span class="string">"string"</span> &amp;&amp; <span class="keyword">typeof</span> (newNode) === <span class="string">"string"</span>) &#123;</span><br><span class="line">    <span class="comment">// 文本内容改变</span></span><br><span class="line">    <span class="keyword">if</span> (newNode !== oldNode) &#123;</span><br><span class="line">      currentPatch.push(&#123; <span class="attr">type</span>: patch.TEXT, <span class="attr">content</span>: newNode &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newNode!=<span class="literal">null</span> &amp;&amp; oldNode.tagName === newNode.tagName &amp;&amp; oldNode.key === newNode.key) &#123;</span><br><span class="line">    <span class="comment">// 节点相同，比较属性</span></span><br><span class="line">    <span class="keyword">var</span> propsPatches = diffProps(oldNode, newNode)</span><br><span class="line">    <span class="keyword">if</span> (propsPatches) &#123;</span><br><span class="line">      currentPatch.push(&#123; <span class="attr">type</span>: patch.PROPS, <span class="attr">props</span>: propsPatches &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较子节点，如果子节点有'ignore'属性，则不需要比较</span></span><br><span class="line">    <span class="keyword">if</span> (!isIgnoreChildren(newNode)) &#123;</span><br><span class="line">      diffChildren(</span><br><span class="line">        oldNode.children,</span><br><span class="line">        newNode.children,</span><br><span class="line">        index,</span><br><span class="line">        patches,</span><br><span class="line">        currentPatch</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(newNode !== <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="comment">// 新节点和旧节点不同，用 replace 替换</span></span><br><span class="line">    currentPatch.push(&#123; <span class="attr">type</span>: patch.REPLACE, <span class="attr">node</span>: newNode &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (currentPatch.length) &#123;</span><br><span class="line">    patches[index] = currentPatch</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上可以得出，<code>patches[1]</code> 表示 <code>p</code> ，<code>patches[3]</code> 表示 <code>ul</code> ，以此类推。</p><p><strong>（2）差异类型</strong></p><p><code>DOM</code> 操作导致的差异类型包括以下几种：</p><ul><li>节点替换：节点改变了，例如将上面的 <code>div</code> 换成 <code>h1</code>;</li><li>顺序互换：移动、删除、新增子节点，例如上面 <code>div</code> 的子节点，把 <code>p</code> 和 <code>ul</code> 顺序互换；</li><li>属性更改：修改了节点的属性，例如把上面 <code>li</code> 的 <code>class</code> 样式类删除；</li><li>文本改变：改变文本节点的文本内容，例如将上面 <code>p</code> 节点的文本内容更改为 “<code>Real Dom</code>”；</li></ul><p>以上描述的几种差异类型在代码中定义如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> REPLACE = <span class="number">0</span> <span class="comment">// 替换原先的节点</span></span><br><span class="line"><span class="keyword">var</span> REORDER = <span class="number">1</span> <span class="comment">// 重新排序</span></span><br><span class="line"><span class="keyword">var</span> PROPS = <span class="number">2</span> <span class="comment">// 修改了节点的属性</span></span><br><span class="line"><span class="keyword">var</span> TEXT = <span class="number">3</span> <span class="comment">// 文本内容改变</span></span><br></pre></td></tr></table></figure><p><strong>（3）列表对比算法</strong></p><p>​    子节点的对比算法，例如      <code>p, ul, div</code> 的顺序换成了 <code>div, p, ul</code>。这个该怎么对比？如果按照同层级进行顺序对比的话，它们都会被替换掉。如 <code>p</code> 和 <code>div</code> 的 <code>tagName</code> 不同，<code>p</code> 会被 <code>div</code> 所替代。最终，三个节点都会被替换，这样 <code>DOM</code> 开销就非常大。而实际上是不需要替换节点，而只需要经过节点移动就可以达到，我们只需知道怎么进行移动。 </p><p>​    将这个问题抽象出来其实就是字符串的最小编辑距离问题（<code>Edition Distance</code>），最常见的解决方法是 <code>Levenshtein Distance</code> , <code>Levenshtein Distance</code> 是一个度量两个字符序列之间差异的字符串度量标准，两个单词之间的 <code>Levenshtein Distance</code> 是将一个单词转换为另一个单词所需的单字符编辑（插入、删除或替换）的最小数量。<code>Levenshtein Distance</code> 是1965年由苏联数学家 Vladimir Levenshtein 发明的。<code>Levenshtein Distance</code> 也被称为编辑距离（<code>Edit Distance</code>），通过<strong>动态规划</strong>求解，时间复杂度为 <code>O(M*N)</code>。</p><p>定义：对于两个字符串 <code>a、b</code>，则他们的 <code>Levenshtein Distance</code> 为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="../../images/virtual_dom5.png?raw=true" alt="5.png" title>                </div>                <div class="image-caption">5.png</div>            </figure> <p> 示例：字符串 <code>a</code> 和 <code>b</code>，<code>a=“abcde” ，b=“cabef”</code>，根据上面给出的计算公式，则他们的 <code>Levenshtein Distance</code> 的计算过程如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="../../images/virtual_dom6.png?raw=true" alt="6.png" title>                </div>                <div class="image-caption">6.png</div>            </figure> <p>本文的 <code>demo</code> 使用插件 <code>list-diff2</code> 算法进行比较，该算法的时间复杂度伟 <code>O(n*m)</code>，虽然该算法并非最优的算法，但是用于对于 <code>dom</code> 元素的常规操作是足够的。该算法具体的实现过程这里不再详细介绍，该算法的具体介绍可以参照：<a href="https://github.com/livoras/list-diff" target="_blank" rel="noopener">https://github.com/livoras/list-diff</a> </p><p><strong>（4）实例输出</strong></p><p>两个虚拟 <code>DOM</code> 对象如下图所示，其中 <code>ul1</code> 表示原有的虚拟 <code>DOM</code> 树，<code>ul2</code> 表示改变后的虚拟 <code>DOM</code> 树</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul1 = el(<span class="string">'div'</span>,&#123;<span class="attr">id</span>:<span class="string">'virtual-dom'</span>&#125;,[</span><br><span class="line">  el(<span class="string">'p'</span>,&#123;&#125;,[<span class="string">'Virtual DOM'</span>]),</span><br><span class="line">  el(<span class="string">'ul'</span>, &#123; <span class="attr">id</span>: <span class="string">'list'</span> &#125;, [</span><br><span class="line">el(<span class="string">'li'</span>, &#123; <span class="attr">class</span>: <span class="string">'item'</span> &#125;, [<span class="string">'Item 1'</span>]),</span><br><span class="line">el(<span class="string">'li'</span>, &#123; <span class="attr">class</span>: <span class="string">'item'</span> &#125;, [<span class="string">'Item 2'</span>]),</span><br><span class="line">el(<span class="string">'li'</span>, &#123; <span class="attr">class</span>: <span class="string">'item'</span> &#125;, [<span class="string">'Item 3'</span>])</span><br><span class="line">  ]),</span><br><span class="line">  el(<span class="string">'div'</span>,&#123;&#125;,[<span class="string">'Hello World'</span>])</span><br><span class="line">]) </span><br><span class="line"><span class="keyword">var</span> ul2 = el(<span class="string">'div'</span>,&#123;<span class="attr">id</span>:<span class="string">'virtual-dom'</span>&#125;,[</span><br><span class="line">  el(<span class="string">'p'</span>,&#123;&#125;,[<span class="string">'Virtual DOM'</span>]),</span><br><span class="line">  el(<span class="string">'ul'</span>, &#123; <span class="attr">id</span>: <span class="string">'list'</span> &#125;, [</span><br><span class="line">el(<span class="string">'li'</span>, &#123; <span class="attr">class</span>: <span class="string">'item'</span> &#125;, [<span class="string">'Item 21'</span>]),</span><br><span class="line">el(<span class="string">'li'</span>, &#123; <span class="attr">class</span>: <span class="string">'item'</span> &#125;, [<span class="string">'Item 23'</span>])</span><br><span class="line">  ]),</span><br><span class="line">  el(<span class="string">'p'</span>,&#123;&#125;,[<span class="string">'Hello World'</span>])</span><br><span class="line">]) </span><br><span class="line"><span class="keyword">var</span> patches = diff(ul1,ul2);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'patches:'</span>,patches);</span><br></pre></td></tr></table></figure><p>我们查看输出的两个虚拟 <code>DOM</code> 对象之间的差异对象如下图所示，我们能通过差异对象得到，两个虚拟 <code>DOM</code> 对象之间进行了哪些变化，从而根据这个差异对象（<code>patches</code>）更改原先的真实 <code>DOM</code> 结构，从而将页面的 <code>DOM</code> 结构进行更改。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="../../images/virtual_dom7.png?raw=true" alt="7" title>                </div>                <div class="image-caption">7</div>            </figure>  <h4 id="2-2-3、将两个虚拟-DOM-对象的差异应用到真正的-DOM-树"><a href="#2-2-3、将两个虚拟-DOM-对象的差异应用到真正的-DOM-树" class="headerlink" title="2.2.3、将两个虚拟 DOM 对象的差异应用到真正的 DOM 树"></a>2.2.3、将两个虚拟 <code>DOM</code> 对象的差异应用到真正的 <code>DOM</code> 树</h4><p><strong>（1）深度优先遍历 <code>DOM</code> 树</strong></p><p>​    因为步骤一所构建的         <code>JavaScript</code> 对象树和 <code>render</code> 出来真正的 <code>DOM</code> 树的信息、结构是一样的。所以我们可以对那棵 <code>DOM</code> 树也进行深度优先的遍历，遍历的时候从步骤二生成的 <code>patches</code> 对象中找出当前遍历的节点差异，如下相关代码所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">node, patches</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> walker = &#123;<span class="attr">index</span>: <span class="number">0</span>&#125;</span><br><span class="line">  dfsWalk(node, walker, patches)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfsWalk</span> (<span class="params">node, walker, patches</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 从patches拿出当前节点的差异</span></span><br><span class="line">  <span class="keyword">var</span> currentPatches = patches[walker.index]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> len = node.childNodes</span><br><span class="line">    ? node.childNodes.length</span><br><span class="line">    : <span class="number">0</span></span><br><span class="line">  <span class="comment">// 深度遍历子节点</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> child = node.childNodes[i]</span><br><span class="line">    walker.index++</span><br><span class="line">    dfsWalk(child, walker, patches)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对当前节点进行DOM操作</span></span><br><span class="line">  <span class="keyword">if</span> (currentPatches) &#123;</span><br><span class="line">    applyPatches(node, currentPatches)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（2）对原有 <code>DOM</code> 树进行 <code>DOM</code> 操作</strong></p><p>我们根据不同类型的差异对当前节点进行不同的 <code>DOM</code> 操作 ，例如如果进行了节点替换，就进行节点替换 <code>DOM</code> 操作；如果节点文本发生了改变，则进行文本替换的 <code>DOM</code> 操作；以及子节点重排、属性改变等 <code>DOM</code> 操作，相关代码如 <code>applyPatches</code> 所示 ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyPatches</span> (<span class="params">node, currentPatches</span>) </span>&#123;</span><br><span class="line">  currentPatches.forEach(<span class="function"><span class="params">currentPatch</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (currentPatch.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> REPLACE:</span><br><span class="line">        <span class="keyword">var</span> newNode = (<span class="keyword">typeof</span> currentPatch.node === <span class="string">'string'</span>)</span><br><span class="line">          ? <span class="built_in">document</span>.createTextNode(currentPatch.node)</span><br><span class="line">          : currentPatch.node.render()</span><br><span class="line">        node.parentNode.replaceChild(newNode, node)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> REORDER:</span><br><span class="line">        reorderChildren(node, currentPatch.moves)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> PROPS:</span><br><span class="line">        setProps(node, currentPatch.props)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> TEXT:</span><br><span class="line">        node.textContent = currentPatch.content</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Unknown patch type '</span> + currentPatch.type)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（3）DOM结构改变</strong></p><p>通过将第 2.2.2 得到的两个 <code>DOM</code> 对象之间的差异，应用到第一个（原先）<code>DOM</code> 结构中，我们可以看到 <code>DOM</code> 结构进行了预期的变化，如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="../../images/virtual_dom8.png?raw=true" alt="8.png" title>                </div>                <div class="image-caption">8.png</div>            </figure>     <h3 id="2-3、结语"><a href="#2-3、结语" class="headerlink" title="2.3、结语"></a>2.3、结语</h3><p><code>Virtual DOM</code> 算法主要实现上面三个步骤来实现：</p><ul><li><p>用 <code>JS</code> 对象模拟 <code>DOM</code> 树 — <code>element.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"virtual-dom"</span>&gt;</span><br><span class="line">&lt;p&gt;Virtual DOM&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;ul id="list"&gt;</span></span><br><span class="line"><span class="regexp">  &lt;li class="item"&gt;Item 1&lt;/</span>li&gt;</span><br><span class="line">  &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">"item"</span>&gt;Item <span class="number">2</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  &lt;li class="item"&gt;Item 3&lt;/</span>li&gt;</span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">&lt;div&gt;Hello World&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>比较两棵虚拟 <code>DOM</code> 树的差异 — <code>diff.js</code></p><p><img src="/img/loading.gif" data-original="../../images/virtual_dom9.png?raw=true" alt="9.png">  </p></li><li><p>将两个虚拟 <code>DOM</code> 对象的差异应用到真正的 <code>DOM</code> 树 — <code>patch.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyPatches</span> (<span class="params">node, currentPatches</span>) </span>&#123;</span><br><span class="line">  currentPatches.forEach(<span class="function"><span class="params">currentPatch</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (currentPatch.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> REPLACE:</span><br><span class="line">        <span class="keyword">var</span> newNode = (<span class="keyword">typeof</span> currentPatch.node === <span class="string">'string'</span>)</span><br><span class="line">          ? <span class="built_in">document</span>.createTextNode(currentPatch.node)</span><br><span class="line">          : currentPatch.node.render()</span><br><span class="line">        node.parentNode.replaceChild(newNode, node)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> REORDER:</span><br><span class="line">        reorderChildren(node, currentPatch.moves)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> PROPS:</span><br><span class="line">        setProps(node, currentPatch.props)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> TEXT:</span><br><span class="line">        node.textContent = currentPatch.content</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Unknown patch type '</span> + currentPatch.type)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="三、Vue-源码-Virtual-DOM-简析"><a href="#三、Vue-源码-Virtual-DOM-简析" class="headerlink" title="三、Vue 源码 Virtual-DOM 简析"></a>三、<code>Vue</code> 源码 <code>Virtual-DOM</code> 简析</h2><p>我们从第二章节（<code>Virtual-DOM</code> 基础）中已经掌握 <code>Virtual DOM</code> 渲染成真实的 <code>DOM</code> 实际上要经历 <code>VNode</code> 的定义、<code>diff</code>、<code>patch</code> 等过程，所以本章节 <code>Vue</code> 源码的解析也按这几个过程来简析。</p><h3 id="3-1、VNode-模拟-DOM-树"><a href="#3-1、VNode-模拟-DOM-树" class="headerlink" title="3.1、VNode 模拟 DOM 树"></a>3.1、<code>VNode</code> 模拟 <code>DOM</code> 树</h3><h4 id="3-1-1、VNode-类简析"><a href="#3-1-1、VNode-类简析" class="headerlink" title="3.1.1、VNode 类简析"></a><strong>3.1.1、<code>VNode</code> 类简析</strong></h4><p>在 <code>Vue.js</code> 中，<code>Virtual DOM</code> 是用 <code>VNode</code> 这个 <code>Class</code> 去描述，它定义在 <code>src/core/vdom/vnode.js</code> 中 ，从以下代码块中可以看到 <code>Vue.js</code> 中的 <code>Virtual DOM</code> 的定义较为复杂一些，因为它这里包含了很多 <code>Vue.js</code> 的特性。实际上 <code>Vue.js</code> 中 <code>Virtual DOM</code> 是借鉴了一个开源库  <a href="https://github.com/snabbdom/snabbdom" target="_blank" rel="noopener">snabbdom</a> 的实现，然后加入了一些 <code>Vue.js</code> 的一些特性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  tag: string | <span class="keyword">void</span>;</span><br><span class="line">  data: VNodeData | <span class="keyword">void</span>;</span><br><span class="line">  children: ?<span class="built_in">Array</span>&lt;VNode&gt;;</span><br><span class="line">  text: string | <span class="keyword">void</span>;</span><br><span class="line">  elm: Node | <span class="keyword">void</span>;</span><br><span class="line">  ns: string | <span class="keyword">void</span>;</span><br><span class="line">  context: Component | <span class="keyword">void</span>; <span class="comment">// rendered in this component's scope</span></span><br><span class="line">  key: string | number | <span class="keyword">void</span>;</span><br><span class="line">  componentOptions: VNodeComponentOptions | <span class="keyword">void</span>;</span><br><span class="line">  componentInstance: Component | <span class="keyword">void</span>; <span class="comment">// component instance</span></span><br><span class="line">  parent: VNode | <span class="keyword">void</span>; <span class="comment">// component placeholder node</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// strictly internal</span></span><br><span class="line">  raw: boolean; <span class="comment">// contains raw HTML? (server only)</span></span><br><span class="line">  isStatic: boolean; <span class="comment">// hoisted static node</span></span><br><span class="line">  isRootInsert: boolean; <span class="comment">// necessary for enter transition check</span></span><br><span class="line">  isComment: boolean; <span class="comment">// empty comment placeholder?</span></span><br><span class="line">  isCloned: boolean; <span class="comment">// is a cloned node?</span></span><br><span class="line">  isOnce: boolean; <span class="comment">// is a v-once node?</span></span><br><span class="line">  asyncFactory: <span class="built_in">Function</span> | <span class="keyword">void</span>; <span class="comment">// async component factory function</span></span><br><span class="line">  asyncMeta: <span class="built_in">Object</span> | <span class="keyword">void</span>;</span><br><span class="line">  isAsyncPlaceholder: boolean;</span><br><span class="line">  ssrContext: <span class="built_in">Object</span> | <span class="keyword">void</span>;</span><br><span class="line">  fnContext: Component | <span class="keyword">void</span>; <span class="comment">// real context vm for functional nodes</span></span><br><span class="line">  fnOptions: ?ComponentOptions; <span class="comment">// for SSR caching</span></span><br><span class="line">  devtoolsMeta: ?<span class="built_in">Object</span>; <span class="comment">// used to store functional render context for devtools</span></span><br><span class="line">  fnScopeId: ?string; <span class="comment">// functional scope id support</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (</span><br><span class="line">    tag?: string,</span><br><span class="line">    data?: VNodeData,</span><br><span class="line">    children?: ?Array&lt;VNode&gt;,</span><br><span class="line">    text?: string,</span><br><span class="line">    elm?: Node,</span><br><span class="line">    context?: Component,</span><br><span class="line">    componentOptions?: VNodeComponentOptions,</span><br><span class="line">    asyncFactory?: Function</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tag = tag</span><br><span class="line">    <span class="keyword">this</span>.data = data</span><br><span class="line">    <span class="keyword">this</span>.children = children</span><br><span class="line">    <span class="keyword">this</span>.text = text</span><br><span class="line">    <span class="keyword">this</span>.elm = elm</span><br><span class="line">    <span class="keyword">this</span>.ns = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.context = context</span><br><span class="line">    <span class="keyword">this</span>.fnContext = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.fnOptions = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.fnScopeId = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.key = data &amp;&amp; data.key</span><br><span class="line">    <span class="keyword">this</span>.componentOptions = componentOptions</span><br><span class="line">    <span class="keyword">this</span>.componentInstance = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.parent = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.raw = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.isStatic = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.isRootInsert = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">this</span>.isComment = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.isCloned = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.isOnce = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.asyncFactory = asyncFactory</span><br><span class="line">    <span class="keyword">this</span>.asyncMeta = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.isAsyncPlaceholder = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里千万不要因为 <code>VNode</code> 的这么属性而被吓到，或者咬紧牙去摸清楚每个属性的意义，其实，我们主要了解其几个核心的关键属性就差不多了，例如：</p><ul><li><code>tag</code> 属性即这个<code>vnode</code>的标签属性</li><li><code>data</code> 属性包含了最后渲染成真实<code>dom</code>节点后，节点上的<code>class</code>，<code>attribute</code>，<code>style</code>以及绑定的事件</li><li><code>children</code> 属性是<code>vnode</code>的子节点</li><li><code>text</code> 属性是文本属性</li><li><code>elm</code> 属性为这个<code>vnode</code>对应的真实<code>dom</code>节点</li><li><code>key</code> 属性是<code>vnode</code>的标记，在<code>diff</code>过程中可以提高<code>diff</code>的效率</li></ul><h4 id="3-1-2、源码创建-VNode-过程"><a href="#3-1-2、源码创建-VNode-过程" class="headerlink" title="3.1.2、源码创建 VNode 过程"></a><strong>3.1.2、源码创建 <code>VNode</code> 过程</strong></h4><p>*<em>（1）初始化  <code>vue</code> *</em></p><p>我们在实例化一个 <code>vue</code> 实例，也即 <code>new Vue( )</code> 时，实际上是执行 <code>src/core/instance/index.js</code>  中定义的 <code>Function</code> 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Vue)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>._init(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过查看 <code>Vue</code> 的 <code>function</code>，我们知道 <code>Vue</code> 只能通过 <code>new</code> 关键字初始化，然后调用 <code>this._init</code> 方法，该方法在 <code>src/core/instance/init.js</code> 中定义。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 省略一系列其它初始化的代码</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'vm.$options.el:'</span>,vm.$options.el);</span><br><span class="line">    vm.$mount(vm.$options.el)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（2）<code>Vue</code> 实例挂载</strong></p><p><code>Vue</code> 中是通过 <code>$mount</code> 实例方法去挂载 <code>dom</code> 的，下面我们通过分析 <code>compiler</code> 版本的 <code>mount</code> 实现，相关源码在目录 <code>src/platforms/web/entry-runtime-with-compiler.js</code> 文件中定义：。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount</span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; query(el)</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 省略一系列初始化以及逻辑判断代码  </span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> mount.call(<span class="keyword">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现最终还是调用用原先原型上的 <code>$mount</code> 方法挂载 ，原先原型上的 <code>$mount</code> 方法在 <code>src/platforms/web/runtime/index.js</code> 中定义 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">return</span> mountComponent(<span class="keyword">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现<code>$mount</code> 方法实际上会去调用 <code>mountComponent</code> 方法，这个方法定义在 <code>src/core/instance/lifecycle.js</code> 文件中 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  el: ?Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  vm.$el = el</span><br><span class="line">  <span class="comment">// 省略一系列其它代码</span></span><br><span class="line">  <span class="keyword">let</span> updateComponent</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 生成虚拟 vnode   </span></span><br><span class="line">      <span class="keyword">const</span> vnode = vm._render()</span><br><span class="line">      <span class="comment">// 更新 DOM</span></span><br><span class="line">      vm._update(vnode, hydrating)</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例化一个渲染Watcher，在它的回调函数中会调用 updateComponent 方法  </span></span><br><span class="line">  <span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</span><br><span class="line">        callHook(vm, <span class="string">'beforeUpdate'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  hydrating = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看到，<code>mountComponent</code> 核心就是先实例化一个渲染<code>Watcher</code>，在它的回调函数中会调用 <code>updateComponent</code> 方法，在此方法中调用 <code>vm._render</code> 方法先生成虚拟 Node，最终调用 <code>vm._update</code> 更新 <code>DOM</code>。 </p><p><strong>（3）创建虚拟 Node</strong></p><p><code>Vue</code> 的 <code>_render</code> 方法是实例的一个私有方法，它用来把实例渲染成一个虚拟 <code>Node</code>。它的定义在 <code>src/core/instance/render.js</code> 文件中： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">   <span class="keyword">const</span> &#123; render, _parentVnode &#125; = vm.$options</span><br><span class="line">   <span class="keyword">let</span> vnode</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// 省略一系列代码  </span></span><br><span class="line">     currentRenderingInstance = vm</span><br><span class="line">     <span class="comment">// 调用 createElement 方法来返回 vnode</span></span><br><span class="line">     vnode = render.call(vm._renderProxy, vm.$createElement)</span><br><span class="line">   &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">     handleError(e, vm, <span class="string">`render`</span>)&#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// set parent</span></span><br><span class="line">   vnode.parent = _parentVnode</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"vnode...:"</span>,vnode);</span><br><span class="line">   <span class="keyword">return</span> vnode</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><code>Vue.js</code> 利用 <code>_createElement</code> 方法创建 <code>VNode</code>，它定义在 <code>src/core/vdom/create-elemenet.js</code> 中： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">_createElement</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  context: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag?: string | Class&lt;Component&gt; | Function | Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  data?: VNodeData,</span></span></span><br><span class="line"><span class="function"><span class="params">  children?: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  normalizationType?: number</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 省略一系列非主线代码</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (normalizationType === ALWAYS_NORMALIZE) &#123;</span><br><span class="line">    <span class="comment">// 场景是 render 函数不是编译生成的</span></span><br><span class="line">    children = normalizeChildren(children)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalizationType === SIMPLE_NORMALIZE) &#123;</span><br><span class="line">    <span class="comment">// 场景是 render 函数是编译生成的</span></span><br><span class="line">    children = simpleNormalizeChildren(children)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> vnode, ns</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> Ctor</span><br><span class="line">    ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag)</span><br><span class="line">    <span class="keyword">if</span> (config.isReservedTag(tag)) &#123;</span><br><span class="line">      <span class="comment">// 创建虚拟 vnode</span></span><br><span class="line">      vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">        config.parsePlatformTagName(tag), data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, <span class="string">'components'</span>, tag))) &#123;</span><br><span class="line">      <span class="comment">// component</span></span><br><span class="line">      vnode = createComponent(Ctor, data, context, children, tag)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">        tag, data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    vnode = createComponent(tag, data, context, children)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(vnode)) &#123;</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(vnode)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDef(ns)) applyNS(vnode, ns)</span><br><span class="line">    <span class="keyword">if</span> (isDef(data)) registerDeepBindings(data)</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> createEmptyVNode()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_createElement</code> 方法有 5 个参数，<code>context</code> 表示 VNode 的上下文环境，它是 <code>Component</code> 类型；<code>tag</code>表示标签，它可以是一个字符串，也可以是一个 <code>Component</code>；<code>data</code> 表示 VNode 的数据，它是一个 <code>VNodeData</code> 类型，可以在 <code>flow/vnode.js</code> 中找到它的定义；<code>children</code> 表示当前 VNode 的子节点，它是任意类型的，需要被规范为标准的 <code>VNode</code> 数组； </p><h4 id="3-1-3、实例查看"><a href="#3-1-3、实例查看" class="headerlink" title="3.1.3、实例查看"></a><strong>3.1.3、实例查看</strong></h4><p>为了更直观查看我们平时写的 <code>Vue</code> 代码如何用 <code>VNode</code> 类来表示，我们通过一个实例的转换进行更深刻了解。</p><p>例如，实例化一个 <code>Vue</code> 实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createElement(<span class="string">'div'</span>, &#123;</span><br><span class="line">      attrs: &#123;</span><br><span class="line">        id: <span class="string">'app'</span>,</span><br><span class="line">        class: "class_box"</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;, <span class="keyword">this</span>.message)</span><br><span class="line">  &#125;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">'Hello Vue!'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们打印出其对应的 <code>VNode</code> 表示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="../../images/virtual_dom10.png?raw=true" alt="10.png" title>                </div>                <div class="image-caption">10.png</div>            </figure>  <h3 id="3-2、diff-过程"><a href="#3-2、diff-过程" class="headerlink" title="3.2、diff 过程"></a>3.2、<code>diff</code> 过程</h3><h4 id="3-2-1、Vue-js-源码的-diff-调用逻辑"><a href="#3-2-1、Vue-js-源码的-diff-调用逻辑" class="headerlink" title="3.2.1、Vue.js 源码的 diff 调用逻辑"></a>3.2.1、<code>Vue.js</code> 源码的 <code>diff</code> 调用逻辑</h4><p><code>Vue.js</code> 源码实例化了一个 <code>watcher</code>，这个 ~ 被添加到了在模板当中所绑定变量的依赖当中，一旦 <code>model</code> 中的响应式的数据发生了变化，这些响应式的数据所维护的 <code>dep</code> 数组便会调用 <code>dep.notify()</code> 方法完成所有依赖遍历执行的工作，这包括视图的更新，即 <code>updateComponent</code> 方法的调用。<code>watcher</code> 和 <code>updateComponent</code>方法定义在  <code>src/core/instance/lifecycle.js</code> 文件中 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  el: ?Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  vm.$el = el</span><br><span class="line">  <span class="comment">// 省略一系列其它代码</span></span><br><span class="line">  <span class="keyword">let</span> updateComponent</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 生成虚拟 vnode   </span></span><br><span class="line">      <span class="keyword">const</span> vnode = vm._render()</span><br><span class="line">      <span class="comment">// 更新 DOM</span></span><br><span class="line">      vm._update(vnode, hydrating)</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例化一个渲染Watcher，在它的回调函数中会调用 updateComponent 方法  </span></span><br><span class="line">  <span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</span><br><span class="line">        callHook(vm, <span class="string">'beforeUpdate'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  hydrating = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成视图的更新工作事实上就是调用了<code>vm._update</code>方法，这个方法接收的第一个参数是刚生成的<code>Vnode</code>，调用的<code>vm._update</code>方法定义在 <code>src/core/instance/lifecycle.js</code>中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> prevEl = vm.$el</span><br><span class="line">  <span class="keyword">const</span> prevVnode = vm._vnode</span><br><span class="line">  <span class="keyword">const</span> restoreActiveInstance = setActiveInstance(vm)</span><br><span class="line">  vm._vnode = vnode</span><br><span class="line">  <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">    <span class="comment">// 第一个参数为真实的node节点，则为初始化</span></span><br><span class="line">    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果需要diff的prevVnode存在，那么对prevVnode和vnode进行diff</span></span><br><span class="line">    vm.$el = vm.__patch__(prevVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">  restoreActiveInstance()</span><br><span class="line">  <span class="comment">// update __vue__ reference</span></span><br><span class="line">  <span class="keyword">if</span> (prevEl) &#123;</span><br><span class="line">    prevEl.__vue__ = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vm.$el) &#123;</span><br><span class="line">    vm.$el.__vue__ = vm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// if parent is an HOC, update its $el as well</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123;</span><br><span class="line">    vm.$parent.$el = vm.$el</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法当中最为关键的就是 <code>vm.__patch__</code> 方法，这也是整个 <code>virtual-dom</code> 当中最为核心的方法，主要完成了<code>prevVnode</code> 和 <code>vnode</code> 的 <code>diff</code> 过程并根据需要操作的 <code>vdom</code> 节点打 <code>patch</code>，最后生成新的真实 <code>dom</code> 节点并完成视图的更新工作。 </p><p>接下来，让我们看下 <code>vm.__patch__</code>的逻辑过程， <code>vm.__patch__</code> 方法定义在 <code>src/core/vdom/patch.js</code> 中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (isUndef(oldVnode)) &#123;</span><br><span class="line">      <span class="comment">// 当oldVnode不存在时，创建新的节点</span></span><br><span class="line">      isInitialPatch = <span class="literal">true</span></span><br><span class="line">      createElm(vnode, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 对oldVnode和vnode进行diff，并对oldVnode打patch  </span></span><br><span class="line">      <span class="keyword">const</span> isRealElement = isDef(oldVnode.nodeType)</span><br><span class="line">      <span class="keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">        <span class="comment">// patch existing root node</span></span><br><span class="line">        patchVnode(oldVnode, vnode, insertedVnodeQueue, <span class="literal">null</span>, <span class="literal">null</span>, removeOnly)</span><br><span class="line">      &#125; </span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>patch</code> 方法中，我们看到会分为两种情况，一种是当 <code>oldVnode</code> 不存在时，会创建新的节点；另一种则是已经存在 <code>oldVnode</code> ，那么会对 <code>oldVnode</code> 和 <code>vnode</code> 进行 <code>diff</code> 及 <code>patch</code> 的过程。其中 <code>patch</code> 过程中会调用 <code>sameVnode</code> 方法来对对传入的2个 <code>vnode</code> 进行基本属性的比较，只有当基本属性相同的情况下才认为这个2个<code>vnode</code> 只是局部发生了更新，然后才会对这2个 <code>vnode</code> 进行 <code>diff</code>，如果2个 <code>vnode</code> 的基本属性存在不一致的情况，那么就会直接跳过 <code>diff</code> 的过程，进而依据 <code>vnode</code> 新建一个真实的 <code>dom</code>，同时删除老的 <code>dom</code>节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sameVnode</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    a.key === b.key &amp;&amp;</span><br><span class="line">    a.tag === b.tag &amp;&amp;</span><br><span class="line">    a.isComment === b.isComment &amp;&amp;</span><br><span class="line">    isDef(a.data) === isDef(b.data) &amp;&amp;</span><br><span class="line">    sameInputType(a, b)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>diff</code> 过程中主要是通过调用 <code>patchVnode</code> 方法进行的:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchVnode</span> (<span class="params">oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly</span>) </span>&#123;</span><br><span class="line">  ...... </span><br><span class="line">  <span class="keyword">const</span> elm = vnode.elm = oldVnode.elm</span><br><span class="line">  <span class="keyword">const</span> oldCh = oldVnode.children</span><br><span class="line">  <span class="keyword">const</span> ch = vnode.children</span><br><span class="line">  <span class="comment">// 如果vnode没有文本节点</span></span><br><span class="line">  <span class="keyword">if</span> (isUndef(vnode.text)) &#123;</span><br><span class="line">    <span class="comment">// 如果oldVnode的children属性存在且vnode的children属性也存在  </span></span><br><span class="line">    <span class="keyword">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">      <span class="comment">// updateChildren，对子节点进行diff  </span></span><br><span class="line">      <span class="keyword">if</span> (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(ch)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        checkDuplicateKeys(ch)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果oldVnode的text存在，那么首先清空text的内容,然后将vnode的children添加进去  </span></span><br><span class="line">      <span class="keyword">if</span> (isDef(oldVnode.text)) nodeOps.setTextContent(elm, <span class="string">''</span>)</span><br><span class="line">      addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldCh)) &#123;</span><br><span class="line">      <span class="comment">// 删除elm下的oldchildren</span></span><br><span class="line">      removeVnodes(elm, oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;</span><br><span class="line">      <span class="comment">// oldVnode有子节点，而vnode没有，那么就清空这个节点  </span></span><br><span class="line">      nodeOps.setTextContent(elm, <span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text !== vnode.text) &#123;</span><br><span class="line">    <span class="comment">// 如果oldVnode和vnode文本属性不同，那么直接更新真是dom节点的文本元素</span></span><br><span class="line">    nodeOps.setTextContent(elm, vnode.text)</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上代码得知，</p><p><code>diff</code> 过程中又分了好几种情况，<code>oldCh</code> 为 <code>oldVnode</code>的子节点，<code>ch</code> 为 <code>Vnode</code>的子节点：</p><ul><li>首先进行文本节点的判断，若 <code>oldVnode.text !== vnode.text</code>，那么就会直接进行文本节点的替换；</li><li>在<code>vnode</code>  没有文本节点的情况下，进入子节点的 <code>diff</code>；</li><li>当 <code>oldCh</code> 和 <code>ch</code> 都存在且不相同的情况下，调用 <code>updateChildren</code> 对子节点进行 <code>diff</code>；</li><li>若 <code>oldCh</code>不存在，<code>ch</code> 存在，首先清空 <code>oldVnode</code> 的文本节点，同时调用 <code>addVnodes</code> 方法将 <code>ch</code> 添加到<code>elm</code>真实 <code>dom</code> 节点当中；</li><li>若 <code>oldCh</code>存在，<code>ch</code>不存在，则删除 <code>elm</code> 真实节点下的 <code>oldCh</code> 子节点；</li><li>若 <code>oldVnode</code> 有文本节点，而 <code>vnode</code> 没有，那么就清空这个文本节点。</li></ul><h4 id="3-2-2、子节点-diff-流程分析"><a href="#3-2-2、子节点-diff-流程分析" class="headerlink" title="3.2.2、子节点 diff 流程分析"></a>3.2.2、子节点 <code>diff</code> 流程分析</h4><p><strong>（1）<code>Vue.js</code> 源码</strong></p><p>​    这里着重分析下<code>updateChildren</code>方法，它也是整个 <code>diff</code> 过程中最重要的环节，以下为 <code>Vue.js</code> 的源码过程，为了更形象理解 <code>diff</code> 过程，我们给出相关的示意图来讲解。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span> (<span class="params">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 为oldCh和newCh分别建立索引，为之后遍历的依据</span></span><br><span class="line">  <span class="keyword">let</span> oldStartIdx = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> newStartIdx = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx]</span><br><span class="line">  <span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> newEndVnode = newCh[newEndIdx]</span><br><span class="line">  <span class="keyword">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直到oldCh或者newCh被遍历完后跳出循环</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx] <span class="comment">// Vnode has been moved left</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">      canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">      canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">      idxInOld = isDef(newStartVnode.key)</span><br><span class="line">        ? oldKeyToIdx[newStartVnode.key]</span><br><span class="line">        : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">      <span class="keyword">if</span> (isUndef(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vnodeToMove = oldCh[idxInOld]</span><br><span class="line">        <span class="keyword">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">          patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">          oldCh[idxInOld] = <span class="literal">undefined</span></span><br><span class="line">          canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">    refElm = isUndef(newCh[newEndIdx + <span class="number">1</span>]) ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].elm</span><br><span class="line">    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在开始遍历 <code>diff</code> 前，首先给 <code>oldCh</code>和 <code>newCh</code> 分别分配一个 <code>startIndex</code> 和 <code>endIndex</code> 来作为遍历的索引，当<code>oldCh</code> 或者 <code>newCh</code> 遍历完后(遍历完的条件就是 <code>oldCh</code> 或者 <code>newCh</code> 的 <code>startIndex &gt;= endIndex</code> )，就停止<code>oldCh</code> 和 <code>newCh</code> 的 <code>diff</code> 过程。接下来通过实例来看下整个 <code>diff</code> 的过程(节点属性中不带 <code>key</code> 的情况)。</p><p><strong>（2）无 <code>key</code> 的 <code>diff</code> 过程</strong></p><p>我们通过以下示意图对以上代码过程进行讲解：</p><p>（2.1）首先从第一个节点开始比较，不管是 <code>oldCh</code> 还是 <code>newCh</code> 的起始或者终止节点都不存在 <code>sameVnode</code> ，同时节点属性中是不带 <code>key</code>标记的，因此第一轮的 <code>diff</code> 完后，<code>newCh</code>的 <code>startVnode</code> 被添加到 <code>oldStartVnode</code>的前面，同时 <code>newStartIndex</code>前移一位；   </p><p><img src="/img/loading.gif" data-original="../../images/virtual_dom11.jpg?raw=true" alt="11.jpg">    </p><p>（2.2）第二轮的 <code>diff</code>中，满足 <code>sameVnode(oldStartVnode, newStartVnode)</code>，因此对这2个 <code>vnode</code> 进行<code>diff</code>，最后将 <code>patch</code> 打到 <code>oldStartVnode</code> 上，同时 <code>oldStartVnode</code>和 <code>newStartIndex</code> 都向前移动一位 ；</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="../../images/virtual_dom12.jpg?raw=true" alt="12.jpg" title>                </div>                <div class="image-caption">12.jpg</div>            </figure>  <p>（2.3）第三轮的 <code>diff</code> 中，满足 <code>sameVnode(oldEndVnode, newStartVnode)</code>，那么首先对  <code>oldEndVnode</code>和<code>newStartVnode</code> 进行 <code>diff</code>，并对 <code>oldEndVnode</code>进行 <code>patch</code>，并完成  <code>oldEndVnode</code> 移位的操作，最后<code>newStartIndex</code>前移一位，<code>oldStartVnode</code> 后移一位； </p><p><img src="/img/loading.gif" data-original="../../images/virtual_dom13.jpg?raw=true" alt="13.jpg">  </p><p>（2.4）第四轮的 <code>diff</code>中，过程同步骤3； </p><p><img src="/img/loading.gif" data-original="../../images/virtual_dom14.jpg?raw=true" alt="14.jpg">  </p><p>  （2.5）第五轮的 <code>diff</code> 中，同过程1； </p><p><img src="/img/loading.gif" data-original="../../images/virtual_dom15.jpg?raw=true" alt="15.jpg">   </p><p>（2.6）遍历的过程结束后，<code>newStartIdx &gt; newEndIdx</code>，说明此时 <code>oldCh</code> 存在多余的节点，那么最后就需要将这些多余的节点删除。 </p><p><img src="/img/loading.gif" data-original="../../images/virtual_dom16.jpg?raw=true" alt="16g">  </p><p><strong>（3）有 <code>key</code> 的 <code>diff</code> 流程</strong></p><p>在 <code>vnode</code> 不带 <code>key</code> 的情况下，每一轮的 <code>diff</code> 过程当中都是<code>起始</code>和<code>结束</code>节点进行比较，直到 <code>oldCh</code> 或者<code>newCh</code> 被遍历完。而当为 <code>vnode</code> 引入 <code>key</code> 属性后，在每一轮的 <code>diff</code> 过程中，当<code>起始</code>和<code>结束</code>节点都没有找到<code>sameVnode</code> 时，然后再判断在 <code>newStartVnode</code> 的属性中是否有 <code>key</code>，且是否在 <code>oldKeyToIndx</code> 中找到对应的节点 ：</p><ul><li>如果不存在这个 <code>key</code>，那么就将这个 <code>newStartVnode</code>作为新的节点创建且插入到原有的 <code>root</code> 的子节点中；</li><li>如果存在这个 <code>key</code>，那么就取出 <code>oldCh</code> 中的存在这个 <code>key</code> 的 <code>vnode</code>，然后再进行 <code>diff</code> 的过；</li></ul><p>通过以上分析，给<code>vdom</code>上添加 <code>key</code>属性后，遍历 <code>diff</code> 的过程中，当<strong>起始点</strong>，<strong>结束点</strong>的<strong>搜寻</strong>及 <code>diff</code> 出现还是无法匹配的情况下时，就会用 <code>key</code> 来作为唯一标识，来进行 <code>diff</code>，这样就可以提高 <code>diff</code> 效率。  </p><p>带有 <code>Key</code>属性的 <code>vnode</code>的 <code>diff</code> 过程可见下图： </p><p>（3.1）首先从第一个节点开始比较，不管是 <code>oldCh</code> 还是 <code>newCh</code> 的起始或者终止节点都不存在 <code>sameVnode</code>，但节点属性中是带 <code>key</code> 标记的， 然后在 <code>oldKeyToIndx</code> 中找到对应的节点，这样第一轮 <code>diff</code> 过后 <code>oldCh</code> 上的<code>B节点</code>被删除了，但是 <code>newCh</code> 上的<code>B节点</code>上 <code>elm</code> 属性保持对 <code>oldCh</code> 上 <code>B节点</code> 的<code>elm</code>引用。  </p><p><img src="/img/loading.gif" data-original="../../images/virtual_dom17.jpg?raw=true" alt="17.jpg">   </p><p>（3.2）第二轮的 <code>diff</code> 中，满足 <code>sameVnode(oldStartVnode, newStartVnode)</code>，因此对这2个 <code>vnode</code> 进行<code>diff</code>，最后将 <code>patch</code> 打到 <code>oldStartVnode</code>上，同时 <code>oldStartVnode</code> 和 <code>newStartIndex</code> 都向前移动一位 ；</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="../../images/virtual_dom18.jpg?raw=true" alt="18.jpg" title>                </div>                <div class="image-caption">18.jpg</div>            </figure>  <p>（3.3）第三轮的 <code>diff</code>中，满足 <code>sameVnode(oldEndVnode, newStartVnode)</code>，那么首先对 <code>oldEndVnode</code> 和<code>newStartVnode</code> 进行 <code>diff</code>，并对 <code>oldEndVnode</code> 进行 <code>patch</code>，并完成 <code>oldEndVnode</code> 移位的操作，最后<code>newStartIndex</code> 前移一位，<code>oldStartVnode</code>后移一位； </p><p><img src="/img/loading.gif" data-original="../../images/virtual_dom19.jpg?raw=true" alt="19.jpg">  </p><p>（3.4）第四轮的<code>diff</code>中，过程同步骤2； </p><p><img src="/img/loading.gif" data-original="../../images/virtual_dom20.jpg?raw=true" alt="20.jpg"> </p><p>  （3.5）第五轮的<code>diff</code>中，因为此时 <code>oldStartIndex</code> 已经大于 <code>oldEndIndex</code>，所以将剩余的 <code>Vnode</code> 队列插入队列最后。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/loading.gif" data-original="../../images/virtual_dom21.jpg?raw=true" alt="21.jpg" title>                </div>                <div class="image-caption">21.jpg</div>            </figure>   <h3 id="3-3、patch-过程"><a href="#3-3、patch-过程" class="headerlink" title="3.3、patch 过程"></a>3.3、<code>patch</code> 过程</h3><p>通过3.2章节介绍的 <code>diff</code> 过程中，我们会看到 <code>nodeOps</code> 相关的方法对真实 <code>DOM</code> 结构进行操作，<code>nodeOps</code> 定义在 <code>src/platforms/web/runtime/node-ops.js</code> 中，其为基本 <code>DOM</code> 操作，这里就不在详细介绍。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createElementNS</span> (<span class="params">namespace: string, tagName: string</span>): <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">document</span>.createElementNS(namespaceMap[namespace], tagName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createTextNode</span> (<span class="params">text: string</span>): <span class="title">Text</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">document</span>.createTextNode(text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComment</span> (<span class="params">text: string</span>): <span class="title">Comment</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">document</span>.createComment(text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">insertBefore</span> (<span class="params">parentNode: Node, newNode: Node, referenceNode: Node</span>) </span>&#123;</span><br><span class="line">  parentNode.insertBefore(newNode, referenceNode)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">removeChild</span> (<span class="params">node: Node, child: Node</span>) </span>&#123;</span><br><span class="line">  node.removeChild(child)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4、总结"><a href="#3-4、总结" class="headerlink" title="3.4、总结"></a>3.4、总结</h3><p>通过前三小节简析，我们从主线上把模板和数据如何渲染成最终的 <code>DOM</code> 的过程分析完毕了，我们可以通过下图更直观地看到从初始化 <code>Vue</code> 到最终渲染的整个过程。 </p><p><img src="/img/loading.gif" data-original="../../images/virtual_dom22.png?raw=true" alt="22.png">  </p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本文从通过介绍真实 <code>DOM</code> 结构其解析过程以及存在的问题，从而引出为什么需要虚拟 <code>DOM</code>；然后分析虚拟<code>DOM</code> 的好处，以及其一些理论基础和基础算法的实现；最后根据我们已经掌握的基础知识，再一步步去查看<code>Vue.js</code> 的源码如何实现的。从存在问题 —&gt; 理论基础 —&gt; 具体实践，一步步深入，帮助大家更好的了解什么是<code>Virtual DOM</code>、为什么需要 <code>Virtual DOM</code>、以及 <code>Virtual DOM</code>的具体实现，希望本文对您有帮助。</p><p><strong>辛苦编写良久，如果对你有帮助，还望手动点赞鼓励<del>~</del></strong></p><p><strong>github地址为：<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Ffengshi123%2Fblog" target="_blank" rel="noopener">github.com/fengshi123/…</a>，上面汇总了作者所有的博客文章，如果喜欢或者有所启发，请帮忙给个 star ~，对作者也是一种鼓励。</strong></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>1、Vue 技术揭秘：<a href="https://ustbhuangyi.github.io/vue-analysis/" target="_blank" rel="noopener">https://ustbhuangyi.github.io/vue-analysis/</a> </p><p>2、深度剖析：如何实现一个 Virtual DOM 算法：<a href="https://segmentfault.com/a/1190000004029168" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004029168</a> </p><p>3、vue核心之虚拟DOM(vdom)：<a href="https://www.jianshu.com/p/af0b398602bc" target="_blank" rel="noopener">https://www.jianshu.com/p/af0b398602bc</a> </p><p>4、virtual-dom(Vue实现)简析：<a href="https://segmentfault.com/a/1190000010090659" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010090659</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入剖析：Vue核心之虚拟DOM&quot;&gt;&lt;a href=&quot;#深入剖析：Vue核心之虚拟DOM&quot; class=&quot;headerlink&quot; title=&quot;深入剖析：Vue核心之虚拟DOM&quot;&gt;&lt;/a&gt;深入剖析：Vue核心之虚拟DOM&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="前端文章" scheme="https://qw66.gitee.io/categories/%E5%89%8D%E7%AB%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="虚拟DOM" scheme="https://qw66.gitee.io/tags/%E8%99%9A%E6%8B%9FDOM/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs</title>
    <link href="https://qw66.gitee.io//articles/nodejs.html"/>
    <id>https://qw66.gitee.io//articles/nodejs.html</id>
    <published>2023-11-18T16:00:00.000Z</published>
    <updated>2024-02-18T02:46:06.000Z</updated>
    
    <content type="html"><![CDATA[<p> <a href="http://blog.fens.me/series-nodejs/" target="_blank" rel="noopener">从零开始nodejs系列文章</a>，将介绍如何利Javascript做为服务端脚本，通过Nodejs框架web开发。Nodejs框架是基于V8的引擎，是目前速度最快的Javascript引擎。chrome浏览器就基于V8，同时打开20-30个网页都很流畅。Nodejs标准的web开发框架Express，可以帮助我们迅速建立web站点，比起PHP的开发效率更高，而且学习曲线更低。非常适合小型网站，个性化网站，我们自己的Geek网站！！ </p><p>首先来说，nodeJs是前端全栈的基石，它的应用场景已经从前端工具的脚手架、辅助工具类，发展到api中间层、代理层，以及专业的后端开发。</p><p>这其中最有价值的就是api中间层。现在的大趋势是越来越多的业务被推到前端，后端专注于只提供服务。很典型且常见的工作场景就是，前后端协作的时候，因为进度不同有时前端需要等后端的接口。</p><p>这种时候，nodeJs的中间层应用就可以很好的解决这个问题。前端通过nodeJs可以自己约定数据的格式，根据前端的需求定制自己的接口，自己封装对数据库的crud操作，创建自己的代理和网关服务器等。这些事情在以往只能是等着后端做，但现在通过nodeJs前端都可以自己搞定，这就使得工作的过程更加可控。</p><p>当然了这也对前端开发人员提出了更高的要求，至少数据库、架构设计、系统结构 、网络应用这些短板都需要慢慢补齐。</p><p>据说啊我也不确定，nodeJs最开始是给后端搞的，只不过为了简单、异步、大并发而选择了Java语言，阴差阳错之下被前端发现并发扬光大。</p><p>所以前端搞nodeJs必然是向后端侵蚀，而后端的开发结构、技术栈已经很完整了，所以后端一般不愿意变动，所以很多时候对于nodeJs的阻力，其实是来源于后端的保守。当然这也是有一定道理的，因为后端主要是服务、数据、底层应用，这些东西都求稳、求安全、还有些历史遗留问题，所以它们不喜欢新东西。</p><p>所以在现阶段吧，很多nodeJs的应用都是处于前端和后端之间的桥梁。一般来讲，没有什么历史包袱的新公司啊，创业公司啊，孵化项目之类的更愿意使用nodeJs，快速、高效嘛。</p><p>现在基本上所有的前端应用都有nodeJs的影子，什么React、vue、angular等，它的应用场景和就业市场也都很大，所以nodeJs的学习不是让你可以做什么，而是让你多了一个施展的空间。</p><h3 id><a href="#" class="headerlink" title=" "></a> </h3><h3 id="NodeJs的优势和适合开发的程序"><a href="#NodeJs的优势和适合开发的程序" class="headerlink" title="NodeJs的优势和适合开发的程序"></a>NodeJs的优势和适合开发的程序</h3><p>做页游或webqq这样的应用nodejs有优势，但如果做微博、豆瓣、facebook这样的社交网络，nodejs还有优势吗？另外不知道大家是什么原因选择的nodejs？是因为应用需求还是对javascript这门语言的喜欢？</p><p>很多同学可能都听说过nodejs，并且知道他是可以运行在服务器上的javascript，但是他的使用场景可能大家并不是很清楚，最近也在看学习nodejs，就做了一下小总结；</p><p><strong>NodeJs的优势：</strong></p><p>现在的很多的服务器端的语言（PHP,JAVA,ASP.net）,有什么问题呢，现在的服务器端的语言在用户访问服务器时，为每个用户链接创建了一个线程，但每个线程大约要耗费2M的内存，如果一个8G内存的服务器，也就能链接4000个左右的用户，如果用户的链接数较大，就必须增加服务器的数量，而且现在用户的链接方式有很多（如app，网页同时访问），这就又涉及到服务器共享的问题，所以服务器怎么支持最大的同时链接用户量就成了一个问题；</p><p>NodeJS修改了客户端到服务器端的链接方法，解决了这个问题，他不在为每个客户端创建一个新的线程，而是为每个客户端链接出发一个NodeJs内部进行处理的事件，所以NodeJS具备同时处理多达几万个用户的客户端链接的能力；</p><p><strong>NodeJS适合开发的应用程序：</strong></p><p>当应用程序需要处理大量并发的输入/输出，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，我们应该考虑使用NodeJs来进行应用程序的开发，例如：</p><p>1、聊天服务器：如果聊天的人很多，用户的与服务器之间的并发链接量很大，但是服务器端的数据处理并不复杂；</p><p>2、综合类服务网站和电子商务网站的服务器：在这类网站中的服务器端，往往可能每秒存内可以接受多达上千条的数据并且需要将这些数据写入数据库中，NodeJs可以通过其队列机制将这些数据迅速写入缓存区中，然后再通过每一个单独的处理从缓存区中取出这些数据并将其写入数据库中，如果是其他的服务器（如Apache服务器或Tomcat服务器）的话，由于这些服务器采用的是阻塞型I/O机制，因此每条数据写入到数据库中都要等待一段时间（等上一条写完，才能写下一条），但是NodeJs使用的是非阻塞的I/O机制，因此可以实现这些数据到数据库中的写入，而不必再为每条数据的写入而等待一段时间；</p><p><strong>总结：</strong></p><p>一个规模稍微大点的系统都不是一种开发语言可以搞定的，往往是几种混杂一起，比如c、c++做服务器端开发，java做业务逻辑，php等做前端展示，此外还需要消息中间件等等。</p><p>nodejs可以很快地在服务器端做原型（原来只有c系和java等能做的事情，性能还很高），而且代码量相对会少很多；另一点是它的语法优势，js闭包等。但它不太适合做cpu密集型处理的工作，只能绕着弯去解决，据说这次QCon会有人分享这方面的研究成果，可以关注下。</p><p>每种语言都有它适合的领域，没必要强求一门语言可以解决所有事情，拥有其它语言的特性，只有不断的tradeoff把系统做出来才是目标。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; &lt;a href=&quot;http://blog.fens.me/series-nodejs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;从零开始nodejs系列文章&lt;/a&gt;，将介绍如何利Javascript做为服务端脚本，通过Nodejs框架web开发。N
      
    
    </summary>
    
      <category term="前端文章" scheme="https://qw66.gitee.io/categories/%E5%89%8D%E7%AB%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Nodejs" scheme="https://qw66.gitee.io/tags/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的33个概念</title>
    <link href="https://qw66.gitee.io//articles/javascript-de-33-ge-gai-nian.html"/>
    <id>https://qw66.gitee.io//articles/javascript-de-33-ge-gai-nian.html</id>
    <published>2023-11-17T16:00:00.000Z</published>
    <updated>2024-02-18T02:45:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 align="center"><br>  <a href="https://github.com/stephentian/33-js-concepts" target="_blank" rel="noopener"><img src="/img/loading.gif" data-original="/articles/javascript-de-33-ge-gai-nian/33_js_concepts.jpg" alt="每位 JS 开发应该懂的 33 个概念" width="200" "></a>  <br>    <br>  JavaScript开发者应懂的33个概念  <br></h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这个项目是为了帮助开发者掌握 JavaScript 概念而创立的。它不是必备，但在未来学习（JavaScript）中，可以作为一篇指南。</p><blockquote><p>本篇文章是参照 @leonardomso 创立，英文版项目地址在<a href="https://github.com/leonardomso/33-js-concepts" target="_blank" rel="noopener">这里</a>。<br>由于原版资源都要翻墙，所以本人创立一个中文版，附上关于这些概念在国内的一些文章和视频。<br>若有觉得更好的文章或者视频，可以贡献出来，觉得有误的，请联系我删除。</p></blockquote><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>若有觉得更好的文章或者视频，可以贡献出来，觉得有误的，请联系我删除。</p><ul><li>文章的排序优化，前面的文章是介绍概念，后面的文章是深入解读。</li><li>将原文的 “高阶函数” 和 “map, reduce, filter” 合并为 “map, reduce, filter 等高阶函数”</li><li>增加 “promise” 概念(替换删除的 “高阶函数”)</li><li>2018-10-24 更新：@BuptStEve 贡献的三篇关于” 函数式编程 “方面的文章</li><li>2018-12-04 更新：@haner199401 贡献的 @冴羽 “JavaScript 深入之从原型到原型链”</li></ul><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><strong><a href="#1-调用堆栈">调用堆栈</a></strong></li><li><strong><a href="#2-原始类型">原始类型</a></strong></li><li><strong><a href="#3-值类型和引用类型">值类型和引用类型</a></strong></li><li><strong><a href="#4-隐式-显式-名义和鸭子类型">隐式, 显式, 名义和鸭子类型</a></strong></li><li><strong><a href="#5--vs--typeof-vs-instanceof">== 与 ===, typeof 与 instanceof</a></strong></li><li><strong><a href="#6-this-call-apply-和-bind">this, call, apply 和 bind</a></strong></li><li><strong><a href="#7-函数作用域-块级作用域和词法作用域">函数作用域, 块级作用域和词法作用域</a></strong></li><li><strong><a href="#8-闭包">闭包</a></strong></li><li><strong><a href="#9-map-reduce-filter-等高阶函数">map, reduce, filter 等高阶函数</a></strong></li><li><strong><a href="#10-表达式和语句">表达式和语句</a></strong></li><li><strong><a href="#11-变量提升">变量提升</a></strong></li><li><strong><a href="#12-promise">Promise</a></strong></li><li><strong><a href="#13-立即执行函数-模块化-命名空间">立即执行函数, 模块化, 命名空间</a></strong></li><li><strong><a href="#14-递归">递归</a></strong></li><li><strong><a href="#15-算法">算法</a></strong></li><li><strong><a href="#16-数据结构">数据结构</a></strong></li><li><strong><a href="#17-消息队列和事件循环">消息队列和事件循环</a></strong></li><li><strong><a href="#18-settimeout-setinterval-和-requestanimationframe">setTimeout, setInterval 和 requestAnimationFrame</a></strong></li><li><strong><a href="#19-继承-多态和代码复用">继承, 多态和代码复用</a></strong></li><li><strong><a href="#20-按位操作符-类数组对象和类型化数组">按位操作符, 类数组对象和类型化数组</a></strong></li><li><strong><a href="#21-dom-树和渲染过程">DOM 树和渲染过程</a></strong></li><li><strong><a href="#22-new-与构造函数-instanceof-与实例">new 与构造函数, instanceof 与实例</a></strong></li><li><strong><a href="#23-原型继承与原型链">原型继承与原型链</a></strong></li><li><strong><a href="#24-objectcreate-和-objectassign">Object.create 和 Object.assign</a></strong></li><li><strong><a href="#25-工厂函数和类">工厂函数和类</a></strong></li><li><strong><a href="#26-设计模式">设计模式</a></strong></li><li><strong><a href="#27-memoization">Memoization</a></strong></li><li><strong><a href="#28-纯函数-函数副作用和状态变化">纯函数, 函数副作用和状态变化</a></strong></li><li><strong><a href="#29-耗性能操作和时间复杂度">耗性能操作和时间复杂度</a></strong></li><li><strong><a href="#30-javascript-引擎">JavaScript 引擎</a></strong></li><li><strong><a href="#31-二进制-十六进制-十进制-科学记数法">二进制, 十进制, 十六进制, 科学记数法</a></strong></li><li><strong><a href="#32-偏函数-柯里化-compose-和-pipe">偏函数, 柯里化, Compose 和 Pipe</a></strong></li><li><strong><a href="#33-代码整洁之道">代码整洁之道</a></strong></li></ol><hr><h2 id="1-调用堆栈"><a href="#1-调用堆栈" class="headerlink" title="1. 调用堆栈"></a>1. 调用堆栈</h2><h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><ul><li>:book: <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Call_stack" target="_blank" rel="noopener">Call Stack — MDN</a></li><li>:book: <a href="https://juejin.im/post/5a05b4576fb9a04519690d42" target="_blank" rel="noopener">[译] JavaScript 如何工作：对引擎、运行时、调用堆栈的概述 —— 掘金</a></li><li>:book: <a href="https://juejin.im/post/5ba32171f265da0ab719a6d7" target="_blank" rel="noopener">[译] 理解 JavaScript 中的执行上下文和执行栈 —— 掘金</a></li><li>:book: <a href="https://juejin.im/post/59e85eebf265da430d571f89" target="_blank" rel="noopener">这一次，彻底弄懂 JavaScript 执行机制 —— 掘金</a></li><li>:book: <a href="https://www.oschina.net/translate/how-does-javascript-actually-work-part-1" target="_blank" rel="noopener">解读 JavaScript 之引擎、运行时和堆栈调用 —— 开源中国</a></li><li>:book: <a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener">Tasks, microtasks, queues and schedules —— Jake Archibald</a></li><li>:book: <a href="https://juejin.im/entry/55dbd51a60b2f3a92a8f5bff" target="_blank" rel="noopener">Tasks, microtasks, queues and schedules（译） —— 掘金</a></li></ul><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><ul><li>:tv: <a href="https://v.qq.com/x/page/h0372bld8re.html?ptag=qqbrowser" target="_blank" rel="noopener">What is the event loop anyway? —— 腾讯视频(英文字幕)</a></li><li>:tv: <a href="https://www.bilibili.com/video/av33824933/" target="_blank" rel="noopener">Understanding The JavaScript Call Stack, Event Queue, Event Table, &amp; Event Loop —— Bilibili</a></li><li>:tv: <a href="http://www.acfun.cn/v/ac4495641" target="_blank" rel="noopener">JS 中的变量提升、堆栈内存及闭包详解 —— Acfun</a></li><li>:tv: <a href="http://www.php.cn/code/21194.html" target="_blank" rel="noopener">事件循环模型 —— PHP 中文网</a></li><li>:tv: <a href="https://www.youtube.com/watch?v=w6QGEiQceOM" target="_blank" rel="noopener">Javascript: the Call Stack explained — Coding Blocks India</a></li><li>:tv: <a href="https://www.youtube.com/watch?v=W8AeMrVtFLY" target="_blank" rel="noopener">The JS Call Stack Explained In 9 Minutes — Colt Steele</a></li><li>:tv: <a href="https://www.youtube.com/watch?v=jT0USJeNFEA" target="_blank" rel="noopener">JavaScript Execution Stack — Codecademy</a></li><li>:tv: <a href="https://www.youtube.com/watch?v=w7QWQlkLY_s" target="_blank" rel="noopener">What is the Call Stack? — Eric Traub</a></li><li>:tv: <a href="https://www.youtube.com/watch?v=Q2sFmqvpBe0" target="_blank" rel="noopener">The Call Stack — Kevin Drumm</a></li><li>:tv: <a href="https://www.youtube.com/watch?v=Z6a1cLyq7Ac&list=PLWrQZnG8l0E4kd1T_nyuVoxQUaYEWFgcD" target="_blank" rel="noopener">Understanding JavaScript Execution — Codesmith</a></li><li>:tv: <a href="https://www.youtube.com/watch?v=mk0lu9MKBto" target="_blank" rel="noopener">Call Stack &amp; Event Loop — movies com</a></li></ul><p><strong><a href="#目录">:arrow_up: 返回目录</a></strong></p><hr><h2 id="2-原始类型"><a href="#2-原始类型" class="headerlink" title="2. 原始类型"></a>2. 原始类型</h2><h3 id="文章-1"><a href="#文章-1" class="headerlink" title="文章"></a>文章</h3><ul><li>:book: <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive" target="_blank" rel="noopener">原始数据 —— MDN</a></li><li>:book: <a href="https://segmentfault.com/a/1190000017090272" target="_blank" rel="noopener">[译]JavaScript 是怎样编码数字的 —— SegmentFault</a></li><li>:book: <a href="https://yanhaijing.com/javascript/2014/03/14/what-every-javascript-developer-should-know-about-floating-points/" target="_blank" rel="noopener">每一个 JavaScript 开发者应该了解的浮点知识 —— 颜海镜</a></li><li>:book: <a href="https://wangdoc.com/javascript/types/number.html" target="_blank" rel="noopener">JavaScript 标准参考教程(基本语法之数值) —— 阮一峰</a></li><li>:book: <a href="https://javascriptweblog.wordpress.com/2010/09/27/the-secret-life-of-javascript-primitives/" target="_blank" rel="noopener">The Secret Life of JavaScript Primitives —— Angus Croll</a></li></ul><h3 id="视频-1"><a href="#视频-1" class="headerlink" title="视频"></a>视频</h3><ul><li>:tv: <a href="https://www.imooc.com/video/5674" target="_blank" rel="noopener">javascript 六种数据类型 —— 慕课网</a></li><li>:tv: <a href="http://www.php.cn/code/5808.html" target="_blank" rel="noopener">javascript 视频教程(数据类型) —— PHP 中文网</a></li><li>:tv: <a href="https://www.youtube.com/watch?v=9ooYYRLdg_g" target="_blank" rel="noopener">JavaScript Reference vs Primitive Types — Academind</a></li><li>:tv: <a href="https://www.youtube.com/watch?v=HsbWQsSCE5Y" target="_blank" rel="noopener">JavaScript Primitive Types — Simon Sez IT</a></li><li>:tv: <a href="https://www.youtube.com/watch?v=F7YbhKbpFic" target="_blank" rel="noopener">Javascript Primitive and Reference Types — Baljeet Singh</a></li><li>:tv: <a href="https://www.youtube.com/watch?v=e-_mDyqm2oU" target="_blank" rel="noopener">Value Types and Reference Types in JavaScript — Programming with Mosh</a></li><li>:tv: <a href="https://www.youtube.com/watch?v=qw3j0A3DIzQ" target="_blank" rel="noopener">JavaScript Primitive Data Types — Avelx</a></li><li>:tv: <a href="https://www.youtube.com/watch?v=MqHDDtVYJRI" target="_blank" rel="noopener">Everything you never wanted to know about JavaScript numbers — Bartek Szopka</a></li></ul><p><strong><a href="#目录">:arrow_up: 返回目录</a></strong></p><hr><h2 id="3-值类型和引用类型"><a href="#3-值类型和引用类型" class="headerlink" title="3. 值类型和引用类型"></a>3. 值类型和引用类型</h2><h3 id="文章-2"><a href="#文章-2" class="headerlink" title="文章"></a>文章</h3><ul><li>:book: <a href="http://www.w3school.com.cn/js/pro_js_referencetypes.asp" target="_blank" rel="noopener">ECMAScript 引用类型 —— W3school</a></li><li>:book: <a href="https://www.cnblogs.com/leiting/p/8081413.html" target="_blank" rel="noopener">js 中的值类型和引用类型的区别 —— 博客园</a></li><li>:book: <a href="https://blog.fundebug.com/2017/08/09/explain_value_reference_in_js/" target="_blank" rel="noopener">JavaScript 的值传递和引用传递 —— FunDebug</a></li><li>:book: <a href="https://docstore.mik.ua/orelly/webprog/jscript/ch04_04.htm" target="_blank" rel="noopener">Primitive Types &amp; Reference Types in JavaScript —— Bran van der Meer</a></li><li>:book: <a href="https://blog.csdn.net/xiaojia_boke/article/details/54906509" target="_blank" rel="noopener">JavaScript: Passing by Value or by Reference —— CSDN</a></li><li>:book: <a href="https://segmentfault.com/a/1190000015411195" target="_blank" rel="noopener">js 值引用和值复制 —— SegmentFault</a></li><li>:book: <a href="https://blog.csdn.net/zzzaquarius/article/details/4902235" target="_blank" rel="noopener">js- 引用和复制(传值和传址) —— CSDN</a></li></ul><h3 id="视频-2"><a href="#视频-2" class="headerlink" title="视频"></a>视频</h3><ul><li>:tv: <a href="https://www.youtube.com/watch?v=E-dAnFdq8k8" target="_blank" rel="noopener">Javascript Pass by Value vs Pass by Reference — techsith</a></li><li>:tv: <a href="https://www.youtube.com/watch?v=fD0t_DKREbE" target="_blank" rel="noopener">JavaScript Value vs Reference Types — Programming with Mosh</a></li></ul><p><strong><a href="#目录">:arrow_up: 返回目录</a></strong></p><hr><h2 id="4-隐式-显式-名义和鸭子类型"><a href="#4-隐式-显式-名义和鸭子类型" class="headerlink" title="4. 隐式, 显式, 名义和鸭子类型"></a>4. 隐式, 显式, 名义和鸭子类型</h2><h3 id="文章-3"><a href="#文章-3" class="headerlink" title="文章"></a>文章</h3><ul><li>:book: <a href="http://www.w3school.com.cn/js/pro_js_typeconversion.asp" target="_blank" rel="noopener">ECMAScript 类型转换 —— W3school</a></li><li>:book: <a href="http://justjavac.com/javascript/2013/04/08/javascript-quirk-1-implicit-conversion-of-values.html" target="_blank" rel="noopener">JavaScript 的怪癖 1：隐式类型转换 —— justjavac</a></li><li>:book: <a href="https://juejin.im/post/59ad2585f265da246a20e026" target="_blank" rel="noopener">JavaScript 运算符规则与隐式类型转换详解 —— 掘金</a></li><li>:book: <a href="https://segmentfault.com/a/1190000004482388" target="_blank" rel="noopener">聊一聊 JS 中的隐式类型转换 —— SegmentFault</a></li><li>:book: <a href="https://www.cnblogs.com/yugege/p/5277883.html" target="_blank" rel="noopener">有趣的 JavaScript 隐式类型转换 —— 博客园</a></li><li>:book: <a href="https://blog.csdn.net/yangjvn/article/details/48284163" target="_blank" rel="noopener">JavaScript 显式类型转换与隐式类型转换 —— CSDN</a></li><li>:book: <a href="https://www.jianshu.com/p/777a89b4ed9a" target="_blank" rel="noopener">你不知道的 JavaScript（中卷）强制类型转换 —— 简书</a></li><li>:book: <a href="https://ithelp.ithome.com.tw/articles/10201512" target="_blank" rel="noopener">你懂 JavaScript 嗎？#8 強制轉型 —— cythilya</a></li><li>:book: <a href="http://book.51cto.com/art/201505/475153.htm" target="_blank" rel="noopener">动态类型语言和鸭子类型 —— 曾探</a></li><li>:book: <a href="https://flow.org/en/docs/lang/nominal-structural/" target="_blank" rel="noopener">Nominal &amp; Structural Typing —— flow</a></li><li>:book: <a href="https://stackoverflow.com/questions/19915688/what-exactly-is-type-coercion-in-javascript" target="_blank" rel="noopener">What exactly is Type Coercion in Javascript? —— stackoverflow</a></li><li>:book: <a href="https://github.com/getify/You-Dont-Know-JS/blob/master/types%20&%20grammar/ch4.md" target="_blank" rel="noopener">You Don’t Know JS: Types &amp; Grammar —— github</a></li></ul><h3 id="视频-3"><a href="#视频-3" class="headerlink" title="视频"></a>视频</h3><ul><li>:tv: <a href="https://www.imooc.com/video/5675" target="_blank" rel="noopener">javascript 隐式转换 —— 慕课网</a></li><li>:tv: <a href="http://www.le.com/ptv/vplay/27767009.html" target="_blank" rel="noopener">Javascript 基础加强-类型转换 —— 黑马程序员</a></li></ul><p><strong><a href="#目录">:arrow_up: 返回目录</a></strong></p><hr><div id="5--vs--typeof-vs-instanceof"></div>## 5. == vs ===, typeof vs instanceof<h3 id="文章-4"><a href="#文章-4" class="headerlink" title="文章"></a>文章</h3><ul><li>:book: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness" target="_blank" rel="noopener">JavaScript 中的相等性判断 —— MDN</a></li><li>:book: <a href="https://juejin.im/entry/584918612f301e005716add6" target="_blank" rel="noopener">js 中 == 和 === 的区别 —— 掘金</a></li><li>:book: <a href="https://blog.csdn.net/w97531/article/details/82255225" target="_blank" rel="noopener">== vs === in Javascript —— CSDN</a></li><li>:book: <a href="https://blog.csdn.net/mevicky/article/details/50353881" target="_blank" rel="noopener">深入理解 javascript 之 typeof 和 instanceof —— CSDN</a></li><li>:book: <a href="http://justjavac.com/javascript/2012/12/23/what-is-javascripts-typeof-operator-used-for.html" target="_blank" rel="noopener">JavaScript 的 typeof 的用途 —— justjavac</a></li><li>:book: <a href="https://juejin.im/post/58358606570c35005e4142bd" target="_blank" rel="noopener">一张图看懂 Function 和 Object 的关系及简述 instanceof 运算符 —— 掘金</a></li><li>:book: <a href="https://juejin.im/post/5b0b9b9051882515773ae714" target="_blank" rel="noopener">浅谈 instanceof 和 typeof 的实现原理 —— 掘金</a></li><li>:book: <a href="https://segmentfault.com/a/1190000000730982" target="_blank" rel="noopener">typeof 和 instanceOf 的区别</a></li></ul><p><strong><a href="#目录">:arrow_up: 返回目录</a></strong></p><hr><h2 id="6-this-call-apply-和-bind"><a href="#6-this-call-apply-和-bind" class="headerlink" title="6. this, call, apply 和 bind"></a>6. this, call, apply 和 bind</h2><h3 id="文章-5"><a href="#文章-5" class="headerlink" title="文章"></a>文章</h3><ul><li>:book: <a href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html" target="_blank" rel="noopener">Javascript 的 this 用法 —— 阮一峰</a></li><li>:book: <a href="https://www.imooc.com/article/1758" target="_blank" rel="noopener">学会 JS 的 this 这一篇就够了，根本不用记 —— 慕课网</a></li><li>:book: <a href="https://juejin.im/post/5b9f176b6fb9a05d3827d03f" target="_blank" rel="noopener">[译] this（他喵的）到底是什么 — 理解 JavaScript 中的 this、call、apply 和 bind —— 掘金</a></li><li>:book: <a href="https://juejin.im/post/59bfe84351882531b730bac2" target="_blank" rel="noopener">this、apply、call、bind —— 掘金</a></li><li>:book: <a href="https://www.cnblogs.com/tingyu-blog/p/6212392.html" target="_blank" rel="noopener">使用 call、apply 和 bind 解决 js 中烦人的 this，事件绑定时的 this 和传参问题 —— 博客园</a></li><li>:book: <a href="https://github.com/Abiel1024/blog/issues/16" target="_blank" rel="noopener">call、apply 和 bind 的原生实现 —— github</a></li></ul><h3 id="视频-4"><a href="#视频-4" class="headerlink" title="视频"></a>视频</h3><ul><li>:tv: <a href="https://www.iqiyi.com/w_19rr1augsd.html" target="_blank" rel="noopener">JavaScript 关于 this 关键字解释 —— 爱奇艺</a></li><li>:tv: <a href="http://baidu.iqiyi.com/watch/845335533383874688.html?page=videoMultiNeed" target="_blank" rel="noopener">JS 关于作用域闭包和 this 的综合面试题 —— 百度视频</a></li><li>:tv: <a href="http://www.le.com/ptv/vplay/27478413.html?ch=baidu_s" target="_blank" rel="noopener">js 面向对象闭包数组 12.函数中的 this —— 乐视视频</a></li><li>:tv: <a href="http://www.le.com/ptv/vplay/24835911.html?ch=baidu_s" target="_blank" rel="noopener">1.3.10-this 指向及 this 应用 —— 乐视视频</a></li><li>:tv: <a href="https://study.163.com/course/introduction/590005.htm" target="_blank" rel="noopener">珠峰培训 JavaScript 开发课程：关于 this 关键字、闭包作用域 —— 网易云课堂</a></li></ul><p><strong><a href="#目录">:arrow_up: 返回目录</a></strong></p><hr><h2 id="7-函数作用域-块级作用域和词法作用域"><a href="#7-函数作用域-块级作用域和词法作用域" class="headerlink" title="7. 函数作用域, 块级作用域和词法作用域"></a>7. 函数作用域, 块级作用域和词法作用域</h2><h3 id="文章-6"><a href="#文章-6" class="headerlink" title="文章"></a>文章</h3><ul><li>:book: <a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014344993159773a464f34e1724700a6d5dd9e235ceb7c000" target="_blank" rel="noopener">变量作用域与解构赋值 —— 廖雪峰</a></li><li>:book: <a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="noopener">学习 Javascript 闭包（Closure） —— 阮一峰</a></li><li>:book: <a href="https://segmentfault.com/a/1190000006671020" target="_blank" rel="noopener">JavaScript 中词法作用域、闭包与跳出闭包 —— SegmentFault</a></li><li>:book: <a href="https://juejin.im/entry/58e70077b123db15eb88dc7e" target="_blank" rel="noopener">JavaScript 深入之词法作用域和动态作用域 —— 掘金</a></li><li>:book: <a href="https://juejin.im/post/5afb0ae56fb9a07aa2138425" target="_blank" rel="noopener">深入理解闭包之前置知识 → 作用域与词法作用域 —— 掘金</a></li><li>:book: <a href="https://stackoverflow.com/questions/1047454/what-is-lexical-scope" target="_blank" rel="noopener">What is lexical scope? —— stackoverflow</a></li><li>:book: <a href="https://github.com/fishenal/You-Dont-Know-JS/blob/master/scope%20&%20closures/ch2.md" target="_blank" rel="noopener">You Don’t Know JS: Scope &amp; Closures —— Kyle Simpson</a></li></ul><p><strong><a href="#目录">:arrow_up: 返回目录</a></strong></p><hr><h2 id="8-闭包"><a href="#8-闭包" class="headerlink" title="8. 闭包"></a>8. 闭包</h2><h3 id="文章-7"><a href="#文章-7" class="headerlink" title="文章"></a>文章</h3><ul><li>:book: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures" target="_blank" rel="noopener">闭包 —— MDN</a></li><li>:book: <a href="http://www.w3school.com.cn/js/pro_js_functions_closures.asp" target="_blank" rel="noopener">ECMAScript 闭包（closure）—— w3school</a></li><li>:book: <a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="noopener">学习 Javascript 闭包（Closure） —— 阮一峰</a></li><li>:book: <a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/00143449934543461c9d5dfeeb848f5b72bd012e1113d15000" target="_blank" rel="noopener">闭包 —— 廖雪峰</a></li><li>:book: <a href="https://www.jianshu.com/p/796e903754f1" target="_blank" rel="noopener">一次性搞懂 JavaScript 闭包 —— 简书</a></li><li>:book: <a href="https://segmentfault.com/a/1190000006875662" target="_blank" rel="noopener">JavaScript 闭包 —— SegmentFault</a></li><li>:book: <a href="https://juejin.im/entry/5800eb7da22b9d005b36156e" target="_blank" rel="noopener">js 匿名自执行函数中闭包的高级使用 —— 掘金</a></li><li>:book: <a href="https://juejin.im/entry/59df405251882551bf7e58c6" target="_blank" rel="noopener">高效使用 JavaScript 闭包 —— 掘金</a></li><li>:book: <a href="https://www.cnblogs.com/wangfupeng1988/p/3977924.html" target="_blank" rel="noopener">深入理解 JavaScript 原型与闭包 —— 王福朋</a></li></ul><h3 id="视频-5"><a href="#视频-5" class="headerlink" title="视频"></a>视频</h3><ul><li>:tv: <a href="http://www.iqiyi.com/w_19rr1amael.html" target="_blank" rel="noopener">JavaScript 闭包和闭包面试题 —— 爱奇艺</a></li><li>:tv: <a href="http://www.le.com/ptv/vplay/27478410.html" target="_blank" rel="noopener">js 面向对象闭包数组 11.闭包 —— 乐视</a></li><li>:tv: <a href="http://www.le.com/ptv/vplay/30505852.html" target="_blank" rel="noopener">白贺翔_函数(闭包) —— 乐视</a></li></ul><p><strong><a href="#目录">:arrow_up: 返回目录</a></strong></p><hr><h2 id="9-map-reduce-filter-等高阶函数"><a href="#9-map-reduce-filter-等高阶函数" class="headerlink" title="9. map, reduce, filter 等高阶函数"></a>9. map, reduce, filter 等高阶函数</h2><h3 id="文章-8"><a href="#文章-8" class="headerlink" title="文章"></a>文章</h3><ul><li>:book: <a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499355829ead974e550644e2ebd9fd8bb1b0dd721000" target="_blank" rel="noopener">高阶函数 —— 廖雪峰</a></li><li>:book: <a href="https://www.zhangxinxu.com/wordpress/2013/04/es5%e6%96%b0%e5%a2%9e%e6%95%b0%e7%bb%84%e6%96%b9%e6%b3%95/" target="_blank" rel="noopener">ES5 中新增的 Array 方法详细说明 —— 张鑫旭</a></li><li>:book: <a href="https://juejin.im/post/5835808067f3560065ed4ab2" target="_blank" rel="noopener">一张图看懂 JavaScript 中数组的迭代方法：forEach、map、filter、reduce、every、some —— 掘金</a></li><li>:book: <a href="https://segmentfault.com/a/1190000012127329" target="_blank" rel="noopener">Transducing（上）－《JavaScript 轻量级函数式编程》 —— SegmentFault</a></li><li>:book: <a href="https://github.com/BuptStEve/blog/issues/15" target="_blank" rel="noopener">JavaScript 函数式编程（三） —— @BuptStEve</a></li></ul><p><strong><a href="#目录">:arrow_up: 返回目录</a></strong></p><hr><h2 id="10-表达式和语句"><a href="#10-表达式和语句" class="headerlink" title="10. 表达式和语句"></a>10. 表达式和语句</h2><h3 id="文章-9"><a href="#文章-9" class="headerlink" title="文章"></a>文章</h3><ul><li>:book: <a href="https://www.cnblogs.com/xianshenglu/p/8386918.html" target="_blank" rel="noopener">js 表达式与语句 —— 博客园</a></li><li>:book: <a href="https://segmentfault.com/q/1010000004102804" target="_blank" rel="noopener">JS 表达式和语句的区别 —— SegmentFault</a></li><li>:book: <a href="https://blog.csdn.net/mett_smith/article/details/78761247" target="_blank" rel="noopener">JavaScript 中的表达式（expression）和语句/声明（statement） —— CSDN</a></li><li>:book: <a href="https://segmentfault.com/a/1190000004565693" target="_blank" rel="noopener">重讀 Axel 的 Javascript 中的 Expression vs Statement 一文 —— SegmentFault</a></li><li>:book: <a href="http://2ality.com/2012/09/expressions-vs-statements.html" target="_blank" rel="noopener">Expressions versus statements in JavaScript —— Dr. Axel</a></li></ul><p><strong><a href="#目录">:arrow_up: 返回目录</a></strong></p><hr><h2 id="11-变量提升"><a href="#11-变量提升" class="headerlink" title="11. 变量提升"></a>11. 变量提升</h2><h3 id="文章-10"><a href="#文章-10" class="headerlink" title="文章"></a>文章</h3><ul><li>:book: <a href="http://www.runoob.com/js/js-hoisting.html" target="_blank" rel="noopener">JavaScript 变量提升 —— 菜鸟教程</a></li><li>:book: <a href="https://juejin.im/post/59905bea6fb9a03c34192c51" target="_blank" rel="noopener">ES6 变量作用域与提升：变量的生命周期详解 —— 掘金</a></li><li>:book: <a href="https://segmentfault.com/a/1190000004345355#articleHeader5" target="_blank" rel="noopener">[翻译] JavaScript Scoping and Hoisting —— SegmentFault</a></li><li>:book: <a href="http://www.adequatelygood.com/JavaScript-Scoping-and-Hoisting.html" target="_blank" rel="noopener">JavaScript Scoping and Hoisting —— Ben Cherry</a></li></ul><p><strong><a href="#目录">:arrow_up: 返回目录</a></strong></p><hr><h2 id="12-Promise"><a href="#12-Promise" class="headerlink" title="12. Promise"></a>12. Promise</h2><h3 id="文章-11"><a href="#文章-11" class="headerlink" title="文章"></a>文章</h3><ul><li>:book: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises" target="_blank" rel="noopener">使用 promises —— MDN</a></li><li>:book: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promise —— MDN</a></li><li>:book: <a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014345008539155e93fc16046d4bb7854943814c4f9dc2000" target="_blank" rel="noopener">Promise — 廖雪峰</a></li><li>:book: <a href="https://www.cnblogs.com/rubylouvre/p/3495286.html" target="_blank" rel="noopener">JavaScript Promise：去而复返 —— 司徒正美</a></li><li>:book: <a href="https://developers.google.com/web/fundamentals/primers/promises#_1" target="_blank" rel="noopener">(上面的原文)JavaScript Promise：简介 —— Web Fundamentals</a></li><li>:book: <a href="https://segmentfault.com/a/1190000011813934" target="_blank" rel="noopener">1 分钟读完《10 分钟学会 JavaScript 的 Async/Await》 —— justjavac</a></li><li>:book: <a href="https://juejin.im/entry/56499ae160b2d1404c4f8834" target="_blank" rel="noopener">JavaScript Promise 迷你书（中文版）</a></li><li>:book: <a href="https://www.cnblogs.com/yunfeifei/p/4453690.html" target="_blank" rel="noopener">JavaScript 进阶之路——认识和使用 Promise，重构你的 Js 代码 —— 博客园</a></li></ul><h3 id="视频-6"><a href="#视频-6" class="headerlink" title="视频"></a>视频</h3><ul><li>:tv: <a href="https://www.imooc.com/learn/949" target="_blank" rel="noopener">Promise 入门 —— 慕课网</a></li></ul><p><strong><a href="#目录">:arrow_up: 返回目录</a></strong></p><hr><h2 id="13-立即执行函数-模块化-命名空间"><a href="#13-立即执行函数-模块化-命名空间" class="headerlink" title="13. 立即执行函数, 模块化, 命名空间"></a>13. 立即执行函数, 模块化, 命名空间</h2><h3 id="文章-12"><a href="#文章-12" class="headerlink" title="文章"></a>文章</h3><ul><li>:book: <a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank" rel="noopener">Javascript 模块化编程（一）：模块的写法 —— 阮一峰</a></li><li>:book: <a href="https://www.jianshu.com/p/4dbf4a4c8ebb" target="_blank" rel="noopener">javascript 模块化编程-详解立即执行函数表达式 —— 简书</a></li><li>:book: <a href="https://juejin.im/entry/57fee360a22b9d005b1d9ae3" target="_blank" rel="noopener">Javascript 的匿名函数与自执行 —— 掘金</a></li><li>:book: <a href="https://segmentfault.com/a/1190000006966358" target="_blank" rel="noopener">前端模块化——技术选型 —— SegmentFault</a></li><li>:book: <a href="https://segmentfault.com/a/1190000015991869#articleHeader8" target="_blank" rel="noopener">谈谈 Js 前端模块化规范 —— SegmentFault</a></li><li>:book: <a href="http://web.jobbole.com/87534/" target="_blank" rel="noopener">函数声明与函数表达式的区别 —— 伯乐在线</a></li></ul><p><strong><a href="#目录">:arrow_up: 返回目录</a></strong></p><hr><h2 id="14-递归"><a href="#14-递归" class="headerlink" title="14. 递归"></a>14. 递归</h2><h3 id="文章-13"><a href="#文章-13" class="headerlink" title="文章"></a>文章</h3><ul><li>:book: <a href="https://segmentfault.com/q/1010000003942347" target="_blank" rel="noopener">求解释 js 递归 —— SegmentFault</a></li><li>:book: <a href="https://juejin.im/post/5948c0d8fe88c2006a939e2a" target="_blank" rel="noopener">JavaScript 中的递归 —— 掘金</a></li><li>:book: <a href="https://juejin.im/post/59c1d91d6fb9a00a53275f79" target="_blank" rel="noopener">递归（上）－《JavaScript 轻量级函数式编程》 —— 掘金</a></li><li>:book: <a href="https://juejin.im/post/59c87fb46fb9a00a437b1a2e" target="_blank" rel="noopener">递归（下）－《JavaScript 轻量级函数式编程》 —— 掘金</a></li><li>:book: <a href="https://juejin.im/post/5acdd7486fb9a028ca53547c" target="_blank" rel="noopener">尾调用和尾递归 —— 掘金</a></li><li>:book: <a href="https://blog.csdn.net/qianqianstd/article/details/75807462" target="_blank" rel="noopener">几个经典递归问题用 js 实现 —— CSDN</a></li><li>:book: <a href="https://blog.csdn.net/x_i_xw/article/details/72026868" target="_blank" rel="noopener">递归函数的几个例子 —— CSDN</a></li></ul><p><strong><a href="#目录">:arrow_up: 返回目录</a></strong></p><hr><h2 id="15-算法"><a href="#15-算法" class="headerlink" title="15. 算法"></a>15. 算法</h2><h3 id="文章-14"><a href="#文章-14" class="headerlink" title="文章"></a>文章</h3><ul><li>:book: <a href="https://juejin.im/post/57dcd394a22b9d00610c5ec8" target="_blank" rel="noopener">十大经典排序算法总结（JavaScript 描述） —— 掘金</a></li><li>:book: <a href="https://juejin.im/post/594dfe795188250d725a220a#comment" target="_blank" rel="noopener">在 JavaScript 中学习数据结构与算法 —— 掘金</a></li><li>:book: <a href="https://juejin.im/post/58c9d5fb1b69e6006b686bce" target="_blank" rel="noopener">JS 中可能用得到的全部的排序算法 —— 掘金</a></li><li>:book: <a href="https://www.jianshu.com/p/1b4068ccd505" target="_blank" rel="noopener">JS 家的排序算法 —— 简书</a></li><li>:book: <a href="https://segmentfault.com/a/1190000008593715" target="_blank" rel="noopener">前端常见算法的 JS 实现 —— SegmentFault</a></li><li>:book: <a href="https://www.jackpu.com/qian-duan-mian-shi-zhong-de-chang-jian-de-suan-fa-wen-ti/" target="_blank" rel="noopener">前端面试中的常见的算法问题 ——蒲小花的博客</a></li></ul><h3 id="视频-7"><a href="#视频-7" class="headerlink" title="视频"></a>视频</h3><ul><li>:tv: <a href="https://www.imooc.com/learn/888" target="_blank" rel="noopener">Javascript 实现二叉树算法 —— 慕课网</a></li></ul><p><strong><a href="#目录">:arrow_up: 返回目录</a></strong></p><hr><h2 id="16-数据结构"><a href="#16-数据结构" class="headerlink" title="16. 数据结构"></a>16. 数据结构</h2><h3 id="文章-15"><a href="#文章-15" class="headerlink" title="文章"></a>文章</h3><ul><li>:book: <a href="https://www.jianshu.com/p/5e0e8d183102" target="_blank" rel="noopener">来我们浅谈一下 js 的数据结构 —— 简书</a></li><li>:book: <a href="https://www.jianshu.com/nb/16835496" target="_blank" rel="noopener">JavaScript 中的算法与数据结构 —— 简书</a></li><li>:book: <a href="http://blog.sina.com.cn/s/blog_7b9c5e4101017mjt.html" target="_blank" rel="noopener">学 JS 必看-JavaScript 数据结构深度剖析 —— 大道至简的博客</a></li><li>:book: <a href="https://juejin.im/entry/586effe0da2f600053d85a9a" target="_blank" rel="noopener">js 中基础数据结构数组去重问题 —— 掘金</a></li></ul><h3 id="视频-8"><a href="#视频-8" class="headerlink" title="视频"></a>视频</h3><ul><li>:tv: :tv: <a href="http://www.le.com/ptv/vplay/27606964.html" target="_blank" rel="noopener">JavaScript 数据结构-运算符 —— 乐视</a></li></ul><p><strong><a href="#目录">:arrow_up: 返回目录</a></strong></p><hr><h2 id="17-消息队列和事件循环"><a href="#17-消息队列和事件循环" class="headerlink" title="17. 消息队列和事件循环"></a>17. 消息队列和事件循环</h2><h3 id="文章-16"><a href="#文章-16" class="headerlink" title="文章"></a>文章</h3><ul><li>:book: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop" target="_blank" rel="noopener">并发模型与事件循环 —— MDN</a></li><li>:book: <a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈 Event Loop —— 阮一峰</a></li><li>:book: <a href="https://www.cnblogs.com/dong-xu/p/7000163.html" target="_blank" rel="noopener">深入理解 JavaScript 事件循环 —— 博客园</a></li><li>:book: <a href="https://zhuanlan.zhihu.com/p/26229293" target="_blank" rel="noopener">深入浅出 Javascript 事件循环机制 —— 知乎</a></li><li>:book: <a href="https://segmentfault.com/a/1190000014940904#articleHeader7" target="_blank" rel="noopener">JS 事件循环机制（event loop）之宏任务、微任务 —— SegmentFault</a></li><li>:book: <a href="https://segmentfault.com/a/1190000004322358" target="_blank" rel="noopener">JavaScript：彻底理解同步、异步和事件循环 —— SegmentFault</a></li><li>:book: <a href="https://juejin.im/post/5a6547d0f265da3e283a1df7" target="_blank" rel="noopener">从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理 —— 掘金</a></li></ul><p><strong><a href="#目录">:arrow_up: 返回目录</a></strong></p><hr><h2 id="18-setTimeout-setInterval-和-requestAnimationFrame"><a href="#18-setTimeout-setInterval-和-requestAnimationFrame" class="headerlink" title="18. setTimeout, setInterval 和 requestAnimationFrame"></a>18. setTimeout, setInterval 和 requestAnimationFrame</h2><h3 id="文章-17"><a href="#文章-17" class="headerlink" title="文章"></a>文章</h3><ul><li>:book: <a href="http://www.runoob.com/jsref/met-win-settimeout.html" target="_blank" rel="noopener">Window setTimeout() 方法 —— 菜鸟教程</a></li><li>:book: <a href="http://www.runoob.com/jsref/met-win-setinterval.html" target="_blank" rel="noopener">Window setInterval() 方法 —— 菜鸟教程</a></li><li>:book: <a href="https://juejin.im/post/5aa4c47af265da239866e236" target="_blank" rel="noopener">关于 setTimeout —— 掘金</a></li><li>:book: <a href="https://juejin.im/post/5a77f8ce5188257a6d635d76" target="_blank" rel="noopener">你不知道的 Javascript：有趣的 setTimeout —— 掘金</a></li><li>:book: <a href="https://juejin.im/entry/5861ebf01b69e6006ce61d38" target="_blank" rel="noopener">原来你是这样的 setTimeout —— 掘金</a></li><li>:book: <a href="https://segmentfault.com/q/1010000005989491" target="_blank" rel="noopener">setTimeout() 和 setInterval() 本质区别在哪里？ —— SegmentFault</a></li><li>book: <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="noopener">window.requestAnimationFrame —— MDN</a></li><li>:book: <a href="http://www.cnblogs.com/onepixel/p/7078617.html" target="_blank" rel="noopener">requestAnimationFrame 知多少？ —— 博客园</a></li><li>:book: <a href="https://www.zhangxinxu.com/wordpress/2013/09/css3-animation-requestanimationframe-tween-%e5%8a%a8%e7%94%bb%e7%ae%97%e6%b3%95/" target="_blank" rel="noopener">CSS3 动画那么强，requestAnimationFrame 还有毛线用？ —— 张鑫旭</a></li><li>:book: <a href="https://segmentfault.com/a/1190000014661035" target="_blank" rel="noopener">「JavaScript 定时器」setInterval、setTimeout 和 requestAnimationFrame 浅析 —— SegmentFault</a></li><li>:book: <a href="https://segmentfault.com/a/1190000000386368" target="_blank" rel="noopener">翻译：setInterval 与 requestAnimationFrame 的时间间隔测试 —— SegmentFault</a></li><li>:book: <a href="https://segmentfault.com/q/1010000013909430" target="_blank" rel="noopener">阿里前端面试题：requestAnimationFrame 实现类似 setInterval 的计时器 —— SegmentFault</a></li></ul><h3 id="视频-9"><a href="#视频-9" class="headerlink" title="视频"></a>视频</h3><ul><li>:tv: <a href="http://v.youku.com/v_show/id_XNTA4OTQ0NzA0.html" target="_blank" rel="noopener">setTimeout 和 setInterval —— 优酷</a></li></ul><p><strong><a href="#目录">:arrow_up: 返回目录</a></strong></p><hr><h2 id="19-继承-多态和代码复用"><a href="#19-继承-多态和代码复用" class="headerlink" title="19. 继承, 多态和代码复用"></a>19. 继承, 多态和代码复用</h2><h3 id="文章-18"><a href="#文章-18" class="headerlink" title="文章"></a>文章</h3><ul><li>:book: <a href="https://www.cnblogs.com/Leo_wl/p/5734794.html" target="_blank" rel="noopener">JS 面向对象编程之：封装、继承、多态 —— 博客园</a></li><li>:book: <a href="https://www.jianshu.com/p/5cb692658704" target="_blank" rel="noopener">Javascript 的继承与多态 —— 简书</a></li><li>:book: <a href="https://juejin.im/post/59396c96fe88c2006afc2707" target="_blank" rel="noopener">js:面向对象编程，带你认识封装、继承和多态 —— 掘金</a></li><li>:book: <a href="https://zhuanlan.zhihu.com/p/34693209" target="_blank" rel="noopener">JavaScript 中的“多继承” —— 掘金</a></li><li>:book: <a href="https://github.com/TooBug/javascript.patterns/blob/master/chapter6.markdown" target="_blank" rel="noopener">代码复用模式 —— github</a></li><li>:book: <a href="http://www.cnblogs.com/TomXu/archive/2012/04/24/2438050.html" target="_blank" rel="noopener">深入理解 JavaScript：代码复用模式(推荐篇) —— 汤姆大叔</a></li><li>:book: <a href="https://www.cnblogs.com/TomXu/archive/2012/04/23/2438005.html" target="_blank" rel="noopener">深入理解 JavaScript：代码复用模式(避免篇) —— 汤姆大叔</a></li></ul><p><strong><a href="#目录">:arrow_up: 返回目录</a></strong></p><hr><h2 id="20-按位操作符-类数组对象和类型化数组"><a href="#20-按位操作符-类数组对象和类型化数组" class="headerlink" title="20. 按位操作符, 类数组对象和类型化数组"></a>20. 按位操作符, 类数组对象和类型化数组</h2><h3 id="文章-19"><a href="#文章-19" class="headerlink" title="文章"></a>文章</h3><ul><li>:book: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators" target="_blank" rel="noopener">按位操作符 —— MDN</a></li><li>:book: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Typed_arrays" target="_blank" rel="noopener">类数组对象 —— MDN</a></li><li>:book: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank" rel="noopener">类型化数组 —— MDN</a></li><li>:book: <a href="https://www.cnblogs.com/gradolabs/p/4762134.html" target="_blank" rel="noopener">JavaScript ArrayBuffer 浅析 —— 博客园</a></li></ul><p><strong><a href="#目录">:arrow_up: 返回目录</a></strong></p><hr><h2 id="21-DOM-树和渲染过程"><a href="#21-DOM-树和渲染过程" class="headerlink" title="21. DOM 树和渲染过程"></a>21. DOM 树和渲染过程</h2><h3 id="文章-20"><a href="#文章-20" class="headerlink" title="文章"></a>文章</h3><ul><li>:book: <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/How_to_create_a_DOM_tree" target="_blank" rel="noopener">如何创建一个 DOM 树 —— MDN</a></li><li>:book: <a href="http://www.w3school.com.cn/htmldom/dom_nodes.asp" target="_blank" rel="noopener">HTML DOM 节点 —— W3school</a></li><li>:book: <a href="http://javascript.ruanyifeng.com/dom/node.html" target="_blank" rel="noopener">DOM 概述 —— 阮一峰</a></li><li>:book: <a href="https://juejin.im/post/583cbbfa61ff4b006ccc41fe" target="_blank" rel="noopener">《JavaScript 闯关记》之 DOM（上）—— 掘金</a></li><li>:book: <a href="https://juejin.im/post/583cbc4961ff4b006ccc44fb" target="_blank" rel="noopener">《JavaScript 闯关记》之 DOM（下）—— 掘金</a></li><li>:book: <a href="https://juejin.im/entry/58314efd8ac2470061bb30fd" target="_blank" rel="noopener">掌握 DOM 操作 —— 掘金</a></li><li>:book: <a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434500494451273e6b3dec9d411d9ba841dee8caec45000" target="_blank" rel="noopener">操作 DOM —— 廖雪峰</a></li><li>:book: <a href="https://juejin.im/post/59c60691518825396f4f71a1" target="_blank" rel="noopener">原来 CSS 与 JS 是这样阻塞 DOM 解析和渲染的 —— 掘金</a></li></ul><h3 id="视频-10"><a href="#视频-10" class="headerlink" title="视频"></a>视频</h3><ul><li>:tv: <a href="https://www.imooc.com/learn/488" target="_blank" rel="noopener">DOM 探索之基础详解篇 —— 慕课网</a></li><li>:tv: <a href="https://www.imooc.com/learn/138" target="_blank" rel="noopener">DOM 事件探秘 —— 慕课网</a></li><li>:tv: <a href="https://www.imooc.com/learn/530" target="_blank" rel="noopener">jQuery 基础(二)DOM 篇 —— 慕课网</a></li><li>:tv: <a href="http://www.iqiyi.com/w_19rr19s08l.html" target="_blank" rel="noopener">JS 操作 DOM 对象属性和方法 —— 爱奇艺</a></li></ul><p><strong><a href="#目录">:arrow_up: 返回目录</a></strong></p><hr><h2 id="22-new-与构造函数-instanceof-与实例"><a href="#22-new-与构造函数-instanceof-与实例" class="headerlink" title="22. new 与构造函数, instanceof 与实例"></a>22. new 与构造函数, instanceof 与实例</h2><h3 id="文章-21"><a href="#文章-21" class="headerlink" title="文章"></a>文章</h3><ul><li>:book: <a href="http://javascript.ruanyifeng.com/oop/basic.html" target="_blank" rel="noopener">构造函数与 new 命令 —— 阮一峰</a></li><li>:book: <a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="noopener">Javascript 面向对象编程（二）：构造函数的继承 —— 阮一峰</a></li><li>:book: <a href="https://blog.csdn.net/SpicyBoiledFish/article/details/71123162" target="_blank" rel="noopener">完整原型链详细图解(构造函数、原型、实例化对象) —— CSDN</a></li><li>:book: <a href="http://www.php.cn/js-tutorial-376246.html" target="_blank" rel="noopener">JavaScript 中构造函数与 new 操作符的实例详解 —— PHP 中文网</a></li><li>:book: <a href="https://blog.csdn.net/yin_991/article/details/80954453" target="_blank" rel="noopener">构造函数、实例、原型、原型链之间的关系 —— CSDN</a></li><li>:book: <a href="https://blog.csdn.net/cecilia620/article/details/71158048" target="_blank" rel="noopener">深入理解 JS—instanceof 和原型链 —— CSDN</a></li><li>:book: <a href="https://www.jianshu.com/p/15ac7393bc1f" target="_blank" rel="noopener">前端基础进阶（九）：详解面向对象、构造函数、原型与原型链 —— 简书</a></li><li>:book: <a href="https://www.jianshu.com/p/60ffc4831bff" target="_blank" rel="noopener">js 用 new 实例化对象与直接调用的 this 的区别 —— 简书</a></li><li>:book: <a href="http://justjavac.com/javascript/2012/12/22/javascript-values-not-everything-is-an-object.html" target="_blank" rel="noopener">JavaScript 并非所有的东西都是对象 —— justjavac</a></li><li>:book: <a href="https://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/" target="_blank" rel="noopener">JavaScript instanceof 运算符深入剖析 —— IBM</a></li></ul><h3 id="视频-11"><a href="#视频-11" class="headerlink" title="视频"></a>视频</h3><ul><li>:tv: <a href="http://www.le.com/ptv/vplay/27766889.html" target="_blank" rel="noopener">改良版的构造函数 —— 乐视</a></li></ul><p><strong><a href="#目录">:arrow_up: 返回目录</a></strong></p><hr><h2 id="23-原型继承与原型链"><a href="#23-原型继承与原型链" class="headerlink" title="23. 原型继承与原型链"></a>23. 原型继承与原型链</h2><h3 id="文章-22"><a href="#文章-22" class="headerlink" title="文章"></a>文章</h3><ul><li>:book: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">继承与原型链 —— MDN</a></li><li>:book: <a href="https://github.com/bigdots/blog/issues/1" target="_blank" rel="noopener">构造函数、原型与原型链 —— github</a></li><li>:book: <a href="https://github.com/stone0090/javascript-lessons/tree/master/2.5-Prototype" target="_blank" rel="noopener">原型及原型链 —— github(1269 Star)</a></li><li>:book: <a href="https://segmentfault.com/a/1190000004282206" target="_blank" rel="noopener">理清 javascript 中的面向对象(一) 原型继承 —— SegmentFault</a></li><li>:book: <a href="http://justjavac.com/2015/12/09/inheritance-and-the-prototype-chain.html" target="_blank" rel="noopener">JavaScript：继承和原型链(译) —— justjavac</a></li><li>:book: <a href="http://www.cnblogs.com/shuiyi/p/5305435.html" target="_blank" rel="noopener">三张图搞懂 JavaScript 的原型对象与原型链 —— 博客园</a></li><li>:book: <a href="https://blog.csdn.net/the__apollo/article/details/76774698" target="_blank" rel="noopener">一张图让你搞懂 JavaScript 的继承与原型链 —— CSDN</a></li><li>:book: <a href="https://blog.csdn.net/xiaotao_css/article/details/72782416" target="_blank" rel="noopener">JS 高级–原型链(一看就懂，但 18 岁以下请绕道) —— CSDN</a></li><li>:book: <a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014344997013405abfb7f0e1904a04ba6898a384b1e925000" target="_blank" rel="noopener">原型继承 —— 廖雪峰</a></li><li>:book: <a href="https://juejin.im/post/58f94c9bb123db411953691b" target="_blank" rel="noopener">JS 原型链与继承别再被问倒了 —— 掘金</a></li><li>:book: <a href="https://juejin.im/entry/5885db221b69e600592253e7" target="_blank" rel="noopener">征服 JavaScript 面试系列：类继承和原型继承的区别 —— 掘金</a></li><li>:book: <a href="https://github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="noopener">JavaScript 深入之从原型到原型链 —— 冴羽</a></li><li>:book: <a href="https://www.cnblogs.com/wangfupeng1988/p/3977924.html" target="_blank" rel="noopener">深入理解 JavaScript 原型与闭包 —— 王福朋</a></li></ul><h3 id="视频-12"><a href="#视频-12" class="headerlink" title="视频"></a>视频</h3><ul><li>:tv: <a href="http://www.le.com/ptv/vplay/27552753.html" target="_blank" rel="noopener">JS 高级-07-原型链继承 —— 乐视</a></li><li>:tv: <a href="https://v.qq.com/x/page/b0511nwa7d3.html" target="_blank" rel="noopener">JS 原型对象和原型链简介 —— 腾讯视频</a></li></ul><p><strong><a href="#目录">:arrow_up: 返回目录</a></strong></p><hr><h2 id="24-Object-create-和-Object-assign"><a href="#24-Object-create-和-Object-assign" class="headerlink" title="24. Object.create 和 Object.assign"></a>24. Object.create 和 Object.assign</h2><h3 id="文章-23"><a href="#文章-23" class="headerlink" title="文章"></a>文章</h3><ul><li>:book: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener">Object.create —— MDN</a></li><li>:book: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="noopener">Object.assign —— MDN</a></li><li>:book: <a href="https://www.imooc.com/article/17591" target="_blank" rel="noopener">Object.create vs Object.assign —— 慕课网手记</a></li><li>:book: <a href="https://blog.csdn.net/DeepLies/article/details/52915143" target="_blank" rel="noopener">JS 中的 Object.assign()、Object.create()、Object.defineProperty() —— CSDN</a></li><li>:book: <a href="http://www.onlyfordream.cn/2018/03/19/es6%E4%B8%ADobject-create%E5%92%8Cobject-assign/" target="_blank" rel="noopener">es6 中 object.create()和 object.assign() —— 风信子博客</a></li><li>:book: <a href="https://github.com/saikojosh/Object-Assign-Deep" target="_blank" rel="noopener">Object-Assign-Deep —— github</a></li></ul><p><strong><a href="#目录">:arrow_up: 返回目录</a></strong></p><hr><h2 id="25-工厂函数和类"><a href="#25-工厂函数和类" class="headerlink" title="25. 工厂函数和类"></a>25. 工厂函数和类</h2><h3 id="文章-24"><a href="#文章-24" class="headerlink" title="文章"></a>文章</h3><ul><li>:book: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">类 —— MDN</a></li><li>:book: <a href="https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/00138682004077376d2d7f8cc8a4e2c9982f92788588322000" target="_blank" rel="noopener">类和实例 —— 廖雪峰</a></li><li>:book: <a href="http://www.ruanyifeng.com/blog/2012/07/three_ways_to_define_a_javascript_class.html" target="_blank" rel="noopener">Javascript 定义类（class）的三种方法 —— 阮一峰</a></li><li>:book: <a href="https://juejin.im/post/59c8c8756fb9a00a681ae5bd" target="_blank" rel="noopener">【译】ES6 的工厂函数 —— 掘金</a></li><li>:book: <a href="https://juejin.im/entry/587992c961ff4b0065edf1ff" target="_blank" rel="noopener">JavaScript 创建对象之单例、工厂、构造函数模式 —— 掘金</a></li></ul><p><strong><a href="#目录">:arrow_up: 返回目录</a></strong></p><hr><h2 id="26-设计模式"><a href="#26-设计模式" class="headerlink" title="26. 设计模式"></a>26. 设计模式</h2><h3 id="文章-25"><a href="#文章-25" class="headerlink" title="文章"></a>文章</h3><ul><li>:book: <a href="https://juejin.im/post/59df4f74f265da430f311909" target="_blank" rel="noopener">JavaScript 设计模式 —— 掘金</a></li><li>:book: <a href="http://wiki.jikexueyuan.com/project/javascript-design-patterns/" target="_blank" rel="noopener">学用 JavaScript 设计模式 —— 极客学院</a></li><li>:book: <a href="https://segmentfault.com/a/1190000010914032" target="_blank" rel="noopener">[面试专题]JS 设计模式 —— SegmentFault</a></li><li>:book: <a href="https://github.com/lxj/javascript.patterns" target="_blank" rel="noopener">JavaScript Patterns 中译本 —— github</a></li></ul><h3 id="视频-13"><a href="#视频-13" class="headerlink" title="视频"></a>视频</h3><ul><li>:tv: <a href="https://tv.sohu.com/v/dXMvMjQwNzYwNzQ4Lzg5NzM2MDA3LnNodG1s.html" target="_blank" rel="noopener">HTML5 课程大纲 2-11JS 设计模式</a></li></ul><p><strong><a href="#目录">:arrow_up: 返回目录</a></strong></p><hr><h2 id="27-Memoization"><a href="#27-Memoization" class="headerlink" title="27. Memoization"></a>27. Memoization</h2><h3 id="文章-26"><a href="#文章-26" class="headerlink" title="文章"></a>文章</h3><ul><li>:book: <a href="https://www.cnblogs.com/rubylouvre/archive/2009/08/06/1540678.html" target="_blank" rel="noopener">JavaScript Memoization —— 司徒正美</a></li><li>:book: <a href="https://www.cnblogs.com/yingshuizy/p/4517102.html" target="_blank" rel="noopener">memoization 提升递归效率 —— 博客园</a></li><li>:book: <a href="http://developer.51cto.com/art/201010/231513.htm" target="_blank" rel="noopener">如何提升 JavaScript 的递归效率 —— 51CTO</a></li><li>:book: <a href="https://segmentfault.com/a/1190000016703106" target="_blank" rel="noopener">JavaScript 高级技巧 Memoization —— SegmentFaut</a></li></ul><p><strong><a href="#目录">:arrow_up: 返回目录</a></strong></p><hr><h2 id="28-纯函数-函数副作用和状态变化"><a href="#28-纯函数-函数副作用和状态变化" class="headerlink" title="28. 纯函数, 函数副作用和状态变化"></a>28. 纯函数, 函数副作用和状态变化</h2><h3 id="文章-27"><a href="#文章-27" class="headerlink" title="文章"></a>文章</h3><ul><li>:book: <a href="http://huziketang.mangojuice.top/books/react/lesson32" target="_blank" rel="noopener">纯函数(Pure Function) —— React.js 小书</a></li><li>:book: <a href="https://ninghao.net/blog/4634" target="_blank" rel="noopener">JavaScript Functional Programming：纯函数 —— 宁皓网</a></li><li>:book: <a href="https://www.jb51.net/article/28079.htm" target="_blank" rel="noopener">js 函数的副作用分析 —— 脚本之家</a></li><li>:book: <a href="https://juejin.im/post/5b82bdb351882542e241ed32?utm_medium=hao.caibaojian.com&utm_source=hao.caibaojian.com" target="_blank" rel="noopener">如何使用纯函数式 JavaScript 处理脏副作用 —— 掘金</a></li><li>:book: <a href="http://www.cnblogs.com/zhangycun/p/9403335.html" target="_blank" rel="noopener">原生 JavaScript 实现 state 状态管理系统 —— 博客园</a></li><li>:book: <a href="https://github.com/BuptStEve/blog/issues/10" target="_blank" rel="noopener">JavaScript 函数式编程 —— @BuptStEve</a></li></ul><p><strong><a href="#目录">:arrow_up: 返回目录</a></strong></p><hr><h2 id="29-耗性能操作和时间复杂度"><a href="#29-耗性能操作和时间复杂度" class="headerlink" title="29. 耗性能操作和时间复杂度"></a>29. 耗性能操作和时间复杂度</h2><h3 id="文章-28"><a href="#文章-28" class="headerlink" title="文章"></a>文章</h3><ul><li>:book: <a href="https://juejin.im/entry/593f56528d6d810058a355f4" target="_blank" rel="noopener">时间复杂度 O(log n) 意味着什么？ —— 掘金</a></li><li>:book: <a href="https://juejin.im/entry/5a49f7d36fb9a0450a67b269" target="_blank" rel="noopener">算法的时间复杂度和空间复杂度 —— 掘金</a></li><li>:book: <a href="https://juejin.im/post/58d15f1044d90400691834d4" target="_blank" rel="noopener">算法（一）时间复杂度 —— 掘金</a></li><li>:book: <a href="http://www.bradoncode.com/blog/2012/04/big-o-algorithm-examples-in-javascript.html" target="_blank" rel="noopener">Big O Search Algorithms in JavaScript —— Bradley Braithwaite</a></li><li>:book: <a href="https://www.jenniferbland.com/time-complexity-analysis-in-javascript/" target="_blank" rel="noopener">Time Complexity Analysis in JavaScript — Jennifer Bland</a></li></ul><p><strong><a href="#目录">:arrow_up: 返回目录</a></strong></p><hr><h2 id="30-JavaScript-引擎"><a href="#30-JavaScript-引擎" class="headerlink" title="30. JavaScript 引擎"></a>30. JavaScript 引擎</h2><h3 id="文章-29"><a href="#文章-29" class="headerlink" title="文章"></a>文章</h3><ul><li>:book: <a href="https://baike.baidu.com/item/javascript引擎/5356108" target="_blank" rel="noopener">javascript 引擎 —— 百度百科</a></li><li>:book: <a href="https://baike.baidu.com/item/V8/6178125" target="_blank" rel="noopener">V8(JavaScript 引擎) —— 百度百科</a></li><li>:book: <a href="https://juejin.im/post/5a6309f76fb9a01cab2858b1" target="_blank" rel="noopener">图解搞懂 JavaScript 引擎 Event Loop —— 掘金</a>3</li><li>:book: <a href="https://segmentfault.com/a/1190000010819020" target="_blank" rel="noopener">V8 JavaScript 引擎：高性能的 ES2015+ —— justjavac</a></li><li>:book: <a href="https://segmentfault.com/a/1190000012806637" target="_blank" rel="noopener">10 分钟理解 JS 引擎的执行机制 —— SegmentFaut</a></li><li>:book: <a href="https://www.cnblogs.com/weirdoQi/p/6609811.html" target="_blank" rel="noopener">V8 javascript 引擎 —— 博客园</a></li></ul><p><strong><a href="#目录">:arrow_up: 返回目录</a></strong></p><hr><h2 id="31-二进制-十六进制-十进制-科学记数法"><a href="#31-二进制-十六进制-十进制-科学记数法" class="headerlink" title="31. 二进制, 十六进制, 十进制, 科学记数法"></a>31. 二进制, 十六进制, 十进制, 科学记数法</h2><h3 id="文章-30"><a href="#文章-30" class="headerlink" title="文章"></a>文章</h3><ul><li>:book: <a href="http://www.cnblogs.com/gaizai/p/4233780.html" target="_blank" rel="noopener">二、八、十、十六进制转换(图解篇) —— 博客园</a></li><li>:book: <a href="https://juejin.im/post/5b93dadaf265da0a857a58a3" target="_blank" rel="noopener">JavaScript 读写二进制数据 —— 掘金</a></li></ul><h3 id="视频-14"><a href="#视频-14" class="headerlink" title="视频"></a>视频</h3><ul><li>:tv: <a href="http://baishi.baidu.com/watch/7873060963471478456.html" target="_blank" rel="noopener">二进制、十进制、十六进制互相转化很难吗？ —— 百度视频</a></li></ul><p><strong><a href="#目录">:arrow_up: 返回目录</a></strong></p><hr><h2 id="32-偏函数-柯里化-Compose-和-Pipe"><a href="#32-偏函数-柯里化-Compose-和-Pipe" class="headerlink" title="32. 偏函数, 柯里化, Compose 和 Pipe"></a>32. 偏函数, 柯里化, Compose 和 Pipe</h2><h3 id="文章-31"><a href="#文章-31" class="headerlink" title="文章"></a>文章</h3><ul><li>:book: <a href="https://blog.csdn.net/qq_42129063/article/details/81874314" target="_blank" rel="noopener">Javascript 函数式编程之偏函数 —— CSDN</a></li><li>:book: <a href="https://segmentfault.com/a/1190000010686144" target="_blank" rel="noopener">JavaScript 专题之偏函数 —— SegmentFault</a></li><li>:book: <a href="https://segmentfault.com/q/1010000008626058" target="_blank" rel="noopener">柯里化和偏函数有什么区别？ —— SegmentFault</a></li><li>:book: <a href="https://blog.csdn.net/neweastsun/article/details/75947785" target="_blank" rel="noopener">Javascript 偏函数与柯里化 —— CSDN</a></li><li>:book: <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch4.html" target="_blank" rel="noopener">柯里化(curry) —— JS 函数式编程指南</a></li><li>:book: <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch5.html" target="_blank" rel="noopener">代码组合(compose) —— JS 函数式编程指南</a></li><li>:book: <a href="https://segmentfault.com/a/1190000008394749" target="_blank" rel="noopener">关于 javascript 函数式编程中 compose 的实现 —— SegmentFault</a></li><li>:book: <a href="https://segmentfault.com/a/1190000011447164" target="_blank" rel="noopener">实现 compose 的五种思路 —— SegmentFault</a></li><li>:book: <a href="https://segmentfault.com/a/1190000015102804" target="_blank" rel="noopener">JavaScript 函数式编程之函数组合函数 compose 和 pipe 的实现 —— SegmentFault</a></li><li>:book: <a href="https://juejin.im/post/59a62f3d6fb9a0248363fd9d#comment" target="_blank" rel="noopener">JavaScript 轻量级函数式编程-第 4 章:组合函数 ——掘金</a></li><li>:book: <a href="https://github.com/BuptStEve/blog/issues/11" target="_blank" rel="noopener">JavaScript 函数式编程（二） —— @BuptStEve</a></li></ul><p><strong><a href="#目录">:arrow_up: 返回目录</a></strong></p><hr><h2 id="33-代码整洁之道"><a href="#33-代码整洁之道" class="headerlink" title="33. 代码整洁之道"></a>33. 代码整洁之道</h2><h3 id="文章-32"><a href="#文章-32" class="headerlink" title="文章"></a>文章</h3><ul><li>:book: <a href="https://www.zcfy.cc/article/clean-code-javascript-readme-md-at-master-ryanmcdermott-clean-code-javascript-github-2273.html" target="_blank" rel="noopener">[译] JavaScript 代码整洁之道 —— 边城</a></li><li>:book: <a href="http://www.ruanyifeng.com/blog/2012/04/javascript_programming_style.html" target="_blank" rel="noopener">Javascript 编程风格 —— 阮一峰</a></li><li>:book: <a href="https://juejin.im/post/5a5b2a5c6fb9a01cbc6e59f9" target="_blank" rel="noopener">重构 - 代码整洁之道 —— 掘金</a></li><li>:book: <a href="https://juejin.im/post/5a7d71836fb9a063435ecf51" target="_blank" rel="noopener">让你的代码更简短，更整洁，更易读的 ES6 小技巧 —— 掘金</a></li><li>:book: <a href="http://blog.jobbole.com/23617/" target="_blank" rel="noopener">Web 前端：11 个让你代码整洁的原则 —— 伯乐在线</a></li><li>:book: <a href="https://github.com/ryanmcdermott/clean-code-javascript" target="_blank" rel="noopener">Clean Code concepts adapted for JavaScript —— ryanmcdermott</a></li></ul><br><p><strong><a href="#目录">:arrow_up: 返回目录</a></strong></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 align=&quot;center&quot;&gt;
&lt;br&gt;
  &lt;a href=&quot;https://github.com/stephentian/33-js-concepts&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;/img/loading.gif
      
    
    </summary>
    
      <category term="前端文章" scheme="https://qw66.gitee.io/categories/%E5%89%8D%E7%AB%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="JavaScript" scheme="https://qw66.gitee.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
